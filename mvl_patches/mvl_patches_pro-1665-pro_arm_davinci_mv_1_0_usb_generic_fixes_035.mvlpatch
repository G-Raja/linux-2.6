#! /usr/bin/env bash
# Patch: -pro_arm_davinci_mv_1_0_usb_generic_fixes_035
# Date: Mon Jan 21 23:04:52 2008
# Source: Texas Instruments Inc.
# MR: 26019
# Type: Enhancement
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
# 
# This patch contains 2 updates from the original patch from TI.
#  1. Patch to remove USB configuration in board-evm.c is deleted.  The code
#     removal is now done at pro_arm_davinci_add_dm6467_and_dm355_support.patch.
#     Instead, the code now remove USB configuration in board-dm355-evm.c which
#     derives from board-evm.c.
# 
#  2. Updates to clock.c is deleted.  The original patch contains two updates
#     First is updates to DAVINCI_MAX_CLK.  This define is no longer used in 
#     the latest code, so the update is removed.  Second is adding USBCLK in 
#     the davinci_clk array.  This array is also no longer available in the
#     latest code.  It is replaced by three similar arrays, one for each
#     variants (DM644X, DM6467, and DM355).
# 
# Comments from TI
# This patch removes the toolchain dependency issues and also fixes some
# generic USB problems.
# 
# 

PATCHNUM=1665
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments Inc.
MR: 26019
Type: Enhancement
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:

This patch contains 2 updates from the original patch from TI.
 1. Patch to remove USB configuration in board-evm.c is deleted.  The code
    removal is now done at pro_arm_davinci_add_dm6467_and_dm355_support.patch.
    Instead, the code now remove USB configuration in board-dm355-evm.c which
    derives from board-evm.c.

 2. Updates to clock.c is deleted.  The original patch contains two updates
    First is updates to DAVINCI_MAX_CLK.  This define is no longer used in 
    the latest code, so the update is removed.  Second is adding USBCLK in 
    the davinci_clk array.  This array is also no longer available in the
    latest code.  It is replaced by three similar arrays, one for each
    variants (DM644X, DM6467, and DM355).

Comments from TI
This patch removes the toolchain dependency issues and also fixes some
generic USB problems.


Index: linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/board-dm355-evm.c
+++ linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
@@ -22,9 +22,6 @@
 #include <linux/major.h>
 #include <linux/root_dev.h>
 #include <linux/dma-mapping.h>
-#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
-#include <linux/usb_musb.h>
-#endif
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/serial_8250.h>
@@ -99,76 +96,6 @@ EXPORT_SYMBOL(cpu_type);
 
 extern void davinci_serial_init(struct platform_device *pdev);
 
-/*
- * USB
- */
-#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
-
-static struct musb_hdrc_platform_data usb_data = {
-#if	 defined(CONFIG_USB_MUSB_OTG)
-	 /* OTG requires a Mini-AB connector */
-	 .mode		 = MUSB_OTG,
-#elif	 defined(CONFIG_USB_MUSB_PERIPHERAL)
-	 .mode		 = MUSB_PERIPHERAL,
-#elif	 defined(CONFIG_USB_MUSB_HOST)
-	 .mode		 = MUSB_HOST,
-#endif
-	 /* irlml6401 switches 5V */
-	 .power		 = 255,		 /* sustains 3.0+ Amps (!) */
-	 .potpgt	 = 4,		 /* ~8 msec */
-
-	 /* REVISIT multipoint is a _chip_ capability; not board specific */
-	 .multipoint	 = 1,
-};
-
-static struct resource usb_resources [] = {
-	{
-		/* physical address */
-		.start		= DAVINCI_USB_OTG_BASE,
-		.end		= DAVINCI_USB_OTG_BASE + 0x5ff,
-		.flags		= IORESOURCE_MEM,
-	},
-	{
-		.start		= IRQ_USBINT,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static u64 usb_dmamask = DMA_32BIT_MASK;
-
-static struct platform_device usb_dev = {
-	 .name		 = "musb_hdrc",
-	 .id		 = -1,
-	 .dev = {
-		 .platform_data  = &usb_data,
-		 .dma_mask		 = &usb_dmamask,
-		 .coherent_dma_mask	 = DMA_32BIT_MASK,
-	 },
-	 .resource	 = usb_resources,
-	 .num_resources  = ARRAY_SIZE(usb_resources),
-};
-
-static inline void setup_usb(void)
-{
-	 /* REVISIT:  everything except platform_data setup should be
-	  * shared between all DaVinci boards using the same core.
-	  */
-	 int status;
-
-	 status = platform_device_register(&usb_dev);
-	 if (status != 0)
-		 pr_debug("setup_usb --> %d\n", status);
-	 else
-		 board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_USB, 1);
-}
-
-#else
-static inline void setup_usb(void)
-{
-	 /* NOP */
-}
-#endif  /* CONFIG_USB_MUSB_HDRC */
-
 #if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
 
 
@@ -409,7 +336,6 @@ static __init void davinci_init(void)
 	platform_add_devices(dm355_evm_devices,
 		ARRAY_SIZE(dm355_evm_devices));
 
-	 setup_usb();
 }
 
 extern void davinci_irq_init(void);
Index: linux-2.6.10/drivers/usb/musb/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/Kconfig
+++ linux-2.6.10/drivers/usb/musb/Kconfig
@@ -144,7 +144,7 @@ config USB_INVENTRA_DMA
 config USB_TI_CPPI_DMA
 	bool
 	depends on USB_MUSB_HDRC && !USB_INVENTRA_FIFO
-	default (ARCH_DAVINCI)
+	default ARCH_DAVINCI
 	help
 	  Enable DMA transfers when TI CPPI DMA is available.
 
Index: linux-2.6.10/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.10/drivers/usb/musb/cppi_dma.c
@@ -286,7 +286,7 @@ static struct dma_channel *cppi_channel_
 	 * with the Mentor DMA engine too
 	 */
 	if (otgCh->pEndPt)
-		DBG(1, "re-allocating DMA%d %cX channel %p\n",
+		DBG(6, "re-allocating DMA%d %cX channel %p\n",
 		    chNum, bTransmit ? 'T' : 'R', otgCh);
 	otgCh->pEndPt = ep;
 	otgCh->Channel.bStatus = MGC_DMA_STATUS_FREE;
@@ -641,16 +641,6 @@ cppi_next_rx_segment(struct musb *musb, 
 	dma_addr_t addr = rx->startAddr + rx->currOffset;
 	size_t length = rx->transferSize - rx->currOffset;
 	struct cppi_descriptor *bd, *tail;
-	/* Description: Change the variables to signed data type
-	 *
-	 * Reason for change:
-	 * Fix for gadget mode RX DMA in Complete preemption mode. The expression
-	 * in a conditional statement was sometimes giving -ve results, but because
-	 * of unsigned variables it resulted in wrong condition evaluation.
-	 *
-	 * Fixed MRs:
-	 * None
-	 */
 	signed n_bds;
 	signed i;
 	void *__iomem tibase = musb->ctrl_base;
@@ -778,16 +768,6 @@ cppi_next_rx_segment(struct musb *musb, 
 	i = musb_readl(tibase, DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
 	    & 0xffff;
 
-	/* Description: Removed the "write - read back - correct write" logic for
-	 *     the RX CPPI BUFCNT register. Just write it once with correct value.
-	 *
-	 * Reason for change:
-	 * In Complete Preemption gadget mode, the RX DMA sometimes misbehaves and
-	 * the device gets reset after sometime.
-	 *
-	 * Fixed MRs:
-	 * None
-	 */
 	if (n_bds > (i - 2)) {
 		musb_writel(tibase,
 			    DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
@@ -871,13 +851,21 @@ static int cppi_rx_scan(struct cppi *cpp
 
 	cppi_dump_rx(6, rx, "/K");
 
-	if (abort) {
-		last = rx->activeQueueHead;
-		goto free;
-	} else {
-		bd = last ? last->next : rx->activeQueueHead;
+	if (abort)
+	{
+		count = musb_readl(rx->pController->musb->ctrl_base, 
+				DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4));
+		safe2ack = musb_readl(CAST & state->completionPtr, 0);
+
+		if ((last == NULL) || (safe2ack == last->dma)) {
+			if (last == NULL)
+				last = rx->activeQueueHead;
+			goto free;
+		}
 	}
 
+	bd = last ? last->next : rx->activeQueueHead;
+
 	do {
 		safe2ack = musb_readl(CAST & state->completionPtr, 0);
 		if (completed)
@@ -936,22 +924,21 @@ static int cppi_rx_scan(struct cppi *cpp
 		} while (!completed);
 	} while (musb_readl(CAST & state->completionPtr, 0) != safe2ack);
 
-	if (is_host_active(rx->pController->musb) && (!completed)
-	    && (last->next->hNext == 0)) {
+	if (is_host_active(rx->pController->musb) && (!abort) 
+		&& (rx->autoReq == 0) && ((!completed) || 
+		(completed && (rx->reqcomplete == 0) && 
+		(rx->actualLen != rx->transferSize)))) {
+
 		csr = MGC_ReadCsr16(rx->pController->pCoreBase,
 				    MGC_O_HDRC_RXCSR, rx->chNo + 1);
-		if ((rx->autoReq == 0) &&
-		    (!((csr & MGC_M_RXCSR_H_REQPKT) ||
-		       (csr & MGC_M_RXCSR_RXPKTRDY)))) {
 			csr |= MGC_M_RXCSR_H_REQPKT;
 			MGC_WriteCsr16(rx->pController->pCoreBase,
 				       MGC_O_HDRC_RXCSR, rx->chNo + 1, csr);
 		}
-	}
 
 	rx->lastHwBDProcessed = last;
 	musb_writel(CAST & state->completionPtr, 0, safe2ack);
-      free:
+free: 
 	if (completed || abort) {
 
 		/* Flush BD's not consumed */
@@ -1052,16 +1039,6 @@ void cppi_completion(struct musb *pThis,
 					 * to the next queued bulk transfer.
 					 */
 #ifndef HOST_TX_DMA_SOLUTION
-					/* Description: Call the completion routine even for host
-					 *    mode driver.
-					 *
-					 * Reason for change:
-					 * Host mode TX DMA does not function, stops with urb_unlink.
-					 *
-					 * Fixed MRs:
-					 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
-					 *    to the Hub fails.
-					 */
 					if (is_peripheral_active(cppi->musb))
 #endif
 						cppi->dma_completed(pThis,
@@ -1201,7 +1178,6 @@ static int cppi_channel_abort(struct dma
 	void *__iomem mbase;
 	void *__iomem regBase;
 	u32 regVal;
-	struct cppi_descriptor *queue;
 
 	switch (pChannel->bStatus) {
 	case MGC_DMA_STATUS_BUS_ABORT:
@@ -1227,10 +1203,6 @@ static int cppi_channel_abort(struct dma
 	mbase = pController->pCoreBase;
 	regBase = mbase - DAVINCI_BASE_OFFSET;
 
-	queue = otgCh->activeQueueHead;
-	otgCh->activeQueueHead = NULL;
-	otgCh->activeQueueTail = NULL;
-
 	/* REVISIT should rely on caller having done this,
 	 * and caller should rely on us not changing it.
 	 * peripheral code is safe ... check host too.
@@ -1352,6 +1324,7 @@ static int cppi_channel_abort(struct dma
 		 * transferred and acking any IRQ
 		 */
 		cppi_rx_scan(pController, chNum, 1);
+		pChannel->dwActualLength += otgCh->actualLen;
 
 		/* clobber the existing state once it's idle
 		 *
@@ -1370,20 +1343,6 @@ static int cppi_channel_abort(struct dma
 
 		/* ... we don't "free" that list, only mutate it in place.  */
 		cppi_dump_rx(5, otgCh, " (done abort)");
-
-		/* clean up previously pending bds */
-		cppi_bd_free(otgCh, otgCh->lastHwBDProcessed);
-		otgCh->lastHwBDProcessed = NULL;
-
-		/* cppi_rx_scan changes the activeQueueHead, read it again */
-		if (otgCh->activeQueueHead)
-			queue = otgCh->activeQueueHead;
-
-		while (queue) {
-			struct cppi_descriptor *tmp = queue->next;
-			cppi_bd_free(otgCh, queue);
-			queue = tmp;
-		}
 	}
 
 	pChannel->bStatus = MGC_DMA_STATUS_FREE;
Index: linux-2.6.10/drivers/usb/musb/davinci.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/davinci.c
+++ linux-2.6.10/drivers/usb/musb/davinci.c
@@ -29,23 +29,17 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/list.h>
-// #include <linux/clk.h>
 #include <asm/hardware/clock.h>
 
 #include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/memory.h>
 #include <asm/mach-types.h>
-
-// #ifdef CONFIG_USB_MUSB_HDRC_HCD
 #include <linux/usb.h>
 #include "../core/hcd.h"
-// #endif
 
 #include "musbdefs.h"
-// #ifdef CONFIG_USB_MUSB_HDRC_HCD
 #include "musb_host.h"
-// #endif
 
 #ifdef CONFIG_ARCH_DAVINCI
 
@@ -59,11 +53,9 @@
 #ifdef CONFIG_USB_TI_CPPI_DMA
 #include "cppi_dma.h"
 #endif
-#if 0
 /*
  * USB
  */
-//#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
 
 static struct musb_hdrc_platform_data usb_data = {
 #if     defined(CONFIG_USB_MUSB_OTG)
@@ -75,22 +67,22 @@ static struct musb_hdrc_platform_data us
 	.mode = MUSB_HOST,
 #endif
 	/* irlml6401 switches 5V */
-	.power = 255,		/* sustains 3.0+ Amps (!) */
-	.potpgt = 4,		/* ~8 msec */
+	.power = 255,           /* sustains 3.0+ Amps (!) */
+	.potpgt = 4,            /* ~8 msec */
 
-	/* REVISIT multipoint is a _chip_ capability; not board specific */
+/* REVISIT multipoint is a _chip_ capability; not board specific */
 	.multipoint = 1,
 };
 
 static struct resource usb_resources[] = { {
-					    /* physical address */
-					    .start = DAVINCI_USB_OTG_BASE,
-					    .end = DAVINCI_USB_OTG_BASE + 0x5ff,
-					    .flags = IORESOURCE_MEM,
-					    }, {
-						.start = IRQ_USBINT,
-						.flags = IORESOURCE_IRQ,
-						},
+		/* physical address */
+		.start = DAVINCI_USB_OTG_BASE,
+		.end = DAVINCI_USB_OTG_BASE + 0x5ff,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_USBINT,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
 static u64 usb_dmamask = DMA_32BIT_MASK;
@@ -102,20 +94,20 @@ struct platform_device usb_dev = {
 		.platform_data = &usb_data,
 		.dma_mask = &usb_dmamask,
 		.coherent_dma_mask = DMA_32BIT_MASK,
-		},
+	},
 	.resource = usb_resources,
 	.num_resources = ARRAY_SIZE(usb_resources),
 };
 
-#endif
+
 static inline void phy_on(void)
 {
 	/* start the on-chip PHY and its PLL */
 	__raw_writel(USBPHY_SESNDEN | USBPHY_VBDTCTEN | USBPHY_PHYPLLON,
-		     IO_ADDRESS(USBPHY_CTL_PADDR));
+		IO_ADDRESS(USBPHY_CTL_PADDR));
 
 	while ((__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR))
-		& USBPHY_PHYCLKGD) == 0)
+			& USBPHY_PHYCLKGD) == 0)
 		cpu_relax();
 }
 
@@ -168,25 +160,8 @@ void musb_platform_disable(struct musb *
  * offchip DRVVBUS support and replacing MGC_OtgMachineInputs with
  * musb struct members (so e.g. vbus_state vanishes).
  */
+#if defined (CONFIG_MACH_DAVINCI_EVM)
 static int vbus_state = -1;
-static int host_session = 0;
-static void session(struct musb *musb, int is_on)
-{
-	void *__iomem mregs = musb->pRegs;
-	u8 devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
-
-	/* NOTE: after drvvbus off the state _could_ be A_IDLE;
-	 * but the silicon seems to couple vbus to "ID grounded".
-	 */
-	if (is_on)
-		devctl |= MGC_M_DEVCTL_SESSION;
-	else
-		devctl &= ~MGC_M_DEVCTL_SESSION;
-
-	musb_writeb(mregs, MGC_O_HDRC_DEVCTL, devctl);
-}
-
-#ifdef CONFIG_MACH_DAVINCI_EVM
 
 /* I2C operations are always synchronous, and require a task context.
  * With unloaded systems, using the shared workqueue seems to suffice
@@ -194,30 +169,22 @@ static void session(struct musb *musb, i
  */
 static void evm_deferred_drvvbus(void *_musb)
 {
-	struct musb *musb = _musb;
 	int is_on = vbus_state;
 
 	davinci_i2c_expander_op(0x3a, USB_DRVVBUS, !is_on);
-	vbus_state = is_on;
-	session(musb, host_session);
 }
 
 DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus, 0);
 
-#endif
 
 /* VBUS SWITCHING IS BOARD-SPECIFIC */
-void davinci_vbus_power(struct musb *musb, int is_on, int sleeping)
+static void davinci_vbus_power(struct musb *musb, int is_on)
 {
 	if (is_on)
 		is_on = 1;
 
-	DBG(1, "vbus_state=is_on\t vbus->%d\n", vbus_state);
-#if 0
-	if (vbus_state == is_on) {
-		return;
-	}
-#endif
+	DBG(1, "vbus_state=>%d\n", is_on);
+
 	if (is_on) {
 		MUSB_HST_MODE(musb);
 	} else {
@@ -237,27 +204,14 @@ void davinci_vbus_power(struct musb *mus
 			REG_DVEVM_GPIO45_CLR |= DAVINCI_VBUS_ON;
 		}
 #else
-		/* Do not turn off the USB bus.  This results in the IDE HDD
-		 * getting reset.
-		 */
-		if (0) {
-			davinci_i2c_expander_op(0x3a, USB_DRVVBUS, !is_on);
-		} else {
-			vbus_state = is_on;
-			host_session = sleeping;
-			schedule_work(&evm_vbus_work);
-			return;
-		}
+		vbus_state = is_on;
+		DBG(2, "VBUS power %s\n", is_on ? "on" : "off");
+		schedule_work(&evm_vbus_work);
 #endif
 	}
 #endif
-	vbus_state = is_on;
-	//if (sleeping){
-	session(musb, sleeping);
-	//}
-	DBG(2, "VBUS power %s, %s\n", is_on ? "on" : "off",
-	    sleeping ? "immediate" : "deferred");
 }
+#endif
 
 static irqreturn_t davinci_interrupt(int irq, void *__hci, struct pt_regs *r)
 {
@@ -307,13 +261,14 @@ static irqreturn_t davinci_interrupt(int
 		/* NOTE:  this must complete poweron within 100 msec */
 		DBG(1, "drvvbus Interrupt\n");
 #ifdef CONFIG_USB_MUSB_OTG
-		davinci_vbus_power(musb, drvvbus, drvvbus);
+		davinci_vbus_power(musb, drvvbus);
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
 		/* In host mode manipulate vbus based on core request but
 		 * keep the session on.
 		 */
-		davinci_vbus_power(musb, drvvbus, 1);
+		davinci_vbus_power(musb, drvvbus);
 #endif
+		drvvbus = 0;
 		retval = IRQ_HANDLED;
 	}
 
@@ -337,20 +292,19 @@ int __init musb_platform_init(struct mus
 {
 	void *__iomem tibase = musb->ctrl_base;
 	u32 revision;
+#ifdef CONFIG_ARCH_DAVINCI
+	struct clk *clkp;
+	
+	clkp = clk_get (NULL, "USBCLK");
+	if (IS_ERR(clkp))
+		return -ENODEV;
 
-	musb->pRegs += DAVINCI_BASE_OFFSET;
-#if 0
-	/* REVISIT there's something odd about clocking, this
-	 * didn't appear do the job ...
-	 */
-	musb->clock = clk_get(pDevice, "usb");
-	if (IS_ERR(musb->clock))
-		return PTR_ERR(musb->clock);
-
-	status = clk_enable(musb->clock);
-	if (status < 0)
+	musb->clock = clkp;	
+	clk_use (clkp);
+	if(clk_enable (clkp) != 0)
 		return -ENODEV;
 #endif
+	musb->pRegs += DAVINCI_BASE_OFFSET;
 
 	/* returns zero if e.g. not clocked */
 	revision = musb_readl(tibase, DAVINCI_USB_VERSION_REG);
@@ -369,10 +323,6 @@ int __init musb_platform_init(struct mus
 #endif
 	evm_vbus_work.data = musb;
 #endif
-	/* HBG 22 SEPT 2006 OTG controller with non-OTG devices */
-	davinci_vbus_power(musb, musb->board_mode == MUSB_HOST,
-			   musb->board_mode != MUSB_OTG);
-
 	/* reset the controller */
 	musb_writel(tibase, DAVINCI_USB_CTRL_REG, 0x1);
 
@@ -402,6 +352,9 @@ int musb_platform_exit(struct musb *musb
 #endif
 #endif
 
-	davinci_vbus_power(musb, 0 /*off */ , 1);
+	davinci_vbus_power(musb, 0);
+	clk_disable (musb->clock);
+	clk_unuse (musb->clock);
+
 	return 0;
 }
Index: linux-2.6.10/drivers/usb/musb/davinci.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/davinci.h
+++ linux-2.6.10/drivers/usb/musb/davinci.h
@@ -16,6 +16,7 @@
 
 /* Integrated highspeed/otg PHY */
 #define	USBPHY_CTL_PADDR	(DAVINCI_SYSTEM_MODULE_BASE + 0x34)
+#if defined(CONFIG_MACH_DAVINCI_EVM)
 #define	USBPHY_PHYCLKGD		(1 << 8)
 #define	USBPHY_SESNDEN		(1 << 7)	/* v(sess_end) comparator */
 #define	USBPHY_VBDTCTEN		(1 << 6)	/* v(bus) comparator */
@@ -24,7 +25,7 @@
 #define	USBPHY_OSCPDWN		(1 << 2)
 #define USBPHY_OTGPWDN		(1 << 1)
 #define	USBPHY_PHYSPDWN		(1 << 0)
-
+#endif
 /* For now include usb OTG module registers here */
 #define DAVINCI_USB_VERSION_REG		0x00
 #define DAVINCI_USB_CTRL_REG		0x04
@@ -87,8 +88,6 @@
 #define DAVINCI_VBUS_ON				0x00000040
 #define DAVINCI_VBUS_OFF			0x00000040
 
-/* REVISIT relying on "volatile" here is wrong ... */
-
 /* define structures of Rx/Tx stateRam entries */
 struct cppi_tx_stateram {
 	volatile u32 headPtr;
Index: linux-2.6.10/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.10/drivers/usb/musb/g_ep0.c
@@ -123,9 +123,9 @@ static int service_tx_status_request(str
 			is_in = bEnd & USB_DIR_IN;
 			if (is_in) {
 				bEnd &= 0x0f;
-				ep = &pThis->aLocalEnd[bEnd].ep_in;
+				ep = &pThis->aLocalEnd[bEnd * 2 - 1].ep_in;
 			} else {
-				ep = &pThis->aLocalEnd[bEnd].ep_out;
+				ep = &pThis->aLocalEnd[bEnd * 2].ep_out;
 			}
 
 			if (bEnd >= MUSB_C_NUM_EPS || !ep->desc) {
@@ -160,7 +160,8 @@ static int service_tx_status_request(str
 
 		if (len > 2)
 			len = 2;
-		musb_write_fifo(&pThis->aLocalEnd[0], len, bResult);
+		if (len)
+			musb_write_fifo(&pThis->aLocalEnd[0], len, bResult);
 	}
 
 	return handled;
@@ -278,11 +279,11 @@ __releases(pThis->Lock) __acquires(pThis
 					if (le16_to_cpu(pControlRequest->wIndex)
 					    & USB_DIR_IN)
 						pEnd =
-						    &pThis->aLocalEnd[bEnd].
+						    &pThis->aLocalEnd[bEnd * 2 -1].
 						    ep_in;
 					else
 						pEnd =
-						    &pThis->aLocalEnd[bEnd].
+						    &pThis->aLocalEnd[bEnd * 2].
 						    ep_out;
 					if (!pEnd->desc)
 						break;
@@ -412,11 +413,11 @@ __releases(pThis->Lock) __acquires(pThis
 					if (le16_to_cpu(pControlRequest->wIndex)
 					    & USB_DIR_IN)
 						pEnd =
-						    &pThis->aLocalEnd[bEnd].
+						    &pThis->aLocalEnd[bEnd * 2 -1].
 						    ep_in;
 					else
 						pEnd =
-						    &pThis->aLocalEnd[bEnd].
+						    &pThis->aLocalEnd[bEnd * 2].
 						    ep_out;
 					if (!pEnd->desc)
 						break;
@@ -471,7 +472,8 @@ static void ep0_rxstate(struct musb *thi
 			req->status = -EOVERFLOW;
 			tmp = len;
 		}
-		musb_read_fifo(&this->aLocalEnd[0], tmp, buf);
+		if (tmp)
+			musb_read_fifo(&this->aLocalEnd[0], tmp, buf);
 		req->actual += tmp;
 		tmp = MGC_M_CSR0_P_SVDRXPKTRDY;
 		if (tmp < 64 || req->actual == req->length) {
@@ -516,7 +518,8 @@ static void ep0_txstate(struct musb *pTh
 	pFifoSource = (u8 *) pRequest->buf + pRequest->actual;
 	wFifoCount = min((unsigned)MGC_END0_FIFOSIZE,
 			 pRequest->length - pRequest->actual);
-	musb_write_fifo(&pThis->aLocalEnd[0], wFifoCount, pFifoSource);
+	if (wFifoCount)
+		musb_write_fifo(&pThis->aLocalEnd[0], wFifoCount, pFifoSource);
 	pRequest->actual += wFifoCount;
 
 	/* update the flags */
@@ -577,17 +580,6 @@ static void musb_read_setup(struct musb 
 	 */
 	pThis->bSetAddress = FALSE;
 	pThis->ackpend = MGC_M_CSR0_P_SVDRXPKTRDY;
-	/* Description: Added extra if condition for req->wLength = 0 & USB_DIR_IN
-	 *
-	 * Reason for change:
-	 * The www.linux-usb.org/usbtest 'test 14' fails with error for zero
-	 * length request. If the SETUP packet requests ZERO length data from
-	 * device-to-host, the TXPKTRDY bit needs to be set in TXCSR otherwise
-	 * the STATUS stage of control transfer will never complete.
-	 *
-	 * Fixed MRs:
-	 * None
-	 */
 	if (req->wLength == 0 && (req->bRequestType & USB_DIR_IN)) {
 		pThis->ackpend |= MGC_M_CSR0_TXPKTRDY;
 		pThis->ep0_state = MGC_END0_STAGE_ACKWAIT;
Index: linux-2.6.10/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.10/drivers/usb/musb/musb_gadget.c
@@ -287,7 +287,7 @@ static void txstate(struct musb *pThis, 
 	}
 
 	if (!use_dma) {
-		if (pRequest->length != 0) {
+		if ((pRequest->length != 0) && wFifoCount) {
 			musb_write_fifo(pEnd->hw_ep, wFifoCount,
 					(u8 *) (pRequest->buf +
 						pRequest->actual));
@@ -318,7 +318,7 @@ void musb_g_tx(struct musb *pThis, u8 bE
 	struct dma_channel *dma;
 
 	MGC_SelectEnd(pBase, bEnd);
-	pEnd = &pThis->aLocalEnd[bEnd].ep_in;
+	pEnd = &pThis->aLocalEnd[bEnd * 2 - 1].ep_in;
 	pRequest = next_request(pEnd);
 
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
@@ -462,7 +462,7 @@ static void rxstate(struct musb *pThis, 
 	const u8 bEnd = req->bEnd;
 	struct usb_request *pRequest = &req->request;
 	void __iomem *pBase = pThis->pRegs;
-	struct musb_ep *pEnd = &pThis->aLocalEnd[bEnd].ep_out;
+	struct musb_ep *pEnd = req->ep;
 	u16 wFifoCount = 0;
 	u16 wCount = pEnd->wPacketSize;
 
@@ -563,7 +563,8 @@ static void rxstate(struct musb *pThis, 
 			    wCount, wFifoCount, pEnd->wPacketSize);
 
 			wFifoCount = min(wCount, wFifoCount);
-			musb_read_fifo(pEnd->hw_ep, wFifoCount,
+			if (wFifoCount)
+				musb_read_fifo(pEnd->hw_ep, wFifoCount,
 				       (u8 *) (pRequest->buf +
 					       pRequest->actual));
 			pRequest->actual += wFifoCount;
@@ -599,7 +600,7 @@ void musb_g_rx(struct musb *pThis, u8 bE
 
 	MGC_SelectEnd(pBase, bEnd);
 
-	pEnd = &pThis->aLocalEnd[bEnd].ep_out;
+	pEnd = &pThis->aLocalEnd[bEnd * 2].ep_out;
 	pRequest = next_request(pEnd);
 	if (pRequest == NULL) {
 		return;
@@ -1408,14 +1409,14 @@ init_peripheral_ep(struct musb *musb, st
 
 	memset(ep, 0, sizeof *ep);
 
-	ep->bEndNumber = bEnd;
+	ep->bEndNumber = hw_ep->bLocalEnd;
 	ep->pThis = musb;
 	ep->hw_ep = hw_ep;
 	ep->is_in = is_in;
 
 	INIT_LIST_HEAD(&ep->req_list);
 
-	sprintf(ep->name, "ep%d%s", bEnd,
+	sprintf(ep->name, "ep%d%s", hw_ep->bLocalEnd,
 		(!bEnd || hw_ep->bIsSharedFifo) ? "" : (is_in ? "in" : "out"));
 	ep->end_point.name = ep->name;
 	INIT_LIST_HEAD(&ep->end_point.ep_list);
@@ -1626,30 +1627,12 @@ stop_activity(struct musb *musb, struct 
 	{
 		for (i = 0, hw_ep = musb->aLocalEnd;
 		     i < musb->bEndCount; i++, hw_ep++) {
-			MGC_SelectEnd(musb->pRegs, i);
+			MGC_SelectEnd(musb->pRegs, hw_ep->bLocalEnd);
 			if (hw_ep->bIsSharedFifo /* || !bEnd */ ) {
-				/* Description: Added lock / unlock calls and replaced nuke() by
-				 *     musb_gadget_disable() call for IN endpoint
-				 *
-				 * Reason for change:
-				 * Resolves the Complete preemption "rmmod" issue
-				 *
-				 * Fixed MRs:
-				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
-				 */
 				spin_unlock(&musb->Lock);
 				musb_gadget_disable(&hw_ep->ep_in.end_point);
 				spin_lock(&musb->Lock);
 			} else {
-				/* Description: Added lock / unlock calls and replaced nuke() by
-				 *     musb_gadget_disable() call for IN & OUT endpoints
-				 *
-				 * Reason for change:
-				 * Resolves the Complete preemption "rmmod" issue
-				 *
-				 * Fixed MRs:
-				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
-				 */
 				if (hw_ep->wMaxPacketSizeTx) {
 					spin_unlock(&musb->Lock);
 					musb_gadget_disable(&hw_ep->ep_in.
Index: linux-2.6.10/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.10/drivers/usb/musb/musb_host.c
@@ -150,15 +150,6 @@ void MGC_HdrcEnableTXDMA(struct musb *pT
 	txCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 	txCsr |= MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_H_WZC_BITS;
 #ifdef HOST_TX_DMA_SOLUTION
-	/* Description: Use DMAMODE = '1' for TX endpoint in host mode.
-	 *
-	 * Reason for change:
-	 * Host mode TX DMA does not function, stops with urb_unlink.
-	 *
-	 * Fixed MRs:
-	 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
-	 *    to the Hub fails.
-	 */
 	txCsr |= MGC_M_TXCSR_DMAMODE;
 #endif
 	MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, txCsr);
@@ -544,6 +535,7 @@ static u8 musb_host_packet_rx(struct mus
 
 	// MGC_SelectEnd(pBase, bEnd);
 	wRxCount = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCOUNT, bEnd);
+
 	DBG(3, "RX%d count %d, buffer %p len %d/%d\n", bEnd, wRxCount,
 	    pUrb->transfer_buffer, pEnd->dwOffset,
 	    pUrb->transfer_buffer_length);
@@ -582,7 +574,8 @@ static u8 musb_host_packet_rx(struct mus
 		    (wRxCount < pEnd->wPacketSize);
 	}
 
-	musb_read_fifo(pEnd, wLength, pBuffer);
+	if (wLength)
+		musb_read_fifo(pEnd, wLength, pBuffer);
 
 	if (wRxCount <= wLength) {
 		wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd);
@@ -657,12 +650,12 @@ static void musb_ep_program(struct musb 
 	if (usb_pipeisoc(nPipe)) {
 		bStdType = USB_ENDPOINT_XFER_ISOC;
 		/* both speeds use log encoding */
-		bInterval = 1 + fls(pUrb->interval);
+		bInterval = fls(pUrb->interval);
 	} else if (usb_pipeint(nPipe)) {
 		bStdType = USB_ENDPOINT_XFER_INT;
 		/* only highspeed uses log encoding */
 		if (USB_SPEED_HIGH == bSpeed)
-			bInterval = 1 + fls(pUrb->interval);
+			bInterval = fls(pUrb->interval);
 		else if (bInterval == 0)
 			bInterval = 1;
 	} else if (bIsBulk) {
@@ -777,16 +770,6 @@ static void musb_ep_program(struct musb 
 	if (is_out) {
 		/* transmit */
 #ifndef HOST_TX_DMA_SOLUTION
-		/* Description: Do not disable endpoint interrupt because Host TX DMA
-		 *    uses DMAMODE = '1'.
-		 *
-		 * Reason for change:
-		 * Host mode TX DMA does not function, stops with urb_unlink.
-		 *
-		 * Fixed MRs:
-		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
-		 *    to the Hub fails.
-		 */
 		/* disable interrupt in case we flush */
 		wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << bEnd));
@@ -965,16 +948,6 @@ static void musb_ep_program(struct musb 
 
 		}
 #ifndef HOST_TX_DMA_SOLUTION
-		/* Description: Do not disable endpoint interrupt because Host TX DMA
-		 *    uses DMAMODE = '1'.
-		 *
-		 * Reason for change:
-		 * Host mode TX DMA does not function, stops with urb_unlink.
-		 *
-		 * Fixed MRs:
-		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
-		 *    to the Hub fails.
-		 */
 		/* re-enable interrupt */
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
 #endif
@@ -1263,7 +1236,8 @@ static u8 musb_h_ep0_continue(struct mus
 							      actual_length)));
 			DBG(3, "Sending %d bytes to %p\n", wFifoCount,
 			    pFifoDest);
-			musb_write_fifo(pEnd, wFifoCount, pFifoDest);
+			if (wFifoCount)
+				musb_write_fifo(pEnd, wFifoCount, pFifoDest);
 
 			pEnd->dwRequestSize = wFifoCount;
 			pUrb->actual_length += wFifoCount;
@@ -1376,15 +1350,16 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 			    MGC_M_CSR0_H_REQPKT : MGC_M_CSR0_TXPKTRDY;
 			DBG(5, "more ep0 DATA, csr %04x\n", wCsrVal);
 		} else {
+			if (usb_pipein(pUrb->pipe))	
+				MGC_WriteCsr8(pBase, MGC_O_HDRC_NAKLIMIT0, 0,
+					      bInterval);
+
 			/* data transfer complete; perform status phase */
 			wCsrVal = MGC_M_CSR0_H_STATUSPKT |
 			    ((usb_pipeout(pUrb->pipe)) ? MGC_M_CSR0_H_REQPKT :
 			     MGC_M_CSR0_TXPKTRDY);
 			/* flag status stage */
 			pThis->bEnd0Stage = MGC_END0_STATUS;
-			if (wCsrVal & MGC_M_CSR0_TXPKTRDY)
-				MGC_WriteCsr8(pBase, MGC_O_HDRC_NAKLIMIT0, 0,
-					      bInterval);
 
 			DBG(5, "ep0 STATUS, csr %04x\n", wCsrVal);
 
@@ -1516,6 +1491,7 @@ void musb_host_tx(struct musb *pThis, u8
 			}
 		} else if (dma) {
 			bDone = TRUE;
+			 pEnd->pDmaChannel->dwActualLength = 0L;
 		} else {
 			/* see if we need to send more data, or ZLP */
 			if (pEnd->dwRequestSize < pEnd->wPacketSize)
@@ -1556,7 +1532,8 @@ void musb_host_tx(struct musb *pThis, u8
 
 		/* PIO:  start next packet in this URB */
 		wLength = min(pEnd->wPacketSize, (u16) wLength);
-		musb_write_fifo(pEnd, wLength, pBuffer);
+		if (wLength)
+			musb_write_fifo(pEnd, wLength, pBuffer);
 		pEnd->dwRequestSize = wLength;
 
 		MGC_SelectEnd(pBase, bEnd);
@@ -1650,6 +1627,7 @@ void musb_host_rx(struct musb *pThis, u8
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
 			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 			xfer_len = dma->dwActualLength;
+			dma->dwActualLength = 0L;
 		}
 	}
 
@@ -1686,6 +1664,7 @@ void musb_host_rx(struct musb *pThis, u8
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
 			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 			xfer_len = dma->dwActualLength;
+			dma->dwActualLength = 0L;
 		}
 
 		DBG(3, "RXCSR%d %04x, reqpkt, len %d%s\n", bEnd, wRxCsrVal,
@@ -1697,7 +1676,7 @@ void musb_host_rx(struct musb *pThis, u8
 			       MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
 	}
 
-	if (dma && (wRxCsrVal & MGC_M_RXCSR_DMAENAB)) {
+	if (dma && ((wRxCsrVal & MGC_M_RXCSR_DMAENAB) || dma->dwActualLength)) {
 #if 0
 		wRxCsrVal &= ~MGC_M_RXCSR_DMAENAB;
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
@@ -1709,6 +1688,7 @@ void musb_host_rx(struct musb *pThis, u8
 #endif
 		bDone = TRUE;
 		xfer_len = dma->dwActualLength;
+		dma->dwActualLength = 0L;
 
 	} else if (!bDone && pUrb->status == -EINPROGRESS) {
 
Index: linux-2.6.10/drivers/usb/musb/musb_host.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.h
+++ linux-2.6.10/drivers/usb/musb/musb_host.h
@@ -80,16 +80,6 @@ struct musb_sched_node {
 };
 
 #if defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA)
-/* Description: Added defines and global externs used by Host TX DMA
- *    completion solution.
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected
- *    to the Hub fails.
- */
 #define	HOST_TX_DMA_SOLUTION 2	/* Host TX DMA completion solution: tasklet */
 
 extern struct list_head tx_completion_list;
Index: linux-2.6.10/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.10/drivers/usb/musb/musbdefs.h
@@ -509,6 +509,10 @@ struct musb {
 	struct usb_gadget_driver *pGadgetDriver;	/* its driver */
 #endif
 
+#ifdef CONFIG_ARCH_DAVINCI_DM355
+	u16	vbuserr_retry;
+#endif
+
 #ifdef CONFIG_USB_MUSB_OTG
 	struct otg_machine OtgMachine;
 	u8 bDelayPortPowerOff;
@@ -550,8 +554,6 @@ extern void musb_platform_disable(struct
 extern void musb_pullup(struct musb *musb, int is_on);
 extern u8 is_otg_b_device(struct musb *pThis);
 //-------------------------
-extern void davinci_vbus_power(struct musb *musb, int is_on, int sleeping);
-
 extern int __init musb_platform_init(struct musb *musb);
 extern int musb_platform_exit(struct musb *musb);
 
Index: linux-2.6.10/drivers/usb/musb/otg.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/otg.c
+++ linux-2.6.10/drivers/usb/musb/otg.c
@@ -71,19 +71,15 @@
 
 static void otg_set_session(struct musb *musb, u8 bSession, u8 bADevice)
 {
-	/* REVISIT unclear what this should do, but this looks
-	 * like the wrong thing ... the OTG machine should never
-	 * shut down so long as both host and peripheral drivers
-	 * are active.
-	 */
-	if (bSession && bADevice) {
-		davinci_vbus_power(musb, 1, 1);
-	} else if (bSession) {
-		davinci_vbus_power(musb, 0, 1);
-	} else {
-		davinci_vbus_power(musb, 0, 0);
-	}
+	void *__iomem mregs = musb->pRegs;
+	u8 devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
+
+	if (bSession)
+		devctl |= MGC_M_DEVCTL_SESSION;
+	else
+		devctl &= ~MGC_M_DEVCTL_SESSION;
 
+	musb_writeb(mregs, MGC_O_HDRC_DEVCTL, devctl);
 }
 
 /* caller has irqlocked musb */
@@ -363,8 +359,6 @@ void MGC_OtgMachineInputsChanged(struct 
 
 	case OTG_STATE_B_HOST:
 		if (pMachine->bRequest == MGC_OTG_REQUEST_SUSPEND_BUS) {
-			u8 power =
-			    musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_POWER);
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_POWER,
 				    power | MGC_M_POWER_SUSPENDM);
 			mdelay(10);
Index: linux-2.6.10/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.10/drivers/usb/musb/plat_uds.c
@@ -1429,7 +1429,6 @@ static int __init musb_core_init(u16 wTy
 	} else
 		status = ep_config_from_hw(pThis);
 #endif
-
 	if (status < 0)
 		return status;
 
@@ -1788,7 +1787,7 @@ static void musb_free(struct musb *musb)
  * 	not yet corrected for platform-specific offsets
  */
 static int __init
-musb_init_controller(struct device *dev, int nIrq, void __iomem * ctrl)
+musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 {
 	int status;
 	struct musb *pThis;
@@ -1818,8 +1817,9 @@ musb_init_controller(struct device *dev,
 	case MUSB_OTG:
 #ifdef CONFIG_USB_MUSB_OTG
 		break;
-#endif
+#else
 	      bad_config:
+#endif
 	default:
 		dev_dbg(dev, "incompatible Kconfig role setting\n");
 		return -EINVAL;
@@ -1869,13 +1869,13 @@ musb_init_controller(struct device *dev,
 
 	/* setup musb parts of the core (especially endpoints) */
 	status = musb_core_init(plat->multipoint
-				? MUSB_CONTROLLER_MHDRC
-				: MUSB_CONTROLLER_HDRC, pThis);
+			   ? MUSB_CONTROLLER_MHDRC
+			   : MUSB_CONTROLLER_HDRC, pThis);
 	if (status < 0)
 		goto fail;
 
 	/* attach to the IRQ */
-	if (request_irq(nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
+	if (request_irq (nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
 		dev_err(dev, "request_irq %d failed!\n", nIrq);
 		status = -ENODEV;
 		goto fail;
@@ -1885,14 +1885,14 @@ musb_init_controller(struct device *dev,
 
 	pr_info("%s: USB %s mode controller at %p using %s, IRQ %d\n",
 		musb_driver_name, ( {
-				   char *s;
-				   switch (pThis->board_mode) {
-case MUSB_HOST:
-s = "Host"; break; case MUSB_PERIPHERAL:
-s = "Peripheral"; break; default:
-				   s = "OTG"; break;}; s;}
-		), ctrl, (is_dma_capable() && pThis->pDmaController)
-		? "DMA" : "PIO", pThis->nIrq) ;
+				char *s;
+				switch (pThis->board_mode) {
+				case MUSB_HOST:
+					s = "Host"; break; case MUSB_PERIPHERAL:
+					s = "Peripheral"; break; default:
+					s = "OTG"; break;}; s;}
+				), ctrl, (is_dma_capable() && pThis->pDmaController)
+				? "DMA" : "PIO", pThis->nIrq) ;
 
 // FIXME:
 //  - convert to the HCD framework
@@ -2002,10 +2002,10 @@ s = "Peripheral"; break; default:
 #endif
 
 		DBG(1, "%s mode, status %d, devctl %02x %c\n",
-		    "HOST", status,
-		    musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
-		    (musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
-		     & MGC_M_DEVCTL_BDEVICE ? 'B' : 'A'));
+                    "HOST", status,
+                    musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
+                    (musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
+                     & MGC_M_DEVCTL_BDEVICE ? 'B' : 'A'));
 
 #ifndef CONFIG_USB_MUSB_OTG
 		break;
@@ -2051,6 +2051,7 @@ static int __init musb_probe(struct devi
 	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!iomem || irq == 0)
 		return -ENODEV;
+
 #ifdef CONFIG_ARCH_DAVINCI
 	base = ioremap(iomem->start, iomem->end - iomem->start + 1);
 	if (!base) {
@@ -2152,6 +2153,11 @@ static struct device_driver musb_driver 
 	.resume = musb_resume,
 };
 
+extern struct platform_device usb_dev;
+static void musb_release(struct device *dev)
+{
+}
+
 /*-------------------------------------------------------------------------*/
 
 static int __init musb_init(void)
@@ -2179,7 +2185,10 @@ static int __init musb_init(void)
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
 		"[host]"
 #endif
-		" [debug=%d]\n", musb_driver_name, MGC_GetDebugLevel());
+                " [debug=%d]\n", musb_driver_name, MGC_GetDebugLevel());
+
+	platform_device_register(&usb_dev);
+	usb_dev.dev.release = musb_release;
 
 	return driver_register(&musb_driver);
 }
@@ -2195,15 +2204,17 @@ static void __exit musb_cleanup(void)
 #ifdef CONFIG_USB_MUSB_OTG
 	remove_proc_entry("driver/otg", NULL);
 #endif
+
 	driver_unregister(&musb_driver);
+	platform_device_unregister(&usb_dev);
 }
-
 module_exit(musb_cleanup);
+
 #ifdef CONFIG_USB_MUSB_OTG
 /* HBG Testing 15SEPT2006 */
 
 static int musb_app_inputs(struct file *file, const char __user * buffer,
-			   unsigned long count, void *data)
+                           unsigned long count, void *data)
 {
 	u8 busReq;
 	struct musb *pThis = data;
@@ -2218,27 +2229,27 @@ static int musb_app_inputs(struct file *
 	case 'e':
 		busReq = MGC_OTG_REQUEST_DROP_BUS;
 		break;
-		/*case 'b':
-		   busReq=MGC_OTG_REQUEST_START_BUS;
-		   pThis->OtgMachine.bRequest = busReq;
-		   return 1;
-		   break;
-		   case 'H':
-		   case 'h':
-		   BusReq=3;
-		   printk("Start HNP\n");
-		   break;
-		   case 'S':
-		   BusReq=4;
-		   printk("Suspend the Bus\n");
-		   break; */
+	/*case 'b':
+		busReq=MGC_OTG_REQUEST_START_BUS;
+		pThis->OtgMachine.bRequest = busReq;
+		return 1;
+		break;
+	case 'H':
+	case 'h':
+		BusReq=3;
+		printk("Start HNP\n");
+		break;
+	case 'S':
+		BusReq=4;
+		printk("Suspend the Bus\n");
+		break; */
 	default:
 		return 1;
 		break;
 	}
 	pThis->OtgMachine.bRequest = busReq;
 	/* This is user initiated change so consider that
-	   the connection is active by default
+	 * the connection is active by default
 	 */
 	otg_input_changed_X(pThis, FALSE, TRUE);
 	return 1;
@@ -2247,7 +2258,7 @@ static int musb_app_inputs(struct file *
 
 /* HBG 22SEPT 2006 */
 /* ID pin sensing support to OTG.c */
-u8 is_otg_b_device(struct musb * pThis)
+u8 is_otg_b_device(struct musb *pThis)
 {
 	u8 Devctl;
 	Devctl = musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL);
Index: linux-2.6.10/drivers/usb/musb/virthub.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/virthub.c
+++ linux-2.6.10/drivers/usb/musb/virthub.c
@@ -658,14 +658,6 @@ int MGC_VirtualHubUnlinkUrb(struct virtu
 {
 	//unsigned long flags;
 
-	/* Description: Commented lock / unlock calls
-	 *
-	 * Reason for change:
-	 * Resolves the RT preemption issue
-	 *
-	 * Fixed MRs:
-	 * 3020: <USB_Host> Image fails to come up in Complete Pre-emption mode.
-	 */
 	//spin_lock_irqsave(&pHub->Lock, flags);
 	if (pUrb && (pHub->pUrb == pUrb) && (pUrb->hcpriv == pHub)) {
 		/* NOTE:  this path should support usb_kill_urb()... */
Index: linux-2.6.10/mvl_patches/pro-1665.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1665.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1665);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

