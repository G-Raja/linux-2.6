#! /usr/bin/env bash
# Patch: -pro_arm_davinci_video_dm355
# Date: Mon Jan 21 23:07:31 2008
# Source: MontaVista Software, Inc. and Texas Instruments Inc.
# MR: 26129
# Type: Enhancement
# Disposition: local
# Signed-off-by: Vladimir Barinov <vbarinov@mvista.com>
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
#  Davinci DM355/DM644X video support
# 

PATCHNUM=1695
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. and Texas Instruments Inc.
MR: 26129
Type: Enhancement
Disposition: local
Signed-off-by: Vladimir Barinov <vbarinov@mvista.com>
Signed-off-by: Steve Chen <schen@mvista.com>
Description:
 Davinci DM355/DM644X video support

Index: linux-2.6.10/drivers/media/video/davinci/ccdc_dm355.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/ccdc_dm355.c
@@ -0,0 +1,1591 @@
+/*
+ * 
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.c */
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <asm/arch/mux.h>
+#include <media/davinci/ccdc_dm355.h>
+/*Object for CCDC raw mode */
+ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = FALSE,
+	.data_sz = _10BITS,
+	.med_filt_thres = 0,
+	.mfilt1 = NO_MEDIAN_FILTER1,
+	.mfilt2 = NO_MEDIAN_FILTER2,
+	.ccdc_offset = 0,
+	.lpf_enable = FALSE,
+	.datasft = 2,
+	.alaw = {
+		 .b_alaw_enable = FALSE,
+		 .gama_wd = 2}
+	,
+	.blk_clamp = {
+		      .b_clamp_enable = FALSE,
+		      .sample_pixel = 1,
+		      .start_pixel = 0,
+		      .dc_sub = 25}
+	,
+	.blk_comp = {
+		     .b_comp = 0,
+		     .gb_comp = 0,
+		     .gr_comp = 0,
+		     .r_comp = 0}
+	,
+	.vertical_dft = {
+			 .ver_dft_en = FALSE}
+	,
+	.lens_sh_corr = {
+			 .lsc_enable = FALSE}
+	,
+	.data_formatter_r = {
+			     .fmt_enable = FALSE}
+	,
+	.color_space_con = {
+			    .csc_enable = FALSE}
+};
+
+/*Object for CCDC ycbcr mode */
+ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = TRUE,
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
+};
+
+extern struct device *vpfe_dev;
+void ccdc_readregs(void)
+{
+	unsigned int val = 0;
+
+	val = regr(SYNCEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SYNCEN...\n", val);
+	val = regr(MODESET);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to MODESET...\n", val);
+	val = regr(HDWIDTH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HDWIDTH...\n", val);
+	val = regr(VDWIDTH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDWIDTH...\n", val);
+	val = regr(PPLN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to PPLN...\n", val);
+	val = regr(LPFR);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LPFR...\n", val);
+	val = regr(SPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SPH...\n", val);
+	val = regr(NPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to NPH...\n", val);
+	val = regr(SLV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SLV0...\n", val);
+	val = regr(SLV1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SLV1...\n", val);
+	val = regr(NLV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to NLV...\n", val);
+	val = regr(CULH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CULH...\n", val);
+	val = regr(CULV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CULV...\n", val);
+	val = regr(HSIZE);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HSIZE...\n", val);
+	val = regr(SDOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SDOFST...\n", val);
+	val = regr(STADRH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to STADRH...\n", val);
+	val = regr(STADRL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to STADRL...\n", val);
+	val = regr(CLAMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CLAMP...\n", val);
+	val = regr(DCSUB);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DCSUB...\n", val);
+	val = regr(COLPTN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to COLPTN...\n", val);
+
+	val = regr(BLKCMP0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP0...\n", val);
+	val = regr(BLKCMP1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP1...\n", val);
+	val = regr(MEDFILT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to MEDFILT...\n", val);
+	val = regr(RYEGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to RYEGAIN...\n", val);
+	val = regr(GRCYGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GRCYGAIN...\n", val);
+	val = regr(GBGGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GBGGAIN...\n", val);
+	val = regr(BMGGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BMGGAIN...\n", val);
+	val = regr(OFFSET);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to OFFSET...\n", val);
+	val = regr(OUTCLIP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to OUTCLIP...\n", val);
+	val = regr(VDINT0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDINT0...\n", val);
+	val = regr(VDINT1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDINT1...\n", val);
+	val = regr(RSV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to RSV0...\n", val);
+	val = regr(GAMMAWD);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GAMMAWD...\n", val);
+	val = regr(REC656IF);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to REC656IF...\n", val);
+	val = regr(CCDCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CCDCFG...\n", val);
+	val = regr(FMTCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTCFG...\n", val);
+	val = regr(FMTPLEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPLEN...\n", val);
+	val = regr(FMTSPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTSPH...\n", val);
+	val = regr(FMTLNH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTLNH...\n", val);
+	val = regr(FMTSLV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTSLV...\n", val);
+	val = regr(FMTLNV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTLNV...\n", val);
+	val = regr(FMTRLEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTRLEN...\n", val);
+	val = regr(FMTHCNT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTHCNT...\n", val);
+	val = regr(FMT_ADDR_PTR_B);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_ADDR_PTR_B...\n", val);
+	val = regr(FMTPGM_VF0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_VF0...\n", val);
+	val = regr(FMTPGM_VF1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_VF1...\n", val);
+	val = regr(FMTPGM_AP0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP0...\n", val);
+	val = regr(FMTPGM_AP1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP1...\n", val);
+	val = regr(FMTPGM_AP2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP2...\n", val);
+	val = regr(FMTPGM_AP3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP3...\n", val);
+	val = regr(FMTPGM_AP4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP4...\n", val);
+	val = regr(FMTPGM_AP5);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP5...\n", val);
+	val = regr(FMTPGM_AP6);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP6...\n", val);
+	val = regr(FMTPGM_AP7);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP7...\n", val);
+
+	val = regr(LSCCFG1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCCFG1...\n", val);
+	val = regr(LSCCFG2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCCFG2...\n", val);
+	val = regr(LSCH0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCH0...\n", val);
+	val = regr(LSCV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCV0...\n", val);
+	val = regr(LSCKH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCKH...\n", val);
+	val = regr(LSCKV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCKV...\n", val);
+	val = regr(LSCMEMCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMCTL...\n", val);
+	val = regr(LSCMEMD);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMD...\n", val);
+	val = regr(LSCMEMQ);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMQ...\n", val);
+	val = regr(DFCCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCCTL...\n", val);
+	val = regr(DFCVSAT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCVSAT...\n", val);
+	val = regr(DFCMEMCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEMCTL...\n", val);
+	val = regr(DFCMEM0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM0...\n", val);
+	val = regr(DFCMEM1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM1...\n", val);
+	val = regr(DFCMEM2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM2...\n", val);
+	val = regr(DFCMEM3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM3...\n", val);
+	val = regr(DFCMEM4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM4...\n", val);
+	val = regr(CSCCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCCTL...\n", val);
+	val = regr(CSCM0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM0...\n", val);
+	val = regr(CSCM1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM1...\n", val);
+
+	val = regr(CSCM2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM2...\n", val);
+
+	val = regr(CSCM3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM3...\n", val);
+	val = regr(CSCM4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM4...\n", val);
+	val = regr(CSCM5);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM5...\n", val);
+
+	val = regr(CSCM6);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM6...\n", val);
+	val = regr(CSCM7);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM7...\n", val);
+	val = regr(DATAOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DATAOFST...\n", val);
+}
+
+int ccdc_update_raw_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_raw,
+	       (ccdc_config_params_raw *) arg, sizeof(ccdc_config_params_raw));
+	return 0;
+}
+
+int ccdc_update_ycbcr_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_ycbcr,
+	       (ccdc_params_ycbcr *) arg, sizeof(ccdc_params_ycbcr));
+	return 0;
+}
+
+void ccdc_init(void)
+{
+	davinci_cfg_reg(DM355_VIN_PCLK);
+	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+	davinci_cfg_reg(DM355_VIN_CAM_VD);
+	davinci_cfg_reg(DM355_VIN_CAM_HD);
+	davinci_cfg_reg(DM355_VIN_YIN_EN);
+	davinci_cfg_reg(DM355_VIN_CINL_EN);
+	davinci_cfg_reg(DM355_VIN_CINH_EN);
+}
+
+void ccdc_cleanup(void)
+{
+	/* Nothing for DM355 */
+}
+
+/*                                                       
+ * ======== ccdc_reset  ========                        
+ */
+/*This function will reset all CCDc reg */
+
+void ccdc_reset()
+{
+	int i, memctrl, clkctrl;
+	/* disable CCDC */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_reset...");
+	mdelay(5);
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x15c; i += 4) {
+		mdelay(5);
+		regw(0, i);
+	}
+	mdelay(5);
+	/* no culling support */
+	regw(0xffff, CULH);
+	mdelay(5);
+	regw(0xff, CULV);
+	mdelay(5);
+	/* always set the gain to 1 */
+	regw(0x80, RYEGAIN);
+	mdelay(5);
+	regw(0x80, GRCYGAIN);
+	mdelay(5);
+	regw(0x80, GBGGAIN);
+	mdelay(5);
+	regw(0x80, BMGGAIN);
+	mdelay(5);
+	/* up to 12 bit sensor */
+	regw(0x0FFF, OUTCLIP);
+	mdelay(5);
+
+	memctrl = regr_bl(MEMCTRL);
+	memctrl &= 0xfffffffe;	/*configuring DFC for IPIPE */
+	mdelay(5);
+	regw_bl(memctrl, MEMCTRL);
+	mdelay(5);
+	regw_bl(0x00, CCDCMUX);	/*CCDC input Mux select directly from sensor */
+	mdelay(5);
+	clkctrl = regr_clk(CLKCTRL);
+	clkctrl &= 0x3f;
+	clkctrl |= 0x40;
+	mdelay(5);
+	regw_clk(clkctrl, CLKCTRL);
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_reset...");
+}
+
+/*                                                       
+ * ======== ccdc_setwin  ========                        
+ */
+/*This function will configure the window size to be capture in CCDC reg */
+void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int mid_img = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;
+
+	/*Writing the horizontal info into the registers */
+	mdelay(5);
+	regw(horz_start & START_PX_HOR_MASK, SPH);
+	mdelay(5);
+	regw(horz_nr_pixels & NUM_PX_HOR_MASK, NPH);
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		/* configure VDINT0 and VDINT1 */
+		regw(vert_start, VDINT0);
+	} else {
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		mid_img = vert_start + (image_win->height / 2);
+		regw(vert_start, VDINT0);
+		regw(mid_img, VDINT1);
+	}
+	mdelay(5);
+	regw(vert_start & START_VER_ONE_MASK, SLV0);
+	mdelay(5);
+	regw(vert_start & START_VER_TWO_MASK, SLV1);
+	mdelay(5);
+	regw(vert_nr_lines & NUM_LINES_VER, NLV);
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_setwin...");
+}
+
+#if 0
+void ccdc_config_stillcapture(void *arg)
+{
+	ccdc_params_raw *params;
+	params = (ccdc_params_raw *) arg;
+	ccdc_config_raw(params);
+
+	/***/
+	regw(0x63, HDWIDTH);
+	regw(0x8, VDWIDTH);
+	regw(0x11c5, PPLN);
+	regw(0x947, LPFR);
+	regw(2, LSCCFG2);
+	/***/
+
+	regw(0xFFFF, CULH);
+	regw(0x159, HSIZE);
+	regw(0x100, RYEGAIN);
+	regw(0x100, GRCYGAIN);
+	regw(0x100, GBGGAIN);
+	regw(0x100, BMGGAIN);
+	regw(0x64, VDINT0);
+	regw(0x1e, VDINT1);
+	regw(0x9, GAMMAWD);
+	regw(0x20, FMTCFG);
+	regw(0x0, CCDCFG);
+
+}
+#endif
+
+/* following function is just for the reference, check the registers value , 
+not used any where */
+void ccdc_config_stillcapture1(void *arg)
+{
+	__REG(0x01C70600) = 0x00000000;
+	__REG(0x01C70604) = 0x00000800;
+	__REG(0x01C70608) = 0x00000063;
+	__REG(0x01C7060c) = 0x00000008;
+	__REG(0x01C70610) = 0x000011c5;
+	__REG(0x01C70614) = 0x00000947;
+	__REG(0x01C70618) = 0x0000037a;
+	__REG(0x01C7061c) = 0x00000e5f;
+	__REG(0x01C70620) = 0x00000037;
+	__REG(0x01C70624) = 0x00000037;
+	__REG(0x01C70628) = 0x00000395;
+	__REG(0x01C7062c) = 0x0000ffff;
+	__REG(0x01C70630) = 0x000000FF;
+	__REG(0x01C70634) = 0x00000159;
+	__REG(0x01C70638) = 0x00000000;
+	__REG(0x01C70644) = 0x00000000;
+	__REG(0x01C70648) = 0x00000000;
+	__REG(0x01C7064c) = 0x00004E4E;
+	__REG(0x01C70650) = 0x00000000;
+	__REG(0x01C70654) = 0x00000000;
+	__REG(0x01C70658) = 0x00000000;
+	__REG(0x01C7065c) = 0x00000100;
+	__REG(0x01C70660) = 0x00000100;
+	__REG(0x01C70664) = 0x00000100;
+	__REG(0x01C70668) = 0x00000100;
+	__REG(0x01C7066c) = 0x00000000;
+	__REG(0x01C70670) = 0x00003FFF;
+	__REG(0x01C70674) = 0x00000064;
+	__REG(0x01C70678) = 0x0000001e;
+	__REG(0x01C7067c) = 0x00000000;
+	__REG(0x01C70680) = 0x00000009;
+	__REG(0x01C70684) = 0x00000000;
+	__REG(0x01C70688) = 0x00000000;
+	__REG(0x01C7068c) = 0x00000020;
+	__REG(0x01C70690) = 0x00007722;
+	__REG(0x01C70694) = 0x0000036e;
+	__REG(0x01C70698) = 0x00000e57;
+	__REG(0x01C7069c) = 0x00000100;
+	__REG(0x01C706a0) = 0x00000395;
+	__REG(0x01C706a4) = 0x000004c7;
+	__REG(0x01C706a8) = 0x000004d2;
+	__REG(0x01C706ac) = 0x00000000;
+	__REG(0x01C706b0) = 0x00002000;
+	__REG(0x01C706b4) = 0x00004000;
+	__REG(0x01C706b8) = 0x00000000;
+	__REG(0x01C706bc) = 0x00000000;
+	__REG(0x01C706c0) = 0x00000000;
+	__REG(0x01C706c4) = 0x00000000;
+	__REG(0x01C706c8) = 0x00000000;
+	__REG(0x01C706cc) = 0x00000007;
+	__REG(0x01C706d0) = 0x00000007;
+	__REG(0x01C706d4) = 0x00000210;
+	__REG(0x01C706d8) = 0x00000000;
+	__REG(0x01C706dc) = 0x00000000;
+	__REG(0x01C706e0) = 0x00000000;
+	__REG(0x01C706e4) = 0x00000210;
+	__REG(0x01C706e8) = 0x00000000;
+	__REG(0x01C706ec) = 0x00000000;
+	__REG(0x01C706f0) = 0x00000000;
+	__REG(0x01C706f4) = 0x00000000;
+	__REG(0x01C706f8) = 0x00000002;
+	__REG(0x01C706fc) = 0x00000000;
+	__REG(0x01C70700) = 0x00000000;
+	__REG(0x01C70704) = 0x00000000;
+	__REG(0x01C70708) = 0x00000000;
+
+}
+
+/*This function will configure CCDC for YCbCr parameters*/
+void ccdc_config_ycbcr()
+{
+	u32 modeset;
+	ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_ycbcr...");
+	mdelay(5);
+	ccdc_reset();
+
+	/* configure pixel format */
+	modeset = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	modeset |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+		mdelay(5);
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		modeset |= 0x04;
+	} else {		/* y/c external sync mode */
+		modeset |= ((params->fid_pol & 0x1) << 4);
+		modeset |= ((params->hd_pol & 0x1) << 3);
+		modeset |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* pack the data to 8-bit */
+	modeset |= 0x1 << 11;
+
+	regw(modeset, MODESET);
+	mdelay(5);
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+	mdelay(5);
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8040, CCDCFG);
+	mdelay(5);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((((params->win.width * 2) + 31) & 0xffffffe0) >> 5), HSIZE);
+	mdelay(5);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+		mdelay(5);
+	}
+	/*val = (unsigned int)ccdc_sbl_reset();
+	   dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val); */
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_config_ycbcr...\n");
+	/*ccdc_readregs(); */
+}
+
+/*                                                        
+ * ======== ccdc_config_raw  ========                   
+ */
+/*This function will configure CCDC for Raw mode parameters*/
+void ccdc_config_raw()
+{
+	ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int mode_set = 0;
+	unsigned int val = 0, val1 = 0;
+	int temp1 = 0, temp2 = 0, i = 0, fmtreg_v = 0, shift_v = 0, flag = 0;
+	int temp_gf = 0, temp_lcs = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	mdelay(5);
+	ccdc_reset();
+
+	/*
+	 *      C O N F I G U R I N G  T H E  C C D C F G  R E G I S T E R
+	 */
+
+	/*Set CCD Not to swap input since input is RAW data */
+	val |= CCDC_YCINSWP_RAW;
+
+	/*set FID detection function to Latch at V-Sync */
+	val |= CCDC_CCDCFG_FIDMD_LATCH_VSYNC << CCDC_CCDCFG_FIDMD_SHIFT;
+
+	/*set WENLOG - ccdc valid area */
+	val |= CCDC_CCDCFG_WENLOG_AND << CCDC_CCDCFG_WENLOG_SHIFT;
+
+	/*set TRGSEL */
+	val |= CCDC_CCDCFG_TRGSEL_WEN << CCDC_CCDCFG_TRGSEL_SHIFT;
+
+	/*set EXTRG */
+	val |= CCDC_CCDCFG_EXTRG_DISABLE << CCDC_CCDCFG_EXTRG_SHIFT;
+
+	/* Disable latching function registers on VSYNC-busy writable
+	   registers  */
+	/*regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG); */
+
+	/* Enable latching function registers on VSYNC-shadowed registers */
+	val |= CCDC_LATCH_ON_VSYNC_DISABLE;
+	mdelay(5);
+	regw(val, CCDCFG);
+	/*
+	 *      C O N F I G U R I N G  T H E  M O D E S E T  R E G I S T E R
+	 */
+
+	/*Set VDHD direction to input */
+	mode_set |=
+	    (CCDC_VDHDOUT_INPUT & CCDC_VDHDOUT_MASK) << CCDC_VDHDOUT_SHIFT;
+
+	/*Set input type to raw input */
+	mode_set |=
+	    (CCDC_RAW_IP_MODE & CCDC_RAW_INPUT_MASK) << CCDC_RAW_INPUT_SHIFT;
+
+	/*      Configure the vertical sync polarity(MODESET.VDPOL) */
+	mode_set = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (MODESET.HDPOL) */
+	mode_set |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (MODESET.FLDPOL) */
+	mode_set |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/*      Configure data polarity */
+	mode_set |=
+	    (CCDC_DATAPOL_NORMAL & CCDC_DATAPOL_MASK) << CCDC_DATAPOL_SHIFT;
+
+	/*      Configure External WEN Selection */
+	mode_set |= (CCDC_EXWEN_DISABLE & CCDC_EXWEN_MASK) << CCDC_EXWEN_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	mode_set |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	mode_set |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		mode_set |= CCDC_DATA_PACK_ENABLE;
+	}
+
+	/*Configure for LPF */
+	if (params->lpf_enable) {
+		mode_set |=
+		    (params->lpf_enable & CCDC_LPF_MASK) << CCDC_LPF_SHIFT;
+	}
+
+	/*Configure the data shift */
+	mode_set |= (params->datasft & CCDC_DATASFT_MASK) << CCDC_DATASFT_SHIFT;
+	mdelay(5);
+	regw(mode_set, MODESET);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to MODESET...\n", mode_set);
+
+	/*Configure the Median Filter threshold */
+	mdelay(5);
+	regw((params->med_filt_thres) & 0x3fff, MEDFILT);
+
+	/*
+	 *      C O N F I G U R E   T H E   G A M M A W D   R E G I S T E R
+	 */
+
+	val = 8;
+	val |=
+	    (CCDC_CFA_MOSAIC & CCDC_GAMMAWD_CFA_MASK) << CCDC_GAMMAWD_CFA_SHIFT;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val |= (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK) << 2;
+		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
+	}
+
+	/*Configure Median filter1 for IPIPE capture */
+	val |= params->mfilt1 << CCDC_MFILT1_SHIFT;
+
+	/*Configure Median filter2 for SDRAM capture */
+	val |= params->mfilt2 << CCDC_MFILT2_SHIFT;
+
+	mdelay(5);
+	regw(val, GAMMAWD);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to GAMMAWD...\n", val);
+
+	/* configure video window */
+	mdelay(5);
+	ccdc_setwin(&params->win, params->frm_fmt, 1);
+
+	/*
+	 *      O P T I C A L   B L A C K   A V E R A G I N G
+	 */
+	val = 0;
+	if (params->blk_clamp.b_clamp_enable) {
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK);
+
+		val1 |= (params->blk_clamp.sample_ln & CCDC_NUM_LINE_CALC_MASK)
+		    << CCDC_NUM_LINE_CALC_SHIFT;	/*No of line
+							   to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;	/*No of pixel/line to be avg */
+		val |= CCDC_BLK_CLAMP_ENABLE;	/*Enable the Black clamping */
+		mdelay(5);
+		regw(val, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to CLAMP...\n", val);
+		mdelay(5);
+		regw(val1, DCSUB);	/*If Black clamping is enable
+					   then make dcsub 0 */
+		dev_dbg(vpfe_dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		mdelay(5);
+		regw(val, DCSUB);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to DCSUB...\n", val);
+		mdelay(5);
+		regw(0x0000, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*
+	 *  C O N F I G U R E   B L A C K   L E V E L   C O M P E N S A T I O N
+	 */
+	val = 0;
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	mdelay(5);
+	regw(val, BLKCMP1);
+
+	val1 = 0;
+	val1 |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val1 |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+	mdelay(5);
+	regw(val1, BLKCMP0);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP1...\n", val);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP0...\n", val1);
+
+	/* Configure Vertical Defect Correction if needed */
+	if (params->vertical_dft.ver_dft_en) {
+
+		shift_v = 0;
+		shift_v = 0 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		shift_v |=
+		    params->vertical_dft.gen_dft_en & CCDC_DFCCTL_GDFCEN_MASK;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcsl & CCDC_DFCCTL_VDFCSL_MASK) <<
+		    CCDC_DFCCTL_VDFCSL_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcuda & CCDC_DFCCTL_VDFCUDA_MASK) <<
+		    CCDC_DFCCTL_VDFCUDA_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdflsft & CCDC_DFCCTL_VDFLSFT_MASK) <<
+		    CCDC_DFCCTL_VDFLSFT_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCCTL);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_vert[0], DFCMEM0);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_horz[0], DFCMEM1);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub1[0], DFCMEM2);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub2[0], DFCMEM3);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub3[0], DFCMEM4);
+
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 1 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		shift_v |= 1;
+		mdelay(5);
+		regw(shift_v, DFCMEMCTL);
+
+		while (1) {
+			flag = regr(DFCMEMCTL);
+			if ((flag & 0x01) == 0x00)
+				break;
+		}
+		flag = 0;
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 0 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCMEMCTL);
+
+		for (i = 1; i < 16; i++) {
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_vert[i], DFCMEM0);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_horz[i], DFCMEM1);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub1[i], DFCMEM2);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub2[i], DFCMEM3);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub3[i], DFCMEM4);
+
+			shift_v = 0;
+			shift_v = regr(DFCMEMCTL);
+			shift_v |= 1;
+			mdelay(5);
+			regw(shift_v, DFCMEMCTL);
+
+			while (1) {
+				mdelay(5);
+				flag = regr(DFCMEMCTL);
+				if ((flag & 0x01) == 0x00)
+					break;
+			}
+			flag = 0;
+		}
+		mdelay(5);
+		regw(params->vertical_dft.
+		     saturation_ctl & CCDC_VDC_DFCVSAT_MASK, DFCVSAT);
+
+		shift_v = 0;
+		shift_v = regr(DFCCTL);
+		shift_v |= 1 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCCTL);
+	}
+
+	/* Configure Lens Shading Correction if needed */
+	if (params->lens_sh_corr.lsc_enable) {
+		dev_dbg(vpfe_dev, "\nlens shading Correction entered....\n");
+
+		/*first disable the LSC */
+		mdelay(5);
+		regw(CCDC_LSC_DISABLE, LSCCFG1);
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 1 */
+
+		/*select table 1 */
+		mdelay(5);
+		regw(CCDC_LSC_TABLE1_SLC, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 1 - u8q8 */
+		temp_gf =
+		    ((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		    & CCDC_LSC_FRAC_MASK_T1;
+		temp_gf |=
+		    (((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		     & CCDC_LSC_FRAC_MASK_T1) << 8;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 2; i < 255; i += 2) {
+			temp_gf = 0;
+			temp_gf = ((int)
+				   (params->lens_sh_corr.gf_table1[0].frac_no *
+				    256))
+			    & CCDC_LSC_FRAC_MASK_T1;
+			temp_gf |= (((int)
+				     (params->lens_sh_corr.gf_table1[0].
+				      frac_no * 256))
+				    & CCDC_LSC_FRAC_MASK_T1) << 8;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 2 */
+
+		/*select table 2 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE2_SLC;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table2[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table2[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				mdelay(5);
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 3 */
+
+		/*select table 3 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE3_SLC;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table3[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			mdelay(5);
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		mdelay(5);
+		temp_lcs = regr(LSCMEMCTL);
+		mdelay(5);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table3[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				mdelay(5);
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+		/*Configuring the optical centre of the lens */
+		mdelay(5);
+		regw(params->lens_sh_corr.
+		     lens_center_horz & CCDC_LSC_CENTRE_MASK, LSCH0);
+		mdelay(5);
+		regw(params->lens_sh_corr.
+		     lens_center_vert & CCDC_LSC_CENTRE_MASK, LSCV0);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.horz_left_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.horz_left_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.horz_right_coef.frac_no * 128))
+		     & 0x7f) << 8;
+		val |=
+		    (params->lens_sh_corr.horz_right_coef.int_no & 0x01) << 15;
+		mdelay(5);
+		regw(val, LSCKH);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.ver_up_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.ver_up_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.ver_low_coef.frac_no * 128)) &
+		     0x7f) << 8;
+		val |= (params->lens_sh_corr.ver_low_coef.int_no & 0x01) << 15;
+		mdelay(5);
+		regw(val, LSCKV);
+
+		/*configuring the lsc configuration register 2 */
+		temp_lcs = 0;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_scaling_fact & CCDC_LSCCFG_GFTSF_MASK) <<
+		    CCDC_LSCCFG_GFTSF_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_interval & CCDC_LSCCFG_GFTINV_MASK) <<
+		    CCDC_LSCCFG_GFTINV_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPOL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPOL_SHIFT;
+		mdelay(5);
+		regw(temp_lcs, LSCCFG2);
+
+		/*configuring the LSC configuration register 1 */
+		temp_lcs = 0;
+		temp_lcs |= CCDC_LSC_ENABLE;
+		temp_lcs |= (params->lens_sh_corr.lsc_config.gfmode &
+			     CCDC_LSC_GFMODE_MASK) << CCDC_LSC_GFMODE_SHIFT;
+		mdelay(5);
+		regw(temp_lcs, LSCCFG1);
+	}
+
+	/* Configure data formatter if needed */
+	if (params->data_formatter_r.fmt_enable
+	    && (!params->color_space_con.csc_enable)) {
+		dev_dbg(vpfe_dev,
+			"\ndata formatter will be configured now....\n");
+
+		/*Configuring the FMTPLEN */
+		fmtreg_v = 0;
+		fmtreg_v |=
+		    (params->data_formatter_r.fmtplen.
+		     plen0 & CCDC_FMTPLEN_P0_MASK);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen1 & CCDC_FMTPLEN_P1_MASK)
+		     << CCDC_FMTPLEN_P1_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen2 & CCDC_FMTPLEN_P2_MASK)
+		     << CCDC_FMTPLEN_P2_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen3 & CCDC_FMTPLEN_P3_MASK)
+		     << CCDC_FMTPLEN_P3_SHIFT);
+		mdelay(5);
+		regw(fmtreg_v, FMTPLEN);
+
+		/*Configurring the FMTSPH */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtsph & CCDC_FMTSPH_MASK),
+		     FMTSPH);
+
+		/*Configurring the FMTLNH */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtlnh & CCDC_FMTLNH_MASK),
+		     FMTLNH);
+
+		/*Configurring the FMTSLV */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtslv & CCDC_FMTSLV_MASK),
+		     FMTSLV);
+
+		/*Configurring the FMTLNV */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtlnv & CCDC_FMTLNV_MASK),
+		     FMTLNV);
+
+		/*Configurring the FMTRLEN */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtrlen & CCDC_FMTRLEN_MASK),
+		     FMTRLEN);
+
+		/*Configurring the FMTHCNT */
+		mdelay(5);
+		regw((params->data_formatter_r.fmthcnt & CCDC_FMTHCNT_MASK),
+		     FMTHCNT);
+
+		/*Configuring the FMTADDR_PTR */
+		for (i = 0; i < 8; i++) {
+			fmtreg_v = 0;
+
+			if (params->data_formatter_r.fmtaddr_ptr[i].init >
+			    (params->data_formatter_r.fmtrlen - 1)) {
+				dev_dbg(vpfe_dev,
+					"\nInvalid init parameter for FMTADDR_PTR....\n");
+				return;
+			}
+
+			fmtreg_v =
+			    (params->data_formatter_r.fmtaddr_ptr[i].
+			     init & CCDC_ADP_INIT_MASK);
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtaddr_ptr[i].
+			      line & CCDC_ADP_LINE_MASK) <<
+			     CCDC_ADP_LINE_SHIFT);
+			mdelay(5);
+			regw(fmtreg_v, FMT_ADDR_PTR(i));
+		}
+
+		/*Configuring the FMTPGM_VF0 */
+		fmtreg_v = 0;
+		for (i = 0; i < 16; i++) {
+			fmtreg_v |= params->data_formatter_r.pgm_en[i] << i;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_VF0);
+
+		/*Configuring the FMTPGM_VF1 */
+		fmtreg_v = 0;
+		for (i = 16; i < 32; i++) {
+			fmtreg_v |=
+			    params->data_formatter_r.pgm_en[i] << (i - 16);
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_VF1);
+
+		/*Configuring the FMTPGM_AP0 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 0; i < 4; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP0);
+
+		/*Configuring the FMTPGM_AP1 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 4; i < 8; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP1);
+
+		/*Configuring the FMTPGM_AP2 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 8; i < 12; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP2);
+
+		/*Configuring the FMTPGM_AP3 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 12; i < 16; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP3);
+
+		/*Configuring the FMTPGM_AP4 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 16; i < 20; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP4);
+
+		/*Configuring the FMTPGM_AP5 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 20; i < 24; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP5);
+
+		/*Configuring the FMTPGM_AP6 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 24; i < 28; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP6);
+
+		/*Configuring the FMTPGM_AP7 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 28; i < 32; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP7);
+
+		/*Configuring the FMTCFG register */
+		fmtreg_v = 0;
+		fmtreg_v = CCDC_DF_ENABLE;
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      fmtmode & CCDC_FMTCFG_FMTMODE_MASK)
+		     << CCDC_FMTCFG_FMTMODE_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      lnum & CCDC_FMTCFG_LNUM_MASK)
+		     << CCDC_FMTCFG_LNUM_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      addrinc & CCDC_FMTCFG_ADDRINC_MASK)
+		     << CCDC_FMTCFG_ADDRINC_SHIFT);
+		mdelay(5);
+		regw(fmtreg_v, FMTCFG);
+
+	} else if (params->data_formatter_r.fmt_enable) {
+		dev_dbg(vpfe_dev,
+			"\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/*
+	 *      C O N F I G U R E   C O L O R   S P A C E   C O N V E R T E R
+	 */
+
+	if ((params->color_space_con.csc_enable)
+	    && (!params->data_formatter_r.fmt_enable)) {
+		dev_dbg(vpfe_dev, "\nconfiguring the CSC Now....\n");
+
+		/*Enable the CSC sub-module */
+		mdelay(5);
+		regw(CCDC_CSC_ENABLE, CSCCTL);
+
+		/*Converting the co-eff as per the format of the register */
+		for (i = 0; i < 16; i++) {
+			temp1 = params->color_space_con.csc_dec_coeff[i];
+			/*Masking the data for 3 bits */
+			temp1 &= CCDC_CSC_COEFF_DEC_MASK;
+			/*Recovering the fractional part and converting to
+			   binary of 5 bits */
+			temp2 =
+			    (int)(params->color_space_con.csc_frac_coeff[i] *
+				  (32 / 10));
+			temp2 &= CCDC_CSC_COEFF_FRAC_MASK;
+			/*shifting the decimal to the MSB */
+			temp1 = temp1 << CCDC_CSC_DEC_SHIFT;
+			temp1 |= temp2;	/*appending the fraction at LSB */
+			params->color_space_con.csc_dec_coeff[i] = temp1;
+		}
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[0], CSCM0);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[1] << CCDC_CSC_COEFF_SHIFT, CSCM0);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[2], CSCM1);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[3] << CCDC_CSC_COEFF_SHIFT, CSCM1);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[4], CSCM2);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[5] << CCDC_CSC_COEFF_SHIFT, CSCM2);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[6], CSCM3);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[7] << CCDC_CSC_COEFF_SHIFT, CSCM3);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[8], CSCM4);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[9] << CCDC_CSC_COEFF_SHIFT, CSCM4);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[10], CSCM5);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[11] << CCDC_CSC_COEFF_SHIFT, CSCM5);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[12], CSCM6);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[13] << CCDC_CSC_COEFF_SHIFT, CSCM6);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[14], CSCM7);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[15] << CCDC_CSC_COEFF_SHIFT, CSCM7);
+
+	} else if (params->color_space_con.csc_enable) {
+		dev_err(vpfe_dev,
+			"\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/*Configure the offset control */
+	if (params->ccdc_offset) {
+		if (params->ccdc_offset < 1024) {
+			mdelay(5);
+			regw(params->ccdc_offset & CCDC_OFFSET_MASK, OFFSET);
+		} else
+			dev_err(vpfe_dev, "\ninvalid offset value....\n");
+	}
+
+	/*
+	 *      C O N F I G U R E  C O L O R  P A T T E R N  A S
+	 *      P E R  N N 1 2 8 6 A  S E N S O R
+	 */
+	mdelay(5);
+	regw(0x4E4E, COLPTN);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x4e4e to COLPTN...\n");
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->data_offset_s.
+	     horz_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_H_SHIFT;
+	val |=
+	    (params->data_offset_s.
+	     vert_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_V_SHIFT;
+	mdelay(5);
+	regw(val, DATAOFST);
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->
+	     horz_flip_enable & CCDC_HSIZE_FLIP_MASK) << CCDC_HSIZE_FLIP_SHIFT;
+
+	/* If pack 8 is enable then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		val |= (((params->win.width) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to HSIZE...\n",
+			(((params->win.width) + 31) >> 5) & 0x0fff);
+	} else {		/* else one pixel will take 2 byte */
+
+		val |= (((params->win.width * 2) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to HSIZE...\n",
+			(((params->win.width * 2) + 31) >> 5) & 0x0fff);
+	}
+	mdelay(5);
+	regw(val, HSIZE);
+
+	/*
+	 *      C O N F I G U R E   S D O F S T  R E G I S T E R
+	 */
+
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For interlace inverse mode */
+			mdelay(5);
+			regw(0x4B6D, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For interlace non inverse mode */
+			regw(0x0B6D, SDOFST);
+			mdelay(5);
+			dev_dbg(vpfe_dev, "\nWriting 0x0B6D to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		if (params->image_invert_enable) {
+			/* For progessive inverse mode */
+			mdelay(5);
+			regw(0x4000, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4000 to SDOFST...\n");
+		}
+
+		else {
+			/* For progessive non inverse mode */
+			mdelay(5);
+			regw(0x0000, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x0000 to SDOFST...\n");
+		}
+
+	}
+
+	/*
+	 *      C O N F I G U R E   I N T E R R U P T   R E G I S T E R S
+	 */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		val = params->win.height / 2;
+		mdelay(5);
+		regw(136, VDINT0);
+		regw(149, VDINT0);
+		mdelay(5);
+		regw(0, VDINT1);
+	} else {
+		mdelay(5);
+		regw(0, VDINT0);
+		mdelay(5);
+		regw(0, VDINT1);
+	}
+
+	dev_dbg(vpfe_dev, "\nend of ccdc_config_raw...");
+	/*ccdc_readregs(); */
+}
+
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam)
+{
+	if (ccdcparam->pix_fmt != 0) {
+		dev_err(vpfe_dev,
+			"Invalid value of pix_fmt, other than RAW data input is \
+ not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->frm_fmt != 0) {
+		dev_err(vpfe_dev,
+			"Other than Progressive fram format is not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->fid_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->fid_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of field id polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->vd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->vd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of VD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->hd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->hd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of HD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->datasft < NO_SHIFT || ccdcparam->datasft > _6BIT) {
+		dev_err(vpfe_dev, "Invalid value of data shift\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt1 < NO_MEDIAN_FILTER1
+	    || ccdcparam->mfilt1 > MEDIAN_FILTER1) {
+		dev_err(vpfe_dev, "Invalid value of median filter1\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt2 < NO_MEDIAN_FILTER2
+	    || ccdcparam->mfilt2 > MEDIAN_FILTER2) {
+		dev_err(vpfe_dev, "Invalid value of median filter2\n");
+		return -1;
+	}
+
+	if (ccdcparam->ccdc_offset < 0 || ccdcparam->ccdc_offset > 1023) {
+		dev_err(vpfe_dev, "Invalid value of offset\n");
+		return -1;
+	}
+
+	if (ccdcparam->med_filt_thres < 0 || ccdcparam->med_filt_thres > 0x3FFF) {
+		dev_err(vpfe_dev, "Invalid value of median filter thresold\n");
+		return -1;
+	}
+
+	if (ccdcparam->data_sz < _16BITS || ccdcparam->data_sz > _8BITS) {
+		dev_err(vpfe_dev, "Invalid value of data size\n");
+		return -1;
+	}
+
+	if (ccdcparam->alaw.b_alaw_enable) {
+		if (ccdcparam->alaw.gama_wd < BITS_13_4
+		    || ccdcparam->alaw.gama_wd > BITS_09_0) {
+			dev_err(vpfe_dev, "Invalid value of ALAW\n");
+			return -1;
+		}
+	}
+
+	if (ccdcparam->blk_clamp.b_clamp_enable) {
+		if (ccdcparam->blk_clamp.sample_pixel < _1PIXELS
+		    && ccdcparam->blk_clamp.sample_pixel > _16PIXELS) {
+			dev_err(vpfe_dev, "Invalid value of sample pixel\n");
+			return -1;
+		}
+		if (ccdcparam->blk_clamp.sample_ln < _1LINES
+		    && ccdcparam->blk_clamp.sample_ln > _16LINES) {
+			dev_err(vpfe_dev, "Invalid value of sample lines\n");
+			return -1;
+		}
+
+	}
+
+	if (ccdcparam->vertical_dft.ver_dft_en) {
+		dev_err(vpfe_dev, "Defect correction is not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->lens_sh_corr.lsc_enable) {
+		dev_err(vpfe_dev,
+			"Lens shadding correction is not supported\n");
+		return -1;
+	}
+	if (ccdcparam->color_space_con.csc_enable) {
+		dev_err(vpfe_dev, "Color Space converter not supported\n");
+		return -1;
+	}
+	return 0;
+}
Index: linux-2.6.10/drivers/media/video/davinci/davinci_display.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_display.c
@@ -0,0 +1,1889 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davinci_display.c */
+
+/*#define DEBUG */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/arch/cpu.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/davinci_display.h>
+
+#define DAVINCI_DISPLAY_DRIVER "DavinciDisplay"
+#define DM355_EVM_CARD  "DM355 EVM"
+#define DM644X_EVM_CARD "DM644X EVM"
+
+static u32 video2_numbuffers = 3;
+static u32 video3_numbuffers = 3;
+
+#define DAVINCI_DISPLAY_HD_BUF_SIZE (1920*1088*2)
+#define DAVINCI_DISPLAY_SD_BUF_SIZE (720*576*2)
+
+#ifdef FB_DAVINCI_THS8200_ENCODER
+static u32 video2_bufsize = DAVINCI_DISPLAY_HD_BUF_SIZE;
+#else
+static u32 video2_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+#endif
+static u32 video3_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+
+module_param(video2_numbuffers, uint, S_IRUGO);
+module_param(video3_numbuffers, uint, S_IRUGO);
+
+module_param(video2_bufsize, uint, S_IRUGO);
+module_param(video3_bufsize, uint, S_IRUGO);
+
+#define DAVINCI_DEFAULT_NUM_BUFS 3
+static struct buf_config_params display_buf_config_params = {
+	.min_numbuffers = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[0] = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[1] = DAVINCI_DEFAULT_NUM_BUFS,
+	.min_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.min_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#ifdef CONFIG_DAVINCI_THS8200_ENCODER
+	.layer_bufsize[0] = DAVINCI_DISPLAY_HD_BUF_SIZE,
+	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#else
+	.layer_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#endif
+};
+
+static int davinci_display_nr[] = { 2, 3 };
+
+/* global variables */
+static struct davinci_display davinci_dm;
+
+struct device *davinci_display_dev = NULL;
+
+static struct v4l2_capability davinci_display_videocap = {
+	.driver = DAVINCI_DISPLAY_DRIVER,
+	.bus_info = "Platform",
+	.version = DAVINCI_DISPLAY_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING
+};
+
+static struct v4l2_fract ntsc_aspect = DAVINCI_DISPLAY_PIXELASPECT_NTSC;
+static struct v4l2_fract pal_aspect = DAVINCI_DISPLAY_PIXELASPECT_PAL;
+static struct v4l2_fract sp_aspect = DAVINCI_DISPLAY_PIXELASPECT_SP;
+
+static struct v4l2_rect ntsc_bounds = DAVINCI_DISPLAY_WIN_NTSC;
+static struct v4l2_rect pal_bounds = DAVINCI_DISPLAY_WIN_PAL;
+static struct v4l2_rect vga_bounds = DAVINCI_DISPLAY_WIN_640_480;
+static struct v4l2_rect hd_720p_bounds = DAVINCI_DISPLAY_WIN_720P;
+static struct v4l2_rect hd_1080i_bounds = DAVINCI_DISPLAY_WIN_1080I;
+
+/*
+ *=====davinci_alloc_buffer=====*/
+/* Allocate memory for buffers */
+static inline unsigned long davinci_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/*
+ *=====davinci_free_buffer=====*/
+/* Free memory for buffers */
+static inline void davinci_free_buffer(unsigned long addr,
+				       unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*
+ * ===== davinci_uservirt_to_phys =====
+ *
+ * This inline function is used to convert user space virtual address
+ * to physical address.
+ */
+static inline u32 davinci_uservirt_to_phys(u32 virt)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte;
+
+	struct mm_struct *mm = current->mm;
+	pgd = pgd_offset(mm, virt);
+	if (!(pgd_none(*pgd) || pgd_bad(*pgd))) {
+		pmd = pmd_offset(pgd, virt);
+
+		if (!(pmd_none(*pmd) || pmd_bad(*pmd))) {
+			pte = pte_offset_kernel(pmd, virt);
+
+			if (pte_present(*pte)) {
+				return __pa(page_address(pte_page(*pte))
+					    + (virt & ~PAGE_MASK));
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * =====buffer_prepare=====*/
+/* This is the callback function called from videobuf_qbuf() function
+ * the buffer is prepared and user space virtual address is converted into
+ * physical address */
+static int davinci_buffer_prepare(struct videobuf_queue *q,
+				  struct videobuf_buffer *vb,
+				  enum v4l2_field field)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_prepare>\n");
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = davinci_dm.mode_info.xres;
+		vb->height = davinci_dm.mode_info.yres;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == layer->memory) {
+		vb->boff = davinci_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(davinci_display_dev, "buffer_prepare:offset is \
+				not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	dev_dbg(davinci_display_dev, "</davinci_buffer_prepare>\n");
+	return 0;
+}
+
+/*
+ * =====davinci_buffer_config=====*/
+/* This function is responsible to responsible for buffer's
+ * physical address */
+static void davinci_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	int i;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_config>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((void *)layer->fbuffers[i]);
+		dev_dbg(davinci_display_dev, "buffer address: %x\n",
+			q->bufs[i]->boff);
+	}
+	dev_dbg(davinci_display_dev, "</davinci_buffer_config>\n");
+}
+
+/*
+ * =====davinci_buffer_setup=====*/
+/* This function allocates memory for the buffers */
+static int davinci_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+				unsigned int *size)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	int i;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_setup>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return 0;
+	}
+
+	/* Calculate the size of the buffer */
+	*size = display_buf_config_params.layer_bufsize[layer->device_id];
+
+	for (i = display_buf_config_params.numbuffers[layer->device_id];
+	     i < *count; i++) {
+		/* Allocate memory for the buffers */
+		layer->fbuffers[i] = davinci_alloc_buffer(*size);
+		if (!layer->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = layer->numbuffers = i;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_setup>\n");
+	return 0;
+}
+
+/*
+ * =====davinci_buffer_queue=====*/
+/* This function adds the buffer to DMA queue  */
+static void davinci_buffer_queue(struct videobuf_queue *q,
+				 struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_queue>\n");
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &layer->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_queue>\n");
+}
+
+/*
+ * =====davinci_buffer_release=====*/
+/* This function is called from the videobuf layer to free memory allocated to
+ * the buffers */
+static void davinci_buffer_release(struct videobuf_queue *q,
+				   struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int buf_size = 0;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_release>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return;
+	}
+	/* Calculate the size of the buffer */
+	buf_size = display_buf_config_params.layer_bufsize[layer->device_id];
+
+	if (((vb->i < layer->numbuffers)
+	     && (vb->i >=
+		 display_buf_config_params.numbuffers[layer->device_id]))
+	    && layer->fbuffers[vb->i]) {
+		davinci_free_buffer(layer->fbuffers[vb->i], buf_size);
+		layer->fbuffers[vb->i] = 0;
+	}
+	vb->state = STATE_NEEDS_INIT;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = davinci_buffer_setup,
+	.buf_prepare = davinci_buffer_prepare,
+	.buf_queue = davinci_buffer_queue,
+	.buf_release = davinci_buffer_release,
+	.buf_config = davinci_buffer_config,
+};
+
+static u8 layer_first_int = 1;
+
+/* TBD */
+/* =====davinci_layer_isr=====*/
+/* It changes status of the displayed buffer, takes next buffer from the queue
+ * and sets its address in VPBE registers */
+/*
+static irqreturn_t davinci_display_isr(int irq, void *dispObj,
+				    struct pt_regs *regs)
+*/
+static void davinci_display_isr(unsigned int event, void *dispObj)
+{
+	unsigned long jiffies_time = get_jiffies_64();
+	struct timeval timevalue;
+	int i, fid;
+	unsigned long addr = 0;
+	struct display_obj *layer = NULL;
+	struct davinci_display *dispDevice = (struct davinci_display *)dispObj;
+
+	/* Convert time represention from jiffies to timeval */
+	jiffies_to_timeval(jiffies_time, &timevalue);
+
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		layer = dispDevice->dev[i];
+		/* If streaming is started in this layer */
+		if (!layer->started)
+			continue;
+		/* Check the field format */
+		if ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&
+		    (!list_empty(&layer->dma_queue)) &&
+		    (event & DAVINCI_DISP_END_OF_FRAME)) {
+			/* Progressive mode */
+			/* Progressive mode */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				continue;
+			} else {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				layer->curFrm->ts = timevalue;
+				layer->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				layer->curFrm = layer->nextFrm;
+			}
+			/* Get the next buffer from buffer queue */
+			layer->nextFrm =
+			    list_entry(layer->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&layer->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			layer->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+			addr = layer->curFrm->boff;
+			davinci_disp_start_layer(layer->layer_info.id, addr);
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				dev_dbg(davinci_display_dev,
+					"irq_first time\n");
+				return;
+			}
+
+			layer->field_id ^= 1;
+			if (event & DAVINCI_DISP_TOP_FIELD)
+				fid = 1;
+			else if (event & DAVINCI_DISP_BOTTOM_FIELD)
+				fid = 0;
+			else
+				return;
+
+			/* If field id does not match with stored
+			   field id */
+			if (fid != layer->field_id) {
+				/* Make them in sync */
+				if (0 == fid) {
+					layer->field_id = fid;
+					dev_dbg(davinci_display_dev,
+						"field synced\n");
+				}
+				return;
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (layer->curFrm == layer->nextFrm)
+					continue;
+				/* one frame is displayed If next frame is
+				 *  available, release curFrm and move on*/
+
+				/* Copy frame display time */
+				layer->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				dev_dbg(davinci_display_dev,
+					"Done with this video buffer\n");
+				layer->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				layer->curFrm = layer->nextFrm;
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&layer->dma_queue)
+				    || (layer->curFrm != layer->nextFrm))
+					continue;
+
+				/* one field is displayed configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				layer->nextFrm = list_entry(layer->
+							    dma_queue.
+							    next, struct
+							    videobuf_buffer,
+							    queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&layer->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				layer->nextFrm->state = STATE_ACTIVE;
+				addr = layer->nextFrm->boff;
+				davinci_disp_start_layer(layer->layer_info.id,
+							 addr);
+			}
+		}
+	}
+}
+
+static int davinci_check_format(struct display_obj *layer,
+				struct v4l2_pix_format *pixfmt)
+{
+	enum v4l2_field field = pixfmt->field;
+	struct vid_enc_mode_info *mode_info;
+	int temp_width = pixfmt->width, temp_height = pixfmt->height;
+	dev_dbg(davinci_display_dev, "<davinci_check_format, >\n");
+
+	if (layer->memory == V4L2_MEMORY_USERPTR) {
+		/* We use bytesperline to calculate the width of the image */
+		temp_width = pixfmt->bytesperline / 2;
+		temp_height = pixfmt->sizeimage / pixfmt->bytesperline;
+	}
+
+	dev_dbg(davinci_display_dev,
+		"<pixelformat = %x, height = %d, width = %d, field = %d >\n",
+		(unsigned int)pixfmt->pixelformat, (unsigned int)temp_height,
+		(unsigned int)temp_width, (unsigned int)pixfmt->field);
+
+	if (!(DAVINCI_DISPLAY_VALID_FIELD(field))) {
+		dev_err(davinci_display_dev,
+			"invalid frame format , field = %d\n", (int)field);
+		return -EINVAL;
+	}
+
+	if (pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) {
+		dev_err(davinci_display_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (temp_width && ((temp_width % 16) != 0)) {
+		/* must be a mutliple of 32 */
+		dev_err(davinci_display_dev,
+			"width should be a multiple of 16\n");
+		return -EINVAL;
+	}
+
+	if ((temp_height & 0x1) && (field == V4L2_FIELD_INTERLACED)) {
+		dev_err(davinci_display_dev,
+			"height should be even for interlaced mode\n");
+		return -EINVAL;
+	}
+
+	/* get the current video display mode from encoder manager */
+	mode_info = &davinci_dm.mode_info;
+	if (davinci_enc_get_mode(0, mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode from enc mngr\n");
+		return -1;
+	}
+
+	if ((0 == temp_width) || (temp_width > mode_info->xres) ||
+	    (0 == temp_height) || (temp_height > mode_info->yres)) {
+		dev_err(davinci_display_dev, "Invalid width or height\n");
+		return -EINVAL;
+	}
+
+	if (field == V4L2_FIELD_ANY) {
+		field = (mode_info->interlaced) ? V4L2_FIELD_INTERLACED :
+		    V4L2_FIELD_NONE;
+	}
+	if ((!mode_info->interlaced && (field == V4L2_FIELD_INTERLACED)) ||
+	    (mode_info->interlaced && (field == V4L2_FIELD_NONE))) {
+		dev_err(davinci_display_dev, "Invalid field\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(davinci_display_dev, "</davinci_check_format>\n");
+	return 0;
+}
+
+static int davinci_set_video_display_params(struct display_obj *layer)
+{
+	unsigned long addr;
+
+	addr = layer->curFrm->boff;
+	/* Set address in the display registers */
+	davinci_disp_start_layer(layer->layer_info.id, addr);
+	davinci_disp_enable_layer(layer->layer_info.id);
+	/* Enable the window */
+	layer->layer_info.enable = 1;
+	return 0;
+}
+static void davinci_disp_calculate_scale_factor(struct display_obj *layer,
+						int expected_xsize,
+						int expected_ysize)
+{
+	struct display_layer_info *layer_info = &layer->layer_info;
+	struct v4l2_pix_format *pixfmt = &layer->pix_fmt;
+	int h_scale = 0, v_scale = 0, h_exp = 0, v_exp = 0, temp;
+	/* Application initially set the image format. Current display
+	   size is obtained from the encoder manager. expected_xsize
+	   and expected_ysize are set through S_CROP ioctl. Based on this,
+	   driver will calculate the scale factors for vertical and
+	   horizontal direction so that the image is displayed scaled
+	   and expanded. Application uses expansion to display the image
+	   in a square pixel. Otherwise it is displayed using displays
+	   pixel aspect ratio.It is expected that application chooses
+	   the crop coordinates for cropped or scaled display. if crop
+	   size is less than the image size, it is displayed cropped or
+	   it is displayed scaled and/or expanded.
+	 */
+
+	/* to begin with, set the crop window same as expected. Later we
+	   will override with scaled window size
+	 */
+	layer->layer_info.config.xsize = pixfmt->width;
+	layer->layer_info.config.ysize = pixfmt->height;
+	layer_info->h_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->v_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->h_exp = H_EXP_OFF;	/* no horizontal zoom */
+	layer_info->v_exp = V_EXP_OFF;	/* no horizontal zoom */
+
+	if (pixfmt->width < expected_xsize) {
+		h_scale = davinci_dm.mode_info.xres / pixfmt->width;
+		if (h_scale < 2)
+			h_scale = 1;
+		else if (h_scale >= 4)
+			h_scale = 4;
+		else
+			h_scale = 2;
+		layer->layer_info.config.xsize *= h_scale;
+		if (layer->layer_info.config.xsize < expected_xsize) {
+			if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)
+			    || !strcmp(davinci_dm.mode_info.name,
+				       VID_ENC_STD_PAL)) {
+				temp =
+				    (layer->layer_info.config.xsize *
+				     DAVINCI_DISPLAY_H_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_H_EXP_RATIO_D;
+				if (temp <= expected_xsize) {
+					h_exp = 1;
+					layer->layer_info.config.xsize = temp;
+				}
+			}
+		}
+		if (h_scale == 2)
+			layer_info->h_zoom = ZOOM_X2;
+		else if (h_scale == 4)
+			layer_info->h_zoom = ZOOM_X4;
+		if (h_exp)
+			layer_info->h_exp = H_EXP_9_OVER_8;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.xsize = expected_xsize;
+	}
+
+	if (pixfmt->height < expected_ysize) {
+		v_scale = expected_ysize / pixfmt->height;
+		if (v_scale < 2)
+			v_scale = 1;
+		else if (v_scale >= 4)
+			v_scale = 4;
+		else
+			v_scale = 2;
+		layer->layer_info.config.ysize *= v_scale;
+		if (layer->layer_info.config.ysize < expected_ysize) {
+			if (!strcmp(davinci_dm.mode_info.name, "PAL")) {
+				temp =
+				    (layer->layer_info.config.ysize *
+				     DAVINCI_DISPLAY_V_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_V_EXP_RATIO_D;
+				if (temp <= expected_ysize) {
+					v_exp = 1;
+					layer->layer_info.config.ysize = temp;
+				}
+			}
+		}
+		if (v_scale == 2)
+			layer_info->v_zoom = ZOOM_X2;
+		else if (v_scale == 4)
+			layer_info->v_zoom = ZOOM_X4;
+		if (v_exp)
+			layer_info->h_exp = V_EXP_6_OVER_5;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.ysize = expected_ysize;
+	}
+	dev_dbg(davinci_display_dev,
+		"crop display xsize = %d, ysize = %d\n",
+		layer->layer_info.config.xsize, layer->layer_info.config.ysize);
+}
+
+static void davinci_disp_adj_position(struct display_obj *layer, int top,
+				      int left)
+{
+	layer->layer_info.config.xpos = 0;
+	layer->layer_info.config.ypos = 0;
+	if (left + layer->layer_info.config.xsize <= davinci_dm.mode_info.xres)
+		layer->layer_info.config.xpos = left;
+	if (top + layer->layer_info.config.ysize <= davinci_dm.mode_info.yres)
+		layer->layer_info.config.ypos = top;
+	dev_dbg(davinci_display_dev,
+		"new xpos = %d, ypos = %d\n",
+		layer->layer_info.config.xpos, layer->layer_info.config.ypos);
+}
+
+static int davinci_disp_check_window_params(struct v4l2_rect *c)
+{
+	if ((c->width == 0) || (c->width > davinci_dm.mode_info.xres) ||
+	    (c->height == 0) || (c->height > davinci_dm.mode_info.yres)) {
+		dev_err(davinci_display_dev, "Invalid window dimension\n");
+		return -1;
+	}
+	if ((c->width & 0xf)) {
+		dev_err(davinci_display_dev,
+			"window width must be a multiple of 16\n");
+		return -1;
+	}
+	if ((c->height & 0x1) && (davinci_dm.mode_info.interlaced)) {
+		dev_err(davinci_display_dev,
+			"window height must be even for interlaced display\n");
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * ======== davinci_doioctl ========*
+ * This function will provide different V4L2 commands.This function can be
+ * used to configure driver or get status of driver as per command passed
+ * by application */
+static int davinci_doioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int index = 0;
+	unsigned long addr, flags;
+	dev_dbg(davinci_display_dev, "<davinci_doioctl>\n");
+
+	/* Check for the priority */
+	switch (cmd) {
+	case VIDIOC_S_FMT:
+		ret = v4l2_prio_check(&layer->prio, &fh->prio);
+		if (0 != ret)
+			return ret;
+		break;
+	}
+
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(davinci_display_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QUERYCAP, layer id = %d\n",
+				layer->device_id);
+			memset(cap, 0, sizeof(*cap));
+			*cap = davinci_display_videocap;
+			break;
+		}
+
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cropcap =
+			    (struct v4l2_cropcap *)arg;
+			dev_dbg(davinci_display_dev,
+				"\nStart of VIDIOC_CROPCAP ioctl");
+			if (davinci_enc_get_mode(0, &davinci_dm.mode_info)) {
+				dev_err(davinci_display_dev,
+					"Error in getting current display mode from enc mngr\n");
+				up(&davinci_dm.lock);
+				return -EINVAL;
+			}
+			down_interruptible(&davinci_dm.lock);
+			cropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			if (!strcmp
+			    (davinci_dm.mode_info.name, VID_ENC_STD_NTSC)) {
+				cropcap->bounds = cropcap->defrect =
+				    ntsc_bounds;
+				cropcap->pixelaspect = ntsc_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name, VID_ENC_STD_PAL)) {
+				cropcap->bounds = cropcap->defrect = pal_bounds;
+				cropcap->pixelaspect = pal_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x480)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x400)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->bounds.height =
+				    cropcap->defrect.height = 400;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x350)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->bounds.height =
+				    cropcap->defrect.height = 350;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_720P_60)) {
+				cropcap->bounds = cropcap->defrect =
+				    hd_720p_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_1080I_30)) {
+				cropcap->bounds = cropcap->defrect =
+				    hd_1080i_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else {
+				dev_err(davinci_display_dev,
+					"Unknown encoder display mode\n");
+				up(&davinci_dm.lock);
+				return -EINVAL;
+			}
+			up(&davinci_dm.lock);
+			dev_dbg(davinci_display_dev,
+				"\nEnd of VIDIOC_CROPCAP ioctl");
+			break;
+		}
+
+	case VIDIOC_G_CROP:
+		{
+			/* TBD to get the x,y and height/width params */
+			struct v4l2_crop *crop = (struct v4l2_crop *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_G_CROP, layer id = %d\n",
+				layer->device_id);
+
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				struct v4l2_rect *rect = &crop->c;
+				down_interruptible(&davinci_dm.lock);
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+				rect->top = layer->layer_info.config.ypos;
+				rect->left = layer->layer_info.config.xpos;
+				rect->width = layer->layer_info.config.xsize;
+				rect->height = layer->layer_info.config.ysize;
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev,
+					"Invalid buf type \n");
+				return -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_S_CROP:
+		{
+			/* TBD to get the x,y and height/width params */
+			struct v4l2_crop *crop = (struct v4l2_crop *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_S_CROP, layer id = %d\n",
+				layer->device_id);
+
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				struct v4l2_rect *rect = &crop->c;
+
+				if (davinci_disp_check_window_params(rect)) {
+					dev_err(davinci_display_dev,
+						"Error in S_CROP params\n");
+					return -EINVAL;
+				}
+				down_interruptible(&davinci_dm.lock);
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				davinci_disp_calculate_scale_factor(layer,
+								    rect->width,
+								    rect->
+								    height);
+
+				davinci_disp_adj_position(layer, rect->top,
+							  rect->left);
+
+				if (davinci_disp_set_layer_config
+				    (layer->layer_info.id,
+				     &layer->layer_info.config)) {
+					dev_err(davinci_display_dev,
+						"Error in S_CROP params\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+				/* apply zooming and h or v expansion */
+				davinci_disp_set_zoom
+				    (layer->layer_info.id,
+				     layer->layer_info.h_zoom,
+				     layer->layer_info.v_zoom);
+
+				davinci_disp_set_vid_expansion
+				    (layer->layer_info.h_exp,
+				     layer->layer_info.v_exp);
+
+				if ((layer->layer_info.h_zoom != ZOOM_X1) ||
+				    (layer->layer_info.v_zoom != ZOOM_X1) ||
+				    (layer->layer_info.h_exp != H_EXP_OFF) ||
+				    (layer->layer_info.v_exp != V_EXP_OFF))
+					/* Enable expansion filter */
+					davinci_disp_set_interpolation_filter
+					    (1);
+				else
+					davinci_disp_set_interpolation_filter
+					    (0);
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev,
+					"Invalid buf type \n");
+				return -EINVAL;
+			}
+			break;
+		}
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_ENUM_FMT, layer id = %d\n",
+				layer->device_id);
+			if (fmt->index > 0) {
+				dev_err(davinci_display_dev,
+					"Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			if (index == 0) {
+				strcpy(fmt->description, "YUV 4:2:2 - UYVY");
+				fmt->pixelformat = V4L2_PIX_FMT_UYVY;
+			}
+			break;
+		}
+
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_G_FMT, layer id = %d\n",
+				layer->device_id);
+
+			/* If buffer type is video output */
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Fill in the information about
+				 * format */
+				down_interruptible(&davinci_dm.lock);
+				*pixfmt = layer->pix_fmt;
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_S_FMT, layer id = %d\n",
+				layer->device_id);
+
+			/* If streaming is started, return error */
+			if (layer->started) {
+				dev_err(davinci_display_dev,
+					"Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = davinci_check_format(layer, pixfmt);
+
+				if (ret)
+					return ret;
+
+				down_interruptible(&davinci_dm.lock);
+				/* store the pixel format in the layer 
+				 * object */
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				if (davinci_enc_get_mode
+				    (0, &davinci_dm.mode_info)) {
+					dev_err(davinci_display_dev,
+						"couldn't get current display mode from enc mngr\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+
+				/* For user ptr io, we calculate image size from bytes
+				   perline and sizeimage as per DaVinciHD
+				 */
+				if (layer->memory == V4L2_MEMORY_USERPTR) {
+					layer->layer_info.config.xsize =
+					    pixfmt->bytesperline / 2;
+					layer->layer_info.config.line_length =
+					    pixfmt->bytesperline;
+					layer->layer_info.config.ysize =
+					    pixfmt->sizeimage /
+					    pixfmt->bytesperline;
+				} else {
+					layer->layer_info.config.xsize =
+					    pixfmt->width;
+					layer->layer_info.config.ysize =
+					    pixfmt->height;
+					layer->layer_info.config.line_length =
+					    pixfmt->width * 2;
+				}
+				layer->layer_info.config.ypos = 0;
+				layer->layer_info.config.xpos = 0;
+
+				if (pixfmt->field == V4L2_FIELD_INTERLACED)
+					layer->layer_info.config.interlaced = 1;
+				else if (pixfmt->field == V4L2_FIELD_NONE)
+					layer->layer_info.config.interlaced = 0;
+
+				if (davinci_disp_set_layer_config
+				    (layer->layer_info.id,
+				     &layer->layer_info.config)) {
+					dev_err(davinci_display_dev,
+						"Error in S_FMT params\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+
+				/* readback and fill the local copy of current pix format */
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				layer->pix_fmt.width =
+				    layer->layer_info.config.xsize;
+				layer->pix_fmt.height =
+				    layer->layer_info.config.ysize;
+				layer->pix_fmt.bytesperline =
+				    layer->layer_info.config.line_length;
+				layer->pix_fmt.sizeimage =
+				    layer->pix_fmt.bytesperline *
+				    layer->pix_fmt.height;
+				if (layer->layer_info.config.interlaced)
+					layer->pix_fmt.field =
+					    V4L2_FIELD_INTERLACED;
+				else
+					layer->pix_fmt.field = V4L2_FIELD_NONE;
+				layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
+				/* Set the scale factors */
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt;
+			dev_dbg(davinci_display_dev, "VIDIOC_TRY_FMT\n");
+			fmt = (struct v4l2_format *)arg;
+
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = davinci_check_format(layer, pixfmt);
+				if (ret) {
+					*pixfmt = layer->pix_fmt;
+				}
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *reqbuf;
+			enum v4l2_field field;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_REQBUFS, count= %d, type = %d, memory = %d\n",
+				reqbuf->count, reqbuf->type, reqbuf->memory);
+
+			/* If io users of the layer is not zero,
+			   return error */
+			if (0 != layer->io_usrs) {
+				dev_err(davinci_display_dev, "not IO user\n");
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&davinci_dm.lock);
+			if (layer->pix_fmt.field == V4L2_FIELD_ANY)
+				if (davinci_dm.mode_info.interlaced)
+					field = V4L2_FIELD_INTERLACED;
+				else
+					field = V4L2_FIELD_NONE;
+			else
+				field = layer->pix_fmt.field;
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&layer->buffer_queue,
+					    &video_qops, NULL,
+					    &layer->irqlock,
+					    V4L2_BUF_TYPE_VIDEO_OUTPUT,
+					    field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&layer->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed = 1;
+			/* Increment io usrs member of layer object
+			   to 1 */
+			layer->io_usrs = 1;
+			/* Store type of memory requested in layer 
+			   object */
+			layer->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&layer->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&layer->buffer_queue, reqbuf);
+			up(&davinci_dm.lock);
+			break;
+		}
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer tbuf;
+			struct videobuf_buffer *buf1;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QBUF, layer id = %d\n",
+				layer->device_id);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (!(list_empty(&layer->dma_queue)) ||
+			    (layer->curFrm != layer->nextFrm) ||
+			    !(layer->started)) {
+
+				ret = videobuf_qbuf(&layer->buffer_queue,
+						    (struct v4l2_buffer *)arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 *  in VPBE registers */
+			down(&layer->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = layer->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(davinci_display_dev,
+					"invalid buffer type\n");
+				up(&layer->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				up(&layer->buffer_queue.lock);
+				dev_err(davinci_display_dev, "invalid state\n");
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					up(&layer->buffer_queue.lock);
+					dev_err(davinci_display_dev,
+						"No Buffer address\n");
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					up(&layer->buffer_queue.lock);
+					dev_err(davinci_display_dev,
+						"No Buffer address\n");
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					davinci_buffer_release(&layer->
+							       buffer_queue,
+							       buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				up(&layer->buffer_queue.lock);
+				dev_err(davinci_display_dev,
+					"Unknow Buffer type \n");
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    davinci_buffer_prepare(&layer->buffer_queue,
+						   buf1,
+						   layer->buffer_queue.field);
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			layer->nextFrm = buf1;
+
+			davinci_disp_start_layer(layer->layer_info.id, addr);
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(layer->buffer_queue.stream));
+			up(&layer->buffer_queue.lock);
+			break;
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_DQBUF, layer id = %d\n",
+				layer->device_id);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&layer->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&layer->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QUERYBUF, layer id = %d\n",
+				layer->device_id);
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&layer->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_STREAMON, layer id = %d\n",
+				layer->device_id);
+			/* If file handle is not allowed IO,
+			 * return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (layer->started) {
+				dev_err(davinci_display_dev,
+					"layer is already streaming\n");
+				ret = -EBUSY;
+				break;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&layer->buffer_queue);
+			if (ret) {
+				dev_err(davinci_display_dev,
+					"error in videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&davinci_dm.lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&layer->dma_queue)) {
+				dev_err(davinci_display_dev,
+					"buffer queue is empty\n");
+				ret = -EIO;
+				up(&davinci_dm.lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			layer->nextFrm = layer->curFrm =
+			    list_entry(layer->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&layer->curFrm->queue);
+			/* Mark state of the current frame to active */
+			layer->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+
+			layer->field_id = 0;
+
+			/* Set parameters in OSD and VENC */
+			ret = davinci_set_video_display_params(layer);
+			if (ret < 0) {
+				up(&davinci_dm.lock);
+				return ret;
+			}
+			layer->started = 1;
+			dev_dbg(davinci_display_dev,
+				"Started streaming on layer id = %d, ret = %d\n",
+				layer->device_id, ret);
+			layer_first_int = 1;
+			up(&davinci_dm.lock);
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_STREAMOFF,layer id = %d\n",
+				layer->device_id);
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!layer->started) {
+				dev_err(davinci_display_dev,
+					"streaming not started in layer id = %d\n",
+					layer->device_id);
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&davinci_dm.lock);
+			davinci_disp_disable_layer(layer->layer_info.id);
+			layer->started = 0;
+			up(&davinci_dm.lock);
+			ret = videobuf_streamoff(&layer->buffer_queue);
+			break;
+		}
+
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(davinci_display_dev, "<davinci_doioctl>\n");
+	return ret;
+}
+
+/*
+ * ======== davinci_ioctl ========*/
+/* Calls davinci_doioctl function */
+static int davinci_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	dev_dbg(davinci_display_dev, "Start of davinci ioctl\n");
+	ret = video_usercopy(inode, file, cmd, arg, (void *)davinci_doioctl);
+	if ((ret >= 0) && (VIDIOC_S_FMT == cmd || VIDIOC_TRY_FMT == cmd)) {
+		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
+				     arg, (void *)davinci_doioctl);
+	}
+	dev_dbg(davinci_display_dev, "</davinci_ioctl>\n");
+	return ret;
+}
+
+/*
+ * ======== davinci_mmap ========*/
+/* It is used to map kernel space buffers into user spaces */
+static int davinci_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+	int err = 0;
+	dev_dbg(davinci_display_dev, "<davinci_mmap>\n");
+
+	err = videobuf_mmap_mapper(&layer->buffer_queue, vma);
+	dev_dbg(davinci_display_dev, "</davinci_mmap>\n");
+	return err;
+}
+
+static int davinci_config_layer(enum davinci_display_device_id id)
+{
+	int err = 0;
+	struct davinci_layer_config *layer_config;
+	struct vid_enc_mode_info *mode_info;
+	struct display_obj *layer = davinci_dm.dev[id];
+
+	/* First claim the layer for this device */
+	if (davinci_disp_request_layer(layer->layer_info.id)) {
+		/* Couldn't get layer */
+		dev_err(davinci_display_dev,
+			"Display Manager failed to allocate layer\n");
+		return -EBUSY;
+	}
+
+	/* get the current video display mode from encoder manager */
+	mode_info = &davinci_dm.mode_info;
+	if (davinci_enc_get_mode(0, mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode from enc mngr\n");
+		return -1;
+	}
+
+	layer_config = &layer->layer_info.config;
+	/* Set the default image and crop values */
+	layer_config->pixfmt = PIXFMT_YCbCrI;
+	layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
+	layer->pix_fmt.bytesperline = layer_config->line_length =
+	    mode_info->xres * 2;
+
+	layer->pix_fmt.width = layer_config->xsize = mode_info->xres;
+	layer->pix_fmt.height = layer_config->ysize = mode_info->yres;
+	layer->pix_fmt.sizeimage =
+	    layer->pix_fmt.bytesperline * layer->pix_fmt.height;
+	layer_config->xpos = 0;
+	layer_config->ypos = 0;
+	layer_config->interlaced = mode_info->interlaced;
+	if (layer->layer_info.config.interlaced)
+		layer->pix_fmt.field = V4L2_FIELD_INTERLACED;
+	else
+		layer->pix_fmt.field = V4L2_FIELD_NONE;
+	davinci_disp_set_layer_config(layer->layer_info.id, layer_config);
+	return err;
+}
+
+/*
+ *=====davinci_open===== */
+/* It creates object of file handle structure and stores it in private_data
+ * member of filepointer */
+static int davinci_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0;
+	struct display_obj *layer;
+	struct davinci_fh *fh = NULL;
+
+	/* Check for valid minor number */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		if (minor == layer->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(davinci_display_dev, "device not found\n");
+		return -ENODEV;
+	}
+
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct davinci_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(davinci_display_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	dev_dbg(davinci_display_dev, "<davinci open> plane = %d\n",
+		layer->device_id);
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->layer = layer;
+
+	if (!layer->usrs) {
+		/* Configure the default values for the layer */
+		if (davinci_config_layer(layer->device_id)) {
+			dev_err(davinci_display_dev,
+				"Unable to configure video layer for id = %d\n",
+				layer->device_id);
+			return -EINVAL;
+		}
+	}
+
+	/* Increment layer usrs counter */
+	layer->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&layer->prio, &fh->prio);
+	dev_dbg(davinci_display_dev, "</davinci_open>\n");
+	return 0;
+}
+
+/*
+ *=====davinci_release=====*/
+/* This function deletes buffer queue, frees the buffers and the davinci 
+   display file * handle */
+static int davinci_release(struct inode *inode, struct file *filep)
+{
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "<davinci_release>\n");
+	/* If this is doing IO and other layer are not closed */
+	if ((layer->usrs != 1) && fh->io_allowed) {
+		dev_err(davinci_display_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on layer object */
+	down_interruptible(&davinci_dm.lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed) {
+		/* Reset io_usrs member of layer object */
+		layer->io_usrs = 0;
+		davinci_disp_disable_layer(layer->layer_info.id);
+		layer->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&layer->buffer_queue);
+	}
+
+	/* Decrement layer usrs counter */
+	layer->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (!layer->usrs) {
+		davinci_disp_disable_layer(layer->layer_info.id);
+		davinci_disp_release_layer(layer->layer_info.id);
+	}
+
+	/* Close the priority */
+	v4l2_prio_close(&layer->prio, &fh->prio);
+	filep->private_data = NULL;
+
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+	/* unlock semaphore on layer object */
+	up(&davinci_dm.lock);
+	dev_dbg(davinci_display_dev, "</davinci_release>\n");
+	return 0;
+}
+
+static void davinci_platform_release(struct device
+				     *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct file_operations davinci_fops = {
+	.owner = THIS_MODULE,
+	.open = davinci_open,
+	.release = davinci_release,
+	.ioctl = davinci_ioctl,
+	.mmap = davinci_mmap
+};
+static struct video_device davinci_video_template = {
+	.name = "davinci",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &davinci_fops,
+	.minor = -1
+};
+
+/*
+ *=====davinci_probe=====*/
+/* This function creates device entries by register itself to the V4L2 driver
+ * and initializes fields of each layer objects */
+static __init int davinci_probe(struct device *device)
+{
+	int i, j = 0, k, err = 0;
+	struct video_device *vbd = NULL;
+	struct display_obj *layer = NULL;
+	struct platform_device *pdev;
+
+	davinci_display_dev = device;
+
+	dev_dbg(davinci_display_dev, "<davinci_probe>\n");
+
+	/* First request memory region for io */
+	pdev = to_platform_device(device);
+	if (pdev->num_resources != 0) {
+		dev_err(davinci_display_dev, "probed for an unknown device\n");
+		return -ENODEV;
+	}
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		/* Allocate memory for video device */
+		vbd = video_device_alloc();
+		if (ISNULL(vbd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release
+				    (davinci_dm.dev[j]->video_dev);
+			}
+			dev_err(davinci_display_dev, "ran out of memory\n");
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vbd = davinci_video_template;
+		vbd->dev = device;
+		vbd->release = video_device_release;
+		snprintf(vbd->name, sizeof(vbd->name),
+			 "DaVinci_VPBEDisplay_DRIVER_V%d.%d.%d",
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 16)
+			 & 0xff,
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 8) &
+			 0xff, (DAVINCI_DISPLAY_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		layer->video_dev = vbd;
+		layer->device_id = i;
+		layer->layer_info.id =
+		    ((i == DAVINCI_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);
+		if (display_buf_config_params.numbuffers[i] == 0)
+			layer->memory = V4L2_MEMORY_USERPTR;
+		else
+			layer->memory = V4L2_MEMORY_MMAP;
+		/* Initialize field of the layer objects */
+		layer->usrs = layer->io_usrs = 0;
+		layer->started = 0;
+#if 0
+		if (j < 2)
+			layer->numbuffers
+			    =
+			    display_buf_config_params.numbuffers[layer->
+								 layer_id];
+		else
+			layer->numbuffers = 0;
+#endif
+
+		/* Initialize prio member of layer object */
+		v4l2_prio_init(&layer->prio);
+
+		/* register video device */
+		printk(KERN_NOTICE
+		       "Trying to register davinci display video device.\n");
+		printk(KERN_NOTICE "layer=%x,layer->video_dev=%x\n", (int)layer,
+		       (int)&layer->video_dev);
+
+		err = video_register_device(layer->
+					    video_dev,
+					    VFL_TYPE_GRABBER,
+					    davinci_display_nr[i]);
+		if (err)
+			goto probe_out;
+	}
+	/* Initialize mutex */
+	init_MUTEX(&davinci_dm.lock);
+	return 0;
+
+      probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[k];
+		/* Unregister video device */
+		video_unregister_device(layer->video_dev);
+		/* Release video device */
+		video_device_release(layer->video_dev);
+		layer->video_dev = NULL;
+	}
+	return err;
+}
+
+/*
+ * ===== davinci_remove =====*/
+/* It un-register hardware planes from V4L2 driver */
+static int davinci_remove(struct device *device)
+{
+	int i;
+	struct display_obj *plane;
+	dev_dbg(davinci_display_dev, "<davinci_remove>\n");
+	/* un-register device */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		plane = davinci_dm.dev[i];
+		/* Unregister video device */
+		video_unregister_device(plane->video_dev);
+
+		plane->video_dev = NULL;
+	}
+
+	dev_dbg(davinci_display_dev, "</davinci_remove>\n");
+	return 0;
+}
+
+static struct device_driver davinci_driver = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.bus = &platform_bus_type,
+	.probe = davinci_probe,
+	.remove = davinci_remove,
+};
+static struct platform_device _davinci_display_device = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.id = 1,
+	.dev = {
+		.release = davinci_platform_release,
+		}
+};
+
+/*
+ *=====davinci_display_init=====*/
+/* This function registers device and driver to the kernel, requests irq
+ * handler and allocates memory for layer objects */
+static __init int davinci_display_init(void)
+{
+	int err = 0, i, j;
+	int free_layer_objects_index;
+	int free_buffer_layer_index;
+	int free_buffer_index;
+	u32 addr;
+	int size;
+
+	printk(KERN_DEBUG "<davinci_display_init>\n");
+
+	/* Default number of buffers should be 3 */
+	if ((video2_numbuffers > 0) &&
+	    (video2_numbuffers < display_buf_config_params.min_numbuffers))
+		video2_numbuffers = display_buf_config_params.min_numbuffers;
+	if ((video3_numbuffers > 0) &&
+	    (video3_numbuffers < display_buf_config_params.min_numbuffers))
+		video3_numbuffers = display_buf_config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (video2_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_0])
+		video2_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_0];
+
+	if (video3_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_1])
+		video3_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_1];
+
+	if (video2_numbuffers) {
+		display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_0] =
+		    video2_numbuffers;
+	}
+	if (video3_numbuffers) {
+		display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_1] =
+		    video3_numbuffers;
+	}
+	if (cpu_is_davinci_dm355()) {
+		strcpy(davinci_display_videocap.card, DM355_EVM_CARD);
+	} else {
+		strcpy(davinci_display_videocap.card, DM644X_EVM_CARD);
+	}
+	/* Allocate memory for four plane display objects */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		davinci_dm.dev[i] =
+		    kmalloc(sizeof(struct display_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!davinci_dm.dev[i]) {
+			free_layer_objects_index = i;
+			printk(KERN_ERR "ran out of memory\n");
+			err = -ENOMEM;
+			goto davinci_init_free_layer_objects;
+		}
+		davinci_dm.dev[i]->irqlock = SPIN_LOCK_UNLOCKED;
+	}
+	free_layer_objects_index = DAVINCI_DISPLAY_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		size = display_buf_config_params.layer_bufsize[i];
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_layer_index = i;
+				free_buffer_index = j;
+				printk(KERN_ERR "ran out of memory\n");
+				err = -ENOMEM;
+				goto davinci_init_free_buffers;
+			}
+			davinci_dm.dev[i]->fbuffers[j] = addr;
+		}
+	}
+	free_buffer_layer_index = DAVINCI_DISPLAY_MAX_DEVICES;
+	free_buffer_index = display_buf_config_params.numbuffers[i - 1];
+	/* Register driver to the kernel */
+	err = driver_register(&davinci_driver);
+	if (0 != err) {
+		goto davinci_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_davinci_display_device);
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+
+	davinci_dm.event_callback.mask = (DAVINCI_DISP_END_OF_FRAME |
+					  DAVINCI_DISP_TOP_FIELD |
+					  DAVINCI_DISP_BOTTOM_FIELD);
+
+	davinci_dm.event_callback.arg = &davinci_dm;
+	davinci_dm.event_callback.handler = davinci_display_isr;
+
+	err = davinci_disp_register_callback(&davinci_dm.event_callback);
+
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+	printk(KERN_NOTICE
+	       "davinci_init:DaVinci V4L2 Display Driver V1.0 loaded\n");
+	printk(KERN_DEBUG "</davinci_init>\n");
+	return 0;
+
+      davinci_init_unregister_driver:
+	driver_unregister(&davinci_driver);
+
+      davinci_init_free_buffers:
+	for (i = 0; i < free_buffer_layer_index; i++) {
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_dm.dev[i]->fbuffers[j];
+			if (addr) {
+				davinci_free_buffer(addr,
+						    display_buf_config_params.
+						    layer_bufsize[i]
+				    );
+				davinci_dm.dev[i]->fbuffers[j] = 0;
+			}
+		}
+	}
+	for (j = 0; j < display_buf_config_params.numbuffers[free_buffer_index];
+	     j++) {
+		addr = davinci_dm.dev[free_buffer_layer_index]->fbuffers[j];
+		if (addr) {
+			davinci_free_buffer(addr,
+					    display_buf_config_params.
+					    layer_bufsize[i]);
+			davinci_dm.dev[free_buffer_layer_index]->fbuffers[j]
+			    = 0;
+		}
+
+	}
+
+      davinci_init_free_layer_objects:
+	for (j = 0; j < free_layer_objects_index; j++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[j]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* =====davinci_cleanup=====
+ * This function un-registers device and driver to the kernel, frees requested
+ * irq handler and de-allocates memory allocated for layer objects.
+ * */
+static void davinci_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+	printk(KERN_INFO "<davinci_cleanup>\n");
+
+	davinci_disp_unregister_callback(&davinci_dm.event_callback);
+	platform_device_unregister(&_davinci_display_device);
+	driver_unregister(&davinci_driver);
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_dm.dev[i]->fbuffers[j];
+			if (addr) {
+				davinci_free_buffer(addr,
+						    display_buf_config_params.
+						    layer_bufsize[i]);
+				davinci_dm.dev[i]->fbuffers[j] = 0;
+			}
+		}
+	}
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[i]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	printk(KERN_INFO "</davinci_cleanup>\n");
+}
+
+EXPORT_SYMBOL(davinci_display_dev);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(davinci_display_init);
+module_exit(davinci_cleanup);
Index: linux-2.6.10/drivers/media/video/davinci/davinci_enc_mngr.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_enc_mngr.c
@@ -0,0 +1,1180 @@
+
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+#define ISNULL(p)       ((NULL) == (p))
+
+static char *ch0_output = "";
+static char *ch1_output = "";
+static char *ch0_mode = "";
+static char *ch1_mode = "";
+module_param(ch0_output, charp, S_IRUGO);
+module_param(ch1_output, charp, S_IRUGO);
+module_param(ch0_mode, charp, S_IRUGO);
+module_param(ch1_mode, charp, S_IRUGO);
+
+struct vid_enc_device_mgr enc_dev[DAVINCI_ENC_MAX_CHANNELS];
+extern struct enc_config davinci_enc_default[];
+extern char *davinci_outputs[];
+extern char *davinci_modes[];
+
+#ifdef CONFIG_SYSFS
+struct display_device {
+	struct module *owner;
+	struct class_device class_dev;
+	int channel;
+};
+
+static struct display_device *davinci_display_device[DAVINCI_ENC_MAX_CHANNELS];
+
+#define to_display_dev(cdev)	container_of(cdev, \
+ struct display_device, class_dev)
+
+static void display_class_release(struct class_device *cdev)
+{
+	struct display_device *dev = to_display_dev(cdev);
+
+	if (dev != NULL)
+		kfree(dev);
+}
+
+struct class display_class = {
+	.name = "davinci_display",
+	.release = display_class_release,
+};
+
+static int my_atoi(const char *name, int *count)
+{
+	int val = 0;
+	*count = 0;
+	for (; *name != 0; name++, (*count)++) {
+		switch (*name) {
+		case '0'...'9':
+			val = 10 * val + (*name - '0');
+			break;
+		case '!'...'/':
+		case ':'...'~':
+			return -EINVAL;
+		default:
+			break;
+		}
+	}
+	return val;
+}
+
+static ssize_t output_show(struct class_device *cdev, char *buf)
+{
+	char name[VID_ENC_NAME_MAX_CHARS];
+	struct display_device *dev = to_display_dev(cdev);
+	int p, ret;
+
+	ret = davinci_enc_get_output(dev->channel, name);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+output_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[count];
+	int ret;
+	if (!buffer || (count == 0))
+		return 0;
+
+	strncpy(name, buffer, VID_ENC_NAME_MAX_CHARS);
+	name[count - 1] = 0;
+	ret = davinci_enc_set_output(dev->channel, name);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t mode_show(struct class_device *cdev, char *buf)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	struct vid_enc_mode_info mode_info;
+	int p;
+	int ret;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, mode_info.name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+mode_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[count];
+	struct vid_enc_mode_info mode_info;
+	int ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	strncpy(name, buffer, VID_ENC_NAME_MAX_CHARS);
+	name[count - 1] = 0;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+
+	if (ret < 0)
+		return ret;
+
+	mode_info.name = name;
+	ret = davinci_enc_set_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t enable_show(struct class_device *cdev, char *buf)
+{
+	return 0;
+}
+
+static ssize_t
+enable_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int enable_output_state, ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	if (strncmp(buffer, "on", 2) == 0)
+		enable_output_state = 1;
+	else if (strncmp(buffer, "off", 3) == 0)
+		enable_output_state = 0;
+	else
+		return -EINVAL;
+
+	ret = davinci_enc_enable_output(dev->channel, enable_output_state);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t
+control_store(struct class_device *cdev, const char *buffer, size_t count,
+	      u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int val;
+	int ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	val = my_atoi(buffer, &count);
+	if (val < 0)
+		return -EINVAL;
+
+	ret = davinci_enc_set_control(dev->channel, ctrl, (char)val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+static ssize_t control_show(struct class_device *cdev, char *buf, u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	unsigned int p;
+	unsigned char val;
+	int ret;
+
+	ret = davinci_enc_get_control(dev->channel, ctrl, &val);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, "%d", val);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+brightness_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t brightness_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t
+hue_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_HUE);
+}
+static ssize_t hue_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_HUE);
+}
+static ssize_t
+gain_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_GAIN);
+}
+static ssize_t gain_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_GAIN);
+}
+
+#define DECLARE_ATTR(_name, _mode, _show, _store)                  \
+{                                                               \
+	.attr   = { .name = __stringify(_name), .mode = _mode,	\
+		    .owner = THIS_MODULE },  			\
+	.show   = _show,                                        \
+	.store  = _store,                                       \
+}
+static struct class_device_attribute bl_class_device_attributes[] = {
+	DECLARE_ATTR(output, S_IRWXUGO, output_show, output_store),
+	DECLARE_ATTR(mode, S_IRWXUGO, mode_show, mode_store),
+	DECLARE_ATTR(enable, S_IRWXUGO, enable_show, enable_store),
+	DECLARE_ATTR(brightness, S_IRWXUGO, brightness_show, brightness_store),
+	DECLARE_ATTR(hue, S_IRWXUGO, hue_show, hue_store),
+	DECLARE_ATTR(gain, S_IRWXUGO, gain_show, gain_store)
+};
+
+static void *create_sysfs_files(int channel)
+{
+	struct display_device *dev;
+	int ret;
+	int i;
+
+	dev = kzalloc(sizeof(struct display_device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->owner = THIS_MODULE;
+	dev->channel = channel;
+	dev->class_dev.class = &display_class;
+	snprintf(dev->class_dev.class_id, BUS_ID_SIZE, "ch%d", channel);
+
+	ret = class_device_register(&dev->class_dev);
+	if (ret < 0) {
+		kfree(dev);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(bl_class_device_attributes); i++) {
+		ret = class_device_create_file(&dev->class_dev,
+					       &bl_class_device_attributes[i]);
+		if (ret < 0) {
+			while (--i >= 0)
+				class_device_remove_file(&dev->class_dev,
+							 &bl_class_device_attributes
+							 [i]);
+			class_device_unregister(&dev->class_dev);
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+static void remove_sysfs_files(struct display_device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(bl_class_device_attributes); i++)
+		class_device_remove_file(&dev->class_dev,
+					 &bl_class_device_attributes[i]);
+
+	class_device_unregister(&dev->class_dev);
+}
+#endif
+
+static void davinci_enc_check_options(void)
+{
+	int i;
+
+	i = 0;
+	while (*(davinci_modes[i]) != 0) {
+		if (*ch0_mode != 0 && !strcmp(ch0_mode, davinci_modes[i])) {
+			if (strcmp(ch0_mode, "ntsc") == 0
+			    || strcmp(ch0_mode, "pal") == 0)
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i]);
+		}
+		if (*ch1_mode != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_mode, davinci_modes[i])) {
+			if (strcmp(ch1_mode, "ntsc") == 0
+			    || strcmp(ch1_mode, "pal") == 0)
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i]);
+		}
+		i++;
+	}
+
+	i = 0;
+	while (*(davinci_outputs[i]) != 0) {
+		if (*ch0_output != 0 && !strcmp(ch0_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[0].output,
+			       davinci_outputs[i]);
+
+		if (*ch1_output != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[1].output,
+			       davinci_outputs[i]);
+		i++;
+	}
+	printk(KERN_NOTICE "ch0 default output \"%s\", mode \"%s\"\n",
+	       davinci_enc_default[0].output, davinci_enc_default[0].mode);
+	if (DAVINCI_ENC_MAX_CHANNELS > 1)
+		printk(KERN_NOTICE "ch1 default output \"%s\", mode \"%s\"\n",
+		       davinci_enc_default[1].output,
+		       davinci_enc_default[1].mode);
+	return;
+}
+
+/*
+ * vid_enc_mgr_init
+ */
+static int davinci_enc_mngr_init(void)
+{
+	int i, err = -EINVAL;
+	struct vid_enc_device_mgr *ptr = 0;
+
+#ifdef CONFIG_SYSFS
+	class_register(&display_class);
+#endif
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++) {
+		ptr = &enc_dev[i];
+
+		memset((void *)ptr, 0, sizeof(struct vid_enc_device_mgr));
+		init_MUTEX(&ptr->lock);
+#ifdef CONFIG_SYSFS
+		davinci_display_device[i] = create_sysfs_files(i);
+		if (!davinci_display_device[i]) {
+			printk(KERN_ERR
+			       "Could not create display control sysfs "
+			       "files for channel %d\n", i);
+			return -EINVAL;
+		}
+#endif
+
+	}
+
+	davinci_enc_check_options();
+	err = 0;
+	return err;
+}
+
+/*
+ * vid_enc_mgr_cleanup
+ */
+static void davinci_enc_mngr_cleanup(void)
+{
+#ifdef CONFIG_SYSFS
+	int i;
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++)
+		remove_sysfs_files(davinci_display_device[i]);
+
+	class_unregister(&display_class);
+#endif
+
+	return;
+}
+
+/*
+ * davinci_get_cur_encoder: get current encoder on the specified channel
+ */
+static struct vid_encoder_device *davinci_get_cur_encoder(int channel)
+{
+	struct vid_enc_device_mgr *mgr;
+
+	if ((channel > DAVINCI_ENC_MAX_CHANNELS) || (channel < 0))
+		return NULL;
+
+	mgr = &enc_dev[channel];
+
+	if (mgr->current_encoder > mgr->num_encoders)
+		return NULL;
+
+	if (mgr->num_encoders == 0)
+		return NULL;
+
+	return mgr->encoder[mgr->current_encoder];
+}
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set encoder
+ * parameters.
+ */
+int davinci_enc_setparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->setparams != NULL)
+		return cur_enc->params_ops->setparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_setparams);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get encoder
+ * parameters.
+ */
+int davinci_enc_getparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->getparams != NULL)
+		return cur_enc->params_ops->getparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_getparams);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->setcontrol != NULL)
+		return cur_enc->ctrl_ops->setcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_control);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops || NULL == val)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->getcontrol != NULL)
+		return cur_enc->ctrl_ops->getcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_control);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		return cur_enc->misc_ops->reset(cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_reset);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+*  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+* configuration of the VENC or related hardware in the VPSS and re-enabled
+* using this API. This will switch the output DACs Off or On based on the
+* flag.
+ */
+int davinci_enc_enable_output(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		return cur_enc->misc_ops->enable(flag, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_output);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to program the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During programing of the SoC hardware for timing, manager
+ * would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output)
+{
+	int i, j, found = -1;
+	int err = -EINVAL;
+	struct vid_encoder_device *cur_enc, *new_enc = 0;
+	struct vid_enc_device_mgr *mgr = NULL;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == output)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	/* enumerate the output for each encoder on this channel
+	   to find a matching one */
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (ISNULL(mgr->encoder[i]))
+			return err;
+
+		for (j = 0; j < mgr->encoder[i]->output_ops->count; j++) {
+			err =
+			    mgr->encoder[i]->output_ops->
+			    enumoutput(j, buf, mgr->encoder[i]);
+			if (err != 0)
+				return err;
+			if (strcmp(buf, output) == 0) {
+				found = i;
+				new_enc = mgr->encoder[i];
+				break;
+			}
+		}
+	}
+
+	if (found < 0) {
+		printk(KERN_ERR "output not found\n");
+		return -EINVAL;
+	}
+
+	/* found the encoder */
+	err = 0;
+	mgr->current_encoder = found;
+	down_interruptible(&mgr->lock);
+	err |= cur_enc->deinitialize(cur_enc);
+	err |= new_enc->initialize(new_enc, VID_ENC_FULL_INIT_FLAG);
+	err |= new_enc->output_ops->setoutput(output, new_enc);
+
+	if (err < 0) {
+		up(&mgr->lock);
+		return err;
+	}
+
+	/* get default mode */
+	err |= new_enc->mode_ops->getmode(&mgr->current_mode, new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(0, new_enc);
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	/* Some encoders need a soft reset after configuring VENC, ex.
+	   ths8200
+	 */
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->reset != NULL)
+		err |= new_enc->misc_ops->reset(new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(1, new_enc);
+
+	if (0 == err)
+		strcpy(enc_dev[channel].current_output, output);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_output);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	int err = -EINVAL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	if (cur_enc->mode_ops->setmode != NULL) {
+		down_interruptible(&mgr->lock);
+		err = cur_enc->mode_ops->setmode(mode_info, cur_enc);
+		up(&mgr->lock);
+	} else
+		return err;
+
+	if (err < 0)
+		return err;
+
+	err = cur_enc->mode_ops->getmode(&mgr->current_mode, cur_enc);
+	if (err < 0)
+		return err;
+
+	err = 0;
+
+	down_interruptible(&mgr->lock);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(0, cur_enc);
+
+	/* non-standard */
+	if (mgr->current_mode.std == 0) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		up(&mgr->lock);
+		return err;
+	}
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		err |= cur_enc->misc_ops->reset(cur_enc);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(1, cur_enc);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode);
+
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * This is updated by encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+*/
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return -EINVAL;
+
+	if (cur_enc->mode_ops->getmode != NULL)
+		return cur_enc->mode_ops->getmode(mode_info, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_mode);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name.
+ * size VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+*   output name
+ */
+int davinci_enc_get_output(int channel, char *output)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->output_ops || NULL == output)
+		return -EINVAL;
+
+	if (cur_enc->output_ops->getoutput != NULL)
+		return cur_enc->output_ops->getoutput(output, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_output);
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device *encoder)
+{
+	int i, found = 0, err = 0;
+	int ch_id = 0;
+	struct vid_enc_device_mgr *mgr = 0;
+	struct vid_encoder_device *cur_enc = 0;
+	struct enc_config *enc_def = 0;
+	struct vid_enc_mode_info mode_info;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	if (ISNULL(encoder))
+		return -EINVAL;
+
+	memset(&mode_info, 0, sizeof(struct vid_enc_mode_info));
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return -EINVAL;
+
+	mgr = &enc_dev[ch_id];
+
+	if (mgr->num_encoders > DAVINCI_ENC_MAX_ENCODERS)
+		return -EINVAL;
+
+	/* get module boot args */
+	enc_def = &davinci_enc_default[ch_id];
+
+	/* we'd assume only std mode being reqeusted from bootargs */
+	mode_info.name = enc_def->mode;
+	mode_info.std = 1;
+
+	if (mgr->num_encoders == 0) {
+		/* set default for the first encoder */
+		err = encoder->initialize(encoder, VID_ENC_FULL_INIT_FLAG);
+
+		if (err == 0) {
+			/* see if this has output requested by default
+			   or bootarg */
+
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err =
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Setmode failed, reset to encoder"
+					     " default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = 0;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			down_interruptible(&mgr->lock);
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+		}
+	} else {
+		/* If we have more than one encoder module, then we still
+		   want to make sure we can set to the default output and
+		   mode. If current one is not the default, try this new
+		   one. If still no luck, just use the newly registered
+		   one as default */
+		cur_enc = davinci_get_cur_encoder(ch_id);
+
+		if ((strcmp(mgr->current_output,
+			    enc_def->output) != 0) && (cur_enc != NULL)) {
+			cur_enc->deinitialize(cur_enc);
+
+			err = encoder->initialize(encoder,
+						  VID_ENC_FULL_INIT_FLAG);
+
+			if (err != 0) {
+				/* no change if new one cannot be
+				   initialized */
+				encoder->deinitialize(encoder);
+				cur_enc->initialize(cur_enc, 0);
+				return err;
+			}
+			/* look for matching output */
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err |=
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				/* setmode went wrong, try redo init */
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Set output or mode failed, "
+					     "reset to encoder default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = mgr->num_encoders - 1;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			down_interruptible(&mgr->lock);
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+
+		} else if (strcmp(mgr->current_output, enc_def->output) == 0) {
+			/* no change in output or mode */
+			mgr->encoder[mgr->num_encoders++] = encoder;
+
+		}
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(vid_enc_register_encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device *encoder)
+{
+	int i, j = 0, err = -EINVAL, ch_id;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	if (ISNULL(encoder))
+		return err;
+
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return err;
+
+	mgr = &enc_dev[ch_id];
+
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (encoder == mgr->encoder[i]) {
+
+			mgr->encoder[i] = NULL;
+			for (j = i; j < mgr->num_encoders - 1; j++)
+				mgr->encoder[j] = mgr->encoder[j + 1];
+			mgr->num_encoders--;
+			err = 0;
+			break;
+		}
+	}
+	return err;
+
+}
+
+EXPORT_SYMBOL(vid_enc_unregister_encoder);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_vbi)
+		return -EINVAL;
+
+	return cur_enc->enable_vbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_vbi);
+
+/**
+ * davinci_enc_enable_hbi
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_hbi)
+		return -EINVAL;
+
+	return cur_enc->enable_hbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_hbi);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *services)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->set_vbi_services)
+		return -EINVAL;
+
+	return cur_enc->set_vbi_services(services, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_sliced_vbi);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->write_vbi_data)
+		return -EINVAL;
+
+	return cur_enc->write_vbi_data(data, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_write_sliced_vbi_data);
+
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *service)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->get_sliced_cap)
+		return -EINVAL;
+
+	return cur_enc->get_sliced_cap(service, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_get_sliced_cap);
+
+subsys_initcall(davinci_enc_mngr_init);
+module_exit(davinci_enc_mngr_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/davinci_osd.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_osd.c
@@ -0,0 +1,2067 @@
+/*
+ * TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu.h>
+
+/* parameters that apply on a per-window (OSD or video) basis */
+struct davinci_window_state {
+	int is_allocated;
+	int is_enabled;
+	unsigned long fb_base_phys;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	struct davinci_layer_config lconfig;
+};
+
+/* parameters that apply on a per-OSD-window basis */
+struct davinci_osdwin_state {
+	enum davinci_clut clut;
+	enum davinci_blending_factor blend;
+	int colorkey_blending;
+	unsigned colorkey;
+	int rec601_attenuation;
+	unsigned char palette_map[16];	/* index is pixel value */
+};
+
+/* hardware rectangular cursor parameters */
+struct davinci_cursor_state {
+	int is_enabled;
+	struct davinci_cursor_config config;
+};
+
+struct davinci_osd_state {
+	spinlock_t lock;
+	unsigned long osdregs;	/* physical base address of OSD registers */
+	unsigned long vencregs;	/* physical base address of VENC registers */
+	int irq;
+	struct davinci_disp_callback *callback;
+	int pingpong;		/* 1-->the isr will toggle the VID0 ping-pong buffer */
+	int interpolation_filter;
+	int field_inversion;
+	enum davinci_h_exp_ratio osd_h_exp;
+	enum davinci_v_exp_ratio osd_v_exp;
+	enum davinci_h_exp_ratio vid_h_exp;
+	enum davinci_v_exp_ratio vid_v_exp;
+	enum davinci_clut backg_clut;
+	unsigned backg_clut_index;
+	enum davinci_rom_clut rom_clut;
+	int is_blinking;	/* attribute window blinking enabled */
+	enum davinci_blink_interval blink;
+	enum davinci_pix_format yc_pixfmt;	/* YCbCrI or YCrCbI */
+	unsigned char clut_ram[256][3];	/* columns are Y, Cb, Cr */
+	struct davinci_cursor_state cursor;
+	struct davinci_window_state win[4];	/* OSD0, VID0, OSD1, VID1 */
+	struct davinci_osdwin_state osdwin[2];	/* OSD0, OSD1 */
+};
+
+static struct davinci_osd_state osd_state;
+static struct davinci_osd_state *osd = &osd_state;
+
+/* register access routines */
+static __inline__ u32 osd_read(u32 offset)
+{
+	return davinci_readl(osd->osdregs + offset);
+}
+
+static __inline__ u32 osd_write(u32 val, u32 offset)
+{
+	davinci_writel(val, osd->osdregs + offset);
+	return val;
+}
+
+static __inline__ u32 osd_set(u32 mask, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 val = davinci_readl(addr) | mask;
+
+	davinci_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_clear(u32 mask, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 val = davinci_readl(addr) & ~mask;
+
+	davinci_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_merge(u32 mask, u32 val, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 new_val = (davinci_readl(addr) & ~mask) | (val & mask);
+
+	davinci_writel(new_val, addr);
+	return new_val;
+}
+
+/* define some macros for layer and pixfmt classification */
+#define is_osd_win(layer) (((layer) == WIN_OSD0) || ((layer) == WIN_OSD1))
+#define is_vid_win(layer) (((layer) == WIN_VID0) || ((layer) == WIN_VID1))
+#define is_rgb_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_RGB565) || ((pixfmt) == PIXFMT_RGB888))
+#define is_yc_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_YCbCrI) || ((pixfmt) == PIXFMT_YCrCbI))
+
+#define MAX_WIN_SIZE OSD_VIDWIN0XP_V0X
+#define MAX_LINE_LENGTH (OSD_VIDWIN0OFST_V0LO << 5)
+
+/* interrupt service routine */
+static irqreturn_t davinci_disp_isr(int irq, void *arg, struct pt_regs *regs)
+{
+	unsigned event = 0;
+	struct davinci_disp_callback *callback = osd->callback;
+
+	if (cpu_is_davinci_dm355()) {
+		if (!
+		    (davinci_readl(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT) &
+		     VPSSBL_INTSTAT_VENCINT)) {
+			return IRQ_NONE;
+		}
+		davinci_writel(VPSSBL_INTSTAT_VENCINT,
+			       DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT);
+	}
+
+	if ((davinci_readl(osd->vencregs + VENC_VSTAT) & VENC_VSTAT_FIDST) ==
+	    VENC_VSTAT_FIDST)
+		event |= DAVINCI_DISP_TOP_FIELD;
+	else
+		event |= DAVINCI_DISP_BOTTOM_FIELD | DAVINCI_DISP_END_OF_FRAME;
+
+	if (osd->pingpong) {
+		/*
+		 * Toggle the ping-pong buffers for VID0.  This is part of the
+		 * workaround for field signal inversion Advisory 1.3.8 for
+		 * the DM6446.
+		 */
+		if (event & DAVINCI_DISP_TOP_FIELD)
+			osd_set(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+		else
+			osd_clear(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+	}
+
+	while (callback) {
+		if (callback->mask & event)
+			callback->handler(event, callback->arg);
+		callback = callback->next;
+	}
+
+	return IRQ_HANDLED;
+}
+
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *prev;
+	int err = 0;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	prev = osd->callback;
+	if (!prev)
+		err = -1;
+	else if (prev == callback)
+		osd->callback = callback->next;
+	else {
+		while (prev->next && (prev->next != callback))
+			prev = prev->next;
+		if (!prev->next)
+			err = -1;
+		else
+			prev->next = callback->next;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return err;
+}
+
+int davinci_disp_register_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *next;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	next = osd->callback;
+	osd->callback = callback;
+	callback->next = next;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+
+/*
+ * This routine implements a workaround for the field signal inversion silicon
+ * erratum described in Advisory 1.3.8 for the DM6446.  The fb_base_phys and
+ * lconfig parameters apply to the vid0 window.  This routine should be called
+ * whenever the vid0 layer configuration or start address is modified, or when
+ * the OSD field inversion setting is modified.
+ * Returns: 1 if the ping-pong buffers need to be toggled in the vsync isr, or
+ *          0 otherwise
+ */
+static int _davinci_disp_dm6446_vid0_pingpong(int field_inversion,
+					      unsigned long fb_base_phys,
+					      const struct davinci_layer_config
+					      *lconfig)
+{
+	if (!cpu_is_davinci_dm644x())
+		return 0;
+
+	if (!field_inversion || !lconfig->interlaced) {
+		osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+		osd_write(fb_base_phys & ~0x1F, OSD_PPVWIN0ADR);
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, 0, OSD_MISCCTL);
+
+		return 0;
+	} else {
+		unsigned miscctl = OSD_MISCCTL_PPRV;
+
+		osd_write((fb_base_phys & ~0x1F) - lconfig->line_length,
+			  OSD_VIDWIN0ADR);
+		osd_write((fb_base_phys & ~0x1F) + lconfig->line_length,
+			  OSD_PPVWIN0ADR);
+		if ((davinci_readl(osd->vencregs + VENC_VSTAT) &
+		     VENC_VSTAT_FIDST) == VENC_VSTAT_FIDST) {
+			miscctl |= OSD_MISCCTL_PPSW;
+		}
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, miscctl,
+			  OSD_MISCCTL);
+
+		return 1;
+	}
+}
+
+int davinci_disp_get_field_inversion(void)
+{
+	return osd->field_inversion;
+}
+
+static void _davinci_disp_set_field_inversion(int enable)
+{
+	unsigned fsinv = 0;
+
+	if (enable)
+		fsinv = OSD_MODE_FSINV;
+
+	osd_merge(OSD_MODE_FSINV, fsinv, OSD_MODE);
+}
+
+void davinci_disp_set_field_inversion(int enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->field_inversion = (enable != 0);
+	_davinci_disp_set_field_inversion(enable);
+
+	osd->pingpong =
+	    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+					       osd->win[WIN_VID0].fb_base_phys,
+					       &osd->win[WIN_VID0].lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*clut = osd->backg_clut;
+	*clut_index = osd->backg_clut_index;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_background(enum davinci_clut clut,
+					 unsigned char clut_index)
+{
+	u32 mode = 0;
+
+	if (clut == RAM_CLUT)
+		mode |= OSD_MODE_BCLUT;
+	mode |= clut_index;
+	osd_merge(OSD_MODE_BCLUT | OSD_MODE_CABG, mode, OSD_MODE);
+}
+
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->backg_clut = clut;
+	osd->backg_clut_index = clut_index;
+	_davinci_disp_set_background(clut, clut_index);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_get_interpolation_filter(void)
+{
+	return osd->interpolation_filter;
+}
+
+static void _davinci_disp_set_interpolation_filter(int filter)
+{
+	if (cpu_is_davinci_dm355())
+		osd_clear(OSD_EXTMODE_EXPMDSEL, OSD_EXTMODE);
+	osd_merge(OSD_MODE_EF, filter ? OSD_MODE_EF : 0, OSD_MODE);
+}
+
+void davinci_disp_set_interpolation_filter(int filter)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->interpolation_filter = (filter != 0);
+	_davinci_disp_set_interpolation_filter(filter);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*cursor = osd->cursor.config;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_cursor_config(const struct davinci_cursor_config
+					    *cursor)
+{
+	unsigned rectcur = 0;
+
+	osd_write(cursor->xsize, OSD_CURXL);
+	osd_write(cursor->xpos, OSD_CURXP);
+
+	if (cursor->interlaced) {
+		osd_write(cursor->ypos >> 1, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write((cursor->ysize >> 1) + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize >> 1, OSD_CURYL);
+	} else {
+		osd_write(cursor->ypos, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write(cursor->ysize + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize, OSD_CURYL);
+	}
+
+	if (cursor->clut == RAM_CLUT)
+		rectcur |= OSD_RECTCUR_CLUTSR;
+	rectcur |= (cursor->clut_index << OSD_RECTCUR_RCAD_SHIFT);
+	rectcur |= (cursor->h_width << OSD_RECTCUR_RCHW_SHIFT);
+	rectcur |= (cursor->v_width << OSD_RECTCUR_RCVW_SHIFT);
+	osd_merge(OSD_RECTCUR_RCAD | OSD_RECTCUR_CLUTSR | OSD_RECTCUR_RCHW |
+		  OSD_RECTCUR_RCVW, rectcur, OSD_RECTCUR);
+}
+
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	cursor->xsize = min(cursor->xsize, (unsigned)OSD_CURXL_RCSW);
+	cursor->ysize = min(cursor->ysize, (unsigned)OSD_CURYL_RCSH);
+	cursor->xpos = min(cursor->xpos, (unsigned)OSD_CURXP_RCSX);
+	cursor->ypos = min(cursor->ypos, (unsigned)OSD_CURYP_RCSY);
+	cursor->interlaced = (cursor->interlaced != 0);
+	if (cursor->interlaced) {
+		cursor->ysize &= ~1;
+		cursor->ypos &= ~1;
+	}
+	cursor->h_width &= (OSD_RECTCUR_RCHW >> OSD_RECTCUR_RCHW_SHIFT);
+	cursor->v_width &= (OSD_RECTCUR_RCVW >> OSD_RECTCUR_RCVW_SHIFT);
+	cursor->clut = (cursor->clut == RAM_CLUT) ? RAM_CLUT : ROM_CLUT;
+
+	osd->cursor.config = *cursor;
+	_davinci_disp_set_cursor_config(cursor);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_cursor_is_enabled(void)
+{
+	return osd->cursor.is_enabled;
+}
+
+static void _davinci_disp_cursor_disable(void)
+{
+	osd_clear(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_disable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 0;
+	_davinci_disp_cursor_disable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_cursor_enable(void)
+{
+	osd_set(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_enable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 1;
+	_davinci_disp_cursor_enable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->vid_h_exp;
+	*v_exp = osd->vid_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_VHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_VIDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_VVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355())
+		osd_merge(OSD_EXTMODE_VIDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_VHRSZ | OSD_MODE_VVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->vid_h_exp = h_exp;
+	osd->vid_v_exp = v_exp;
+	_davinci_disp_set_vid_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->osd_h_exp;
+	*v_exp = osd->osd_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_OHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_OSDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_OVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355())
+		osd_merge(OSD_EXTMODE_OSDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_OHRSZ | OSD_MODE_OVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->osd_h_exp = h_exp;
+	osd->osd_v_exp = v_exp;
+	_davinci_disp_set_osd_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*enable = osd->is_blinking;
+	*blink = osd->blink;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_blink_attribute(int enable,
+					      enum davinci_blink_interval blink)
+{
+	u32 osdatrmd = 0;
+
+	if (enable) {
+		osdatrmd |= OSD_OSDATRMD_BLNK;
+		osdatrmd |= blink << OSD_OSDATRMD_BLNKINT_SHIFT;
+	}
+	/* caller must ensure that OSD1 is configured in attribute mode */
+	osd_merge(OSD_OSDATRMD_BLNKINT | OSD_OSDATRMD_BLNK, osdatrmd,
+		  OSD_OSDATRMD);
+}
+
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->is_blinking = (enable != 0);
+	osd->blink = blink;
+	if (osd->win[WIN_OSD1].lconfig.pixfmt == PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blink_attribute(enable, blink);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_rom_clut davinci_disp_get_rom_clut(void)
+{
+	return osd->rom_clut;
+}
+
+static void _davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	if (rom_clut == ROM_CLUT0)
+		osd_clear(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+	else
+		osd_set(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+}
+
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->rom_clut = rom_clut;
+	_davinci_disp_set_rom_clut(rom_clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_clut_ycbcr(unsigned char clut_index,
+					 unsigned char y, unsigned char cb,
+					 unsigned char cr)
+{
+	/* wait until any previous writes to the CLUT RAM have completed */
+	while (osd_read(OSD_MISCCTL) & OSD_MISCCTL_CPBSY)
+		cpu_relax();
+
+	osd_write((y << OSD_CLUTRAMYCB_Y_SHIFT) | cb, OSD_CLUTRAMYCB);
+	osd_write((cr << OSD_CLUTRAMCR_CR_SHIFT) | clut_index, OSD_CLUTRAMCR);
+}
+
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = y;
+	osd->clut_ram[clut_index][1] = cb;
+	osd->clut_ram[clut_index][2] = cr;
+	_davinci_disp_set_clut_ycbcr(clut_index, y, cb, cr);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_rgb_to_ycbcr(const unsigned char rgb[3],
+				       unsigned char ycbcr[3])
+{
+	int y, cb, cr;
+	int r = rgb[0];
+	int g = rgb[1];
+	int b = rgb[2];
+	/*
+	 * This conversion matrix corresponds to the conversion matrix used
+	 * by the OSD to convert RGB values to YCbCr values.  All coefficients
+	 * have been scaled by a factor of 2^22.
+	 */
+	static const int rgb_to_ycbcr[3][3] = {
+		{1250330, 2453618, 490352},
+		{-726093, -1424868, 2150957},
+		{2099836, -1750086, -349759}
+	};
+
+	y = rgb_to_ycbcr[0][0] * r + rgb_to_ycbcr[0][1] * g +
+	    rgb_to_ycbcr[0][2] * b;
+	cb = rgb_to_ycbcr[1][0] * r + rgb_to_ycbcr[1][1] * g +
+	    rgb_to_ycbcr[1][2] * b;
+	cr = rgb_to_ycbcr[2][0] * r + rgb_to_ycbcr[2][1] * g +
+	    rgb_to_ycbcr[2][2] * b;
+
+	/* round and scale */
+	y = ((y + (1 << 21)) >> 22);
+	cb = ((cb + (1 << 21)) >> 22) + 128;
+	cr = ((cr + (1 << 21)) >> 22) + 128;
+
+	/* clip */
+	y = (y < 0) ? 0 : y;
+	y = (y > 255) ? 255 : y;
+	cb = (cb < 0) ? 0 : cb;
+	cb = (cb > 255) ? 255 : cb;
+	cr = (cr < 0) ? 0 : cr;
+	cr = (cr > 255) ? 255 : cr;
+
+	ycbcr[0] = y;
+	ycbcr[1] = cb;
+	ycbcr[2] = cr;
+}
+
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b)
+{
+	unsigned char rgb[3], ycbcr[3];
+	unsigned long flags;
+
+	rgb[0] = r;
+	rgb[1] = g;
+	rgb[2] = b;
+	_davinci_disp_rgb_to_ycbcr(rgb, ycbcr);
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = ycbcr[0];
+	osd->clut_ram[clut_index][1] = ycbcr[1];
+	osd->clut_ram[clut_index][2] = ycbcr[2];
+	_davinci_disp_set_clut_ycbcr(clut_index, ycbcr[0], ycbcr[1], ycbcr[2]);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+					   unsigned char pixel_value)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned char clut_index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0xf];
+		break;
+	default:
+		clut_index = 0;
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return clut_index;
+}
+
+static void _davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+					  unsigned char pixel_value,
+					  unsigned char clut_index,
+					  enum davinci_pix_format pixfmt)
+{
+	int bmp_reg, bmp_offset, bmp_mask, bmp_shift;
+	static const int map_1bpp[] = { 0, 15 };
+	static const int map_2bpp[] = { 0, 5, 10, 15 };
+
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+		bmp_reg = map_1bpp[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		bmp_reg = map_2bpp[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		bmp_reg = pixel_value & 0xf;
+		break;
+	default:
+		return;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		bmp_offset = OSD_W0BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	case OSDWIN_OSD1:
+		bmp_offset = OSD_W1BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	default:
+		return;
+	}
+
+	if (bmp_reg & 1) {
+		bmp_shift = 8;
+		bmp_mask = 0xff << 8;
+	} else {
+		bmp_shift = 0;
+		bmp_mask = 0xff;
+	}
+
+	osd_merge(bmp_mask, clut_index << bmp_shift, bmp_offset);
+}
+
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		osdwin_state->palette_map[pixel_value & 0x1] = clut_index;
+		break;
+	case PIXFMT_2BPP:
+		osdwin_state->palette_map[pixel_value & 0x3] = clut_index;
+		break;
+	case PIXFMT_4BPP:
+		osdwin_state->palette_map[pixel_value & 0xf] = clut_index;
+		break;
+	default:
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	_davinci_disp_set_palette_map(osdwin, pixel_value, clut_index,
+				      win->lconfig.pixfmt);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->rec601_attenuation;
+}
+
+static void _davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+						 int enable)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN0MD_ATN0E,
+				  enable ? OSD_OSDWIN0MD_ATN0E : 0,
+				  OSD_OSDWIN0MD);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_merge(OSD_EXTMODE_ATNOSD0EN,
+				  enable ? OSD_EXTMODE_ATNOSD0EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	case OSDWIN_OSD1:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN1MD_ATN1E,
+				  enable ? OSD_OSDWIN1MD_ATN1E : 0,
+				  OSD_OSDWIN1MD);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_merge(OSD_EXTMODE_ATNOSD1EN,
+				  enable ? OSD_EXTMODE_ATNOSD1EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	}
+}
+
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->rec601_attenuation = (enable != 0);
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_rec601_attenuation(osdwin, enable);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->blend;
+}
+
+static void _davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+					      enum davinci_blending_factor
+					      blend)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_merge(OSD_OSDWIN0MD_BLND0,
+			  blend << OSD_OSDWIN0MD_BLND0_SHIFT, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_merge(OSD_OSDWIN1MD_BLND1,
+			  blend << OSD_OSDWIN1MD_BLND1_SHIFT, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->blend = blend;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blending_factor(osdwin, blend);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_clear(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 0;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_disable_color_key(osdwin);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+					   unsigned colorkey,
+					   enum davinci_pix_format pixfmt)
+{
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+		if (cpu_is_davinci_dm355()) {
+			switch (osdwin) {
+			case OSDWIN_OSD0:
+				osd_merge(OSD_TRANSPBMPIDX_BMP0,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP0_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			case OSDWIN_OSD1:
+				osd_merge(OSD_TRANSPBMPIDX_BMP1,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP1_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			}
+		}
+		break;
+	case PIXFMT_RGB565:
+		if (cpu_is_davinci_dm644x()) {
+			osd_write(colorkey & OSD_TRANSPVAL_RGBTRANS,
+				  OSD_TRANSPVAL);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+		}
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm355())
+			osd_merge(OSD_TRANSPVALU_Y, colorkey, OSD_TRANSPVALU);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+			osd_merge(OSD_TRANSPVALU_RGBU, colorkey >> 16,
+				  OSD_TRANSPVALU);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_set(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 1;
+	osdwin_state->colorkey = colorkey;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR) {
+		_davinci_disp_enable_color_key(osdwin, colorkey,
+					       win->lconfig.pixfmt);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->clut;
+}
+
+static void _davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+				       enum davinci_clut clut)
+{
+	u32 winmd = 0;
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN0MD_CLUTS0;
+		osd_merge(OSD_OSDWIN0MD_CLUTS0, winmd, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN1MD_CLUTS1;
+		osd_merge(OSD_OSDWIN1MD_CLUTS1, winmd, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->clut = clut;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_osd_clut(osdwin, clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_zoom = win->h_zoom;
+	*v_zoom = win->v_zoom;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_zoom(enum davinci_disp_layer layer,
+				   enum davinci_zoom_factor h_zoom,
+				   enum davinci_zoom_factor v_zoom)
+{
+	u32 winmd = 0;
+
+	switch (layer) {
+	case WIN_OSD0:
+		winmd |= (h_zoom << OSD_OSDWIN0MD_OHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN0MD_OVZ0_SHIFT);
+		osd_merge(OSD_OSDWIN0MD_OHZ0 | OSD_OSDWIN0MD_OVZ0, winmd,
+			  OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ0_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ0 | OSD_VIDWINMD_VVZ0, winmd,
+			  OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		winmd |= (h_zoom << OSD_OSDWIN1MD_OHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN1MD_OVZ1_SHIFT);
+		osd_merge(OSD_OSDWIN1MD_OHZ1 | OSD_OSDWIN1MD_OVZ1, winmd,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ1_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ1 | OSD_VIDWINMD_VVZ1, winmd,
+			  OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->h_zoom = h_zoom;
+	win->v_zoom = v_zoom;
+	_davinci_disp_set_zoom(layer, h_zoom, v_zoom);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	return win->is_enabled;
+}
+
+static void _davinci_disp_disable_layer(enum
+					davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_clear(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* disable attribute mode as well as disabling the window */
+		osd_clear(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_clear(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_disable_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+	win->is_enabled = 0;
+
+	_davinci_disp_disable_layer(layer);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_enable_attribute_mode(void)
+{
+	/* enable attribute mode for OSD1 */
+	osd_set(OSD_OSDWIN1MD_OASW, OSD_OSDWIN1MD);
+}
+
+static void _davinci_disp_enable_layer(enum
+				       davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_set(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* enable OSD1 and disable attribute mode */
+		osd_merge(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD_OACT1, OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_set(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+int davinci_disp_enable_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_allocated || !win->fb_base_phys
+	    || !win->lconfig.line_length || !win->lconfig.xsize
+	    || !win->lconfig.ysize) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+
+	if (win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return 0;
+	}
+	win->is_enabled = 1;
+
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_enable_layer(layer);
+	else {
+		_davinci_disp_enable_attribute_mode();
+		_davinci_disp_set_blink_attribute(osd->is_blinking, osd->blink);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+static void _davinci_disp_start_layer(enum davinci_disp_layer layer,
+				      unsigned long fb_base_phys)
+{
+	if (cpu_is_davinci_dm644x()) {
+		switch (layer) {
+		case WIN_OSD0:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN0ADR);
+			break;
+		case WIN_VID0:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+			break;
+		case WIN_OSD1:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN1ADR);
+			break;
+		case WIN_VID1:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN1ADR);
+			break;
+		}
+	} else if (cpu_is_davinci_dm355()) {
+		unsigned long fb_offset_32 =
+		    (fb_base_phys - DAVINCI_DDR_BASE) >> 5;
+
+		switch (layer) {
+		case WIN_OSD0:
+			osd_merge(OSD_OSDWINADH_O0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O0AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN0ADL_O0AL,
+				  OSD_OSDWIN0ADL);
+			break;
+		case WIN_VID0:
+			osd_merge(OSD_VIDWINADH_V0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V0AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN0ADL_V0AL,
+				  OSD_VIDWIN0ADL);
+			break;
+		case WIN_OSD1:
+			osd_merge(OSD_OSDWINADH_O1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O1AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN1ADL_O1AL,
+				  OSD_OSDWIN1ADL);
+			break;
+		case WIN_VID1:
+			osd_merge(OSD_VIDWINADH_V1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V1AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN1ADL_V1AL,
+				  OSD_VIDWIN1ADL);
+			break;
+		}
+	}
+}
+
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->fb_base_phys = fb_base_phys & ~0x1F;
+	_davinci_disp_start_layer(layer, fb_base_phys);
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*lconfig = win->lconfig;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+/*
+ * If the requested lconfig is completely rejected and the value of lconfig on
+ * exit is the current lconfig, then try_layer_config() returns 1.  Otherwise,
+ * try_layer_config() returns 0.  A return value of 0 does not necessarily mean
+ * that the value of lconfig on exit is identical to the value of lconfig on
+ * entry, but merely that it represents a change from the current lconfig.
+ */
+static int try_layer_config(enum davinci_disp_layer layer,
+			    struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int bad_config = 0;
+
+	/* verify that the pixel format is compatible with the layer */
+	switch (lconfig->pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+	case PIXFMT_RGB565:
+		bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		else if (cpu_is_davinci_dm355())
+			bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_OSD_ATTR:
+		bad_config = (layer != WIN_OSD1);
+		break;
+	default:
+		bad_config = 1;
+		break;
+	}
+	if (bad_config) {
+		/*
+		 * The requested pixel format is incompatible with the layer, so
+		 * keep the current layer configuration.
+		 */
+		*lconfig = win->lconfig;
+		return bad_config;
+	}
+
+	/* only one OSD window at a time can use RGB or YC pixel formats */
+	if (is_osd_win(layer)
+	    && (is_rgb_pixfmt(lconfig->pixfmt)
+		|| is_yc_pixfmt(lconfig->pixfmt))) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_OSD0)
+			pixfmt = osd->win[WIN_OSD1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_OSD0].lconfig.pixfmt;
+
+		if (is_rgb_pixfmt(pixfmt) || is_yc_pixfmt(pixfmt)) {
+			/*
+			 * The other OSD window is already configured for an RGB
+			 * or YC pixel format, so keep the current layer
+			 * configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* DM6446: only one video window at a time can use RGB888 */
+	if (is_vid_win(layer) && lconfig->pixfmt == PIXFMT_RGB888) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_VID0)
+			pixfmt = osd->win[WIN_VID1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_VID0].lconfig.pixfmt;
+
+		if (pixfmt == PIXFMT_RGB888) {
+			/*
+			 * The other video window is already configured for
+			 * RGB888, so keep the current layer configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* window dimensions must be non-zero */
+	if (!lconfig->line_length || !lconfig->xsize || !lconfig->ysize) {
+		*lconfig = win->lconfig;
+		return 1;
+	}
+
+	/* round line_length up to a multiple of 32 */
+	lconfig->line_length = ((lconfig->line_length + 31) / 32) * 32;
+	lconfig->line_length =
+	    min(lconfig->line_length, (unsigned)MAX_LINE_LENGTH);
+	lconfig->xsize = min(lconfig->xsize, (unsigned)MAX_WIN_SIZE);
+	lconfig->ysize = min(lconfig->ysize, (unsigned)MAX_WIN_SIZE);
+	lconfig->xpos = min(lconfig->xpos, (unsigned)MAX_WIN_SIZE);
+	lconfig->ypos = min(lconfig->ypos, (unsigned)MAX_WIN_SIZE);
+	lconfig->interlaced = (lconfig->interlaced != 0);
+	if (lconfig->interlaced) {
+		/* ysize and ypos must be even for interlaced displays */
+		lconfig->ysize &= ~1;
+		lconfig->ypos &= ~1;
+	}
+
+	return 0;
+}
+
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return reject_config;
+}
+
+static void _davinci_disp_disable_vid_rgb888(void)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine disables RGB888 pixel format for both video windows.
+	 * The caller must ensure that neither video window is currently
+	 * configured for RGB888 pixel format.
+	 */
+	if (cpu_is_davinci_dm644x())
+		osd_clear(OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+}
+
+static void _davinci_disp_enable_vid_rgb888(enum davinci_disp_layer layer)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine enables RGB888 pixel format for the specified video
+	 * window.  The caller must ensure that the other video window is not
+	 * currently configured for RGB888 pixel format, as this routine will
+	 * disable RGB888 pixel format for the other window.
+	 */
+	if (cpu_is_davinci_dm644x()) {
+		if (layer == WIN_VID0) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+		} else if (layer == WIN_VID1) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL);
+		}
+	}
+}
+
+static void _davinci_disp_set_cbcr_order(enum davinci_pix_format pixfmt)
+{
+	/*
+	 * The caller must ensure that all windows using YC pixfmt use the same
+	 * Cb/Cr order.
+	 */
+	if (pixfmt == PIXFMT_YCbCrI)
+		osd_clear(OSD_MODE_CS, OSD_MODE);
+	else if (pixfmt == PIXFMT_YCrCbI)
+		osd_set(OSD_MODE_CS, OSD_MODE);
+}
+
+static void _davinci_disp_set_layer_config(enum davinci_disp_layer layer, const struct davinci_layer_config
+					   *lconfig)
+{
+	u32 winmd = 0, winmd_mask = 0, bmw = 0;
+
+	_davinci_disp_set_cbcr_order(lconfig->pixfmt);
+
+	switch (layer) {
+	case WIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			winmd_mask |= OSD_OSDWIN0MD_RGB0E;
+			if (lconfig->pixfmt == PIXFMT_RGB565)
+				winmd |= OSD_OSDWIN0MD_RGB0E;
+		} else if (cpu_is_davinci_dm355()) {
+			winmd_mask |= OSD_OSDWIN0MD_BMP0MD;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_RGB565:
+				winmd |= (1 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			case PIXFMT_RGB888:
+				winmd |= (2 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			case PIXFMT_YCbCrI:
+			case PIXFMT_YCrCbI:
+				winmd |= (3 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			default:
+				break;
+			}
+		}
+
+		winmd_mask |= OSD_OSDWIN0MD_BMW0 | OSD_OSDWIN0MD_OFF0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			bmw = 0;
+			break;
+		case PIXFMT_2BPP:
+			bmw = 1;
+			break;
+		case PIXFMT_4BPP:
+			bmw = 2;
+			break;
+		case PIXFMT_8BPP:
+			bmw = 3;
+			break;
+		default:
+			break;
+		}
+		winmd |= (bmw << OSD_OSDWIN0MD_BMW0_SHIFT);
+
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN0MD_OFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN0MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN0XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN0XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN0YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN0YL);
+		}
+		break;
+	case WIN_VID0:
+		winmd_mask |= OSD_VIDWINMD_VFF0;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN0XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN0XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN0YL);
+		}
+		break;
+	case WIN_OSD1:
+		/*
+		 * The caller must ensure that OSD1 is disabled prior to
+		 * switching from a normal mode to attribute mode or from
+		 * attribute mode to a normal mode.
+		 */
+		if (lconfig->pixfmt == PIXFMT_OSD_ATTR) {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_ATN1E | OSD_OSDWIN1MD_RGB1E |
+				    OSD_OSDWIN1MD_CLUTS1 | OSD_OSDWIN1MD_BLND1 |
+				    OSD_OSDWIN1MD_TE1;
+			} else {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_BMP1MD | OSD_OSDWIN1MD_CLUTS1
+				    | OSD_OSDWIN1MD_BLND1 | OSD_OSDWIN1MD_TE1;
+			}
+		} else {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |= OSD_OSDWIN1MD_RGB1E;
+				if (lconfig->pixfmt == PIXFMT_RGB565)
+					winmd |= OSD_OSDWIN1MD_RGB1E;
+			} else if (cpu_is_davinci_dm355()) {
+				winmd_mask |= OSD_OSDWIN1MD_BMP1MD;
+				switch (lconfig->pixfmt) {
+				case PIXFMT_RGB565:
+					winmd |=
+					    (1 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				case PIXFMT_RGB888:
+					winmd |=
+					    (2 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				case PIXFMT_YCbCrI:
+				case PIXFMT_YCrCbI:
+					winmd |=
+					    (3 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				default:
+					break;
+				}
+			}
+
+			winmd_mask |= OSD_OSDWIN1MD_BMW1;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_1BPP:
+				bmw = 0;
+				break;
+			case PIXFMT_2BPP:
+				bmw = 1;
+				break;
+			case PIXFMT_4BPP:
+				bmw = 2;
+				break;
+			case PIXFMT_8BPP:
+				bmw = 3;
+				break;
+			default:
+				break;
+			}
+			winmd |= (bmw << OSD_OSDWIN1MD_BMW1_SHIFT);
+		}
+
+		winmd_mask |= OSD_OSDWIN1MD_OFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN1MD_OFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN1MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN1XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN1XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN1YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN1YL);
+		}
+		break;
+	case WIN_VID1:
+		winmd_mask |= OSD_VIDWINMD_VFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN1XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN1XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN1YL);
+		}
+		break;
+	}
+}
+
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+	if (reject_config) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return reject_config;
+	}
+
+	/* update the current Cb/Cr order */
+	if (is_yc_pixfmt(lconfig->pixfmt))
+		osd->yc_pixfmt = lconfig->pixfmt;
+
+	/*
+	 * If we are switching OSD1 from normal mode to attribute mode or from
+	 * attribute mode to normal mode, then we must disable the window.
+	 */
+	if (layer == WIN_OSD1) {
+		if (((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+		     && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR))
+		    || ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+			&& (win->lconfig.pixfmt == PIXFMT_OSD_ATTR))) {
+			win->is_enabled = 0;
+			_davinci_disp_disable_layer(layer);
+		}
+	}
+
+	_davinci_disp_set_layer_config(layer, lconfig);
+
+	if (layer == WIN_OSD1) {
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[OSDWIN_OSD1];
+
+		if ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+		    && (win->lconfig.pixfmt == PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from attribute mode to normal
+			 * mode, so we must initialize the CLUT select, the
+			 * blend factor, transparency colorkey enable, and
+			 * attenuation enable (DM6446 only) bits in the
+			 * OSDWIN1MD register.
+			 */
+			_davinci_disp_set_osd_clut(OSDWIN_OSD1,
+						   osdwin_state->clut);
+			_davinci_disp_set_blending_factor(OSDWIN_OSD1,
+							  osdwin_state->blend);
+			if (osdwin_state->colorkey_blending) {
+				_davinci_disp_enable_color_key(OSDWIN_OSD1,
+							       osdwin_state->
+							       colorkey,
+							       lconfig->pixfmt);
+			} else
+				_davinci_disp_disable_color_key(OSDWIN_OSD1);
+			_davinci_disp_set_rec601_attenuation(OSDWIN_OSD1,
+							     osdwin_state->
+							     rec601_attenuation);
+		} else if ((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+			   && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from normal mode to attribute
+			 * mode, so we must initialize the blink enable and
+			 * blink interval bits in the OSDATRMD register.
+			 */
+			_davinci_disp_set_blink_attribute(osd->is_blinking,
+							  osd->blink);
+		}
+	}
+
+	/*
+	 * If we just switched to a 1-, 2-, or 4-bits-per-pixel bitmap format
+	 * then configure a default palette map.
+	 */
+	if ((lconfig->pixfmt != win->lconfig.pixfmt)
+	    && ((lconfig->pixfmt == PIXFMT_1BPP)
+		|| (lconfig->pixfmt == PIXFMT_2BPP)
+		|| (lconfig->pixfmt == PIXFMT_4BPP))) {
+		enum davinci_osd_layer osdwin =
+		    ((layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1);
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[osdwin];
+		unsigned char clut_index;
+		unsigned char clut_entries = 0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			clut_entries = 2;
+			break;
+		case PIXFMT_2BPP:
+			clut_entries = 4;
+			break;
+		case PIXFMT_4BPP:
+			clut_entries = 16;
+			break;
+		default:
+			break;
+		}
+		/*
+		 * The default palette map maps the pixel value to the clut
+		 * index, i.e. pixel value 0 maps to clut entry 0, pixel value 1
+		 * maps to clut entry 1, etc.
+		 */
+		for (clut_index = 0; clut_index < 16; clut_index++) {
+			osdwin_state->palette_map[clut_index] = clut_index;
+			if (clut_index < clut_entries) {
+				_davinci_disp_set_palette_map(osdwin,
+							      clut_index,
+							      clut_index,
+							      lconfig->pixfmt);
+			}
+		}
+	}
+
+	win->lconfig = *lconfig;
+
+	/* DM6446: configure the RGB888 enable and window selection */
+	if (osd->win[WIN_VID0].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID0);
+	else if (osd->win[WIN_VID1].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID1);
+	else
+		_davinci_disp_disable_vid_rgb888();
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+
+void davinci_disp_init_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	enum davinci_osd_layer osdwin;
+	struct davinci_osdwin_state *osdwin_state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_enabled = 0;
+	_davinci_disp_disable_layer(layer);
+
+	win->h_zoom = ZOOM_X1;
+	win->v_zoom = ZOOM_X1;
+	_davinci_disp_set_zoom(layer, win->h_zoom, win->v_zoom);
+
+	win->fb_base_phys = 0;
+	_davinci_disp_start_layer(layer, win->fb_base_phys);
+
+	win->lconfig.line_length = 0;
+	win->lconfig.xsize = 0;
+	win->lconfig.ysize = 0;
+	win->lconfig.xpos = 0;
+	win->lconfig.ypos = 0;
+	win->lconfig.interlaced = 0;
+	switch (layer) {
+	case WIN_OSD0:
+	case WIN_OSD1:
+		osdwin = (layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1;
+		osdwin_state = &osd->osdwin[osdwin];
+		/*
+		 * Other code relies on the fact that OSD windows default to a
+		 * bitmap pixel format when they are deallocated, so don't
+		 * change this default pixel format.
+		 */
+		win->lconfig.pixfmt = PIXFMT_8BPP;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		osdwin_state->clut = RAM_CLUT;
+		_davinci_disp_set_osd_clut(osdwin, osdwin_state->clut);
+		osdwin_state->colorkey_blending = 0;
+		_davinci_disp_disable_color_key(osdwin);
+		osdwin_state->blend = OSD_8_VID_0;
+		_davinci_disp_set_blending_factor(osdwin, osdwin_state->blend);
+		osdwin_state->rec601_attenuation = 0;
+		_davinci_disp_set_rec601_attenuation(osdwin,
+						     osdwin_state->
+						     rec601_attenuation);
+		if (osdwin == OSDWIN_OSD1) {
+			osd->is_blinking = 0;
+			osd->blink = BLINK_X1;
+		}
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		win->lconfig.pixfmt = osd->yc_pixfmt;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_release_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	davinci_disp_init_layer(layer);
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_allocated = 0;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_request_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+	win->is_allocated = 1;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+static void _davinci_disp_init(void)
+{
+	osd_write(0, OSD_MODE);
+	osd_write(0, OSD_VIDWINMD);
+	osd_write(0, OSD_OSDWIN0MD);
+	osd_write(0, OSD_OSDWIN1MD);
+	osd_write(0, OSD_RECTCUR);
+	osd_write(0, OSD_MISCCTL);
+	if (cpu_is_davinci_dm355()) {
+		osd_write(0, OSD_VBNDRY);
+		osd_write(0, OSD_EXTMODE);
+		osd_write(OSD_MISCCTL_DMANG, OSD_MISCCTL);
+	}
+}
+
+int davinci_disp_init(void)
+{
+	spin_lock_init(&osd->lock);
+
+	if (cpu_is_davinci_dm644x()) {
+		osd->osdregs = DM644X_OSD_REG_BASE;
+		osd->vencregs = DM644X_VENC_REG_BASE;
+	} else if (cpu_is_davinci_dm355()) {
+		osd->osdregs = DM355_OSD_REG_BASE;
+		osd->vencregs = DM355_VENC_REG_BASE;
+	} else
+		return -1;
+
+	osd->irq = IRQ_VENCINT;
+
+	_davinci_disp_init();
+
+	/* set default Cb/Cr order */
+	osd->yc_pixfmt = PIXFMT_YCbCrI;
+
+	if (cpu_is_davinci_dm644x()) {
+		/*
+		 * DM6446 silicon advisory 1.3.8 says that when using interlaced
+		 * video output, the field signal is improperly inverted for
+		 * OSD0, OSD1, and VID1.  The field signal is not inverted for
+		 * VID0.  The workaround is to set the field signal inversion
+		 * bit so that OSD0, OSD1, and VID1 have the correct field
+		 * polarity.  The VID0 ping-pong buffer register will be used
+		 * in the encoder ISR to compensate for the reversed field
+		 * polarity of VID0.
+		 */
+		osd->field_inversion = 1;
+	}
+	if (cpu_is_davinci_dm355()) {
+		/*
+		 * ROM CLUT1 on the DM355 is similar (identical?) to ROM CLUT0
+		 * on the DM6446, so make ROM_CLUT1 the default on the DM355.
+		 */
+		osd->rom_clut = ROM_CLUT1;
+	}
+	_davinci_disp_set_field_inversion(osd->field_inversion);
+	_davinci_disp_set_rom_clut(osd->rom_clut);
+
+	davinci_disp_init_layer(WIN_OSD0);
+	davinci_disp_init_layer(WIN_VID0);
+	davinci_disp_init_layer(WIN_OSD1);
+	davinci_disp_init_layer(WIN_VID1);
+
+	if (request_irq
+	    (osd->irq, davinci_disp_isr, SA_SHIRQ, "davinci_osd", osd))
+		return -1;
+
+	return 0;
+}
+
+subsys_initcall(davinci_disp_init);
+
+EXPORT_SYMBOL(davinci_disp_request_layer);
+EXPORT_SYMBOL(davinci_disp_release_layer);
+EXPORT_SYMBOL(davinci_disp_init_layer);
+EXPORT_SYMBOL(davinci_disp_enable_layer);
+EXPORT_SYMBOL(davinci_disp_disable_layer);
+EXPORT_SYMBOL(davinci_disp_layer_is_enabled);
+EXPORT_SYMBOL(davinci_disp_set_layer_config);
+EXPORT_SYMBOL(davinci_disp_try_layer_config);
+EXPORT_SYMBOL(davinci_disp_get_layer_config);
+EXPORT_SYMBOL(davinci_disp_start_layer);
+EXPORT_SYMBOL(davinci_disp_set_interpolation_filter);
+EXPORT_SYMBOL(davinci_disp_get_interpolation_filter);
+EXPORT_SYMBOL(davinci_disp_set_osd_expansion);
+EXPORT_SYMBOL(davinci_disp_get_osd_expansion);
+EXPORT_SYMBOL(davinci_disp_set_vid_expansion);
+EXPORT_SYMBOL(davinci_disp_get_vid_expansion);
+EXPORT_SYMBOL(davinci_disp_set_zoom);
+EXPORT_SYMBOL(davinci_disp_get_zoom);
+EXPORT_SYMBOL(davinci_disp_set_background);
+EXPORT_SYMBOL(davinci_disp_get_background);
+EXPORT_SYMBOL(davinci_disp_set_rom_clut);
+EXPORT_SYMBOL(davinci_disp_get_rom_clut);
+EXPORT_SYMBOL(davinci_disp_set_clut_ycbcr);
+EXPORT_SYMBOL(davinci_disp_set_clut_rgb);
+EXPORT_SYMBOL(davinci_disp_set_osd_clut);
+EXPORT_SYMBOL(davinci_disp_get_osd_clut);
+EXPORT_SYMBOL(davinci_disp_enable_color_key);
+EXPORT_SYMBOL(davinci_disp_disable_color_key);
+EXPORT_SYMBOL(davinci_disp_set_blending_factor);
+EXPORT_SYMBOL(davinci_disp_get_blending_factor);
+EXPORT_SYMBOL(davinci_disp_set_rec601_attenuation);
+EXPORT_SYMBOL(davinci_disp_get_rec601_attenuation);
+EXPORT_SYMBOL(davinci_disp_set_palette_map);
+EXPORT_SYMBOL(davinci_disp_get_palette_map);
+EXPORT_SYMBOL(davinci_disp_set_blink_attribute);
+EXPORT_SYMBOL(davinci_disp_get_blink_attribute);
+EXPORT_SYMBOL(davinci_disp_cursor_enable);
+EXPORT_SYMBOL(davinci_disp_cursor_disable);
+EXPORT_SYMBOL(davinci_disp_cursor_is_enabled);
+EXPORT_SYMBOL(davinci_disp_set_cursor_config);
+EXPORT_SYMBOL(davinci_disp_get_cursor_config);
+EXPORT_SYMBOL(davinci_disp_set_field_inversion);
+EXPORT_SYMBOL(davinci_disp_get_field_inversion);
+EXPORT_SYMBOL(davinci_disp_register_callback);
+EXPORT_SYMBOL(davinci_disp_unregister_callback);
Index: linux-2.6.10/drivers/media/video/davinci/davinci_platform.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_platform.c
@@ -0,0 +1,639 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+extern struct vid_enc_device_mgr enc_dev[];
+
+struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
+	{VID_ENC_OUTPUT_COMPOSITE,
+	 VID_ENC_STD_NTSC}
+};
+
+char *davinci_outputs[] = {
+	VID_ENC_OUTPUT_COMPOSITE,
+	VID_ENC_OUTPUT_COMPOSITE1,
+	VID_ENC_OUTPUT_SVIDEO,
+	VID_ENC_OUTPUT_SVIDEO1,
+	VID_ENC_OUTPUT_COMPONENT,
+	VID_ENC_OUTPUT_COMPONENT1,
+	VID_ENC_OUTPUT_LCD,
+	VID_ENC_OUTPUT_LCD1,
+	""
+};
+
+char *davinci_modes[] = {
+	VID_ENC_STD_NTSC,
+	"ntsc",
+	VID_ENC_STD_NTSC_RGB,
+	VID_ENC_STD_PAL,
+	"pal",
+	VID_ENC_STD_PAL_RGB,
+	VID_ENC_STD_720P_25,
+	VID_ENC_STD_720P_30,
+	VID_ENC_STD_720P_50,
+	VID_ENC_STD_720P_60,
+	VID_ENC_STD_1080I_25,
+	VID_ENC_STD_1080I_30,
+	VID_ENC_STD_1080P_25,
+	VID_ENC_STD_1080P_30,
+	VID_ENC_STD_1080P_50,
+	VID_ENC_STD_1080P_60,
+	VID_ENC_STD_480P_60,
+	VID_ENC_STD_576P_50,
+	VID_ENC_STD_640x480,
+	VID_ENC_STD_640x400,
+	VID_ENC_STD_640x350,
+	""
+};
+
+struct platform_specific_base davinci_platform_base;
+
+static __inline__ u32 dispc_reg_in(u32 offset)
+{
+	if (cpu_is_davinci_dm355())
+		return (davinci_readl(DM355_VENC_REG_BASE + offset));
+	else
+		return (davinci_readl(DM644X_VENC_REG_BASE + offset));
+}
+
+static __inline__ u32 dispc_reg_out(u32 offset, u32 val)
+{
+	if (cpu_is_davinci_dm355())
+		davinci_writel(val, (DM355_VENC_REG_BASE + offset));
+	else
+		davinci_writel(val, (DM644X_VENC_REG_BASE + offset));
+	return (val);
+}
+
+static __inline__ u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+
+	if (cpu_is_davinci_dm355())
+		addr = DM355_VENC_REG_BASE + offset;
+	else
+		addr = DM644X_VENC_REG_BASE + offset;
+
+	new_val = (davinci_readl(addr) & ~mask) | (val & mask);
+	davinci_writel(new_val, addr);
+	return (new_val);
+}
+
+void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy)
+{
+	struct vid_enc_device_mgr *mgr = &enc_dev[channel];
+	down_interruptible(&mgr->lock);
+	davinci_platform_base.basepx = basepx;
+	davinci_platform_base.basepy = basepy;
+	davinci_writel(basepx, OSD_BASEPX);
+	davinci_writel(basepx, OSD_BASEPY);
+	up(&mgr->lock);
+}
+
+EXPORT_SYMBOL(davinci_enc_set_basep);
+
+void davinci_enc_get_basep(int channel, unsigned *basepx, unsigned *basepy)
+{
+	struct vid_enc_device_mgr *mgr = &enc_dev[channel];
+	down_interruptible(&mgr->lock);
+	*basepx = davinci_platform_base.basepx;
+	*basepy = davinci_platform_base.basepy;
+	up(&mgr->lock);
+}
+
+EXPORT_SYMBOL(davinci_enc_get_basep);
+
+/**
+ * function davinci_enc_select_venc_clk
+ * @clk_source: clock source defined by davinci_enc_clk_source_type
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Select the venc input clock based on the clk_source_type.
+ */
+int davinci_enc_select_venc_clock(int clk)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_select_venc_clock);
+
+static void enableDigitalOutput(int bEnable)
+{
+	if (bEnable) {
+		dispc_reg_out(VENC_VMOD, 0);
+		dispc_reg_out(VENC_CVBS, 0);
+
+		if (!cpu_is_davinci_dm355()) {
+			dispc_reg_out(VPBE_PCR, 0);
+		}
+		dispc_reg_out(VENC_LCDOUT, 0);
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_DACSEL, 0);
+
+	} else {
+		/* Initialize the VPSS Clock Control register */
+		davinci_writel(0x18, SYS_VPSS_CLKCTL);
+
+		/* Set PINMUX0 reg to enable LCD (all other settings are kept
+		   per boot)
+		 */
+		if (!cpu_is_davinci_dm355()) {
+			davinci_cfg_reg(DM644X_LOEEN);
+			davinci_cfg_reg(DM644X_LFLDEN);
+		}
+
+		/* disable VCLK output pin enable */
+		dispc_reg_out(VENC_VIDCTL, 0x1101);
+
+		/* Disable output sync pins */
+		dispc_reg_out(VENC_SYNCCTL, 0);
+
+		/* Disable DCLOCK */
+		dispc_reg_out(VENC_DCLKCTL, 0);
+		dispc_reg_out(VENC_DRGBX1, 0x0000057C);
+
+		/* Disable LCD output control (accepting default polarity) */
+		dispc_reg_out(VENC_LCDOUT, 0);
+		if (!cpu_is_davinci_dm355()) {
+			dispc_reg_out(VENC_CMPNT, 0x100);
+		}
+
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+
+		dispc_reg_out(VENC_HSDLY, 0);
+		dispc_reg_out(VENC_VSDLY, 0);
+
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_VSTARTA, 0);
+
+		/* Set OSD clock and OSD Sync Adavance registers */
+		dispc_reg_out(VENC_OSDCLK0, 1);
+		dispc_reg_out(VENC_OSDCLK1, 2);
+	}
+}
+
+/*
+ * setting NTSC mode
+ */
+
+static void davinci_enc_set_ntsc(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x01);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM 350 Configure VDAC_CONFIG , why ?? */
+		davinci_writel(0x0E21A6B6, DM355_VDAC_CONFIG);
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
+	}
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ * setting PAL mode
+ */
+static void davinci_enc_set_pal(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x1);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM350 Configure VDAC_CONFIG  */
+		davinci_writel(0x0E21A6B6, DM355_VDAC_CONFIG);
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+	}
+
+	dispc_reg_merge(VENC_SYNCCTL, 1 << VENC_SYNCCTL_OVD_SHIFT,
+			VENC_SYNCCTL_OVD);
+
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+	dispc_reg_out(VENC_DACTST, 0x0);
+}
+
+/*
+ * davinci_enc_set_display_timing
+ */
+/* This function sets the display timing from the fb_info structure*/
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
+{
+	dispc_reg_out(VENC_HSPLS, mode->hsync_len);
+	dispc_reg_out(VENC_HSTART, mode->left_margin);
+	dispc_reg_out(VENC_HVALID, mode->xres);
+	dispc_reg_out(VENC_HINT,
+		      mode->xres + mode->left_margin + mode->right_margin - 1);
+
+	dispc_reg_out(VENC_VSPLS, mode->vsync_len);
+	dispc_reg_out(VENC_VSTART, mode->upper_margin);
+	dispc_reg_out(VENC_VVALID, mode->yres);
+	dispc_reg_out(VENC_VINT,
+		      mode->yres + mode->upper_margin + mode->lower_margin);
+};
+
+EXPORT_SYMBOL(davinci_enc_set_display_timing);
+
+/*
+ * setting DLCD 480P PRGB mode
+ */
+static void davinci_enc_set_prgb(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, 0x141);
+	/* set VPSS clock */
+	davinci_writel(0x18, SYS_VPSS_CLKCTL);
+
+	dispc_reg_out(VENC_DCLKCTL, 0);
+	dispc_reg_out(VENC_DCLKPTN0, 0);
+
+	/* Set the OSD Divisor to 1. */
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	/* Clear composite mode register */
+	dispc_reg_out(VENC_CVBS, 0);
+
+	/* Set PINMUX1 to enable all outputs needed to support RGB666 */
+	if (cpu_is_davinci_dm355()) {
+		/* Enable the venc and dlcd clocks. */
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		dispc_reg_out(VENC_CMPNT, 0x100);
+		davinci_cfg_reg(DM644X_GPIO46_47);
+		davinci_cfg_reg(DM644X_GPIO0);
+		davinci_cfg_reg(DM644X_RGB666);
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+
+	/* Set VIDCTL to select VCLKE = 1,
+	   VCLKZ =0, SYDIR = 0 (set o/p), DOMD = 0 */
+	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
+			VENC_VIDCTL_VCLKE);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
+			VENC_VIDCTL_VCLKZ);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
+			VENC_VIDCTL_SYDIR);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
+			VENC_VIDCTL_YCDIR);
+
+	dispc_reg_merge(VENC_DCLKCTL,
+			1 << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
+
+	dispc_reg_out(VENC_DCLKPTN0, 0x1);
+
+	davinci_enc_set_display_timing(mode_info);
+	dispc_reg_out(VENC_SYNCCTL,
+		      (VENC_SYNCCTL_SYEV |
+		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
+		       | VENC_SYNCCTL_VPL));
+
+	/* Configure VMOD. No change in VENC bit */
+	dispc_reg_out(VENC_VMOD, 0x2011);
+	dispc_reg_out(VENC_LCDOUT, 0x1);
+
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_720p(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	davinci_writel(0xa, SYS_VPSS_CLKCTL);
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	dispc_reg_out(VENC_HSDLY, 0);
+	dispc_reg_out(VENC_VSDLY, 0);
+	dispc_reg_out(VENC_YCCCTL, 0);
+	dispc_reg_out(VENC_VSTARTA, 0);
+
+	/* Enable all VENC, non-standard timing mode, master timing, HD,
+	   progressive
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VENC | VENC_VMOD_VMD));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_HDMD));
+	}
+	dispc_reg_out(VENC_LCDOUT, 1);
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_1080i(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	davinci_writel(0xa, SYS_VPSS_CLKCTL);
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM355_VOUT_FIELD);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM644X_LFLDEN);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	/* Enable all VENC, non-standard timing mode, master timing,
+	   HD, interlaced
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_NSIT));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD | VENC_VMOD_HDMD |
+			       VENC_VMOD_NSIT));
+	}
+}
+
+void davinci_enc_priv_setmode(struct vid_enc_device_mgr *mgr)
+{
+
+	switch (mgr->current_mode.if_type) {
+	case VID_ENC_IF_BT656:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		dispc_reg_merge(VENC_YCCCTL, 1, 1);
+		break;
+	case VID_ENC_IF_BT1120:
+		break;
+	case VID_ENC_IF_YCC8:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_YCC16:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR16 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_SRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_PRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB666 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	default:
+		break;
+	}
+
+	if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC) == 0) {
+		davinci_enc_set_ntsc(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC_RGB) == 0) {
+
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL) == 0) {
+		davinci_enc_set_pal(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL_RGB) == 0) {
+		davinci_enc_set_pal(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_640x480) == 0 ||
+		   strcmp(mgr->current_mode.name, VID_ENC_STD_640x400) == 0 ||
+		   strcmp(mgr->current_mode.name, VID_ENC_STD_640x350) == 0) {
+		davinci_enc_set_prgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_720P_30) == 0) {
+		davinci_enc_set_720p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0) {
+		davinci_enc_set_1080i(&mgr->current_mode);
+	}
+
+	return;
+}
+
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
+{
+
+	if (0 == mgr->current_mode.std) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		return;
+	}
+	davinci_enc_priv_setmode(mgr);
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode_platform);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/davinci_vpfe.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_vpfe.c
@@ -0,0 +1,2088 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davinci_vpfe.c */
+/* !FIXME needs to add code to program the i2c switch on the EVM to select tvp5146 or mt9t001 */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+#include <linux/time.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/dma-mapping.h>
+
+#include <media/davinci/davinci_vpfe.h>
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+#include <media/davinci/ccdc_dm355.h>
+#else
+#include <media/davinci/ccdc_davinci.h>
+#endif
+
+MODULE_LICENSE("GPL");
+
+/* Global variable for insmode command which will decide that either MT9T001
+ * (device =0)  or TVP5146 (device = 1) is the device
+ */
+static int device_type = TVP5146;
+//static int device_type = MT9T001;
+
+struct device *vpfe_dev;
+
+module_param(device_type, int, 0);
+
+#ifndef MODULE
+/*
+ * Pass boot-time options by adding the following string to the boot params:
+ * 	v4l2_video_capture:[option[:option]]
+ * Valid options:
+ * 	device=[MT9T031|MT9T001|TVP5146]
+ */
+
+char *dm355_devices[] = { "MT9T001", "TVP5146", "MT9T031" };
+int __init dm355_v4l2_device_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ":")) != NULL) {
+
+		if (!*this_opt)
+			continue;
+
+		if (!strncmp(this_opt, "device=", 6)) {
+			if (!strncmp(this_opt + 7, "MT9T031", 7)) {
+				device_type = MT9T031;
+			} else if (!strncmp(this_opt + 7, "MT9T001", 7)) {
+				device_type = MT9T001;
+			} else if (!strncmp(this_opt + 7, "TVP5146", 7)) {
+				device_type = TVP5146;
+			}
+		}
+	}
+	return 0;
+}
+
+__setup("v4l2_video_capture=", dm355_v4l2_device_setup);
+#endif
+
+static struct v4l2_rect ntsc_bounds = VPFE_WIN_NTSC;
+static struct v4l2_rect pal_bounds = VPFE_WIN_PAL;
+static struct v4l2_fract ntsc_aspect = VPFE_PIXELASPECT_NTSC;
+static struct v4l2_fract pal_aspect = VPFE_PIXELASPECT_PAL;
+static struct v4l2_rect ntscsp_bounds = VPFE_WIN_NTSC_SP;
+static struct v4l2_rect palsp_bounds = VPFE_WIN_PAL_SP;
+static struct v4l2_fract sp_aspect = VPFE_PIXELASPECT_NTSC_SP;
+
+static struct v4l2_rect VGA_bounds = VPFE_WIN_VGA;
+static struct v4l2_rect SVGA_bounds = VPFE_WIN_SVGA;
+static struct v4l2_rect XGA_bounds = VPFE_WIN_XGA;
+static struct v4l2_rect P480_bounds = VPFE_WIN_480p;
+static struct v4l2_rect P576_bounds = VPFE_WIN_576p;
+static struct v4l2_rect P720_bounds = VPFE_WIN_720p;
+static struct v4l2_rect P1080_bounds = VPFE_WIN_1080p;
+static struct v4l2_fract default_aspect = VPFE_PIXELASPECT_DEFAULT;
+
+static vpfe_obj vpfe_device_ycbcr = {	/* the default format is NTSC */
+	.usrs = 0,
+	.io_usrs = 0,
+	.std = VPFE_STD_AUTO,
+	.vwin = VPFE_WIN_PAL,
+	.bounds = VPFE_WIN_PAL,
+	.pixelaspect = VPFE_PIXELASPECT_NTSC,
+	.pixelfmt = V4L2_PIX_FMT_UYVY,
+	.field = V4L2_FIELD_INTERLACED,
+	.numbuffers = VPFE_DEFNUM_FBUFS,
+	.capture_device = TVP5146,
+	.tvp5146_params = {
+			   .mode = TVP5146_MODE_AUTO,
+			   .amuxmode = TVP5146_AMUX_COMPOSITE,
+			   .enablebt656sync = TRUE,
+			   .data_width = TVP5146_WIDTH_8BIT},
+
+	.irqlock = SPIN_LOCK_UNLOCKED
+};
+
+static vpfe_obj vpfe_device_raw = {	/*Default is vga mode */
+	.usrs = 0,
+	.io_usrs = 0,
+	.std = V4L2_STD_MT9T001_VGA_30FPS,
+	.vwin = VPFE_WIN_VGA,
+	.bounds = VPFE_WIN_VGA,
+	.pixelaspect = VPFE_PIXELASPECT_DEFAULT,
+	.pixelfmt = V4L2_PIX_FMT_SBGGR8,
+	.field = V4L2_FIELD_NONE,
+	.numbuffers = VPFE_DEFNUM_FBUFS,
+	.capture_device = MT9T001,
+	.irqlock = SPIN_LOCK_UNLOCKED
+	/* .resizer_no = -1, */    /* Extra field for resizer number filled in open */
+	/* .otf_on = 0 */          /* On the Fly Flag initialize to 0 i.e. Disabled */
+};
+
+static ccdc_frmfmt frm_format;
+static ccdc_imgwin image_window;
+static vpfe_obj vpfe_device = { 0 };
+
+struct v4l2_capability vpfe_drvcap = {
+	.driver = "vpfe driver",
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+	.card = "dm355 EVM",
+#else
+	.card = "DaVinci EVM",
+#endif
+	.bus_info = "Platform",
+	.version = VPFE_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING
+};
+
+/* inline function to free reserved pages  */
+void inline free_reserved_pages(unsigned long bufaddr, unsigned long bufsize)
+{
+	unsigned long size, addr;
+	if (!bufaddr)
+		return;
+	addr = bufaddr;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(bufaddr, get_order(bufsize));
+}
+
+/*
+ * ======== sense_std ========
+ */
+/*This function will get current input standard for TVP5146*/
+static int sense_std(v4l2_std_id * std_id)
+{
+	v4l2_std_id id = 0;
+	tvp5146_mode mode;
+	int ret;
+	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe sense_std...");
+	ret = tvp5146_ctrl(TVP5146_GET_STD, &mode);
+	if (ret < 0)
+		return ret;
+	switch (mode & 0x7) {
+	case TVP5146_MODE_NTSC:
+		id = V4L2_STD_NTSC;
+		break;
+	case TVP5146_MODE_PAL:
+		id = V4L2_STD_PAL;
+		break;
+	case TVP5146_MODE_PAL_M:
+		id = V4L2_STD_PAL_M;
+		break;
+	case TVP5146_MODE_PAL_CN:
+		id = V4L2_STD_PAL_N;
+		break;
+	case TVP5146_MODE_SECAM:
+		id = V4L2_STD_SECAM;
+		break;
+	case TVP5146_MODE_PAL_60:
+		id = V4L2_STD_PAL_60;
+		break;
+	}
+	if (mode & 0x8) {	/* square pixel mode */
+		id <<= 32;
+	}
+	if (mode == TVP5146_MODE_AUTO) {
+		id = VPFE_STD_AUTO;	/* auto-detection for all other modes */
+	} else if (mode == TVP5146_MODE_AUTO_SQP) {
+		id = VPFE_STD_AUTO_SQP;
+	}
+	if (id == 0)
+		return -EINVAL;
+	*std_id = id;
+	dev_dbg(vpfe_dev, "\nEnd of Davinci_vpfe sense_std...");
+	return 0;
+}
+
+/*
+ * ======== vpfe_isr ========
+ */
+/*ISR for VINT0*/
+static irqreturn_t vpfe_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int fid;
+	unsigned long jiffies_time = get_jiffies_64();
+	struct timeval timevalue;
+	int val = 0;
+
+	val = ccdc_sbl_reset();
+
+	/*Convert time representations between jiffies and struct timeval */
+	jiffies_to_timeval(jiffies_time, &timevalue);
+
+	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe\vpfe_isr...");
+	if (frm_format == CCDC_FRMFMT_INTERLACED) {
+		/* check which field we are in hardware */
+		fid = ccdc_getfid();
+		/* switch the software maintained field id */
+		vpfe->field_id ^= 1;
+		dev_dbg(vpfe_dev, "field id = %x:%x.\n", fid, vpfe->field_id);
+		if (fid == vpfe->field_id) {	/* we are in-sync here,continue */
+			if (fid == 0) {
+				/*  One frame is just being captured. If the 
+				 * next frame is available, release the current 
+				 * frame and move on 
+				 */
+				if (vpfe->curFrm != vpfe->nextFrm) {
+					/* Copy frame capture time value in 
+					 * curFrm->ts 
+					 */
+					vpfe->curFrm->ts = timevalue;
+					vpfe->curFrm->state = STATE_DONE;
+					wake_up_interruptible(&vpfe->
+							      curFrm->done);
+					vpfe->curFrm = vpfe->nextFrm;
+				}
+				/* based on whether the two fields are stored  
+				 * interleavely or separately in memory, 
+				 * reconfigure the CCDC memory address 
+				 */
+				if (vpfe->field == V4L2_FIELD_SEQ_TB) {
+					u32 addr =
+					    vpfe->curFrm->boff +
+					    vpfe->field_offset;
+					ccdc_setfbaddr((unsigned long)
+						       addr);
+				}
+			} else if (fid == 1) {
+				/* if one field is just being captured */
+				/* configure the next frame */
+				/* get the next frame from the empty queue */
+				/* if no frame is available, */
+				/* hold on to the current buffer */
+				if (!list_empty(&vpfe->dma_queue)
+				    && vpfe->curFrm == vpfe->nextFrm) {
+					vpfe->nextFrm =
+					    list_entry(vpfe->dma_queue.
+						       next, struct
+						       videobuf_buffer, queue);
+					list_del(&vpfe->nextFrm->queue);
+					vpfe->nextFrm->state = STATE_ACTIVE;
+					ccdc_setfbaddr((unsigned long)
+						       vpfe->nextFrm->boff);
+				}
+				if (vpfe->mode_changed) {
+					ccdc_setwin(&image_window,
+						    frm_format, 2);
+					/* update the field offset */
+					vpfe->field_offset =
+					    (vpfe->vwin.height -
+					     2) * vpfe->vwin.width;
+					vpfe->mode_changed = FALSE;
+				}
+			}
+		} else if (fid == 0) {
+			/* recover from any hardware out-of-sync due to */
+			/* possible switch of video source              */
+			/* for fid == 0, sync up the two fids           */
+			/* for fid == 1, no action, one bad frame will  */
+			/* go out, but it is not a big deal             */
+			vpfe->field_id = fid;
+		}
+	} else if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
+
+		dev_dbg(vpfe_dev, "\nframe format is progressive...");
+		if (vpfe->curFrm != vpfe->nextFrm) {
+			/* Copy frame capture time value in curFrm->ts */
+			vpfe->curFrm->ts = timevalue;
+			vpfe->curFrm->state = STATE_DONE;
+			wake_up_interruptible(&vpfe->curFrm->done);
+			vpfe->curFrm = vpfe->nextFrm;
+		}
+
+	}
+	dev_dbg(vpfe_dev, "interrupt returned.\n");
+	return IRQ_RETVAL(1);
+}
+
+static irqreturn_t vdint1_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+	vpfe_obj *vpfe = &vpfe_device;
+
+	dev_dbg(vpfe_dev, "\nInside vdint1_isr...");
+
+	if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
+		if (!list_empty(&vpfe->dma_queue)
+		    && vpfe->curFrm == vpfe->nextFrm) {
+			vpfe->nextFrm =
+			    list_entry(vpfe->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			list_del(&vpfe->nextFrm->queue);
+			vpfe->nextFrm->state = STATE_ACTIVE;
+			ccdc_setfbaddr((unsigned long)vpfe->nextFrm->boff);
+		}
+	}
+	return IRQ_RETVAL(1);
+}
+
+/*
+ * ======== buffer_prepare ========
+ */
+/* this is the callback function called from videobuf_qbuf() function */
+/* the buffer is prepared and queued into the dma queue */
+static int buffer_prepare(struct videobuf_queue *q,
+			  struct videobuf_buffer *vb, enum v4l2_field field)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nstarting buffer_prepare");
+	if (device_type == TVP5146) {
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+	if (vb->state == STATE_NEEDS_INIT) {
+		vb->width = vpfe->vwin.width;
+		vb->height = vpfe->vwin.height;
+		vb->size = buf_size;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_prepare");
+	return 0;
+
+}
+
+/*
+ * ======== buffer_config ========
+ */
+ /* This function is responsible to queue up vpfe buffer is into video buffer
+  * queue. 
+  */
+static void buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int i;
+	dev_dbg(vpfe_dev, "\nstarting buffer_config");
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys(vpfe->fbuffers[i]);
+		dev_dbg(vpfe_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpfe_dev, "\nEnd of buffer_config");
+}
+
+/*
+ * ======== buffer_setup ========
+ */
+ /* This function allocate free pages and makes it sure that they will not
+  * swapped 
+  */
+static int
+buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int i;
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nstarting buffer_setup");
+	if (device_type == TVP5146) {
+		*size = buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		*size = buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+
+	for (i = VPFE_DEFNUM_FBUFS; i < *count; i++) {
+		u32 size = PAGE_SIZE << (get_order(buf_size));
+		void *mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+						     get_order(buf_size));
+		if (mem) {
+			unsigned long adr = (unsigned long)mem;
+			while (size > 0) {
+				/* make sure the frame buffers are never 
+				   swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			vpfe->fbuffers[i] = mem;
+		} else {
+			break;
+		}
+	}
+	*count = vpfe->numbuffers = i;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_setup");
+	return 0;
+}
+
+/*
+ * ======== buffer_queue ========
+ */
+ /* This function adds the buffer to DMA queue */
+static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	/* add the buffer to the DMA queue */
+	dev_dbg(vpfe_dev, "\nstarting buffer_queue");
+	list_add_tail(&vb->queue, &vpfe->dma_queue);
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpfe_dev, "\nEnding buffer_queue");
+}
+
+/*
+ * ======== buffer_release ========
+ */
+ /* This function will free the buffer if it is not one
+  * of the 3 allocated at initialization time. 
+  */
+static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nStarting buffer_release");
+	if (device_type == TVP5146) {
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+
+	/* free the buffer if it is not one of the 3 allocated at initializaiton
+	 * time
+	 */
+	if (vb->i < vpfe_device.numbuffers
+	    && vb->i >= VPFE_DEFNUM_FBUFS && vpfe_device.fbuffers[vb->i]) {
+		free_pages((unsigned long)vpfe_device.
+			   fbuffers[vb->i], get_order(buf_size));
+		vpfe_device.fbuffers[vb->i] = NULL;
+	}
+	vb->state = STATE_NEEDS_INIT;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_release");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = buffer_setup,
+	.buf_prepare = buffer_prepare,
+	.buf_queue = buffer_queue,
+	.buf_release = buffer_release,
+	.buf_config = buffer_config,
+};
+
+/*
+ * ======== vpfe_doioctl ========
+ */
+ /* This function will provide different V4L2 commands.This function can be
+  * used to configure driver or get status of driver as per command passed 
+  * by application. 
+  */
+static int vpfe_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, void *arg)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	vpfe_fh *fh = file->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case VIDIOC_S_CTRL:
+	case VIDIOC_S_FMT:
+	case VIDIOC_S_STD:
+	case VIDIOC_S_CROP:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
+		ret = v4l2_prio_check(&vpfe->prio, &fh->prio);
+		if (0 != ret) {
+			return ret;
+		}
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
+		break;
+	}
+
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUEYCAP ioctl");
+			memset(cap, 0, sizeof(*cap));
+			*cap = vpfe_drvcap;
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUEYCAP ioctl");
+			break;
+		}
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			u32 index = fmt->index;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_ENUM_FMT ioctl");
+			memset(fmt, 0, sizeof(*fmt));
+
+			fmt->index = index;
+			if (device_type == TVP5146) {
+				if (index == 0) {
+					/* only yuv4:2:2 format is supported 
+					 * at this point 
+					 */
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "YCbCr4:2:2 Interleaved UYUV");
+					fmt->pixelformat = V4L2_PIX_FMT_UYVY;
+				} else if (index == 1) {
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "YCbCr4:2:2 Interleaved YUYV");
+					fmt->pixelformat = V4L2_PIX_FMT_YUYV;
+				} else {
+					ret = -EINVAL;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				if (index == 0) {
+					/* only Bayer Raw Mode format is 
+					 * supported at this point 
+					 */
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "Raw Mode -Bayer Pattern GrRBGb");
+					fmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
+				} else {
+					ret = -EINVAL;
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUM_FMT ioctl");
+
+			break;
+		}
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				down_interruptible(&vpfe->lock);
+				pixfmt->width = vpfe->vwin.width;
+				pixfmt->height = vpfe->vwin.height;
+				pixfmt->field = vpfe->field;
+				pixfmt->pixelformat = vpfe->pixelfmt;
+				if (device_type == TVP5146) {
+					pixfmt->bytesperline =
+					    pixfmt->width * 2;
+				} else {
+					pixfmt->bytesperline =
+					    (((ccdc_raw_data_size() == _8BITS)
+					      || ccdc_alaw_enable())? pixfmt->
+					     width : (pixfmt->width * 2));
+
+				}
+				pixfmt->sizeimage =
+				    pixfmt->bytesperline * pixfmt->height;
+				pixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;
+				up(&vpfe->lock);
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
+			break;
+		}
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+			enum hw_frame frame_type;
+
+			if (device_type == TVP5146)
+				frame_type = CCDC_YCBCR;
+			else
+				frame_type = CCDC_RAW;
+
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_FMT ioctl");
+			if (vpfe->started) {
+				/* make sure streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+
+			down_interruptible(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nAfter down_interruptible");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+				up(&vpfe->lock);
+				break;
+			}
+
+			if ((pixfmt->width + vpfe->vwin.left <=
+			     vpfe->bounds.width)
+			    && (pixfmt->height + vpfe->vwin.top <=
+				vpfe->bounds.height)) {
+				/* this is the case when no scaling is 
+				 * supported 
+				 */
+				/* crop window is directed modified */
+				vpfe->vwin.height = pixfmt->height;
+				vpfe->vwin.width = pixfmt->width;
+				ccdc_set_image_window(frame_type, vpfe->vwin);
+			} else {
+				ret = -EINVAL;
+				dev_dbg(vpfe_dev, "\n window size error!");
+				up(&vpfe->lock);
+				break;
+			}
+
+			/* setup the CCDC parameters accordingly */
+			if (device_type == TVP5146) {
+
+				if (pixfmt->pixelformat == V4L2_PIX_FMT_YUYV) {
+					ccdc_set_pix_order
+					    (CCDC_PIXORDER_YCBYCR);
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else if (pixfmt->pixelformat ==
+					   V4L2_PIX_FMT_UYVY) {
+					ccdc_set_pix_order
+					    (CCDC_PIXORDER_CBYCRY);
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else {
+					/* not supported format */
+					ret = -EINVAL;
+					up(&vpfe->lock);
+					break;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+
+				if (pixfmt->pixelformat == V4L2_PIX_FMT_SBGGR8) {
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else {
+					/* not supported format */
+					dev_dbg(vpfe_dev,
+						"\n format not supported");
+					ret = -EINVAL;
+					up(&vpfe->lock);
+					break;
+				}
+			}
+
+			/* Configure buffer type and frame format as per field
+			 *  value passed 
+			 */
+			if (pixfmt->field == V4L2_FIELD_INTERLACED) {
+				ccdc_set_buf_type(frame_type,
+						  CCDC_BUFTYPE_FLD_INTERLEAVED);
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_INTERLACED);
+				vpfe->field = pixfmt->field;
+			} else if (pixfmt->field == V4L2_FIELD_SEQ_TB) {
+				ccdc_set_buf_type(frame_type,
+						  CCDC_BUFTYPE_FLD_SEPARATED);
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_INTERLACED);
+				vpfe->field = pixfmt->field;
+			} else if (pixfmt->field == V4L2_FIELD_NONE) {
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_PROGRESSIVE);
+				vpfe->field = pixfmt->field;
+			} else {
+				dev_dbg(vpfe_dev, "\n field error!");
+				ret = -EINVAL;
+			}
+
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_FMT ioctl");
+			break;
+		}
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_TRY_FMT ioctl");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+
+				if (device_type == TVP5146) {
+					if (pixfmt->width >
+					    vpfe->bounds.width
+					    || pixfmt->height >
+					    vpfe->bounds.height
+					    || (pixfmt->pixelformat !=
+						V4L2_PIX_FMT_UYVY
+						&& pixfmt->pixelformat !=
+						V4L2_PIX_FMT_YUYV)) {
+						ret = -EINVAL;
+					}
+				} else if (device_type == MT9T001
+					   || device_type == MT9T031) {
+					if (pixfmt->width > vpfe->bounds.width
+					    || pixfmt->height >
+					    vpfe->bounds.height
+					    || (pixfmt->pixelformat !=
+						V4L2_PIX_FMT_SBGGR8)) {
+						ret = -EINVAL;
+					}
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_TRY_FMT ioctl");
+			break;
+		}
+	case VIDIOC_G_STD:
+		{
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
+			*id = vpfe->std;
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
+			break;
+		}
+	case VIDIOC_S_STD:
+		{
+			v4l2_std_id id = *(v4l2_std_id *) arg;
+			tvp5146_mode mode = TVP5146_MODE_INV;
+			int sqp = 0;
+			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_S_STD ioctl");
+			/* make sure streaming is not started */
+			if (vpfe->started) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+
+			if (device_type == TVP5146) {
+				if (id & V4L2_STD_625_50) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = pal_bounds;
+					vpfe->pixelaspect = pal_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      pal_bounds);
+				} else if (id & V4L2_STD_525_60) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = ntsc_bounds;
+					vpfe->pixelaspect = ntsc_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      ntsc_bounds);
+				} else if (id & VPFE_STD_625_50_SQP) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    palsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					sqp = 1;
+					id >>= 32;
+				} else if (id & VPFE_STD_525_60_SQP) {
+					vpfe->std = id;
+					sqp = 1;
+					vpfe->std = id;
+					id >>= 32;
+					vpfe->bounds = vpfe->vwin =
+					    ntscsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      ntscsp_bounds);
+				} else if (id & VPFE_STD_AUTO) {
+					mode = TVP5146_MODE_AUTO;
+					vpfe->bounds = vpfe->vwin = pal_bounds;
+					vpfe->pixelaspect = pal_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      pal_bounds);
+					vpfe->std = id;
+				} else if (id & VPFE_STD_AUTO_SQP) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    palsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					sqp = 1;
+					mode = TVP5146_MODE_AUTO_SQP;
+					vpfe->pixelaspect = sp_aspect;
+				} else {
+					ret = -EINVAL;
+				}
+				if (id == V4L2_STD_PAL_60) {
+					mode = TVP5146_MODE_PAL_60;
+				} else if (id == V4L2_STD_PAL_M) {
+					mode = TVP5146_MODE_PAL_M;
+				} else if (id == V4L2_STD_PAL_Nc
+					   || id == V4L2_STD_PAL_N) {
+					mode = TVP5146_MODE_PAL_CN;
+				} else if (id & V4L2_STD_PAL) {
+					mode = TVP5146_MODE_PAL;
+				} else if (id & V4L2_STD_NTSC) {
+					mode = TVP5146_MODE_NTSC;
+				} else if (id & V4L2_STD_SECAM) {
+					mode = TVP5146_MODE_SECAM;
+				}
+				vpfe->tvp5146_params.mode = mode | (sqp << 3);
+				tvp5146_ctrl(TVP5146_CONFIG,
+					     &vpfe->tvp5146_params);
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				/* Store image window paramters and pixel 
+				 * aspect values as per standard 
+				 * passed by application 
+				 */
+				if ((id == V4L2_STD_MT9T001_VGA_30FPS)
+				    || (id == V4L2_STD_MT9T001_VGA_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = VGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      VGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_SVGA_30FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_SVGA_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = SVGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      SVGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_XGA_30FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = XGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      XGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_480p_30FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_480p_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P480_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P480_bounds);
+				} else if ((id == V4L2_STD_MT9T001_576p_25FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_576p_50FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P576_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P576_bounds);
+				} else if ((id == V4L2_STD_MT9T001_720p_24FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_720p_30FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P720_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P720_bounds);
+				} else if ((id == V4L2_STD_MT9T001_1080p_18FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    P1080_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P1080_bounds);
+				} else {
+					ret = -EINVAL;
+				}
+				if (ret != -EINVAL) {
+					/* Call device control function to 
+					 * configure video standard 
+					 */
+					dev_dbg(vpfe_dev,
+						"\ncalling mt9t001 setup in SET_STD");
+					ret =
+					    vpfe->
+					    config_dev_fxn(MT9T001_SET_STD,
+							   &vpfe->std,
+							   vpfe->device_params);
+				}
+			}
+			dev_dbg(vpfe_dev, "\nAbove up(&vpfe->lock)");
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_STD ioctl");
+			break;
+		}
+	case VIDIOC_ENUMSTD:
+		{
+			struct v4l2_standard *std = (struct v4l2_standard *)arg;
+			u32 index = std->index;
+			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_ENUMSTD ioctl");
+			memset(std, 0, sizeof(*std));
+			std->index = index;
+
+			if (device_type == TVP5146) {
+				if (index == 0) {
+					std->id = V4L2_STD_525_60;
+					strcpy(std->name, "SD-525line-30fps");
+					std->framelines = 525;
+					std->frameperiod.numerator = 1001;
+					std->frameperiod.denominator = 30000;
+				} else if (index == 1) {
+					std->id = V4L2_STD_625_50;
+					strcpy(std->name, "SD-625line-25fps");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 25;
+				} else if (index == 2) {
+					std->id = VPFE_STD_625_50_SQP;
+					strcpy(std->name,
+					       "SD-625line-25fps square pixel");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 25;
+				} else if (index == 3) {
+					std->id = VPFE_STD_525_60_SQP;
+					strcpy(std->name,
+					       "SD-525line-25fps square pixel");
+					std->framelines = 525;
+					std->frameperiod.numerator = 1001;
+					std->frameperiod.denominator = 30000;
+				} else if (index == 4) {
+					std->id = VPFE_STD_AUTO;
+					strcpy(std->name, "automatic detect");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 1;
+				} else if (index == 5) {
+					std->id = VPFE_STD_AUTO_SQP;
+					strcpy(std->name,
+					       "automatic detect square pixel");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 1;
+				} else {
+					ret = -EINVAL;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				/* fill number of lines per frame and FPS value
+				 *  as per standard passed by application 
+				 */
+				if (index == 0) {
+					std->id = V4L2_STD_MT9T001_VGA_30FPS;
+					strcpy(std->name, "VGA-480line- 30fps");
+					std->framelines = FMT_VGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 1) {
+					std->id = V4L2_STD_MT9T001_VGA_60FPS;
+					strcpy(std->name, "VGA-480line- 60fps");
+					std->framelines = FMT_VGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_60_DENOMIRATOR;
+				} else if (index == 2) {
+					std->id = V4L2_STD_MT9T001_SVGA_30FPS;
+					strcpy(std->name,
+					       "SVGA-600line- 30fps");
+					std->framelines = FMT_SVGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 3) {
+					std->id = V4L2_STD_MT9T001_SVGA_60FPS;
+					strcpy(std->name,
+					       "SVGA-600line- 60fps");
+					std->framelines = FMT_SVGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 4) {
+					std->id = V4L2_STD_MT9T001_XGA_30FPS;
+					strcpy(std->name, "XGA-768line- 30fps");
+					std->framelines = FMT_XGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 5) {
+					std->id = V4L2_STD_MT9T001_480p_30FPS;
+					strcpy(std->name, "480p-480line-30fps");
+					std->framelines = FMT_480p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 6) {
+					std->id = V4L2_STD_MT9T001_480p_60FPS;
+					strcpy(std->name, "480p-480line-60fps");
+					std->framelines = FMT_480p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_60_DENOMIRATOR;
+				} else if (index == 7) {
+					std->id = V4L2_STD_MT9T001_576p_25FPS;
+					strcpy(std->name, "576p-576line-25fps");
+					std->framelines = FMT_576p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_25_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_25_DENOMIRATOR;
+				} else if (index == 8) {
+					std->id = V4L2_STD_MT9T001_576p_50FPS;
+					strcpy(std->name, "576p-576line-50fps");
+					std->framelines = FMT_576p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_50_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_50_DENOMIRATOR;
+				} else if (index == 9) {
+					std->id = V4L2_STD_MT9T001_720p_24FPS;
+					strcpy(std->name, "720p-720line-24fps");
+					std->framelines = FMT_720p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_24_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_24_DENOMIRATOR;
+				} else if (index == 10) {
+					std->id = V4L2_STD_MT9T001_720p_30FPS;
+					strcpy(std->name, "720p-720line-30fps");
+					std->framelines = FMT_720p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 11) {
+					std->id = V4L2_STD_MT9T001_1080p_18FPS;
+					strcpy(std->name,
+					       "1080p-1080line-18fps");
+					std->framelines = FMT_1080i_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_18_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_18_DENOMIRATOR;
+				} else {
+					ret = -EINVAL;
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMSTD ioctl");
+			break;
+		}
+	case VIDIOC_ENUMINPUT:
+		{
+			u32 index = 0;
+			struct v4l2_input *input = (struct v4l2_input *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_ENUMINPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			/* only two inputs are available */
+			if (input->index > 1)
+				ret = -EINVAL;
+			index = input->index;
+			memset(input, 0, sizeof(*input));
+			input->index = index;
+			input->type = V4L2_INPUT_TYPE_CAMERA;
+			input->std = V4L2_STD_ALL;
+			if (input->index == 0) {
+				sprintf(input->name, "COMPOSITE");
+			} else if (input->index == 1) {
+				sprintf(input->name, "S-VIDEO");
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMINPUT ioctl");
+			break;
+		}
+	case VIDIOC_G_INPUT:
+		{
+			int *index = (int *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			*index = vpfe->tvp5146_params.amuxmode;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
+			break;
+		}
+	case VIDIOC_S_INPUT:
+		{
+			int *index = (int *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			if (*index > 1 || *index < 0) {
+				ret = -EINVAL;
+			}
+			vpfe->tvp5146_params.amuxmode = *index;
+			tvp5146_ctrl(TVP5146_SET_AMUXMODE, index);
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
+			break;
+		}
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cropcap =
+			    (struct v4l2_cropcap *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_CROPCAP ioctl");
+			cropcap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			down_interruptible(&vpfe->lock);
+			cropcap->bounds = cropcap->defrect = vpfe->vwin;
+			cropcap->pixelaspect = vpfe->pixelaspect;
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_CROPCAP ioctl");
+			break;
+		}
+	case VIDIOC_G_PARM:
+		{
+			struct v4l2_streamparm *parm =
+			    (struct v4l2_streamparm *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_PARM ioctl");
+			if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				/* only capture is supported */
+				ret = -EINVAL;
+			} else {
+				struct v4l2_captureparm *capparm =
+				    &parm->parm.capture;
+				memset(capparm, 0,
+				       sizeof(struct v4l2_captureparm));
+				down_interruptible(&vpfe->lock);
+
+				if (device_type == TVP5146) {
+					if (vpfe->std & V4L2_STD_625_50) {
+						/* PAL 25fps */
+						capparm->timeperframe.
+						    numerator = 1;
+						capparm->timeperframe.
+						    denominator = 25;
+					} else {
+						/*NTSC 29.97fps */
+						capparm->timeperframe.
+						    numerator = 1001;
+						capparm->timeperframe.
+						    denominator = 30000;
+					}
+				} else if (device_type == MT9T001
+					   || device_type == MT9T031) {
+					/* fill FPS value as per standard */
+					if (vpfe->
+					    std & V4L2_STD_MT9T001_VGA_30FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_VGA_60FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_SVGA_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_SVGA_60FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_XGA_30FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_480p_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_480p_60FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_576p_25FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_25_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_25_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_576p_50FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_50_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_50_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_720p_24FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_24_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_24_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_720p_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_1080p_18FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_18_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_18_DENOMIRATOR;
+					}
+
+				}
+
+				/* Copy number of buffers allocated to arg 
+				 * passed 
+				 */
+				capparm->readbuffers = vpfe->numbuffers;
+
+				up(&vpfe->lock);
+				dev_dbg(vpfe_dev,
+					"\nEnd of VIDIOC_G_PARM ioctl");
+			}
+			break;
+		}
+	case VIDIOC_G_CTRL:
+		dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_CTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			tvp5146_ctrl(VIDIOC_G_CTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to get control value */
+			ret = vpfe->config_dev_fxn(VIDIOC_G_CTRL, arg,
+						   vpfe->device_params);
+		}
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CTRL ioctl");
+		break;
+	case VIDIOC_S_CTRL:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			ret = tvp5146_ctrl(VIDIOC_S_CTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to configure control 
+			 * value 
+			 */
+			ret = vpfe->config_dev_fxn(VIDIOC_S_CTRL, arg,
+						   vpfe->device_params);
+		}
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
+		break;
+	case VIDIOC_QUERYCTRL:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYCTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			tvp5146_ctrl(VIDIOC_QUERYCTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to query about  
+			 * supported control commands 
+			 */
+			ret = vpfe->config_dev_fxn(VIDIOC_QUERYCTRL, arg,
+						   vpfe->device_params);
+		}
+
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYCTRL ioctl");
+
+		break;
+	case VIDIOC_G_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_CROP ioctl");
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				crop->c = vpfe->vwin;
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CROP ioctl");
+			break;
+		}
+	case VIDIOC_S_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+			enum hw_frame frame_type =
+			    (device_type == TVP5146) ? CCDC_YCBCR : CCDC_RAW;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CROP ioctl");
+			if (vpfe->started) {
+				/* make sure streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			/* adjust the width to 16 pixel boundry */
+			crop->c.width = ((crop->c.width + 15) / 16) * 16;
+
+			/* make sure parameters are valid */
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_CAPTURE
+			    && (crop->c.left + crop->c.width
+				<= vpfe->bounds.left + vpfe->bounds.width)
+			    && (crop->c.top + crop->c.height
+				<= vpfe->bounds.top + vpfe->bounds.height)) {
+
+				down_interruptible(&vpfe->lock);
+				vpfe->vwin = crop->c;
+				ccdc_set_image_window(frame_type, vpfe->vwin);
+				up(&vpfe->lock);
+			} else {
+				ret = -EINVAL;
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CROP ioctl");
+			break;
+		}
+	case VIDIOC_QUERYSTD:
+		{
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYSTD ioctl");
+
+			if (device_type == TVP5146) {
+				down_interruptible(&vpfe->lock);
+				ret = sense_std(id);
+				up(&vpfe->lock);
+			} else {
+				/* return -EINVAL indicating this ioctl 
+				 * is not supported 
+				 */
+				ret = -EINVAL;
+			}
+
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYSTD ioctl");
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_PRIORITY ioctl");
+			*p = v4l2_prio_max(&vpfe->prio);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_PRIORITY ioctl");
+			break;
+		}
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_PRIORITY ioctl");
+			ret = v4l2_prio_change(&vpfe->prio, &fh->prio, *p);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_PRIORITY ioctl");
+			break;
+		}
+
+	case VIDIOC_REQBUFS:
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
+		if (vpfe->io_usrs != 0) {
+			ret = -EBUSY;
+			break;
+		}
+		down_interruptible(&vpfe->lock);
+		videobuf_queue_init(&vpfe->bufqueue, &video_qops, NULL,
+				    &vpfe->irqlock,
+				    V4L2_BUF_TYPE_VIDEO_CAPTURE,
+				    vpfe->field,
+				    sizeof(struct videobuf_buffer), fh);
+
+		videobuf_set_buftype(&vpfe->bufqueue, VIDEOBUF_BUF_LINEAR);
+
+		fh->io_allowed = TRUE;
+		vpfe->io_usrs = 1;
+		INIT_LIST_HEAD(&vpfe->dma_queue);
+		ret = videobuf_reqbufs(&vpfe->bufqueue, arg);
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
+		break;
+	case VIDIOC_QUERYBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYBUF ioctl");
+		ret = videobuf_querybuf(&vpfe->bufqueue, arg);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYBUF ioctl");
+		break;
+	case VIDIOC_QBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QBUF ioctl");
+		if (!fh->io_allowed) {
+			dev_dbg(vpfe_dev, "\nfh->io_allowed");
+			ret = -EACCES;
+		} else {
+			dev_dbg(vpfe_dev, "\n else of fh->io_allowed");
+			ret = videobuf_qbuf(&vpfe->bufqueue, arg);
+		}
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QBUF ioctl");
+		break;
+
+	case VIDIOC_DQBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_DQBUF ioctl");
+		if (!fh->io_allowed)
+			ret = -EACCES;
+		else
+			ret = videobuf_dqbuf(&vpfe->bufqueue, arg, 0);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_DQBUF ioctl");
+		break;
+
+	case VIDIOC_STREAMON:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMON ioctl");
+		if (!fh->io_allowed) {
+			ret = -EACCES;
+			break;
+		}
+		if (vpfe->started) {
+			ret = -EBUSY;
+			break;
+		}
+		ret = videobuf_streamon(&vpfe->bufqueue);
+		if (ret)
+			break;
+
+		down_interruptible(&vpfe->lock);
+		/* get the current and next frame buffers */
+		/* we expect at least one buffer is in driver at this point */
+		/* if not, error is returned */
+		if (list_empty(&vpfe->dma_queue)) {
+			ret = -EIO;
+			break;
+		}
+		dev_dbg(vpfe_dev, "cur frame %x.\n",
+			(unsigned int)vpfe->dma_queue.next);
+		vpfe->nextFrm = vpfe->curFrm =
+		    list_entry(vpfe->dma_queue.next,
+			       struct videobuf_buffer, queue);
+		/* remove the buffer from the queue */
+		list_del(&vpfe->curFrm->queue);
+		vpfe->curFrm->state = STATE_ACTIVE;
+
+		if (device_type == TVP5146) {
+			/* sense the current video input standard */
+			tvp5146_ctrl(TVP5146_CONFIG, &vpfe->tvp5146_params);
+			frm_format = ccdc_get_frame_format(CCDC_YCBCR);
+			ccdc_get_image_window(CCDC_YCBCR, &image_window);
+			/* configure the ccdc and resizer as needed   */
+			/* start capture by enabling CCDC and resizer */
+			ccdc_config_ycbcr();
+		} else {
+			frm_format = ccdc_get_frame_format(CCDC_YCBCR);
+			frm_format = ccdc_get_frame_format(CCDC_RAW);
+			ccdc_get_image_window(CCDC_RAW, &image_window);
+			/* configure the ccdc and resizer as needed   */
+			/* start capture by enabling CCDC and resizer */
+			ccdc_config_raw();
+		}
+
+		/* setup the memory address for the frame buffer */
+		ccdc_setfbaddr(((unsigned long)(vpfe->curFrm->boff)));
+		/* enable CCDC */
+		vpfe->field_id = 0;
+		vpfe->started = TRUE;
+		vpfe->mode_changed = FALSE;
+		vpfe->field_offset = (vpfe->vwin.height - 2) * vpfe->vwin.width;
+		ccdc_enable(TRUE);
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "started video streaming.\n");
+		break;
+	case VIDIOC_STREAMOFF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMOFF ioctl");
+		if (!fh->io_allowed) {
+			ret = -EACCES;
+			break;
+		}
+		if (!vpfe->started) {
+			ret = -EINVAL;
+			break;
+		}
+		/* disable CCDC */
+		down_interruptible(&vpfe->lock);
+		ccdc_enable(FALSE);
+		vpfe->started = FALSE;
+		up(&vpfe->lock);
+		ret = videobuf_streamoff(&vpfe->bufqueue);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_STREAMOFF ioctl");
+		break;
+
+	case VPFE_CMD_CONFIG_CCDC_YCBCR:
+		/* this can be used directly and bypass the V4L2 APIs */
+		{
+
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+			/* make sure the other v4l2 related fields 
+			   have consistant settings */
+			ccdc_update_ycbcr_params(arg);
+			ccdc_get_image_window(CCDC_YCBCR, &vpfe->vwin);
+
+			if (ccdc_get_buf_type(CCDC_YCBCR) ==
+			    CCDC_BUFTYPE_FLD_INTERLEAVED)
+				vpfe->field = V4L2_FIELD_INTERLACED;
+			else if (ccdc_get_buf_type(CCDC_YCBCR) ==
+				   CCDC_BUFTYPE_FLD_SEPARATED)
+				vpfe->field = V4L2_FIELD_SEQ_TB;
+
+			if (ccdc_get_pix_order() == CCDC_PIXORDER_YCBYCR)
+				vpfe->pixelfmt = V4L2_PIX_FMT_YUYV;
+			else if (ccdc_get_pix_order() == CCDC_PIXORDER_CBYCRY)
+				vpfe->pixelfmt = V4L2_PIX_FMT_UYVY;
+
+			up(&vpfe->lock);
+			break;
+		}
+	case VPFE_CMD_CONFIG_CCDC_RAW:
+		/* This command is used to configure driver for CCDC Raw 
+		 * mode parameters 
+		 */
+		{
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+
+			if (validate_ccdc_param((ccdc_config_params_raw *) arg)
+			    == -1) {
+				dev_err(vpfe_dev,
+					"\nValidation of ccdc parameters failed \n");
+				return -EINVAL;
+			} else {
+				dev_err(vpfe_dev, "\n Validation pass\n");
+				if (ccdc_update_raw_params(arg) == -1) {
+					dev_err(vpfe_dev,
+						"\n ccdc parameters update failed \n");
+					return -EINVAL;
+				}
+			}
+			break;
+		}
+
+	case VPFE_CMD_CONFIG_TVP5146:
+		/* this can be used directly and bypass the V4L2 APIs */
+		{
+			/* the settings here must be consistant with that of
+			   the CCDC's,driver does not check the consistancy */
+			tvp5146_params *params = (tvp5146_params *) arg;
+			v4l2_std_id std = 0;
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_CONFIG_TVP5146 ioctl");
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+			/* make sure the other v4l2 related fields have 
+			 * consistant settings 
+			 */
+			switch (params->mode & 0x7) {
+			case TVP5146_MODE_NTSC:
+				std = V4L2_STD_NTSC;
+				break;
+			case TVP5146_MODE_PAL:
+				std = V4L2_STD_PAL;
+				break;
+			case TVP5146_MODE_PAL_M:
+				std = V4L2_STD_PAL_M;
+				break;
+			case TVP5146_MODE_PAL_CN:
+				std = V4L2_STD_PAL_N;
+				break;
+			case TVP5146_MODE_SECAM:
+				std = V4L2_STD_SECAM;
+				break;
+			case TVP5146_MODE_PAL_60:
+				std = V4L2_STD_PAL_60;
+				break;
+			}
+			dev_dbg(vpfe_dev,
+				"\nVPFE_CMD_CONFIG_TVP5146:std = %d", (int)std);
+			if (params->mode & 0x8) {	/* square pixel mode */
+				std <<= 32;
+			}
+			/* auto-detection modes */
+			if (params->mode == TVP5146_MODE_AUTO) {
+				std = VPFE_STD_AUTO;
+			} else if (params->mode == TVP5146_MODE_AUTO_SQP) {
+				std = VPFE_STD_AUTO_SQP;
+			}
+
+			if (std & V4L2_STD_625_50) {
+				vpfe->bounds = pal_bounds;
+				vpfe->pixelaspect = pal_aspect;
+			} else if (std & V4L2_STD_525_60) {
+				vpfe->bounds = ntsc_bounds;
+				vpfe->pixelaspect = ntsc_aspect;
+			} else if (std & VPFE_STD_625_50_SQP) {
+				vpfe->bounds = palsp_bounds;
+				vpfe->pixelaspect = sp_aspect;
+			} else if (std & VPFE_STD_525_60_SQP) {
+				vpfe->bounds = ntscsp_bounds;
+				vpfe->pixelaspect = sp_aspect;
+			}
+			vpfe->std = std;
+			ret = tvp5146_ctrl(TVP5146_CONFIG, params);
+			dev_dbg(vpfe_dev,
+				"\nVPFE_CMD_CONFIG_TVP5146:ret = %d", (int)ret);
+			vpfe->tvp5146_params = *params;
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev,
+				"\nEnd VPFE_CMD_CONFIG_TVP5146 ioctl");
+			break;
+		}
+	case VPFE_CMD_S_MT9T001_PARAMS:
+		/* This command configures MT9T001 */
+		{
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_S_MT9T001_PARAMS ioctl");
+			/* Call device control function to configure MT9T001 */
+			ret = vpfe->config_dev_fxn(MT9T001_SET_PARAMS, arg,
+						   vpfe->device_params);
+			dev_dbg(vpfe_dev,
+				"\nEnd VPFE_CMD_S_MT9T001_PARAMS ioctl");
+			break;
+		}
+	case VPFE_CMD_G_MT9T001_PARAMS:
+		/* This command returns MT9T001 configuration values to 
+		 * application. 
+		 */
+		{
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_G_MT9T001_PARAMS ioctl");
+			/* Call device control function to get 
+			 * MT9T001 configuration values 
+			 */
+			ret = vpfe->config_dev_fxn(MT9T001_GET_PARAMS, arg,
+						   vpfe->device_params);
+			dev_dbg(vpfe_dev,
+				"\nEnd of VPFE_CMD_G_MT9T001_PARAMS ioctl");
+			break;
+		}
+	default:
+		dev_dbg(vpfe_dev, "\nDefault ioctl");
+		ret = -ENOIOCTLCMD;
+		break;
+	}			/* end switch(cmd) */
+	return ret;
+}
+
+/*
+ * ======== vpfe_ioctl ========
+ */
+static int vpfe_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_ioctl...");
+	ret = video_usercopy(inode, file, cmd, arg, vpfe_doioctl);
+	dev_dbg(vpfe_dev, "\n(vpfe_ioctl) video_usercopy done ...");
+	if ((ret >= 0) && (cmd == VIDIOC_S_FMT || cmd == VIDIOC_TRY_FMT)) {
+		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
+				     arg, vpfe_doioctl);
+	}
+	dev_dbg(vpfe_dev, "\nEnd of vpfe_ioctl...");
+	return ret;
+}
+
+/*
+ * ======== vpfe_mmap ========
+ */
+static int vpfe_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_mmap...");
+	return videobuf_mmap_mapper(&vpfe_device.bufqueue, vma);
+}
+
+/*
+ * ======== vpfe_open ========
+ */
+ /* Creates a file handle for video object. Initialize itwith default value */
+static int vpfe_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	vpfe_obj *vpfe = NULL;
+	vpfe_fh *fh = NULL;
+
+	dev_dbg(vpfe_dev, "vpfe: open minor=%d\n", minor);
+
+	/* check to make sure the minor numbers match */
+	if (vpfe_device.video_dev && vpfe_device.video_dev->minor == minor) {
+		vpfe = &vpfe_device;
+	} else {		/* device not found here */
+		return -ENODEV;
+	}
+
+	/* allocate per filehandle data */
+	if ((fh = kmalloc(sizeof(*fh), GFP_KERNEL)) == NULL) {
+		return -ENOMEM;
+	}
+	filep->private_data = fh;
+	fh->dev = vpfe;
+	fh->io_allowed = FALSE;
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&vpfe->prio, &fh->prio);
+	vpfe->usrs++;
+	dev_dbg(vpfe_dev, "\nvpfe_open done ...");
+	return 0;
+}
+
+/*
+ * ======== vpfe_release ========
+ */
+ /* This function disables the CCDC, Deletes the buffer queue and frees
+  * the vpfe file handle. 
+  */
+static int vpfe_release(struct inode *inode, struct file *filep)
+{
+	vpfe_fh *fh = filep->private_data;
+	vpfe_obj *vpfe = fh->dev;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_release...");
+	down_interruptible(&vpfe->lock);
+	if (fh->io_allowed) {
+		vpfe->io_usrs = 0;
+		ccdc_enable(FALSE);
+		vpfe->started = FALSE;
+		videobuf_queue_cancel(&vpfe->bufqueue);
+		vpfe->numbuffers = VPFE_DEFNUM_FBUFS;
+	}
+	vpfe->usrs--;
+	v4l2_prio_close(&vpfe->prio, &fh->prio);
+	filep->private_data = NULL;
+	if (fh != NULL)
+		kfree(fh);
+	up(&vpfe->lock);
+	dev_dbg(vpfe_dev, "\nEnd of vpfe_release...");
+	return 0;
+}
+
+static struct file_operations vpfe_fops = {
+	.owner = THIS_MODULE,
+	.open = vpfe_open,
+	.release = vpfe_release,
+	.ioctl = vpfe_ioctl,
+	.mmap = vpfe_mmap
+};
+
+static struct video_device vpfe_video_template = {
+	.name = "vpfe",
+	.type = VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
+	.hardware = 0,
+	.fops = &vpfe_fops,
+	.minor = -1,
+};
+
+static void vpfe_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero. */
+}
+
+/*
+ * ======== vpfe_probe ========
+ */
+ /* This function will allocate video device initialize and 
+  * registers the device 
+  */
+static int __init vpfe_probe(struct device *device)
+{
+	struct video_device *vfd;
+	vpfe_obj *vpfe = &vpfe_device;
+	vpfe_dev = device;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_probe...");
+	/* alloc video device */
+	if ((vfd = video_device_alloc()) == NULL) {
+		return -ENOMEM;
+	}
+	*vfd = vpfe_video_template;
+	vfd->dev = device;
+	vfd->release = video_device_release;
+
+	snprintf(vfd->name, sizeof(vfd->name),
+		 "DaVinci_VPFE_DRIVER_V%d.%d.%d",
+		 (VPFE_VERSION_CODE >> 16) & 0xff,
+		 (VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
+
+	vpfe->video_dev = vfd;
+	vpfe->usrs = 0;
+	vpfe->io_usrs = 0;
+	vpfe->started = FALSE;
+	vpfe->latest_only = TRUE;
+
+	v4l2_prio_init(&vpfe->prio);
+	init_MUTEX(&vpfe->lock);
+
+	/* register video device */
+	dev_dbg(vpfe_dev, "trying to register vpfe device.\n");
+	dev_dbg(vpfe_dev, "vpfe=%x,vpfe->video_dev=%x\n", (int)vpfe,
+		(int)&vpfe->video_dev);
+	if (video_register_device(vpfe->video_dev, VFL_TYPE_GRABBER, -1) < 0) {
+		video_device_release(vpfe->video_dev);
+		vpfe->video_dev = NULL;
+		return -1;
+	}
+
+	dev_dbg(vpfe_dev, "DaVinci vpfe: driver version V%d.%d.%d loaded\n",
+		(VPFE_VERSION_CODE >> 16) & 0xff,
+		(VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
+
+	dev_dbg(vpfe_dev, "vpfe: registered device video%d\n",
+		vpfe->video_dev->minor & 0x1f);
+
+	/* all done */
+	return 0;
+}
+
+/*
+ * ======== vpfe_remove ========
+ */
+static int vpfe_remove(struct device *device)
+{
+	/* un-register device */
+	dev_dbg(vpfe_dev, "\nUnregistering device...");
+	video_unregister_device(vpfe_device.video_dev);
+
+	return 0;
+}
+
+static struct device_driver vpfe_driver = {
+	.name = "vpfe",
+	.bus = &platform_bus_type,
+	.probe = vpfe_probe,
+	.remove = vpfe_remove,
+};
+
+static struct platform_device _vpfe_device = {
+	.name = "vpfe",
+	.id = 1,
+	.dev = {
+		.release = vpfe_platform_release,
+		}
+};
+
+/*
+ * ======== vpfe_init ========
+ */
+ /*This function allocates free pages and register the driver. Then reset the 
+  * CCDC and configure capture device with default parameters
+  */
+static int vpfe_init(void)
+{
+	int i = 0;
+	int fbuf_size;
+	ccdc_frmfmt frame_format;
+	void *mem;
+	int ret = 0;
+
+	ccdc_init();
+
+	if (device_type == TVP5146) {
+		fbuf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+		vpfe_device = vpfe_device_ycbcr;
+		frame_format = ccdc_get_frame_format(CCDC_YCBCR);
+	}
+
+	else if (device_type == MT9T001 || device_type == MT9T031) {
+		fbuf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+		vpfe_device = vpfe_device_raw;
+		frame_format = ccdc_get_frame_format(CCDC_RAW);
+	} else {
+		return -1;
+	}
+	/* allocate memory at initialization time to guarentee availability */
+	for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+		mem =
+		    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+					     get_order(fbuf_size));
+		if (mem) {
+			unsigned long adr = (unsigned long)mem;
+			u32 size = PAGE_SIZE << (get_order(fbuf_size));
+			while (size > 0) {
+				/* make sure the frame buffers 
+				   are never swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			vpfe_device.fbuffers[i] = (u8 *) mem;
+		} else {
+			while (--i >= 0) {
+				free_reserved_pages((unsigned long)
+						    vpfe_device.
+						    fbuffers[i], fbuf_size);
+			}
+			dev_err(vpfe_dev,
+				"frame buffer memory allocation failed.\n");
+			return -ENOMEM;
+		}
+	}
+	if (driver_register(&vpfe_driver) != 0) {
+		dev_err(vpfe_dev, "driver registration failed\n");
+		return -1;
+	}
+	if (platform_device_register(&_vpfe_device) != 0) {
+		driver_unregister(&vpfe_driver);
+		dev_err(vpfe_dev, "device registration failed\n");
+		return -1;
+	}
+
+	ccdc_reset();
+
+	if (device_type == TVP5146) {
+		ret = tvp5146_ctrl(TVP5146_INIT, NULL);
+		if (ret >= 0) {
+			ret = tvp5146_ctrl(TVP5146_RESET, NULL);
+			/* configure the tvp5146 to default parameters */
+			ret |=
+			    tvp5146_ctrl(TVP5146_CONFIG,
+					 &vpfe_device.tvp5146_params);
+		}
+		if (ret < 0) {
+			tvp5146_ctrl(TVP5146_CLEANUP, NULL);
+		}
+	} else if (device_type == MT9T001 || device_type == MT9T031) {
+		/* enable video port in case of raw capture */
+		ccdc_enable_vport();
+		vpfe_device.config_dev_fxn = mt9t001_ctrl;
+		/* enable the i2c switch on the MT9T031 head board */
+		if (device_type == MT9T031)
+			vpfe_device.config_dev_fxn(MT9T001_ENABLE_I2C_SWITCH,
+						   NULL, NULL);
+		ret =
+		    vpfe_device.config_dev_fxn(MT9T001_INIT,
+					       &vpfe_device.std,
+					       &vpfe_device.device_params);
+	}
+
+	if (ret < 0) {
+		platform_device_unregister(&_vpfe_device);
+		driver_unregister(&vpfe_driver);
+		/* Free memory for all image buffers */
+		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+			free_reserved_pages((unsigned long)
+					    vpfe_device.fbuffers[i], fbuf_size);
+		}
+		return -1;
+	}
+
+	/* setup interrupt handling */
+	/* request VDINT1 if progressive format */
+	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+		ret = request_irq(IRQ_VDINT1, vdint1_isr, SA_INTERRUPT,
+				  "vpfe_capture", (void *)&vpfe_device);
+		if (ret < 0) {
+			platform_device_unregister(&_vpfe_device);
+			driver_unregister(&vpfe_driver);
+			/* Free memory for all image buffers */
+			for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+				free_reserved_pages((unsigned long)
+						    vpfe_device.
+						    fbuffers[i], fbuf_size);
+			}
+			return -1;
+		}
+	}
+	ret = request_irq(IRQ_VDINT0, vpfe_isr, SA_INTERRUPT,
+			  "vpfe_capture", (void *)&vpfe_device);
+	if (ret < 0) {
+		platform_device_unregister(&_vpfe_device);
+		driver_unregister(&vpfe_driver);
+		/* Free memory for all image buffers */
+		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+			free_reserved_pages((unsigned long)
+					    vpfe_device.fbuffers[i], fbuf_size);
+		}
+		free_irq(IRQ_VDINT1, &vpfe_device);
+		return -1;
+	}
+
+	dev_err(vpfe_dev, "DaVinci v4l2 capture driver V1.0 loaded\n");
+	return 0;
+}
+
+/*
+ * ======== vpfe_cleanup ========
+ */
+ /*This function unregisters the driver and free the allocated pages */
+static void vpfe_cleanup(void)
+{
+	int i = vpfe_device.numbuffers;
+	int buf_size;
+	ccdc_frmfmt frame_format;
+	//unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
+
+	if (device_type == TVP5146) {
+		tvp5146_ctrl(TVP5146_CLEANUP, NULL);
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+		frame_format = ccdc_get_frame_format(CCDC_YCBCR);
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+		/* Free mt9t001 object memory */
+		vpfe_device.config_dev_fxn(MT9T001_CLEANUP, NULL,
+					   vpfe_device.device_params);
+		frame_format = ccdc_get_frame_format(CCDC_RAW);
+	}
+
+	platform_device_unregister(&_vpfe_device);
+	driver_unregister(&vpfe_driver);
+	/* disable interrupt */
+	free_irq(IRQ_VDINT0, &vpfe_device);
+	/* Free VDINT1 if progressive format */
+	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+		free_irq(IRQ_VDINT1, &vpfe_device);
+	}
+
+	ccdc_cleanup();
+
+	/* Free memory for all image buffers */
+	while (--i >= 0) {
+		free_reserved_pages((unsigned long)vpfe_device.
+				    fbuffers[i], buf_size);
+	}
+}
+
+module_init(vpfe_init);
+module_exit(vpfe_cleanup);
Index: linux-2.6.10/drivers/media/video/davinci/dm355_aew.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_aew.c
@@ -0,0 +1,820 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_aew.c file */
+
+/* Kernel specific header files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* File Structure fops... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* Types like size_t */
+#include <linux/cdev.h>
+#include <linux/interrupt.h>	/* For interrupt */
+#include <linux/dma-mapping.h>	/* For class_simple_create */
+#include <asm/uaccess.h>
+#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
+#include <asm/semaphore.h>
+#include <linux/device.h>
+#include <linux/major.h>
+/* Driver Header Files */
+#include <asm/arch-davinci/dm355_aew.h>	/*Local Definitions */
+#include <asm/arch-davinci/dm355_aew_hw.h>	/* Local Definitions */
+
+/*Global structure*/
+static struct class_simple *aew_class = NULL;
+struct aew_device *aew_dev_configptr;
+struct device *aewdev = NULL;
+/* device structure to make entry in device*/
+static dev_t dev;
+
+/* For registeration of charatcer device*/
+static struct cdev c_dev;
+
+/* Module License*/
+MODULE_LICENSE("GPL");
+int aew_validate_parameters(void)
+{
+	int result = 0;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+	/* Check horizontal Count */
+	if ((aew_dev_configptr->config->window_config.hz_cnt <
+	     AEW_WINDOW_HORIZONTAL_COUNT_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_cnt >
+		AEW_WINDOW_HORIZONTAL_COUNT_MAX)) {
+		dev_err(aewdev, "\n Horizontal Count is incorrect");
+		result = -EINVAL;
+	}
+	/* Check Vertical Count */
+	if ((aew_dev_configptr->config->window_config.vt_cnt <
+	     AEW_WINDOW_VERTICAL_COUNT_MIN)
+	    || (aew_dev_configptr->config->window_config.vt_cnt >
+		AEW_WINDOW_VERTICAL_COUNT_MAX)) {
+		dev_err(aewdev, "\n Vertical Count is incorrect");
+		result = -EINVAL;
+	}
+	/* Check line increment */
+	if ((AEW_NOT_EVEN ==
+	     AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
+			    hz_line_incr))
+	    || (aew_dev_configptr->config->window_config.hz_line_incr <
+		AEW_HZ_LINEINCR_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_line_incr >
+		AEW_HZ_LINEINCR_MAX)) {
+		dev_err(aewdev, "\n Invalid Parameters");
+		dev_err(aewdev, "\n Horizontal Line Increment is incorrect");
+		result = -EINVAL;
+	}
+	/* Check line increment */
+	if ((AEW_NOT_EVEN ==
+	     AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.
+			    vt_line_incr))
+	    || (aew_dev_configptr->config->window_config.vt_line_incr <
+		AEW_VT_LINEINCR_MIN)
+	    || (aew_dev_configptr->config->window_config.vt_line_incr >
+		AEW_VT_LINEINCR_MAX)) {
+		dev_err(aewdev, "\n Invalid Parameters");
+		dev_err(aewdev, "\n Vertical Line Increment is incorrect");
+		result = -EINVAL;
+	}
+	/* Check width */
+	if ((AEW_NOT_EVEN ==
+	     AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.width))
+	    || (aew_dev_configptr->config->window_config.width < AEW_WIDTH_MIN)
+	    || (aew_dev_configptr->config->window_config.width > AEW_WIDTH_MAX)) {
+		dev_err(aewdev, "\n Width is incorrect");
+
+		result = -EINVAL;
+	}
+	/* Check Height */
+	if ((AEW_NOT_EVEN ==
+	     AEW_CHECK_EVEN(aew_dev_configptr->config->window_config.height))
+	    || (aew_dev_configptr->config->window_config.height <
+		AEW_HEIGHT_MIN)
+	    || (aew_dev_configptr->config->window_config.height >
+		AEW_HEIGHT_MAX)) {
+		dev_err(aewdev, "\n height incorrect");
+		result = -EINVAL;
+	}
+	/* Check Horizontal Start */
+	if ((aew_dev_configptr->config->window_config.hz_start <
+	     AEW_HZSTART_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_start >
+		AEW_HZSTART_MAX)) {
+		dev_err(aewdev, "\n horizontal start is  incorrect");
+		result = -EINVAL;
+	}
+	if ((aew_dev_configptr->config->window_config.vt_start >
+	     AEW_VTSTART_MAX)) {
+		dev_err(aewdev, "\n Vertical start is  incorrect");
+		result = -EINVAL;
+	}
+	if ((aew_dev_configptr->config->alaw_enable > H3A_AEW_ENABLE)
+	    || (aew_dev_configptr->config->alaw_enable < H3A_AEW_DISABLE)) {
+		dev_err(aewdev, "\n A Law setting is incorrect");
+		result = -EINVAL;
+	}
+	if (aew_dev_configptr->config->saturation_limit > AEW_AVELMT_MAX) {
+		dev_err(aewdev, "\n Saturation Limit is incorrect");
+		result = -EINVAL;
+	}
+	/* Check Black Window Height */
+	if (AEW_NOT_EVEN ==
+	    AEW_CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.height)
+	    || (aew_dev_configptr->config->blackwindow_config.height <
+		AEW_BLKWINHEIGHT_MIN)
+	    || (aew_dev_configptr->config->blackwindow_config.height >
+		AEW_BLKWINHEIGHT_MAX)) {
+		dev_err(aewdev, "\n Black Window height incorrect");
+		result = -EINVAL;
+	}
+	/* Check Black Window Height */
+	if ((AEW_NOT_EVEN ==
+	     AEW_CHECK_EVEN(aew_dev_configptr->config->blackwindow_config.
+			    height))
+	    || (aew_dev_configptr->config->blackwindow_config.vt_start <
+		AEW_BLKWINVTSTART_MIN)
+	    || (aew_dev_configptr->config->blackwindow_config.vt_start >
+		AEW_BLKWINVTSTART_MAX)) {
+		dev_err(aewdev, "\n Black Window vertical Start is incorrect");
+
+		result = -EINVAL;
+	}
+
+	if (((aew_dev_configptr->config->window_config.vt_cnt)
+	     * (aew_dev_configptr->config->window_config.height)
+	     + (aew_dev_configptr->config->window_config.vt_start)) > 156) {
+		dev_err(aewdev,
+			"\n Only 156 Lines are supported for CCDC mode");
+		dev_err(aewdev, "\n Vertical count * Height + vertical Start \
+                        should not exceed 156");
+		result = -EINVAL;
+	}
+	return result;
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+}
+
+/* inline function to free reserver pages  */
+void inline aew_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long tempaddr;
+	unsigned long size;
+	tempaddr = addr;
+	if (!addr)
+		return;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(tempaddr, get_order(bufsize));
+}
+
+/* Function to perform hardware Configuration */
+int aew_hardware_setup(void)
+{
+	int result;
+	/*Size for buffer in bytes */
+	int buff_size = 0;
+	unsigned long adr;
+	unsigned long size;
+	unsigned int busyaew;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaew = AEW_GET_PCR;
+
+	/* Mask with BUSYAF bit */
+	busyaew = busyaew & AEW_BUSYAEWB;
+
+	/* Shift it 18 times to get value of 1 or 0 */
+	busyaew = busyaew >> AEW_BUSYAEWB_SHIFT;
+
+	/* If H3A Engine is busy then return */
+	if (busyaew == 1) {
+		dev_err(aewdev, "\n Error : AEW Engine is busy");
+		return -EBUSY;
+	}
+
+	result = aew_validate_parameters();
+	dev_dbg(aewdev, "Result =  %d\n", result);
+	if (result < 0) {
+		dev_err(aewdev, "Error : Parameters are incorrect \n");
+		return result;
+	}
+
+	/* Deallocate the previously allocated buffers */
+	if (aew_dev_configptr->buff_old)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
+			       aew_dev_configptr->size_window);
+
+	if (aew_dev_configptr->buff_curr)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_curr, aew_dev_configptr->size_window);
+
+	if (aew_dev_configptr->buff_app)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_app, aew_dev_configptr->size_window);
+
+	/*Allocat the buffers as per the new buffer size */
+	/*Allocate memory for old buffer */
+	buff_size = (aew_dev_configptr->config->window_config.hz_cnt)
+	    * (aew_dev_configptr->config->window_config.vt_cnt) *
+	    AEW_WINDOW_SIZE;
+
+	aew_dev_configptr->buff_old =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_old == NULL)
+		return -ENOMEM;
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_old;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for current buffer */
+	aew_dev_configptr->buff_curr =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_curr == NULL) {
+
+		/*Free all  buffer that are allocated */
+		if (aew_dev_configptr->buff_old)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_curr;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for application buffer */
+	aew_dev_configptr->buff_app =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_app == NULL) {
+		/*Free all  buffer that were allocated previously */
+		if (aew_dev_configptr->buff_old)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_old, buff_size);
+		if (aew_dev_configptr->buff_curr)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_curr, buff_size);
+		return -ENOMEM;
+	}
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_app;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/* Set the registers */
+	aew_register_setup(aew_dev_configptr);
+	aew_dev_configptr->size_window = buff_size;
+	aew_dev_configptr->aew_config = H3A_AEW_CONFIG;
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;		/*Success */
+}
+
+/* This Function is called when driver is opened */
+static int aew_open(struct inode *inode, struct file *filp)
+{
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/*Return if Device is in use (Single Channel Support is provided) */
+	if (aew_dev_configptr->in_use == AEW_IN_USE)
+		return -EBUSY;
+
+	/* Set the aew_dev_configptr structure */
+	aew_dev_configptr->config = NULL;
+
+	/* Allocate memory for configuration  structure of this channel */
+	aew_dev_configptr->config = (struct aew_configuration *)
+	    kmalloc(sizeof(struct aew_configuration), GFP_KERNEL);
+
+	if (aew_dev_configptr->config == NULL) {
+		dev_err(aewdev, "Error : Kmalloc fail\n");
+		return -ENOMEM;
+	}
+
+	/* Initiaze the wait queue */
+	init_waitqueue_head(&(aew_dev_configptr->aew_wait_queue));
+
+	/*Device is in use */
+	aew_dev_configptr->in_use = AEW_IN_USE;
+
+	/* No Hardware Set up done */
+	aew_dev_configptr->aew_config = H3A_AEW_CONFIG_NOT_DONE;
+
+	/* No statistics are available */
+	aew_dev_configptr->buffer_filled = 0;
+
+	/* Set Window Size to 0 */
+	aew_dev_configptr->size_window = 0;
+
+	/* Initialize the semaphore */
+	init_MUTEX(&(aew_dev_configptr->read_blocked));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+static void aew_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+static int aew_probe(struct device *device)
+{
+	aewdev = device;
+	return 0;
+}
+
+static int aew_remove(struct device *device)
+{
+	return 0;
+}
+
+/* This Function is called when driver is closed */
+static int aew_release(struct inode *inode, struct file *filp)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	aew_engine_setup(0);
+	/* The Application has closed device so device is not in use */
+	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
+
+	/*Release memory for configuration structure of this channel */
+	if (aew_dev_configptr->config)
+		kfree(aew_dev_configptr->config);
+
+	/* Free Old Buffer */
+	if (aew_dev_configptr->buff_old)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
+			       aew_dev_configptr->size_window);
+
+	/* Free Current Buffer */
+	if (aew_dev_configptr->buff_curr)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_curr, aew_dev_configptr->size_window);
+
+	/* Free Application Buffer */
+	if (aew_dev_configptr->buff_app)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_app,
+			       aew_dev_configptr->size_window);
+
+	aew_dev_configptr->buff_old = NULL;
+	aew_dev_configptr->buff_curr = NULL;
+	aew_dev_configptr->config = NULL;
+	aew_dev_configptr->buff_app = NULL;
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* This function will process IOCTL commands sent by the application and
+ * control the devices IO operations.
+ */
+static int aew_ioctl(struct inode *inode, struct file *filep,
+		     unsigned int cmd, unsigned long arg)
+{
+	/* Stores Previous Configurations */
+	struct aew_configuration aewconfig = *(aew_dev_configptr->config);
+	int result = 0;
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Decrement the semaphore */
+	down_interruptible(&aew_dev_configptr->read_blocked);
+
+	/*Extract the type and number bitfields, and don't decode wrong cmds: */
+	/*verify the magic number */
+	if (_IOC_TYPE(cmd) != AEW_MAGIC_NO) {
+		up(&aew_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/*verify the command number */
+	if (_IOC_NR(cmd) > AEW_IOC_MAXNR) {
+		/* Release semaphore  in case of fault */
+		up(&aew_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/* check for the permission of the operation */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		result =
+		    !access_ok(VERIFY_WRITE, (void __user *)arg,
+			       _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		result =
+		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (result) {
+		/* Release semaphore in case of fault */
+		up(&aew_dev_configptr->read_blocked);
+		return -EFAULT;
+	}
+
+	/* Switch according to IOCTL command */
+	switch (cmd) {
+		/* This ioctl is used to perform hardware set up
+		 * and will set all the regiseters */
+		/*for AF engine */
+	case AEW_S_PARAM:
+
+		/*Copy config structure passed by user */
+		if (copy_from_user(aew_dev_configptr->config,
+				   (struct aew_configuration *)arg,
+				   sizeof(struct aew_configuration))) {
+			*(aew_dev_configptr->config) = aewconfig;
+			up(&aew_dev_configptr->read_blocked);
+			return -EFAULT;
+		}
+
+		/*Call aew_hardware_setup to perform register configuration */
+		result = aew_hardware_setup();
+		if (!result) {	/* Hardware Set up is successful */
+			/*Return the no of bytes required for buffer */
+			result = aew_dev_configptr->size_window;
+		} else {
+			/*Change Configuration Structure to original */
+			*(aew_dev_configptr->config) = aewconfig;
+			dev_err(aewdev, "Error : AEW_S_PARAM  failed\n");
+		}
+
+		break;
+
+		/* This ioctl is used to return parameters in user space */
+	case AEW_G_PARAM:
+		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG) {
+			if (copy_to_user
+			    ((struct aew_configuration *)arg,
+			     aew_dev_configptr->config,
+			     sizeof(struct aew_configuration))) {
+				up(&aew_dev_configptr->read_blocked);
+				return -EFAULT;
+			} else
+				result = aew_dev_configptr->size_window;
+		} else {
+			dev_err(aewdev,
+				"Error : AEW Hardware is not configured.\n");
+			result = -EINVAL;
+		}
+		break;
+
+		/* This ioctl is used to enable AEW Engine */
+	case AEW_ENABLE:
+		/*Enable AEW Engine if Hardware set up is done */
+		if (aew_dev_configptr->aew_config == H3A_AEW_CONFIG_NOT_DONE) {
+			dev_err(aewdev,
+				"Error : AEW Hardware is not configured.\n");
+			result = -EINVAL;
+		} else
+			/* Enable AF Engine */
+			aew_engine_setup(1);
+		break;
+
+		/* This ioctl is used to disable AEW Engine */
+	case AEW_DISABLE:
+		/* Disable AEW Engine */
+		aew_engine_setup(0);
+		break;
+
+		/* Invalid Command */
+	default:
+		dev_err(aewdev, "Error: It should not come here!!\n");
+		result = -ENOTTY;
+		break;
+	}
+
+	/*Release the semaphore */
+	up(&aew_dev_configptr->read_blocked);
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* This function will return statistics to user */
+static ssize_t aew_read(struct file *filep, char *kbuff,
+			size_t size, loff_t *offset)
+{
+	void *buffer_temp;
+	int result = 0;
+	int ret;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Semaphore will return immediately if read call is busy */
+	ret = down_trylock(&(aew_dev_configptr->read_blocked));
+	if (ret != 0) {
+		dev_dbg(aewdev, "Read Call : busy  : %d\n", ret);
+		return -EBUSY;
+	}
+
+	/* First Check the size given by user */
+	if (size < aew_dev_configptr->size_window) {
+		/* Return Failure to applicaiton */
+		/*if size is less than required size */
+		dev_dbg(aewdev, "Error : Invalid size of buffer\n");
+		up(&(aew_dev_configptr->read_blocked));
+		return -1;
+	}
+
+	/* The value of buffer_filled flag determines
+	 * the status of statistics
+	 */
+	if (aew_dev_configptr->buffer_filled == 0) {
+		/* Decrement the semaphore */
+		dev_dbg(aewdev, "READ CALL IS BLOCKED............\n");
+		/* Block the read call */
+		wait_event_interruptible_timeout(aew_dev_configptr->
+						 aew_wait_queue,
+						 aew_dev_configptr->
+						 buffer_filled, AEW_TIMEOUT);
+		dev_dbg(aewdev, "Read Call is unbloked and waking up.......\n");
+		dev_dbg(aewdev, "Buffer Filled.... %d\n",
+			aew_dev_configptr->buffer_filled);
+	}
+
+	if (aew_dev_configptr->buffer_filled == 1) {
+		/* Disable the interrupts and then swap the buffers */
+		dev_dbg(aewdev, "READING............\n");
+		disable_irq(IRQ_DM355_H3AINT);
+
+		/* New Statistics are availaible */
+		aew_dev_configptr->buffer_filled = 0;
+
+		/*Swap application buffer and old buffer */
+		buffer_temp = aew_dev_configptr->buff_old;
+		aew_dev_configptr->buff_old = aew_dev_configptr->buff_app;
+		aew_dev_configptr->buff_app = buffer_temp;
+
+		/* Interrupts are enabled */
+		enable_irq(IRQ_DM355_H3AINT);
+
+		/* Copy the entire statistics located in application
+		 * buffer to user space
+		 */
+		if (copy_to_user(kbuff, aew_dev_configptr->buff_app,
+				 aew_dev_configptr->size_window)) {
+			dev_err(aewdev, "Error : Read Fault\n");
+			up(&(aew_dev_configptr->read_blocked));
+			return -EFAULT;
+		} else
+			result = aew_dev_configptr->size_window;
+
+		dev_dbg(aewdev, "Reading Done........................\n");
+	}
+
+	dev_dbg(aewdev, "APP BUFF VALUE %x\n",
+		(*((unsigned int *)(aew_dev_configptr->buff_app))));
+
+	/*Increment the semaphore */
+	up(&(aew_dev_configptr->read_blocked));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* This function will handle interrupt generated by H3A Engine. */
+static irqreturn_t aew_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* Busy AF Bit */
+	unsigned int busyaew;
+	/* Temporary Buffer for Swapping */
+	void *buffer_temp;
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaew = AEW_GET_PCR;
+
+	/* If AEW engine is not enabled, interrupt is not for AEW */
+	if (((busyaew & 0x10000) >> 16) == 0)
+		return -1;
+
+	/*Interrupt is generated by AEW, so Service the Interrupt */
+	/*Swap current buffer and old buffer */
+	buffer_temp = aew_dev_configptr->buff_curr;
+	aew_dev_configptr->buff_curr = aew_dev_configptr->buff_old;
+	aew_dev_configptr->buff_old = buffer_temp;
+
+	/* Set the AEWBUFSTAT REgister to current buffer Address */
+	aew_set_address((unsigned
+			 long)(virt_to_phys(aew_dev_configptr->buff_curr)));
+
+	/*Set buffer filled flag to indicate statistics are available */
+	aew_dev_configptr->buffer_filled = 1;
+
+	/*new statistics are available */
+	/* Wake up the read call */
+	wake_up(&(aew_dev_configptr->aew_wait_queue));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return IRQ_HANDLED;
+}
+
+/* file Operation Structure*/
+static struct file_operations aew_fops = {
+	.owner = THIS_MODULE,
+	.open = aew_open,
+	.read = aew_read,
+	.ioctl = aew_ioctl,
+	.release = aew_release,
+};
+static struct platform_device aewdevice = {
+	.name = "dm355_aew",
+	.id = 2,
+	.dev = {
+		.release = aew_platform_release,
+		}
+};
+
+static struct device_driver aew_driver = {
+	.name = "dm355_aew",
+	.bus = &platform_bus_type,
+	.probe = aew_probe,
+	.remove = aew_remove,
+};
+
+#define DRIVERNAME  "DM355AEW"
+/* Function to register the AF character device driver. */
+int __init aew_init(void)
+{
+	int err;
+	int result = 0;
+	unsigned int vpssclk;
+
+	/* Register the driver in the kernel */
+	/* dynmically get the major number for the driver using
+	   alloc_chrdev_region function */
+	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
+
+	if (result < 0) {
+		printk("Error :  Could not register character device");
+		return -ENODEV;
+	}
+	printk(KERN_INFO "aew major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
+	/*allocate memory for device structure and initialize it with 0 */
+	aew_dev_configptr =
+	    (struct aew_device *)kmalloc(sizeof(struct aew_device), GFP_KERNEL);
+	if (!aew_dev_configptr) {
+		printk("Error : kmalloc fail");
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+		return -ENOMEM;
+
+	}
+
+	/* Initialize character device */
+	cdev_init(&c_dev, &aew_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &aew_fops;
+	err = cdev_add(&c_dev, dev, 1);
+	if (err) {
+		printk("Error : Error in  Adding Davinci AEW");
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+		return -err;
+	}
+	/* register driver as a platform driver */
+	if (driver_register(&aew_driver) != 0) {
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+
+	/* Register the drive as a platform device */
+	if (platform_device_register(&aewdevice) != 0) {
+		driver_unregister(&aew_driver);
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+
+	aew_class = class_simple_create(THIS_MODULE, "dm355_aew");
+	if (!aew_class) {
+		printk("aew_init: error in creating device class\n");
+		driver_unregister(&aew_driver);
+		platform_device_unregister(&aewdevice);
+		unregister_chrdev_region(dev, 1);
+		unregister_chrdev(MAJOR(dev), DRIVERNAME);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+	/* register simple device class */
+	class_simple_device_add(aew_class, dev, NULL, "dm355_aew");
+
+	/* AEW_SELINT(interrupt_no);*/
+	AEW_SETGAMMAWD;
+	vpssclk = AEW_GETCLKCTRL;
+	vpssclk |= (1 << 4);
+	AEW_SETCLKCTRL(vpssclk);
+	/* Set up the Interrupt handler for H3AINT interrupt */
+	result =
+	    request_irq(IRQ_DM355_H3AINT, aew_isr, SA_SHIRQ, "dm644xh3a_aew",
+			(void *)aew_dev_configptr);
+
+	if (result != 0) {
+		printk("Error : Request IRQ Failed");
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+		class_simple_device_remove(dev);
+		class_simple_destroy(aew_class);
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+		driver_unregister(&aew_driver);
+		platform_device_unregister(&aewdevice);
+		cdev_del(&c_dev);
+		return result;
+	}
+
+	/* Initialize device structure */
+	memset(aew_dev_configptr, 0, sizeof(struct aew_device));
+
+	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
+	aew_dev_configptr->buffer_filled = 0;
+	return 0;		/*Sucess */
+}
+
+/*
+=====================aew_cleanup===========================
+*/
+/* This Function is called by the kernel while unloading the driver
+This will unregister the
+ Character Device Driver
+*/
+void __exit aew_cleanup(void)
+{
+	/* Device is in use */
+	if (aew_dev_configptr->in_use == AEW_IN_USE) {
+		printk("Error : Driver in use");
+		return;
+	}
+
+	free_irq(IRQ_DM355_H3AINT, aew_dev_configptr);
+	/*Free device structure */
+	if (aew_dev_configptr)
+		kfree(aew_dev_configptr);
+	aew_dev_configptr = NULL;
+	unregister_chrdev_region(dev, AEW_NR_DEVS);
+
+	driver_unregister(&aew_driver);
+
+	/* remove simple class device */
+	class_simple_device_remove(dev);
+
+	/* destroy simple class */
+	class_simple_destroy(aew_class);
+
+	platform_device_unregister(&aewdevice);
+	/* Free the interrupt Handler */
+	cdev_del(&c_dev);
+
+	/*unregistering the driver from the kernel */
+	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+}
+
+module_init(aew_init)
+    module_exit(aew_cleanup)
+    MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/dm355_aew_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_aew_hw.c
@@ -0,0 +1,149 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_aew_hw.c file */
+
+/* include driver header files */
+#include <asm/arch-davinci/dm355_aew.h>
+#include <asm/arch-davinci/dm355_aew_hw.h>
+#include <linux/device.h>
+extern struct device *aewdev;
+/* Function to set hardware configuration registers */
+int aew_register_setup(struct aew_device *aew_dev)
+{
+	unsigned int pcr = 0, win1 = 0, winstart = 0, blkwin = 0, subwin = 0;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Set up the registers */
+	pcr = regr(AEWPCR);
+
+	/* Enable A Law */
+	if (aew_dev->config->alaw_enable == H3A_AEW_ENABLE)
+		pcr |= AEW_ALAW_EN;
+	else
+		pcr &= ~AEW_ALAW_EN;
+
+	/*Configure Saturation limit */
+	pcr &= ~AVE2LMT;
+	pcr |= aew_dev->config->saturation_limit << AEW_AVE2LMT_SHIFT;
+	/* Set Input Source */
+	pcr &= ~AEW_INP_SRC;
+	pcr |= (AEW_CCDC) << AEW_INP_SRC_SHIFT;
+
+	regw(pcr, AEWPCR);
+
+	/*Window parameter configuration */
+
+	/* Configure Window Width in AEWWIN1 register */
+	win1 = 0;
+	win1 |=
+	    ((AEW_SET_VAL(aew_dev->config->window_config.height)) <<
+	     AEW_WINH_SHIFT);
+
+	/* Configure Window height  in AEWWIN1 register */
+	win1 |=
+	    ((AEW_SET_VAL(aew_dev->config->window_config.width)) <<
+	     AEW_WINW_SHIFT);
+
+	/* Configure Window vertical count  in AEWWIN2 register */
+	win1 |=
+	    ((aew_dev->config->window_config).vt_cnt - 1) << AEW_VT_COUNT_SHIFT;
+
+	/* Configure Window horizontal count  in AEWWIN1 register */
+	win1 |= ((aew_dev->config->window_config).hz_cnt - 1);
+
+	/* Configure Window vertical start  in AEWWIN1 register */
+	regw(win1, AEWWIN1);
+
+	/*Window Start parameter configuration */
+
+	winstart &= ~WINSV;
+	winstart |=
+	    (aew_dev->config->window_config).vt_start << AEW_VT_START_SHIFT;
+
+	/* Configure Window horizontal start  in AEWWIN2 register */
+	winstart &= ~WINSH;
+	winstart |= (aew_dev->config->window_config).hz_start;
+	regw(winstart, AEWINSTART);
+
+	/*Window Line Increment configuration */
+	/*Configure vertical line increment in AEWSUBWIN */
+	subwin &= ~AEWINCV;
+	subwin |=
+	    (AEW_SET_VAL(aew_dev->config->window_config.
+			 vt_line_incr) << AEW_LINE_INCR_SHIFT);
+
+	/* Configuring Horizontal Line increment in AEWSUBWIN */
+	subwin &= ~AEWINCH;
+	subwin |= (AEW_SET_VAL(aew_dev->config->window_config.hz_line_incr));
+
+	regw(subwin, AEWSUBWIN);
+
+	/* Black Window Configuration */
+	/* Configure vertical start and height in AEWWINBLK */
+	blkwin &= ~BLKWINSV;
+	blkwin |=
+	    (aew_dev->config->blackwindow_config).
+	    vt_start << AEW_BLKWIN_VT_START_SHIFT;
+
+	/* Configure height in Black window */
+	blkwin &= ~BLKWINH;
+	blkwin |= (AEW_SET_VAL(aew_dev->config->blackwindow_config.height));
+	regw(blkwin, AEWINBLK);
+
+	/* Set AFBUFST to Current buffer Physical Address */
+	regw((unsigned int)(virt_to_phys(aew_dev->buff_curr)), AEWBUFST);
+	dev_dbg(aewdev, "\n PCR is %x", regr(AEWPCR));
+	dev_dbg(aewdev, "\n SUBWIN is %x", regr(AEWSUBWIN));
+	dev_dbg(aewdev, "\n WINSTART is %x", regr(AEWINSTART));
+	dev_dbg(aewdev, "\n WINBLK is %x", regr(AEWINBLK));
+	dev_dbg(aewdev, "\n WIN1  is %x", regr(AEWWIN1));
+	dev_dbg(aewdev, "\n AEWBUST %x", regr(AEWBUFST));
+
+	AEW_SETGAMMAWD;
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* Function to enable/ disable AEW Engine */
+inline void aew_engine_setup(int value)
+{
+	unsigned int pcr;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+	dev_dbg(aewdev, "\nAEW_REG(PCR) Before Setting %x", regr(AEWPCR));
+
+	/* Read Pcr Register */
+	pcr = regr(AEWPCR);
+	pcr &= ~AEW_EN;
+	pcr |= (value << AEW_EN_SHIFT);
+
+	/*Set AF_EN bit in PCR Register */
+	regw(pcr, AEWPCR);
+
+	dev_dbg(aewdev, "\nAfter Setting %d : PCR VALUE %x", value,
+		regr(AEWPCR));
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+
+}
+
+/* Function used to set adddress */
+inline void aew_set_address(unsigned long address)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+	regw(address, AEWBUFST);
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+}
Index: linux-2.6.10/drivers/media/video/davinci/dm355_af.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_af.c
@@ -0,0 +1,803 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_af.c file */
+/* Linux specific include files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk  */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* File Structure... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/cdev.h>
+#include <linux/interrupt.h>	/* For interrupt */
+#include <linux/dma-mapping.h>	/* For class_simple_create */
+#include <asm/uaccess.h>
+#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
+#include <asm/semaphore.h>	/* Semaphore */
+#include <linux/device.h>
+#include <linux/major.h>
+/* Driver include files */
+#include <asm/arch-davinci/dm355_af.h>	/*Local Definitions */
+#include <asm/arch-davinci/dm355_af_hw.h>	/* Local Definitions */
+
+/* Module License */
+MODULE_LICENSE("GPL");
+
+/*Global structure for device */
+struct af_device *af_dev_configptr;
+
+/* For registeration of charatcer device */
+static struct cdev c_dev;
+
+/* device structure to make entry in device */
+static struct class_simple *af_class = NULL;
+static dev_t dev;
+struct device *afdev = NULL;
+/* Function to check paxel parameters */
+/* inline function to free reserver pages  */
+void inline af_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long tempaddr;
+	unsigned long size;
+	tempaddr = addr;
+	if (!addr)
+		return;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(tempaddr, get_order(bufsize));
+}
+
+/* Function to check paxel parameters */
+static int af_validate_parameters(void)
+{
+	int result = 0;
+	dev_dbg(afdev, "E\n");
+	/* Check horizontal Count */
+	if ((af_dev_configptr->config->paxel_config.hz_cnt <
+	     AF_PAXEL_HORIZONTAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.hz_cnt >
+		AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel Horizontal Count is incorrect");
+		result = -EINVAL;
+	}
+	/* Check Vertical Count */
+	if ((af_dev_configptr->config->paxel_config.vt_cnt <
+	     AF_PAXEL_VERTICAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_cnt >
+		AF_PAXEL_VERTICAL_COUNT_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel Vertical Count is incorrect");
+		result = -EINVAL;
+	}
+	/* Check line increment */
+	if ((AF_NOT_EVEN ==
+	     AF_CHECK_EVEN(af_dev_configptr->config->paxel_config.line_incr))
+	    || (af_dev_configptr->config->paxel_config.line_incr <
+		AF_LINE_INCR_MIN)
+	    || (af_dev_configptr->config->paxel_config.line_incr >
+		AF_LINE_INCR_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel Line Increment is incorrect");
+		result = -EINVAL;
+	}
+	/* Check width */
+	if ((AF_NOT_EVEN ==
+	     AF_CHECK_EVEN(af_dev_configptr->config->paxel_config.width))
+	    || (af_dev_configptr->config->paxel_config.width < AF_WIDTH_MIN)
+	    || (af_dev_configptr->config->paxel_config.width > AF_WIDTH_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel Width is incorrect");
+		result = -EINVAL;
+	}
+	/* Check Height */
+	if ((AF_NOT_EVEN ==
+	     AF_CHECK_EVEN(af_dev_configptr->config->paxel_config.height))
+	    || (af_dev_configptr->config->paxel_config.height < AF_HEIGHT_MIN)
+	    || (af_dev_configptr->config->paxel_config.height > AF_HEIGHT_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel Height is incorrect");
+		result = -EINVAL;
+	}
+	/* Check Horizontal Start */
+	if ((AF_NOT_EVEN ==
+	     AF_CHECK_EVEN(af_dev_configptr->config->paxel_config.hz_start))
+	    || (af_dev_configptr->config->paxel_config.hz_start <
+		(af_dev_configptr->config->iir_config.hz_start_pos + 2))
+	    || (af_dev_configptr->config->paxel_config.hz_start <
+		AF_HZSTART_MIN)
+	    || (af_dev_configptr->config->paxel_config.hz_start >
+		AF_HZSTART_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel horizontal start is  incorrect");
+		result = -EINVAL;
+	}
+	/* Check Vertical Start */
+	if ((af_dev_configptr->config->paxel_config.vt_start < AF_VTSTART_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_start >
+		AF_VTSTART_MAX)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n Paxel vertical start is  incorrect");
+		result = -EINVAL;
+	}
+	/* Check Threshold  */
+	if ((af_dev_configptr->config->hmf_config.threshold > AF_MEDTH_MAX)
+	    && (af_dev_configptr->config->hmf_config.enable == H3A_AF_ENABLE)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev,
+			"\n Horizontal Median Filter Threshold is  incorrect");
+		result = -EINVAL;
+	}
+	/* Check IIRSH start */
+	if (af_dev_configptr->config->iir_config.hz_start_pos > AF_IIRSH_MAX) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev,
+			"\n IIR FITLER  horizontal start position is incorrect");
+		result = -EINVAL;
+	}
+	/* Verify ALaw */
+	if ((af_dev_configptr->config->alaw_enable < H3A_AF_DISABLE)
+	    || (af_dev_configptr->config->alaw_enable > H3A_AF_ENABLE)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n ALaw Setting is incorrect");
+		result = -EINVAL;
+	}
+	/* Check RGB position */
+	if ((af_dev_configptr->config->rgb_pos < GR_GB_BAYER)
+	    || (af_dev_configptr->config->rgb_pos > RB_GG_CUSTOM)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev, "\n RGB Position Setting is incorrect");
+		result = -EINVAL;
+	}
+	/* Verify Horizontal Median Filter Setting */
+	if ((af_dev_configptr->config->hmf_config.enable < H3A_AF_DISABLE)
+	    || (af_dev_configptr->config->hmf_config.enable > H3A_AF_ENABLE)) {
+		dev_err(afdev, "\n Invalid Parameters");
+		dev_err(afdev,
+			"\n Horizontal Median Filter Setting is incorrect");
+		result = -EINVAL;
+	}
+	if (((af_dev_configptr->config->paxel_config.vt_cnt)
+	     * (af_dev_configptr->config->paxel_config.height)
+	     + (af_dev_configptr->config->paxel_config.vt_start)) > 156) {
+
+		dev_err(afdev, "\n Only 156 Lines are supported for CCDC mode");
+		dev_err(afdev, "\n Paxel count * Height + vertical Start \
+			should not exceed 156");
+		result = -EINVAL;
+	}
+	dev_dbg(afdev, "L\n");
+	return result;
+}
+
+/* Function to perform hardware set up */
+int af_hardware_setup(void)
+{
+	int result;
+
+	/*Size for buffer in bytes */
+	int buff_size;
+	unsigned long adr, size;
+	unsigned int busyaf;
+	dev_dbg(afdev, "E\n");
+
+	/* Get the value of PCR register */
+	busyaf = AF_GET_PCR;
+
+	/* Mask with BUSYAF bit */
+	busyaf = busyaf & AF_BUSYAF;
+
+	/* Shift it 15 times to get value of 1 or 0 */
+	busyaf = busyaf >> 15;
+
+	/*If busy bit is 1 then busy lock registers caanot be configured */
+	if (busyaf == 1) {
+		/* Hardware cannot be configure while engine is busy */
+		dev_err(afdev, "AF_register_setup_ERROR : Engine Busy");
+		dev_err(afdev, "\n Configuration cannot be done ");
+		return -EBUSY;
+	}
+
+	/*Check IIR Coefficient and start Values */
+	result = af_validate_parameters();
+	if (result < 0)
+		return result;
+
+	/* Compute buffer size */
+	buff_size =
+	    (af_dev_configptr->config->paxel_config.hz_cnt) *
+	    (af_dev_configptr->config->paxel_config.vt_cnt) * AF_PAXEL_SIZE;
+
+	/*Deallocate the previosu buffers */
+	/* free old buffers */
+	if (af_dev_configptr->buff_old)
+		af_free_pages((unsigned long)af_dev_configptr->buff_old,
+			      af_dev_configptr->size_paxel);
+
+	/* Free current buffer */
+	if (af_dev_configptr->buff_curr)
+		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
+			      af_dev_configptr->size_paxel);
+
+	/* Free application buffers */
+	if (af_dev_configptr->buff_app)
+		af_free_pages((unsigned long)af_dev_configptr->buff_app,
+			      af_dev_configptr->size_paxel);
+
+	/* Reallocate the buffer as per new paxel configurations */
+	/*Allocate memory for old buffer */
+	af_dev_configptr->buff_old =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (af_dev_configptr->buff_old == NULL)
+		return -ENOMEM;
+
+	/* allocate the memory for storing old statistics */
+	adr = (unsigned long)af_dev_configptr->buff_old;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for current buffer */
+	af_dev_configptr->buff_curr =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	/* Free the previously allocated buffer */
+	if (af_dev_configptr->buff_curr == NULL) {
+		if (af_dev_configptr->buff_old)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	adr = (unsigned long)af_dev_configptr->buff_curr;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for old buffer */
+	af_dev_configptr->buff_app =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (af_dev_configptr->buff_app == NULL) {
+
+		/*Free the previously allocated buffer */
+		if (af_dev_configptr->buff_curr)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_curr, buff_size);
+		/*Free the previously allocated buffer */
+		if (af_dev_configptr->buff_old)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	adr = (unsigned long)af_dev_configptr->buff_app;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	result = af_register_setup(af_dev_configptr);
+	if (result < 0)
+		return result;
+	af_dev_configptr->size_paxel = buff_size;
+
+	/*Set configuration flag to indicate HW setup done */
+	af_dev_configptr->af_config = H3A_AF_CONFIG;
+
+	dev_dbg(afdev, "L\n");
+	/*Success */
+	return 0;
+}
+
+/* This function called when driver is opened.It creates Channel
+ * Configuration Structure
+ */
+static int af_open(struct inode *inode, struct file *filp)
+{
+	dev_dbg(afdev, "E\n");
+
+	/*Return if device is in use */
+	if (af_dev_configptr->in_use == AF_IN_USE)
+		return -EBUSY;
+	af_dev_configptr->config = NULL;
+
+	/* Allocate memory for Device Structure */
+	af_dev_configptr->config = (struct af_configuration *)
+	    kmalloc(sizeof(struct af_configuration)
+		    , GFP_KERNEL);
+	if (af_dev_configptr->config == NULL) {
+		dev_err(afdev, "Error : Kmalloc fail\n");
+		return -ENOMEM;
+	}
+
+	/* Initialize the wait queue */
+	init_waitqueue_head(&(af_dev_configptr->af_wait_queue));
+
+	/* Driver is in use */
+	af_dev_configptr->in_use = AF_IN_USE;
+
+	/* Hardware is not set up */
+	af_dev_configptr->af_config = H3A_AF_CONFIG_NOT_DONE;
+	af_dev_configptr->buffer_filled = 0;
+
+	/* Initialize the semaphore */
+	init_MUTEX(&(af_dev_configptr->read_blocked));
+	dev_dbg(afdev, "L\n");
+	return 0;
+}
+
+/* This function called when driver is closed.
+ * It will deallocate all the buffers.
+ */
+static int af_release(struct inode *inode, struct file *filp)
+{
+	dev_dbg(afdev, "E\n");
+
+	af_engine_setup(0);
+	/* Free all the buffers */
+	/* free current buffer */
+	if (af_dev_configptr->buff_curr)
+		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
+			      af_dev_configptr->size_paxel);
+
+	/*Free old buffer */
+	if (af_dev_configptr->buff_old)
+		af_free_pages((unsigned long)af_dev_configptr->buff_old,
+			      af_dev_configptr->size_paxel);
+
+	/* Free application buffer */
+	if (af_dev_configptr->buff_app)
+		af_free_pages((unsigned long)af_dev_configptr->buff_app,
+			      af_dev_configptr->size_paxel);
+
+	/*Release memory for configuration structure of this channel */
+	af_dev_configptr->buff_curr = NULL;
+	af_dev_configptr->buff_old = NULL;
+	af_dev_configptr->buff_app = NULL;
+	if (af_dev_configptr->config)
+		kfree(af_dev_configptr->config);
+	af_dev_configptr->config = NULL;
+
+	/*Device is not in use */
+	af_dev_configptr->in_use = AF_NOT_IN_USE;
+
+	dev_dbg(afdev, "L\n");
+
+	return 0;
+}
+static void af_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+static int af_probe(struct device *device)
+{
+	afdev = device;
+	return 0;
+}
+
+static int af_remove(struct device *device)
+{
+	return 0;
+}
+
+/* This function will process IOCTL commands sent by the application and
+ * control the device IO operations.
+ */
+static int af_ioctl(struct inode *inode, struct file *filep,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct af_configuration afconfig = *(af_dev_configptr->config);
+	int result = 0;
+	dev_dbg(afdev, "E\n");
+
+	/* Block the semaphore while ioctl is called */
+	down_interruptible(&af_dev_configptr->read_blocked);
+
+	/*Extract the type and number bitfields, and don't */
+	/* decode wrong cmds */
+	/*return ENOTTY (inappropriate ioctl) */
+	if (_IOC_TYPE(cmd) != AF_MAGIC_NO) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	if (_IOC_NR(cmd) > AF_IOC_MAXNR) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/*Use 'access_ok' to validate user space pointer */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		result =
+		    !access_ok(VERIFY_WRITE, (void __user *)arg,
+			       _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		result =
+		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (result) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+
+		/* This ioctl is used to perform hardware */
+		/* set up for AF Engine */
+		/* It will configura all the registers. */
+	case AF_S_PARAM:
+		/*Copy params structure passed by user */
+		if (copy_from_user(af_dev_configptr->config,
+				   (struct af_configuration *)arg,
+				   sizeof(struct af_configuration))) {
+			/* Release the semaphore */
+			up(&af_dev_configptr->read_blocked);
+			return -EFAULT;
+		}
+
+		/*Call AF_hardware_setup to perform register configuration */
+		result = af_hardware_setup();
+		if (!result) {
+			result = af_dev_configptr->size_paxel;
+		} else {
+			dev_err(afdev, "Error : AF_S_PARAM failed");
+			*(af_dev_configptr->config) = afconfig;
+		}
+		break;
+
+		/* This ioctl will get the paramters from application */
+	case AF_G_PARAM:
+		/*Check if Hardware is configured or not */
+		if (af_dev_configptr->af_config == H3A_AF_CONFIG) {
+			if (copy_to_user((struct af_configuration *)arg,
+					 af_dev_configptr->config,
+					 sizeof(struct af_configuration))) {
+				up(&af_dev_configptr->read_blocked);
+				return -EFAULT;
+			} else
+				result = af_dev_configptr->size_paxel;
+
+		} else {
+			dev_dbg(afdev, "Error : AF Hardware not configured.");
+			result = -EINVAL;
+		}
+
+		break;
+
+		/* This ioctl will enable AF Engine */
+		/*if hardware configuration is done */
+	case AF_ENABLE:
+		/* Check if hardware is configured or not */
+		if (af_dev_configptr->af_config == H3A_AF_CONFIG_NOT_DONE) {
+			dev_err(afdev, "Error :  AF Hardware not configured.");
+			result = -EINVAL;
+		} else
+			af_engine_setup(1);
+		break;
+
+		/* This ioctl will disable AF Engine */
+	case AF_DISABLE:
+		af_engine_setup(0);
+		break;
+
+	default:
+		dev_err(afdev, "Error : Invalid IOCTL!");
+		result = -ENOTTY;
+		break;
+	}
+
+	/* Before returning increment semaphore */
+	up(&af_dev_configptr->read_blocked);
+	dev_dbg(afdev, "L\n");
+	return result;
+}
+
+/* Function will return the statistics to user */
+ssize_t af_read(struct file * filep, char *kbuff, size_t size, loff_t * offset)
+{
+	void *buff_temp;
+	int result = 0;
+	int ret;
+	dev_dbg(afdev, "E\n");
+	/* Semaphore will return immediately if read call is busy */
+	ret = down_trylock(&(af_dev_configptr->read_blocked));
+	if (ret != 0) {
+		dev_err(afdev, "\n Read Call : busy");
+		return -EBUSY;
+	}
+
+	/*If no of bytes specified by the user is less */
+	/* than that of buffer return error */
+	if (size < af_dev_configptr->size_paxel) {
+		dev_err(afdev, "\n Error : Invalid buffer size");
+		up(&(af_dev_configptr->read_blocked));
+		return -1;	/* Return error to application */
+	}
+
+	/* The value of bufffer_filled flag determines
+	   the status of statistics */
+	if (af_dev_configptr->buffer_filled == 0) {
+		dev_dbg(afdev, "Read call is blocked .......................");
+		/* Block the read call until new statistics are available */
+		/* or timer expires */
+		/* Decrement the semaphore count */
+		wait_event_interruptible_timeout(af_dev_configptr->
+						 af_wait_queue,
+						 af_dev_configptr->
+						 buffer_filled, AF_TIMEOUT);
+		dev_dbg(afdev,
+			"\n Read Call Unblocked..........................");
+	}
+	if (af_dev_configptr->buffer_filled == 1) {
+		/* New Statistics are available */
+		/* Disable the interrupts while swapping the buffers */
+		dev_dbg(afdev, "\n Reading.............................");
+		disable_irq(IRQ_DM355_H3AINT);
+
+		af_dev_configptr->buffer_filled = 0;
+
+		/*Swap application buffer and old buffer */
+		buff_temp = af_dev_configptr->buff_old;
+		af_dev_configptr->buff_old = af_dev_configptr->buff_app;
+		af_dev_configptr->buff_app = buff_temp;
+
+		dev_dbg(afdev, "\n Reading Done.............................");
+
+		/* Enable the interrupts  once swapping is done */
+		enable_irq(IRQ_DM355_H3AINT);
+
+		/* New Statistics are not availaible */
+		/* copy the application buffer to user */
+		/* Return the entire statistics to user */
+		if (copy_to_user(kbuff, af_dev_configptr->buff_app,
+				 af_dev_configptr->size_paxel)) {
+			/* Release the semaphore in case of fault */
+			up(&(af_dev_configptr->read_blocked));
+			return -EFAULT;
+		} else
+			result = af_dev_configptr->size_paxel;
+	}
+
+	/* Release the seamphore */
+	up(&(af_dev_configptr->read_blocked));
+	dev_dbg(afdev, "\n Read APPLICATION  BUFFER %d",
+		*((int *)((af_dev_configptr->buff_app))));
+	dev_dbg(afdev, "L\n");
+	return result;
+}
+
+/* This function will handle the H3A interrupt. */
+static irqreturn_t af_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	void *buff_temp;	/*Temporary buffer for swapping */
+	int busyaf;
+
+	dev_dbg(afdev, "E\n");
+
+	/* Get the value of PCR register */
+	busyaf = AF_GET_PCR;
+
+	/* If AF Engine has enabled, interrupt is not for AF */
+	if ((busyaf & 0x01) == 0)
+		return -1;
+
+	/*Service  the Interrupt */
+	/*Set buffer filled flag to indicate statistics are available */
+	/*Swap current buffer and old buffer */
+	buff_temp = af_dev_configptr->buff_curr;
+	af_dev_configptr->buff_curr = af_dev_configptr->buff_old;
+	af_dev_configptr->buff_old = buff_temp;
+
+	/* Set AF Buf st to current register address */
+	if (af_dev_configptr->buff_curr)
+		af_set_address((unsigned long)
+			       virt_to_phys(af_dev_configptr->buff_curr));
+
+	/* Wake up read as new statistics are available */
+	af_dev_configptr->buffer_filled = 1;
+	wake_up(&(af_dev_configptr->af_wait_queue));
+	dev_dbg(afdev, "L\n");
+	return IRQ_HANDLED;
+}
+
+/* File Operation Structure */
+static struct file_operations af_fops = {
+	.owner = THIS_MODULE,
+	.open = af_open,
+	.ioctl = af_ioctl,
+	.read = af_read,
+	.release = af_release
+};
+static struct platform_device afdevice = {
+	.name = "dm355_af",
+	.id = 2,
+	.dev = {
+		.release = af_platform_release,
+		}
+};
+
+static struct device_driver af_driver = {
+	.name = "dm355_af",
+	.bus = &platform_bus_type,
+	.probe = af_probe,
+	.remove = af_remove,
+};
+
+/* Function to register the AF character device driver. */
+/* Function to register the AF character device driver. */
+#define DRIVERNAME  "DM355AF"
+int __init af_init(void)
+{
+	int get_int;
+	int err;
+	int result = 0;
+	int interrupt_no;
+	unsigned int vpssclk;
+
+	/* Register the driver in the kernel */
+	/* dynmically get the major number for the driver using
+	   alloc_chrdev_region function */
+	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
+
+	if (result < 0) {
+		printk("Error :  Could not register character device");
+		return -ENODEV;
+	}
+	printk(KERN_INFO "af major#: %d, minor# %d\n", MAJOR(dev), MINOR(dev));
+	/*allocate memory for device structure and initialize it with 0 */
+	af_dev_configptr =
+	    (struct af_device *)kmalloc(sizeof(struct af_device), GFP_KERNEL);
+	if (!af_dev_configptr) {
+		printk("Error : kmalloc fail");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		return -ENOMEM;
+
+	}
+	/* Initialize character device */
+	cdev_init(&c_dev, &af_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &af_fops;
+	err = cdev_add(&c_dev, dev, 1);
+	if (err) {
+		printk("Error : Error in  Adding Davinci AF");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		return -err;
+	}
+	/* register driver as a platform driver */
+	if (driver_register(&af_driver) != 0) {
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+
+	/* Register the drive as a platform device */
+	if (platform_device_register(&afdevice) != 0) {
+		driver_unregister(&af_driver);
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+	af_class = class_simple_create(THIS_MODULE, "dm355_af");
+	if (!af_class) {
+		printk("af_init: error in creating device class\n");
+		driver_unregister(&af_driver);
+		platform_device_unregister(&afdevice);
+		unregister_chrdev_region(dev, 1);
+		unregister_chrdev(MAJOR(dev), DRIVERNAME);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+	/* register simple device class */
+	class_simple_device_add(af_class, dev, NULL, "dm355_af");
+
+	AF_SETGAMMAWD;
+
+	vpssclk = AF_GETCLKCTRL;
+	vpssclk |= (1 << 4);
+	AF_SETCLKCTRL(vpssclk);
+	/* Set up the Interrupt handler for H3AINT interrupt */
+	result =
+	    request_irq(IRQ_DM355_H3AINT, af_isr, SA_SHIRQ, "dm644xh3a_af",
+			(void *)af_dev_configptr);
+
+	if (result != 0) {
+		printk("Error : Request IRQ Failed");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		class_simple_device_remove(dev);
+		class_simple_destroy(af_class);
+		driver_unregister(&af_driver);
+		platform_device_unregister(&afdevice);
+		cdev_del(&c_dev);
+		return result;
+	}
+
+	/* Initialize device structure */
+	memset((unsigned char *)af_dev_configptr, 0, sizeof(struct af_device));
+
+	af_dev_configptr->in_use = AF_NOT_IN_USE;
+	af_dev_configptr->buffer_filled = 0;
+	return 0;		/*Sucess */
+}
+
+/* This function is called by the kernel while unloading the driver.
+ * It will unregister character device driver
+ */
+void __exit af_cleanup(void)
+{
+	/* Return if driver is busy */
+	if (af_dev_configptr->in_use == AF_IN_USE) {
+		printk("Error : Driver in use. Can't remove.");
+		return;
+	}
+	free_irq(IRQ_DM355_H3AINT, af_dev_configptr);
+	/*Free device structure */
+	if (af_dev_configptr)
+		kfree(af_dev_configptr);
+
+	unregister_chrdev_region(dev, AF_NR_DEVS);
+
+	driver_unregister(&af_driver);
+
+	/* remove simple class device */
+	class_simple_device_remove(dev);
+
+	/* destroy simple class */
+	class_simple_destroy(af_class);
+
+	platform_device_unregister(&afdevice);
+	/*unregistering the driver from the kernel */
+	cdev_del(&c_dev);
+	/*Free interrupt line */
+
+}
+
+module_init(af_init)
+    module_exit(af_cleanup)
+    MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/dm355_af_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_af_hw.c
@@ -0,0 +1,171 @@
+/* Include driver header file */
+#include <asm/arch-davinci/dm355_af_hw.h>
+#include <linux/device.h>
+extern struct device *afdev;
+/* Function to set register */
+int af_register_setup(struct af_device *af_dev)
+{
+	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
+	unsigned int coef = 0;
+	unsigned int base_coef_set0 = 0;
+	unsigned int base_coef_set1 = 0;
+	int index;
+//      unsigned int vpssclk;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Configure Hardware Registers */
+	/* Set PCR Register */
+	pcr = regr(AFPCR);	/* Read PCR Register */
+
+	/*Set Accumulator Mode */
+	if (af_dev->config->mode == ACCUMULATOR_PEAK)
+		pcr |= FVMODE;
+	else
+		pcr &= ~FVMODE;
+
+	/* Set A-law */
+	if (af_dev->config->alaw_enable == H3A_AF_ENABLE)
+		pcr |= AF_ALAW_EN;
+	else
+		pcr &= ~AF_ALAW_EN;
+
+	/* Set RGB Position */
+	pcr &= ~RGBPOS;
+	pcr |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
+
+	/*HMF Configurations */
+	if (af_dev->config->hmf_config.enable == H3A_AF_ENABLE) {
+		pcr &= ~AF_MED_EN;
+		/* Enable HMF */
+		pcr |= AF_MED_EN;
+
+		/* Set Median Threshold */
+		pcr &= ~MED_TH;
+		pcr |=
+		    (af_dev->config->hmf_config.threshold) << AF_MED_TH_SHIFT;
+	} else
+		pcr &= ~AF_MED_EN;
+
+	/* Set Input Source as CCDC */
+	pcr &= ~AF_INP_SRC;
+	pcr |= (AF_CCDC) << AF_INP_SRC_SHIFT;
+
+	/* Set PCR Register */
+	regw(pcr, AFPCR);
+
+	/* Configure AFPAX1 */
+	/*Paxel parameter configuration */
+	/*Set Width in AFPAX1 Register */
+	pax1 &= ~PAXW;
+	pax1 |=
+	    (AF_SET_VAL(af_dev->config->paxel_config.width)) << AF_PAXW_SHIFT;
+
+	/* Set height in AFPAX1 */
+	pax1 &= ~PAXH;
+	pax1 |= (AF_SET_VAL(af_dev->config->paxel_config.height));
+
+	regw(pax1, AFPAX1);
+
+	/* Configure AFPAX2 Register */
+	/* Set Line Increment in AFPAX2 Register */
+	pax2 &= ~AFINCV;
+	pax2 |=
+	    (AF_SET_VAL(af_dev->config->paxel_config.line_incr)) <<
+	    AF_LINE_INCR_SHIFT;
+	/* Set Vertical Count */
+	pax2 &= ~PAXVC;
+	pax2 |= (af_dev->config->paxel_config.vt_cnt - 1) << AF_VT_COUNT_SHIFT;
+	/* Set Horizontal Count */
+	pax2 &= ~PAXHC;
+	pax2 |= (af_dev->config->paxel_config.hz_cnt - 1);
+	regw(pax2, AFPAX2);
+
+	/* Configure PAXSTART Register */
+	/*Configure Horizontal Start */
+	paxstart &= ~PAXSH;
+	paxstart |=
+	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
+	/* Configure Vertical Start */
+	paxstart &= ~PAXSV;
+	paxstart |= af_dev->config->paxel_config.vt_start;
+	regw(paxstart, AFPAXSTART);
+
+	/*SetIIRSH Register */
+	regw(af_dev->config->iir_config.hz_start_pos, AFIIRSH);
+
+	/* Set IIR Filter0 Coefficients */
+	base_coef_set0 = AFCOEF010;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set0[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set0[index + 1]) << AF_COEF_SHIFT;
+		regw(coef, base_coef_set0);
+		dev_dbg(afdev, "\n COEF0 %x", regr(base_coef_set0));
+		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
+	}
+
+	/* Set AFCOEF0010 Register */
+	regw(af_dev->config->iir_config.coeff_set0[10], AFCOEF0010);
+
+	/*Set IIR Filter1 Coefficients */
+
+	base_coef_set1 = AFCOEF110;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set1[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set1[index + 1]) << AF_COEF_SHIFT;
+		regw(coef, base_coef_set1);
+		dev_dbg(afdev, "\n COEF1 %x", regr(base_coef_set1));
+		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
+	}
+	/* Set AFCOEF0110 */
+	regw(af_dev->config->iir_config.coeff_set1[10], AFCOEF1010);
+
+	/* Set AFBUFST to Current buffer Physical Address */
+	regw((unsigned int)(virt_to_phys(af_dev->buff_curr)), AFBUFST);
+
+	AF_SETGAMMAWD;
+	dev_dbg(afdev, "\n PCR %x", pcr);
+	dev_dbg(afdev, "\n AFPAX1 %x", regr(AFPAX1));
+	dev_dbg(afdev, "\n PAXSTART %x", paxstart);
+	dev_dbg(afdev, "\n PAX2 %x", regr(AFPAX2));
+	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF0010));
+	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF1010));
+	dev_dbg(afdev, "\n AFBUFST %x", regr(AFBUFST));
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return 0;
+
+}
+
+/* Function to Enable/Disable AF Engine */
+inline void af_engine_setup(int enable)
+{
+	unsigned int pcr;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	pcr = regr(AFPCR);
+	dev_dbg(afdev, "\nEngine Setup value before PCR : %x", pcr);
+
+	/* Set AF_EN bit in PCR Register */
+	if (enable)
+		pcr |= AF_EN;
+	else
+		pcr &= ~AF_EN;
+
+	regw(pcr, AFPCR);
+
+	dev_dbg(afdev, "\n Engine Setup value after PCR : %x", pcr);
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+}
+
+/* Function to set address */
+inline void af_set_address(unsigned long address)
+{
+	regw(address, AFBUFST);
+}
Index: linux-2.6.10/drivers/media/video/davinci/dm355_ipipe.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_ipipe.c
@@ -0,0 +1,1571 @@
+/*
+ * 
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_ipipe.c file */
+
+/* include Linux files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/cdev.h>		/* Used for struct cdev */
+#include <linux/dma-mapping.h>	/* For class_simple_create */
+#include <linux/interrupt.h>	/* For IRQ_HANDLED and irqreturn_t */
+#include <asm/uaccess.h>	/* for VERIFY_READ/VERIFY_WRITE/
+				   copy_from_user */
+#include <linux/device.h>
+#include <asm/semaphore.h>
+#include <asm-arm/arch-davinci/dm355_ipipe_hw.h>
+#include <linux/major.h>
+#include <asm-arm/arch-davinci/dm355_ipipe.h>
+
+#include "ipipe_para.h"
+
+/* Keeps track of how many times the device driver has been opened */
+static atomic_t reference_count = ATOMIC_INIT(0);
+
+static struct class_simple *ipipe_class = NULL;
+struct device *ipipe_dev;
+/* ipipe_isr: It is interrupt handler for PRVINT interrupt. 
+ It will be called when ipipe completes processing of one 
+ frame and writes data to the DDR. It unblocks the IPIPE 
+ ioctl which is waiting for the processing to be completed */
+irqreturn_t ipipe_isr(int irq, void *device_id, struct pt_regs *regs)
+{
+
+	struct ipipe_device *ipipedevice = (struct ipipe_device *)device_id;
+	dev_dbg(ipipe_dev, "IPIPE isr returned.\n");
+	/* indicate the completion ofr frame processing */
+	if (ipipedevice)
+		complete(&(ipipedevice->wfc));
+
+	return IRQ_HANDLED;
+}
+
+#define DRIVERNAME  "DM355IPIPE"
+
+/* global object of ipipe_device structure */
+struct ipipe_device ipipedevice = { 0 };
+
+/* inline function to free reserver pages  */
+void inline ipipe_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long size, ad = addr;
+	size = PAGE_SIZE << (get_order(bufsize));
+	if (!addr)
+		return;
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(ad, get_order(bufsize));
+}
+
+/* This function is used to free memory allocated to buffers */
+int free_buffers(struct ipipe_device *device)
+{
+	int i;
+	unsigned long adr;
+	if (!device) {
+		dev_err(ipipe_dev, "\nfree_buffers:error in argument");
+		return -EINVAL;
+	}
+	/* free memory allocated to in buffers */
+	for (i = 0; i < device->in_numbuffers; i++) {
+		if (device->in_buff[i]) {
+			adr = device->in_buff[i]->offset;
+			if (adr)
+				ipipe_free_pages((unsigned long)
+						 phys_to_virt(adr),
+						 device->in_buff[i]->size);
+
+			kfree(device->in_buff[i]);
+
+			device->in_buff[i] = NULL;
+		}
+	}
+	device->in_numbuffers = 0;
+	/* free memory allocated to out buffers */
+	for (i = 0; i < device->out_numbuffers; i++) {
+		if (device->out_buff[i]) {
+			adr = device->out_buff[i]->offset;
+			if (adr)
+				ipipe_free_pages((unsigned long)
+						 phys_to_virt(adr),
+						 device->out_buff[i]->size);
+
+			kfree(device->out_buff[i]);
+
+			device->out_buff[i] = NULL;
+		}
+	}
+
+	device->out_numbuffers = 0;
+	return 0;
+}
+
+/* 
+ * This function will query the buffer's physical address
+ * whose index is passed in ipipe_buffer. 
+ * It will store that address in ipipe_buffer. 
+ */
+int query_buffer(struct ipipe_device *device, struct ipipe_buffer *buffer)
+{
+
+	if (!buffer || !device) {
+		dev_err(ipipe_dev, "query_buffer: error in argument\n");
+		return -EINVAL;
+	}
+
+	if (buffer->index < 0) {
+		dev_err(ipipe_dev, "query_buffer: invalid index %d\n",
+			buffer->index);
+		return -EINVAL;
+	}
+
+	if ((buffer->buf_type != IPIPE_BUF_IN)
+	    && (buffer->buf_type != IPIPE_BUF_OUT)) {
+		dev_err(ipipe_dev, "request_buffer: invalid buffer type\n");
+		return -EINVAL;
+	}
+	/* if buf_type is input buffer then get offset of input buffer */
+	if (buffer->buf_type == IPIPE_BUF_IN) {
+		/* error checking for wrong index number */
+		if (buffer->index >= device->in_numbuffers) {
+			dev_err(ipipe_dev, "query_buffer: invalid index");
+
+			return -EINVAL;
+		}
+
+		/* get the offset and size of the buffer and store
+		   it in buffer */
+		buffer->offset = device->in_buff[buffer->index]->offset;
+		buffer->size = device->in_buff[buffer->index]->size;
+	}
+	/* if buf_type is output buffer then get offset of output buffer */
+	else if (buffer->buf_type == IPIPE_BUF_OUT) {
+		/* error checking for wrong index number */
+		if (buffer->index >= device->out_numbuffers) {
+			dev_err(ipipe_dev, "query_buffer: invalid index\n");
+
+			return -EINVAL;
+		}
+		/* get the offset and size of the buffer and store
+		   it in buffer */
+		buffer->offset = device->out_buff[buffer->index]->offset;
+		buffer->size = device->out_buff[buffer->index]->size;
+	} else {
+		dev_err(ipipe_dev, "query_buffer: invalid buffer type\n");
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int request_buffer(struct ipipe_device *device, struct ipipe_reqbufs *reqbufs)
+{
+	struct ipipe_buffer *buffer = NULL;
+	int count = 0;
+	unsigned long adr;
+	u32 size;
+
+	if (!reqbufs || !device) {
+		dev_err(ipipe_dev, "request_buffer: error in argument\n");
+		return -EINVAL;
+	}
+
+	/* if number of buffers requested is more then support return error */
+	if (reqbufs->count > MAX_BUFFER) {
+		dev_err(ipipe_dev, "request_buffer: invalid buffer count\n");
+		return -EINVAL;
+	}
+
+	if ((reqbufs->buf_type != IPIPE_BUF_IN)
+	    && (reqbufs->buf_type != IPIPE_BUF_OUT)) {
+		dev_err(ipipe_dev, "request_buffer: invalid buffer type %d\n",
+			reqbufs->buf_type);
+		return -EINVAL;
+	}
+	if (reqbufs->count < 0) {
+		dev_err(ipipe_dev, "request_buffer: invalid buffer count %d\n",
+			reqbufs->count);
+		return -EINVAL;
+	}
+	/* if buf_type is input then allocate buffers for input */
+	if (reqbufs->buf_type == IPIPE_BUF_IN) {
+		/*if buffer count is zero, free all the buffers */
+		if (reqbufs->count == 0) {
+			/* free all the buffers */
+			for (count = 0; count < device->in_numbuffers; count++) {
+				/* free memory allocate for the image */
+				if (device->in_buff[count]) {
+					adr =
+					    (unsigned long)device->
+					    in_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->in_buff
+								 [count]->size);
+
+					/* free the memory allocated
+					   to ipipe_buffer */
+					kfree(device->in_buff[count]);
+
+					device->in_buff[count] = NULL;
+				}
+			}
+			device->in_numbuffers = 0;
+			return 0;
+		}
+
+		/* free the extra buffers */
+		if (device->in_numbuffers > reqbufs->count &&
+		    reqbufs->size == device->in_buff[0]->size) {
+			for (count = reqbufs->count;
+			     count < device->in_numbuffers; count++) {
+				/* free memory allocate for the image */
+				if (device->in_buff[count]) {
+					adr = device->in_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->in_buff
+								 [count]->size);
+
+					/* free the memory allocated
+					   to ipipe_buffer */
+					kfree(device->in_buff[count]);
+
+					device->in_buff[count] = NULL;
+				}
+			}
+			device->in_numbuffers = reqbufs->count;
+			return 0;
+		}
+		/* if size requested is different from already allocated,
+		   free memory of all already allocated buffers */
+		if (device->in_numbuffers) {
+			if (reqbufs->size != device->in_buff[0]->size) {
+				for (count = 0;
+				     count < device->in_numbuffers; count++) {
+					if (device->in_buff[count]) {
+						adr =
+						    device->
+						    in_buff[count]->offset;
+						if (adr)
+							ipipe_free_pages((unsigned long)
+									 phys_to_virt
+									 (adr),
+									 device->
+									 in_buff
+									 [count]->
+									 size);
+
+						kfree(device->in_buff[count]);
+
+						device->in_buff[count] = NULL;
+					}
+				}
+				device->in_numbuffers = 0;
+			}
+		}
+
+		/* allocate the buffer */
+		for (count = device->in_numbuffers; count < reqbufs->count;
+		     count++) {
+			/* Allocate memory for struct ipipe_buffer */
+			buffer =
+			    kmalloc(sizeof(struct ipipe_buffer), GFP_KERNEL);
+
+			/* if memory allocation fails then return error */
+			if (!buffer) {
+				/* free all the buffers */
+				while (--count >= device->in_numbuffers) {
+					adr = device->in_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->in_buff
+								 [count]->size);
+					kfree(device->in_buff[count]);
+					device->in_buff[count] = NULL;
+				}
+				dev_err(ipipe_dev, "1.request_buffer:not \
+					enough memory\n");
+				return -ENOMEM;
+			}
+
+			/* assign buffer's address in configuration */
+			device->in_buff[count] = buffer;
+
+			/* set buffers index and buf_type,size parameters */
+			buffer->index = count;
+			buffer->buf_type = IPIPE_BUF_IN;
+			buffer->size = reqbufs->size;
+			/* allocate memory for buffer of size passed
+			   in reqbufs */
+			buffer->offset =
+			    (unsigned long)__get_free_pages(GFP_KERNEL |
+							    GFP_DMA,
+							    get_order
+							    (reqbufs->size));
+
+			/* if memory allocation fails, return error */
+			if (!(buffer->offset)) {
+				/* free all the buffer's space */
+				kfree(buffer);
+				device->in_buff[count] = NULL;
+				while (--count >= device->in_numbuffers) {
+					adr = device->in_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->in_buff
+								 [count]->size);
+					kfree(device->in_buff[count]);
+					device->in_buff[count] = NULL;
+				}
+				dev_err(ipipe_dev, "2.request_buffer:not \
+					enough memory\n");
+
+				return -ENOMEM;
+			}
+
+			adr = (unsigned long)buffer->offset;
+			size = PAGE_SIZE << (get_order(reqbufs->size));
+			while (size > 0) {
+				/* make sure the frame buffers
+				   are never swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			/* convert vertual address to physical */
+			buffer->offset = (unsigned long)
+			    virt_to_phys((void *)(buffer->offset));
+		}
+		device->in_numbuffers = reqbufs->count;
+	}
+	/* if buf_type is output then allocate buffers for output */
+	else if (reqbufs->buf_type == IPIPE_BUF_OUT) {
+		if (reqbufs->count == 0) {
+			/* free all the buffers */
+			for (count = 0; count < device->out_numbuffers; count++) {
+				/* free memory allocate for the image */
+				if (device->out_buff[count]) {
+					adr = device->out_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->
+								 out_buff
+								 [count]->size);
+
+					/* free the memory allocated to
+					   ipipe_buffer */
+					kfree(device->out_buff[count]);
+
+					device->out_buff[count] = NULL;
+				}
+			}
+			device->out_numbuffers = 0;
+
+			return 0;
+		}
+		/* free the buffers */
+		if (device->out_numbuffers > reqbufs->count &&
+		    reqbufs->size == device->out_buff[0]->size) {
+			for (count = reqbufs->count;
+			     count < device->out_numbuffers; count++) {
+				/* free memory allocate for the image */
+				if (device->out_buff[count]) {
+					adr = device->out_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->
+								 out_buff
+								 [count]->size);
+
+					/* free the memory allocated to
+					   ipipe_buffer */
+					kfree(device->out_buff[count]);
+
+					device->out_buff[count] = NULL;
+				}
+			}
+			device->out_numbuffers = reqbufs->count;
+
+			return 0;
+		}
+		/* if size requested is different from already allocated,
+		   free memory of all already allocated buffers */
+		if (device->out_numbuffers) {
+			if (reqbufs->size != device->out_buff[0]->size) {
+				for (count = 0;
+				     count < device->out_numbuffers; count++) {
+					if (device->out_buff[count]) {
+						adr =
+						    device->
+						    out_buff[count]->offset;
+
+						if (adr)
+							ipipe_free_pages((unsigned long)
+									 phys_to_virt
+									 (adr),
+									 device->
+									 out_buff
+									 [count]->
+									 size);
+
+						kfree(device->out_buff[count]);
+
+						device->out_buff[count] = NULL;
+					}
+				}
+				device->out_numbuffers = 0;
+			}
+		}
+
+		/* allocate the buffer */
+		for (count = device->out_numbuffers;
+		     count < reqbufs->count; count++) {
+			/* Allocate memory for struct ipipe_buffer */
+			buffer =
+			    kmalloc(sizeof(struct ipipe_buffer), GFP_KERNEL);
+
+			/* if memory allocation fails then return error */
+			if (!buffer) {
+				/* free all the buffers */
+				while (--count >= device->out_numbuffers) {
+					adr = device->out_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->
+								 out_buff
+								 [count]->size);
+					kfree(device->out_buff[count]);
+					device->out_buff[count] = NULL;
+				}
+
+				dev_err(ipipe_dev,
+					"3.request_buffer:not enough \
+					memory\n");
+
+				return -ENOMEM;
+			}
+
+			/* assign buffer's address out configuration */
+			device->out_buff[count] = buffer;
+
+			/* set buffers outdex and buf_type,size parameters */
+			buffer->index = count;
+			buffer->buf_type = IPIPE_BUF_OUT;
+			buffer->size = reqbufs->size;
+			/* allocate memory for buffer of size passed
+			   in reqbufs */
+			buffer->offset =
+			    (unsigned long)__get_free_pages(GFP_KERNEL |
+							    GFP_DMA,
+							    get_order
+							    (reqbufs->size));
+
+			/* if memory allocation fails, return error */
+			if (!(buffer->offset)) {
+				/* free all the buffer's space */
+				kfree(buffer);
+				device->out_buff[count] = NULL;
+				while (--count >= device->out_numbuffers) {
+					adr = device->out_buff[count]->offset;
+					if (adr)
+						ipipe_free_pages((unsigned long)
+								 phys_to_virt
+								 (adr),
+								 device->
+								 out_buff
+								 [count]->size);
+					kfree(device->out_buff[count]);
+					device->out_buff[count] = NULL;
+				}
+				dev_err(ipipe_dev, "4.request_buffer:not \
+					enough memory\n");
+
+				return -ENOMEM;
+			}
+
+			adr = (unsigned long)buffer->offset;
+			size = PAGE_SIZE << (get_order(reqbufs->size));
+			while (size > 0) {
+				/* make sure the frame buffers
+				   are never swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			/* convert vertual address to physical */
+			buffer->offset = (unsigned long)
+			    virt_to_phys((void *)(buffer->offset));
+		}
+		device->out_numbuffers = reqbufs->count;
+	} else {
+		dev_err(ipipe_dev, "request_buffer: invalid buffer type\n");
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Functions */
+int ipipe_open(struct inode *inode, struct file *filp)
+{
+	struct ipipe_params *config = NULL;
+
+	if (atomic_inc_return(&reference_count) != 1) {
+		dev_err(ipipe_dev, "ipipe_open: device is already openend\n");
+		return -EBUSY;
+	}
+
+	/* allocate memory for a new configuration */
+	if ((config = kmalloc(sizeof(struct ipipe_params), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	/* store the pointer of ipipe_params in private_data member of file
+	   and params member of ipipe_device */
+	filp->private_data = config;
+
+	/* initialize mutex to 0 */
+	ipipedevice.params = config;
+	ipipedevice.opened = 1;
+	ipipedevice.in_numbuffers = 0;
+	ipipedevice.out_numbuffers = 0;
+	init_completion(&(ipipedevice.wfc));
+	ipipedevice.wfc.done = 0;
+	init_MUTEX(&(ipipedevice.sem));
+
+	return 0;
+}
+int write_out_addr(int resize_no, unsigned int address)
+{
+	unsigned int utemp;
+	unsigned int rsz_start_add;
+	if ((resize_no == 0) || (resize_no == 1)) {
+		if (resize_no)
+			rsz_start_add = RSZ_EN_1;
+		else
+			rsz_start_add = RSZ_EN_0;
+	} else
+		return -EINVAL;
+
+	utemp = address & SET_LOW_ADD;
+	regw_ip(utemp, rsz_start_add + RSZ_SDR_BAD_L);
+	regw_ip(utemp, rsz_start_add + RSZ_SDR_SAD_L);
+
+	utemp = (address & SET_HIGH_ADD) >> 16;
+	regw_ip(utemp, rsz_start_add + RSZ_SDR_BAD_H);
+	regw_ip(utemp, rsz_start_add + RSZ_SDR_SAD_H);
+	return 0;
+}
+int validate_params(struct ipipe_params *params)
+{
+
+	u32 data_format;
+
+	if ((params->ipipeif_param.source == SDRAM_RAW) &&
+	    (params->ipipe_dpaths_fmt == YUV2YUV)) {
+
+		dev_err(ipipe_dev,
+			"validate:input source and data format does not match\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.source == SDRAM_YUV) &&
+	    (params->ipipe_dpaths_fmt == RAW2YUV)) {
+
+		dev_err(ipipe_dev,
+			"validate:input source and data format does not match\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.source < CCDC) ||
+	    (params->ipipeif_param.source > SDRAM_YUV)) {
+
+		dev_err(ipipe_dev,
+			"validate:invalidate input source of ipipeif\n");
+		return -EINVAL;
+	}
+
+	if (params->ipipeif_param.source == CCDC_DARKFM) {
+		if (!(params->ipipeif_param.glob_ver_size)) {
+
+			dev_err(ipipe_dev, "validate:glob_ver_size is 0\n");
+			return -EINVAL;
+		}
+		/*Data should be read from SDRAM with CFG.ALAW set to .0 and
+		   CFG.PACK8IN set to 1 */
+		if ((params->ipipeif_param.ialaw)
+		    || (!(params->ipipeif_param.pack_mode))) {
+
+			dev_err(ipipe_dev,
+				"validate: error in either ialaw or ipipeif pack mode\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((params->ipipeif_param.source == CCDC_DARKFM)
+	    || (params->ipipeif_param.source == CCDC)) {
+		if (params->ipipeif_param.clock_select) {
+			dev_err(ipipe_dev, "validate:error in clock select\n");
+			return -EINVAL;
+		}
+	}
+
+	if (params->ipipeif_param.decimation) {
+		if ((params->ipipeif_param.rsz < ONE) ||
+		    (params->ipipeif_param.rsz > ONE_SEVENTH)) {
+			dev_err(ipipe_dev,
+				"validate:error in resize factor for decimation \n");
+			return -EINVAL;
+		}
+	}
+
+	if (params->ipipeif_param.clock_select) {
+		if ((params->ipipeif_param.clk_div < DIVIDE_HALF) ||
+		    (params->ipipeif_param.clk_div > DIVIDE_THIRTY)) {
+			dev_err(ipipe_dev,
+				"validate:error in clock divisor factor value\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((params->ipipeif_param.data_shift < BITS15_2)
+	    || (params->ipipeif_param.data_shift > BITS9_0)) {
+
+		dev_err(ipipe_dev, "validate:error in data shift value\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.clock_select != SDRAM_CLK)
+	    && (params->ipipeif_param.clock_select != PIXCEL_CLK)) {
+
+		dev_err(ipipe_dev, "validate:error in clock select value\n");
+		return -EINVAL;
+	}
+	if ((params->ipipeif_param.ialaw != ALAW_OFF)
+	    && (params->ipipeif_param.ialaw != ALAW_ON)) {
+
+		dev_err(ipipe_dev, "validate:error in ialaw value\n");
+		return -EINVAL;
+	}
+	if ((params->ipipeif_param.pack_mode != SIXTEEN_BIT)
+	    && (params->ipipeif_param.pack_mode != EIGHT_BIT)) {
+
+		dev_err(ipipe_dev, "validate:error in pack mode value\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.avg_filter != AVG_OFF)
+	    && (params->ipipeif_param.avg_filter != AVG_ON)) {
+
+		dev_err(ipipe_dev, "validate:error in average filter value\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.decimation != DECIMATION_OFF)
+	    && (params->ipipeif_param.decimation != DECIMATION_ON)) {
+
+		dev_err(ipipe_dev, "validate:error in decimation value\n");
+		return -EINVAL;
+	}
+
+	if ((params->ipipeif_param.mode != CONTINUOUS)
+	    && (params->ipipeif_param.mode != ONE_SHOT)) {
+
+		dev_err(ipipe_dev, "validate:error in ipipeif mode value\n");
+		return -EINVAL;
+	}
+
+	data_format =
+	    (params->ipipe_dpaths_fmt | (params->ipipe_dpaths_bypass) << 2);
+	/*in raw pass through mode   data can be < 4096 */
+	if (data_format == RAW2RAW_BYPASS) {
+		if (params->ipipe_hsz > MAX_SIZE_RAW_BY_PASS) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid ipipe horizontal size\n");
+			return -EINVAL;
+		}
+	}
+	if (data_format != RAW2RAW_BYPASS) {
+		if (params->ipipe_hsz > MAX_SIZE) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid ipipe horizontal size\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((params->ipipe_mode != 0) && (params->ipipe_mode != 1)) {
+
+		dev_err(ipipe_dev, "validate:invalid ipipe mode\n");
+		return -EINVAL;
+	}
+	if ((params->ipipe_dpaths_bypass != RAW_MODE_OFF) &&
+	    (params->ipipe_dpaths_bypass != RAW_MODE_ON)) {
+
+		dev_err(ipipe_dev, "validate:invalid ipipe datapath\n");
+		return -EINVAL;
+
+	}
+	if ((params->ipipe_colpat_elep < RED)
+	    || (params->ipipe_colpat_elep > BLUE)) {
+
+		dev_err(ipipe_dev, "validate:invalid elep value\n");
+		return -EINVAL;
+	}
+	if ((params->ipipe_colpat_elop < RED)
+	    || (params->ipipe_colpat_elop > BLUE)) {
+
+		dev_err(ipipe_dev, "validate:invalid elop value\n");
+		return -EINVAL;
+	}
+	if ((params->ipipe_colpat_olep < RED)
+	    || (params->ipipe_colpat_olep > BLUE)) {
+
+		dev_err(ipipe_dev, "validate:invalid olep value\n");
+		return -EINVAL;
+	}
+	if ((params->ipipe_colpat_olop < RED)
+	    || (params->ipipe_colpat_olop > BLUE)) {
+
+		dev_err(ipipe_dev, "validate:invalid olop value\n");
+		return -EINVAL;
+	}
+
+	if (params->def_cor.dfc_en) {
+		if ((params->def_cor.dfc_sel != FROMTOP)
+		    && (params->def_cor.dfc_sel != FROMBOTTON)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid copy method in defect correction\n");
+			return -EINVAL;
+		}
+		if (params->def_cor.dfc_siz > 1024) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid defect correction table size\n");
+			return -EINVAL;
+		}
+	}
+
+	if (params->prog_nf.noise_fil_en) {
+		if ((params->prog_nf.type != BOX)
+		    && (params->prog_nf.type != DIAMOND)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid noise filter type\n");
+			return -EINVAL;
+		}
+
+	}
+	if (params->prefilter.pre_en) {
+
+		if ((params->prefilter.sel_0 != AVG2MEDPIX)
+		    && (params->prefilter.sel_0 != AVG4PIX)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid averaging method(sel0) in prefilter\n");
+			return -EINVAL;
+		}
+
+		if ((params->prefilter.sel_1 != AVG2MEDPIX)
+		    && (params->prefilter.sel_1 != AVG4PIX)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid averaging method(sel1) in prefilter\n");
+			return -EINVAL;
+		}
+
+		if ((params->prefilter.typ_adaptive != DISABLE) &&
+		    (params->prefilter.typ_adaptive != ENABLE)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid adaptive filter value(en0) in pre filter\n");
+			return -EINVAL;
+		}
+		if ((params->prefilter.typ_adaptive_dotred != DISABLE) &&
+		    (params->prefilter.typ_adaptive_dotred != ENABLE)) {
+
+			dev_err(ipipe_dev,
+				"validate:invalid adaptive dot reduction value(en1) in pre filter\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((params->rgb2rgb.gmm_cfg_bypr != GC_ENABLE) &&
+	    (params->rgb2rgb.gmm_cfg_bypr != GC_BYPASS)) {
+
+		dev_err(ipipe_dev,
+			"validate:invalid gamma correction enable/bypass value\n");
+		return -EINVAL;
+	}
+	if ((params->rgb2rgb.gmm_cfg_bypr == GC_ENABLE)
+	    && params->rgb2rgb.gmm_cfg_tbl == IPIPE_RAM
+	    && (params->rgb2rgb.gmm_tbl_r == NULL)) {
+		dev_err(ipipe_dev,
+			"validate:gamma red enabled but table field is NULL\n");
+		return -EINVAL;
+	}
+
+	if ((params->rgb2rgb.gmm_cfg_bypg != GC_ENABLE)
+	    && params->rgb2rgb.gmm_cfg_tbl == IPIPE_RAM
+	    && (params->rgb2rgb.gmm_cfg_bypg != GC_BYPASS)) {
+
+		dev_err(ipipe_dev,
+			"validate:invalid gamma green correction enable/bypass value\n");
+		return -EINVAL;
+	}
+
+	if ((params->rgb2rgb.gmm_cfg_bypg == GC_ENABLE)
+	    && params->rgb2rgb.gmm_cfg_tbl == IPIPE_RAM
+	    && (params->rgb2rgb.gmm_tbl_g == NULL)) {
+		dev_err(ipipe_dev,
+			"validate:gamma green enabled but table field is NULL\n");
+		return -EINVAL;
+	}
+
+	if ((params->rgb2rgb.gmm_cfg_bypb != GC_ENABLE)
+	    && (params->rgb2rgb.gmm_cfg_bypb != GC_BYPASS)) {
+
+		dev_err(ipipe_dev,
+			"validate:invalid gamma blue correction enable/bypass value\n");
+		return -EINVAL;
+	}
+	if ((params->rgb2rgb.gmm_cfg_bypb == GC_ENABLE)
+	    && params->rgb2rgb.gmm_cfg_tbl == IPIPE_RAM
+	    && (params->rgb2rgb.gmm_tbl_b == NULL)) {
+		dev_err(ipipe_dev,
+			"validate:gamma blue enabled but table field is NULL\n");
+		return -EINVAL;
+	}
+	if ((params->rgb2rgb.gmm_cfg_tbl != IPIPE_RAM)
+	    && (params->rgb2rgb.gmm_cfg_tbl != IPIPE_ROM)) {
+
+		dev_err(ipipe_dev, "invlid gamma table source\n");
+		return -EINVAL;
+	}
+
+	if ((params->rgb2rgb.gmm_cfg_siz < IPIPE_128)
+	    || (params->rgb2rgb.gmm_cfg_siz > IPIPE_512)) {
+
+		dev_err(ipipe_dev, "invalid gamma table size\n");
+		return -EINVAL;
+	}
+
+	if ((params->rgb2yuv.yuv_phs_position != COSITING)
+	    && (params->rgb2yuv.yuv_phs_position != CENTERING)) {
+
+		dev_err(ipipe_dev, "invalid phase position\n");
+		return -EINVAL;
+	}
+	if ((params->rgb2yuv.yuv_phs_lpf != ENABLE)
+	    && (params->rgb2yuv.yuv_phs_lpf != DISABLE)) {
+
+		dev_err(ipipe_dev, "invalid phase position\n");
+		return -EINVAL;
+	}
+
+	if ((params->edge_enhancer.yee_en != ENABLE)
+	    && (params->edge_enhancer.yee_en != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value in edge enhancement enable field\n");
+		return -EINVAL;
+	}
+
+	if ((params->edge_enhancer.yee_emf != ENABLE)
+	    && (params->edge_enhancer.yee_emf != DISABLE)) {
+
+		dev_err(ipipe_dev, "invalid value in median NR enable field\n");
+		return -EINVAL;
+	}
+
+	if (params->false_color_suppresion.fcs_en) {
+		if ((params->false_color_suppresion.fcs_typ_typ < Y) ||
+		    (params->false_color_suppresion.fcs_typ_typ > HPF_2D_YEE)) {
+
+			dev_err(ipipe_dev,
+				"invalid value in color suppresion enable field\n");
+			return -EINVAL;
+		}
+	}
+
+	if ((params->rsz_seq_seq != ENABLE) && (params->rsz_seq_seq != DISABLE)) {
+
+		dev_err(ipipe_dev, "invalid value of operation mode field\n");
+		return -EINVAL;
+	}
+
+	if ((params->rsz_seq_tmm != ENABLE) && (params->rsz_seq_tmm != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value of terminal condition enable field\n");
+		return -EINVAL;
+	}
+
+	if ((params->rsz_seq_hrv != ENABLE) && (params->rsz_seq_hrv != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value of horizontal reversal field\n");
+		return -EINVAL;
+	}
+
+	if ((params->rsz_seq_vrv != ENABLE) && (params->rsz_seq_vrv != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value of vertical reversal field\n");
+		return -EINVAL;
+	}
+
+	if ((params->rsz_seq_crv != ENABLE) && (params->rsz_seq_crv != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value of chroma sampling point field\n");
+		return -EINVAL;
+	}
+
+	if ((params->rsz_aal != ENABLE) && (params->rsz_aal != DISABLE)) {
+
+		dev_err(ipipe_dev,
+			"invalid value of anti aliasing filter field\n");
+		return -EINVAL;
+	}
+
+	if (params->rsz_en[0]) {
+		if ((params->rsz_rsc_param[0].rsz_h_typ != CUBIC)
+		    && (params->rsz_rsc_param[0].rsz_h_typ != LINEAR)) {
+
+			dev_err(ipipe_dev,
+				"invalid low pass filter type in RZA\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz_rsc_param[0].rsz_h_lse_sel != INTERNAL_VALUE)
+		    && (params->rsz_rsc_param[0].rsz_h_lse_sel !=
+			PROGRAMMED_VALUE)) {
+
+			dev_err(ipipe_dev,
+				"invalid intensity value of LPF in RZA\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[0].rsz_rgb_typ != OUTPUT_16BIT) &&
+		    (params->rsz2rgb[0].rsz_rgb_typ != OUTPUT_32BIT)) {
+
+			dev_err(ipipe_dev, "invalid RGB output type in RZA\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[0].rsz_rgb_msk0 != MASKLAST2)
+		    && (params->rsz2rgb[0].rsz_rgb_msk0 != NOMASK)) {
+
+			dev_err(ipipe_dev,
+				"invalid value of mask0 field in RZA\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[0].rsz_rgb_msk1 != MASKLAST2)
+		    && (params->rsz2rgb[0].rsz_rgb_msk1 != NOMASK)) {
+
+			dev_err(ipipe_dev,
+				"invalid value of mask1 field in RZA\n");
+			return -EINVAL;
+		}
+		/*Check that mode selected by user in all modules should be same */
+		if (!(params->ipipeif_param.mode == params->ipipe_mode) &&
+		    (params->ipipeif_param.mode ==
+		     params->rsz_rsc_param[0].rsz_mode)
+		    && (params->ipipe_mode ==
+			params->rsz_rsc_param[0].rsz_mode)) {
+
+			dev_err(ipipe_dev, "mode does not match in RZA\n");
+			return -EINVAL;
+		}
+
+		if (params->rsz_rsc_param[0].rsz_o_hsz > MAX_SIZE_RSZ0) {
+
+			dev_err(ipipe_dev,
+				"invalid output horizontal size in RZA\n");
+			return -EINVAL;
+		}
+
+	}
+
+	if (params->rsz_en[1]) {
+		if ((params->rsz_rsc_param[1].rsz_h_typ != CUBIC)
+		    && (params->rsz_rsc_param[1].rsz_h_typ != LINEAR)) {
+
+			dev_err(ipipe_dev,
+				"invalid low pass filter type in RZB\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz_rsc_param[1].rsz_h_lse_sel != INTERNAL_VALUE)
+		    && (params->rsz_rsc_param[1].rsz_h_lse_sel !=
+			PROGRAMMED_VALUE)) {
+
+			dev_err(ipipe_dev,
+				"invalid intensity value of LPF in RZB\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[1].rsz_rgb_typ != OUTPUT_16BIT) &&
+		    (params->rsz2rgb[1].rsz_rgb_typ != OUTPUT_32BIT)) {
+
+			dev_err(ipipe_dev, "invalid RGB output type in RZB\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[1].rsz_rgb_msk0 != MASKLAST2)
+		    && (params->rsz2rgb[1].rsz_rgb_msk0 != NOMASK)) {
+
+			dev_err(ipipe_dev,
+				"invalid value of mask0 field in RZB\n");
+			return -EINVAL;
+		}
+
+		if ((params->rsz2rgb[1].rsz_rgb_msk1 != MASKLAST2)
+		    && (params->rsz2rgb[1].rsz_rgb_msk1 != NOMASK)) {
+
+			dev_err(ipipe_dev,
+				"invalid value of mask1 field in RZB\n");
+			return -EINVAL;
+		}
+		/*Check that mode selected by user in all modules should be same */
+		if (!(params->ipipeif_param.mode == params->ipipe_mode) &&
+		    (params->ipipeif_param.mode ==
+		     params->rsz_rsc_param[1].rsz_mode)
+		    && (params->ipipe_mode ==
+			params->rsz_rsc_param[1].rsz_mode)) {
+
+			dev_err(ipipe_dev, "mode does not match in RZB\n");
+			return -EINVAL;
+		}
+
+		if (params->rsz_rsc_param[1].rsz_o_hsz > MAX_SIZE_RSZ1) {
+
+			dev_err(ipipe_dev,
+				"invalid output horizontal size in RZB\n");
+			return -EINVAL;
+		}
+	}
+	/*both resizers can not be enabled simultaniously in one shot mode */
+
+	if ((params->ipipe_dpaths_fmt > YUV2YUV)
+	    || (params->ipipe_dpaths_fmt < RAW2YUV)) {
+
+		dev_err(ipipe_dev, "invalid data format\n");
+		return -EINVAL;
+	}
+
+	if (params->def_cor.dfc_en)
+		if (params->def_cor.dfc_siz > MAX_SIZE_DFC) {
+
+			dev_err(ipipe_dev, "DFC table size exceeds limit\n");
+			return -EINVAL;
+		}
+	return 0;
+}
+
+int ipipe(struct ipipe_device *device, struct ipipe_convert *arg)
+{
+	unsigned int utemp, utemp_h, utemp_l;
+	int resizer_no_0, resizer_no_1;
+
+	resizer_no_0 = device->params->rsz_en[0];
+	resizer_no_1 = device->params->rsz_en[1];
+
+	/*set ipipe clock */
+	regw_vpss(0x79, VPSS_CLK);	/*!FIXME */
+	if (device->params->ipipeif_param.source != 0) {
+		regw_if(((device->params->ipipeif_param.adofs) >> 5),
+			IPIPEIF_ADOFS);
+
+		if (arg->in_buff.index < 0) {
+			/*check if adress is 32 bit alligned */
+			if (arg->in_buff.offset % 32) {
+				dev_dbg(ipipe_dev,
+					"address offset not alligned\n");
+				return -EINVAL;
+			}
+			/*lower sixteen bit */
+			utemp = arg->in_buff.offset;
+			utemp_l = utemp >> 5;
+			regw_if(utemp_l, IPIPEIF_ADDRL);
+			/*upper next seven bit */
+			utemp_h = utemp >> 21;
+			regw_if(utemp_h, IPIPEIF_ADDRU);
+		} else if (arg->in_buff.index > 7) {
+			dev_dbg(ipipe_dev, "Invalid buffer index\n");
+			return -EINVAL;
+		} else {
+			/*lower sixteen bit */
+			utemp = device->in_buff[arg->in_buff.index]->offset;
+			utemp_l = utemp >> 5;
+			regw_if(utemp_l, IPIPEIF_ADDRL);
+			utemp_h = utemp >> 21;
+
+			regw_if(utemp_h, IPIPEIF_ADDRU);
+		}
+	}
+	if (resizer_no_0)
+		regw_ip(device->params->ext_mem_param[0].rsz_sdr_oft,
+			RSZ_EN_0 + RSZ_SDR_OFT);
+	regw_ip(device->params->rsz_en[0], RSZ_EN_0);
+	if (resizer_no_1)
+		regw_ip(device->params->ext_mem_param[1].rsz_sdr_oft,
+			RSZ_EN_1 + RSZ_SDR_OFT);
+	regw_ip(device->params->rsz_en[1], RSZ_EN_1);
+
+	if (arg->out_buff.index < 0) {
+		if (arg->out_buff.offset % 32)
+			return -EINVAL;
+		else {
+			/* CHECK this statems */
+			if (resizer_no_0 == 1 && resizer_no_1 == 1) {
+				printk
+				    ("If both the resizer enable then user can \
+					 not provide output address\n");
+				return -EINVAL;
+			}
+			if (resizer_no_0)
+				write_out_addr(0, arg->out_buff.offset);
+			if (resizer_no_1)
+				write_out_addr(1, arg->out_buff.offset);
+		}
+	} else if (arg->in_buff.index > 7) {
+		return -EINVAL;
+	} else {
+		if (resizer_no_0)
+			write_out_addr(0,
+				       device->out_buff[arg->out_buff.index]->
+				       offset);
+		if (resizer_no_1 && resizer_no_0)
+			write_out_addr(1,
+				       device->out_buff[arg->out_buff.index +
+							1]->offset);
+		if (resizer_no_1 && !resizer_no_0)
+			write_out_addr(1,
+				       device->out_buff[arg->out_buff.index]->
+				       offset);
+
+	}
+
+	regw_ip(0xff, IRQ_EN);
+	while (1) {
+		utemp = regr_ip(IPIPE_EN);
+		if (utemp == 0)
+			break;
+	}
+	regw_ip(1, IPIPE_EN);
+	while (1) {
+		utemp = regr_if(IPIPEIF_ENABLE);
+		if (utemp == 0)
+			break;
+	};
+
+	regw_if(1, IPIPEIF_ENABLE);
+	dev_dbg(ipipe_dev, "ipipe started\n");
+	wait_for_completion_interruptible(&device->wfc);
+	return 0;
+
+}
+int ipipe_release(struct inode *inode, struct file *filp)
+{
+	/* get the configuratin from private_date member of file */
+	struct ipipe_params *config = filp->private_data;
+	struct ipipe_device *device = &ipipedevice;
+	/* call free_buffers to free memory allocated to buffers */
+	if (atomic_dec_and_test(&reference_count)) {
+		free_buffers(device);
+		/* change the device status to available */
+		device->opened = 0;
+	}
+
+	/* free the memory allocated to configuration */
+	if (config)
+		kfree(config);
+
+	/* Assign null to private_data member of file and params
+	   member of device */
+	filp->private_data = device->params = NULL;
+
+	return 0;
+}
+
+int ipipe_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	/* get the address of global object of ipipe_device structure */
+	struct ipipe_device *device = &ipipedevice;
+	int i, flag = 0, shift;
+	/* get the page offset */
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	shift = PAGE_SHIFT;
+	for (i = 0; i < device->in_numbuffers; i++) {
+		if (device->in_buff[i]->offset == offset) {
+			flag = 1;
+			break;
+		}
+	}
+
+	/* page offset passed in mmap should one from output buffers */
+	if (flag == 0) {
+		for (i = 0; i < device->out_numbuffers; i++) {
+			if (device->out_buff[i]->offset == offset) {
+				flag = 1;
+				break;
+			}
+		}
+	}
+	/* map buffers address space from kernel space to user space */
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+int ipipe_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	unsigned int dpath_reg;
+	struct ipipe_params params_t;
+	/* struct ipipe_reg_dump reg_addr; */
+	int ret = 0;
+	/* get the address of global object of ipipe_device structure */
+	struct ipipe_device *device = &ipipedevice;
+	struct ipipe_params *params = &params_t;
+	struct ipipe_convert addr_struct;
+	/* struct ipipe_cropsize *crop_struct = NULL; */
+	/* Before decoding check for correctness of cmd */
+	dev_dbg(ipipe_dev, "ipipe ioctl\n");
+	if (_IOC_TYPE(cmd) != IPIPE_IOC_BASE) {
+		dev_dbg(ipipe_dev, "Bad command Value \n");
+		return -1;
+	}
+	if (_IOC_NR(cmd) > IPIPE_IOC_MAXNR) {
+		dev_dbg(ipipe_dev, "Bad command Value\n");
+		return -1;
+	}
+
+	/* Verify accesses       */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (ret) {
+		dev_err(ipipe_dev, "access denied\n");
+		return -1;	/*error in access */
+	}
+	/* switch according value of cmd */
+	switch (cmd) {
+
+	case IPIPE_QUERYBUF:
+		/* call query buffer which will return buffer address */
+		down_interruptible(&(device->sem));
+		if ((ret =
+		     query_buffer(device, (struct ipipe_buffer *)arg)) != 0) {
+			up(&(device->sem));
+			return ret;
+		}
+		up(&(device->sem));
+		break;
+	case IPIPE_REQBUF:
+		/* call request buffer to allocate buffers */
+		down_interruptible(&(device->sem));
+		if ((ret =
+		     request_buffer(device,
+				    (struct ipipe_reqbufs *)arg)) != 0) {
+			up(&(device->sem));
+			return ret;
+		}
+
+		up(&(device->sem));
+		break;
+	case IPIPE_SET_PARAM:
+		/*set the parametres */
+
+		down_interruptible(&(device->sem));
+		/*default parameters */
+		if ((void *)arg == NULL) {
+			params = &param_def;
+			dev_dbg(ipipe_dev, "NULL parameters.\n");
+		} else {
+			/* copy the parameters to the configuration */
+			if (copy_from_user
+			    (params, (struct ipipe_params *)arg,
+			     sizeof(struct ipipe_params))) {
+				/* if it fails return error */
+				up(&(device->sem));
+				return -EFAULT;
+			}
+		}
+
+		/* test for register write OK */
+		if ((ret = validate_params(params)) != 0) {
+			dev_dbg(ipipe_dev, "Error in validate \n");
+			up(&(device->sem));
+			return ret;
+		}
+		dev_dbg(ipipe_dev, "Pass validation.\n");
+
+		/* copy the values to device params */
+		if (device->params)
+			memcpy(device->params, params,
+			       sizeof(struct ipipe_params));
+		else {
+			up(&(device->sem));
+			dev_dbg(ipipe_dev,
+				"invalid device parameter buffer.\n");
+			return -EINVAL;
+		}
+		if ((ret = ipipe_hw_setup(device->params)) != 0) {
+			dev_dbg(ipipe_dev, "Error in hardware set up\n");
+			up(&(device->sem));
+			return ret;
+		}
+		/* test for register write OK */
+		/*dpath_reg = regr_ip(IPIPE_DPATHS);*/
+		up(&(device->sem));
+		break;
+
+	case IPIPE_GET_PARAM:
+
+		down_interruptible(&(device->sem));
+		/* copy the parameters from the configuration */
+		if (copy_to_user((struct ipipe_params *)arg, (device->params),
+				 sizeof(struct ipipe_params))) {
+			/* if copying fails return error */
+
+			ret = -EFAULT;
+		}
+		up(&(device->sem));
+		break;
+
+	case IPIPE_START:
+
+		down_interruptible(&(device->sem));
+		dev_dbg(ipipe_dev, "ipipe startioctl\n");
+		/* copy the parameters to the configuration */
+		if (copy_from_user
+		    (&addr_struct, (struct ipipe_convert *)arg,
+		     sizeof(struct ipipe_convert)))
+			/* if it fails return error */
+		{
+			up(&(device->sem));
+			return -EFAULT;
+		}
+		/*ret = ipipe_hw_setup(device->params);*/
+		if ((ret = ipipe(device, &addr_struct)) != 0) {
+			up(&(device->sem));
+			return ret;
+		}
+		up(&(device->sem));
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+
+}
+static void ipipe_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static int ipipe_probe(struct device *device)
+{
+	ipipe_dev = device;
+	return 0;
+}
+
+static int ipipe_remove(struct device *device)
+{
+	return 0;
+}
+
+/* global variable of type file_operations containing function 
+pointers of file operations */
+static struct file_operations ipipe_fops = {
+	.owner = THIS_MODULE,
+	.open = ipipe_open,
+	.release = ipipe_release,
+	.mmap = ipipe_mmap,
+	.ioctl = ipipe_ioctl,
+};
+
+/* global variable of type cdev to register driver to the kernel */
+static struct cdev cdev;
+
+/* global variable which keeps major and minor number of the driver in it */
+static dev_t dev;
+
+static struct device_driver ipipe_driver = {
+	.name = "dm355_ipipe",
+	.bus = &platform_bus_type,
+	.probe = ipipe_probe,
+	.remove = ipipe_remove,
+};
+static struct platform_device ipipe_pt_device = {
+	.name = "dm355_ipipe",
+	.id = 2,
+	.dev = {
+		.release = ipipe_platform_release,
+		}
+};
+int __init ipipe_init(void)
+{
+	u32 utemp;
+	int result;
+
+	/* Register the driver in the kernel */
+	/* dynmically get the major number for the driver using
+	   alloc_chrdev_region function */
+	result = alloc_chrdev_region(&dev, 0, 1, DRIVERNAME);
+
+	/* if it fails return error */
+	if (result < 0) {
+		dev_dbg(ipipe_dev, "DM355IPIPE: Module intialization \
+                failed. could not register character device\n");
+		return -ENODEV;
+	}
+	printk(KERN_INFO "ipipe major#: %d, minor# %d\n", MAJOR(dev),
+	       MINOR(dev));
+
+	/* initialize cdev with file operations */
+	cdev_init(&cdev, &ipipe_fops);
+
+	cdev.owner = THIS_MODULE;
+	cdev.ops = &ipipe_fops;
+
+	/* add cdev to the kernel */
+	result = cdev_add(&cdev, dev, 1);
+
+	if (result) {
+		unregister_chrdev_region(dev, 1);
+		dev_dbg(ipipe_dev, "DM355 IPIPE: Error adding \
+		DM355 IPIPE .. error no:%d\n", result);
+		return -EINVAL;
+	}
+
+	/* register driver as a platform driver */
+	if (driver_register(&ipipe_driver) != 0) {
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&cdev);
+		return -EINVAL;
+	}
+
+	/* Register the drive as a platform device */
+	if (platform_device_register(&ipipe_pt_device) != 0) {
+		driver_unregister(&ipipe_driver);
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&cdev);
+		return -EINVAL;
+	}
+
+	ipipe_class = class_simple_create(THIS_MODULE, "dm355_ipipe");
+	if (!ipipe_class) {
+		printk("ipipe_init: error in creating device class\n");
+		driver_unregister(&ipipe_driver);
+		platform_device_unregister(&ipipe_pt_device);
+		unregister_chrdev_region(dev, 1);
+		unregister_chrdev(MAJOR(dev), DRIVERNAME);
+		cdev_del(&cdev);
+		return -EINVAL;
+	}
+	/* register simple device class */
+	class_simple_device_add(ipipe_class, dev, NULL, "dm355_ipipe");
+
+	/* Set up the Interrupt handler for PRVINT interrupt */
+	/*request irq 8(sdr) intt */
+	result = request_irq(IRQ_DM355_IPIPE_SDR, ipipe_isr, SA_INTERRUPT,
+			     "dm355_ipipe", (void *)&ipipedevice);
+
+	if (result < 0) {
+		dev_dbg(ipipe_dev, "ipipe_init:cannot get irq\n");
+
+		unregister_chrdev_region(dev, 1);
+		class_simple_device_remove(dev);
+		class_simple_destroy(ipipe_class);
+		driver_unregister(&ipipe_driver);
+		platform_device_unregister(&ipipe_pt_device);
+		cdev_del(&cdev);
+		return -EINVAL;
+	}
+
+	ipipedevice.opened = 0;
+	printk(KERN_INFO "ipipe driver registered\n");
+
+	return 0;
+}
+
+void __exit ipipe_cleanup(void)
+{
+	/* remove major number allocated to this driver */
+	unregister_chrdev_region(dev, 1);
+
+	/* Remove platform driver */
+	driver_unregister(&ipipe_driver);
+
+	/* remove simple class device */
+	class_simple_device_remove(dev);
+
+	/* destroy simple class */
+	class_simple_destroy(ipipe_class);
+
+	/* remove platform device */
+	platform_device_unregister(&ipipe_pt_device);
+
+	/* disable interrupt */
+	free_irq(IRQ_DM355_IPIPE_SDR, &ipipedevice);
+	cdev_del(&cdev);
+
+	/* unregistering the driver from the kernel */
+	unregister_chrdev(MAJOR(dev), DRIVERNAME);
+}
+
+module_init(ipipe_init);
+module_exit(ipipe_cleanup);
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/dm355_ipipe_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/dm355_ipipe_hw.c
@@ -0,0 +1,725 @@
+/*
+ * 
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_ipipe_hw.c file */
+
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <asm-arm/arch-davinci/dm355_ipipe_hw.h>
+#include <asm-arm/arch-davinci/dm355_ipipe.h>
+
+#include <linux/device.h>
+#ifdef __KERNEL__
+
+extern struct device *ipipe_dev;
+
+/* ipipe_hw_setup:It is used for Hardware Setup */
+int ipipe_hw_setup(struct ipipe_params *config)
+{
+	u32 utemp = 0;
+	u32 data_format;
+	ipipeif_decimation decimation_en;
+	ipipeif_input_source input_source = config->ipipeif_param.source;
+	if (!config)
+		return -EINVAL;
+
+	/*Hardware set up of IPIPEIF Module */
+	/*Combine all the fields to make CFG register of IPIPEIF */
+	utemp = config->ipipeif_param.mode << 0;
+	utemp |= config->ipipeif_param.decimation << 1;
+	utemp |= config->ipipeif_param.source << 2;
+	utemp |= config->ipipeif_param.clk_div << 4;
+	utemp |= config->ipipeif_param.avg_filter << 7;
+	utemp |= config->ipipeif_param.pack_mode << 8;
+	utemp |= config->ipipeif_param.ialaw << 9;
+	utemp |= config->ipipeif_param.clock_select << 10;
+	utemp |= config->ipipeif_param.data_shift << 11;
+	regw_if(utemp, IPIPEIF_GFG);
+	switch (input_source) {
+	case CCDC:
+		regw_if(config->ipipeif_param.gain, IPIPEIF_GAIN);
+
+		break;
+
+	case SDRAM_RAW:
+
+	case CCDC_DARKFM:
+		regw_if(config->ipipeif_param.gain, IPIPEIF_GAIN);
+
+	case SDRAM_YUV:
+		regw_if(config->ipipeif_param.glob_hor_size, IPIPEIF_PPLN);
+		regw_if(config->ipipeif_param.glob_ver_size, IPIPEIF_LPFR);
+		regw_if(config->ipipeif_param.hnum, IPIPEIF_HNUM);
+		regw_if(config->ipipeif_param.vnum, IPIPEIF_VNUM);
+#if 0
+		/* Following Register are part of buffer management (ipipe) */
+		regw_if(config->ipipeif_param.addru, IPIPEIF_ADDRU);
+		regw_if(config->ipipeif_param.addrl, IPIPEIF_ADDRL);
+		regw_if(config->ipipeif_param.adofs, IPIPEIF_ADOFS);
+#endif
+		utemp = regr_vpss(VPSS_PCR);
+		RESETBIT(utemp, 4);
+		RESETBIT(utemp, 5);
+		regw_vpss(utemp, VPSS_PCR);
+
+		break;
+
+	}
+	/*check if decimation is enable or not */
+	decimation_en = config->ipipeif_param.decimation;
+	if (decimation_en) {
+		regw_if(config->ipipeif_param.rsz, IPIPEIF_RSZ);
+		/* Enable Aneraging filter PRATIK */
+	}
+
+	/*Hardware set up of IPIPE Module */
+	/*set GCL_ARM reg before writting to ipipe registers */
+	regw_ip(1, GCL_ARM);
+	/*enable the clock wb,cfa,dfc,d2f,pre modules */
+	regw_ip(0x06, GCL_CCD);
+	data_format =
+	    (config->ipipe_dpaths_fmt | (config->ipipe_dpaths_bypass) << 2);
+
+	utemp = regr_vpss(VPSS_PCR);
+	RESETBIT(utemp, 6);
+	regw_vpss(utemp, VPSS_PCR);
+	/*enable ipipe mode to either one shot or continuous */
+	utemp = regr_ip(IPIPE_MODE);
+	RESETBIT(utemp, 0); /*first reset mode bit and then set it by
+			      config->ipipe_mode */
+	utemp |= config->ipipe_mode;
+	regw_ip(utemp, IPIPE_MODE);
+	regw_ip(data_format, IPIPE_DPATHS);
+	/*set size */
+	regw_ip(config->ipipe_vst, IPIPE_VST);
+	regw_ip(config->ipipe_hst, IPIPE_HST);
+	regw_ip(config->ipipe_vsz, IPIPE_VSZ);
+	regw_ip(config->ipipe_hsz, IPIPE_HSZ);
+	switch (data_format) {
+	case RAW2YUV:
+
+		/*Combine all the fields to make COLPAT register of IPIPE */
+		utemp = (config->ipipe_colpat_elep << 0);
+		utemp |= (config->ipipe_colpat_elop << 2);
+		utemp |= (config->ipipe_colpat_olep << 4);
+		utemp |= (config->ipipe_colpat_olop << 6);
+
+		regw_ip(utemp, IPIPE_COLPAT);
+		/* set_dfc_regs(&(config->def_cor)); */ /*defect correction */
+		set_d2f_regs(&(config->prog_nf));	/*noise filter */
+		set_pre_regs(&(config->prefilter));	/*prefilter */
+		/*histogram configuration may come here */
+		set_wb_regs(&(config->wb));
+		/*diff data_format value needs diff regs to be
+		  configured so passing the value of data_format */
+		set_rgb_2_yuv_regs(config->ipipe_dpaths_fmt,
+				   &(config->rgb2yuv));
+
+		set_rgb_to_rgb_regs(&(config->rgb2rgb));	/*set RGB_*
+								   and GMM reg */
+		/*boundary scan calc configuration may come here */
+
+		set_ee_regs(&(config->edge_enhancer));
+		set_fcs_regs(&(config->false_color_suppresion));
+		set_rsz_regs(config);	/*set RSZ_SEQ registers */
+		set_aal_regs(config);	/*set RSZ_AAL registers */
+		/*set the registers of either RSZ0 or RSZ1 */
+		set_rsz_structs(config);
+
+		break;
+
+	case RAW2RAW:
+
+		/* set_dfc_regs(&(config->def_cor)); */       /*defect correction */
+		set_d2f_regs(&(config->prog_nf));	/*noise filter */
+		set_pre_regs(&(config->prefilter));	/*prefilter */
+		set_wb_regs(&(config->wb));	/* .................CHECK */
+		/*diff format value needs diff regs to be configured */
+		/*set_rgb_2_yuv_regs(config->ipipe_dpaths_fmt,
+		   &(config->rgb2yuv)); */
+		set_aal_regs(config);	/*set RSZ_AAL registers */
+		/*set the registers of RSZ0 and RSZ1 */
+		set_rsz_structs(config);	/*...................CHECK */
+		default_for_raw2raw(config);
+		break;
+
+	case RAW2BOX:
+		printk(KERN_INFO "boxcar mode is not supported by driver\n");
+
+		break;
+
+	case YUV2YUV:
+		set_ee_regs(&(config->edge_enhancer));
+		set_fcs_regs(&(config->false_color_suppresion));
+		set_rsz_regs(config);	/*set RSZ_SEQ registers */
+		set_aal_regs(config);	/*set RSZ_AAL registers */
+		/*set the registers of either RSZ0 or RSZ1 */
+		set_rsz_structs(config);
+		break;
+
+	case RAW2RAW_BYPASS:
+		/*set_dfc_regs(&(config->def_cor)); */      /*defect correction */
+		set_d2f_regs(&(config->prog_nf));	/*noise filter */
+		set_pre_regs(&(config->prefilter));	/*prefilter */
+		set_wb_regs(&(config->wb));
+		/*diff data_format  value needs diff regs to be configured
+		   so passing the value of data_format */
+		set_rgb_2_yuv_regs(config->ipipe_dpaths_fmt,
+				   &(config->rgb2yuv));
+		default_for_raw2raw(config);
+		default_for_bypass(config);
+		set_aal_regs(config);	/*set RSZ_AAL registers */
+		/*set the registers of either RSZ0 or RSZ1 */
+		set_rsz_structs(config);
+		break;
+
+	}
+	return 0;
+
+}
+
+/*default configuratins for RAW2RAW mode*/
+int default_for_raw2raw(struct ipipe_params *parameter)
+{
+	u32 utemp;
+	u32 bright = 0;
+	u32 contrast = 16;
+
+	int seq_tmm = 0;
+	utemp = regr_vpss(VPSS_MEMCTL);
+	RESETBIT(utemp, 1);
+	RESETBIT(utemp, 0);
+	SETBIT(utemp, 2);
+	regw_vpss(utemp, VPSS_MEMCTL);
+
+	regw_ip(1, GCL_SDR);
+
+	/*set this to 0 for dafault config */
+	utemp =
+	    (parameter->rsz_seq_seq << 0) | (seq_tmm << 1) | (parameter->
+							      rsz_seq_hrv << 2)
+	    | (parameter->rsz_seq_vrv << 3) | (parameter->rsz_seq_crv << 4);
+	regw_ip(utemp, RSZ_SEQ);
+	/*set this to 0 for dafault config */
+	regw_ip(0, FCS_EN);
+	/*set this to 0 for dafault config */
+	regw_ip(0, YEE_EN);
+	/*set default brightness and contrast */
+	utemp = ((contrast << 0) | (bright << 8));
+	regw_ip(utemp, YUV_ADJ);
+
+	/*set default luminance */
+	regw_ip(0, YUV_Y_MIN);
+	regw_ip(255, YUV_Y_MAX);
+
+	/*set default chrominance */
+	regw_ip(0, YUV_C_MIN);
+	regw_ip(255, YUV_C_MAX);
+	/*default config for resizer 1  registers */
+	regw_ip(1, RSZ_EN_0);
+	regw_ip(0, RSZ_EN_0 + RSZ_I_HST);
+	regw_ip(0, RSZ_EN_0 + RSZ_I_VST);
+	regw_ip(0, RSZ_EN_0 + RSZ_O_HST);
+	regw_ip(0, RSZ_EN_0 + RSZ_V_PHS);
+	regw_ip(256, RSZ_EN_0 + RSZ_V_DIF);
+	regw_ip(256, RSZ_EN_0 + RSZ_H_DIF);
+	regw_ip(0, RSZ_EN_0 + RSZ_H_PHS);
+	regw_ip(0, RSZ_EN_0 + RSZ_H_TYP);
+	regw_ip(0, RSZ_EN_0 + RSZ_H_LSE);
+	regw_ip(0, RSZ_EN_0 + RSZ_H_LPF);
+	regw_ip(0, RSZ_EN_0 + RSZ_RGB_EN);
+	/*disable resizer 0 in default mode */
+	regw_ip(0, RSZ_EN_1);
+/*
+for debugging	
+*/
+	return 0;
+}
+
+/*default configuratins for RAW2RAW_bypass mode*/
+int default_for_bypass(struct ipipe_params *parameter)
+{
+	/*disable noise filter in default config */
+	regw_ip(0, D2F_EN);
+	/*disable defect coorection in default config */
+	regw_ip(0, DFC_EN);
+	/*disable prefilter filter in default config */
+	regw_ip(0, PRE_EN);
+	/*set default config for white balance */
+	regw_ip(256, WB2_DGN);
+	regw_ip(128, WB2_WG_R);
+	regw_ip(128, WB2_WG_GR);
+	regw_ip(128, WB2_WG_GB);
+	regw_ip(128, WB2_WG_B);
+	return 0;
+}
+
+/*IPIPE Register write function definition */
+int set_dfc_regs(struct ipipe_def_cor *dfc)
+{
+	u32 utemp;
+	unsigned int horizontal_pos[MAX_SIZE_DFC];
+	unsigned int vertical_pos_method[MAX_SIZE_DFC];
+	unsigned int count;
+	regw_ip(dfc->dfc_en, DFC_EN);	/*writting to enable register */
+
+	if (1 == dfc->dfc_en) {
+		regw_ip(dfc->dfc_sel, DFC_SEL);
+		regw_ip(DEF_COR_START_ADDR, DFC_ADR);
+		regw_ip(dfc->dfc_siz, DFC_SIZE);
+		utemp = regr_vpss(VPSS_MEMCTL);
+		RESETBIT(utemp, 0);
+		regw_vpss(utemp, VPSS_MEMCTL);
+		/*set the auto increment,write only,dfc mode in RAM_MODE */
+		regw_ip(0x0034, RAM_MODE);
+		regw_ip(0x00, RAM_ADR);
+		regw_ip(dfc->dfc_adr, DFC_ADR);
+		/*regw_ip(0x00,DFC_ADR);*/
+		if (dfc->dfc_table != NULL) {
+			for (count = 0; count < dfc->dfc_siz; count++) {
+				horizontal_pos[count] =
+				    dfc->dfc_table[count] & 0x00000FFF;
+				vertical_pos_method[count] =
+				    dfc->dfc_table[count] & 0x07FFF000;
+			}
+
+			/*write first twelve bit */
+			count = 0;
+
+			while (count < dfc->dfc_siz) {
+				regw_ip(horizontal_pos[count], RAM_WDT);
+				printk(KERN_INFO "###RAM_WDT[%d] = %x\n", count,
+				       regr_ip(RAM_WDT));
+				/*write next fifteen bit */
+				regw_ip(vertical_pos_method[count], RAM_WDT);
+				printk(KERN_INFO "RAM_WDT[%d] = %x\n", count,
+				       regr_ip(RAM_WDT));
+
+				count++;
+			}
+
+		} else {
+
+		}
+
+	}
+	return 0;
+
+}
+
+int set_d2f_regs(struct ipipe_prog_nf *noise_filter)
+{
+	u32 utemp;
+	int count = 0;
+	regw_ip(noise_filter->noise_fil_en, D2F_EN);
+	if (1 == noise_filter->noise_fil_en) {
+		/*Combine all the fields to make D2F_CFG register of IPIPE */
+		utemp =
+		    (noise_filter->d2f_cfg_spr << 0) | (noise_filter->
+							d2f_cfg_shf << 2) |
+		    (noise_filter->type << 4);
+		regw_ip(utemp, D2F_CFG);
+		if (noise_filter->d2f_str != NULL) {
+			count = 0;
+			while (count < 32) {
+				regw_ip(noise_filter->d2f_str[count],
+					D2F_STR + count * 4);
+				count++;
+			}
+		} else {
+		}
+		if (noise_filter->d2f_thr != NULL) {
+			count = 0;
+			while (count < 32) {
+				regw_ip(noise_filter->d2f_thr[count],
+					DFC_THR + count * 4);
+				count++;
+			}
+		} else {
+		}
+	}
+	return 0;
+}
+
+int set_pre_regs(struct ipipe_prefilter *pre_filter)
+{
+
+	u32 utemp;
+	regw_ip(pre_filter->pre_en, PRE_EN);
+	if (1 == pre_filter->pre_en) {
+		/*Combine all the fields to make PRE_EN register of IPIPE */
+		utemp = ((pre_filter->sel_0 << 0) | (pre_filter->sel_1 << 1) |
+			 (pre_filter->typ_adaptive << 2) | (pre_filter->
+							    typ_adaptive_dotred)
+			 << 3);
+		regw_ip(utemp, PRE_TYP);
+		regw_ip(pre_filter->pre_shf, PRE_SHF);
+		regw_ip(pre_filter->pre_gain, PRE_GAIN);
+		regw_ip(pre_filter->pre_thr_g, PRE_THR_G);
+		regw_ip(pre_filter->pre_thr_b, PRE_THR_B);
+		regw_ip(pre_filter->pre_thr_1, PRE_THR_1);
+	}
+	return 0;
+
+}
+int set_wb_regs(struct ipipe_wb *white_balance)
+{
+	regw_ip(white_balance->wb2_dgn, WB2_DGN);
+	regw_ip(white_balance->wb2_wg_r, WB2_WG_R);
+	regw_ip(white_balance->wb2_wg_gr, WB2_WG_GR);
+	regw_ip(white_balance->wb2_wg_gb, WB2_WG_GB);
+	regw_ip(white_balance->wb2_wg_b, WB2_WG_B);
+	return 0;
+}
+
+int set_rgb_2_yuv_regs(int data_format, struct ipipe_rgb2yuv *y_cr_cb)
+{
+	u32 utemp;
+	if (data_format < 2) {
+		/*combine fields of YUV_ADJ to set brightness and contrast */
+		utemp =
+		    ((y_cr_cb->yuv_adj_ctr << 0) | (y_cr_cb->yuv_adj_brt << 8));
+		regw_ip(utemp, YUV_ADJ);
+		regw_ip(y_cr_cb->yuv_y_min, YUV_Y_MIN);
+		regw_ip(y_cr_cb->yuv_y_max, YUV_Y_MAX);
+		regw_ip(y_cr_cb->yuv_c_min, YUV_C_MIN);
+		regw_ip(y_cr_cb->yuv_c_max, YUV_C_MAX);
+
+	}
+	if (data_format == 0) {
+
+		regw_ip(y_cr_cb->yuv_mul_ry, YUV_MUL_RY);
+		regw_ip(y_cr_cb->yuv_mul_gy, YUV_MUL_GY);
+		regw_ip(y_cr_cb->yuv_mul_by, YUV_MUL_BY);
+		regw_ip(y_cr_cb->yuv_mul_rcb, YUV_MUL_RCB);
+		regw_ip(y_cr_cb->yuv_mul_gcb, YUV_MUL_GCB);
+		regw_ip(y_cr_cb->yuv_mul_bcb, YUV_MUL_BCB);
+		regw_ip(y_cr_cb->yuv_mul_rcr, YUV_MUL_RCR);
+		regw_ip(y_cr_cb->yuv_mul_gcr, YUV_MUL_GCR);
+		regw_ip(y_cr_cb->yuv_mul_bcr, YUV_MUL_BCR);
+		regw_ip(y_cr_cb->yuv_oft_y, YUV_OFT_Y);
+		regw_ip(y_cr_cb->yuv_oft_cb, YUV_OFT_CB);
+		regw_ip(y_cr_cb->yuv_oft_cr, YUV_OFT_CR);
+		/*Combine all the fields to make YUV_PHS register of IPIPE */
+		utemp =
+		    ((y_cr_cb->yuv_phs_position << 0) | (y_cr_cb->
+							 yuv_phs_lpf << 1));
+		regw_ip(utemp, YUV_PHS);
+
+	}
+	return 0;
+}
+int set_rgb_to_rgb_regs(struct ipipe_rgb2rgb *rgb)
+{
+	u32 utemp;
+	int count, table_size = 0;
+
+	regw_ip(rgb->rgb_mul_rr, RGB_MUL_RR);
+	regw_ip(rgb->rgb_mul_gr, RGB_MUL_GR);
+	regw_ip(rgb->rgb_mul_br, RGB_MUL_BR);
+	regw_ip(rgb->rgb_mul_rg, RGB_MUL_RG);
+	regw_ip(rgb->rgb_mul_gg, RGB_MUL_GG);
+	regw_ip(rgb->rgb_mul_bg, RGB_MUL_BG);
+	regw_ip(rgb->rgb_mul_rb, RGB_MUL_RB);
+	regw_ip(rgb->rgb_mul_gb, RGB_MUL_GB);
+	regw_ip(rgb->rgb_mul_bb, RGB_MUL_BB);
+	regw_ip(rgb->rgb_oft_or, RGB_MUL_OR);
+	regw_ip(rgb->rgb_oft_og, RGB_MUL_OG);
+	regw_ip(rgb->rgb_oft_ob, RGB_MUL_OB);
+
+	utemp =
+	    ((rgb->gmm_cfg_bypr << 0) | (rgb->gmm_cfg_bypg << 1) | (rgb->
+								    gmm_cfg_bypb
+								    << 2)
+	     | (rgb->gmm_cfg_tbl << 4) | (rgb->gmm_cfg_siz << 5));
+
+	regw_ip(utemp, GMM_CFG);
+	/*testing -- for register write */
+	utemp = regr_ip(GMM_CFG);
+
+	if (rgb->gmm_cfg_siz == IPIPE_128) {
+		table_size = 128 * 2;
+	} else if (rgb->gmm_cfg_siz == IPIPE_256) {
+		table_size = 256 * 2;
+	} else if (rgb->gmm_cfg_siz == IPIPE_512) {
+		table_size = 512 * 2;
+	}
+	if (!(rgb->gmm_cfg_bypr)) {
+		if (rgb->gmm_tbl_r != NULL) {
+			/*set the auto increment,write only, gamma
+			  red mode in RAM_MODE */
+			regw_ip(0x0035, RAM_MODE);
+			/*set the starting address of gamma table */
+			regw_ip(0x00, RAM_ADR);
+
+			for (count = 0; count < table_size; count++)
+				regw_ip(rgb->gmm_tbl_r[count], RAM_WDT);
+		}
+	}
+	if (!(rgb->gmm_cfg_bypb)) {
+		if (rgb->gmm_tbl_b != NULL) {
+			/*set the auto increment,write only, gamma red mode
+			  in RAM_MODE */
+			regw_ip(0x0036, RAM_MODE);
+			/*set the starting address of gamma table */
+			regw_ip(0x00, RAM_ADR);
+			for (count = 0; count < table_size; count++)
+				regw_ip(rgb->gmm_tbl_b[count], RAM_WDT);
+		}
+	}
+	if (!(rgb->gmm_cfg_bypg)) {
+		if (rgb->gmm_tbl_g != NULL) {
+			/*set the auto increment,write only, gamma red
+			  mode in RAM_MODE */
+			regw_ip(0x0037, RAM_MODE);
+			/*set the starting address of gamma table */
+			regw_ip(0x00, RAM_ADR);
+			for (count = 0; count < table_size; count++)
+				regw_ip(rgb->gmm_tbl_g[count], RAM_WDT);
+		}
+	}
+	/*set the auto increment,write only, gamma red mode in RAM_MODE */
+	regw_ip(0x0038, RAM_MODE);
+	/*set the starting address of gamma table */
+	regw_ip(0x00, RAM_ADR);
+	if (rgb->gmm_tbl_all != NULL) {
+		printk(KERN_INFO "gamma table not null\n");
+		for (count = 0; count < table_size; count++)
+			regw_ip(rgb->gmm_tbl_all[count], RAM_WDT);
+	} else {
+	}
+	regw_ip(0x00, RAM_MODE);
+	return 0;
+}
+
+int set_ee_regs(struct ipipe_edge_enhancer *edge_enhance)
+{
+	unsigned int count;
+	regw_ip(edge_enhance->yee_en, YEE_EN);
+	if (1 == edge_enhance->yee_en) {
+		regw_ip(edge_enhance->yee_emf, YEE_EMF);
+		regw_ip(edge_enhance->yee_shf, YEE_SHF);
+		regw_ip(edge_enhance->yee_mul_00, YEE_MUL_00);
+		regw_ip(edge_enhance->yee_mul_01, YEE_MUL_01);
+		regw_ip(edge_enhance->yee_mul_02, YEE_MUL_02);
+		regw_ip(edge_enhance->yee_mul_10, YEE_MUL_10);
+		regw_ip(edge_enhance->yee_mul_11, YEE_MUL_11);
+		regw_ip(edge_enhance->yee_mul_12, YEE_MUL_12);
+		regw_ip(edge_enhance->yee_mul_20, YEE_MUL_20);
+		regw_ip(edge_enhance->yee_mul_21, YEE_MUL_21);
+		regw_ip(edge_enhance->yee_mul_22, YEE_MUL_22);
+		/*set the auto increment,write only,ee mode in RAM_MODE */
+		regw_ip(0x0039, RAM_MODE);
+		regw_ip(-512 /*0x1FF */ , RAM_ADR);
+		if (edge_enhance->ee_table != NULL) {
+			for (count = 0; count < MAX_SIZE_EEC; count++)
+				regw_ip(edge_enhance->ee_table[count], RAM_WDT);
+
+			regw_ip(0x0, RAM_MODE);
+			regw_ip(0x0019, RAM_MODE);
+			regw_ip(-512, RAM_ADR);
+			for (count = 0; count < MAX_SIZE_EEC; count++)
+				regw_ip(0xFF, RAM_WDT);
+		}
+	}
+	return 0;
+}
+
+int set_fcs_regs(struct ipipe_false_color_suppresion *color_supress)
+{
+	regw_ip(color_supress->fcs_en, FCS_EN);
+	if (1 == color_supress->fcs_en) {
+		regw_ip(color_supress->fcs_typ_typ, FCS_TYP);
+		regw_ip(color_supress->fcs_shf_y, FCS_SHF_Y);
+		regw_ip(color_supress->fcs_shf_c, FCS_SHF_C);
+		regw_ip(color_supress->fcs_thr, FCS_THR);
+		regw_ip(color_supress->fcs_sgn, FCS_SGN);
+		regw_ip(color_supress->fcs_lth, FCS_LTH);
+	}
+	return 0;
+}
+
+int set_rsz_regs(struct ipipe_params *param_resize)
+{
+	u32 utemp;
+	/*Combine all the fields to make RSZ_SEQ register of IPIPE */
+	utemp =
+	    (param_resize->rsz_seq_seq << 0) | (param_resize->
+						rsz_seq_tmm << 1) |
+	    (param_resize->rsz_seq_hrv << 2)
+	    | (param_resize->rsz_seq_vrv << 3) | (param_resize->
+						  rsz_seq_crv << 4);
+	regw_ip(utemp, RSZ_SEQ);
+
+	return 0;
+}
+
+int set_aal_regs(struct ipipe_params *param_resize)
+{
+	regw_ip(param_resize->rsz_aal, RSZ_AAL);
+	return 0;
+}
+
+int set_rsz_structs(struct ipipe_params *params)
+{				/*set the registers of either RSZ0 or RSZ1 */
+	u32 utemp;
+	u32 rsz_seq, rsz_tmm;
+	utemp = regr_vpss(VPSS_MEMCTL);
+	RESETBIT(utemp, 1);
+	RESETBIT(utemp, 0);
+	SETBIT(utemp, 2);
+	regw_vpss(utemp, VPSS_MEMCTL);
+	regw_ip(params->rsz_en[0], RSZ_EN_0);
+	if (params->rsz_en[0]) {
+		/*testing--- for register write */
+		utemp = regr_ip(RSZ_EN_0);
+		/*enable RSZ clock */
+		regw_ip(1, GCL_SDR);
+		/*setting rescale parameters */
+		regw_ip(params->rsz_rsc_param[0].rsz_mode, RSZ_EN_0 + RSZ_MODE);
+		regw_ip(params->rsz_rsc_param[0].rsz_i_vst,
+			RSZ_EN_0 + RSZ_I_VST);
+		regw_ip(params->rsz_rsc_param[0].rsz_i_hst,
+			RSZ_EN_0 + RSZ_I_HST);
+		regw_ip(params->rsz_rsc_param[0].rsz_o_vsz,
+			RSZ_EN_0 + RSZ_O_VSZ);
+		regw_ip(params->rsz_rsc_param[0].rsz_o_hsz,
+			RSZ_EN_0 + RSZ_O_HSZ);
+		regw_ip(params->rsz_rsc_param[0].rsz_o_hst,
+			RSZ_EN_0 + RSZ_O_HST);
+		regw_ip(params->rsz_rsc_param[0].rsz_v_phs,
+			RSZ_EN_0 + RSZ_V_PHS);
+		regw_ip(params->rsz_rsc_param[0].rsz_v_dif,
+			RSZ_EN_0 + RSZ_V_DIF);
+		regw_ip(params->rsz_rsc_param[0].rsz_h_phs,
+			RSZ_EN_0 + RSZ_H_PHS);
+		regw_ip(params->rsz_rsc_param[0].rsz_h_dif,
+			RSZ_EN_0 + RSZ_H_DIF);
+		regw_ip(params->rsz_rsc_param[0].rsz_h_typ,
+			RSZ_EN_0 + RSZ_H_TYP);
+		regw_ip(params->rsz_rsc_param[0].rsz_h_lse_sel,
+			RSZ_EN_0 + RSZ_H_LSE);
+		regw_ip(params->rsz_rsc_param[0].rsz_h_lpf,
+			RSZ_EN_0 + RSZ_H_LPF);
+
+		/*seting rgb conversion parameters */
+		regw_ip(params->rsz2rgb[0].rsz_rgb_en, RSZ_EN_0 + RSZ_RGB_EN);
+		regw_ip(params->rsz2rgb[0].rsz_rgb_en, RSZ_EN_0 + RSZ_RGB_EN);
+		utemp =
+		    ((params->rsz2rgb[0].rsz_rgb_typ << 0) | (params->
+							      rsz2rgb[0].
+							      rsz_rgb_msk0 << 1)
+		     | (params->rsz2rgb[0].rsz_rgb_msk1) << 2);
+		regw_ip(utemp, RSZ_RGB_TYP);
+		regw_ip(params->rsz2rgb[0].rsz_rgb_alpha_val,
+			RSZ_EN_0 + RSZ_RGB_BLD);
+
+		/*setting external memory parameters */
+		regw_ip(params->ext_mem_param[0].rsz_sdr_oft,
+			RSZ_EN_0 + RSZ_SDR_OFT);
+		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_s,
+			RSZ_EN_0 + RSZ_SDR_PTR_S);
+		regw_ip(params->ext_mem_param[0].rsz_sdr_ptr_e,
+			RSZ_EN_0 + RSZ_SDR_PTR_E);
+	}
+
+	regw_ip(params->rsz_en[1], RSZ_EN_1);
+	if (params->rsz_en[1]) {
+		/*testing---- for register write */
+		utemp = regr_ip(RSZ_EN_1);
+
+		/*enable RSZ clock */
+		regw_ip(1, GCL_SDR);
+		/*setting rescale parameters */
+		regw_ip(params->rsz_rsc_param[1].rsz_mode, RSZ_EN_1 + RSZ_MODE);
+		regw_ip(params->rsz_rsc_param[1].rsz_i_vst,
+			RSZ_EN_1 + RSZ_I_VST);
+		/*regw_ip(rez_rescale_para->rsz_i_vsz,
+		   RSZ_EN_0 + RSZ_I_VSZ); */
+		regw_ip(params->rsz_rsc_param[1].rsz_i_hst,
+			RSZ_EN_1 + RSZ_I_HST);
+		regw_ip(params->rsz_rsc_param[1].rsz_o_vsz,
+			RSZ_EN_1 + RSZ_O_VSZ);
+		regw_ip(params->rsz_rsc_param[1].rsz_o_hsz,
+			RSZ_EN_1 + RSZ_O_HSZ);
+		regw_ip(params->rsz_rsc_param[1].rsz_o_hst,
+			RSZ_EN_1 + RSZ_O_HST);
+		regw_ip(params->rsz_rsc_param[1].rsz_v_phs,
+			RSZ_EN_1 + RSZ_V_PHS);
+		regw_ip(params->rsz_rsc_param[1].rsz_v_dif,
+			RSZ_EN_1 + RSZ_V_DIF);
+		regw_ip(params->rsz_rsc_param[1].rsz_h_phs,
+			RSZ_EN_1 + RSZ_H_PHS);
+		regw_ip(params->rsz_rsc_param[1].rsz_h_dif,
+			RSZ_EN_1 + RSZ_H_DIF);
+		regw_ip(params->rsz_rsc_param[1].rsz_h_typ,
+			RSZ_EN_1 + RSZ_H_TYP);
+		regw_ip(params->rsz_rsc_param[1].rsz_h_lse_sel,
+			RSZ_EN_1 + RSZ_H_LSE);
+		regw_ip(params->rsz_rsc_param[1].rsz_h_lpf,
+			RSZ_EN_1 + RSZ_H_LPF);
+
+		/*seting rgb conversion parameters */
+		regw_ip(params->rsz2rgb[1].rsz_rgb_en, RSZ_EN_1 + RSZ_RGB_EN);
+		regw_ip(params->rsz2rgb[1].rsz_rgb_en, RSZ_EN_1 + RSZ_RGB_EN);
+		utemp =
+		    ((params->rsz2rgb[1].rsz_rgb_typ << 0) | (params->
+							      rsz2rgb[1].
+							      rsz_rgb_msk0 << 1)
+		     | (params->rsz2rgb[1].rsz_rgb_msk1) << 2);
+		regw_ip(utemp, RSZ_RGB_TYP);
+		regw_ip(params->rsz2rgb[1].rsz_rgb_alpha_val,
+			RSZ_EN_1 + RSZ_RGB_BLD);
+
+		/*setting external memory parameters */
+		regw_ip(params->ext_mem_param[1].rsz_sdr_oft,
+			RSZ_EN_1 + RSZ_SDR_OFT);
+		regw_ip(params->ext_mem_param[1].rsz_sdr_ptr_s,
+			RSZ_EN_1 + RSZ_SDR_PTR_S);
+		regw_ip(params->ext_mem_param[1].rsz_sdr_ptr_e,
+			RSZ_EN_1 + RSZ_SDR_PTR_E);
+
+	} else {
+	}
+
+	if (!params->rsz_en[0] && !params->rsz_en[1]) {	/*resizer bypass mode */
+		rsz_tmm = 0;
+		rsz_seq = 0;
+		utemp =
+		    (params->rsz_seq_seq << 0) | (params->
+						  rsz_seq_tmm << 1) | (params->
+								       rsz_seq_hrv
+								       << 2)
+		    | (params->rsz_seq_vrv << 3) | (params->rsz_seq_crv << 4);
+		regw_ip(0, RSZ_AAL);
+		regw_ip(0, RSZ_EN_0 + RSZ_O_HST);
+		regw_ip(0, RSZ_EN_0 + RSZ_V_PHS);
+		regw_ip(256, RSZ_EN_0 + RSZ_V_DIF);
+		regw_ip(256, RSZ_EN_0 + RSZ_H_DIF);
+		regw_ip(0, RSZ_EN_0 + RSZ_H_LSE);
+		regw_ip(0, RSZ_EN_0 + RSZ_H_PHS);
+		regw_ip(0, RSZ_EN_1);
+		/*disable resizer clock, necessary to bypass resizer */
+		regw_ip(0, GCL_SDR);
+
+	}
+	return 0;
+}
+
+#endif				/* End of #ifdef __KERNEL__ */
Index: linux-2.6.10/drivers/media/video/davinci/ipipe_para.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/ipipe_para.h
@@ -0,0 +1,228 @@
+#define  WIDTH_I 640
+#define  HEIGHT_I 480
+#define  WIDTH_O 640
+#define  HEIGHT_O 480
+
+struct ipipe_params param_def = {
+	.ipipeif_param = {
+			  /*IPPEIF config register */
+			  .data_shift = BITS9_0,
+			  .clock_select = SDRAM_CLK,
+
+			  .ialaw = ALAW_OFF,
+			  .pack_mode = SIXTEEN_BIT,
+			  .avg_filter = AVG_OFF,
+			  .clk_div = DIVIDE_SIXTH,
+			  .source = SDRAM_RAW,
+			  .decimation = DECIMATION_OFF,
+			  .mode = ONE_SHOT,
+
+			  .glob_hor_size = WIDTH_I + 8,	/*632,*/
+			  .glob_ver_size = HEIGHT_I + 10,	/*466,*/
+			  .hnum = WIDTH_I,	/* 624,*/
+			  .vnum = HEIGHT_I,	/* 456, */
+			  .adofs = WIDTH_I * 2,	/* 1248,  to make it
+						   32 alligned */
+			  .rsz = 16,	/* resize ratio = 16/rsz:
+					   valid range (16-112) */
+			  .gain = 0x200	/* (precision is U10Q9) */
+			  },
+	.ipipe_mode = ONE_SHOT,
+	/*input/output datapath register */
+	.ipipe_dpaths_fmt = RAW2YUV,
+	.ipipe_dpaths_bypass = RAW_MODE_OFF,	/*...check */
+
+	/*color pattern register */
+	.ipipe_colpat_olop = RED,
+	.ipipe_colpat_olep = GREEN_RED,
+	.ipipe_colpat_elop = GREEN_BLUE,
+	.ipipe_colpat_elep = BLUE,
+
+	/*horizontal/vertical start, horizontal/vertical size */
+	.ipipe_vst = 0,
+	.ipipe_vsz = HEIGHT_I - 1,	/*456 - 1,*/
+	.ipipe_hst = 0,		/*check*/
+	.ipipe_hsz = WIDTH_I - 1,	/*624 - 1,*/
+	/*interupt generation after lines */
+
+	.def_cor = {.dfc_en = DISABLE,
+		    .dfc_sel = 0,
+		    /*.dfc_adr = 0,*/
+		    .dfc_siz = 4,
+		    .dfc_table = NULL	/*(unsigned int*) yeeTable*/
+		    },
+	.prog_nf = {
+		    .noise_fil_en = DISABLE,
+		    .d2f_cfg_spr = 0,
+		    .d2f_cfg_shf = 0,
+		    .type = 0,
+		    .d2f_thr = NULL,	/*(unsigned int *)NoiseFilterTHR ,*/
+		    .d2f_str = NULL	/*(unsigned int *)NoiseFilterSTR */
+		    },
+	.prefilter = {
+		      .pre_en = ENABLE,
+		      .sel_0 = 1,	/*AVG2MEDPIX,*/
+		      .sel_1 = 1,
+		      .typ_adaptive = ENABLE,
+		      .typ_adaptive_dotred = DISABLE,
+		      .pre_shf = 9,
+		      .pre_gain = 128,
+		      .pre_thr_g = 500,
+		      .pre_thr_b = 4096,
+		      .pre_thr_1 = 800},
+	.wb = {
+	       .wb2_dgn = 0x200,	/*512,512,1023,256, */
+	       .wb2_wg_r = 0x40,	/*444,*/
+	       .wb2_wg_gr = 0x45,	/*256,*/
+	       .wb2_wg_gb = 0x60,	/*256,*/
+	       .wb2_wg_b = 0x45,	/*568,428*/
+	       },
+	.rgb2rgb = {
+		    .rgb_mul_rr = 0x1a1,	/*0x016c,*/
+		    .rgb_mul_gr = 0xf8a,	/*0x0FA4,*/
+		    .rgb_mul_br = 0xfd5,	/*0x0FF1,*/
+		    .rgb_mul_rg = 0xfa1,	/*0x0FD2,*/
+		    .rgb_mul_gg = 0x1c4,	/*0x013D,*/
+		    .rgb_mul_bg = 0xf9b,	/*0x0FF1,*/
+		    .rgb_mul_rb = 0xfbd,	/*0x0FD2,*/
+		    .rgb_mul_gb = 0xfb1,	/*0x0FA4,*/
+		    .rgb_mul_bb = 0x192,	/*0x018A,*/
+		    .rgb_oft_or = 0x0000,
+		    .rgb_oft_og = 0x0000,
+		    .rgb_oft_ob = 0x0000,
+		    .gmm_cfg_bypr = GC_BYPASS,
+		    .gmm_cfg_bypg = GC_BYPASS,
+		    .gmm_cfg_bypb = GC_BYPASS,
+		    .gmm_cfg_tbl = IPIPE_RAM,
+		    .gmm_cfg_siz = IPIPE_512,
+		    .gmm_tbl_r = NULL,
+		    .gmm_tbl_b = NULL,
+		    .gmm_tbl_g = NULL,
+		    .gmm_tbl_all = NULL	/*(unsigned int *)GammaTableall */
+		    },
+	.rgb2yuv = {
+		    /* RDRV_IPIPE__SAT_LOW */
+		    .yuv_adj_ctr = 0x10,
+		    .yuv_adj_brt = 0x00,
+
+		    .yuv_mul_ry = 0x004d,
+		    .yuv_mul_gy = 0x0096,
+		    .yuv_mul_by = 0x001d,
+		    .yuv_mul_rcb = 0x03d4,
+		    .yuv_mul_gcb = 0x03ac,
+		    .yuv_mul_bcb = 0x0080,
+		    .yuv_mul_rcr = 0x0080,
+		    .yuv_mul_gcr = 0x0395,
+		    .yuv_mul_bcr = 0x03eb,
+		    .yuv_oft_y = 0x00,
+		    .yuv_oft_cb = 0x80,
+		    .yuv_oft_cr = 0x80,
+		    .yuv_y_min = 0,
+		    .yuv_y_max = 0xFF,
+		    .yuv_c_min = 0,
+		    .yuv_c_max = 0xFF,
+		    .yuv_phs_lpf = DISABLE,
+		    .yuv_phs_position = 1,
+
+		    },
+	.edge_enhancer = {
+
+			  .yee_en = DISABLE,
+			  .yee_emf = ENABLE,
+			  .yee_shf = 4,	/* HPF Down Shift
+					   Value: valid range (0-15) */
+			  .yee_mul_00 = 48,
+			  .yee_mul_01 = 12,
+			  .yee_mul_02 = 1014,
+			  .yee_mul_10 = 12,
+			  .yee_mul_11 = 0,
+			  .yee_mul_12 = 1018,
+			  .yee_mul_20 = 1014,
+			  .yee_mul_21 = 1018,
+			  .yee_mul_22 = 1022,
+			  .ee_table = NULL	/*(unsigned int*) yeeTable*/
+			  },
+	.false_color_suppresion = {
+				   .fcs_en = ENABLE,	/* Uint8 csupEnable*/
+				   .fcs_typ_typ = 0,
+				   .fcs_shf_y = 0,
+				   .fcs_shf_c = 7,
+				   .fcs_thr = 235,
+				   .fcs_sgn = 0,
+				   .fcs_lth = 0},
+	.rsz_seq_seq = DISABLE,
+	.rsz_seq_tmm = DISABLE,	/* output confined mode (normal mode) */
+	.rsz_seq_hrv = DISABLE,
+	.rsz_seq_vrv = DISABLE,
+	.rsz_seq_crv = DISABLE,
+
+	.rsz_aal = DISABLE,
+
+	.rsz_rsc_param = {
+			  {
+			   .rsz_mode = ONE_SHOT,
+			   .rsz_i_vst = 0,
+			   .rsz_i_vsz = 0,
+			   .rsz_i_hst = 0,
+			   .rsz_o_vsz = HEIGHT_O - 1,
+			   .rsz_o_hsz = WIDTH_O - 1,
+			   .rsz_o_hst = 0,
+			   .rsz_v_phs = 0,
+			   /*unsigned int rsz_v_phs_o;*/
+			   .rsz_v_dif = 243,
+			   /*unsigned int rsz_v_siz_o;*/
+			   .rsz_h_phs = 0,
+			   .rsz_h_dif = 243,
+			   .rsz_h_typ = CUBIC,
+			   .rsz_h_lse_sel = INTERNAL_VALUE,
+			   .rsz_h_lpf = 0},
+			  {
+			   ONE_SHOT,
+			   0,
+			   0,
+			   0,
+			   239,
+			   319,
+			   0,
+			   0,
+			   256,
+			   0,
+			   256,
+			   CUBIC,
+			   INTERNAL_VALUE,
+			   0}
+			  },
+	.rsz2rgb = {
+		    {
+		     .rsz_rgb_en = DISABLE,	/*....check*/
+		     /* .rsz_rgb_typ = 0,
+			.rsz_rgb_msk0 = 0,
+			.rsz_rgb_msk1 = 0,
+			.rsz_rgb_alpha_val = 0 */
+		     },
+		    {
+		     DISABLE,
+		     }
+		    },
+
+	.ext_mem_param = {
+			  {
+			   .rsz_sdr_bad_h = 0,
+			   .rsz_sdr_bad_l = 0,
+			   .rsz_sdr_sad_h = 0,
+			   .rsz_sdr_sad_l = 0,
+			   .rsz_sdr_oft = WIDTH_O * 2,
+			   .rsz_sdr_ptr_s = 0,
+			   .rsz_sdr_ptr_e = WIDTH_O},
+			  {
+			   0,
+			   0,
+			   0,
+			   0,
+			   WIDTH_O * 2,
+			   0,
+			   8191}
+			  },
+	.rsz_en[0] = ENABLE,
+	.rsz_en[1] = DISABLE
+};
Index: linux-2.6.10/drivers/media/video/davinci/logicpd_encoder.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/logicpd_encoder.c
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* logicpd_encoder.c. This is just a place holder for hardcoding all supported
+   modes timing. LogicPD timing signals are programmed by the encoder manager
+   based on this data.
+ */
+
+/* Kernel Specific header files */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/logicpd_encoder.h>
+
+/* Function prototypes */
+static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag);
+static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc);
+
+static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc);
+static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc);
+
+static int logicpd_encoder_setoutput(char *output,
+				     struct vid_encoder_device *enc);
+static int logicpd_encoder_getoutput(char *output,
+				     struct vid_encoder_device *enc);
+
+static int logicpd_encoder_enumoutput(int index,
+				      char *output,
+				      struct vid_encoder_device *enc);
+
+static struct logicpd_encoder_config logicpd_encoder_configuration = {
+	.no_of_outputs = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_LCD,
+		      .no_of_standard = LOGICPD_ENCODER_GRAPHICS_NUM_STD,
+		      .standards[0] = {
+				       .name = VID_ENC_STD_640x480,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 480,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 32,
+				       .lower_margin = 11,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 0},	/* hsync -ve, vsync -ve */
+		      .standards[1] = {
+				       .name = VID_ENC_STD_640x400,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 400,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 72,
+				       .lower_margin = 51,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 2},	/* hsync -ve, vsync +ve */
+		      .standards[2] = {
+				       .name = VID_ENC_STD_640x350,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 350,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 97,
+				       .lower_margin = 76,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 1},	/* hsync +ve, vsync -ve */
+		      .standards[3] = {	/* This is programmed by the user application. We just save
+					   the received timing information */
+				       .name = VID_ENC_STD_NON_STANDARD,
+				       .std = 0,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 0,
+				       .yres = 0,
+				       .fps = {0, 0},
+				       .left_margin = 0,
+				       .right_margin = 0,
+				       .upper_margin = 0,
+				       .lower_margin = 0,
+				       .hsync_len = 0,
+				       .vsync_len = 0,
+				       .flags = 0},
+		      },
+};
+
+static struct logicpd_encoder_channel logicpd_encoder_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_640x480,
+	.enc_device = NULL
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
+	.enumoutput = logicpd_encoder_enumoutput,
+	.setoutput = logicpd_encoder_setoutput,
+	.getoutput = logicpd_encoder_getoutput
+};
+
+static struct vid_enc_mode_ops modes_ops = {
+	.setmode = logicpd_encoder_setmode,
+	.getmode = logicpd_encoder_getmode,
+};
+
+static struct vid_encoder_device logicpd_encoder_dev = {
+	.name = "LOGICPD_ENCODER",
+	.capabilities = 0,
+	.initialize = logicpd_encoder_initialize,
+	.mode_ops = &modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = NULL,
+	.deinitialize = logicpd_encoder_deinitialize,
+};
+
+/* This function is called by the encoder manager to initialize logicpd encoder driver.
+ */
+static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0, outindex;
+	char *std, *output;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.enc_device = (struct encoder_device *)enc;
+
+	/* call set standard */
+	std = logicpd_encoder_channel_info.params.mode;
+	outindex = logicpd_encoder_channel_info.params.outindex;
+	output = logicpd_encoder_configuration.output[outindex].output_name;
+	err |= logicpd_encoder_setoutput(output, enc);
+	if (err < 0) {
+		err = -EINVAL;
+		printk(KERN_ERR "Error occured in setoutput\n");
+		logicpd_encoder_deinitialize(enc);
+		return err;
+	}
+	printk(KERN_DEBUG "LogicPD Encoder initialized\n");
+	return err;
+}
+
+/* Function to de-initialize the encoder */
+static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc)
+{
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.enc_device = NULL;
+	printk(KERN_DEBUG "LogicPD Encoder de-initialized\n");
+	return 0;
+}
+
+/* Following function is used to set the mode*/
+static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i;
+	char *mode;
+	struct vid_enc_mode_info *my_mode_info = NULL;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (NULL == (mode = mode_info->name)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "Start of logicpd_encoder_setmode..\n");
+	outindex = logicpd_encoder_channel_info.params.outindex;
+
+	if (mode_info->std) {
+		char *mymode = NULL;
+		/* This is a standard mode */
+		for (i = 0;
+		     i <
+		     logicpd_encoder_configuration.output[outindex].
+		     no_of_standard; i++) {
+			if (!strcmp
+			    (logicpd_encoder_configuration.output[outindex].
+			     standards[i].name, mode)) {
+				mymode =
+				    logicpd_encoder_configuration.
+				    output[outindex].standards[i].name;
+				break;
+			}
+		}
+		if ((i ==
+		     logicpd_encoder_configuration.output[outindex].
+		     no_of_standard) || (NULL == mymode)) {
+			printk(KERN_ERR "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of logicpd_encoder */
+		logicpd_encoder_channel_info.params.mode = mymode;
+		return 0;
+	} else {
+		/* Non- Standard mode. Check if we support it. If so
+		   save the timing info and return */
+		for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
+			if (!strcmp
+			    (logicpd_encoder_configuration.output[outindex].
+			     standards[i].name, VID_ENC_STD_NON_STANDARD)) {
+				my_mode_info =
+				    &logicpd_encoder_configuration.
+				    output[outindex].standards[i];
+				break;
+			}
+		}
+		if (my_mode_info) {
+			/* We support. So save timing info and return success 
+			   interface type is same as what is currently is active
+			 */
+			my_mode_info->interlaced = mode_info->interlaced;
+			my_mode_info->xres = mode_info->xres;
+			my_mode_info->yres = mode_info->yres;
+			my_mode_info->fps = mode_info->fps;
+			my_mode_info->left_margin = mode_info->left_margin;
+			my_mode_info->right_margin = mode_info->right_margin;
+			my_mode_info->upper_margin = mode_info->upper_margin;
+			my_mode_info->lower_margin = mode_info->lower_margin;
+			my_mode_info->hsync_len = mode_info->hsync_len;
+			my_mode_info->vsync_len = mode_info->vsync_len;
+			my_mode_info->flags = mode_info->flags;
+			/* If we need to configure something in the encoder module, we need to
+			   do this here */
+			return 0;
+		}
+		printk(KERN_ERR "Mode not supported..\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_setmode>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected mode.*/
+static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0, i, outindex;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<logicpd_encoder_getmode>\n");
+	outindex = logicpd_encoder_channel_info.params.outindex;
+	for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
+		if (!strcmp(logicpd_encoder_channel_info.params.mode,
+			    logicpd_encoder_configuration.output[outindex].
+			    standards[i].name)) {
+			memcpy(mode_info,
+			       &logicpd_encoder_configuration.output[outindex].
+			       standards[i], sizeof(struct vid_enc_mode_info));
+			break;
+		}
+	}
+	if (i == LOGICPD_ENCODER_GRAPHICS_NUM_STD) {
+		printk(KERN_ERR "Wiered. No mode info\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_getmode>\n");
+	return err;
+}
+
+/* For LogicPD, we have only one output, called LCD, we 
+   always set this to this at init 
+*/
+static int logicpd_encoder_setoutput(char *output,
+				     struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	printk(KERN_DEBUG "<logicpd_encoder_setoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output: NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Just check if the default output match with this output name */
+	if (strcmp(logicpd_encoder_configuration.output[0].output_name, output)) {
+		printk(KERN_ERR "no matching output found.\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.params.mode
+	    = logicpd_encoder_configuration.output[0].standards[0].name;
+
+	my_mode_info = &logicpd_encoder_configuration.output[0].standards[0];
+	err |= logicpd_encoder_setmode(my_mode_info, enc);
+	if (err < 0) {
+		printk(KERN_ERR "Error in setting default mode\n");
+		return err;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get output name of current output.*/
+static int logicpd_encoder_getoutput(char *output,
+				     struct vid_encoder_device *enc)
+{
+	int err = 0, index, len;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<logicpd_encoder_getoutput>\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = logicpd_encoder_channel_info.params.outindex;
+	len = strlen(logicpd_encoder_configuration.output[index].output_name);
+	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
+		len = VID_ENC_NAME_MAX_CHARS - 1;
+	strncpy(output, logicpd_encoder_configuration.output[index].output_name,
+		len);
+	output[len] = '\0';
+	printk(KERN_DEBUG "</logicpd_encoder_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information in the output. */
+static int logicpd_encoder_enumoutput(int index, char *output,
+				      struct vid_encoder_device *enc)
+{
+	int err = 0;
+
+	printk(KERN_DEBUG "<logicpd_encoder_enumoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= logicpd_encoder_configuration.no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		logicpd_encoder_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	printk(KERN_DEBUG "</logicpd_encoder_enumoutput>\n");
+	return err;
+}
+
+/* This function used to initialize the LogicPD encoder driver */
+static int logicpd_encoder_init(void)
+{
+	int err = 0;
+
+	err = vid_enc_register_encoder(&logicpd_encoder_dev);
+	printk(KERN_NOTICE "LogicPD encoder initialized\n");
+	return err;
+}
+
+/* Function used to cleanup LogicPD encoder driver */
+static void logicpd_encoder_cleanup(void)
+{
+	vid_enc_unregister_encoder(&logicpd_encoder_dev);
+}
+
+subsys_initcall(logicpd_encoder_init);
+module_exit(logicpd_encoder_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/Makefile
@@ -0,0 +1,41 @@
+#
+# Makefile for the davinci video device drivers.
+#
+
+# Capture: DaVinci and DM355
+obj-$(CONFIG_ARCH_DAVINCI_DM644x) += ccdc_davinci.o
+obj-$(CONFIG_ARCH_DAVINCI_DM355) += ccdc_dm355.o
+obj-$(CONFIG_VIDEO_TVP5146) += tvp5146.o
+obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
+obj-$(CONFIG_VIDEO_DAVINCI_CAPTURE) += davinci_vpfe.o
+obj-$(CONFIG_DAVINCI_OSD) += davinci_osd.o davinci_platform.o
+
+# Encoder Manager and Encoders
+obj-$(CONFIG_DAVINCI_ENC_MNGR)	+= davinci_enc_mngr.o
+obj-$(CONFIG_DAVINCI_VPBE_ENCODER)	+= vpbe_encoder.o
+obj-$(CONFIG_DAVINCI_LOGICPD_ENCODER) += logicpd_encoder.o
+obj-$(CONFIG_DAVINCI_THS8200_ENCODER) += ths8200_encoder.o
+
+obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY) += davinci_display.o
+
+# DaVinci HD
+obj-$(CONFIG_VIDEO_DAVINCIHD_VPIF) += vpif.o davincihd_platform.o
+obj-$(CONFIG_CAPTURE_DAVINCIHD) += davincihd_capture.o
+obj-$(CONFIG_VIDEO_TVP5147) += tvp5147.o
+obj-$(CONFIG_VIDEO_TVP7002) += tvp7002.o
+
+obj-$(CONFIG_DISPLAY_DAVINCIHD) += davincihd_display.o
+obj-$(CONFIG_VIDEO_ADV7343) += adv7343.o
+
+# H3A and IPIPE
+davinci_aew_driver-objs := davinci_aew_hw.o davinci_aew.o
+obj-$(CONFIG_AEW) += davinci_aew_driver.o
+davinci_af_driver-objs := davinci_af_hw.o davinci_af.o
+obj-$(CONFIG_AF) += davinci_af_driver.o
+
+dm355_ipipe_driver-objs := dm355_ipipe.o dm355_ipipe_hw.o
+obj-$(CONFIG_DM355_IPIPE) += dm355_ipipe_driver.o
+dm355_af_driver-objs := dm355_af_hw.o dm355_af.o
+obj-$(CONFIG_DM355_AF) += dm355_af_driver.o
+dm355_aew_driver-objs := dm355_aew_hw.o dm355_aew.o
+obj-$(CONFIG_DM355_AEW) += dm355_aew_driver.o
Index: linux-2.6.10/drivers/media/video/davinci/ths8200_encoder.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/ths8200_encoder.c
@@ -0,0 +1,810 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ths8200_encoder.c */
+
+/* Kernel Specific header files */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <media/davinci/ths8200_encoder.h>
+
+/* Function prototypes */
+static int ths8200_initialize(struct vid_encoder_device *enc, int flag);
+static int ths8200_deinitialize(struct vid_encoder_device *enc);
+
+static int ths8200_setmode(struct vid_enc_mode_info *mode_info,
+			   struct vid_encoder_device *enc);
+static int ths8200_getmode(struct vid_enc_mode_info *mode_info,
+			   struct vid_encoder_device *enc);
+
+static int ths8200_setoutput(char *output, struct vid_encoder_device *enc);
+static int ths8200_getoutput(char *output, struct vid_encoder_device *enc);
+static int ths8200_enumoutput(int index,
+			      char *output, struct vid_encoder_device *enc);
+
+static int ths8200_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int ths8200_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+
+/* i2c function prototypes */
+static int ths8200_i2c_attach_client(struct i2c_client *,
+				     struct i2c_driver *,
+				     struct i2c_adapter *, int);
+static int ths8200_i2c_detach_client(struct i2c_client *);
+static int ths8200_i2c_probe_adapter(struct i2c_adapter *);
+static int ths8200_init(void);
+static void ths8200_cleanup(void);
+static int ths8200_soft_reset(struct vid_encoder_device *enc);
+static int ths8200_encoder_enable(int flag, struct vid_encoder_device *enc);
+
+static struct vid_enc_mode_info
+    ths8200_component_standards[THS8200_COMPONENT_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_720P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,	/* TBD */
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {60, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,	/* TBD */
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30, 1},
+	 .left_margin = 200,
+	 .right_margin = 80,
+	 .upper_margin = 13,
+	 .lower_margin = 31,
+	 .hsync_len = 88,
+	 .vsync_len = 5,
+	 .flags = 0},
+};
+
+#define THS8200_MAX_REGISTERS 40
+static struct ths8200_std_info
+    ths8200_component_std_info[THS8200_COMPONENT_NUM_STD][THS8200_MAX_REGISTERS]
+    = {
+	{
+	 {THS8200_DTG2_CNTL, THS8200_DTG2_CNTL_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_A, THS8200_DTG1_SPEC_A_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_B, THS8200_DTG1_SPEC_B_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_C, THS8200_DTG1_SPEC_C_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_D_LSB, THS8200_DTG1_SPEC_D_LSB_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_E_LSB, THS8200_DTG1_SPEC_E_LSB_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_DEH_MSB, THS8200_DTG1_SPEC_DEH_MSB_720P_DEFAULT},
+	 {THS8200_DTG1_SPEC_K_LSB, THS8200_DTG1_SPEC_K_LSB_720P_DEFAULT},
+	 {THS8200_DTG1_TOT_PIXELS_MSB,
+	  THS8200_DTG1_TOT_PIXELS_MSB_720P_DEFAULT},
+	 {THS8200_DTG1_TOT_PIXELS_LSB,
+	  THS8200_DTG1_TOT_PIXELS_LSB_720P_DEFAULT},
+	 {THS8200_DTG1_MODE, THS8200_DTG1_MODE_720P_DEFAULT},
+	 {THS8200_DTG1_FRAME_FIELD_SZ_MSB,
+	  THS8200_DTG1_FRAME_FIELD_SZ_MSB_720P_DEFAULT},
+	 {THS8200_DTG1_FRAME_SZ_LSB, THS8200_DTG1_FRAME_SZ_LSB_720P_DEFAULT},
+	 {THS8200_DTG1_FIELD_SZ_LSB, THS8200_DTG1_FIELD_SZ_LSB_720P_DEFAULT},
+	 {THS8200_DTG2_HS_IN_DLY_LSB, THS8200_DTG2_HS_IN_DLY_LSB_720P_DEFAULT},
+	 {THS8200_DTG2_VS_IN_DLY_MSB, THS8200_DTG2_VS_IN_DLY_MSB_720P_DEFAULT},
+	 {THS8200_DTG2_VS_IN_DLY_LSB, THS8200_DTG2_VS_IN_DLY_LSB_720P_DEFAULT},
+	 {0, 0},
+	 },
+	{
+	 {THS8200_TST_CNTL1, THS8200_TST_CNTL1_1080I_DEFAULT},
+	 {THS8200_TST_CNTL2, THS8200_TST_CNTL2_1080I_DEFAULT},
+	 {THS8200_CSM_GY_CNTL_MULT_MSB,
+	  THS8200_CSM_GY_CNTL_MULT_MSB_1080I_DEFAULT},
+	 {THS8200_DTG2_CNTL, THS8200_DTG2_CNTL_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_A, THS8200_DTG1_SPEC_A_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_B, THS8200_DTG1_SPEC_B_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_C, THS8200_DTG1_SPEC_C_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_D1, THS8200_DTG1_SPEC_D1_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_D_LSB, THS8200_DTG1_SPEC_D_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_E_LSB, THS8200_DTG1_SPEC_E_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_DEH_MSB, THS8200_DTG1_SPEC_DEH_MSB_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_K_LSB, THS8200_DTG1_SPEC_K_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_G_LSB, THS8200_DTG1_SPEC_G_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_SPEC_G_MSB, THS8200_DTG1_SPEC_G_MSB_1080I_DEFAULT},
+	 {THS8200_DTG1_TOT_PIXELS_MSB,
+	  THS8200_DTG1_TOT_PIXELS_MSB_1080I_DEFAULT},
+	 {THS8200_DTG1_TOT_PIXELS_LSB,
+	  THS8200_DTG1_TOT_PIXELS_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_MODE, THS8200_DTG1_MODE_1080I_DEFAULT},
+	 {THS8200_DTG1_FRAME_FIELD_SZ_MSB,
+	  THS8200_DTG1_FRAME_FIELD_SZ_MSB_1080I_DEFAULT},
+	 {THS8200_DTG1_FRAME_SZ_LSB, THS8200_DTG1_FRAME_SZ_LSB_1080I_DEFAULT},
+	 {THS8200_DTG1_FIELD_SZ_LSB, THS8200_DTG1_FIELD_SZ_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_HLENGTH_LSB, THS8200_DTG2_HLENGTH_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_HLENGTH_LSB_HDLY_MSB,
+	  THS8200_DTG2_HLENGTH_LSB_HDLY_MSB_1080I_DEFAULT},
+	 {THS8200_DTG2_HLENGTH_HDLY_LSB,
+	  THS8200_DTG2_HLENGTH_HDLY_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VLENGTH1_LSB, THS8200_DTG2_VLENGTH1_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB,
+	  THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VDLY1_LSB, THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VLENGTH2_LSB, THS8200_DTG2_VLENGTH2_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VDLY2_LSB, THS8200_DTG2_VDLY2_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB,
+	  THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VDLY1_LSB, THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_HS_IN_DLY_LSB, THS8200_DTG2_HS_IN_DLY_LSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VS_IN_DLY_MSB, THS8200_DTG2_VS_IN_DLY_MSB_1080I_DEFAULT},
+	 {THS8200_DTG2_VS_IN_DLY_LSB, THS8200_DTG2_VS_IN_DLY_LSB_1080I_DEFAULT},
+	 {0, 0}
+	 }
+};
+
+static struct ths8200_config ths8200_configuration = {
+	.no_of_outputs = THS8200_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_COMPONENT1,
+		      .no_of_standard = THS8200_COMPONENT_NUM_STD,
+		      .standards = {VID_ENC_STD_720P_30, VID_ENC_STD_1080I_30},
+		      .std_info = (struct ths8200_std_info *)
+		      &ths8200_component_std_info,
+		      },
+};
+
+static struct ths8200_channel ths8200_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_720P_30,
+	.i2c_dev.clients[0] = {
+			       .i2c_addr = THS8200_I2C_ADDR},
+	.i2c_dev.clients[1] = {
+			       .i2c_addr = CDCE_I2C_ADDR},
+	.i2c_dev.clients[2] = {
+			       .i2c_addr = THS7303_I2C_ADDR0},
+	.i2c_dev.i2c_registration = 0,
+	.enc_device = NULL
+};
+
+/* Global variables */
+static struct device *ths8200_i2c_dev;
+
+static struct vid_enc_output_ops ths8200_outputs_ops = {
+	.count = THS8200_MAX_NO_OUTPUTS,
+	.enumoutput = ths8200_enumoutput,
+	.setoutput = ths8200_setoutput,
+	.getoutput = ths8200_getoutput
+};
+static struct vid_enc_mode_ops ths8200_modes_ops = {
+	.setmode = ths8200_setmode,
+	.getmode = ths8200_getmode,
+};
+
+static struct vid_enc_misc_ops ths8200_miscs_ops = {
+	.reset = ths8200_soft_reset,
+	.enable = ths8200_encoder_enable,
+};
+
+static struct vid_encoder_device ths8200_dev = {
+	.name = "THS8200_ENCODER",
+	.channel_id = 0,
+	.capabilities = 0,
+	.initialize = ths8200_initialize,
+	.mode_ops = &ths8200_modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &ths8200_outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = &ths8200_miscs_ops,
+	.deinitialize = ths8200_deinitialize
+};
+
+static int ths8200_encoder_enable(int flag, struct vid_encoder_device *enc)
+{
+
+	struct i2c_client *client;
+	int err = 0;
+	u8 val;
+
+	client = &ths8200_channel_info.i2c_dev.clients[THS8200].client;
+	err |= ths8200_i2c_read_reg(client, THS8200_CHIP_CTL, &val);
+	if (err < 0) {
+		dev_err(ths8200_i2c_dev,
+			"Error reading i2c register 0x%x\n", THS8200_CHIP_CTL);
+		return -1;
+	}
+	if (flag) {
+		/* power down the dac */
+		val = (val & 0xf7);
+		err |= ths8200_i2c_write_reg(client, THS8200_CHIP_CTL, val);
+	} else {
+		val |= 0x8;
+		err |= ths8200_i2c_write_reg(client, THS8200_CHIP_CTL, val);
+	}
+	if (err < 0) {
+		dev_err(ths8200_i2c_dev, "Error in writing to register 0x%x\n",
+			THS8200_CHIP_CTL);
+		return -1;
+	}
+	return 0;
+}
+
+static int ths8200_soft_reset(struct vid_encoder_device *enc)
+{
+
+	struct i2c_client *client;
+	int err = 0;
+	u8 val;
+
+	client = &ths8200_channel_info.i2c_dev.clients[THS8200].client;
+	err |= ths8200_i2c_read_reg(client, THS8200_CHIP_CTL, &val);
+	dev_info(ths8200_i2c_dev, "Resetting THS8200 card\n");
+	/* reset consists of toggling the reset bit from low to high */
+
+	val &= 0xfe;
+	err |= ths8200_i2c_write_reg(&ths8200_channel_info.i2c_dev.
+				     clients[THS8200].client, THS8200_CHIP_CTL,
+				     val);
+	val |= 0x1;
+	err |= ths8200_i2c_write_reg(&ths8200_channel_info.i2c_dev.
+				     clients[THS8200].client, THS8200_CHIP_CTL,
+				     val);
+
+	return err;
+}
+
+/* This function is called by the vpif driver to initialize ADV7343 driver.
+ * It initializes all registers of ths8200 with the default values
+ */
+static int ths8200_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0;
+	char *std, *output;
+	int outindex;
+	struct i2c_client *ch_client;
+
+	dev_dbg(ths8200_i2c_dev, "ths8200_initialize\n");
+	if (NULL == enc) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* Register THS8200 I2C client */
+	err = i2c_add_driver(&ths8200_channel_info.i2c_dev.driver);
+	if (err) {
+		dev_err(ths8200_i2c_dev,
+			"Failed to register THS8200 I2C client.\n");
+		return -EINVAL;
+	}
+	ths8200_channel_info.i2c_dev.i2c_registration |= 1;
+	ths8200_channel_info.enc_device = (struct encoder_device *)enc;
+
+	dev_dbg(ths8200_i2c_dev, "THS8200 driver registered\n");
+
+	/* Following sets default values to the THS8200 registers */
+	err = ths8200_soft_reset(enc);
+
+	/* Program the clock to output 74.25MHz to VPBE ext clock in */
+	ch_client =
+	    &ths8200_channel_info.i2c_dev.clients[CDCE_CLK_SYNTH].client;
+	err |= ths8200_i2c_write_reg(ch_client, 0x16, 0x4);
+	err |= ths8200_i2c_write_reg(ch_client, 0x03, 2);
+	err |= ths8200_i2c_write_reg(ch_client, 0x18, 2);
+	err |= ths8200_i2c_write_reg(ch_client, 0x19, 0xc0);
+	err |= ths8200_i2c_write_reg(ch_client, 0x1a, 2);
+	err |= ths8200_i2c_write_reg(ch_client, 0x1b, 0xc8);
+	err |= ths8200_i2c_write_reg(ch_client, 0x14, 0x6f);
+	if (err < 0) {
+		err = -EINVAL;
+		dev_err(ths8200_i2c_dev,
+			"Failed to Program CDCE Clock Synthesiser\n");
+		ths8200_deinitialize(enc);
+		return -EINVAL;
+	}
+
+	msleep(2000);
+
+	ch_client =
+	    &ths8200_channel_info.i2c_dev.clients[THS7303_VIDEO_BUFFER].client;
+
+	/* Configure the 7303 video buffer to enable output with HD LPF */
+	err |=
+	    ths8200_i2c_write_reg(ch_client, THS7303_CHANNEL_1,
+				  THS7303_DEFAULT_CHANNEL_VAL);
+	err |=
+	    ths8200_i2c_write_reg(ch_client, THS7303_CHANNEL_2,
+				  THS7303_DEFAULT_CHANNEL_VAL);
+	err |=
+	    ths8200_i2c_write_reg(ch_client, THS7303_CHANNEL_3,
+				  THS7303_DEFAULT_CHANNEL_VAL);
+
+	if (err < 0) {
+		err = -EINVAL;
+		dev_err(ths8200_i2c_dev, "Error in init code, quitting...\n");
+		ths8200_deinitialize(enc);
+		return err;
+	} else {
+		/* Configure for default video standard */
+		/* call set standard */
+		std = ths8200_channel_info.params.mode;
+		outindex = ths8200_channel_info.params.outindex;
+		output = ths8200_configuration.output[outindex].output_name;
+		err |= ths8200_setoutput(output, enc);
+		if (err < 0) {
+			dev_err(ths8200_i2c_dev,
+				"Error in init code, quitting...\n");
+			err = -EINVAL;
+			ths8200_deinitialize(enc);
+			return err;
+		}
+	}
+	dev_dbg(ths8200_i2c_dev, "ths8200 initialized ...\n");
+	ths8200_channel_info.i2c_dev.i2c_registration |= 2;
+	dev_dbg(ths8200_i2c_dev, "</ths8200_initialize>\n");
+	return err;
+}
+
+static int ths8200_deinitialize(struct vid_encoder_device *enc)
+{
+	int i;
+	if (NULL == enc) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(ths8200_i2c_dev, "ths8200 ch deinitialization \
+		 called\n");
+
+	if (ths8200_channel_info.i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&ths8200_channel_info.i2c_dev.driver);
+		for (i = 0; i < THS8200_MAX_I2C_DEVICES; i++) {
+			ths8200_channel_info.i2c_dev.clients[i].client.adapter =
+			    NULL;
+		}
+		ths8200_channel_info.i2c_dev.i2c_registration &= ~(0x01);
+		ths8200_channel_info.enc_device = NULL;
+	}
+	return 0;
+}
+
+/* Following function is used to set the standard */
+static int ths8200_setmode(struct vid_enc_mode_info *mode_info,
+			   struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i, std_index;
+	struct i2c_client *ch_client;
+	char *mode;
+	u8 reg, val;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	mode = mode_info->name;
+	if (NULL == mode) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(ths8200_i2c_dev, "<ths8200_setmode>\n");
+	ch_client = &ths8200_channel_info.i2c_dev.clients[THS8200].client;
+	dev_dbg(ths8200_i2c_dev, "Start of ths8200_setmode..\n");
+	outindex = ths8200_channel_info.params.outindex;
+
+	if (mode_info->std) {
+
+		char *mymode = NULL;
+		for (std_index = 0;
+		     std_index <
+		     ths8200_configuration.output[outindex].no_of_standard;
+		     std_index++) {
+			if (!strcmp
+			    (ths8200_configuration.output[outindex].
+			     standards[std_index], mode)) {
+				mymode =
+				    ths8200_configuration.output[outindex].
+				    standards[std_index];
+				break;
+			}
+		}
+		if ((std_index ==
+		     ths8200_configuration.output[outindex].no_of_standard)
+		    || (NULL == mymode)) {
+			dev_err(ths8200_i2c_dev, "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of ths8200 encoder */
+		ths8200_channel_info.params.mode = mymode;
+		dev_dbg(ths8200_i2c_dev, "Setting mode to  = %s\n",
+			mode_info->name);
+		ths8200_soft_reset(enc);
+
+		for (i = THS8200_CSC_R11; i <= THS8200_CSC_OFFS3; i++) {
+			/* reset color space conversion registers */
+			err |= ths8200_i2c_write_reg(ch_client, i, 0x0);
+		}
+
+		/* CSC bypassed and Under overflow protection ON */
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_CSC_OFFS3,
+					     ((THS8200_CSC_BYPASS <<
+					       THS8200_CSC_BYPASS_SHIFT) |
+					      THS8200_CSC_UOF_CNTL));
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DATA_CNTL,
+					     THS8200_DATA_CNTL_MODE_20BIT_YCBCR);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_Y_SYNC1_LSB,
+					     THS8200_DTG1_CBCR_SYNC1_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_Y_SYNC2_LSB,
+					     THS8200_DTG1_Y_SYNC2_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_Y_SYNC3_LSB,
+					     THS8200_DTG1_Y_SYNC3_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_CBCR_SYNC1_LSB,
+					     THS8200_DTG1_CBCR_SYNC1_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_CBCR_SYNC2_LSB,
+					     THS8200_DTG1_CBCR_SYNC2_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_CBCR_SYNC3_LSB,
+					     THS8200_DTG1_CBCR_SYNC3_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_Y_SYNC_MSB,
+					     THS8200_DTG1_Y_SYNC_MSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_CBCR_SYNC_MSB,
+					     THS8200_DTG1_CBCR_SYNC_MSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_SPEC_H_LSB,
+					     THS8200_DTG1_SPEC_H_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_SPEC_K_MSB,
+					     THS8200_DTG1_SPEC_K_MSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_FLD_FLIP_LINECNT_MSB,
+					     THS8200_DTG1_FLD_FLIP_LINECNT_MSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG1_LINECNT_LSB,
+					     THS8200_DTG1_LINECNT_LSB_DEFAULT);
+
+		err |= ths8200_i2c_write_reg(ch_client,
+					     THS8200_DTG2_HS_IN_DLY_MSB,
+					     THS8200_DTG2_HS_IN_DLY_MSB_DEFAULT);
+
+		i = 0;
+
+		do {
+			reg = ths8200_component_std_info[std_index][i].reg;
+			val = ths8200_component_std_info[std_index][i].val;
+			if (!reg)
+				break;
+
+			err |= ths8200_i2c_write_reg(ch_client, reg, val);
+
+			if (err < 0) {
+				dev_err(ths8200_i2c_dev,
+					"Set mode i2c write error\n");
+				break;
+			}
+			i++;
+		}
+		while (i < THS8200_MAX_REGISTERS);
+
+		if (err < 0) {
+			dev_err(ths8200_i2c_dev, "Set standard failed\n");
+			return err;
+		}
+		ths8200_soft_reset(enc);
+	} else {
+		/* Non-standard mode not supported */
+		return -1;
+	}
+	dev_dbg(ths8200_i2c_dev, "</ths8200_setmode>\n");
+	return 0;
+}
+
+static struct vid_enc_mode_info *ths8200_get_modeinfo(char *mode_name)
+{
+	int i;
+	for (i = 0; i < THS8200_MAX_NUM_STD; i++) {
+		if (!strcmp(ths8200_configuration.output[0].standards[i],
+			    mode_name)) {
+			return &ths8200_component_standards[i];
+		}
+	}
+	return NULL;
+}
+
+/* Following function is used to get currently selected mode .*/
+static int ths8200_getmode(struct vid_enc_mode_info *mode_info,
+			   struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(ths8200_i2c_dev, "<ths8200_getmode>\n");
+	my_mode_info = ths8200_get_modeinfo(ths8200_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		dev_err(ths8200_i2c_dev,
+			"NULL Pointer for current mode info\n");
+		return -EINVAL;
+	}
+	memcpy(mode_info, my_mode_info, sizeof(struct vid_enc_mode_info));
+	dev_dbg(ths8200_i2c_dev, "</ths8200_getmode>\n");
+	return err;
+}
+
+/* Following function is used to set output format in ths8200 device. The index
+   of the output format is  passed as the argument to this function. */
+static int ths8200_setoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+
+	if ((NULL == enc) || (NULL == output)) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(ths8200_i2c_dev, "<ths8200_setoutput>\n");
+	if (strcmp(output, ths8200_configuration.output[0].output_name)) {
+		dev_err(ths8200_i2c_dev, "No matching output: %s\n", output);
+		return -EINVAL;
+	}
+	ths8200_channel_info.params.mode
+	    = ths8200_configuration.output[0].standards[0];
+
+	my_mode_info = ths8200_get_modeinfo(ths8200_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		dev_err(ths8200_i2c_dev, "No matching mode_info entry found\n");
+		return -EINVAL;
+	}
+	err |= ths8200_setmode(my_mode_info, enc);
+	if (err < 0) {
+		dev_err(ths8200_i2c_dev, "Erron in setting default mode\n");
+		return err;
+	}
+	dev_dbg(ths8200_i2c_dev, "</ths8200_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get index of the output currently selected.*/
+static int ths8200_getoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	if ((NULL == enc) || (NULL == output)) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(ths8200_i2c_dev, "<ths8200_getoutput>\n");
+	strcpy(output, ths8200_configuration.output[0].output_name);
+	dev_dbg(ths8200_i2c_dev, "</ths8200_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information about the output in the outp. */
+static int ths8200_enumoutput(int index, char *output,
+			      struct vid_encoder_device *enc)
+{
+	int err = 0;
+	if ((NULL == enc) || (NULL == output)) {
+		dev_err(ths8200_i2c_dev, "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= ths8200_configuration.no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		ths8200_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	return err;
+}
+
+/* This function is used to read value from register using i2c client. */
+static int ths8200_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		if (client->addr == CDCE_I2C_ADDR) {
+			data[0] = (reg | 0x80);
+		} else
+			data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+	if (err < 0)
+		dev_err(ths8200_i2c_dev, "i2c read error\n");
+	return err;
+}
+
+/*This function is used to write value into register using i2c client. */
+static int ths8200_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	u8 read_val;
+
+	dev_dbg(ths8200_i2c_dev,
+		"ths8200_i2c_write_reg, reg = %x, val = %x\n", reg, val);
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		if (client->addr == CDCE_I2C_ADDR) {
+			data[0] = (reg | 0x80);
+		} else
+			data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+
+		if (err >= 0) {
+			ths8200_i2c_read_reg(client, reg, &read_val);
+
+			if (read_val != val) {
+				dev_err(ths8200_i2c_dev,
+					"i2c write verification failed\n");
+				return -1;
+			}
+		}
+
+		if (err < 0) {
+			dev_err(ths8200_i2c_dev, "i2c write error = %x\n", err);
+			return err;
+		}
+	}
+	return err;
+}
+
+/* This function is used to attach i2c client */
+static int ths8200_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* This function is used to detach i2c client */
+static int ths8200_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+static int ths8200_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	int i;
+	ths8200_i2c_dev = &(adap->dev);
+	dev_dbg(ths8200_i2c_dev, "THS8200 i2c probe adapter called...\n");
+	/* Attach the clients */
+	for (i = 0; i < THS8200_MAX_I2C_DEVICES; i++) {
+		err |=
+		    ths8200_i2c_attach_client(&ths8200_channel_info.i2c_dev.
+					      clients[i].client,
+					      &ths8200_channel_info.i2c_dev.
+					      driver, adap,
+					      ths8200_channel_info.i2c_dev.
+					      clients[i].i2c_addr);
+	}
+	dev_info(ths8200_i2c_dev, "THS8200 encoder initialized\n");
+	return err;
+}
+
+/* This function used to initialize the i2c driver */
+static int ths8200_init(void)
+{
+	int err = 0;
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+	driver = &ths8200_channel_info.i2c_dev.driver;
+	driver->owner = THIS_MODULE;
+	strcpy(driver->name, "THS8200 encoder I2C driver");
+	driver->id = I2C_DRIVERID_EXP0;
+	driver->flags = I2C_DF_NOTIFY;
+	driver->attach_adapter = ths8200_i2c_probe_adapter;
+	driver->detach_client = ths8200_i2c_detach_client;
+	err |= vid_enc_register_encoder(&ths8200_dev);
+	if (err < 0) {
+		vid_enc_unregister_encoder(&ths8200_dev);
+		return err;
+	}
+	return err;
+}
+
+/* Function used to cleanup i2c driver */
+static void ths8200_cleanup(void)
+{
+	int j;
+	if (ths8200_channel_info.i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&ths8200_channel_info.i2c_dev.driver);
+		for (j = 0; j < THS8200_MAX_I2C_DEVICES; j++) {
+			ths8200_channel_info.i2c_dev.clients[j].client.adapter =
+			    NULL;
+		}
+		ths8200_channel_info.i2c_dev.i2c_registration = 0;
+		vid_enc_unregister_encoder(&ths8200_dev);
+	}
+}
+
+subsys_initcall(ths8200_init);
+module_exit(ths8200_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/vpbe_encoder.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/vpbe_encoder.c
@@ -0,0 +1,660 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpbe_encoder.c.. For internal encoder of the VPBE */
+
+/* Kernel Specific header files */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/vpbe_encoder.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu.h>
+
+struct vpbe_encoder_params {
+	int outindex;
+	char *mode;
+};
+
+struct vpbe_encoder_config {
+	unsigned long vencregs;
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		char *standards[VPBE_ENCODER_MAX_NUM_STD];
+	} output[VPBE_ENCODER_MAX_NO_OUTPUTS];
+};
+
+struct vpbe_encoder_channel {
+	struct encoder_device *enc_device;
+	struct vpbe_encoder_params params;
+};
+
+/* Function prototypes */
+static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag);
+static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc);
+
+static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc);
+static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc);
+
+static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc);
+static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc);
+
+static int vpbe_encoder_enumoutput(int index,
+				   char *output,
+				   struct vid_encoder_device *enc);
+
+static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc);
+
+/* All Supported encoder modes */
+static struct vid_enc_mode_info vpbe_encoder_modes[VPBE_ENCODER_MAX_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0x88,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0x88,
+	 .right_margin = 0,
+	 .upper_margin = 0x18,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_NTSC_RGB,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL_RGB,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_480P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {60, 1},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_576P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {50, 1},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0}
+};
+
+static struct vpbe_encoder_config vpbe_encoder_configuration = {
+	.vencregs = DM644X_VENC_REG_BASE,
+	.no_of_outputs = VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_COMPOSITE,
+		      .no_of_standard = VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
+		      },
+	.output[1] = {
+		      .output_name = VID_ENC_OUTPUT_SVIDEO,
+		      .no_of_standard = VPBE_DM644X_ENCODER_SVIDEO_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
+		      },
+	.output[2] = {
+		      .output_name = VID_ENC_OUTPUT_COMPONENT,
+		      .no_of_standard = VPBE_DM644X_ENCODER_COMPONENT_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC,
+				    VID_ENC_STD_PAL,
+				    VID_ENC_STD_NTSC_RGB,
+				    VID_ENC_STD_PAL_RGB,
+				    VID_ENC_STD_480P_60,
+				    VID_ENC_STD_576P_50},
+		      }
+};
+
+static struct vpbe_encoder_channel vpbe_encoder_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_NTSC,
+	.enc_device = NULL
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = VPBE_ENCODER_MAX_NO_OUTPUTS,
+	.enumoutput = vpbe_encoder_enumoutput,
+	.setoutput = vpbe_encoder_setoutput,
+	.getoutput = vpbe_encoder_getoutput
+};
+
+static struct vid_enc_mode_ops modes_ops = {
+	.setmode = vpbe_encoder_setmode,
+	.getmode = vpbe_encoder_getmode,
+};
+
+static struct vid_enc_misc_ops miscs_ops = {
+	.reset = NULL,
+	.enable = vpbe_encoder_enable,
+};
+
+static struct vid_encoder_device vpbe_encoder_dev = {
+	.name = "VPBE_ENCODER",
+	.capabilities = 0,
+	.initialize = vpbe_encoder_initialize,
+	.mode_ops = &modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = &miscs_ops,
+	.deinitialize = vpbe_encoder_deinitialize,
+};
+
+/*
+ * display controller register I/O routines
+ */
+static __inline__ u32 dispc_reg_in(u32 offset)
+{
+	u32 addr;
+	addr = vpbe_encoder_configuration.vencregs + offset;
+	return (davinci_readl(addr));
+}
+static __inline__ u32 dispc_reg_out(u32 offset, u32 val)
+{
+	u32 addr = vpbe_encoder_configuration.vencregs + offset;
+	davinci_writel(val, addr);
+	return (val);
+}
+static __inline__ u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+	addr = vpbe_encoder_configuration.vencregs + offset;
+	new_val = (davinci_readl(addr) & ~mask) | (val & mask);
+	davinci_writel(new_val, addr);
+	return (new_val);
+}
+
+/* Function to enable/disable output */
+static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc)
+{
+	if (flag)
+		dispc_reg_out(VENC_DACTST, 0);
+	else
+		dispc_reg_out(VENC_DACTST, 0xF000);
+	return 0;
+}
+
+/* This function sets the dac of the VPBE for various outputs
+ */
+static int vpbe_encoder_set_dac(char *output)
+{
+	int error = 0;
+	if (cpu_is_davinci_dm644x()) {
+		if (!strcmp(output, VID_ENC_OUTPUT_COMPOSITE)) {
+			printk(KERN_DEBUG "Setting output to Composite\n");
+			dispc_reg_out(VENC_DACSEL, 0);
+		} else if (!strcmp(output, VID_ENC_OUTPUT_SVIDEO)) {
+			printk(KERN_DEBUG "Setting output to S-Video\n");
+			dispc_reg_out(VENC_DACSEL, 0x210);
+		} else if (!strcmp(output, VID_ENC_OUTPUT_COMPONENT)) {
+			printk(KERN_DEBUG
+			       "Setting output to Component Video\n");
+			dispc_reg_out(VENC_DACSEL, 0x543);
+		} else
+			error = -1;
+	} else if (!cpu_is_davinci_dm355())
+		error = -1;
+	return error;
+}
+
+/* This function is called by the encoder manager to initialize vpbe encoder driver.
+ * It initializes all registers of vpbe_encoder with the default values
+ */
+static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0, outindex;
+	char *std, *output;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	vpbe_encoder_channel_info.enc_device = (struct encoder_device *)enc;
+
+	/* call set standard */
+	std = vpbe_encoder_channel_info.params.mode;
+	outindex = vpbe_encoder_channel_info.params.outindex;
+	output = vpbe_encoder_configuration.output[outindex].output_name;
+	err |= vpbe_encoder_setoutput(output, enc);
+	if (err < 0) {
+		err = -EINVAL;
+		printk(KERN_ERR "Error occured in setoutput\n");
+		vpbe_encoder_deinitialize(enc);
+		return err;
+	}
+	printk(KERN_DEBUG "VPBE Encoder initialized\n");
+	return err;
+}
+
+static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc)
+{
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if (cpu_is_davinci_dm644x()) {
+		dispc_reg_out(VENC_DACSEL, 0);
+	}
+
+	/* disable output */
+	dispc_reg_out(VENC_DACTST, 0xF000);
+	dispc_reg_out(VENC_VMOD, 0);
+
+	vpbe_encoder_channel_info.enc_device = NULL;
+	printk(KERN_DEBUG "VPBE Encoder de-initialized\n");
+	return 0;
+}
+
+/* Following function returns ptr to a mode_info structure*/
+static struct vid_enc_mode_info *get_modeinfo(char *mode_name)
+{
+	int i;
+	for (i = 0; i < VPBE_ENCODER_MAX_NUM_STD; i++) {
+		if (!strcmp(vpbe_encoder_modes[i].name, mode_name)) {
+			return &vpbe_encoder_modes[i];
+		}
+	}
+	return NULL;
+}
+
+/* Following function is used to set the mode*/
+static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i, dm6446 = 0;
+	char *mode;
+	struct vid_enc_mode_info *my_mode_info;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (NULL == (mode = mode_info->name)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "Start of vpbe_encoder_setmode..\n");
+	outindex = vpbe_encoder_channel_info.params.outindex;
+	if (cpu_is_davinci_dm644x())
+		dm6446 = 1;
+	else if (!cpu_is_davinci_dm355())
+		return -EINVAL;
+
+	if (mode_info->std) {
+		char *mymode = NULL;
+		/* This is a standard mode */
+		for (i = 0;
+		     i <
+		     vpbe_encoder_configuration.output[outindex].no_of_standard;
+		     i++) {
+			if (!strcmp
+			    (vpbe_encoder_configuration.output[outindex].
+			     standards[i], mode)) {
+				mymode =
+				    vpbe_encoder_configuration.output[outindex].
+				    standards[i];
+				break;
+			}
+		}
+		if ((i ==
+		     vpbe_encoder_configuration.output[outindex].no_of_standard)
+		    || (NULL == mymode)) {
+			printk(KERN_ERR "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of vpbe_encoder */
+		vpbe_encoder_channel_info.params.mode = mymode;
+		if (!strcmp(mymode, VID_ENC_STD_NTSC)) {
+			/* Setup NTSC */
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+		} else if (!strcmp(mymode, VID_ENC_STD_PAL)) {
+			/* Setup PAL */
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+		} else if (!strcmp(mymode, VID_ENC_STD_NTSC_RGB) && dm6446) {
+			/* Setup for NTSC RGB */
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+			dispc_reg_merge(VENC_CMPNT,
+					(1 << VENC_CMPNT_MRGB_SHIFT),
+					VENC_CMPNT_MRGB);
+		} else if (!strcmp(mymode, VID_ENC_STD_PAL_RGB) && dm6446) {
+			/* Setup for PAL RGB */
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			dispc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+			dispc_reg_merge(VENC_CMPNT,
+					(1 << VENC_CMPNT_MRGB_SHIFT),
+					VENC_CMPNT_MRGB);
+		} else if (!strcmp(mymode, VID_ENC_STD_480P_60) && dm6446) {
+			/* Setup for 480P-60, Progressive NTSC */
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			dispc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			dispc_reg_merge(VENC_VMOD,
+					(HDTV_525P << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+
+		} else if (!strcmp(mymode, VID_ENC_STD_576P_50) && dm6446) {
+			/* Setup for 576P-50, Progressive PAL */
+			dispc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			dispc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			dispc_reg_merge
+			    (VENC_VMOD,
+			     (HDTV_625P << VENC_VMOD_TVTYP_SHIFT),
+			     VENC_VMOD_TVTYP);
+		} else {
+			printk(KERN_ERR "Mode not supported..\n");
+			return -EINVAL;
+		}
+	} else {
+		/* Non- Standard mode. Check if we support it. If so
+		   save the timing info and return */
+		my_mode_info = get_modeinfo(VID_ENC_STD_NON_STANDARD);
+		if (my_mode_info) {
+			/* We support. So save timing info and return success 
+			   interface type is same as what is currently is active
+			 */
+			vpbe_encoder_channel_info.params.mode =
+			    VID_ENC_STD_NON_STANDARD;
+			my_mode_info->std = 0;
+			my_mode_info->interlaced = mode_info->interlaced;
+			my_mode_info->xres = mode_info->xres;
+			my_mode_info->yres = mode_info->yres;
+			my_mode_info->fps = mode_info->fps;
+			my_mode_info->left_margin = mode_info->left_margin;
+			my_mode_info->right_margin = mode_info->right_margin;
+			my_mode_info->upper_margin = mode_info->upper_margin;
+			my_mode_info->lower_margin = mode_info->lower_margin;
+			my_mode_info->hsync_len = mode_info->hsync_len;
+			my_mode_info->vsync_len = mode_info->vsync_len;
+			my_mode_info->flags = mode_info->flags;
+			/* If we need to configure something in the encoder module, we need to
+			   do this here */
+			return 0;
+		}
+		printk(KERN_ERR "Mode not supported..\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</vpbe_encoder_setmode>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected mode.*/
+static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<vpbe_encoder_getmode>\n");
+	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		printk(KERN_ERR "NULL Pointer for current mode info\n");
+		return -EINVAL;
+	}
+	memcpy(mode_info, my_mode_info, sizeof(struct vid_enc_mode_info));
+	printk(KERN_DEBUG "<vpbe_encoder_getmode/>\n");
+	return err;
+}
+
+/* Following function is used to set output format in VPBE DAC. The 
+   output name is  passed as the argument to this function. */
+static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0, index;
+	struct vid_enc_mode_info *my_mode_info;
+	printk(KERN_DEBUG "<vpbe_encoder_setoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output: NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < vpbe_encoder_configuration.no_of_outputs;
+	     index++) {
+		if (!strcmp
+		    (output,
+		     vpbe_encoder_configuration.output[index].output_name)) {
+			break;
+		}
+	}
+
+	if (index == vpbe_encoder_configuration.no_of_outputs) {
+		/* No output matching this name */
+		printk(KERN_ERR "No matching output: %s\n", output);
+		return -EINVAL;
+	}
+
+	if (vpbe_encoder_set_dac(output) < 0) {
+		printk(KERN_ERR
+		       "<vpbe_encoder_setoutput, error in setting DAC config>\n");
+		return -EINVAL;
+	}
+
+	vpbe_encoder_channel_info.params.outindex = index;
+
+	/* set default standard */
+	vpbe_encoder_channel_info.params.mode
+	    = vpbe_encoder_configuration.output[index].standards[0];
+
+	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		printk(KERN_ERR "No matching mode_info entry found\n");
+		return -EINVAL;
+	}
+
+	err |= vpbe_encoder_setmode(my_mode_info, enc);
+	if (err < 0) {
+		printk(KERN_ERR "Erron in setting default mode\n");
+		return err;
+	}
+	printk(KERN_DEBUG "</vpbe_encoder_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get output name of current output.*/
+static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0, index, len;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<vpbe_encoder_getoutput>\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = vpbe_encoder_channel_info.params.outindex;
+	len = strlen(vpbe_encoder_configuration.output[index].output_name);
+	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
+		len = VID_ENC_NAME_MAX_CHARS - 1;
+	strncpy(output, vpbe_encoder_configuration.output[index].output_name,
+		len);
+	output[len] = '\0';
+	printk(KERN_DEBUG "</vpbe_encoder_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information about the output in the output. */
+static int vpbe_encoder_enumoutput(int index, char *output,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0;
+
+	printk(KERN_DEBUG "<vpbe_encoder_enumoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= vpbe_encoder_configuration.no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		vpbe_encoder_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	printk(KERN_DEBUG "</vpbe_encoder_enumoutput>\n");
+	return err;
+}
+
+/* This function used to initialize the vpbe encoder driver */
+static int vpbe_encoder_init(void)
+{
+	int err = 0;
+
+	if (cpu_is_davinci_dm644x()) {
+		/* Do nothing. We have everything setup for DM6446 */
+	} else if (cpu_is_davinci_dm355()) {
+		outputs_ops.count = VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
+		vpbe_encoder_configuration.vencregs = DM355_VENC_REG_BASE;
+		vpbe_encoder_configuration.no_of_outputs =
+		    VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
+		vpbe_encoder_configuration.output[0].no_of_standard =
+		    VPBE_DM355_ENCODER_COMPOSITE_NUM_STD;
+		/* If we have different no of standards for composite in DM355 and DM6446
+		   we need to fill the stanard names as well here. Now both are the same.
+		 */
+	} else
+		return -1;
+
+	err = vid_enc_register_encoder(&vpbe_encoder_dev);
+	printk(KERN_NOTICE "VPBE Encoder Initialized\n");
+	return err;
+}
+
+/* Function used to cleanup vpbe encoder driver */
+static void vpbe_encoder_cleanup(void)
+{
+	vid_enc_unregister_encoder(&vpbe_encoder_dev);
+}
+
+subsys_initcall(vpbe_encoder_init);
+module_exit(vpbe_encoder_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/media/video/Kconfig
+++ linux-2.6.10/drivers/media/video/Kconfig
@@ -7,9 +7,9 @@ menu "Video For Linux"
 
 comment "Video Adapters"
 
-config VIDEO_DAVINCI
+config VIDEO_DAVINCI_CAPTURE
 	tristate "Davinci Video Capture"
-	depends on VIDEO_DEV && ARCH_DAVINCI
+	depends on VIDEO_DEV && (ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355)
 	select VIDEO_BUF
 	select VIDEO_TVP5146
 	select VIDEO_MT9T001
@@ -19,9 +19,22 @@ config VIDEO_DAVINCI
 	  To compile this driver as a module, choose M here: the
 	  module will be called vpfe.
 
+config CAPTURE_DAVINCIHD
+	tristate "DavinciHD Video Capture"
+	depends on VIDEO_DEV && MACH_DAVINCI_HD_EVM
+	select VIDEO_DAVINCIHD_VPIF
+	select VIDEO_BUF
+	select VIDEO_TVP5147
+	select VIDEO_TVP7002
+	help
+	  Support for Davinci based frame grabber through CCDC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpfe.
+
 config VIDEO_TVP5146
         tristate "TVP5146 video decoder"
-        depends on I2C && ARCH_DAVINCI && VIDEO_DAVINCI
+        depends on I2C && ARCH_DAVINCI && VIDEO_DAVINCI_CAPTURE
         help
           Support for I2C bus based TVP5146 configuration.
 
@@ -30,9 +43,143 @@ config VIDEO_TVP5146
 
 config VIDEO_MT9T001
         tristate "MT9T001 Sensor"
-        depends on I2C && ARCH_DAVINCI && VIDEO_DAVINCI
+        depends on I2C && ARCH_DAVINCI && MACH_DAVINCI_EVM && VIDEO_DAVINCI_CAPTURE
         help
           Support for I2C bus based MT9T001 Driver
+	  
+	  To compile this driver as a module, choose M here: the
+	  module will be called mt9t001.
+
+config VIDEO_TVP5147
+	tristate "TVP5147 video decoder"
+	depends on I2C && MACH_DAVINCI_HD_EVM && CAPTURE_DAVINCIHD
+	help
+	  Support for I2C bus based TVP5147 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp5147.
+
+config VIDEO_TVP7002
+	tristate "TVP7002 video decoder"
+	depends on I2C && MACH_DAVINCI_HD_EVM && CAPTURE_DAVINCIHD
+	help
+	  Support for I2C bus based TVP7002 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp7002.
+
+config VIDEO_DAVINCI_DISPLAY
+	tristate "Davinci V4L2 Video Display"
+	depends on VIDEO_DEV && (ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355) && DAVINCI_ENC_MNGR
+	select VIDEO_BUF
+	select DAVINCI_OSD
+	help
+	  V4L2 Display driver support for davinci.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called davinci_display.
+
+config DISPLAY_DAVINCIHD
+	tristate "DavinciHD Video Display"
+	depends on VIDEO_DEV && MACH_DAVINCI_HD_EVM && DAVINCI_ENC_MNGR
+	select VIDEO_DAVINCIHD_VPIF
+	select VIDEO_BUF
+	select VIDEO_ADV7343
+	help
+	  Support for Davinci based frame grabber through CCDC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpfe.
+
+config DAVINCI_ENC_MNGR
+	tristate "Davinci Encoder Manager support"	
+	depends on ARCH_DAVINCI_DM646x || ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355
+	default y
+	help
+	  Enable support for the DaVinci Encoder Manager. This is responsible
+	  for managing output and video/graphics modes for davinci video drivers.
+
+config ENC_MNGR_MAX_CHANNELS
+	int "Max number of channels for Encoder Manager"
+	depends on DAVINCI_ENC_MNGR
+	default "2"
+	help
+	  Used to give max number of channels supported by encoder manager
+	  driver.
+
+config DAVINCI_VPBE_ENCODER	
+	tristate "Davinci VPBE Encoder support"
+	depends on (DAVINCI_ENC_MNGR) && (FB_DAVINCI || VIDEO_DAVINCI_DISPLAY)
+	default y
+	help
+	  Enable support for the DaVinci VPBE internal encoder. DaVinci VPBE
+	  has internal VENC and DAC to output analog SD outputs (composite,
+	  S-Video and Component video outputs). 
+
+config DAVINCI_LOGICPD_ENCODER
+	tristate "Logic PD Encoder support"
+	depends on (DAVINCI_ENC_MNGR && !DAVINCI_PWM) && (FB_DAVINCI || VIDEO_DAVINCI_DISPLAY)
+	default y
+	help
+	  Enable support for the DaVinci VPBE internal encoder. DaVinci VPBE
+	  has internal VENC and DAC to output analog SD outputs (composite,
+	  S-Video and Component video outputs). 
+
+config DAVINCI_THS8200_ENCODER
+	tristate "THS8200 Encoder support"
+	depends on DAVINCI_ENC_MNGR && (FB_DAVINCI || VIDEO_DAVINCI_DISPLAY)
+	default y
+	help
+	  Enable support for THS8200 encoder. This daughter card is used to
+	  output HD resolution outputs:- 720P and 1080i.
+
+
+config VIDEO_ADV7343
+	tristate "ADV7343 video encoder"
+	depends on I2C && MACH_DAVINCI_HD_EVM && DISPLAY_DAVINCIHD && DAVINCI_ENC_MNGR
+	help
+	  Support for I2C bus based ADV7343 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mt9t001.
+
+config VIDEO_DAVINCIHD_VPIF
+	tristate "DavinciHD VPIF Driver"
+	depends on CAPTURE_DAVINCIHD || DISPLAY_DAVINCIHD
+	help
+	  Support for DavinciHD VPIF Driver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpif.
+
+config DAVINCI_OSD 
+	tristate "Davinci Display Manage"
+	depends on VIDEO_DAVINCI_DISPLAY || FB_DAVINCI
+	help
+	  Support for Davinci Display Manager.
+	  
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpif.
+
+config DM355_IPIPE
+	depends on ARCH_DAVINCI && VIDEO_MT9T001 && ARCH_DAVINCI_DM355
+	tristate "DM355 IPIPE"
+	---help---
+		DM3555 IPIPE driver
+
+config DM355_AF
+        tristate "DM355 Auto Focus Driver"
+	depends on ARCH_DAVINCI && VIDEO_DAVINCI_CAPTURE && ARCH_DAVINCI_DM355
+        help
+                DM355 Auto Focus Driver.This may be able to work for Davinci H3A as well,
+		but it is not validated
+
+config DM355_AEW
+        tristate "DM355 Auto exposure /White Balance Driver"
+	depends on ARCH_DAVINCI && VIDEO_DAVINCI_CAPTURE && ARCH_DAVINCI_DM355
+        help
+                DM355 Auto Exposure and Auto White Balancing Driver. This may be able to 
+		work for Davinci H3A as well, but it is not validated
 
 config VIDEO_BT848
 	tristate "BT848 Video For Linux"
@@ -391,7 +538,7 @@ config VIDEO_OMAP_CAMERA
 
 config AF
         tristate "DaVinci Auto Focus Driver"
-        depends on VIDEO_DEV && VIDEO_DAVINCI
+        depends on VIDEO_DEV && VIDEO_DAVINCI_CAPTURE && ARCH_DAVINCI_DM644x
         default n
         help
                 DaVinci Auto Focus Driver
@@ -405,7 +552,7 @@ config VIDEO_MAINSTONE_CAMERA
 
 config AEW
        tristate "DaVinci Auto Exposure/White Balancing Driver"
-       depends on VIDEO_DEV && VIDEO_DAVINCI
+       depends on VIDEO_DEV && VIDEO_DAVINCI_CAPTURE && ARCH_DAVINCI_DM644x
        default n
        help
                DaVinci Auto Exposure/White Balancing Driver
Index: linux-2.6.10/drivers/video/davinci/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/video/davinci/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the TI DaVinci video drivers
+#
+
+obj-$(CONFIG_FB_DAVINCI)		+= davincifb.o
Index: linux-2.6.10/drivers/video/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/video/Kconfig
+++ linux-2.6.10/drivers/video/Kconfig
@@ -1315,11 +1315,12 @@ config FB_XILINX_ROTATE
 
 config FB_DAVINCI
 	tristate "Davinci Framebuffer support"
-	depends on FB && ARCH_DAVINCI
+	depends on FB && (ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355)
+	select DAVINCI_OSD
 	help
 	  This is the frame buffer device driver for the DAVINCI graphics
-	  hardware found on the TI DAVINCI EVM.	 If
-	  unsure, say N.
+	  hardware found on the TI DAVINCI EVM and the TI DAVINCI DM355 EVM.
+	  If unsure, say N.
 
 config FB_INTEL_VR
 	tristate "Intel Vermilion Range framebuffer support"
Index: linux-2.6.10/drivers/video/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/video/Makefile
+++ linux-2.6.10/drivers/video/Makefile
@@ -113,8 +113,8 @@ obj-$(CONFIG_FB_VGA16)            += vga
 	                             cfbimgblt.o vgastate.o
 obj-$(CONFIG_FB_OF)               += offb.o cfbfillrect.o cfbimgblt.o cfbcopyarea.o
 obj-$(CONFIG_FB_OMAP)		   += omap/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
-obj-$(CONFIG_FB_DAVINCI)            += vpbe_davincifb.o 
-vpbe_davincifb-objs            := davincifb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o 
+obj-$(CONFIG_FB_DAVINCI)	  += cfbcopyarea.o cfbfillrect.o cfbimgblt.o
+obj-$(CONFIG_ARCH_DAVINCI)	  += davinci/
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
Index: linux-2.6.10/include/linux/videodev2.h
===================================================================
--- linux-2.6.10.orig/include/linux/videodev2.h
+++ linux-2.6.10/include/linux/videodev2.h
@@ -65,6 +65,12 @@ enum v4l2_buf_type {
 	V4L2_BUF_TYPE_VIDEO_OVERLAY  = 3,
 	V4L2_BUF_TYPE_VBI_CAPTURE    = 4,
 	V4L2_BUF_TYPE_VBI_OUTPUT     = 5,
+#if 1
+	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
+	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
+#endif	
+	V4L2_BUF_TYPE_HBI_CAPTURE    = 8,
+	V4L2_BUF_TYPE_HBI_OUTPUT     = 9,
 	V4L2_BUF_TYPE_PRIVATE        = 0x80,
 };
 
@@ -153,6 +159,8 @@ struct v4l2_capability
 #define V4L2_CAP_VIDEO_OVERLAY	0x00000004  /* Can do video overlay */
 #define V4L2_CAP_VBI_CAPTURE	0x00000010  /* Is a VBI capture device */
 #define V4L2_CAP_VBI_OUTPUT	0x00000020  /* Is a VBI output device */
+#define V4L2_CAP_SLICED_VBI_CAPTURE 0x00000040
+#define V4L2_CAP_SLICED_VBI_OUTPUT  0x00000080
 #define V4L2_CAP_RDS_CAPTURE	0x00000100  /* RDS data capture */
 
 #define V4L2_CAP_TUNER		0x00010000  /* has a tuner */
@@ -162,6 +170,8 @@ struct v4l2_capability
 #define V4L2_CAP_READWRITE      0x01000000  /* read/write systemcalls */
 #define V4L2_CAP_ASYNCIO        0x02000000  /* async I/O */
 #define V4L2_CAP_STREAMING      0x04000000  /* streaming I/O ioctls */
+#define V4L2_CAP_HBI_CAPTURE    0x08000000
+#define V4L2_CAP_HBI_OUTPUT	0x10000000 
 
 /*
  *	V I D E O   I M A G E   F O R M A T
@@ -221,6 +231,8 @@ struct v4l2_pix_format
 #define V4L2_PIX_FMT_WNVA     v4l2_fourcc('W','N','V','A') /* Winnov hw compress */
 #define V4L2_PIX_FMT_SN9C10X  v4l2_fourcc('S','9','1','0') /* SN9C10x compression */
 
+#define V4L2_PIX_FMT_YUV422UVP v4l2_fourcc('Y', '8', 'C', '8')
+
 /*
  *	F O R M A T   E N U M E R A T I O N
  */
@@ -555,6 +567,18 @@ typedef __u64 v4l2_std_id;
 #define V4L2_STD_ALL            (V4L2_STD_525_60	|\
 				 V4L2_STD_625_50)
 
+#define V4L2_STD_720P_60	((v4l2_std_id)(0x0001000000000000ULL))
+#define V4L2_STD_1080I_60	((v4l2_std_id)(0x0002000000000000ULL))
+#define V4L2_STD_1080I_50	((v4l2_std_id)(0x0004000000000000ULL))
+#define V4L2_STD_525P_60	((v4l2_std_id)(0x0008000000000000ULL))
+#define V4L2_STD_625P_50	((v4l2_std_id)(0x0010000000000000ULL))
+#define V4L2_STD_720P_25	((v4l2_std_id)(0x0020000000000000ULL))
+#define V4L2_STD_720P_30	((v4l2_std_id)(0x0040000000000000ULL))
+#define V4L2_STD_720P_50	((v4l2_std_id)(0x0080000000000000ULL))
+#define V4L2_STD_1080P_25	((v4l2_std_id)(0x0100000000000000ULL))
+#define V4L2_STD_1080P_30	((v4l2_std_id)(0x0200000000000000ULL))
+#define V4L2_STD_1080P_24	((v4l2_std_id)(0x0400000000000000ULL))
+
 struct v4l2_standard
 {
 	__u32	       	     index;
@@ -803,6 +827,14 @@ struct v4l2_vbi_format
 
 /*	Stream data format
  */
+ struct v4l2_sliced_vbi_format
+{
+	__u16 service_set;
+	__u16 service_lines[2][24];
+	__u32 io_size;
+	__u32 reserved[2];
+};
+
 struct v4l2_format
 {
 	enum v4l2_buf_type type;
@@ -811,6 +843,7 @@ struct v4l2_format
 		struct v4l2_pix_format	pix;  // V4L2_BUF_TYPE_VIDEO_CAPTURE
 		struct v4l2_window	win;  // V4L2_BUF_TYPE_VIDEO_OVERLAY
 		struct v4l2_vbi_format	vbi;  // V4L2_BUF_TYPE_VBI_CAPTURE
+		struct v4l2_sliced_vbi_format sliced;
 		__u8	raw_data[200];        // user-defined
 	} fmt;
 };
@@ -829,6 +862,26 @@ struct v4l2_streamparm
 	} parm;
 };
 
+#define V4L2_SLICED_CAPTION_525 0x1000
+#define V4L2_SLICED_WSS_625     0x4000
+#define V4L2_SLICED_CGMS_525    0x8000
+
+struct v4l2_sliced_vbi_cap
+{
+	__u16 service_set;
+	__u16 service_lines[2][24];
+	enum v4l2_buf_type type;
+	__u32 reserved[3];
+};
+
+struct v4l2_sliced_vbi_data
+{
+	__u32 id;
+	__u32 field;
+	__u32 line;
+	__u32 reserved;
+	__u8  data[48];
+};
 
 
 /*
@@ -897,6 +950,7 @@ struct v4l2_streamparm
 #define VIDIOC_G_AUDIO_OLD     	_IOWR ('V', 33, struct v4l2_audio)
 #define VIDIOC_G_AUDOUT_OLD    	_IOWR ('V', 49, struct v4l2_audioout)
 #define VIDIOC_CROPCAP_OLD     	_IOR  ('V', 58, struct v4l2_cropcap)
+#define VIDIOC_G_SLICED_VBI_CAP _IOWR ('V', 59, struct v4l2_sliced_vbi_cap)
 
 #define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
 
Index: linux-2.6.10/include/media/davinci/ccdc_dm355.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/ccdc_dm355.h
@@ -0,0 +1,874 @@
+/*
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.h */
+
+#ifndef CCDC_DM355_H
+#define CCDC_DM355_H
+
+#ifdef __KERNEL__
+#include <asm/io.h>
+#endif
+#include <linux/videodev.h>
+
+#ifndef TYPES
+#define TYPES
+typedef unsigned char bool;
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+/* Define to enable/disable video port */
+#define VIDEO_PORT_ENABLE	(1)
+
+typedef enum ccdc_pixfmt {
+	CCDC_PIXFMT_RAW = 0,
+	CCDC_PIXFMT_YCBCR_16BIT = 1,
+	CCDC_PIXFMT_YCBCR_8BIT = 2
+} ccdc_pixfmt;
+
+typedef enum ccdc_frmfmt {
+	CCDC_FRMFMT_PROGRESSIVE = 0,
+	CCDC_FRMFMT_INTERLACED = 1
+} ccdc_frmfmt;
+
+typedef enum ccdc_pinpol {
+	CCDC_PINPOL_POSITIVE = 0,
+	CCDC_PINPOL_NEGATIVE = 1
+} ccdc_pinpol;
+
+/* PIXEL ORDER IN MEMORY from LSB to MSB */
+/* only applicable for 8-bit input mode  */
+typedef enum ccdc_pixorder {
+	CCDC_PIXORDER_CBYCRY = 1,
+	CCDC_PIXORDER_YCBYCR = 0
+} ccdc_pixorder;
+
+typedef enum ccdc_buftype {
+	CCDC_BUFTYPE_FLD_INTERLEAVED,
+	CCDC_BUFTYPE_FLD_SEPARATED
+} ccdc_buftype;
+
+/* enum for No of pixel per line to be avg. in Black Clamping*/
+enum sample_length {
+	_1PIXELS = 0,
+	_2PIXELS,
+	_4PIXELS,
+	_8PIXELS,
+	_16PIXELS
+};
+
+#define FP_NUM_BYTES					(4)
+/* Define for extra pixel/line and extra lines/frame */
+#define NUM_EXTRAPIXELS	    0
+#define NUM_EXTRALINES		0
+
+/* settings for commonly used video formats */
+#define VPFE_WIN_NTSC    {0,0,720,480}
+#define VPFE_WIN_PAL     {0,0,720,576}
+#define VPFE_WIN_NTSC_SP {0,0,640,480}	/* ntsc square pixel */
+#define VPFE_WIN_PAL_SP  {0,0,768,576}	/* pal square pixel */
+#define VPFE_WIN_CIF     {0,0,352,288}
+#define VPFE_WIN_QCIF    {0,0,176,144}
+#define VPFE_WIN_QVGA    {0,0,320,240}
+#define VPFE_WIN_SIF     {0,0,352,240}
+
+#define VPFE_WIN_VGA	{0,0,(640 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_SVGA 	{0,0,(800 + NUM_EXTRAPIXELS),(600 + NUM_EXTRALINES)}
+#define VPFE_WIN_XGA	{0,0,(1024+ NUM_EXTRAPIXELS),(768 + NUM_EXTRALINES)}
+#define VPFE_WIN_480p	{0,0,(720 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_576p	{0,0,(720 + NUM_EXTRAPIXELS),(576 + NUM_EXTRALINES)}
+#define VPFE_WIN_720p 	{0,0,(1280+ NUM_EXTRAPIXELS),(720 + NUM_EXTRALINES)}
+#define VPFE_WIN_1080p 	{0,0,(1920),(1080)}
+
+/* enum for No of lines in Black Clamping */
+enum sample_line {
+	_1LINES = 0,
+	_2LINES,
+	_4LINES,
+	_8LINES,
+	_16LINES
+};
+
+enum hw_frame {
+	CCDC_RAW,
+	CCDC_YCBCR
+};
+
+/* enum for Alaw gama width */
+enum gama_width {
+	BITS_13_4 = 0,
+	BITS_12_3,
+	BITS_11_2,
+	BITS_10_1,
+	BITS_09_0
+};
+
+enum ccdc_datasft {
+	NO_SHIFT = 0,
+	_1BIT,
+	_2BIT,
+	_3BIT,
+	_4BIT,
+	_5BIT,
+	_6BIT
+};
+
+enum data_size {
+	_16BITS = 0,
+	_15BITS,
+	_14BITS,
+	_13BITS,
+	_12BITS,
+	_11BITS,
+	_10BITS,
+	_8BITS
+};
+enum ccdc_mfilt1 {
+	NO_MEDIAN_FILTER1 = 0,
+	AVERAGE_FILTER1,
+	MEDIAN_FILTER1
+};
+
+enum ccdc_mfilt2 {
+	NO_MEDIAN_FILTER2 = 0,
+	AVERAGE_FILTER2,
+	MEDIAN_FILTER2
+};
+
+typedef struct v4l2_rect ccdc_imgwin;
+
+/* structure for ALaw */
+struct a_law {
+	bool b_alaw_enable;	/* Enable/disable A-Law */
+	enum gama_width gama_wd;	/*Gama Width Input */
+};
+
+/* structure for Black Clamping */
+struct black_clamp {
+	bool b_clamp_enable;
+	enum sample_length sample_pixel;	/* only if bClampEnable is TRUE */
+	enum sample_line sample_ln;	/* only if bClampEnable is TRUE */
+	unsigned short start_pixel;	/* only if bClampEnable is TRUE */
+	unsigned short sgain;	/* only if bClampEnable is TRUE */
+	unsigned short dc_sub;	/* only if bClampEnable is FALSE */
+};
+
+/* structure for Black Level Compensation */
+struct black_compensation {
+	char r_comp;		/* Constant value to subtract from Red component */
+	char gr_comp;		/* Constant value to subtract from Gr component */
+	char b_comp;		/* Constant value to subtract from Blue component */
+	char gb_comp;		/* Constant value to subtract from Gb component */
+};
+
+/*structures for lens shading correction*/
+
+/*gain factor modes*/
+typedef enum GfMode {
+	u8q8_interpol = 0,
+	u16q14_interpol,
+	reserved,
+	u16q14
+} GfMode;
+
+typedef enum gf_table_sel {
+	table1 = 0,
+	table2,
+	table3
+} gf_table_sel;
+
+/*LSC configuration structure*/
+typedef struct LscCfg {
+	GfMode gfmode;
+	int gf_table_scaling_fact;
+	int gf_table_interval;
+	gf_table_sel epel;
+	gf_table_sel opel;
+	gf_table_sel epol;
+	gf_table_sel opol;
+} LscCfg;
+
+typedef struct float_ccdc {
+	unsigned int int_no;
+	unsigned int frac_no;
+} float_ccdc;
+
+/*Main structure for lens shading correction*/
+struct lens_shading_corr {
+	bool lsc_enable;
+	LscCfg lsc_config;
+	unsigned int lens_center_horz;
+	unsigned int lens_center_vert;
+	float_ccdc horz_left_coef;
+	float_ccdc horz_right_coef;
+	float_ccdc ver_low_coef;
+	float_ccdc ver_up_coef;
+	float_ccdc gf_table1[256];	/*int_no will be always 0 since it is u8q8 */
+	float_ccdc gf_table2[128];
+	float_ccdc gf_table3[128];
+};
+
+/*structure for color space converter*/
+struct color_space_converter {
+	bool csc_enable;
+	int csc_dec_coeff[16];
+	int csc_frac_coeff[16];
+};
+
+/*supporting structures for data formatter*/
+
+typedef enum FmtMode {
+	split = 0,
+	combine,
+	line_alt_mode
+} FmtMode;
+
+typedef enum LNum {
+	_1line = 0,
+	_2lines,
+	_3lines,
+	_4lines
+} LNum;
+
+typedef enum Line {
+	_1stline = 0,
+	_2ndline,
+	_3rdline,
+	_4thline
+} Line;
+
+typedef struct FmtpLen {
+	unsigned int plen0;
+	unsigned int plen1;
+	unsigned int plen2;
+	unsigned int plen3;
+} FmtpLen_s;
+
+typedef struct FmtCfg {
+	FmtMode fmtmode;
+	LNum lnum;
+	unsigned int addrinc;
+} FmtCfg_s;
+
+typedef struct FmtAddr_Ptr {
+	unsigned int init;
+	Line line;
+} fmtaddr_ptr_s;
+
+typedef struct FmtPgm_AP {
+	unsigned int pgm_aptr;
+	bool pgmupdt;
+} fmtpgm_ap_s;
+
+/*Main Structure for data formatter*/
+struct data_formatter {
+	bool fmt_enable;
+	FmtCfg_s fmtcfg;
+	FmtpLen_s fmtplen;
+	unsigned int fmtsph;
+	unsigned int fmtlnh;
+	unsigned int fmtslv;
+	unsigned int fmtlnv;
+	unsigned int fmtrlen;
+	unsigned int fmthcnt;
+	fmtaddr_ptr_s fmtaddr_ptr[8];
+	bool pgm_en[32];
+	fmtpgm_ap_s fmtpgm_ap[32];
+};
+
+/*Structures for Vertical Defect Correction*/
+typedef enum VdfCsl {
+	normal = 0,
+	horz_interpol_sat,
+	horz_interpol
+} VdfCsl;
+
+typedef enum VdfCuda {
+	whole_line_correct = 0,
+	upper_disable
+} VdfCuda;
+
+typedef enum DfcMwr {
+	write_complete = 0,
+	write_reg
+} DfcMwr;
+
+typedef enum DfcMrd {
+	read_complete = 0,
+	read_reg
+} DfcMrd;
+
+typedef enum DfcMaRst {
+	incr_addr = 0,
+	clr_addr
+} DfcMaRst;
+
+typedef enum DfcmClr {
+	clear_complete = 0,
+	clear
+} DfcmClr;
+
+struct dft_corr_ctl_s {
+	VdfCsl vdfcsl;
+	VdfCuda vdfcuda;
+	unsigned int vdflsft;
+};
+
+struct dft_corr_mem_ctl_s {
+	DfcMwr dfcmwr;
+	DfcMrd dfcmrd;
+	DfcMaRst dfcmarst;
+	DfcmClr dfcmclr;
+};
+
+/*Main Structure for vertical defect correction*/
+/*Vertical defect correction can correct upto 16 defects*/
+/*if defects less than 16 then pad the rest with 0*/
+struct vertical_dft_s {
+	bool ver_dft_en;
+	bool gen_dft_en;
+	unsigned int saturation_ctl;
+	struct dft_corr_ctl_s dft_corr_ctl;
+	struct dft_corr_mem_ctl_s dft_corr_mem_ctl;
+	unsigned int dft_corr_horz[16];
+	unsigned int dft_corr_vert[16];
+	unsigned int dft_corr_sub1[16];
+	unsigned int dft_corr_sub2[16];
+	unsigned int dft_corr_sub3[16];
+};
+
+struct data_offset {
+	unsigned char horz_offset;
+	unsigned char vert_offset;
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode passed 
+ * by application
+ */
+typedef struct ccdc_config_params_raw {
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	ccdc_buftype buf_type;	/* interleaved or separated fields */
+
+	enum ccdc_datasft datasft;	/*data shift to be applied before storing */
+	enum ccdc_mfilt1 mfilt1;	/*median filter for sdram */
+	enum ccdc_mfilt2 mfilt2;	/*median filter for ipipe */
+	bool lpf_enable;	/*low pass filter enable/disable */
+	bool horz_flip_enable;
+	unsigned int ccdc_offset;	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	int med_filt_thres;	/*Threshold of median filter */
+	bool image_invert_enable;	/* enable to store the image in inverse
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct data_offset data_offset_s;	/*horz and vertical data offset */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for
+						   Black Compensation */
+	struct vertical_dft_s vertical_dft;	/*struture for vertical Defect Correction
+						   Module Configuration */
+	struct lens_shading_corr lens_sh_corr;	/*structure for lens shading Correction
+						   Module Configuration */
+	struct data_formatter data_formatter_r;	/*structure for data formatter
+						   Module Configuration */
+	struct color_space_converter color_space_con;	/*structure for color space converter
+							   Module Configuration */
+} ccdc_config_params_raw;
+
+#define VPFE_CMD_CONFIG_CCDC_YCBCR \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 1,ccdc_params_ycbcr)
+#define VPFE_CMD_CONFIG_CCDC_RAW \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 4,ccdc_config_params_raw)
+
+#ifdef __KERNEL__
+
+/* Structure for CCDC configuration parameters for raw capture mode */
+typedef struct ccdc_params_raw {
+
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	ccdc_buftype buf_type;	/* interleaved or separated fields */
+
+	enum ccdc_datasft datasft;	/*data shift to be applied before storing */
+	enum ccdc_mfilt1 mfilt1;	/*median filter for sdram */
+	enum ccdc_mfilt2 mfilt2;	/*median filter for ipipe */
+	bool lpf_enable;	/*low pass filter enable/disable */
+	bool horz_flip_enable;
+	unsigned int ccdc_offset;	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	int med_filt_thres;	/*Threshold of median filter */
+	bool image_invert_enable;	/* enable to store the image in inverse 
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct data_offset data_offset_s;	/*horz and vertical data offset */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for 
+						   Black Compensation */
+	struct vertical_dft_s vertical_dft;	/*struture for vertical Defect Correction 
+						   Module Configuration */
+	struct lens_shading_corr lens_sh_corr;	/*structure for lens shading Correction
+						   Module Configuration */
+	struct data_formatter data_formatter_r;	/*structure for data formatter
+						   Module Configuration */
+	struct color_space_converter color_space_con;	/*structure for color space converter
+							   Module Configuration */
+
+} ccdc_params_raw;
+
+typedef struct ccdc_params_ycbcr {
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	int bt656_enable;	/* enable BT.656 embedded sync mode */
+	ccdc_pixorder pix_order;	/* cb:y:cr:y or y:cb:y:cr in memory */
+	ccdc_buftype buf_type;	/* interleaved or separated fields  */
+
+} ccdc_params_ycbcr;
+
+extern ccdc_params_raw ccdc_hw_params_raw;
+extern ccdc_params_ycbcr ccdc_hw_params_ycbcr;
+
+static inline enum data_size ccdc_raw_data_size(void)
+{
+	return ccdc_hw_params_raw.data_sz;
+}
+
+static inline bool ccdc_alaw_enable(void)
+{
+	return ccdc_hw_params_raw.alaw.b_alaw_enable;
+}
+
+static inline void ccdc_set_frame_format(enum hw_frame frame_type,
+					 ccdc_frmfmt frame_format)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.frm_fmt = frame_format;
+	else
+		ccdc_hw_params_raw.frm_fmt = frame_format;
+}
+
+static inline ccdc_frmfmt ccdc_get_frame_format(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.frm_fmt;
+	else
+		return ccdc_hw_params_raw.frm_fmt;
+}
+
+static inline void ccdc_set_buf_type(enum hw_frame frame_type,
+				     ccdc_buftype buf_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.buf_type = buf_type;
+	else
+		ccdc_hw_params_raw.buf_type = buf_type;
+}
+
+static inline ccdc_buftype ccdc_get_buf_type(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.buf_type;
+	else
+		return ccdc_hw_params_raw.buf_type;
+}
+
+static inline void ccdc_get_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin * win)
+{
+	if (frame_type == CCDC_YCBCR)
+		*win = ccdc_hw_params_ycbcr.win;
+	else
+		*win = ccdc_hw_params_raw.win;
+}
+
+static inline void ccdc_set_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin win)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.win = win;
+	else
+		ccdc_hw_params_raw.win = win;
+}
+
+static inline void ccdc_set_pix_order(ccdc_pixorder order)
+{
+	ccdc_hw_params_ycbcr.pix_order = order;
+}
+static inline ccdc_pixorder ccdc_get_pix_order(void)
+{
+	return ccdc_hw_params_ycbcr.pix_order;
+}
+
+/**************************************************************************\
+* Register OFFSET Definitions
+\**************************************************************************/
+#define SYNCEN				0x00
+#define MODESET				0x04
+#define HDWIDTH				0x08
+#define VDWIDTH				0x0c
+#define PPLN				0x10
+#define LPFR				0x14
+#define SPH				0x18
+#define NPH				0x1c
+#define SLV0				0x20
+#define SLV1				0x24
+#define NLV				0x28
+#define CULH				0x2c
+#define CULV				0x30
+#define HSIZE				0x34
+#define SDOFST				0x38
+#define STADRH				0x3c
+#define STADRL				0x40
+#define CLAMP				0x44
+#define DCSUB				0x48
+#define COLPTN				0x4c
+#define BLKCMP0				0x50
+#define BLKCMP1				0x54
+#define MEDFILT				0x58
+#define RYEGAIN				0x5c
+#define GRCYGAIN			0x60
+#define GBGGAIN				0x64
+#define BMGGAIN				0x68
+#define OFFSET				0x6c
+#define OUTCLIP				0x70
+#define VDINT0				0x74
+#define VDINT1				0x78
+#define RSV0				0x7c
+#define GAMMAWD				0x80
+#define REC656IF			0x84
+#define CCDCFG				0x88
+#define FMTCFG				0x8c
+#define FMTPLEN				0x90
+#define FMTSPH				0x94
+#define FMTLNH				0x98
+#define FMTSLV				0x9c
+#define FMTLNV				0xa0
+#define FMTRLEN				0xa4
+#define FMTHCNT				0xa8
+#define FMT_ADDR_PTR_B			0xac
+#define FMT_ADDR_PTR(i)			(FMT_ADDR_PTR_B + (i*4))
+#define FMTPGM_VF0			0xcc
+#define FMTPGM_VF1			0xd0
+#define FMTPGM_AP0			0xd4
+#define FMTPGM_AP1			0xd8
+#define FMTPGM_AP2			0xdc
+#define FMTPGM_AP3                      0xe0
+#define FMTPGM_AP4                      0xe4
+#define FMTPGM_AP5                      0xe8
+#define FMTPGM_AP6                      0xec
+#define FMTPGM_AP7                      0xf0
+#define LSCCFG1                         0xf4
+#define LSCCFG2                         0xf8
+#define LSCH0                           0xfc
+#define LSCV0                           0x100
+#define LSCKH                           0x104
+#define LSCKV                           0x108
+#define LSCMEMCTL                       0x10c
+#define LSCMEMD                         0x110
+#define LSCMEMQ                         0x114
+#define DFCCTL                          0x118
+#define DFCVSAT                         0x11c
+#define DFCMEMCTL                       0x120
+#define DFCMEM0                         0x124
+#define DFCMEM1                         0x128
+#define DFCMEM2                         0x12c
+#define DFCMEM3                         0x130
+#define DFCMEM4                         0x134
+#define CSCCTL                          0x138
+#define CSCM0                           0x13c
+#define CSCM1                           0x140
+#define CSCM2                           0x144
+#define CSCM3                           0x148
+#define CSCM4                           0x14c
+#define CSCM5                           0x150
+#define CSCM6                           0x154
+#define CSCM7                           0x158
+#define DATAOFST			0x15c
+
+#define CCDC_IOBASE_VADDR               IO_ADDRESS(0x01c70600)
+
+#define regw(val, reg)    		outl(val, (reg)+CCDC_IOBASE_VADDR)
+#define regr(reg)         		inl((reg)+CCDC_IOBASE_VADDR)
+
+#define VPSS_BL_IOBASE_VADDR		IO_ADDRESS(0x01c70000)
+#define regw_bl(val, reg)    		outl(val, (reg)+VPSS_BL_IOBASE_VADDR)
+#define regr_bl(reg)         		inl((reg)+VPSS_BL_IOBASE_VADDR)
+
+#define VPSS_VPSSCLK_BASE		IO_ADDRESS(0x01c70000)
+#define regw_clk(val, reg)		outl(val, (reg)+VPSS_VPSSCLK_BASE)
+#define regr_clk(reg)                   inl((reg)+VPSS_VPSSCLK_BASE)
+
+#define CLKCTRL				(0x04)
+
+#define INTSTAT				(0x80C)
+#define INTSEL				(0x810)
+#define	EVTSEL				(0x814)
+#define MEMCTRL				(0x818)
+#define CCDCMUX				(0x81C)
+
+/**************************************************************
+*	Define for various register bit mask and shifts for CCDC
+*
+**************************************************************/
+#define CCDC_RAW_IP_MODE			(0x00)
+#define CCDC_VDHDOUT_INPUT			(0x00)
+#define CCDC_YCINSWP_RAW			(0x00 << 4)
+#define CCDC_EXWEN_DISABLE 			(0x00)
+#define CCDC_DATAPOL_NORMAL			(0x00)
+#define CCDC_CCDCFG_FIDMD_LATCH_VSYNC		(0x00)
+#define CCDC_CCDCFG_WENLOG_AND			(0x00)
+#define CCDC_CCDCFG_TRGSEL_WEN                  (0x00)
+#define CCDC_CCDCFG_EXTRG_DISABLE               (0x00)
+#define CCDC_CFA_MOSAIC				(0x00)
+
+#define CCDC_VDC_DFCVSAT_MASK			(0x3fff)
+#define CCDC_DATAOFST_MASK			(0x0ff)
+#define CCDC_DATAOFST_H_SHIFT			(0)
+#define CCDC_DATAOFST_V_SHIFT			(8)
+#define CCDC_GAMMAWD_CFA_MASK			(0x01)
+#define CCDC_GAMMAWD_CFA_SHIFT			(5)
+#define CCDC_FID_POL_MASK			(0x01)
+#define CCDC_FID_POL_SHIFT			(4)
+#define CCDC_HD_POL_MASK			(0x01)
+#define CCDC_HD_POL_SHIFT			(3)
+#define CCDC_VD_POL_MASK			(0x01)
+#define CCDC_VD_POL_SHIFT			(2)
+#define CCDC_FRM_FMT_MASK			(0x01)
+#define CCDC_FRM_FMT_SHIFT			(7  )
+#define CCDC_DATA_SZ_MASK			(0x07)
+#define CCDC_DATA_SZ_SHIFT			(8)
+#define CCDC_VDHDOUT_MASK                       (0x01)
+#define CCDC_VDHDOUT_SHIFT                      (0)
+#define CCDC_EXWEN_MASK				(0x01)
+#define CCDC_EXWEN_SHIFT			(5)
+#define CCDC_RAW_INPUT_MASK                     (0x03)
+#define CCDC_RAW_INPUT_SHIFT                    (12)
+#define CCDC_PIX_FMT_MASK			(0x03)
+#define CCDC_PIX_FMT_SHIFT			(12)
+#define CCDC_DATAPOL_MASK			(0x01)
+#define CCDC_DATAPOL_SHIFT			(6)
+#define CCDC_WEN_ENABLE				(0x01 << 1)
+#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
+#define CCDC_LPF_ENABLE				(0x01 << 14)
+#define CCDC_ALAW_ENABLE			(0x01)
+#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
+
+#define CCDC_FMTCFG_FMTMODE_MASK 		(0x03)
+#define CCDC_FMTCFG_FMTMODE_SHIFT		(1)
+#define CCDC_FMTCFG_LNUM_MASK			(0x03)
+#define CCDC_FMTCFG_LNUM_SHIFT			(4)
+#define CCDC_FMTCFG_ADDRINC_MASK		(0x07)
+#define CCDC_FMTCFG_ADDRINC_SHIFT		(8)
+
+#define CCDC_CCDCFG_FIDMD_SHIFT			(6)
+#define	CCDC_CCDCFG_WENLOG_SHIFT		(8)
+#define CCDC_CCDCFG_TRGSEL_SHIFT                (9)
+#define CCDC_CCDCFG_EXTRG_SHIFT                 (10)
+#define CCDC_CCDCFG_MSBINVI_SHIFT               (13)
+
+#define CCDC_HSIZE_FLIP_SHIFT			(12)
+#define CCDC_HSIZE_FLIP_MASK			(0x01)
+
+#define START_PX_HOR_MASK			(0x7FFF)
+#define NUM_PX_HOR_MASK				(0x7FFF)
+#define START_VER_ONE_MASK			(0x7FFF)
+#define START_VER_TWO_MASK			(0x7FFF)
+#define NUM_LINES_VER				(0x7FFF)
+
+#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 15)
+#define CCDC_BLK_SGAIN_MASK			(0x1F )
+#define CCDC_BLK_ST_PXL_MASK			(0x1FFF)
+#define CCDC_BLK_SAMPLE_LN_MASK			(0x03)
+#define CCDC_BLK_SAMPLE_LN_SHIFT		(13)
+
+#define CCDC_NUM_LINE_CALC_MASK			(0x03)
+#define CCDC_NUM_LINE_CALC_SHIFT		(14)
+
+#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
+#define CCDC_BLK_COMP_MASK			(0x000000FF)
+#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
+#define CCDC_BLK_COMP_GR_COMP_SHIFT		(0)
+#define CCDC_BLK_COMP_R_COMP_SHIFT		(8)
+#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
+#define CCDC_LATCH_ON_VSYNC_ENABLE		(0x00 << 15)
+#define CCDC_FPC_ENABLE				(0x01 << 15)
+#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
+#define CCDC_DATA_PACK_ENABLE			(0x01<<11)
+#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16 )
+#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16 )
+#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
+#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
+#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
+#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
+#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
+
+#define CCDC_CSC_COEFF_SHIFT			(8)
+#define CCDC_CSC_COEFF_DEC_MASK			(0x0007)
+#define CCDC_CSC_COEFF_FRAC_MASK		(0x001F)
+#define CCDC_CSC_DEC_SHIFT			(5)
+#define CCDC_CSC_ENABLE                         (0x01)
+#define CCDC_MFILT1_SHIFT			(10)
+#define CCDC_MFILT2_SHIFT			(8)
+#define CCDC_LPF_MASK				(0x01)
+#define CCDC_LPF_SHIFT				(14)
+#define CCDC_OFFSET_MASK			(0x3FF)
+#define CCDC_DATASFT_MASK			(0x07)
+#define CCDC_DATASFT_SHIFT			(8)
+#define CCDC_DF_ENABLE				(0x01)
+
+#define CCDC_FMTPLEN_P0_MASK			(0x000F)
+#define CCDC_FMTPLEN_P1_MASK			(0x000F)
+#define CCDC_FMTPLEN_P2_MASK			(0x0007)
+#define CCDC_FMTPLEN_P3_MASK			(0x0007)
+#define CCDC_FMTPLEN_P0_SHIFT			(0)
+#define CCDC_FMTPLEN_P1_SHIFT			(4)
+#define CCDC_FMTPLEN_P2_SHIFT			(8)
+#define CCDC_FMTPLEN_P3_SHIFT			(12)
+
+#define CCDC_FMTSPH_MASK			(0x01FFF)
+#define CCDC_FMTLNH_MASK                        (0x01FFF)
+#define CCDC_FMTSLV_MASK                        (0x01FFF)
+#define CCDC_FMTLNV_MASK                        (0x07FFF)
+#define CCDC_FMTRLEN_MASK                       (0x01FFF)
+#define CCDC_FMTHCNT_MASK                       (0x01FFF)
+
+#define CCDC_ADP_INIT_MASK			(0x01FFF)
+#define CCDC_ADP_LINE_SHIFT			(13)
+#define CCDC_ADP_LINE_MASK			(0x0003)
+#define CCDC_FMTPGN_APTR_MASK			(0x0007)
+
+#define CCDC_DFCCTL_GDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_SHIFT		(4)
+#define CCDC_DFCCTL_VDFCSL_MASK			(0x03)
+#define CCDC_DFCCTL_VDFCSL_SHIFT		(5)
+#define CCDC_DFCCTL_VDFCUDA_MASK		(0x01)
+#define CCDC_DFCCTL_VDFCUDA_SHIFT		(7)
+#define CCDC_DFCCTL_VDFLSFT_MASK                (0x03)
+#define CCDC_DFCCTL_VDFLSFT_SHIFT               (8)
+#define CCDC_DFCMEMCTL_DFCMARST_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMARST_SHIFT		(2)
+#define CCDC_DFCMEMCTL_DFCMWR_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMWR_SHIFT		(0)
+
+#define CCDC_LSCCFG_GFTSF_MASK			(0x07)
+#define CCDC_LSCCFG_GFTSF_SHIFT			(1)
+#define CCDC_LSCCFG_GFTINV_MASK                 (0x0f)
+#define CCDC_LSCCFG_GFTINV_SHIFT                (4)
+#define CCDC_LSC_GFTABLE_SEL_MASK		(0x03)
+#define CCDC_LSC_GFTABLE_EPEL_SHIFT		(8)
+#define CCDC_LSC_GFTABLE_OPEL_SHIFT		(10)
+#define CCDC_LSC_GFTABLE_EPOL_SHIFT		(12)
+#define CCDC_LSC_GFTABLE_OPOL_SHIFT		(14)
+#define CCDC_LSC_GFMODE_MASK			(0x03)
+#define CCDC_LSC_GFMODE_SHIFT			(4)
+#define CCDC_LSC_DISABLE			(0)
+#define CCDC_LSC_ENABLE				(1)
+#define CCDC_LSC_TABLE1_SLC			(0)
+#define CCDC_LSC_TABLE2_SLC			(1)
+#define CCDC_LSC_TABLE3_SLC			(2)
+#define CCDC_LSC_MEMADDR_RESET			(1<<2)
+#define CCDC_LSC_MEMADDR_INCR                   (0<<2)
+#define CCDC_LSC_FRAC_MASK_T1			(0xFF)
+#define CCDC_LSC_INT_MASK			(0x03)
+#define CCDC_LSC_FRAC_MASK                      (0x3FFF)
+#define CCDC_LSC_CENTRE_MASK			(0x3FFF)
+#define CCDC_LSC_COEF_MASK			(0x0ff)
+#define  CCDC_LSC_COEFL_SHIFT			(0)
+#define CCDC_LSC_COEFU_SHIFT			(8)
+
+extern void ccdc_reset(void);
+extern void ccdc_init(void);
+extern void ccdc_cleanup(void);
+extern void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc);
+void ccdc_config_raw(void);
+void ccdc_config_ycbcr(void);
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam);
+int ccdc_update_ycbcr_params(void *);
+int ccdc_update_raw_params(void *);
+static inline void ccdc_enable_vport(void)
+{
+	/* Do nothing for DM355 */
+}
+
+static inline int ccdc_sbl_reset(void)
+{
+	return 0;
+}
+
+/* inline functions that must be fast because they are called frequently */
+static inline void ccdc_enable(int flag)
+{
+	if (flag)
+		flag = 3;
+	else
+		flag = 0;
+	regw(flag, SYNCEN);
+}
+
+/*
+static inline void sdramop_enable(int flag){
+        unsigned int temp;
+	temp = regr(SYNCEN);
+	temp |= (flag & 0x01)<<1;
+	regw(temp, SYNCEN);
+}
+*/
+static inline void ccdc_setfbaddr(unsigned long paddr)
+{
+	regw((paddr >> 21) & 0x007f, STADRH);
+	regw((paddr >> 5) & 0x0ffff, STADRL);
+}
+
+static inline int ccdc_getfid(void)
+{
+	int fid = (regr(MODESET) >> 15) & 0x1;
+	return fid;
+}
+
+/*
+static inline int ccdc_sbl_reset(void)
+{
+	int sb_reset;
+	sb_reset = regr_sb(4);
+	regw_sb((sb_reset & 0xFF7FFFFF), 4);
+	return sb_reset;
+}*/
+
+#endif
+
+#endif				/* CCDC_DM355_H */
Index: linux-2.6.10/include/media/davinci/davinci_display.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davinci_display.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_display.h */
+
+#ifndef DAVINCI_DISPLAY_H
+#define DAVINCI_DISPLAY_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/video-buf.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/vid_encoder_types.h>
+
+#define DAVINCI_DISPLAY_MAX_DEVICES 2
+
+enum davinci_display_device_id {
+	DAVINCI_DISPLAY_DEVICE_0,
+	DAVINCI_DISPLAY_DEVICE_1
+};
+
+#define DAVINCI_DISPLAY_MAJOR_RELEASE              1
+#define DAVINCI_DISPLAY_MINOR_RELEASE              0
+#define DAVINCI_DISPLAY_BUILD                      1
+#define DAVINCI_DISPLAY_VERSION_CODE       ((DAVINCI_DISPLAY_MAJOR_RELEASE<<16) | \
+	(DAVINCI_DISPLAY_MINOR_RELEASE<<8)  | \
+	DAVINCI_DISPLAY_BUILD)
+
+#define DAVINCI_DISPLAY_VALID_FIELD(field)   ((V4L2_FIELD_NONE == field) || \
+	 (V4L2_FIELD_ANY == field) || (V4L2_FIELD_INTERLACED == field))
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+
+/* Exp ratio numerator and denominator constants */
+#define DAVINCI_DISPLAY_H_EXP_RATIO_N   (9)
+#define DAVINCI_DISPLAY_H_EXP_RATIO_D   (8)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_N   (6)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_D   (5)
+
+/* Zoom multiplication factor */
+#define DAVINCI_DISPLAY_ZOOM_4X (4)
+#define DAVINCI_DISPLAY_ZOOM_2X (2)
+
+#define DAVINCI_DISPLAY_PIXELASPECT_NTSC 		{11, 10}
+#define DAVINCI_DISPLAY_PIXELASPECT_PAL  		{54, 59}
+#define DAVINCI_DISPLAY_PIXELASPECT_SP    	    {1, 1}
+
+/* settings for commonly used video formats */
+#define DAVINCI_DISPLAY_WIN_NTSC     {0, 0, 720, 480}
+#define DAVINCI_DISPLAY_WIN_PAL      {0, 0, 720, 576}
+#define DAVINCI_DISPLAY_WIN_640_480  {0, 0, 640, 480}
+#define DAVINCI_DISPLAY_WIN_640_400  {0, 0, 640, 400}
+#define DAVINCI_DISPLAY_WIN_640_350  {0, 0, 640, 350}
+#define DAVINCI_DISPLAY_WIN_720P  {0, 0, 1280, 720}
+#define DAVINCI_DISPLAY_WIN_1080I  {0, 0, 1920, 1080}
+
+/* Structures */
+struct display_layer_info {
+	int enable;
+	enum davinci_disp_layer id;	/* Layer ID used by Display Manager */
+	struct davinci_layer_config config;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+};
+
+/* display object structure */
+struct display_obj {
+	/* Buffer specific parameters */
+	u32 fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   v4l2_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   v4l2_buffer */
+	/* videobuf specific parameters */
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this layer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism user
+					   has selected */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	struct v4l2_pix_format pix_fmt;	/* Used to store pixel format */
+	enum v4l2_field buf_field;
+
+	/* Video layer configuration params */
+	struct display_layer_info layer_info;
+
+	/* vpbe specific parameters */
+	unsigned char window_enable;	/*enabke window for display */
+
+	u32 usrs;		/* number of open instances of
+				   the layer */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+
+	u8 started;		/* Indicates whether streaming
+				   started */
+	enum davinci_display_device_id device_id;	/* Identifies device object */
+};
+
+/* File handle structure */
+struct davinci_fh {
+	struct display_obj *layer;	/* pointer to layer object for
+					   opened device */
+	u8 io_allowed;		/* Indicates whether this file handle
+				   is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+};
+
+/* vpbe device structure */
+struct davinci_display {
+	/* layer specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+
+	/* Display mode information */
+	struct vid_enc_mode_info mode_info;
+
+	/* interrupt callback */
+	struct davinci_disp_callback event_callback;
+
+	struct display_obj *dev[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+struct buf_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 min_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 layer_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+#endif				/* End of __KERNEL__ */
+
+#endif				/* DAVINCI_DISPLAY_H */
Index: linux-2.6.10/include/media/davinci/davinci_enc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davinci_enc.h
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * davinci_enc.h.
+ * This file contains APIs exported by Davinci Encoder Manager. Davinci Encoder
+ * manager uses the services from encoder interface for implementing it's
+ * functionality.
+ * It also configure the VENC/DLCD to support a specific video/graphics mode
+ * This interface allows set/get of output, mode , parameters and controls at
+ * the encoder. encoder may support multiple channels, each with a set of
+ * encoders So encoder manager support registration of encoders and APIs
+ * on a per channel basis.
+ */
+
+#ifndef DAVINCI_ENC_H
+#define DAVINCI_ENC_H
+
+#ifdef __KERNEL__
+#include <linux/config.h>
+#include <media/davinci/vid_encoder_types.h>
+
+/**
+ *  Maximum channels supported by encoder manager. Set to 1 for DM355 & DM6446.
+ * If a platform support multiple channel, this needs to be changed. Channel
+ * number starts with 0
+ */
+#define DAVINCI_ENC_MAX_CHANNELS	CONFIG_ENC_MNGR_MAX_CHANNELS
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set
+ * encoder parameters.
+ */
+int davinci_enc_setparams(int channel, void *params);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get
+ * encoder parameters.
+ */
+int davinci_enc_getparams(int channel, void *params);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info);
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure. This is updated by
+ * encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+ */
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * to set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to configure the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During configuration of the SoC hardware for timing,
+ * mgr would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name. size
+ * VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+ *   output name
+ */
+int davinci_enc_get_output(int channel, char *output);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+ * configuration of the VENC or related hardware in the VPSS and re-enabled
+ * using this API. This will switch the output DACs Off or On based on the
+ * flag.
+ */
+int davinci_enc_enable_output(int channel, int flag);
+
+/**
+ * davinci_enc_set_basep
+ * @channel: channel number (0 to MAX_CHANNELS-1)
+ * @basepx: horizontal reference position (in pixels) for all layers
+ * @basepy: vertical reference position (in lines) for all layers
+ *
+ * Description:
+ * Set the base display reference position for all display layers.
+ */
+void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy);
+
+/**
+ * davinci_enc_get_basep
+ * @channel: channel number (0 to MAX_CHANNELS-1)
+ * @basepx: horizontal reference position (in pixels) for all layers
+ * @basepy: vertical reference position (in lines) for all layers
+ *
+ * Description:
+ * Get the base display reference position for all display layers.
+ */
+void davinci_disp_get_basep(int channel, unsigned *basepx, unsigned *basepy);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_hbi
+ * @channel: channel number (0 to MAX_CHANNELS-1)
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *service);
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @service: pointer to the structure vid_enc_sliced_vbi_service
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *services);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @channel: channel number.
+ * @data: pointer to the structure vid_enc_sliced_vbi_data
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data);
+
+#endif				/* #ifdef __KERNEL__ */
+#endif				/* #ifdef DAVINCI_ENC_H */
Index: linux-2.6.10/include/media/davinci/davinci_enc_mngr.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davinci_enc_mngr.h
@@ -0,0 +1,57 @@
+
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DAVINCI_ENC_MNGR_H
+#define DAVINCI_ENC_MNGR_H
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+
+#ifdef __KERNEL__
+
+#define DAVINCI_ENC_MAX_ENCODERS (4)
+
+struct vid_enc_device_mgr {
+	struct semaphore lock;
+	int num_encoders;	/* number of encoders in this channel */
+	int current_encoder;	/* index to current encoder */
+	char current_output[VID_ENC_NAME_MAX_CHARS];	/* current output */
+	struct vid_enc_mode_info current_mode;	/* current mode */
+	struct vid_encoder_device *encoder[DAVINCI_ENC_MAX_ENCODERS];
+};
+
+struct enc_config {
+	char output[VID_ENC_NAME_MAX_CHARS];
+	char mode[VID_ENC_NAME_MAX_CHARS];
+};
+
+#endif				/* __KERNEL__ */
+
+#endif
Index: linux-2.6.10/include/media/davinci/davinci_platform.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davinci_platform.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef DAVINCI_PLATFORM_H
+#define DAVINCI_PLATFORM_H
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/davinci_enc_mngr.h>
+
+#ifdef __KERNEL__
+struct platform_specific_base {
+	unsigned int basepx;
+	unsigned int basepy;
+};
+void davinci_enc_get_basep(int channel, unsigned *basepx, unsigned *basepy);
+int davinci_enc_select_venc_clock(int clk);
+void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy);
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode);
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr);
+
+#endif				/* End of __KERNEL__ */
+
+#endif				/* End of ifndef DAVINCI_PLATFORM_H */
Index: linux-2.6.10/include/media/davinci/logicpd_encoder.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/logicpd_encoder.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LOGICPD_ENCODER_H
+#define LOGICPD_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#endif
+
+#ifdef __KERNEL__
+/* encoder standard related strctures */
+#define LOGICPD_ENCODER_MAX_NO_OUTPUTS		    (1)
+#define LOGICPD_ENCODER_GRAPHICS_NUM_STD		(4)
+
+struct logicpd_encoder_params {
+	int outindex;
+	char *mode;
+};
+
+struct logicpd_encoder_config {
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		struct vid_enc_mode_info
+		 standards[LOGICPD_ENCODER_GRAPHICS_NUM_STD];
+	} output[LOGICPD_ENCODER_MAX_NO_OUTPUTS];
+};
+
+struct logicpd_encoder_channel {
+	struct encoder_device *enc_device;
+	struct logicpd_encoder_params params;
+};
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef LOGICPD_ENCODER_H */
Index: linux-2.6.10/include/media/davinci/ths8200_encoder.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/ths8200_encoder.h
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*ths8200_encoder.h*/
+
+#ifndef THS8200_ENCODER_H
+#define THS8200_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <media/davinci/vid_encoder_if.h>
+
+/* encoder standard related strctures */
+#define THS8200_MAX_NO_OUTPUTS			(1)
+#define THS8200_COMPONENT_NUM_STD		(2)
+#define THS8200_MAX_NUM_STD		        (2)
+#define THS8200_STANDARD_INFO_SIZE THS8200_COMPONENT_NUM_STD
+
+enum ths8200_i2_devices {
+	THS8200,
+	CDCE_CLK_SYNTH,
+	THS7303_VIDEO_BUFFER,
+};
+
+struct ths8200_std_info {
+	int reg;
+	u32 val;
+};
+
+struct ths8200_params {
+	int outindex;
+	char *mode;
+};
+
+struct ths8200_config {
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		char *standards[THS8200_MAX_NUM_STD];
+		struct ths8200_std_info *std_info;
+	} output[THS8200_MAX_NO_OUTPUTS];
+};
+
+struct ths8200_i2c_client {
+	struct i2c_client client;
+	u8 i2c_addr;
+};
+
+#define THS8200_MAX_I2C_DEVICES 3
+struct ths8200_channel {
+	struct vid_encoder_device *enc_device;
+	struct {
+		struct i2c_driver driver;
+		struct ths8200_i2c_client clients[THS8200_MAX_I2C_DEVICES];
+		int i2c_registration;
+	} i2c_dev;
+	struct ths8200_params params;
+};
+
+#define THS8200_I2C_ADDR  0x21
+#define THS7303_I2C_ADDR0 0x2c
+#define CDCE_I2C_ADDR     0x6c
+
+#define THS7303_CHANNEL_1 0x1
+#define THS7303_CHANNEL_2 0x2
+#define THS7303_CHANNEL_3 0x3
+
+#define THS7303_DEFAULT_CHANNEL_VAL 0x92
+
+/* Register Macros */
+#define THS8200_VERSION             0x02
+#define THS8200_CHIP_CTL            0x03
+#define THS8200_CSC_R11             0x04
+#define THS8200_CSC_R12             0x05
+#define THS8200_CSC_R21             0x06
+#define THS8200_CSC_R22             0x07
+#define THS8200_CSC_R31             0x08
+#define THS8200_CSC_R32             0x09
+#define THS8200_CSC_G11             0x0a
+#define THS8200_CSC_G12             0x0b
+#define THS8200_CSC_G21             0x0c
+#define THS8200_CSC_G22             0x0d
+#define THS8200_CSC_G31             0x0e
+#define THS8200_CSC_G32             0x0f
+#define THS8200_CSC_B11             0x10
+#define THS8200_CSC_B12             0x11
+#define THS8200_CSC_B21             0x12
+#define THS8200_CSC_B22             0x13
+#define THS8200_CSC_B31             0x14
+#define THS8200_CSC_B32             0x15
+#define THS8200_CSC_OFFS1           0x16
+#define THS8200_CSC_OFFS12          0x17
+#define THS8200_CSC_OFFS23          0x18
+#define THS8200_CSC_OFFS3           0x19
+#define THS8200_TST_CNTL1           0x1a
+#define THS8200_TST_CNTL2           0x1b
+#define THS8200_DATA_CNTL           0x1c
+#define THS8200_DTG1_Y_SYNC1_LSB    0x1d
+#define THS8200_DTG1_Y_SYNC2_LSB    0x1e
+#define THS8200_DTG1_Y_SYNC3_LSB    0x1f
+#define THS8200_DTG1_CBCR_SYNC1_LSB 0x20
+#define THS8200_DTG1_CBCR_SYNC2_LSB 0x21
+#define THS8200_DTG1_CBCR_SYNC3_LSB 0x22
+#define THS8200_DTG1_Y_SYNC_MSB     0x23
+#define THS8200_DTG1_CBCR_SYNC_MSB  0x24
+#define THS8200_DTG1_SPEC_A         0x25
+#define THS8200_DTG1_SPEC_B         0x26
+#define THS8200_DTG1_SPEC_C         0x27
+#define THS8200_DTG1_SPEC_D_LSB     0x28
+#define THS8200_DTG1_SPEC_D1        0x29
+#define THS8200_DTG1_SPEC_E_LSB     0x2a
+#define THS8200_DTG1_SPEC_DEH_MSB   0x2b
+#define THS8200_DTG1_SPEC_H_LSB     0x2c
+#define THS8200_DTG1_SPEC_I_MSB     0x2d
+#define THS8200_DTG1_SPEC_I_LSB     0x2e
+#define THS8200_DTG1_SPEC_K_LSB     0x2f
+#define THS8200_DTG1_SPEC_K_MSB     0x30
+#define THS8200_DTG1_SPEC_K1        0x31
+#define THS8200_DTG1_SPEC_G_LSB     0x32
+#define THS8200_DTG1_SPEC_G_MSB     0x33
+#define THS8200_DTG1_TOT_PIXELS_MSB 0x34
+#define THS8200_DTG1_TOT_PIXELS_LSB 0x35
+#define THS8200_DTG1_FLD_FLIP_LINECNT_MSB 0x36
+#define THS8200_DTG1_LINECNT_LSB    0x37
+#define THS8200_DTG1_MODE           0x38
+#define THS8200_DTG1_FRAME_FIELD_SZ_MSB   0x39
+#define THS8200_DTG1_FRAME_SZ_LSB   0x3a
+#define THS8200_DTG1_FIELD_SZ_LSB   0x3b
+#define THS8200_DTG1_VESA_CBAR_SIZE 0x3c
+#define THS8200_DAC_CNTL_MSB        0x3d
+#define THS8200_DAC1_CNTL_LSB       0x3e
+#define THS8200_DAC2_CNTL_LSB       0x3f
+#define THS8200_DAC3_CNTL_LSB       0x40
+#define THS8200_CSM_CLIP_GY_LOW     0x41
+#define THS8200_CSM_CLIP_BCB_LOW    0x42
+#define THS8200_CSM_CLIP_RCR_LOW    0x43
+#define THS8200_CSM_CLIP_GY_HIGH    0x44
+#define THS8200_CSM_CLIP_BCB_HIGH   0x45
+#define THS8200_CSM_CLIP_RCR_HIGH   0x46
+#define THS8200_CSM_SHIFT_GY        0x47
+#define THS8200_CSM_SHIFT_BCB       0x48
+#define THS8200_CSM_SHIFT_RCR       0x49
+#define THS8200_CSM_GY_CNTL_MULT_MSB     0x4a
+#define THS8200_CSM_MULT_BCB_RCR_MSB     0x4b
+#define THS8200_CSM_MULT_GY_LSB     0x4c
+#define THS8200_CSM_MULT_BCB_LSB    0x4d
+#define THS8200_CSM_MULT_RCR_LSB    0x4e
+#define THS8200_CSM_MULT_RCR_BCB_CNTL    0x4f
+#define THS8200_CSM_MULT_RCR_LSB    0x4e
+#define THS8200_DTG2_BP1_2_MSB      0x50
+#define THS8200_DTG2_BP3_4_MSB      0x51
+#define THS8200_DTG2_BP5_6_MSB      0x52
+#define THS8200_DTG2_BP7_8_MSB      0x53
+#define THS8200_DTG2_BP9_10_MSB     0x54
+#define THS8200_DTG2_BP11_12_MSB    0x55
+#define THS8200_DTG2_BP13_14_MSB    0x56
+#define THS8200_DTG2_BP15_16_MSB    0x57
+#define THS8200_DTG2_BP1_LSB        0x58
+#define THS8200_DTG2_BP2_LSB        0x59
+#define THS8200_DTG2_BP3_LSB        0x5a
+#define THS8200_DTG2_BP4_LSB        0x5b
+#define THS8200_DTG2_BP5_LSB        0x5c
+#define THS8200_DTG2_BP6_LSB        0x5d
+#define THS8200_DTG2_BP7_LSB        0x5e
+#define THS8200_DTG2_BP8_LSB        0x5f
+#define THS8200_DTG2_BP9_LSB        0x60
+#define THS8200_DTG2_BP10_LSB       0x61
+#define THS8200_DTG2_BP11_LSB       0x62
+#define THS8200_DTG2_BP12_LSB       0x63
+#define THS8200_DTG2_BP13_LSB       0x64
+#define THS8200_DTG2_BP14_LSB       0x65
+#define THS8200_DTG2_BP15_LSB       0x66
+#define THS8200_DTG2_BP16_LSB       0x67
+#define THS8200_DTG2_LINETYPE1      0x68
+#define THS8200_DTG2_LINETYPE2      0x69
+#define THS8200_DTG2_LINETYPE3      0x6a
+#define THS8200_DTG2_LINETYPE4      0x6b
+#define THS8200_DTG2_LINETYPE5      0x6c
+#define THS8200_DTG2_LINETYPE6      0x6d
+#define THS8200_DTG2_LINETYPE7      0x6e
+#define THS8200_DTG2_LINETYPE8      0x6f
+#define THS8200_DTG2_HLENGTH_LSB    0x70
+#define THS8200_DTG2_HLENGTH_LSB_HDLY_MSB    0x71
+#define THS8200_DTG2_HLENGTH_HDLY_LSB        0x72
+#define THS8200_DTG2_VLENGTH1_LSB   0x73
+#define THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB  0x74
+#define THS8200_DTG2_VDLY1_LSB      0x75
+#define THS8200_DTG2_VLENGTH2_LSB   0x76
+#define THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB  0x77
+#define THS8200_DTG2_VDLY2_LSB      0x78
+#define THS8200_DTG2_HS_IN_DLY_MSB  0x79
+#define THS8200_DTG2_HS_IN_DLY_LSB  0x7a
+#define THS8200_DTG2_VS_IN_DLY_MSB  0x7b
+#define THS8200_DTG2_VS_IN_DLY_LSB  0x7c
+#define THS8200_DTG2_PIXEL_CNT_MSB  0x7d
+#define THS8200_DTG2_PIXEL_CNT_LSB  0x7e
+#define THS8200_DTG2_LINE_CNT_MSB   0x7f
+#define THS8200_DTG2_LINE_CNT_LSB   0x80
+#define THS8200_DTG2_CNTL           0x82
+#define THS8200_CGMS_CNTL_HEADER    0x83
+#define THS8200_CGMS_PAYLOAD_MSB    0x84
+#define THS8200_CGMS_PAYLOAD_LSB    0x85
+#define THS8200_MISC_PPL_LSB        0x86
+#define THS8200_MISC_PPL_MSB        0x87
+#define THS8200_MISC_LPF_MSB        0x88
+#define THS8200_MISC_LPF_LSB        0x89
+
+/* Default values for the registers */
+#define THS8200_DTG1_Y_SYNC1_LSB_DEFAULT    0xff
+#define THS8200_DTG1_Y_SYNC2_LSB_DEFAULT    0x49
+#define THS8200_DTG1_Y_SYNC3_LSB_DEFAULT    0xb6
+#define THS8200_DTG1_CBCR_SYNC1_LSB_DEFAULT 0xff
+#define THS8200_DTG1_CBCR_SYNC2_LSB_DEFAULT 0xff
+#define THS8200_DTG1_CBCR_SYNC3_LSB_DEFAULT 0xff
+#define THS8200_DTG1_Y_SYNC_MSB_DEFAULT     0x13
+#define THS8200_DTG1_CBCR_SYNC_MSB_DEFAULT  0x15
+#define THS8200_DTG1_SPEC_H_LSB_DEFAULT     0x0
+#define THS8200_DTG1_SPEC_K_MSB_DEFAULT     0x0
+#define THS8200_DTG1_FLD_FLIP_LINECNT_MSB_DEFAULT 0x0
+#define THS8200_DTG1_LINECNT_LSB_DEFAULT 0x1
+#define THS8200_DTG2_HS_IN_DLY_MSB_DEFAULT 0x0
+
+/* defaults for 720P HD */
+#define THS8200_DTG2_CNTL_720P_DEFAULT    0x1b
+#define THS8200_DTG1_SPEC_A_720P_DEFAULT  0x28
+/* distance from end of active video to start of sync */
+#define THS8200_DTG1_SPEC_B_720P_DEFAULT  0x46
+#define THS8200_DTG1_SPEC_C_720P_DEFAULT  0x28
+#define THS8200_DTG1_SPEC_D_LSB_720P_DEFAULT 0x2c
+/* distance from Hsync to start of active video */
+#define THS8200_DTG1_SPEC_E_LSB_720P_DEFAULT 0x2c
+#define THS8200_DTG1_SPEC_DEH_MSB_720P_DEFAULT 0xc0
+#define THS8200_DTG1_SPEC_K_LSB_720P_DEFAULT 0x46
+#define THS8200_DTG1_TOT_PIXELS_MSB_720P_DEFAULT 0x06
+#define THS8200_DTG1_TOT_PIXELS_LSB_720P_DEFAULT 0x72
+#define THS8200_DTG1_MODE_720P_DEFAULT 0x82
+#define THS8200_DTG1_FRAME_FIELD_SZ_MSB_720P_DEFAULT 0x27
+#define THS8200_DTG1_FRAME_SZ_LSB_720P_DEFAULT 0xee
+#define THS8200_DTG1_FIELD_SZ_LSB_720P_DEFAULT 0xff
+#define THS8200_DTG2_HS_IN_DLY_LSB_720P_DEFAULT 0x60
+#define THS8200_DTG2_VS_IN_DLY_MSB_720P_DEFAULT 0x08
+#define THS8200_DTG2_VS_IN_DLY_LSB_720P_DEFAULT 0x06
+
+/* defaults for 1080i HD */
+#define THS8200_TST_CNTL1_1080I_DEFAULT             0x0
+#define THS8200_TST_CNTL2_1080I_DEFAULT             0x0
+#define THS8200_CSM_GY_CNTL_MULT_MSB_1080I_DEFAULT  0x0
+#define THS8200_DTG2_CNTL_1080I_DEFAULT 0x1f
+#define THS8200_DTG1_SPEC_A_1080I_DEFAULT 0x2c
+/* distance from end of active video to start of sync */
+#define THS8200_DTG1_SPEC_B_1080I_DEFAULT 0x58
+#define THS8200_DTG1_SPEC_C_1080I_DEFAULT 0x2c
+#define THS8200_DTG1_SPEC_D1_1080I_DEFAULT 0x0
+#define THS8200_DTG1_SPEC_D_LSB_1080I_DEFAULT 0x84
+/* distance from Hsync to start of active video */
+#define THS8200_DTG1_SPEC_E_LSB_1080I_DEFAULT 0xc0
+#define THS8200_DTG1_SPEC_DEH_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG1_SPEC_K_LSB_1080I_DEFAULT 0x58
+#define THS8200_DTG1_SPEC_G_LSB_1080I_DEFAULT 0x58
+#define THS8200_DTG1_SPEC_G_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG1_TOT_PIXELS_MSB_1080I_DEFAULT 0x08
+/* Total pixels per line */
+#define THS8200_DTG1_TOT_PIXELS_LSB_1080I_DEFAULT 0x98
+#define THS8200_DTG1_MODE_1080I_DEFAULT 0x81
+#define THS8200_DTG1_FRAME_FIELD_SZ_MSB_1080I_DEFAULT 0x42
+#define THS8200_DTG1_FRAME_SZ_LSB_1080I_DEFAULT 0x65
+#define THS8200_DTG1_FIELD_SZ_LSB_1080I_DEFAULT 0x33
+#define THS8200_DTG2_HLENGTH_LSB_1080I_DEFAULT 0x58
+#define THS8200_DTG2_HLENGTH_LSB_HDLY_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_HLENGTH_HDLY_LSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VLENGTH1_LSB_1080I_DEFAULT 0x05
+#define THS8200_DTG2_VLENGTH1_MSB_VDLY1_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VLENGTH2_LSB_1080I_DEFAULT 0x5
+#define THS8200_DTG2_VDLY2_LSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VLENGTH2_MSB_VDLY2_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VDLY1_LSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_HS_IN_DLY_LSB_1080I_DEFAULT 0x44
+#define THS8200_DTG2_VS_IN_DLY_MSB_1080I_DEFAULT 0x0
+#define THS8200_DTG2_VS_IN_DLY_LSB_1080I_DEFAULT 0x1
+
+/* MASKS */
+
+/* MODE VALUES */
+#define THS8200_ATSCHD_MODE_1080P    0x0
+#define THS8200_ATSCHD_MODE_1080I    0x1
+#define THS8200_ATSCHD_MODE_720P     0x2
+#define THS8200_HDMODE_GENERIC       0x3
+#define THS8200_ATSCSD_MODE_480I     0x4
+#define THS8200_ATSCSD_MODE_480P     0x5
+#define THS8200_VESA_MASTER          0x6
+#define THS8200_VESA_SLAVE           0x7
+#define THS8200_SD625I               0x8
+#define THS8200_MODE_MAX             0x8
+#define THS8200_DTG1_MODE_MASK       0xf
+
+/* Reset */
+#define THS8200_CHIP_CNTL_RESET            0x10
+#define THS8200_CHIP_CNTL_RESET_NORMAL     0x11
+
+/* CSC bypass */
+#define THS8200_CSC_BYPASS_SHIFT           0x1
+#define THS8200_CSC_BYPASS                 0x1
+#define THS8200_CSC_UOF_CNTL               0x1
+
+/* data manager control input mode */
+#define THS8200_DATA_CNTL_MODE_20BIT_YCBCR 0x3	/* 20 but YCbCr 4:2:2 */
+
+#endif				/* End of #ifdef __KERNEL__ */
+#endif				/* End of #ifndef THS8200_ENCODER_H */
Index: linux-2.6.10/include/media/davinci/vid_encoder_if.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/vid_encoder_if.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * File: vid_encoder_if.h
+ * Description:
+ * ============
+ * This file defines the interface to allow abstraction of an encoder hardware
+ * to an encoder module. Each encoder module support one or more display
+ * channels. It registers with the encoder manager at init and
+ * unregisters at exit. Encoder modules implement a set of operations defines
+ * by this interface. For each display channel, encoder manager selects
+ * one of the encoder registered with it to support the user specified output
+ * and video/graphics modes on that output. First step is to set the output
+ * as requested by the user. To do so, encoder manager iterates through
+ * all supported encoders to match a given output name as requested by the user
+ * by calling enumoutput(). Once there is a match, this encoder is set as the
+ * current active encoder. Encoder manager calls initialize() to init the
+ * encoder and then calls setouput() set the output. If another encoder was
+ * active before this, encoder manager calls deinitialize() to make it
+ * inactive. Encoder must select a default mode for this output as part of
+ * setoutput() call. To set a mode, user call setmode(). All output names and
+ * mode names are defined in vid_encoder_types.h
+ */
+
+#ifndef VID_ENCODER_IF_H
+#define VID_ENCODER_IF_H
+
+#ifdef __KERNEL__
+#include <media/davinci/vid_encoder_types.h>
+
+struct vid_encoder_device;
+/**
+ * struct vid_enc_param_ops
+ * @setparams:
+ * @getparams:
+ *
+ * Description:
+ * Operation used for setting and getting encoder specific parameters.
+ * Operations are applied to the current encoder selected by the
+ * encoder manager
+ * @setparams: pointer to setparams function. This Set Encoder parameters.
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ * @getparams: pointer to getparams function. This Get encoder parameters
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_param_ops {
+	int (*setparams) (void *params, struct vid_encoder_device * enc);
+	int (*getparams) (void *params, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_mode_ops
+ * @setmode:
+ * @getmode:
+ *
+ * Description:
+ *  video/graphics mode ops structure. Operations are applied to the
+ *  current output selected by the encoder
+ * @setmode: Function pointer to setmode. set video/graphics mode or standard
+ *    for current output encoder first check if the std flag is present in the
+ *    mode_info. if yes, it will use name field to match a standard mode. If std
+ *    flag is reset, it may reject the command if non-standard mode
+ *    is not implemented. If non-standard mode is implemented, it would
+ *    save the timing information in the internal structure with a
+ *    key,VID_ENC_STD_NON_STANDARD as defined in vid_encoder_types.h
+ *    It is expected that only one such instance is defined in the video driver.
+ *    Please consider defining a mode in the vid_encoder_types.h
+ *    and use that instead if encoder is to be extended to support additional
+ *    modes not already supported by existing encoders.
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ * @getmode: Function pointer to getmode. get current video/graphics mode
+ *    information at the outpu.t
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_mode_ops {
+	int (*setmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+	int (*getmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_control_ops
+ * @setcontrol:
+ * @getcontrol:
+ *
+ * Description:
+ * Control ops structure. Control operations are performed for the current
+ * output. Control brightness, hue, contrast, saturation etc.
+ * @setcontrol: Function pointer to setcontrol. Set control value.
+ *   ctrl - control type.
+ *   val - value to be set for the control.
+ *   enc - ptr to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getcontrol: Function pointer to getcontrol. Get control value.
+ *   ctrl - control type.
+ *   val - ptr to value that gets updated
+ *   enc - ptr to encoder device
+ *   Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_control_ops {
+	int (*setcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char val, struct vid_encoder_device * enc);
+	int (*getcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char *val, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_output_ops
+ * @count: Indicates number of outputs supported
+ * @enumoutput:
+ * @setoutput:
+ * @getoutput:
+ *
+ * Description:
+ * output ops structure. enumoutput() is called to iterate
+ * through all outputs supported by the encoder. Encoder manager ues
+ * this API to select an encoder based on the output to be supported.
+ * setoutput is called to set output at the encoder. getoutput is called
+ * for getting the current output at the encoder.
+ * @enumoutput:
+ *   Function pointer.
+ *   index - index of the output.
+ *   output - ptr to char array to hold output name.(size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ *   enumerates the outputs supported by encoder. To iterate the output, caller
+ *   call this successively, starting with an index set to 0, and incrementing
+ *   the same until this function returns non-zero. Each time name of the output
+ *   at the given index is copied to output. Beware that this API assumes the
+*   passed in output array size is VID_ENC_NAME_MAX_CHARS.
+ * @setoutput:
+ *   Function pointer.
+ *   setoutput to the given output identifed by name. Encoder also must set a
+ *   default mode on the selected output.
+*   output - ptr to output name string.
+*   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getoutput:
+ *   Function pointer.
+ *   getoutput returns name of current output selected at the encoder.
+ *   output - ptr to char array to hold the output name. (size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_output_ops {
+	int count;
+	int (*enumoutput) (int index,
+			   char *output, struct vid_encoder_device * enc);
+	int (*setoutput) (char *output, struct vid_encoder_device * enc);
+	int (*getoutput) (char *output, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_misc_ops
+ * @reset:
+ * @enable: *
+ * Description:
+ *  misc ops structure. Applied for the current encoder selected by the
+ *  encoder manager
+ * @reset: Function pointer to reset.
+ *    For soft reset. Encoder may implement a soft reset that doesn't affect
+ *    any configured registers. Some of the encoder hardware may require
+ *    this if the input signal timings are changed after configuring it's
+ *    mode registers.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ * @enable: Function pointer to enable.
+ *    enable/disable output. To eliminate noise on the display during SoC mode
+ *    timing configuration, user may call this function to switch Off/On
+ *    the output. Encoder must implement this API call if there is a hardware
+ *    support for the same.
+ *    flag - 0 - disable, 1 - enable.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_misc_ops {
+	int (*reset) (struct vid_encoder_device * enc);
+	int (*enable) (int flag, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_encoder_device
+ * @name: Name of the encoder device
+ * @channel_id:  Id of the channel to which encoder is connected
+ * @capabilities: encoder capabilities. This is only for VBI capabilities
+ * @initialize: Pointer to initialize function to initialize encoder
+ * @mode_ops: Set of functions pointers for standard related functions
+ * @ctrl_ops: Set of functions pointers for control related functions
+ * @output_ops: Set of functions pointers for output related functions
+ * @fmt_ops: Set of functions pointers for format related functions
+ * @params_ops: Set of functions pointers for params related functions
+ * @misc_ops: Set of functions pointers for miscellaneous functions functions
+ * @deinitialize: functions pointer to de-initialize functio
+ * @start_display: function to start display.
+ * @stop_display: function to stop display.
+ * @write_vbi_data: function to write sliced vbi data.
+ * @enable_vbi: Function to enable support for RAW VBI.
+ * @enable_hbi: Function to enable support for RAW HBI.
+ * @set_vbi_services: function to enable sliced vbi services
+ *
+ * Description:
+ * output ops structure
+ *   Channel_id is used when encoder support multiple channels. In this case
+ *   encoder module will use the channel id to select the channel for
+ *   which the operation applies.
+ *   initialize() called by encoder manager to initialize the encoder. Usually
+ *   called before invoking any operations on the encoder.flag may be used by
+ *   the encoder module to do different level of initialization. Encoder
+ *   module must set a default output and mode in this code.
+ *   deinitialize() called to deinitialize the current encoder that is active
+ *   before initializing the new encoder.
+ */
+struct vid_encoder_device {
+	u8 name[VID_ENC_NAME_MAX_CHARS];
+	int channel_id;
+	u32 capabilities;
+	int (*initialize) (struct vid_encoder_device * enc, int flag);
+	struct vid_enc_mode_ops *mode_ops;
+	struct vid_enc_control_ops *ctrl_ops;
+	struct vid_enc_output_ops *output_ops;
+	struct vid_enc_param_ops *params_ops;
+	struct vid_enc_misc_ops *misc_ops;
+	int (*write_vbi_data) (struct vid_enc_sliced_vbi_data * data,
+			       struct vid_encoder_device * enc);
+	int (*enable_vbi) (int flag, struct vid_encoder_device * enc);
+	int (*enable_hbi) (int flag, struct vid_encoder_device * enc);
+	int (*set_vbi_services) (struct vid_enc_sliced_vbi_service * services,
+				 struct vid_encoder_device * enc);
+	int (*get_sliced_cap) (struct vid_enc_sliced_vbi_service *,
+			       struct vid_encoder_device * enc);
+	int (*deinitialize) (struct vid_encoder_device * enc);
+	int (*start_display) (struct vid_encoder_device * enc);
+	int (*stop_display) (struct vid_encoder_device * enc);
+};
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device
+			     *encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device
+			       *encoder);
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_IF_H */
Index: linux-2.6.10/include/media/davinci/vid_encoder_types.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/vid_encoder_types.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * vid_encoder_types.h
+ * This file contains data types which will be used across encoder manager
+ * , encoders and users of both interfaces */
+
+#ifndef VID_ENCODER_TYPES_H
+#define VID_ENCODER_TYPES_H
+
+#ifdef __KERNEL__
+
+/**
+ * enum vid_enc_init_flag
+ * @VID_ENC_I2C_BIND_FLAG: Only I2C bind
+ * @VID_ENC_FULL_INIT_FLAG: Full initialization
+ *
+ * Description:
+ * An enumeration of the encoder initialization flag.
+ */
+enum vid_enc_init_flag {
+	VID_ENC_I2C_BIND_FLAG,
+	VID_ENC_FULL_INIT_FLAG,
+};
+
+/**
+ * enum vid_enc_frame_type
+ * @VID_ENC_FRAME_INTERLACED: Interlaced frame
+ * @VID_ENC_FRAME_PROGRESSIVE: Progressive frame
+ *
+ * Description:
+ * An enumeration of the Frame Formats.
+ */
+enum vid_enc_frame_type {
+	VID_ENC_FRAME_INTERLACED,
+	VID_ENC_FRAME_PROGRESSIVE,
+};
+
+/** VID_ENC_NAME_MAX_CHARS
+ *
+ * Description:
+ * MAX characters in the name.
+ */
+#define VID_ENC_NAME_MAX_CHARS	30
+
+/**
+ * enum vid_enc_if_type
+ * @VID_ENC_IF_INT: for internal DAC
+ * @VID_ENC_IF_BT656: for BT656 input format
+ * @VID_ENC_IF_BT1120: for BT1120 input format
+ * @VID_ENC_IF_YCC8: for YCC8 input format
+ * @VID_ENC_IF_YCC16: for YCC16 input format
+ * @VID_ENC_IF_SRGB: for SRGB input format
+ * @VID_ENC_IF_PRGB: for PRGB input format
+ *
+ * Description:
+ * An enumeration of the encoder interface types.
+ *
+ */
+enum vid_enc_if_type {
+	VID_ENC_IF_INT,
+	VID_ENC_IF_BT656,
+	VID_ENC_IF_BT1120,
+	VID_ENC_IF_YCC8,
+	VID_ENC_IF_YCC16,
+	VID_ENC_IF_SRGB,
+	VID_ENC_IF_PRGB,
+};
+
+/**
+ * constant strings for standard names or mode names. All modules uses this to
+ * refer a specific standard or mode name
+ */
+#define VID_ENC_STD_NTSC         "NTSC"
+#define VID_ENC_STD_NTSC_RGB     "NTSC-RGB"
+#define VID_ENC_STD_PAL          "PAL"
+#define VID_ENC_STD_PAL_RGB      "PAL-RGB"
+#define VID_ENC_STD_720P_25      "720P-25"
+#define VID_ENC_STD_720P_30      "720P-30"
+#define VID_ENC_STD_720P_50      "720P-50"
+#define VID_ENC_STD_720P_60      "720P-60"
+#define VID_ENC_STD_1080I_25     "1080I-25"
+#define VID_ENC_STD_1080I_30     "1080I-30"
+#define VID_ENC_STD_1080P_24	 "1080P-24"
+#define VID_ENC_STD_1080P_25     "1080P-25"
+#define VID_ENC_STD_1080P_30     "1080P-30"
+#define VID_ENC_STD_1080P_50     "1080P-50"
+#define VID_ENC_STD_1080P_60     "1080P-60"
+#define VID_ENC_STD_480P_60      "480P-60"
+#define VID_ENC_STD_576P_50      "576P-50"
+#define VID_ENC_STD_640x480      "640x480"
+#define VID_ENC_STD_640x400      "640x400"
+#define VID_ENC_STD_640x350      "640x350"
+#define VID_ENC_STD_NON_STANDARD "NON-STANDARD"
+
+/**
+ * enum vid_enc_ctrl_id
+ * @VID_ENC_CTRL_GAIN: Gain control
+ * @VID_ENC_CTRL_BRIGHTNESS: Brighness control
+ * @VID_ENC_CTRL_CONTRAST: Contrast control
+ * @VID_ENC_CTRL_HUE: Hue control
+ * @VID_ENC_CTRL_SATURATION: Saturation Control
+ *
+ * Description:
+ * Constants used for control type IDs
+*/
+enum vid_enc_ctrl_id {
+	VID_ENC_CTRL_GAIN,
+	VID_ENC_CTRL_BRIGHTNESS,
+	VID_ENC_CTRL_CONTRAST,
+	VID_ENC_CTRL_HUE,
+	VID_ENC_CTRL_SATURATION,
+};
+
+/**
+ * constant strings for output names. All modules uses this to
+ * refer a specific output at the encoder hardware or VPBE analog output.
+ * May add additional output names as per following convention. First
+ * output of a type is always with out a suffix, and subsequent outputs
+ * of the same type is defined with suffix x increasing from 1 to max
+ * output names supported as shown below.
+ */
+#define VID_ENC_OUTPUT_COMPOSITE  "COMPOSITE"
+#define VID_ENC_OUTPUT_COMPOSITE1 "COMPOSITE1"
+#define VID_ENC_OUTPUT_SVIDEO     "SVIDEO"
+#define VID_ENC_OUTPUT_SVIDEO1    "SVIDEO1"
+#define	VID_ENC_OUTPUT_COMPONENT  "COMPONENT"
+#define	VID_ENC_OUTPUT_COMPONENT1 "COMPONENT1"
+#define VID_ENC_OUTPUT_LCD        "LCD"
+#define VID_ENC_OUTPUT_LCD1       "LCD1"
+
+/**
+ * struct vid_enc_fract
+ * @numerator: numerator part of a fractional number
+ * @denominator: denominator part of a fractional number
+ *
+ * Description:
+ *  Structure used to represent fractional numbers
+ */
+struct vid_enc_fract {
+	unsigned int numerator;
+	unsigned int denominator;
+};
+
+/* Set of macros for sliced vbi services */
+#define VID_ENC_SLICED_VBI_WSS_PAL	0x0001
+#define VID_ENC_SLICED_VBI_CGMS_NTSC	0x0002
+#define VID_ENC_SLICED_VBI_CC_NTSC	0x0004
+
+/**
+ * struct vid_enc_sliced_vbi_service
+ * @service_set: set of services to be enabled in encoder
+ * @line: line number of the field in which data for these
+ * services is to be included.
+ *
+ * Description:
+ *  Structure used to enable set of sliced VBI services in encoder
+ */
+struct vid_enc_sliced_vbi_data {
+
+	unsigned int service_id;
+	unsigned char field;
+	unsigned char data[48];
+};
+
+struct vid_enc_sliced_vbi_service {
+	unsigned short service_set;
+	unsigned int line[2][23];
+};
+
+/**
+ * struct vid_enc_mode_info
+ * @name: ptr to name string of the standard, "NTSC", "PAL" etc
+ * @std: standard or non-standard mode. 1 - standard, 0 - nonstandard
+ * @if_type: interface type used for this standard configuration
+ * @interlaced: 1 - interlaced, 0 - non interlaced/progressive
+ * @xres: x or horizontal resolution of the display
+ * @yres: y or vertical resolution of the display
+ * @fps: frame per second
+ * @left_margin: left margin of the display
+ * @right_margin: right margin of the display
+ * @upper_margin: upper margin of the display
+ * @lower_margin: lower margin of the display
+ * @hsync_len: h-sync length
+ * @vsync_len: v-sync length
+ * @flags: bit field: bit usage is documented below
+ *
+ * Description:
+ *  Structure holding timing and resolution information of a standard.
+ *  Notes
+ *  ------
+ *  if_type should be used only by encoder manager and encoder.
+ *  flags usage
+ *     b0 (LSB) - hsync polarity, 0 - negative, 1 - positive
+ *     b1       - vsync polarity, 0 - negative, 1 - positive
+ *     b2       - field id polarity, 0 - negative, 1  - positive
+ */
+struct vid_enc_mode_info {
+	unsigned char *name;
+	unsigned int std;
+	enum vid_enc_if_type if_type;
+	unsigned int interlaced;
+	unsigned int xres;
+	unsigned int yres;
+	struct vid_enc_fract fps;
+	unsigned int left_margin;
+	unsigned int right_margin;
+	unsigned int upper_margin;
+	unsigned int lower_margin;
+	unsigned int hsync_len;
+	unsigned int vsync_len;
+	unsigned int flags;
+};
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_TYPES_H */
Index: linux-2.6.10/include/media/davinci/vpbe_encoder.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/vpbe_encoder.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef VPBE_ENCODER_H
+#define VPBE_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#endif
+
+#ifdef __KERNEL__
+/* encoder standard related strctures */
+#define VPBE_ENCODER_MAX_NO_OUTPUTS		            (3)
+#define VPBE_ENCODER_MAX_NUM_STD                    (6)
+#define VPBE_DM355_ENCODER_MAX_NO_OUTPUTS		    (1)
+#define VPBE_DM355_ENCODER_COMPOSITE_NUM_STD        (2)
+#define VPBE_DM355_ENCODER_MAX_NUM_STD              (2)
+#define VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS		    (3)
+#define VPBE_DM644X_ENCODER_COMPONENT_NUM_STD		(6)
+#define VPBE_DM644X_ENCODER_SVIDEO_NUM_STD		    (2)
+#define VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD       (2)
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef VPBE_VENC_H */
Index: linux-2.6.10/include/video/davincifb.h
===================================================================
--- linux-2.6.10.orig/include/video/davincifb.h
+++ linux-2.6.10/include/video/davincifb.h
@@ -1,4 +1,5 @@
-/* 
+/*
+ * Copyright (C) 2007 MontaVista Software Inc.
  * Copyright (C) 2006 Texas Instruments Inc
  *
  * This program is free software; you can redistribute it and/or modify
@@ -14,535 +15,47 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davincifb.h	
- */
-
-#ifndef DAVINVI_VPBE_H
-#define DAVINVI_VPBE_H
-
-/* include Linux files */
-#include <linux/fb.h>
-
-/* define the custom FBIO_WAITFORVSYNC ioctl */
-#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
-#define FBIO_SETATTRIBUTE       _IOW('F', 0x21, struct fb_fillrect)
-
-/* Backported IOCTLS. */
-#define FBIO_SETPOSX                            _IOW('F', 0x22, u_int32_t)
-#define FBIO_SETPOSY                            _IOW('F', 0x23, u_int32_t)
-#define FBIO_SETZOOM            		_IOW('F', 0x24, struct zoom_params)
-#define FBIO_GETSTD                             _IOR('F', 0x25, u_int32_t)
-
-typedef struct zoom_params {
-	u_int32_t window_id;
-	u_int32_t zoom_h;
-	u_int32_t zoom_v;
-} zoom_params_t;
-
-#define	RAM_CLUT_SIZE	256*3
-#define FBIO_ENABLE_DISABLE_WIN		\
-	_IOW('F', 0x30, unsigned char)
-#define FBIO_SET_BITMAP_BLEND_FACTOR	\
-	_IOW('F', 0x31, sizeof(vpbe_bitmap_blend_params_t))
-#define FBIO_SET_BITMAP_WIN_RAM_CLUT    \
-	_IOW('F', 0x32, sizeof(unsigned char)*RAM_CLUT_SIZE)
-#define FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN \
-	_IOW('F', 0x33, unsigned int)
-#define FBIO_GET_BLINK_INTERVAL		\
-	_IOR('F', 0x34, sizeof(vpbe_blink_option_t))
-#define FBIO_SET_BLINK_INTERVAL         \
-	_IOW('F', 0x35, sizeof(vpbe_blink_option_t))
-#define FBIO_GET_VIDEO_CONFIG_PARAMS    \
-	_IOR('F', 0x36, sizeof(vpbe_video_config_params_t))
-#define FBIO_SET_VIDEO_CONFIG_PARAMS    \
-	_IOW('F', 0x37, sizeof(vpbe_video_config_params_t))
-#define FBIO_GET_BITMAP_CONFIG_PARAMS   \
-	_IOR('F', 0x38, sizeof(vpbe_bitmap_config_params_t))
-#define FBIO_SET_BITMAP_CONFIG_PARAMS   \
-	_IOW('F', 0x39, sizeof(vpbe_bitmap_config_params_t))
-#define FBIO_SET_DCLK                   \
-	_IOW('F', 0x40, sizeof(vpbe_dclk_t))
-#define FBIO_SET_INTERFACE		\
-	_IOW('F', 0x41, unsigned char)
-#define FBIO_GET_INTERFACE		\
-	_IOR('F', 0x42, unsigned char)
-#define FBIO_QUERY_TIMING		\
-	_IOWR('F', 0x43, sizeof(struct vpbe_mode_info))
-#define FBIO_SET_TIMING			\
-	_IOW('F', 0x44, sizeof(struct vpbe_fb_videomode))
-#define FBIO_GET_TIMING                 \
-	_IOR('F', 0x45, sizeof(struct vpbe_fb_videomode))
-#define FBIO_SET_VENC_CLK_SOURCE	\
-	_IOW('F', 0x46, unsigned char)
-#define FBIO_SET_BACKG_COLOR            \
-	_IOW('F', 0x47, sizeof(vpbe_backg_color_t))
-#define FBIO_ENABLE_DISPLAY		\
-	_IOW('F', 0x48, unsigned char)
-#define FBIO_SETPOS            		\
-	_IOW('F', 0x49, u_int32_t)
-#define FBIO_SET_CURSOR         	\
-	_IOW('F', 0x50, struct fb_cursor)
-
-/* 
- * Defines and Constants
  */
-#ifdef __KERNEL__
-#define DAVINCIFB_DEVICE "davincifb"
-#define DAVINCIFB_DRIVER "davincifb"
-
-#define MULTIPLE_BUFFERING      1
-
-#ifdef MULTIPLE_BUFFERING
-#define DOUBLE_BUF      2
-#define TRIPLE_BUF      3
-#else
-#define DOUBLE_BUF      1
-#define TRIPLE_BUF      1
-#endif
 
-/* usage:	if (is_win(info->fix.id, OSD0)) ... */
-#define is_win(name, x) ((strcmp(name, x ## _FBNAME) == 0) ? 1 : 0)
+#ifndef DAVINCIFB_H
+#define DAVINCIFB_H
 
-/*
- * display controller register I/O routines
- */
-u32 dispc_reg_in(u32 offset);
-u32 dispc_reg_out(u32 offset, u32 val);
-u32 dispc_reg_merge(u32 offset, u32 val, u32 mask);
+#define DAVINCIFB_NAME "davincifb"
 
-#endif				/*__KERNEL__*/
-
-/*  Error return codes  */
-#define VPBE_INVALID_PARA_VALUE         700
-#define VPBE_WRONG_WINDOW_ID            701
-#define VPBE_CURRENTLY_IN_REQUIRED_MODE 702
-#define VPBE_INSUFFICIENT_CLUT_VALUES   703
-#define VPBE_CLUT_WRITE_TIMEOUT         704
-#define VPBE_VID0_BUF_ADR_NULL          705
-#define VPBE_WINDOW_NOT_DISABLED        706
-#define VPBE_WINDOW_NOT_ENABLED         707
-
-#ifndef __KERNEL__
-/*  Window ID definations */
-#define OSD0      0
-#define VID0      1
-#define OSD1      2
-#define VID1      3
-#endif
-
-/* There are 4 framebuffers, each represented by an fb_info and
- * a dm_win_info structure */
+/* There are 4 framebuffer devices, one per window. */
 #define OSD0_FBNAME "dm_osd0_fb"
 #define OSD1_FBNAME "dm_osd1_fb"
 #define VID0_FBNAME "dm_vid0_fb"
 #define VID1_FBNAME "dm_vid1_fb"
 
-/*  FIXME: Digital LCD RGB matrix coefficients */
-#define DLCD_DGY_VAL    0
-#define DLCD_DRV_VAL    0
-#define DLCD_DGU_VAL    0
-#define DLCD_DBU_VAL		0
-
-/* Defines for bitmap format */
-#define VPBE_BITMAP_BIT_1	1
-#define VPBE_BITMAP_BIT_2	2
-#define VPBE_BITMAP_BIT_4	4
-#define VPBE_BITMAP_BIT_8	8
-#define VPBE_BITMAP_RGB565	16
-#define VPBE_VIDEO_YUV422 	16
-#define VPBE_VIDEO_RGB888 	24
-
-/* Defines foe cursor parameter validation*/
-#define MAX_CURSOR_WIDTH	0x3FF
-#define MAX_CURSOR_HEIGHT	0x1FF
-#define MAX_CURSOR_LINEWIDTH    7
-
-#define BASEX		0x80
-#define BASEY		0x12
-#define BASEX_DLCD		0x59
-#define BASEY_DLCD		0x22
-
-/*
- * Enumerations 
- */
-/*  Enum for blending factor  */
-typedef enum vpbe_blend_factor {
-	OSD_CONTRIBUTION_ZERO = 0,
-	OSD_CONTRIBUTION_1_BY_8 = 1,
-	OSD_CONTRIBUTION_2_BY_8 = 2,
-	OSD_CONTRIBUTION_3_BY_8 = 3,
-	OSD_CONTRIBUTION_4_BY_8 = 4,
-	OSD_CONTRIBUTION_5_BY_8 = 5,
-	OSD_CONTRIBUTION_6_BY_8 = 6,
-	OSD_CONTRIBUTION_ONE = 7
-} vpbe_blend_factor_t;
-
-/*  Enum for Boolean variables  */
-typedef enum {
-	SET_0 = 0,
-	SET_1 = 1
-} CB_CR_ORDER, ATTRIBUTE, ROM_RAM_CLUT;
-
-/*  Defines for Display Interface */
-#define  PRGB		0
-#define  COMPOSITE      1
-#define  SVIDEO    	2
-#define  COMPONENT 	3
-#define  RGB       	4
-#define  YCC16     	5
-#define  YCC8      	6
-#define  SRGB      	7
-#define  EPSON     	8
-#define  CASIO1G   	9
-#define  UDISP     	10
-#define  STN       	11
-#define VPBE_MAX_INTERFACES	12
-
-/*  Defines for Display Mode */
-#define  LCD    0
-#define  NTSC	1
-#define  PAL    2
-#define  P525   3
-#define  P625   4
-
-#define DEFAULT_MODE 0
-#define  P480   0
-#define  P400   1
-#define  P350   2
-#define NON_EXISTING_MODE 255
-/*  Enable/Disable enum */
-typedef enum {
-	VPBE_DISABLE = 0,
-	VPBE_ENABLE = 1
-} ATTENUATION, TRANSPARENCY, EXPANSION, BLINKING;
-
-typedef enum clk_source {
-	CLK_SOURCE_CLK27 = 0,
-	CLK_SOURCE_CLK54 = 1,
-	CLK_SOURCE_VPBECLK = 2
-} CLK_SOURCE;
-
-/*
- * Structures and Union Definitions
- */
-
-/*  Structure for transparency and the blending factor for the bitmap window  */
-typedef struct vpbe_bitmap_blend_params {
-	unsigned int colorkey;	/* color key to be blend */
-	unsigned int enable_colorkeying;	/* enable color keying */
-	unsigned int bf;	/* valid range from 0 to 7 only. */
-} vpbe_bitmap_blend_params_t;
-
-/*  Structure for window expansion  */
-typedef struct vpbe_win_expansion {
-	EXPANSION horizontal;
-	EXPANSION vertical;	/* 1: Enable 0:disable */
-} vpbe_win_expansion_t;
-
-/*  Structure for OSD window blinking options */
-typedef struct vpbe_blink_option {
-	BLINKING blinking;	/* 1: Enable blinking 0: Disable */
-	unsigned int interval;	/* Valid only if blinking is 1 */
-} vpbe_blink_option_t;
-
-/*  Structure for DCLK parameters */
-typedef struct vpbe_dclk {
-	unsigned char dclk_pattern_width;
-	unsigned int dclk_pattern0;
-	unsigned int dclk_pattern1;
-	unsigned int dclk_pattern2;
-	unsigned int dclk_pattern3;
-} vpbe_dclk_t;
-
-/*  Structure for display format  */
-typedef struct vpbe_display_format {
-	unsigned char interface;	/* Output interface type */
-	unsigned char mode;	/* output mode */
-} vpbe_display_format_t;
-
-/*  Structure for background color  */
-typedef struct vpbe_backg_color {
-	unsigned char clut_select;	/* 2: RAM CLUT 1:ROM1 CLUT 0:ROM0 CLUT */
-	unsigned char color_offset;	/* index of color */
-} vpbe_backg_color_t;
-
-/*  Structure for Video window configurable parameters  */
-typedef struct vpbe_video_config_params {
-	CB_CR_ORDER cb_cr_order;	/*Cb/Cr order in input data for a pixel. */
-	/*    0: cb cr  1:  cr cb */
-	vpbe_win_expansion_t exp_info;	/* HZ/VT Expansion enable disable */
-} vpbe_video_config_params_t;
-
-/*Union of structures giving the CLUT index for the 1, 2, 4 bit bitmap values.*/
-typedef union vpbe_clut_idx {
-	struct _for_4bit_bimap {
-		unsigned char bitmap_val_0;
-		unsigned char bitmap_val_1;
-		unsigned char bitmap_val_2;
-		unsigned char bitmap_val_3;
-		unsigned char bitmap_val_4;
-		unsigned char bitmap_val_5;
-		unsigned char bitmap_val_6;
-		unsigned char bitmap_val_7;
-		unsigned char bitmap_val_8;
-		unsigned char bitmap_val_9;
-		unsigned char bitmap_val_10;
-		unsigned char bitmap_val_11;
-		unsigned char bitmap_val_12;
-		unsigned char bitmap_val_13;
-		unsigned char bitmap_val_14;
-		unsigned char bitmap_val_15;
-	} for_4bit_bimap;
-	struct _for_2bit_bimap {
-		unsigned char bitmap_val_0;
-		unsigned char dummy0[4];
-		unsigned char bitmap_val_1;
-		unsigned char dummy1[4];
-		unsigned char bitmap_val_2;
-		unsigned char dummy2[4];
-		unsigned char bitmap_val_3;
-	} for_2bit_bimap;
-	struct _for_1bit_bimap {
-		unsigned char bitmap_val_0;
-		unsigned char dummy0[14];
-		unsigned char bitmap_val_1;
-	} for_1bit_bimap;
-} vpbe_clut_idx_t;
-
-/*  Structure for bitmap window configurable parameters */
-typedef struct vpbe_bitmap_config_params {
-	/* Only for bitmap width = 1,2,4 bits */
-	vpbe_clut_idx_t clut_idx;
-	/* Attenuation value for YUV o/p for bitmap window */
-	unsigned char attenuation_enable;
-	/* 0: ROM DM270, 1:ROM DM320, 2:RAM CLUT */
-	unsigned char clut_select;
-} vpbe_bitmap_config_params_t;
-
-/*  Unioun for video/OSD configuration parameters  */
-typedef union vpbe_conf_params {
-
-	struct vpbe_video_params {
-		CB_CR_ORDER cb_cr_order;
-		/* HZ/VT Expansion enable disable */
-		vpbe_win_expansion_t exp_info;
-	} video_params;
-
-	struct vpbe_bitmap_params {
-		/* Attenuation value for YUV o/p */
-		ATTENUATION attenuation_enable;
-		/* 0: ROM DM270, 1: ROM DM320, 2:RAM CLUT */
-		unsigned char clut_select;
-		/* Only for bitmap width = 1,2,4 bits */
-		vpbe_clut_idx_t clut_idx;
-		/* 0: OSD window is bitmap window */
-		/* 1: OSD window is attribute window */
-		ATTRIBUTE enable_attribute;
-		/* To hold bps value. 
-		   Used to switch back from attribute to bitmap. */
-		unsigned int stored_bits_per_pixel;
-		/* Blending information */
-		vpbe_bitmap_blend_params_t blend_info;
-		/* OSD Blinking information */
-		vpbe_blink_option_t blink_info;
-	} bitmap_params;
-
-} vpbe_conf_params_t;
-
-typedef struct vpbe_video_params vpbe_video_params_t;
-typedef struct vpbe_bitmap_params vpbe_bitmap_params_t;
-
-/* Structure to hold window position */
-typedef struct vpbe_window_position {
-	unsigned int xpos;	/* X position of the window */
-	unsigned int ypos;	/* Y position of the window */
-} vpbe_window_position_t;
-
-#ifdef __KERNEL__
 /*  Structure for each window */
-typedef struct vpbe_dm_win_info {
-	struct fb_info info;
-	vpbe_window_position_t win_pos;	/* X,Y position of window */
-	/* Size of window is already there in var_info structure. */
-
-	dma_addr_t fb_base_phys;	/*framebuffer area */
-	unsigned int fb_base;	/*window memory pointer */
-	unsigned int fb_size;	/*memory size */
-	unsigned int pseudo_palette[17];
-	int alloc_fb_mem;
-	/*flag to identify if framebuffer area is fixed or not */
-	unsigned long sdram_address;
+struct vpbe_dm_win_info {
+	struct fb_info *info;
 	struct vpbe_dm_info *dm;
-	unsigned char window_enable;	/*Additions for all windows */
-	zoom_params_t zoom;	/*Zooming parameters */
-	unsigned char field_frame_select;	/*To select Field or frame */
-	unsigned char numbufs;	/*Number of buffers valid 2 or 3 */
-	vpbe_conf_params_t conf_params;
-	/*window configuration parameter union pointer */
-} vpbe_dm_win_info_t;
-#endif				/*__KERNEL__*/
+	enum davinci_disp_layer layer;
+	unsigned xpos;
+	unsigned ypos;
+	unsigned own_window; /* Does the framebuffer driver own this window? */
+	unsigned display_window;
+	u32 pseudo_palette[16];
+};
 
 /*
- *  Videmode structure for display interface and mode settings
- */
-typedef struct vpbe_fb_videomode {
-	unsigned char name[10];	/* Mode name ( NTSC , PAL) */
-	unsigned int vmode;	/* FB_MODE_INTERLACED or FB_MODE_NON_INTERLACED */
-	unsigned int xres;	/* X Resolution of the display */
-	unsigned int yres;	/* Y Resolution of the display */
-	unsigned int fps;	/* frames per second */
-	/* Timing Parameters applicable for std = 0 only */
-	unsigned int left_margin;
-	unsigned int right_margin;
-	unsigned int upper_margin;
-	unsigned int lower_margin;
-	unsigned int hsync_len;
-	unsigned int vsync_len;
-	unsigned int sync;	/* 0: hsync -ve/vsync -ve */
-	/*1: hsync -ve/vsync +ve */
-	/*2: hsync +ve/vsync -ve */
-	/*3: hsync +ve/vsync +ve */
-	unsigned int basepx;	/* Display x,y start position */
-	unsigned int basepy;
-/*  1= Mode s available in modelist 0=Mode is not available in modelist */
-	unsigned int std;
-} vpbe_fb_videomode_t;
-
-/* Structure to interface videomode to application*/
-typedef struct vpbe_mode_info {
-	vpbe_fb_videomode_t vid_mode;
-	unsigned char interface;
-	unsigned char mode_idx;
-} vpbe_mode_info_t;
-
-#ifdef __KERNEL__
-/* 
- * Structure for the driver holding information of windows, 
+ * Structure for the driver holding information of windows,
  *  memory base addresses etc.
  */
-typedef struct vpbe_dm_info {
-	vpbe_dm_win_info_t *osd0;
-	vpbe_dm_win_info_t *osd1;
-	vpbe_dm_win_info_t *vid0;
-	vpbe_dm_win_info_t *vid1;
-
-/* to map the registers */
-	dma_addr_t mmio_base_phys;
-	unsigned int mmio_base;
-	unsigned int mmio_size;
+struct vpbe_dm_info {
+	struct vpbe_dm_win_info win[4];
 
 	wait_queue_head_t vsync_wait;
 	unsigned int vsync_cnt;
 	int timeout;
+	struct davinci_disp_callback vsync_callback;
 
-	/* this is the function that configures the output device (NTSC/PAL/LCD)
-	 * for the required output format (composite/s-video/component/rgb)
-	 */
-	void (*output_device_config) (void);
-
-	struct device *dev;
+	unsigned char ram_clut[256][3];
+	enum davinci_pix_format yc_pixfmt;
 
-	vpbe_backg_color_t backg;	/* background color */
-	vpbe_dclk_t dclk;	/*DCLK parameters */
-	vpbe_display_format_t display;	/*Display interface and mode */
-	vpbe_fb_videomode_t videomode;	/*Cuurent videomode */
-	char ram_clut[256][3];	/*RAM CLUT array */
-	struct fb_cursor cursor;	/* cursor config params from fb.h */
-/*Flag that indicates whether any of the display is enabled or not*/
-	int display_enable;
-} vpbe_dm_info_t;
-
-/*
- * Functions Definitions for 'davincifb' module
- */
-int vpbe_mem_alloc_window_buf(vpbe_dm_win_info_t *);
-int vpbe_mem_release_window_buf(vpbe_dm_win_info_t *);
-void init_display_function(vpbe_display_format_t *);
-int vpbe_mem_alloc_struct(vpbe_dm_win_info_t **);
-void set_vid0_default_conf(void);
-void set_vid1_default_conf(void);
-void set_osd0_default_conf(void);
-void set_osd1_default_conf(void);
-void set_cursor_default_conf(void);
-void set_dm_default_conf(void);
-void set_win_enable(char *, unsigned int);
-int within_vid0_limits(u32, u32, u32, u32);
-void vpbe_set_display_default(void);
-#ifdef __KERNEL__
-void set_win_position(char *, u32, u32, u32, u32);
-void change_win_param(int);
-void set_interlaced(char *, unsigned int);
-#endif /* __KERNEL__ */
-
-/*
- *	Function definations for 'osd' module
- */
-
-int vpbe_enable_window(vpbe_dm_win_info_t *);
-int vpbe_disable_window(vpbe_dm_win_info_t *);
-int vpbe_vid_osd_select_field_frame(u8 *, u8);
-int vpbe_bitmap_set_blend_factor(u8 *, vpbe_bitmap_blend_params_t *);
-int vpbe_bitmap_set_ram_clut(void);
-int vpbe_enable_disable_attribute_window(u32);
-int vpbe_get_blinking(u8 *, vpbe_blink_option_t *);
-int vpbe_set_blinking(u8 *, vpbe_blink_option_t *);
-int vpbe_set_vid_params(u8 *, vpbe_video_config_params_t *);
-int vpbe_get_vid_params(u8 *, vpbe_video_config_params_t *);
-int vpbe_bitmap_get_params(u8 *, vpbe_bitmap_config_params_t *);
-int vpbe_bitmap_set_params(u8 *, vpbe_bitmap_config_params_t *);
-int vpbe_set_cursor_params(struct fb_cursor *);
-int vpbe_set_vid_expansion(vpbe_win_expansion_t *);
-int vpbe_set_dclk(vpbe_dclk_t *);
-int vpbe_set_display_format(vpbe_display_format_t *);
-int vpbe_set_backg_color(vpbe_backg_color_t *);
-int vpbe_set_interface(u8);
-int vpbe_query_mode(vpbe_mode_info_t *);
-int vpbe_set_mode(struct vpbe_fb_videomode *);
-int vpbe_set_venc_clk_source(u8);
-void set_vid0_default_conf(void);
-void set_osd0_default_conf(void);
-void set_vid1_default_conf(void);
-void set_osd1_default_conf(void);
-void set_cursor_default_conf(void);
-void set_dm_default_conf(void);
-/*
- * Function definations for 'venc' module
- */
-
-void davincifb_ntsc_composite_config(void);
-void davincifb_ntsc_svideo_config(void);
-void davincifb_ntsc_component_config(void);
-void davincifb_pal_composite_config(void);
-void davincifb_pal_svideo_config(void);
-void davincifb_pal_component_config(void);
-
-void vpbe_davincifb_ntsc_rgb_config(void);
-void vpbe_davincifb_pal_rgb_config(void);
-void vpbe_davincifb_525p_component_config(void);
-void vpbe_davincifb_625p_component_config(void);
-
-void vpbe_enable_venc(int);
-void vpbe_enable_dacs(int);
-/*
- * Function definations for 'dlcd' module
- */
-void vpbe_davincifb_480p_prgb_config(void);
-void vpbe_davincifb_400p_prgb_config(void);
-void vpbe_davincifb_350p_prgb_config(void);
-void vpbe_set_display_timing(struct vpbe_fb_videomode *);
-
-void vpbe_enable_lcd(int);
-/*
- * Following functions are not implemented
- */
-void vpbe_davincifb_default_ycc16_config(void);
-void vpbe_davincifb_default_ycc8_config(void);
-void vpbe_davincifb_default_srgb_config(void);
-void vpbe_davincifb_default_epson_config(void);
-void vpbe_davincifb_default_casio_config(void);
-void vpbe_davincifb_default_UDISP_config(void);
-void vpbe_davincifb_default_STN_config(void);
-#endif				/*__KERNEL__*/
+	struct fb_videomode mode;
+};
 
-#endif				/* End of #ifndef DAVINCI_VPBE_H */
+#endif				/* ifndef DAVINCIFB__H */
Index: linux-2.6.10/include/video/davincifb_ioctl.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/video/davincifb_ioctl.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef DAVINCIFB_IOCTL_H
+#define DAVINCIFB_IOCTL_H
+
+/*
+ * Enumerations
+ */
+
+/*  Enum for Boolean variables  */
+typedef enum {
+	SET_0 = 0,
+	SET_1 = 1
+} CB_CR_ORDER, ATTRIBUTE;
+
+/*  Enable/Disable enum */
+typedef enum {
+	VPBE_DISABLE = 0,
+	VPBE_ENABLE = 1
+} ATTENUATION, EXPANSION, BLINKING;
+
+/*
+ * Structures and Union Definitions
+ */
+
+typedef struct zoom_params {
+	u_int32_t window_id;
+	u_int32_t zoom_h;
+	u_int32_t zoom_v;
+} zoom_params_t;
+
+/* Structure for transparency and the blending factor for the bitmap window */
+typedef struct vpbe_bitmap_blend_params {
+	unsigned int colorkey;	/* color key to be blended */
+	unsigned int enable_colorkeying;	/* enable color keying */
+	unsigned int bf;	/* valid range from 0 to 7 only. */
+} vpbe_bitmap_blend_params_t;
+
+/*  Structure for window expansion  */
+typedef struct vpbe_win_expansion {
+	EXPANSION horizontal;
+	EXPANSION vertical;	/* 1: Enable 0:disable */
+} vpbe_win_expansion_t;
+
+/*  Structure for OSD window blinking options */
+typedef struct vpbe_blink_option {
+	BLINKING blinking;	/* 1: Enable blinking 0: Disable */
+	unsigned int interval;	/* Valid only if blinking is 1 */
+} vpbe_blink_option_t;
+
+/*  Structure for background color  */
+typedef struct vpbe_backg_color {
+	unsigned char clut_select;	/* 2: RAM CLUT 1:ROM1 CLUT 0:ROM0 CLUT */
+	unsigned char color_offset;	/* index of color */
+} vpbe_backg_color_t;
+
+/*  Structure for Video window configurable parameters  */
+typedef struct vpbe_video_config_params {
+	CB_CR_ORDER cb_cr_order;	/* Cb/Cr order in input data for a pixel. */
+	/*    0: cb cr  1:  cr cb */
+	vpbe_win_expansion_t exp_info;	/* HZ/VT Expansion enable disable */
+} vpbe_video_config_params_t;
+
+/*
+ * Union of structures giving the CLUT index for the 1, 2, 4 bit bitmap values
+ */
+typedef union vpbe_clut_idx {
+	struct _for_4bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char bitmap_val_1;
+		unsigned char bitmap_val_2;
+		unsigned char bitmap_val_3;
+		unsigned char bitmap_val_4;
+		unsigned char bitmap_val_5;
+		unsigned char bitmap_val_6;
+		unsigned char bitmap_val_7;
+		unsigned char bitmap_val_8;
+		unsigned char bitmap_val_9;
+		unsigned char bitmap_val_10;
+		unsigned char bitmap_val_11;
+		unsigned char bitmap_val_12;
+		unsigned char bitmap_val_13;
+		unsigned char bitmap_val_14;
+		unsigned char bitmap_val_15;
+	} for_4bit_bitmap;
+	struct _for_2bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char dummy0[4];
+		unsigned char bitmap_val_1;
+		unsigned char dummy1[4];
+		unsigned char bitmap_val_2;
+		unsigned char dummy2[4];
+		unsigned char bitmap_val_3;
+	} for_2bit_bitmap;
+	struct _for_1bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char dummy0[14];
+		unsigned char bitmap_val_1;
+	} for_1bit_bitmap;
+} vpbe_clut_idx_t;
+
+/* Structure for bitmap window configurable parameters */
+typedef struct vpbe_bitmap_config_params {
+	/* Only for bitmap width = 1,2,4 bits */
+	vpbe_clut_idx_t clut_idx;
+	/* Attenuation value for YUV o/p for bitmap window */
+	unsigned char attenuation_enable;
+	/* 0: ROM DM270, 1:ROM DM320, 2:RAM CLUT */
+	unsigned char clut_select;
+} vpbe_bitmap_config_params_t;
+
+/* Structure to hold window position */
+typedef struct vpbe_window_position {
+	unsigned int xpos;	/* X position of the window */
+	unsigned int ypos;	/* Y position of the window */
+} vpbe_window_position_t;
+
+#define	RAM_CLUT_SIZE	256*3
+
+/* custom ioctl definitions */
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
+#define FBIO_SETATTRIBUTE	_IOW('F', 0x21, struct fb_fillrect)
+#define FBIO_SETPOSX		_IOW('F', 0x22, u_int32_t)
+#define FBIO_SETPOSY		_IOW('F', 0x23, u_int32_t)
+#define FBIO_SETZOOM		_IOW('F', 0x24, struct zoom_params)
+#define FBIO_ENABLE_DISABLE_WIN		\
+	_IOW('F', 0x30, unsigned char)
+#define FBIO_SET_BITMAP_BLEND_FACTOR	\
+	_IOW('F', 0x31, sizeof(vpbe_bitmap_blend_params_t))
+#define FBIO_SET_BITMAP_WIN_RAM_CLUT	\
+	_IOW('F', 0x32, sizeof(unsigned char)*RAM_CLUT_SIZE)
+#define FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN \
+	_IOW('F', 0x33, unsigned int)
+#define FBIO_GET_BLINK_INTERVAL		\
+	_IOR('F', 0x34, sizeof(vpbe_blink_option_t))
+#define FBIO_SET_BLINK_INTERVAL		\
+	_IOW('F', 0x35, sizeof(vpbe_blink_option_t))
+#define FBIO_GET_VIDEO_CONFIG_PARAMS	\
+	_IOR('F', 0x36, sizeof(vpbe_video_config_params_t))
+#define FBIO_SET_VIDEO_CONFIG_PARAMS	\
+	_IOW('F', 0x37, sizeof(vpbe_video_config_params_t))
+#define FBIO_GET_BITMAP_CONFIG_PARAMS	\
+	_IOR('F', 0x38, sizeof(vpbe_bitmap_config_params_t))
+#define FBIO_SET_BITMAP_CONFIG_PARAMS	\
+	_IOW('F', 0x39, sizeof(vpbe_bitmap_config_params_t))
+#define FBIO_SET_BACKG_COLOR		\
+	_IOW('F', 0x47, sizeof(vpbe_backg_color_t))
+#define FBIO_SETPOS			\
+	_IOW('F', 0x49, u_int32_t)
+#define FBIO_SET_CURSOR			\
+	_IOW('F', 0x50, struct fb_cursor)
+
+/*  Window ID definitions */
+#define OSD0 0
+#define VID0 1
+#define OSD1 2
+#define VID1 3
+
+#endif				/* ifndef DAVINCIFB_IOCTL_H */
Index: linux-2.6.10/include/video/davinci_osd.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/video/davinci_osd.h
@@ -0,0 +1,887 @@
+/*
+ * Header file for the TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef _DAVINCI_OSD_H
+#define _DAVINCI_OSD_H
+
+/**
+ * enum davinci_disp_layer
+ * @WIN_OSD0: On-Screen Display Window 0
+ * @WIN_VID0: Video Window 0
+ * @WIN_OSD1: On-Screen Display Window 1
+ * @WIN_VID1: Video Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci display layers.
+ */
+enum davinci_disp_layer {
+	WIN_OSD0,
+	WIN_VID0,
+	WIN_OSD1,
+	WIN_VID1,
+};
+
+/**
+ * enum davinci_osd_layer
+ * @OSDWIN_OSD0: On-Screen Display Window 0
+ * @OSDWIN_OSD1: On-Screen Display Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci OSD layers.
+ */
+enum davinci_osd_layer {
+	OSDWIN_OSD0,
+	OSDWIN_OSD1,
+};
+
+/**
+ * enum davinci_pix_format
+ * @PIXFMT_1BPP: 1-bit-per-pixel bitmap
+ * @PIXFMT_2BPP: 2-bits-per-pixel bitmap
+ * @PIXFMT_4BPP: 4-bits-per-pixel bitmap
+ * @PIXFMT_8BPP: 8-bits-per-pixel bitmap
+ * @PIXFMT_RGB565: 16-bits-per-pixel RGB565
+ * @PIXFMT_YCbCrI: YUV 4:2:2
+ * @PIXFMT_RGB888: 24-bits-per-pixel RGB888
+ * @PIXFMT_YCrCbI: YUV 4:2:2 with chroma swap
+ * @PIXFMT_OSD_ATTR: OSD Attribute Window pixel format (4bpp)
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel formats.
+ */
+enum davinci_pix_format {
+	PIXFMT_1BPP = 0,
+	PIXFMT_2BPP,
+	PIXFMT_4BPP,
+	PIXFMT_8BPP,
+	PIXFMT_RGB565,
+	PIXFMT_YCbCrI,
+	PIXFMT_RGB888,
+	PIXFMT_YCrCbI,
+	PIXFMT_OSD_ATTR,
+};
+
+/**
+ * enum davinci_h_exp_ratio
+ * @H_EXP_OFF: no expansion (1/1)
+ * @H_EXP_9_OVER_8: 9/8 expansion ratio
+ * @H_EXP_3_OVER_2: 3/2 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available horizontal expansion ratios.
+ */
+enum davinci_h_exp_ratio {
+	H_EXP_OFF,
+	H_EXP_9_OVER_8,
+	H_EXP_3_OVER_2,
+};
+
+/**
+ * enum davinci_v_exp_ratio
+ * @V_EXP_OFF: no expansion (1/1)
+ * @V_EXP_6_OVER_5: 6/5 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available vertical expansion ratios.
+ */
+enum davinci_v_exp_ratio {
+	V_EXP_OFF,
+	V_EXP_6_OVER_5,
+};
+
+/**
+ * enum davinci_zoom_factor
+ * @ZOOM_X1: no zoom (x1)
+ * @ZOOM_X2: x2 zoom
+ * @ZOOM_X4: x4 zoom
+ *
+ * Description:
+ * An enumeration of the available zoom factors.
+ */
+enum davinci_zoom_factor {
+	ZOOM_X1,
+	ZOOM_X2,
+	ZOOM_X4,
+};
+
+/**
+ * enum davinci_clut
+ * @ROM_CLUT: ROM CLUT
+ * @RAM_CLUT: RAM CLUT
+ *
+ * Description:
+ * An enumeration of the available Color Lookup Tables (CLUTs).
+ */
+enum davinci_clut {
+	ROM_CLUT,
+	RAM_CLUT,
+};
+
+/**
+ * enum davinci_rom_clut
+ * @ROM_CLUT0: Macintosh CLUT
+ * @ROM_CLUT1: CLUT from DM270 and prior devices
+ *
+ * Description:
+ * An enumeration of the ROM Color Lookup Table (CLUT) options.
+ */
+enum davinci_rom_clut {
+	ROM_CLUT0,
+	ROM_CLUT1,
+};
+
+/**
+ * enum davinci_blending_factor
+ * @OSD_0_VID_8: OSD pixels are fully transparent
+ * @OSD_1_VID_7: OSD pixels contribute 1/8, video pixels contribute 7/8
+ * @OSD_2_VID_6: OSD pixels contribute 2/8, video pixels contribute 6/8
+ * @OSD_3_VID_5: OSD pixels contribute 3/8, video pixels contribute 5/8
+ * @OSD_4_VID_4: OSD pixels contribute 4/8, video pixels contribute 4/8
+ * @OSD_5_VID_3: OSD pixels contribute 5/8, video pixels contribute 3/8
+ * @OSD_6_VID_2: OSD pixels contribute 6/8, video pixels contribute 2/8
+ * @OSD_8_VID_0: OSD pixels are fully opaque
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blending factor options.
+ */
+enum davinci_blending_factor {
+	OSD_0_VID_8,
+	OSD_1_VID_7,
+	OSD_2_VID_6,
+	OSD_3_VID_5,
+	OSD_4_VID_4,
+	OSD_5_VID_3,
+	OSD_6_VID_2,
+	OSD_8_VID_0,
+};
+
+/**
+ * enum davinci_blink_interval
+ * @BLINK_X1: blink interval is 1 vertical refresh cycle
+ * @BLINK_X2: blink interval is 2 vertical refresh cycles
+ * @BLINK_X3: blink interval is 3 vertical refresh cycles
+ * @BLINK_X4: blink interval is 4 vertical refresh cycles
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blinking interval options.
+ */
+enum davinci_blink_interval {
+	BLINK_X1,
+	BLINK_X2,
+	BLINK_X3,
+	BLINK_X4,
+};
+
+/**
+ * enum davinci_cursor_h_width
+ * @H_WIDTH_1: horizontal line width is 1 pixel
+ * @H_WIDTH_4: horizontal line width is 4 pixels
+ * @H_WIDTH_8: horizontal line width is 8 pixels
+ * @H_WIDTH_12: horizontal line width is 12 pixels
+ * @H_WIDTH_16: horizontal line width is 16 pixels
+ * @H_WIDTH_20: horizontal line width is 20 pixels
+ * @H_WIDTH_24: horizontal line width is 24 pixels
+ * @H_WIDTH_28: horizontal line width is 28 pixels
+ */
+enum davinci_cursor_h_width {
+	H_WIDTH_1,
+	H_WIDTH_4,
+	H_WIDTH_8,
+	H_WIDTH_12,
+	H_WIDTH_16,
+	H_WIDTH_20,
+	H_WIDTH_24,
+	H_WIDTH_28,
+};
+
+/**
+ * enum davinci_cursor_v_width
+ * @V_WIDTH_1: vertical line width is 1 line
+ * @V_WIDTH_2: vertical line width is 2 lines
+ * @V_WIDTH_4: vertical line width is 4 lines
+ * @V_WIDTH_6: vertical line width is 6 lines
+ * @V_WIDTH_8: vertical line width is 8 lines
+ * @V_WIDTH_10: vertical line width is 10 lines
+ * @V_WIDTH_12: vertical line width is 12 lines
+ * @V_WIDTH_14: vertical line width is 14 lines
+ */
+enum davinci_cursor_v_width {
+	V_WIDTH_1,
+	V_WIDTH_2,
+	V_WIDTH_4,
+	V_WIDTH_6,
+	V_WIDTH_8,
+	V_WIDTH_10,
+	V_WIDTH_12,
+	V_WIDTH_14,
+};
+
+/**
+ * struct davinci_cursor_config
+ * @xsize: horizontal size in pixels
+ * @ysize: vertical size in lines
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ * @h_width: horizontal line width
+ * @v_width: vertical line width
+ * @clut: the CLUT selector (ROM or RAM) for the cursor color
+ * @clut_index: an index into the CLUT for the cursor color
+ *
+ * Description:
+ * A structure describing the configuration parameters of the hardware
+ * rectangular cursor.
+ */
+struct davinci_cursor_config {
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+	enum davinci_cursor_h_width h_width;
+	enum davinci_cursor_v_width v_width;
+	enum davinci_clut clut;
+	unsigned char clut_index;
+};
+
+/**
+ * struct davinci_disp_callback
+ * @next: used internally by the display manager to maintain a liked list of
+ *        callbacks
+ * @mask: a bitmask specifying the display manager event(s) for which the
+ *        callback will be invoked
+ * @handler: the callback routine
+ * @arg: a null pointer that is passed as the second argument to the callback
+ *       routine
+ */
+struct davinci_disp_callback {
+	struct davinci_disp_callback *next;
+	unsigned mask;
+	void (*handler) (unsigned event, void *arg);
+	void *arg;
+};
+
+/* display manager events */
+#define DAVINCI_DISP_END_OF_FRAME	1
+#define DAVINCI_DISP_TOP_FIELD		2
+#define DAVINCI_DISP_BOTTOM_FIELD	4
+
+/**
+ * struct davinci_layer_config
+ * @pixfmt: pixel format
+ * @line_length: offset in bytes between start of each line in memory
+ * @xsize: number of horizontal pixels displayed per line
+ * @ysize: number of lines displayed
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ *
+ * Description:
+ * A structure describing the configuration parameters of an On-Screen Display
+ * (OSD) or video layer related to how the image is stored in memory.
+ * @line_length must be a multiple of the cache line size (32 bytes).
+ */
+struct davinci_layer_config {
+	enum davinci_pix_format pixfmt;
+	unsigned line_length;
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+};
+
+/**
+ * davinci_disp_request_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Request to use an On-Screen Display (OSD) or video layer (window).
+ */
+int davinci_disp_request_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_release_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Release a layer previously obtained via davinci_disp_request_layer().
+ */
+void davinci_disp_release_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_init_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Initialize all parameters that are uniquely associated with the specified
+ * display layer to their default values.  Parameters that are common to
+ * multiple display layers (e.g. expansion ratios) are not affected.  The
+ * default state of a layer is disabled with X1 zoom.  The OSD layers default
+ * to 8-bits-per-pixel bitmap format, RAM CLUT, REC601 attenuation disabled,
+ * color key blending disabled, and are fully opaque.  Video layers maintain
+ * their current pixel format, either YCbCrI or YCrCbI, but will default to
+ * YCbCrI when first initialized.
+ * In general, it is not necessary for a display manager user to call this
+ * routine.  The display manager calls this routine automatically for every
+ * layer at initialization time and for an individual layer when the layer is
+ * released.
+ */
+void davinci_disp_init_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_enable_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Enable a video layer so that it is displayed.
+ */
+int davinci_disp_enable_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_disable_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Disable a video layer so that it is not displayed.
+ */
+void davinci_disp_disable_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_layer_is_enabled
+ * @layer: layer id
+ * Returns: 1 if the layer is enabled, or 0 otherwise
+ *
+ * Description:
+ * Determine whether or not a video layer is enabled..
+ */
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_set_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Configure the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On entry, the values of the
+ * members of the @lconfig struct specify the desired configuration.  On exit,
+ * the values of the members of the @lconfig struct will be updated to reflect
+ * the actual configuration, which is subject to the constraints of the
+ * DaVinci OSD controller.
+ */
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_try_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Evaluate the parameters of an On-Screen Display (OSD) or video layer
+ * configuration.  On entry, the values of the members of the @lconfig struct
+ * specify the desired configuration.  On exit, the values of the members of the
+ * @lconfig struct will be updated to reflect the closest actual configuration
+ * which could currently be set and enabled subject to the constraints of the
+ * DaVinci OSD controller.  The actual layer configuration is not modified by
+ * this routine.
+ *
+ * Note that some of the constraints depend on the current configuration of
+ * other windows, so it is possible for a configuration returned by
+ * davinci_disp_try_layer_config() to fail to be set or enabled successfully
+ * if the configuration of other windows has changed.
+ */
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_get_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ *
+ * Description:
+ * Get the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On exit, the values of the
+ * members of the @lconfig struct will be updated to reflect the current
+ * configuration.
+ */
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_start_layer
+ * @layer: layer id
+ * @fb_base_phys: physical base address of the framebuffer
+ *
+ * Description:
+ * Initialize the framebuffer base address \of an On-Screen Display (OSD) or
+ * video layer.  Display of the layer may be either enabled or disabled on
+ * entry and will be unchanged on exit.  @fb_base_phys must be cache-line
+ * (32-byte) aligned.
+ */
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys);
+
+/**
+ * davinci_disp_set_interpolation_filter
+ * @filter: non-zero to enable the interpolation filter, or zero to disable
+ *
+ * Description:
+ * Globally enable or disable the scaling (zoom and expansion) interpolation
+ * filter.  It applies to all OSD and video windows.
+ */
+void davinci_disp_set_interpolation_filter(int filter);
+
+/**
+ * davinci_disp_get_interpolation_filter
+ * Returns: 1 if the interpolation filter is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the enabled/disabled status of the scaling (zoom and expansion)
+ * interpolation filter.
+ */
+int davinci_disp_get_interpolation_filter(void);
+
+/**
+ * davinci_disp_set_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the OSD windows.
+ */
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the OSD windows.
+ */
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the video windows.
+ */
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the video windows.
+ */
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Set the horizontal and vertical zoom factors.
+ */
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom);
+
+/**
+ * davinci_disp_get_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Get the horizontal and vertical zoom factors.
+ */
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom);
+
+/**
+ * davinci_disp_set_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Set the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index);
+
+/**
+ * davinci_disp_get_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Get the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index);
+
+/**
+ * davinci_disp_set_rom_clut
+ * @rom_clut: the ROM CLUT selector
+ *
+ * Description:
+ * Choose which of the two ROM Color Lookup Tables will be used.
+ */
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut);
+
+/**
+ * davinci_disp_get_rom_clut
+ * Returns: the ROM CLUT selector
+ *
+ * Description:
+ * Query which of the two ROM Color Lookup Tables is currently selected.
+ */
+enum davinci_rom_clut davinci_disp_get_rom_clut(void);
+
+/**
+ * davinci_disp_set_clut_ycbcr
+ * @clut_index: an index into the CLUT
+ * @y: Luma (Y) value
+ * @cb: Blue Chroma (Cb) value
+ * @cr: Red Chroma (Cr) value
+ *
+ * Description:
+ * Set a YCbCr value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr);
+
+/**
+ * davinci_disp_set_clut_rgb
+ * @clut_index: an index into the CLUT
+ * @r: Red value
+ * @g: Green value
+ * @b: Blue value
+ *
+ * Description:
+ * Set an RGB value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b);
+
+/**
+ * davinci_disp_set_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * @clut: the CLUT selector
+ *
+ * Description:
+ * Select whether the RAM CLUT or the ROM CLUT is to be used for an OSD window.
+ * The selection is only significant if the window is using a 1-, 2-, 4-, or
+ * 8-bit pixel format.
+ */
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut);
+
+/**
+ * davinci_disp_get_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the CLUT selector
+ *
+ * Description:
+ * Query whether the RAM CLUT or the ROM CLUT is currently selected for an OSD
+ * window.  The selection is only significant if the window is using a 1-, 2-,
+ * 4-, or 8-bit pixel format.
+ */
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_enable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ * @colorkey: the transparency color key
+ *
+ * Description:
+ * Enable transparency color key blending.  Any pixel in the specified OSD
+ * window which matches the color key will be transparent (or partially
+ * transparent) and allow the underlying video pixel to be displayed based on
+ * the blending factor.
+ *
+ * Interpretation of the @colorkey argument is determined by the pixel format
+ * assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ *
+ * %PIXFMT_1BPP pixels matching @colorkey bit 0 are blended.
+ * %PIXFMT_2BPP pixels matching @colorkey bits 1-0 are blended.
+ * %PIXFMT_4BPP pixels matching @colorkey bits 3-0 are blended.
+ * %PIXFMT_8BPP pixels matching @colorkey bits 7-0 are blended.
+ * %PIXFMT_RGB565 pixels matching @colorkey bits 15-0 are blended.
+ * %PIXFMT_YCbCrI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * %PIXFMT_RGB888 pixels matching @colorkey bits 23-0 are blended.
+ * %PIXFMT_YCrCbI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * Color keying is not applicable to %PIXFMT_OSD_ATTR pixels.
+ *
+ * For DM644x processors, only the four %PIXFMT_nBPP pixel formats and
+ * %PIXFMT_RGB565 are supported.  The color key for the bitmap formats is fixed
+ * at zero on DM644x processors, so the value passed in the @colorkey argument
+ * is only significant for the %PIXFMT_RGB565 pixel format.
+ */
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey);
+
+/**
+ * davinci_disp_disable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ *
+ * Description:
+ * Disable transparency color key blending for the specified OSD layer.  All
+ * pixels in the OSD window will be blended with video pixels according to the
+ * blending factor.
+ */
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * @blend: the blending factor
+ *
+ * Description:
+ * Set the blending factor for an OSD window.  The blending factor determines
+ * the degree of opacity or transparency of OSD pixels.  Transparent or
+ * partially transparent pixels allow the underlying video pixels to be
+ * displayed based on the blending factor.  All OSD pixels are blended unless
+ * color keying is enabled, in which case only pixels matching the color key
+ * are blended.
+ */
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend);
+
+/**
+ * davinci_disp_get_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the blending factor
+ *
+ * Description:
+ * Get the blending factor for an OSD window.
+ */
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin);
+
+/**
+ * davinci_disp_set_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * @enable: non-zero to enable REC601 attenuation, or zero to disable
+ *
+ * Description:
+ * Enable or disable REC601 attenuation of data in an OSD window.
+ */
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable);
+
+/**
+ * davinci_disp_get_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: 1 if REC601 attenuation is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the REC601 attenuation status for an OSD window.
+ */
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * A 256-entry Color Lookup Table (CLUT) is used for bitmap pixel formats.
+ * Every entry in the CLUT is used when the color depth is 8 bits.  However,
+ * only a subset of the CLUT entries are needed for color depths of 1, 2,
+ * or 4 bits.  Each pixel value for color depths of 1, 2, or 4 bits can be
+ * mapped to any of the 256 CLUT entries.  Two CLUT entries are used for a
+ * color depth of 1 bit, four CLUT entries are used for a color depth of
+ * 2 bits, and sixteen CLUT entries are used for a color depth of 4 bits.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index);
+
+/**
+ * davinci_disp_get_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * Returns: an index into the CLUT
+ *
+ * Description:
+ * Given a pixel value, return the corresponding clut index from the palette
+ * map.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value);
+
+/**
+ * davinci_disp_set_blink_attribute
+ * @enable: non-zero to enable blinking, zero to disable
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Set the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink);
+
+/**
+ * davinci_disp_get_blink_attribute
+ * @enable: one if blinking is enabled, or zero if disabled
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Get the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink);
+
+/**
+ * davinci_disp_cursor_enable
+ *
+ * Description:
+ * Enable display of the hardware cursor.
+ */
+void davinci_disp_cursor_enable(void);
+
+/**
+ * davinci_disp_cursor_disable
+ *
+ * Description:
+ * Disable display of the hardware cursor.
+ */
+void davinci_disp_cursor_disable(void);
+
+/**
+ * davinci_disp_cursor_is_enabled
+ * Returns: 1 if cursor is enabled, or 0 otherwise
+ *
+ * Description:
+ * Query whether or not display of the hardware cursor is enabled.
+ */
+int davinci_disp_cursor_is_enabled(void);
+
+/**
+ * davinci_disp_set_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Set the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_get_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Get the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_set_field_inversion
+ * @enable: non-zero to enable field signal inversion, or zero to disable
+ *
+ * Description:
+ * Enable or disable field signal inversion, which inverts the polarity of the
+ * field ID signal from the video encoder.  This setting applies to all OSD and
+ * video windows.  It is only significant when the display is interlaced.
+ */
+void davinci_disp_set_field_inversion(int enable);
+
+/**
+ * davinci_disp_get_field_inversion
+ * Returns: 1 if field signal inversion is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the field signal inversion state.
+ */
+int davinci_disp_get_field_inversion(void);
+
+/**
+ * davinci_disp_register_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register a callback routine for a DaVinci display manager event.
+ * @callback->handler is a pointer to the callback routine.  The first argument
+ * passed to the callback routine is the display manager event bitmask
+ * indicating which event(s) occurred.  The second argument passed to the
+ * callback routine is @callback->arg.  @callback->mask is a bitmask specifying
+ * the events for which the caller wishes to be notified.  @callback->next is
+ * used internally by the display manager and need not be initialized by the
+ * caller.  Once a callback routine has been registered, the caller must not
+ * modify the @callback struct until the callback has been unregistered.
+ *
+ * The display manager events are %DAVINCI_DISP_END_OF_FRAME,
+ * %DAVINCI_DISP_TOP_FIELD, and %DAVINCI_DISP_BOTTOM_FIELD.
+ */
+int davinci_disp_register_callback(struct davinci_disp_callback *callback);
+
+/**
+ * davinci_disp_unregister_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister a display manager callback routine previously registered with
+ * davinci_disp_register_callback().
+ */
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback);
+
+#endif				/* ifndef _DAVINCI_OSD_H */
Index: linux-2.6.10/include/video/davinci_vpbe.h
===================================================================
--- linux-2.6.10.orig/include/video/davinci_vpbe.h
+++ linux-2.6.10/include/video/davinci_vpbe.h
@@ -14,186 +14,213 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davinci_vpbe.h	
  */
-#ifndef _DAVINCIFB_H_
-#define _DAVINCIFB_H_
+#ifndef _DAVINCI_VPBE_H_
+#define _DAVINCI_VPBE_H_
 
-#include <asm/arch/io.h>
+/* VPBE register base addresses */
+#define DM644X_VENC_REG_BASE		0x01C72400
+#define DM644X_OSD_REG_BASE		0x01C72600
+#define DM644X_VPBE_REG_BASE		0x01C72780
+
+#define DM355_VPSSCLK_REG_BASE		0x01C70000
+#define DM355_OSD_REG_BASE		0x01C70200
+#define DM355_VENC_REG_BASE		0x01C70400
+#define DM355_VPSSBL_REG_BASE		0x01C70800
 
-/* Base registers */
-#define	VPBE_REG_BASE		IO_ADDRESS(0x01c72780)
-#define	VENC_REG_BASE		IO_ADDRESS(0x01c72400)
-#define	OSD_REG_BASE		IO_ADDRESS(0x01c72600)
-#define OSD_REG_SIZE		0x00000180
+#define OSD_REG_SIZE			0x00000100
 
-/* VPBE Global Registers */
-#define	VPBE_PID		(VPBE_REG_BASE + 0x0)
-#define	VPBE_PCR		(VPBE_REG_BASE + 0x4)
+/* SYS register addresses */
+#define SYS_VPSS_CLKCTL			0x01C40044
+
+#define DM355_VDAC_CONFIG		0x01C4002C
+#define DM355_USB_PHY_CTRL		0x01c40034
 
-/* VPSS Clock Control Register */
-#define	VPSS_CLKCTL		IO_ADDRESS(0x01c40044)
+/* VPBE Global Registers */
+#define VPBE_PID				0x0
+#define VPBE_PCR				0x4
 
-/* Pin Multiplexing Control Registers*/
-#define	VPSS_PINMUX_BASE	IO_ADDRESS(0x01c40000)
-#define PINMUX0			(VPSS_PINMUX_BASE + 0x0)
-#define PINMUX1			(VPSS_PINMUX_BASE + 0x4)
+/* VPSS CLock Registers */
+#define VPSSCLK_PID				0x00
+#define VPSSCLK_CLKCTRL				0x04
+
+/* VPSS Buffer Logic Registers */
+#define VPSSBL_PID				0x00
+#define VPSSBL_PCR				0x04
+#define VPSSBL_INTSTAT				0x0C
+#define VPSSBL_INTSEL				0x10
+#define VPSSBL_EVTSEL				0x14
+#define VPSSBL_MEMCTRL				0x18
+#define VPSSBL_CCDCMUX				0x1C
 
 /* VPBE Video Encoder / Digital LCD Subsystem Registers (VENC) */
-#define	VENC_VMOD				(VENC_REG_BASE + 0x00)
-#define	VENC_VIDCTL				(VENC_REG_BASE + 0x04)
-#define	VENC_VDPRO				(VENC_REG_BASE + 0x08)
-#define	VENC_SYNCCTL				(VENC_REG_BASE + 0x0C)
-#define	VENC_HSPLS				(VENC_REG_BASE + 0x10)
-#define	VENC_VSPLS				(VENC_REG_BASE + 0x14)
-#define	VENC_HINT				(VENC_REG_BASE + 0x18)
-#define	VENC_HSTART				(VENC_REG_BASE + 0x1C)
-#define	VENC_HVALID				(VENC_REG_BASE + 0x20)
-#define	VENC_VINT				(VENC_REG_BASE + 0x24)
-#define	VENC_VSTART				(VENC_REG_BASE + 0x28)
-#define	VENC_VVALID				(VENC_REG_BASE + 0x2C)
-#define	VENC_HSDLY				(VENC_REG_BASE + 0x30)
-#define	VENC_VSDLY				(VENC_REG_BASE + 0x34)
-#define	VENC_YCCCTL				(VENC_REG_BASE + 0x38)
-#define	VENC_RGBCTL				(VENC_REG_BASE + 0x3C)
-#define	VENC_RGBCLP				(VENC_REG_BASE + 0x40)
-#define	VENC_LINECTL				(VENC_REG_BASE + 0x44)
-#define	VENC_CULLLINE				(VENC_REG_BASE + 0x48)
-#define	VENC_LCDOUT				(VENC_REG_BASE + 0x4C)
-#define	VENC_BRTS				(VENC_REG_BASE + 0x50)
-#define	VENC_BRTW				(VENC_REG_BASE + 0x54)
-#define	VENC_ACCTL				(VENC_REG_BASE + 0x58)
-#define	VENC_PWMP				(VENC_REG_BASE + 0x5C)
-#define	VENC_PWMW				(VENC_REG_BASE + 0x60)
-#define	VENC_DCLKCTL				(VENC_REG_BASE + 0x64)
-#define	VENC_DCLKPTN0				(VENC_REG_BASE + 0x68)
-#define	VENC_DCLKPTN1				(VENC_REG_BASE + 0x6C)
-#define	VENC_DCLKPTN2				(VENC_REG_BASE + 0x70)
-#define	VENC_DCLKPTN3				(VENC_REG_BASE + 0x74)
-#define	VENC_DCLKPTN0A				(VENC_REG_BASE + 0x78)
-#define	VENC_DCLKPTN1A				(VENC_REG_BASE + 0x7C)
-#define	VENC_DCLKPTN2A				(VENC_REG_BASE + 0x80)
-#define	VENC_DCLKPTN3A				(VENC_REG_BASE + 0x84)
-#define	VENC_DCLKHS				(VENC_REG_BASE + 0x88)
-#define	VENC_DCLKHSA				(VENC_REG_BASE + 0x8C)
-#define	VENC_DCLKHR				(VENC_REG_BASE + 0x90)
-#define	VENC_DCLKVS				(VENC_REG_BASE + 0x94)
-#define	VENC_DCLKVR				(VENC_REG_BASE + 0x98)
-#define	VENC_CAPCTL				(VENC_REG_BASE + 0x9C)
-#define	VENC_CAPDO				(VENC_REG_BASE + 0xA0)
-#define	VENC_CAPDE				(VENC_REG_BASE + 0xA4)
-#define	VENC_ATR0				(VENC_REG_BASE + 0xA8)
-#define	VENC_ATR1				(VENC_REG_BASE + 0xAC)
-#define	VENC_ATR2				(VENC_REG_BASE + 0xB0)
-#define	VENC_EPSON_LCDCTL			(VENC_REG_BASE + 0xB4)
-#define	VENC_CASIO_LCDCTL			(VENC_REG_BASE + 0xB4)
-#define	VENC_UDISP_LCDCT			(VENC_REG_BASE + 0xB4)
-#define	VENC_STN_LCDCT				(VENC_REG_BASE + 0xB4)
-#define	VENC_VSTAT				(VENC_REG_BASE + 0xB8)
-#define	VENC_RAMADR				(VENC_REG_BASE + 0xBC)
-#define	VENC_RAMPORT				(VENC_REG_BASE + 0xC0)
-#define	VENC_DACTST				(VENC_REG_BASE + 0xC4)
-#define	VENC_YCOLVL				(VENC_REG_BASE + 0xC8)
-#define	VENC_SCPROG				(VENC_REG_BASE + 0xCC)
-#define	VENC_CVBS				(VENC_REG_BASE + 0xDC)
-#define	VENC_CMPNT				(VENC_REG_BASE + 0xE0)
-#define	VENC_ETMG0				(VENC_REG_BASE + 0xE4)
-#define	VENC_ETMG1				(VENC_REG_BASE + 0xE8)
-#define	VENC_ETMG2				(VENC_REG_BASE + 0xEC)
-#define	VENC_ETMG3				(VENC_REG_BASE + 0xF0)
-#define	VENC_DACSEL				(VENC_REG_BASE + 0xF4)
-#define	VENC_ARGBX0				(VENC_REG_BASE + 0x100)
-#define	VENC_ARGBX1				(VENC_REG_BASE + 0x104)
-#define	VENC_ARGBX2				(VENC_REG_BASE + 0x108)
-#define	VENC_ARGBX3				(VENC_REG_BASE + 0x10C)
-#define	VENC_ARGBX4				(VENC_REG_BASE + 0x110)
-#define	VENC_DRGBX0				(VENC_REG_BASE + 0x114)
-#define	VENC_DRGBX1				(VENC_REG_BASE + 0x118)
-#define	VENC_DRGBX2				(VENC_REG_BASE + 0x11C)
-#define	VENC_DRGBX3				(VENC_REG_BASE + 0x120)
-#define	VENC_DRGBX4				(VENC_REG_BASE + 0x124)
-#define	VENC_VSTARTA				(VENC_REG_BASE + 0x128)
-#define	VENC_OSDCLK0				(VENC_REG_BASE + 0x12C)
-#define	VENC_OSDCLK1				(VENC_REG_BASE + 0x130)
-#define	VENC_HVLDCL0				(VENC_REG_BASE + 0x134)
-#define	VENC_HVLDCL1				(VENC_REG_BASE + 0x138)
-#define	VENC_OSDHAD				(VENC_REG_BASE + 0x13C)
-
-#define OSD0	0
-#define VID0	1
-#define OSD1	2
-#define VID1	3
+#define VENC_VMOD				0x00
+#define VENC_VIDCTL				0x04
+#define VENC_VDPRO				0x08
+#define VENC_SYNCCTL				0x0C
+#define VENC_HSPLS				0x10
+#define VENC_VSPLS				0x14
+#define VENC_HINT				0x18
+#define VENC_HSTART				0x1C
+#define VENC_HVALID				0x20
+#define VENC_VINT				0x24
+#define VENC_VSTART				0x28
+#define VENC_VVALID				0x2C
+#define VENC_HSDLY				0x30
+#define VENC_VSDLY				0x34
+#define VENC_YCCCTL				0x38
+#define VENC_RGBCTL				0x3C
+#define VENC_RGBCLP				0x40
+#define VENC_LINECTL				0x44
+#define VENC_CULLLINE				0x48
+#define VENC_LCDOUT				0x4C
+#define VENC_BRTS				0x50
+#define VENC_BRTW				0x54
+#define VENC_ACCTL				0x58
+#define VENC_PWMP				0x5C
+#define VENC_PWMW				0x60
+#define VENC_DCLKCTL				0x64
+#define VENC_DCLKPTN0				0x68
+#define VENC_DCLKPTN1				0x6C
+#define VENC_DCLKPTN2				0x70
+#define VENC_DCLKPTN3				0x74
+#define VENC_DCLKPTN0A				0x78
+#define VENC_DCLKPTN1A				0x7C
+#define VENC_DCLKPTN2A				0x80
+#define VENC_DCLKPTN3A				0x84
+#define VENC_DCLKHS				0x88
+#define VENC_DCLKHSA				0x8C
+#define VENC_DCLKHR				0x90
+#define VENC_DCLKVS				0x94
+#define VENC_DCLKVR				0x98
+#define VENC_CAPCTL				0x9C
+#define VENC_CAPDO				0xA0
+#define VENC_CAPDE				0xA4
+#define VENC_ATR0				0xA8
+#define VENC_ATR1				0xAC
+#define VENC_ATR2				0xB0
+#define VENC_VSTAT				0xB8
+#define VENC_RAMADR				0xBC
+#define VENC_RAMPORT				0xC0
+#define VENC_DACTST				0xC4
+#define VENC_YCOLVL				0xC8
+#define VENC_SCPROG				0xCC
+#define VENC_CVBS				0xDC
+#define VENC_CMPNT				0xE0
+#define VENC_ETMG0				0xE4
+#define VENC_ETMG1				0xE8
+#define VENC_ETMG2				0xEC
+#define VENC_ETMG3				0xF0
+#define VENC_DACSEL				0xF4
+#define VENC_ARGBX0				0x100
+#define VENC_ARGBX1				0x104
+#define VENC_ARGBX2				0x108
+#define VENC_ARGBX3				0x10C
+#define VENC_ARGBX4				0x110
+#define VENC_DRGBX0				0x114
+#define VENC_DRGBX1				0x118
+#define VENC_DRGBX2				0x11C
+#define VENC_DRGBX3				0x120
+#define VENC_DRGBX4				0x124
+#define VENC_VSTARTA				0x128
+#define VENC_OSDCLK0				0x12C
+#define VENC_OSDCLK1				0x130
+#define VENC_HVLDCL0				0x134
+#define VENC_HVLDCL1				0x138
+#define VENC_OSDHADV				0x13C
+#define VENC_CLKCTL				0x140
+#define VENC_GAMCTL				0x144
 
 /* VPBE On-Screen Display Subsystem Registers (OSD) */
-#define	OSD_MODE				(OSD_REG_BASE + 0x00)
-#define	OSD_VIDWINMD				(OSD_REG_BASE + 0x04)
-#define	OSD_OSDWIN0MD				(OSD_REG_BASE + 0x08)
-#define	OSD_OSDWIN1MD				(OSD_REG_BASE + 0x0C)
-#define	OSD_OSDATRMD				(OSD_REG_BASE + 0x0C)
-#define	OSD_RECTCUR				(OSD_REG_BASE + 0x10)
-#define		OSD_WINOFST(i)			(OSD_REG_BASE + 0x18 + (i)*0x4)
-#define	OSD_VIDWIN0OFST				(OSD_REG_BASE + 0x18)
-#define	OSD_VIDWIN1OFST				(OSD_REG_BASE + 0x1C)
-#define	OSD_OSDWIN0OFST				(OSD_REG_BASE + 0x20)
-#define	OSD_OSDWIN1OFST				(OSD_REG_BASE + 0x24)
-#define		OSD_WINADR(i)			(OSD_REG_BASE + 0x2C + (i)*0x4)
-#define	OSD_VIDWIN0ADR				(OSD_REG_BASE + 0x2C)
-#define	OSD_VIDWIN1ADR				(OSD_REG_BASE + 0x30)
-#define	OSD_OSDWIN0ADR				(OSD_REG_BASE + 0x38)
-#define	OSD_OSDWIN1ADR				(OSD_REG_BASE + 0x3C)
-#define	OSD_BASEPX				(OSD_REG_BASE + 0x40)
-#define	OSD_BASEPY				(OSD_REG_BASE + 0x44)
-#define	OSD_WINXP(i)				(OSD_REG_BASE + 0x48 + (i)*0x10)
-#define	OSD_WINYP(i)				(OSD_REG_BASE + 0x4C + (i)*0x10)
-#define	OSD_WINXL(i)				(OSD_REG_BASE + 0x50 + (i)*0x10)
-#define	OSD_WINYL(i)				(OSD_REG_BASE + 0x54 + (i)*0x10)
-#define	OSD_VIDWIN0XP				(OSD_REG_BASE + 0x48)
-#define	OSD_VIDWIN0YP				(OSD_REG_BASE + 0x4C)
-#define	OSD_VIDWIN0XL				(OSD_REG_BASE + 0x50)
-#define	OSD_VIDWIN0YL				(OSD_REG_BASE + 0x54)
-#define	OSD_VIDWIN1XP				(OSD_REG_BASE + 0x58)
-#define	OSD_VIDWIN1YP				(OSD_REG_BASE + 0x5C)
-#define	OSD_VIDWIN1XL				(OSD_REG_BASE + 0x60)
-#define	OSD_VIDWIN1YL				(OSD_REG_BASE + 0x64)
-#define	OSD_OSDWIN0XP				(OSD_REG_BASE + 0x68)
-#define	OSD_OSDWIN0YP				(OSD_REG_BASE + 0x6C)
-#define	OSD_OSDWIN0XL				(OSD_REG_BASE + 0x70)
-#define	OSD_OSDWIN0YL				(OSD_REG_BASE + 0x74)
-#define	OSD_OSDWIN1XP				(OSD_REG_BASE + 0x78)
-#define	OSD_OSDWIN1YP				(OSD_REG_BASE + 0x7C)
-#define	OSD_OSDWIN1XL				(OSD_REG_BASE + 0x80)
-#define	OSD_OSDWIN1YL				(OSD_REG_BASE + 0x84)
-#define	OSD_CURXP				(OSD_REG_BASE + 0x88)
-#define	OSD_CURYP				(OSD_REG_BASE + 0x8C)
-#define	OSD_CURXL				(OSD_REG_BASE + 0x90)
-#define	OSD_CURYL				(OSD_REG_BASE + 0x94)
-#define	OSD_W0BMP01				(OSD_REG_BASE + 0xA0)
-#define	OSD_W0BMP23				(OSD_REG_BASE + 0xA4)
-#define	OSD_W0BMP45				(OSD_REG_BASE + 0xA8)
-#define	OSD_W0BMP67				(OSD_REG_BASE + 0xAC)
-#define	OSD_W0BMP89				(OSD_REG_BASE + 0xB0)
-#define	OSD_W0BMPAB				(OSD_REG_BASE + 0xB4)
-#define	OSD_W0BMPCD				(OSD_REG_BASE + 0xB8)
-#define	OSD_W0BMPEF				(OSD_REG_BASE + 0xBC)
-#define	OSD_W1BMP0				(OSD_REG_BASE + 0xC0)
-#define	OSD_W1BMP2				(OSD_REG_BASE + 0xC4)
-#define	OSD_W1BMP4				(OSD_REG_BASE + 0xC8)
-#define	OSD_W1BMP6				(OSD_REG_BASE + 0xCC)
-#define	OSD_W1BMP8				(OSD_REG_BASE + 0xD0)
-#define	OSD_W1BMPA				(OSD_REG_BASE + 0xD4)
-#define	OSD_W1BMPC				(OSD_REG_BASE + 0xD8)
-#define	OSD_W1BMPE				(OSD_REG_BASE + 0xDC)
-#define	OSD_TI_TES				(OSD_REG_BASE + 0xE0)
-#define	OSD_MISCCT				(OSD_REG_BASE + 0xE8)
-#define	OSD_CLUTRAMYC				(OSD_REG_BASE + 0xEC)
-#define	OSD_CLUTRAMC				(OSD_REG_BASE + 0xF0)
-#define	OSD_TRANSPVA				(OSD_REG_BASE + 0xF4)
-#define	OSD_PPVWIN0AD				(OSD_REG_BASE + 0xFC)
+#define OSD_MODE				0x00
+#define OSD_VIDWINMD				0x04
+#define OSD_OSDWIN0MD				0x08
+#define OSD_OSDWIN1MD				0x0C
+#define OSD_OSDATRMD				0x0C
+#define OSD_RECTCUR				0x10
+#define OSD_VIDWIN0OFST				0x18
+#define OSD_VIDWIN1OFST				0x1C
+#define OSD_OSDWIN0OFST				0x20
+#define OSD_OSDWIN1OFST				0x24
+#define OSD_VIDWINADH				0x28
+#define OSD_VIDWIN0ADL				0x2C
+#define OSD_VIDWIN0ADR				0x2C
+#define OSD_VIDWIN1ADL				0x30
+#define OSD_VIDWIN1ADR				0x30
+#define OSD_OSDWINADH				0x34
+#define OSD_OSDWIN0ADL				0x38
+#define OSD_OSDWIN0ADR				0x38
+#define OSD_OSDWIN1ADL				0x3C
+#define OSD_OSDWIN1ADR				0x3C
+#define OSD_BASEPX				0x40
+#define OSD_BASEPY				0x44
+#define OSD_VIDWIN0XP				0x48
+#define OSD_VIDWIN0YP				0x4C
+#define OSD_VIDWIN0XL				0x50
+#define OSD_VIDWIN0YL				0x54
+#define OSD_VIDWIN1XP				0x58
+#define OSD_VIDWIN1YP				0x5C
+#define OSD_VIDWIN1XL				0x60
+#define OSD_VIDWIN1YL				0x64
+#define OSD_OSDWIN0XP				0x68
+#define OSD_OSDWIN0YP				0x6C
+#define OSD_OSDWIN0XL				0x70
+#define OSD_OSDWIN0YL				0x74
+#define OSD_OSDWIN1XP				0x78
+#define OSD_OSDWIN1YP				0x7C
+#define OSD_OSDWIN1XL				0x80
+#define OSD_OSDWIN1YL				0x84
+#define OSD_CURXP				0x88
+#define OSD_CURYP				0x8C
+#define OSD_CURXL				0x90
+#define OSD_CURYL				0x94
+#define OSD_W0BMP01				0xA0
+#define OSD_W0BMP23				0xA4
+#define OSD_W0BMP45				0xA8
+#define OSD_W0BMP67				0xAC
+#define OSD_W0BMP89				0xB0
+#define OSD_W0BMPAB				0xB4
+#define OSD_W0BMPCD				0xB8
+#define OSD_W0BMPEF				0xBC
+#define OSD_W1BMP01				0xC0
+#define OSD_W1BMP23				0xC4
+#define OSD_W1BMP45				0xC8
+#define OSD_W1BMP67				0xCC
+#define OSD_W1BMP89				0xD0
+#define OSD_W1BMPAB				0xD4
+#define OSD_W1BMPCD				0xD8
+#define OSD_W1BMPEF				0xDC
+#define OSD_VBNDRY				0xE0
+#define OSD_EXTMODE				0xE4
+#define OSD_MISCCTL				0xE8
+#define OSD_CLUTRAMYCB				0xEC
+#define OSD_CLUTRAMCR				0xF0
+#define OSD_TRANSPVAL				0xF4
+#define OSD_TRANSPVALL				0xF4
+#define OSD_TRANSPVALU				0xF8
+#define OSD_TRANSPBMPIDX			0xFC
+#define OSD_PPVWIN0ADR				0xFC
 
 /* bit definitions */
 #define VPBE_PCR_VENC_DIV			(1 << 1)
 #define VPBE_PCR_CLK_OFF			(1 << 0)
+
+#define VPSSBL_INTSTAT_HSSIINT			(1 << 14)
+#define VPSSBL_INTSTAT_CFALDINT			(1 << 13)
+#define VPSSBL_INTSTAT_IPIPE_INT5		(1 << 12)
+#define VPSSBL_INTSTAT_IPIPE_INT4		(1 << 11)
+#define VPSSBL_INTSTAT_IPIPE_INT3		(1 << 10)
+#define VPSSBL_INTSTAT_IPIPE_INT2		(1 << 9)
+#define VPSSBL_INTSTAT_IPIPE_INT1		(1 << 8)
+#define VPSSBL_INTSTAT_IPIPE_INT0		(1 << 7)
+#define VPSSBL_INTSTAT_IPIPEIFINT		(1 << 6)
+#define VPSSBL_INTSTAT_OSDINT			(1 << 5)
+#define VPSSBL_INTSTAT_VENCINT			(1 << 4)
+#define VPSSBL_INTSTAT_H3AINT			(1 << 3)
+#define VPSSBL_INTSTAT_CCDC_VDINT2		(1 << 2)
+#define VPSSBL_INTSTAT_CCDC_VDINT1		(1 << 1)
+#define VPSSBL_INTSTAT_CCDC_VDINT0		(1 << 0)
+
 #define VENC_VMOD_VDMD_SHIFT			12
 #define VENC_VMOD_VDMD_YCBCR16			0
 #define VENC_VMOD_VDMD_YCBCR8			1
@@ -209,294 +236,262 @@
 #define VENC_VMOD_ITLC				(1 << 10)
 #define VENC_VMOD_NSIT				(1 << 9)
 #define VENC_VMOD_HDMD				(1 << 8)
+#define VENC_VMOD_TVTYP_SHIFT			6
 #define VENC_VMOD_TVTYP				(3 << 6)
 #define VENC_VMOD_SLAVE				(1 << 5)
 #define VENC_VMOD_VMD				(1 << 4)
 #define VENC_VMOD_BLNK				(1 << 3)
 #define VENC_VMOD_VIE				(1 << 1)
 #define VENC_VMOD_VENC				(1 << 0)
-/* other VENC registers' bit positions not defined yet */
 
-#define	OSD_MODE_CS				(1 << 15)
-#define	OSD_MODE_CS_SHIFT			15
-#define	OSD_MODE_OVRSZ				(1 << 14)
-#define	OSD_MODE_OHRSZ				(1 << 13)
-#define	OSD_MODE_EF				(1 << 12)
-#define	OSD_MODE_VVRSZ				(1 << 11)
-#define	OSD_MODE_VHRSZ				(1 << 10)
-#define	OSD_MODE_FSINV				(1 << 9)
-#define	OSD_MODE_BCLUT				(1 << 8)
-#define OSD_MODE_BCLUT_SHIFT			8
-#define	OSD_MODE_CABG				(0xff << 0)
-#define	OSD_MODE_CABG_SHIFT			0
-
-#define	OSD_VIDWINMD_VFINV			(1 << 15)
-#define	OSD_VIDWINMD_V1EFC			(1 << 14)
-#define	OSD_VIDWINMD_VHZ1			(3 << 12)
-#define	OSD_VIDWINMD_VHZ1_SHIFT			12
-#define	OSD_VIDWINMD_VVZ1			(3 << 10)
-#define	OSD_VIDWINMD_VVZ1_SHIFT			10
-#define	OSD_VIDWINMD_VFF1			(1 << 9)
-#define	OSD_VIDWINMD_ACT1			(1 << 8)
-#define	OSD_VIDWINMD_V0EFC			(1 << 6)
-#define	OSD_VIDWINMD_VHZ0			(3 << 4)
-#define	OSD_VIDWINMD_VHZ0_SHIFT			4
-#define	OSD_VIDWINMD_VVZ0			(3 << 2)
-#define	OSD_VIDWINMD_VVZ0_SHIFT			2
-#define	OSD_VIDWINMD_VFF0			(1 << 1)
-#define	OSD_VIDWINMD_ACT0			(1 << 0)
-
-#define	OSD_OSDWIN0MD_ATN0E			(1 << 14)
-#define	OSD_OSDWIN0MD_RGB0E			(1 << 13)
-#define OSD_OSDWIN0MD_RGB0E_SHIFT		13
-#define	OSD_OSDWIN0MD_CLUTS0			(1 << 12)
-#define	OSD_OSDWIN0MD_OHZ0			(3 << 10)
-#define	OSD_OSDWIN0MD_OHZ0_SHIFT		10
-#define	OSD_OSDWIN0MD_OVZ0			(3 << 8)
-#define	OSD_OSDWIN0MD_OVZ0_SHIFT		8
-#define	OSD_OSDWIN0MD_BMW0			(3 << 6)
-#define	OSD_OSDWIN0MD_BMW0_SHIFT		6
-#define	OSD_OSDWIN0MD_BLND0			(7 << 3)
-#define	OSD_OSDWIN0MD_BLND0_SHIFT		3
-#define	OSD_OSDWIN0MD_TE0			(1 << 2)
-#define	OSD_OSDWIN0MD_TE0_SHIFT			2
-#define	OSD_OSDWIN0MD_OFF0			(1 << 1)
-#define	OSD_OSDWIN0MD_OACT0			(1 << 0)
-
-#define	OSD_OSDWIN1MD_OASW			(1 << 15)
-#define OSD_OSDWIN1MD_OASW_SHIFT		15
-#define	OSD_OSDWIN1MD_ATN1E			(1 << 14)
-#define	OSD_OSDWIN1MD_RGB1E			(1 << 13)
-#define OSD_OSDWIN1MD_RGB1E_SHIFT		13
-#define	OSD_OSDWIN1MD_CLUTS1			(1 << 12)
-#define	OSD_OSDWIN1MD_OHZ1			(3 << 10)
-#define	OSD_OSDWIN1MD_OHZ1_SHIFT		10
-#define	OSD_OSDWIN1MD_OVZ1			(3 << 8)
-#define	OSD_OSDWIN1MD_OVZ1_SHIFT		8
-#define	OSD_OSDWIN1MD_BMW1			(3 << 6)
-#define	OSD_OSDWIN1MD_BMW1_SHIFT		6
-#define	OSD_OSDWIN1MD_BLND1			(7 << 3)
-#define	OSD_OSDWIN1MD_BLND1_SHIFT		3
-#define	OSD_OSDWIN1MD_TE1			(1 << 2)
-#define	OSD_OSDWIN1MD_TE1_SHIFT			2
-#define	OSD_OSDWIN1MD_OFF1			(1 << 1)
-#define	OSD_OSDWIN1MD_OACT1			(1 << 0)
-
-#define	OSD_OSDATRMD_OASW			(1 << 15)
-#define OSD_OSDATRMD_OSAW_SHIFT			15
-#define	OSD_OSDATRMD_OHZA			(3 << 10)
-#define	OSD_OSDATRMD_OHZA_SHIFT			10
-#define	OSD_OSDATRMD_OVZA			(3 << 8)
-#define	OSD_OSDATRMD_OVZA_SHIFT			8
-#define	OSD_OSDATRMD_BLNKINT			(3 << 6)
-#define	OSD_OSDATRMD_BLNKINT_SHIFT		6
-#define	OSD_OSDATRMD_OFFA			(1 << 1)
-#define	OSD_OSDATRMD_BLNK			(1 << 0)
-
-#define	 OSD_RECTCUR_CLUTSR_SHIFT	7
-#define	OSD_RECTCUR_RCHW_SHIFT		4
-#define	OSD_RECTCUR_RCHW		(7 <<	OSD_RECTCUR_RCHW_SHIFT)
-#define	OSD_RECTCUR_RCVW_SHIFT		1
-#define	OSD_RECTCUR_RCVW		(7 <<	OSD_RECTCUR_RCVW_SHIFT)
-#define	OSD_RECTCUR_RCAD_SHIFT		8
-#define	OSD_RECTCUR_RCAD		(0xff	<< OSD_RECTCUR_RCAD_SHIFT)
-#define	OSD_RECTCUR_CLUTSR		(1 << 7)
-#define	OSD_RECTCUR_RCACT		(1 << 0)
-
-#define	OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
-#define	OSD_VIDWIN0OFST_V0LO_SHIFT		0
-#define	OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
-#define	OSD_VIDWIN1OFST_V1LO_SHIFT		0
-#define	OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
-#define	OSD_OSDWIN0OFST_O0LO_SHIFT		0
-#define	OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
-#define	OSD_OSDWIN1OFST_O1LO_SHIFT		0
-#define	OSD_BASEPX_BPX				(0x3ff << 0)
-#define	OSD_BASEPX_BPX_SHIFT			0
-#define	OSD_BASEPY_BPY				(0x1ff << 0)
-#define	OSD_BASEPY_BPY_SHIFT			0
-#define	OSD_VIDWIN0XP_V0X			(0x3ff << 0)
-#define	OSD_VIDWIN0XP_V0X_SHIFT			0
-#define	OSD_VIDWIN0YP_V0Y			(0x1ff << 0)
-#define	OSD_VIDWIN0YP_V0Y_SHIFT			0
-#define	OSD_VIDWIN0XL_V0W			(0xfff << 0)
-#define	OSD_VIDWIN0XL_V0W_SHIFT			0
-#define	OSD_VIDWIN0YL_V0H			(0x7ff << 0)
-#define	OSD_VIDWIN0YL_V0H_SHIFT			0
-#define	OSD_VIDWIN1XP_V1X			(0x3ff << 0)
-#define	OSD_VIDWIN1XP_V1X_SHIFT			0
-#define	OSD_VIDWIN1YP_V1Y			(0x1ff << 0)
-#define	OSD_VIDWIN1YP_V1Y_SHIFT			0
-#define	OSD_VIDWIN1XL_V1W			(0xfff << 0)
-#define	OSD_VIDWIN1XL_V1W_SHIFT			0
-#define	OSD_VIDWIN1YL_V1H			(0x7ff << 0)
-#define	OSD_VIDWIN1YL_V1H_SHIFT			0
-#define	OSD_OSDWIN0XP_W0X			(0x3ff << 0)
-#define	OSD_OSDWIN0XP_W0X_SHIFT			0
-#define	OSD_OSDWIN0YP_W0Y			(0x1ff << 0)
-#define	OSD_OSDWIN0YP_W0Y_SHIFT			0
-#define	OSD_OSDWIN0XL_W0W			(0xfff << 0)
-#define	OSD_OSDWIN0XL_W0W_SHIFT			0
-#define	OSD_OSDWIN0YL_W0H			(0x7ff << 0)
-#define	OSD_OSDWIN0YL_W0H_SHIFT			0
-#define	OSD_OSDWIN1XP_W1X			(0x3ff << 0)
-#define	OSD_OSDWIN1XP_W1X_SHIFT			0
-#define	OSD_OSDWIN1YP_W1Y			(0x1ff << 0)
-#define	OSD_OSDWIN1YP_W1Y_SHIFT			0
-#define	OSD_OSDWIN1XL_W1W			(0xfff << 0)
-#define	OSD_OSDWIN1XL_W1W_SHIFT			0
-#define	OSD_OSDWIN1YL_W1H			(0x7ff << 0)
-#define	OSD_OSDWIN1YL_W1H_SHIFT			0
-#define	OSD_CURXP_RCSX				(0x3ff << 0)
-#define	OSD_CURXP_RCSX_SHIFT			0
-#define	OSD_CURYP_RCSY				(0x1ff << 0)
-#define	OSD_CURYP_RCSY_SHIFT			0
-#define	OSD_CURYL_RCSH				(0x7ff << 0)
-#define	OSD_CURYL_RCSH_SHIFT			0
-#define	OSD_W0BMP01_PAL01			(0xff << 8)
-#define	OSD_W0BMP01_PAL01_SHIFT			8
-#define	OSD_W0BMP01_PAL00			(0xff << 0)
-#define	OSD_W0BMP01_PAL00_SHIFT			0
-#define	OSD_W0BMP23_PAL03			(0xff << 8)
-#define	OSD_W0BMP23_PAL03_SHIFT			8
-#define	OSD_W0BMP23_PAL02			(0xff << 0)
-#define	OSD_W0BMP23_PAL02_SHIFT			0
-#define	OSD_W0BMP45_PAL05			(0xff << 8)
-#define	OSD_W0BMP45_PAL05_SHIFT			8
-#define	OSD_W0BMP45_PAL04			(0xff << 0)
-#define	OSD_W0BMP45_PAL04_SHIFT			0
-#define	OSD_W0BMP67_PAL07			(0xff << 8)
-#define	OSD_W0BMP67_PAL07_SHIFT			8
-#define	OSD_W0BMP67_PAL06			(0xff << 0)
-#define	OSD_W0BMP67_PAL06_SHIFT			0
-#define	OSD_W0BMP89_PAL09			(0xff << 8)
-#define	OSD_W0BMP89_PAL09_SHIFT			8
-#define	OSD_W0BMP89_PAL08			(0xff << 0)
-#define	OSD_W0BMP89_PAL08_SHIFT			0
-#define	OSD_W0BMPAB_PAL11			(0xff << 8)
-#define	OSD_W0BMPAB_PAL11_SHIFT			8
-#define	OSD_W0BMPAB_PAL10			(0xff << 0)
-#define	OSD_W0BMPAB_PAL10_SHIFT			0
-#define	OSD_W0BMPCD_PAL13			(0xff << 8)
-#define	OSD_W0BMPCD_PAL13_SHIFT			8
-#define	OSD_W0BMPCD_PAL12			(0xff << 0)
-#define	OSD_W0BMPCD_PAL12_SHIFT			0
-#define	OSD_W0BMPEF_PAL15			(0xff << 8)
-#define	OSD_W0BMPEF_PAL15_SHIFT			8
-#define	OSD_W0BMPEF_PAL14			(0xff << 0)
-#define	OSD_W0BMPEF_PAL14_SHIFT			0
-#define	OSD_W1BMP0_PAL01			(0xff << 8)
-#define	OSD_W1BMP0_PAL01_SHIFT			8
-#define	OSD_W1BMP0_PAL00			(0xff << 0)
-#define	OSD_W1BMP0_PAL00_SHIFT			0
-#define	OSD_W1BMP2_PAL03			(0xff << 8)
-#define	OSD_W1BMP2_PAL03_SHIFT			8
-#define	OSD_W1BMP2_PAL02			(0xff << 0)
-#define	OSD_W1BMP2_PAL02_SHIFT			0
-#define	OSD_W1BMP4_PAL05			(0xff << 8)
-#define	OSD_W1BMP4_PAL05_SHIFT			8
-#define	OSD_W1BMP4_PAL04			(0xff << 0)
-#define	OSD_W1BMP4_PAL04_SHIFT			0
-#define	OSD_W1BMP6_PAL07			(0xff << 8)
-#define	OSD_W1BMP6_PAL07_SHIFT			8
-#define	OSD_W1BMP6_PAL06			(0xff << 0)
-#define	OSD_W1BMP6_PAL06_SHIFT			0
-#define	OSD_W1BMP8_PAL09			(0xff << 8)
-#define	OSD_W1BMP8_PAL09_SHIFT			8
-#define	OSD_W1BMP8_PAL08			(0xff << 0)
-#define	OSD_W1BMP8_PAL08_SHIFT			0
-#define	OSD_W1BMPA_PAL11			(0xff << 8)
-#define	OSD_W1BMPA_PAL11_SHIFT			8
-#define	OSD_W1BMPA_PAL10			(0xff << 0)
-#define	OSD_W1BMPA_PAL10_SHIFT			0
-#define	OSD_W1BMPC_PAL13			(0xff << 8)
-#define	OSD_W1BMPC_PAL13_SHIFT			8
-#define	OSD_W1BMPC_PAL12			(0xff << 0)
-#define	OSD_W1BMPC_PAL12_SHIFT			0
-#define	OSD_W1BMPE_PAL15			(0xff << 8)
-#define	OSD_W1BMPE_PAL15_SHIFT			8
-#define	OSD_W1BMPE_PAL14			(0xff << 0)
-#define	OSD_W1BMPE_PAL14_SHIFT			0
-
-#define	OSD_MISCCT_RGBEN			(1 << 7)
-#define	OSD_MISCCT_RGBWIN			(1 << 6)
-#define OSD_MISCCT_RGBEN_SHIFT			7
-#define OSD_MISCCT_RGBWIN_SHIFT			6
-#define	OSD_MISCCT_TMON				(1 << 5)
-#define	OSD_MISCCT_RSEL				(1 << 4)
-#define	OSD_MISCCT_RSEL_SHIFT			4
-#define	OSD_MISCCT_CPBSY			(1 << 3)
-#define	OSD_MISCCT_PPSW				(1 << 2)
-#define	OSD_MISCCT_PPRV				(1 << 1)
-
-#define	OSD_CLUTRAMY_Y				(0xff << 8)
-#define	OSD_CLUTRAMY_Y_SHIFT			8
-#define	OSD_CLUTRAMY_CB				(0xff << 0)
-#define	OSD_CLUTRAMY_CB_SHIFT			0
-#define	OSD_CLUTRAM_CR				(0xff << 8)
-#define	OSD_CLUTRAM_CR_SHIFT			8
-#define	OSD_CLUTRAM_CADDR			(0xff << 0)
-#define	OSD_CLUTRAM_CADDR_SHIFT			0
-#define	OSD_TRANSPVA_RGBTRANS			(0xFFFF << 0)
-#define	OSD_TRANSPVA_RGBTRANS_SHIFT		0
-
-#define	OSD_OSDWIN0MD_CLUTS0			(1 <<	12)
-#define	OSD_OSDWIN1MD_CLUTS0			(1 <<	12)
-#define	OSD_OSDWIN0MD_CLUTS0_SHIFT		12
-#define	OSD_OSDWIN1MD_CLUTS1_SHIFT		12
-#define	OSD_OSDWIN0MD_ATN0E			(1 <<	14)
-#define	OSD_OSDWIN0MD_ATN0E_SHIFT		14
-#define	OSD_OSDWIN1MD_ATN1E			(1 <<	14)
-#define	OSD_OSDWIN1MD_ATN1E_SHIFT		14
-
-#define OSD_MODE_VHRSZ_SHIFT			10
-#define OSD_MODE_VVRSZ_SHIFT			11
-
-#define 	VENC_CMPNT_MRGB_SHIFT		14
-#define 	VENC_CMPNT_MRGB			(1 << 14)
-#define		SDTV_NTSC			1
-#define		SDTV_PAL			2
-#define		VENC_VMOD_TVTYP_SHIFT		6
+/* VMOD TVTYP options for HDMD=0 */
+#define SDTV_NTSC				0
+#define SDTV_PAL				1
+/* VMOD TVTYP options for HDMD=1 */
+#define HDTV_525P				0
+#define HDTV_625P				1
 
-#define VENC_VDPRO_DAFRQ			(1 << 3)
-#define VENC_VDPRO_DAUPS			(1 << 2)
-#define VENC_VDPRO_YUPS				(1 << 0)
-#define VENC_VDPRO_CUPS				(1 << 1)
-#define	HDTV_525P				0
-#define	HDTV_625P				1
-#define	VENC_VMOD_TVTYP_SHIFT			6
-
-#define VENC_VIDCTL_VCLKE			(1 << 13)
-#define VENC_VIDCTL_VCLKZ			(1 << 12)
-#define VENC_VIDCTL_SYDIR			(1 << 8)
-#define VENC_VIDCTL_YCDIR			(1 << 0)
 #define VENC_VIDCTL_VCLKP			(1 << 14)
-
-#define VENC_VIDCTL_VCLKZ_SHIFT			12
 #define VENC_VIDCTL_VCLKE_SHIFT			13
+#define VENC_VIDCTL_VCLKE			(1 << 13)
+#define VENC_VIDCTL_VCLKZ_SHIFT			12
+#define VENC_VIDCTL_VCLKZ			(1 << 12)
 #define VENC_VIDCTL_SYDIR_SHIFT			8
+#define VENC_VIDCTL_SYDIR			(1 << 8)
+#define VENC_VIDCTL_DOMD_SHIFT			4
+#define VENC_VIDCTL_DOMD			(3 << 4)
 #define VENC_VIDCTL_YCDIR_SHIFT			0
+#define VENC_VIDCTL_YCDIR			(1 << 0)
 
-#define PINMUX0_RGB666 			(1 << 22)
-#define PINMUX0_RGB666_SHIFT 		22
-#define PINMUX0_LOEEN 			(1 << 24)
-#define PINMUX0_LOEEN_SHIFT 		24
-
-#define VENC_SYNCCTL_SYEH  		(1 << 0)
-#define VENC_SYNCCTL_SYEV  		(1 << 1)
-#define VENC_SYNCCTL_HPL  		(1 << 2)
-#define VENC_SYNCCTL_VPL  		(1 << 3)
-
-#define VENC_SYNCCTL_SYEH_SHIFT   	0
-#define VENC_SYNCCTL_SYEV_SHIFT   	1
-#define VENC_SYNCCTL_HPL_SHIFT 	  	2
-#define VENC_SYNCCTL_VPL_SHIFT    	3
-
-#define VENC_DCLKCTL_DCKEC_SHIFT	11
-#define VENC_DCLKCTL_DCKEC		(1 << 11)
-#define VENC_DCLKCTL_DCKPW		(0x3f << 0)
-#define VENC_DCLKCTL_DCKPW_SHIFT	0
+#define VENC_VDPRO_ATYCC_SHIFT			5
+#define VENC_VDPRO_ATYCC			(1 << 5)
+#define VENC_VDPRO_ATCOM_SHIFT			4
+#define VENC_VDPRO_ATCOM			(1 << 4)
+#define VENC_VDPRO_DAFRQ			(1 << 3)
+#define VENC_VDPRO_DAUPS			(1 << 2)
+#define VENC_VDPRO_CUPS				(1 << 1)
+#define VENC_VDPRO_YUPS				(1 << 0)
 
-#define PINMUX0_LFLDEN  		(1 << 25)
+#define VENC_SYNCCTL_VPL_SHIFT    		3
+#define VENC_SYNCCTL_VPL  			(1 << 3)
+#define VENC_SYNCCTL_HPL_SHIFT 	  		2
+#define VENC_SYNCCTL_HPL  			(1 << 2)
+#define VENC_SYNCCTL_SYEV_SHIFT   		1
+#define VENC_SYNCCTL_SYEV  			(1 << 1)
+#define VENC_SYNCCTL_SYEH_SHIFT   		0
+#define VENC_SYNCCTL_SYEH  			(1 << 0)
+#define VENC_SYNCCTL_OVD_SHIFT   		14
+#define VENC_SYNCCTL_OVD  			(1 << 14)
+
+#define VENC_DCLKCTL_DCKEC_SHIFT		11
+#define VENC_DCLKCTL_DCKEC			(1 << 11)
+#define VENC_DCLKCTL_DCKPW_SHIFT		0
+#define VENC_DCLKCTL_DCKPW			(0x3f << 0)
+
+#define VENC_VSTAT_FIDST			(1 << 4)
+
+#define VENC_CMPNT_MRGB_SHIFT			14
+#define VENC_CMPNT_MRGB				(1 << 14)
+
+#define OSD_MODE_CS				(1 << 15)
+#define OSD_MODE_OVRSZ				(1 << 14)
+#define OSD_MODE_OHRSZ				(1 << 13)
+#define OSD_MODE_EF				(1 << 12)
+#define OSD_MODE_VVRSZ				(1 << 11)
+#define OSD_MODE_VHRSZ				(1 << 10)
+#define OSD_MODE_FSINV				(1 << 9)
+#define OSD_MODE_BCLUT				(1 << 8)
+#define OSD_MODE_CABG_SHIFT			0
+#define OSD_MODE_CABG				(0xff << 0)
+
+#define OSD_VIDWINMD_VFINV			(1 << 15)
+#define OSD_VIDWINMD_V1EFC			(1 << 14)
+#define OSD_VIDWINMD_VHZ1_SHIFT			12
+#define OSD_VIDWINMD_VHZ1			(3 << 12)
+#define OSD_VIDWINMD_VVZ1_SHIFT			10
+#define OSD_VIDWINMD_VVZ1			(3 << 10)
+#define OSD_VIDWINMD_VFF1			(1 << 9)
+#define OSD_VIDWINMD_ACT1			(1 << 8)
+#define OSD_VIDWINMD_V0EFC			(1 << 6)
+#define OSD_VIDWINMD_VHZ0_SHIFT			4
+#define OSD_VIDWINMD_VHZ0			(3 << 4)
+#define OSD_VIDWINMD_VVZ0_SHIFT			2
+#define OSD_VIDWINMD_VVZ0			(3 << 2)
+#define OSD_VIDWINMD_VFF0			(1 << 1)
+#define OSD_VIDWINMD_ACT0			(1 << 0)
+
+#define OSD_OSDWIN0MD_ATN0E			(1 << 14)
+#define OSD_OSDWIN0MD_RGB0E			(1 << 13)
+#define OSD_OSDWIN0MD_BMP0MD_SHIFT		13
+#define OSD_OSDWIN0MD_BMP0MD			(3 << 13)
+#define OSD_OSDWIN0MD_CLUTS0			(1 << 12)
+#define OSD_OSDWIN0MD_OHZ0_SHIFT		10
+#define OSD_OSDWIN0MD_OHZ0			(3 << 10)
+#define OSD_OSDWIN0MD_OVZ0_SHIFT		8
+#define OSD_OSDWIN0MD_OVZ0			(3 << 8)
+#define OSD_OSDWIN0MD_BMW0_SHIFT		6
+#define OSD_OSDWIN0MD_BMW0			(3 << 6)
+#define OSD_OSDWIN0MD_BLND0_SHIFT		3
+#define OSD_OSDWIN0MD_BLND0			(7 << 3)
+#define OSD_OSDWIN0MD_TE0			(1 << 2)
+#define OSD_OSDWIN0MD_OFF0			(1 << 1)
+#define OSD_OSDWIN0MD_OACT0			(1 << 0)
+
+#define OSD_OSDWIN1MD_OASW			(1 << 15)
+#define OSD_OSDWIN1MD_ATN1E			(1 << 14)
+#define OSD_OSDWIN1MD_RGB1E			(1 << 13)
+#define OSD_OSDWIN1MD_BMP1MD_SHIFT		13
+#define OSD_OSDWIN1MD_BMP1MD			(3 << 13)
+#define OSD_OSDWIN1MD_CLUTS1			(1 << 12)
+#define OSD_OSDWIN1MD_OHZ1_SHIFT		10
+#define OSD_OSDWIN1MD_OHZ1			(3 << 10)
+#define OSD_OSDWIN1MD_OVZ1_SHIFT		8
+#define OSD_OSDWIN1MD_OVZ1			(3 << 8)
+#define OSD_OSDWIN1MD_BMW1_SHIFT		6
+#define OSD_OSDWIN1MD_BMW1			(3 << 6)
+#define OSD_OSDWIN1MD_BLND1_SHIFT		3
+#define OSD_OSDWIN1MD_BLND1			(7 << 3)
+#define OSD_OSDWIN1MD_TE1			(1 << 2)
+#define OSD_OSDWIN1MD_OFF1			(1 << 1)
+#define OSD_OSDWIN1MD_OACT1			(1 << 0)
+
+#define OSD_OSDATRMD_OASW			(1 << 15)
+#define OSD_OSDATRMD_OHZA_SHIFT			10
+#define OSD_OSDATRMD_OHZA			(3 << 10)
+#define OSD_OSDATRMD_OVZA_SHIFT			8
+#define OSD_OSDATRMD_OVZA			(3 << 8)
+#define OSD_OSDATRMD_BLNKINT_SHIFT		6
+#define OSD_OSDATRMD_BLNKINT			(3 << 6)
+#define OSD_OSDATRMD_OFFA			(1 << 1)
+#define OSD_OSDATRMD_BLNK			(1 << 0)
+
+#define OSD_RECTCUR_RCAD_SHIFT			8
+#define OSD_RECTCUR_RCAD			(0xff << 8)
+#define OSD_RECTCUR_CLUTSR			(1 << 7)
+#define OSD_RECTCUR_RCHW_SHIFT			4
+#define OSD_RECTCUR_RCHW			(7 << 4)
+#define OSD_RECTCUR_RCVW_SHIFT			1
+#define OSD_RECTCUR_RCVW			(7 << 1)
+#define OSD_RECTCUR_RCACT			(1 << 0)
+
+#define OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
+
+#define OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
+
+#define OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
+
+#define OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
+
+#define OSD_VIDWINADH_V1AH_SHIFT		8
+#define OSD_VIDWINADH_V1AH			(0x7f << 8)
+#define OSD_VIDWINADH_V0AH_SHIFT		0
+#define OSD_VIDWINADH_V0AH			(0x7f << 0)
+
+#define OSD_VIDWIN0ADL_V0AL			(0xffff << 0)
+
+#define OSD_VIDWIN1ADL_V1AL			(0xffff << 0)
+
+#define OSD_OSDWINADH_O1AH_SHIFT		8
+#define OSD_OSDWINADH_O1AH			(0x7f << 8)
+#define OSD_OSDWINADH_O0AH_SHIFT		0
+#define OSD_OSDWINADH_O0AH			(0x7f << 0)
+
+#define OSD_OSDWIN0ADL_O0AL			(0xffff << 0)
+
+#define OSD_OSDWIN1ADL_O1AL			(0xffff << 0)
+
+#define OSD_BASEPX_BPX				(0x3ff << 0)
+
+#define OSD_BASEPY_BPY				(0x1ff << 0)
+
+#define OSD_VIDWIN0XP_V0X			(0x7ff << 0)
+
+#define OSD_VIDWIN0YP_V0Y			(0x7ff << 0)
+
+#define OSD_VIDWIN0XL_V0W			(0x7ff << 0)
+
+#define OSD_VIDWIN0YL_V0H			(0x7ff << 0)
+
+#define OSD_VIDWIN1XP_V1X			(0x7ff << 0)
+
+#define OSD_VIDWIN1YP_V1Y			(0x7ff << 0)
+
+#define OSD_VIDWIN1XL_V1W			(0x7ff << 0)
+
+#define OSD_VIDWIN1YL_V1H			(0x7ff << 0)
+
+#define OSD_OSDWIN0XP_W0X			(0x7ff << 0)
+
+#define OSD_OSDWIN0YP_W0Y			(0x7ff << 0)
+
+#define OSD_OSDWIN0XL_W0W			(0x7ff << 0)
+
+#define OSD_OSDWIN0YL_W0H			(0x7ff << 0)
+
+#define OSD_OSDWIN1XP_W1X			(0x7ff << 0)
+
+#define OSD_OSDWIN1YP_W1Y			(0x7ff << 0)
+
+#define OSD_OSDWIN1XL_W1W			(0x7ff << 0)
+
+#define OSD_OSDWIN1YL_W1H			(0x7ff << 0)
+
+#define OSD_CURXP_RCSX				(0x7ff << 0)
+
+#define OSD_CURYP_RCSY				(0x7ff << 0)
+
+#define OSD_CURXL_RCSW				(0x7ff << 0)
+
+#define OSD_CURYL_RCSH				(0x7ff << 0)
+
+#define OSD_EXTMODE_EXPMDSEL			(1 << 15)
+#define OSD_EXTMODE_SCRNHEXP_SHIFT		13
+#define OSD_EXTMODE_SCRNHEXP			(3 << 13)
+#define OSD_EXTMODE_SCRNVEXP			(1 << 12)
+#define OSD_EXTMODE_OSD1BLDCHR			(1 << 11)
+#define OSD_EXTMODE_OSD0BLDCHR			(1 << 10)
+#define OSD_EXTMODE_ATNOSD1EN			(1 << 9)
+#define OSD_EXTMODE_ATNOSD0EN			(1 << 8)
+#define OSD_EXTMODE_OSDHRSZ15			(1 << 7)
+#define OSD_EXTMODE_VIDHRSZ15			(1 << 6)
+#define OSD_EXTMODE_ZMFILV1HEN			(1 << 5)
+#define OSD_EXTMODE_ZMFILV1VEN			(1 << 4)
+#define OSD_EXTMODE_ZMFILV0HEN			(1 << 3)
+#define OSD_EXTMODE_ZMFILV0VEN			(1 << 2)
+#define OSD_EXTMODE_EXPFILHEN			(1 << 1)
+#define OSD_EXTMODE_EXPFILVEN			(1 << 0)
+
+#define OSD_MISCCTL_RGBEN			(1 << 7)
+#define OSD_MISCCTL_RGBWIN			(1 << 6)
+#define OSD_MISCCTL_DMANG			(1 << 6)
+#define OSD_MISCCTL_TMON			(1 << 5)
+#define OSD_MISCCTL_RSEL			(1 << 4)
+#define OSD_MISCCTL_CPBSY			(1 << 3)
+#define OSD_MISCCTL_PPSW			(1 << 2)
+#define OSD_MISCCTL_PPRV			(1 << 1)
+
+#define OSD_CLUTRAMYCB_Y_SHIFT			8
+#define OSD_CLUTRAMYCB_Y			(0xff << 8)
+#define OSD_CLUTRAMYCB_CB_SHIFT			0
+#define OSD_CLUTRAMYCB_CB			(0xff << 0)
+
+#define OSD_CLUTRAMCR_CR_SHIFT			8
+#define OSD_CLUTRAMCR_CR			(0xff << 8)
+#define OSD_CLUTRAMCR_CADDR_SHIFT		0
+#define OSD_CLUTRAMCR_CADDR			(0xff << 0)
+
+#define OSD_TRANSPVAL_RGBTRANS			(0xffff << 0)
+
+#define OSD_TRANSPVALL_RGBL			(0xffff << 0)
+
+#define OSD_TRANSPVALU_Y_SHIFT			8
+#define OSD_TRANSPVALU_Y 			(0xff << 8)
+#define OSD_TRANSPVALU_RGBU_SHIFT		0
+#define OSD_TRANSPVALU_RGBU			(0xff << 0)
+
+#define OSD_TRANSPBMPIDX_BMP1_SHIFT		8
+#define OSD_TRANSPBMPIDX_BMP1			(0xff << 8)
+#define OSD_TRANSPBMPIDX_BMP0_SHIFT		0
+#define OSD_TRANSPBMPIDX_BMP0			0xff
 
-#endif				/* _DAVINCIFB_H_ */
+#endif				/* _DAVINCI_VPBE_H_ */
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_aew.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_aew.h
@@ -0,0 +1,156 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_aew.h file */
+#ifndef DM355_AEW_DRIVER_H
+#define DM355_AEW_DRIVER_H
+
+/* Include Files */
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+#include <asm/semaphore.h>	/* For sempaphores */
+#include <asm/fcntl.h>
+#endif				/* end of #ifdef __KERNEL__ */
+
+/* Driver Range Constants*/
+#define AEW_WINDOW_VERTICAL_COUNT_MIN       1
+#define AEW_WINDOW_VERTICAL_COUNT_MAX       128
+#define AEW_WINDOW_HORIZONTAL_COUNT_MIN     2
+#define AEW_WINDOW_HORIZONTAL_COUNT_MAX     36
+#define AEW_WINDOW_SIZE                     18
+
+#define AEW_WIDTH_MIN                       8
+#define AEW_WIDTH_MAX                      256
+
+#define AEW_AVELMT_MAX                      1023
+
+#define AEW_HZ_LINEINCR_MIN                 2
+#define AEW_HZ_LINEINCR_MAX                 32
+
+
+#define AEW_VT_LINEINCR_MIN                 2
+#define AEW_VT_LINEINCR_MAX                 32
+
+#define AEW_HEIGHT_MIN                      2
+#define AEW_HEIGHT_MAX                      256
+
+#define AEW_HZSTART_MIN                      0
+#define AEW_HZSTART_MAX                      4095
+
+#define AEW_VTSTART_MIN                      0
+#define AEW_VTSTART_MAX                      4095
+
+#define AEW_BLKWINHEIGHT_MIN                2
+#define AEW_BLKWINHEIGHT_MAX                256
+
+#define AEW_BLKWINVTSTART_MIN               0
+#define AEW_BLKWINVTSTART_MAX               4095
+
+
+#ifdef __KERNEL__
+
+/* Device Constants*/
+#define AEW_NR_DEVS                         1
+#define DEVICE_NAME                         "dm355_aew"
+#define AEW_MAJOR_NUMBER                    0
+#define AEW_IOC_MAXNR                       4
+#define AEW_TIMEOUT                         (300 * HZ/1000)
+#endif
+
+
+/* List of ioctls */
+#pragma pack(1)
+#define AEW_MAGIC_NO    'e'
+#define AEW_S_PARAM     _IOWR(AEW_MAGIC_NO,1,struct aew_configuration *)
+#define AEW_G_PARAM     _IOWR(AEW_MAGIC_NO,2,struct aew_configuration *)
+#define AEW_ENABLE      _IO(AEW_MAGIC_NO,3)
+#define AEW_DISABLE     _IO(AEW_MAGIC_NO,4)
+#pragma  pack()
+
+/*Enum for device usage*/
+typedef enum {
+	AEW_NOT_IN_USE = 0,	/* Device is not in use */
+	AEW_IN_USE = 1		/* Device in use */
+} aew_In_use;
+
+/*Enum for Enable/Disable specific feature*/
+typedef enum {
+	H3A_AEW_ENABLE = 1,
+	H3A_AEW_DISABLE = 0
+} aew_alaw_enable;
+
+typedef enum {
+	H3A_AEW_CONFIG_NOT_DONE,
+	H3A_AEW_CONFIG
+} aew_config_flag;
+
+
+/* Contains the information regarding Window Structure in AEW Engine*/
+struct aew_window {
+	unsigned int width;	/* Width of the window */
+	unsigned int height;	/* Height of the window */
+	unsigned int hz_start;	/* Horizontal Start of the window */
+	unsigned int vt_start;	/* Vertical Start of the window */
+	unsigned int hz_cnt;	/* Horizontal Count */
+	unsigned int vt_cnt;	/* Vertical Count */
+	unsigned int hz_line_incr;	/* Horizontal Line Increment */
+	unsigned int vt_line_incr;	/* Vertical Line Increment */
+};
+
+/* Contains the information regarding the AEW Black Window Structure*/
+struct aew_black_window {
+	unsigned int height;	/* Height of the Black Window */
+	unsigned int vt_start;	/* Vertical Start of the black Window */
+};
+
+typedef enum _aew_input_src {
+	AEW_CCDC = 0,
+	AEW_SDRAM = 1
+} aew_input_src_t;
+/* Contains configuration required for setup of AEW engine*/
+struct aew_configuration {
+	aew_alaw_enable alaw_enable;	/* A-law status */
+	int saturation_limit;	/* Saturation Limit */
+	struct aew_window window_config;	/* Window for AEW Engine */
+	struct aew_black_window blackwindow_config;	/* Black Window */
+};
+#ifdef __KERNEL__
+/* Contains information about device structure of AEW*/
+struct aew_device {
+	aew_In_use in_use;	/* Driver usage flag */
+	struct aew_configuration *config;	/* Device configuration */
+	void *buff_old;		/* Contains latest statistics */
+	void *buff_curr;	/* Buffer in which HW will */
+	/*fill the statistics */
+	/*or HW is already filling */
+	/*statistics */
+	void *buff_app;		/* Buffer which will be passed */
+	/*to user on read call */
+	int buffer_filled;	/* Flag indicates statistics */
+	/*are available */
+	unsigned int size_window;	/* Window size in bytes */
+	wait_queue_head_t aew_wait_queue;	/*Wait queue for the driver */
+	struct semaphore read_blocked;	/* Semaphore for driver */
+	aew_config_flag aew_config;	/*Flag indicates Engine is configured */
+};
+
+int aew_hardware_setup(void);
+int aew_validate_parameters(void);
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/*End of DM355_AEW_H */
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_aew_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_aew_hw.h
@@ -0,0 +1,136 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_aew_hw.h file */
+
+
+#ifndef DM355_AEW_DRIVER_HW_H
+#define DM355_AEW_DRIVER_HW_H
+
+/* Include Files */
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+
+#ifdef __KERNEL__
+
+/* Register Offsets */
+#define AEWPID          0x0000000	/*Peripheral Revision */
+					    /*and Class Information */
+#define AEWPCR          0x00000004	/*Peripheral Control Register */
+#define AEWWIN1         0x0000004c	/*Configuration for AE/AWB Windows */
+#define AEWINSTART      0x00000050	/*Start position for AE/AWB Windows */
+#define AEWINBLK        0x00000054	/*Start position and */
+					    /*height for black linr */
+					/*of AE/AWB Windows */
+#define AEWSUBWIN       0x00000058	/*Configuration for subsampled data */
+					/* in AE/AWB windows */
+#define AEWBUFST        0x0000005c	/*SDRAM/DDRAM Start address */
+					    /*for AEW Engine */
+
+#define AEW_RSDR_ADDR	0x00000060	/*SDRAM/DDRAM Read Address */
+#define AEW_RSDR_OFFSET	0x00000064	/*SDRAM/DDRAM Line Offset */
+#define AEW_SDR_FRSIZE	0x00000068	/*Frame Size for SDRAM read data */
+/* PID fields */
+#define AEW_TID             (0xFF<<16)
+#define AEW_CID             (0xFF<<8)
+#define AEW_PREV            0xFF
+
+/* PCR FIELDS */
+#define AVE2LMT             	(0x3ff<<22)	/*Saturation Limit */
+#define AEW_SDR_FETCH_ENABLE	(1<<21)
+#define AEW_INP_WIDTH		(1<<20)
+#define AEW_INP_SRC		(1<<19)
+#define AEW_ALAW_EN         	(1<<17)	/*Alaw Enable/Disable Bit */
+#define AEW_BUSYAF          	(1<<15)	/* Busy Bit for AF */
+#define AEW_BUSYAEWB        	(1<<18)	/*Busy bit for AEW */
+#define AEW_EN              	(1<<16)	/*AEW Engine Enable/Disable bit */
+
+/* AEWWIN1 fields */
+#define WINH                	(0x7F<<24)	/*Window Height */
+#define WINW                	(0x7f<<13)	/*Window Width */
+#define WINVC               	(0x7f<<6)	/*Window vertical Count */
+#define WINHC               	0x3f	/*Window Horizontal Count */
+
+/* AEWWINSTART fields */
+#define WINSV               	(0xfff<<16)	/*Window Vertical Start */
+#define WINSH               	0xfff	/*Window Horizontal start */
+
+/* AEWWINBLK fields */
+#define BLKWINSV            	(0xfff<<16)	/*Black Window Vertical Start */
+#define BLKWINH             	0x7f	/* Black Window height */
+
+/* AEWSUBWIN fields */
+#define AEWINCV             	(0xf<<8)	/*Vertical Lime Increment */
+#define AEWINCH             	0xf	/*Horizontal Line Increment */
+
+/* BIT POSITIONS */
+#define AEW_AVE2LMT_SHIFT		22
+
+#define AEW_WINH_SHIFT			24
+#define AEW_WINW_SHIFT              	13
+#define AEW_VT_COUNT_SHIFT		6
+#define AEW_VT_START_SHIFT		16
+#define AEW_LINE_INCR_SHIFT		8
+#define AEW_BLKWIN_VT_START_SHIFT   	16
+#define AEW_EN_SHIFT                	16
+#define AEW_BUSYAEWB_SHIFT          	18
+#define AEW_INP_SRC_SHIFT               19
+
+//#define AEW_INTSEL			IO_ADDRESS(0x1c70810)
+
+
+#define AEW_SET_VAL(x)       	    	(((x)/2)-1)
+#define AEW_NOT_EVEN		        1
+#define AEW_CHECK_EVEN(x)	        ((x)%2)
+
+
+#define AEW_CCDC			0
+#define AEW_INTSTATBASE			(IO_ADDRESS(0x01C7080C))
+#define AEW_EVNTSELADDR			(IO_ADDRESS(0x01C70814))
+
+
+//#define AEW_SELINT(val)			outl(val,AEW_INTSEL)
+//#define AEW_EVNTSEL(val)		outl(val,AEW_EVNTSELADDR)
+//#define AEW_GETINT			inl(AEW_INTSEL)
+//#define AEW_INTMASK			(0xF << 16)
+#define AEW_GETINTSTAT			inl(AEW_INTSTATBASE)
+#define AEW_SETGAMMAWD			outl(0x00000010,IO_ADDRESS(0x01C70680))
+#define	AEW_CLKCTRL_ADDR		(IO_ADDRESS(0x01C70004))
+#define AEW_GETCLKCTRL			inl(AEW_CLKCTRL_ADDR)
+#define AEW_SETCLKCTRL(val)		outl(val,AEW_CLKCTRL_ADDR)
+
+#define AEW_IOBASE_VADDR 		(IO_ADDRESS(0x01c70080))	/*Base Addr */
+
+#define regw(val,reg)               	outl(val,(reg+AEW_IOBASE_VADDR))
+#define regr(reg)                   	inl(reg+AEW_IOBASE_VADDR)
+
+#define AEW_GETEVNT			inl(AEW_EVNTSELADDR)
+
+
+
+#define AEW_GET_PCR                 	inl(AEW_IOBASE_VADDR + AEWPCR);
+
+#define isbusy()			(regr(AEWPCR) & 0x40000)
+
+/* Function Declaration */
+int aew_register_setup(struct aew_device *);
+void aew_engine_setup(int);
+void aew_set_address(unsigned long);
+
+#endif				/*end of #ifdef __KERNEL__ */
+
+#endif				/*end of #ifdef __DAVINCI_AEW_HW_H */
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_af.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_af.h
@@ -0,0 +1,182 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_af.h file */
+#ifndef AF_DM355_DRIVER_H
+#define AF_DM355_DRIVER_H
+
+/* Kernel Header files */
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>	/* printk  */
+#include <linux/wait.h>		/* Wait queue */
+#include <asm/semaphore.h>	/* Semphores */
+#include <asm/io.h>
+#endif				/*End of __KERNEL_ */
+
+#ifdef __KERNEL__
+/* Device Constants */
+#define AF_MAJOR_NUMBER                 0
+#define DEVICE_NAME                     "dm355_af"
+#define AF_NR_DEVS                      1
+#define AF_TIMEOUT                      (300*HZ)/1000
+#endif				/*enf of #ifdef __KERNEL__ */
+
+/* Range Constants */
+
+#define AF_PAXEL_HORIZONTAL_COUNT_MIN       1
+#define AF_PAXEL_HORIZONTAL_COUNT_MAX       36
+
+#define AF_PAXEL_VERTICAL_COUNT_MIN         1
+#define AF_PAXEL_VERTICAL_COUNT_MAX         128
+
+#define AF_PAXEL_SIZE                       48
+
+#define AF_WIDTH_MIN                        8
+#define AF_WIDTH_MAX                        256
+
+#define AF_LINE_INCR_MIN                    2
+#define AF_LINE_INCR_MAX                    32
+
+#define AF_HEIGHT_MIN                       2
+#define AF_HEIGHT_MAX                       256
+
+#define AF_HZSTART_MIN                      2
+#define AF_HZSTART_MAX                      4094
+
+#define AF_VTSTART_MIN                      0
+#define AF_VTSTART_MAX                      4095
+
+#define AF_MEDTH_MAX                        255
+
+#define AF_IIRSH_MAX                        4094
+#define AF_COEF_MIN                         0xFFFFF800
+#define AF_COEF_MAX                         0x000007FF
+
+
+//#define IRQ_H3AINT  3
+#define AF_NUMBER_OF_COEF                   11
+
+
+/* list of ioctls */
+#pragma pack(1)
+#define  AF_IOC_MAXNR       5
+#define  AF_MAGIC_NO        'a'
+#define  AF_S_PARAM         _IOWR(AF_MAGIC_NO,1,struct af_configuration *)
+#define  AF_G_PARAM         _IOWR(AF_MAGIC_NO,2,struct af_configuration *)
+#define  AF_ENABLE          _IO(AF_MAGIC_NO,3)
+#define  AF_DISABLE         _IO(AF_MAGIC_NO,4)
+#pragma  pack()
+
+/* enum used for status of specific feature */
+typedef enum {
+	H3A_AF_DISABLE = 0,
+	H3A_AF_ENABLE = 1
+} af_alaw_enable, af_hmf_enable;
+typedef enum {
+	H3A_AF_CONFIG_NOT_DONE,
+	H3A_AF_CONFIG
+} af_config_flag;
+
+struct af_reg_dump {
+	unsigned int addr;
+	unsigned int val;
+};
+
+/* enum used for keep track of whether hardware is used */
+typedef enum {
+	AF_NOT_IN_USE = 0,
+	AF_IN_USE = 1
+} af_In_use;
+
+typedef enum {
+	ACCUMULATOR_SUMMED = 0,
+	ACCUMULATOR_PEAK = 1
+} af_mode;
+
+/* Red, Green, and blue pixel location in the AF windows */
+typedef enum {
+	GR_GB_BAYER = 0,	/* GR and GB as Bayer pattern */
+	RG_GB_BAYER = 1,	/* RG and GB as Bayer pattern */
+	GR_BG_BAYER = 2,	/* GR and BG as Bayer pattern */
+	RG_BG_BAYER = 3,	/* RG and BG as Bayer pattern */
+	GG_RB_CUSTOM = 4,	/* GG and RB as custom pattern */
+	RB_GG_CUSTOM = 5	/* RB and GG as custom pattern */
+} rgbpos;
+
+/* Contains the information regarding the Horizontal Median Filter */
+struct af_hmf {
+	af_hmf_enable enable;	/* Status of Horizontal Median Filter */
+	unsigned int threshold;	/* Threshhold Value for */
+	/*Horizontal Median Filter */
+};
+
+/* Contains the information regarding the IIR Filters */
+struct af_iir {
+	unsigned int hz_start_pos;	/* IIR Start Register Value */
+	int coeff_set0[AF_NUMBER_OF_COEF];	/* IIR Filter Coefficient for Set 0 */
+	int coeff_set1[AF_NUMBER_OF_COEF];	/* IIR Filter Coefficient for Set 1 */
+};
+
+/* Contains the information regarding the Paxels Structure in AF Engine */
+struct af_paxel {
+	unsigned int width;	/* Width of the Paxel */
+	unsigned int height;	/* Height of the Paxel */
+	unsigned int hz_start;	/* Horizontal Start Position */
+	unsigned int vt_start;	/* Vertical Start Position */
+	unsigned int hz_cnt;	/* Horizontal Count */
+	unsigned int vt_cnt;	/* vertical Count */
+	unsigned int line_incr;	/* Line Increment */
+};
+
+
+/* Contains the parameters required for hardware set up of AF Engine */
+struct af_configuration {
+	af_alaw_enable alaw_enable;	/*ALAW status */
+	struct af_hmf hmf_config;	/*HMF configurations */
+	rgbpos rgb_pos;		/*RGB Positions */
+	struct af_iir iir_config;	/*IIR filter configurations */
+	struct af_paxel paxel_config;	/*Paxel parameters */
+	af_mode mode;		/*Accumulator mode */
+
+};
+
+#ifdef __KERNEL__
+/* Structure for device of AF Engine */
+struct af_device {
+	af_In_use in_use;	/*Driver usage counter */
+	struct af_configuration *config;	/*Device configuration structure */
+	void *buff_old;		/*Contains the latest statistics */
+	void *buff_curr;	/*Buffer in which HW will */
+	/*fill the statistics */
+	/*or HW is already filling statistics */
+	void *buff_app;		/*Buffer which will be passed to */
+	/* user space on read call */
+	unsigned int buff_size;	/* Size of image buffer */
+	int buffer_filled;	/*Flag indicates */
+	/*statistics are available */
+	int size_paxel;		/*Paxel size in bytes */
+	wait_queue_head_t af_wait_queue;	/*Wait queue for driver */
+	struct semaphore read_blocked;	/* Semaphore for driver */
+	af_config_flag af_config;	/*Flag indicates Engine is configured */
+
+};
+
+#endif				/* __KERNEL__ */
+
+#endif				/* AF_DM355_DRIVER_H */
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_af_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_af_hw.h
@@ -0,0 +1,164 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_af.h file */
+
+#ifndef DM355_AF_DRIVER_HW_H
+#define DM355_AF_DRIVER_HW_H
+
+/* Include driver header file */
+#include "dm355_af.h"
+
+#ifdef __KERNEL__
+
+/* Register Offsets */
+#define AFPID               0x0	/*Peripheral Revision */
+					/*and Class Information */
+#define AFPCR               0x00000004	/*Peripheral Control Register */
+#define AFPAX1              0x00000008	/*Setup for the Paxel Configuration */
+#define AFPAX2              0x0000000c	/*Setup for the Paxel Configuration */
+#define AFPAXSTART          0x00000010	/*Start Position for AF Engine Paxels */
+#define AFIIRSH             0x00000014	/*Start Position for IIRSH */
+#define AFBUFST             0x00000018	/*SDRAM/DDRAM Start address */
+#define AFCOEF010           0x0000001c	/*IIR filter coefficient data 
+					   for SET 0 */
+#define AFCOEF032           0x00000020	/*IIR filter coefficient data
+					   for SET 0 */
+#define AFCOEF054           0x00000024	/*IIR filter coefficient data 
+					   for SET 0 */
+#define AFCOEF076           0x00000028	/*IIR filter coefficient data
+					   for SET 0 */
+#define AFCOEF098           0x0000002c	/*IIR filter coefficient data 
+					   for SET 0 */
+#define AFCOEF0010          0x00000030	/*IIR filter coefficient data 
+					   for SET 0 */
+#define AFCOEF110           0x00000034	/*IIR filter coefficient data 
+					   for SET 1 */
+#define AFCOEF132           0x00000038	/*IIR filter coefficient 
+					   data for SET 1 */
+#define AFCOEF154           0x0000003c	/*IIR filter coefficient data 
+					   for SET 1 */
+#define AFCOEF176           0x00000040	/*IIR filter coefficient data 
+					   for SET 1 */
+#define AFCOEF198           0x00000044	/*IIR filter coefficient data 
+					   for SET 1 */
+#define AFCOEF1010          0x00000048	/*IIR filter coefficient data 
+					   for SET 1 */
+#define AF_RSDR_ADDR	0x00000060	/*SDRAM/DDRAM Read Address */
+#define AF_RSDR_OFFSET	0x00000064	/*SDRAM/DDRAM Line Offset */
+#define AF_SDR_FRSIZE	0x00000068	/*Frame Size for SDRAM read data */
+
+#define AFCOEF_OFFSET	0x00000004	/* COEFFICIENT BASE ADDRESS */
+//#define AF_INTSEL	IO_ADDRESS(0x1c70810)
+
+#define AF_SET_VAL(x)       	(((x)/2)-1)
+#define AF_NOT_EVEN		        1
+#define AF_CHECK_EVEN(x)	    ((x)%2)
+/* Register Fields */
+/*
+ *    PID fields
+ */
+#define AF_TID                          (0xFF<<16)
+#define AF_CID                          (0xFF<<8)
+#define AF_PREV                         0xFF
+
+/*
+ *    PCR fields
+ */
+#define AVE2LMT                         (0x3FF<<22)
+#define AF_INP_SRC			(1<<19)
+#define AF_BUSYAEWB                     (1<<18)
+#define AEW_ALAW_EN                     (1<<17)
+#define AEW_EN                          (1<<16)
+#define AF_BUSYAF                       (1<<15)
+#define FVMODE                          (1<<14)
+#define RGBPOS                          (0x7<<11)
+#define MED_TH                          (0xFF<<3)
+#define AF_MED_EN                       (1<<2)
+#define AF_ALAW_EN                      (1<<1)
+#define AF_EN                           (1<<0)
+
+#define AF_SETGAMMAWD			outl(0x00000010,IO_ADDRESS(0x01C70680))
+
+/*
+ * AFPAX1 fields
+ */
+#define PAXW                            (0x7F<<16)
+#define PAXH                            0x7F
+
+#define AF_CCDC				0
+/*
+ * AFPAX2 fields
+ */
+#define  AFINCV                         (0xF<<13)
+#define  PAXVC                          (0x7F<<6)
+#define  PAXHC                          0x3F
+
+/*
+ * AFPAXSTART fields
+ */
+#define  PAXSH                          (0xFFF<<16)
+#define  PAXSV                          0xFFF
+
+/*
+ * COEFFICIENT MASK
+ */
+
+#define COEF_MASK0                      0xFFF
+#define COEF_MASK1                      (0xFFF<<16)
+
+
+/* SDRAM Frame Size */
+#define AF_SDR_FRSIZE_HSIZE             0xFFF
+#define AF_SDR_FRSIZE_VSIZE		(0xFFF<<16)
+#define AF_SDR_FRSIZE_BITSEL		(0x7<<28)
+
+/* BIT SHIFTS */
+#define AF_RGBPOS_SHIFT                 11
+#define AF_MED_TH_SHIFT                 3
+#define AF_PAXW_SHIFT                   16
+#define AF_LINE_INCR_SHIFT              13
+#define AF_VT_COUNT_SHIFT               6
+#define AF_HZ_START_SHIFT               16
+#define AF_COEF_SHIFT                   16
+#define AF_INP_SRC_SHIFT                19
+#define AF_GETFRAME_SIZE 		(inl(IO_ADDRESS(0x01C70910)))
+#define AF_GETINIT_XY 			(inl(IO_ADDRESS(0x01C70910)))
+#define AF_INTSTATBASE			(IO_ADDRESS(0x01C7080C))
+#define AF_EVNTSELADDR			(IO_ADDRESS(0x01C70814))
+#define	AF_CLKCTRL_ADDR			(IO_ADDRESS(0x01C70004))
+#define AF_GETCLKCTRL			inl(AF_CLKCTRL_ADDR)
+#define AF_SETCLKCTRL(val)		outl(val,AF_CLKCTRL_ADDR)
+
+/* Macros for register read and write */
+#define AF_IOBASE_VADDR                 IO_ADDRESS(0x01c70080)
+#define regr(reg)                       inl((reg)+AF_IOBASE_VADDR)
+#define regw(val,reg)                   outl(val,(reg)+AF_IOBASE_VADDR)
+#define AF_GET_PCR                      inl(AF_IOBASE_VADDR + AFPCR)
+//#define AF_SELINT(val)			outl(val,AF_INTSEL)
+//#define AFSETINT(val)			outl(val,AF_INTSEL)
+//#define AF_EVNTSEL(val)			outl(val,AF_EVNTSELADDR)
+//#define AF_GETINT			inl(AF_INTSEL)
+//#define AF_GETEVNT			inl(AF_EVNTSELADDR)
+//#define AF_INTMASK			(0xF << 16)
+#define AF_GETINTSTAT			inl(AF_INTSTATBASE)
+/* Function declaration */
+int af_register_setup(struct af_device *);
+void af_engine_setup(int);
+void af_set_address(unsigned long);
+#endif				/*enf of #ifdef __KERNEL__  */
+#endif
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_ipipe.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_ipipe.h
@@ -0,0 +1,553 @@
+/*
+ * 
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* dm355_ipipe.h file */
+
+
+#ifndef DM355_IPIPE_H
+#define DM355_IPIPE_H
+
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+
+/* include linux specific header files */
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <asm/semaphore.h>
+
+#endif	/* End of #ifdef __KERNEL__ */
+
+
+#define MAX_SIZE_DFC			1024
+#define MAX_SIZE_EEC			1024
+#define MAX_SIZE_GAMMA			512
+
+#define MAX_SIZE_RAW_BY_PASS		4096
+#define MAX_SIZE			1344
+#define MAX_SIZE_RSZ0			1344
+#define MAX_SIZE_RSZ1			640
+
+#define WB_GAIN_MAX     4
+#define RGB_MAX         3
+
+#define MAX_BUFFER      8
+#define SET_LOW_ADD    	0x0000FFFF
+#define SET_HIGH_ADD	0xFFFF0000
+
+#define IPIPE_BUF_IN     0	/* input buffer */
+#define IPIPE_BUF_OUT    1	/* output buffer */
+
+#define IPIPE_INWIDTH_8BIT   0	/* pixel width of 8 bitS */
+#define IPIPE_INWIDTH_10BIT  1	/* pixel width of 10 bits */
+
+/* 
+ * list of enums
+ */
+typedef enum copy_method {
+	FROMTOP    = 0,
+	FROMBOTTON = 1
+}copy_method_t; 
+
+typedef enum sampling_type {
+	BOX = 0,
+	DIAMOND = 1
+}sampling_type_t;
+
+typedef enum pre_filter_type {
+        AVG4PIX = 0,
+        AVG2MEDPIX = 1
+}pre_filter_type_t;
+
+typedef enum enable_disable {
+	DISABLE =  0,
+	ENABLE =   1
+}enable_disable_t;
+
+typedef enum gamma_cor {
+        GC_ENABLE = 0,
+        GC_BYPASS = 1
+}gamma_cor_t;
+
+typedef enum gamma_tbl {
+        IPIPE_RAM = 0,
+        IPIPE_ROM = 1
+}gamma_tbl_t;
+
+typedef enum gamma_siz {
+        IPIPE_128  = 0,
+        IPIPE_256  = 1,
+        IPIPE_RESV = 2,
+        IPIPE_512  = 3
+}gamma_siz_t;
+
+
+typedef enum _ipipe_dpaths_fmt {
+	RAW2YUV = 0,
+	RAW2RAW = 1,
+	RAW2BOX = 2,
+	YUV2YUV = 3,
+	RAW2RAW_BYPASS = 4
+}ipipe_dpaths_fmt_t;
+
+typedef enum _ipipe_dpaths_bypass {
+        RAW_MODE_OFF = 0,
+        RAW_MODE_ON  = 1    
+}ipipe_dpaths_bypass_t;
+
+typedef enum _ipipe_colpat {
+	RED = 0, 	
+	GREEN_RED  = 1,	
+	GREEN_BLUE = 2,
+	BLUE = 3 
+}ipipe_colpat_t;
+
+typedef enum fcs_typ {
+        Y          = 0,
+        HPF_HORZ   = 1,
+	HPF_VERT   = 2,
+	HPF_2D     = 3,
+	HPF_2D_YEE = 4	
+}fcs_typ_t;
+
+/* Resizer */
+typedef enum rsz_h_typ {
+	CUBIC =  0,
+	LINEAR = 1
+}rsz_h_typ_t;
+
+typedef enum rsz_h_lse {
+	INTERNAL_VALUE   = 0,
+	PROGRAMMED_VALUE = 1 
+}rsz_h_lse_t;
+
+typedef enum _ipipe_rsz_rgb_typ {
+        OUTPUT_32BIT = 0,
+        OUTPUT_16BIT = 1,
+}ipipe_rsz_rgb_typ_t;
+
+typedef enum _ipipe_rsz_rgb_msk {
+        NOMASK = 0,
+        MASKLAST2 = 1,
+}ipipe_rsz_rgb_msk_t;
+
+typedef enum _data_shift{
+        BITS15_2	   = 0,
+        BITS14_1	   = 1,
+	BITS13_0	   = 2,
+	BITS12_0	   = 3,
+	BITS11_0	   = 4,
+	BITS10_0	   = 5,
+	BITS9_0	   	   = 6
+}ipipeif_data_shift;
+
+typedef enum _clk_sel{
+	PIXCEL_CLK	= 0,
+	SDRAM_CLK	= 1 	
+}ipipeif_clock;
+
+typedef enum _ialaw {
+	ALAW_OFF	= 0,
+	ALAW_ON		= 1
+}ipipeif_ialaw;
+
+typedef enum  _pack_mode {
+	SIXTEEN_BIT	= 0,
+	EIGHT_BIT	= 1
+}ipipeif_pack_mode;
+
+typedef enum   _avg_filter{
+	AVG_OFF		= 0,
+	AVG_ON		= 1
+}ipipeif_avg_filter;
+
+typedef enum _clk_div {
+	DIVIDE_HALF		= 0,
+	DIVIDE_THIRD		= 1,
+	DIVIDE_FOURTH		= 2,
+	DIVIDE_FIFTH		= 3,
+	DIVIDE_SIXTH		= 4,
+	DIVIDE_EIGHTH		= 5,
+	DIVIDE_SIXTEENTH	= 6,
+	DIVIDE_THIRTY		= 7
+	
+}ipipeif_clkdiv;
+
+typedef enum   _data_selection{
+	CCDC		= 0,
+	SDRAM_RAW	= 1,
+	CCDC_DARKFM	= 2,
+	SDRAM_YUV	= 3
+}ipipeif_input_source;
+
+typedef enum   _decimation {
+	DECIMATION_OFF	= 0,
+	DECIMATION_ON	= 1
+}ipipeif_decimation;
+
+typedef enum  _mode { 
+	CONTINUOUS	= 0,
+	ONE_SHOT	= 1
+}operation_mode;
+
+typedef enum _RSZ{
+	ONE		= 16,
+	ONE_HALF	= 32,
+	ONE_THIRD	= 48,
+	ONE_FOURTH	= 64,
+	ONE_FIFTH	= 80,
+	ONE_SIXTH	= 96,
+	ONE_SEVENTH	= 112
+	
+}ipipeif_rsz_ratio;
+
+
+
+/*struct ipipe_cropsize {
+	int hcrop;
+        int vcrop;
+};
+*/
+/* Defect Correction */
+struct ipipe_def_cor {
+	enable_disable_t dfc_en;
+	copy_method_t dfc_sel;
+
+        unsigned int dfc_siz;
+	unsigned int dfc_adr;	
+	unsigned int *dfc_table;
+};
+/* 
+ * list of structures 
+ */
+/* structure for request buffer */
+
+struct ipipe_reqbufs {
+        int buf_type;   /* type of frame buffer */
+        unsigned int size;       /* size of the frame buffer to be allocated */
+        int count;      /* number of frame buffer to be allocated */
+};	
+/* structure buffer */
+struct ipipe_buffer {
+        int index;      /* index number, 0 -> N-1 */
+        int buf_type;   /* buffer type, input or output */
+        unsigned int offset;     /* address of the buffer used in the mmap()
+                           system call */
+        unsigned int size;       /* size of the buffer */
+};
+
+
+/* Programmable Noise Filter */
+struct ipipe_prog_nf {   
+	enable_disable_t noise_fil_en;
+        unsigned int d2f_cfg_spr;
+	unsigned int d2f_cfg_shf;
+	sampling_type_t type; 
+        unsigned int *d2f_thr;
+        unsigned int *d2f_str;
+};
+
+/* Prefilter */
+struct ipipe_prefilter {
+	enable_disable_t pre_en;
+	pre_filter_type_t sel_0;
+	pre_filter_type_t sel_1;
+
+	enable_disable_t typ_adaptive; 
+	enable_disable_t typ_adaptive_dotred;
+	unsigned int pre_shf;
+	unsigned int pre_gain;
+	unsigned int pre_thr_g;
+	unsigned int pre_thr_b;
+	unsigned int pre_thr_1;
+};
+
+/* White Balance */
+struct ipipe_wb {
+	unsigned int wb2_dgn;
+	unsigned int wb2_wg_r;
+	unsigned int wb2_wg_gr;
+	unsigned int wb2_wg_gb;
+	unsigned int wb2_wg_b;
+};
+
+/* RGB to RGB conversion (include GAMMA correction) */
+struct ipipe_rgb2rgb {
+	unsigned int rgb_mul_rr;
+	unsigned int rgb_mul_gr;	
+	unsigned int rgb_mul_br;	
+        unsigned int rgb_mul_rg;
+        unsigned int rgb_mul_gg;
+        unsigned int rgb_mul_bg;
+	unsigned int rgb_mul_rb;
+	unsigned int rgb_mul_gb;
+	unsigned int rgb_mul_bb;
+	unsigned int rgb_oft_or;
+	unsigned int rgb_oft_og;
+	unsigned int rgb_oft_ob;
+	gamma_cor_t gmm_cfg_bypr;
+	gamma_cor_t gmm_cfg_bypg;
+	gamma_cor_t gmm_cfg_bypb;
+	gamma_tbl_t gmm_cfg_tbl;
+	gamma_siz_t gmm_cfg_siz;
+	/* 
+	unsigned int gmm_tbl_r[1024];
+	unsigned int gmm_tbl_b[1024];
+	unsigned int gmm_tbl_g[1024];
+	unsigned int gmm_tbl_all[1024];
+	*/
+	unsigned int *gmm_tbl_r;
+	unsigned int *gmm_tbl_b;
+	unsigned int *gmm_tbl_g;
+	unsigned int *gmm_tbl_all;
+};
+
+typedef enum yuv_phs_pos {
+	COSITING =  0,
+	CENTERING = 1
+}yuv_phs_pos_t;
+
+/* RGB to YUV(YCbCr) conversion */
+struct ipipe_rgb2yuv {
+	unsigned int yuv_adj_ctr;
+	unsigned int yuv_adj_brt;
+	
+	unsigned int yuv_mul_ry;
+	unsigned int yuv_mul_gy;
+	unsigned int yuv_mul_by;
+	unsigned int yuv_mul_rcb;
+	unsigned int yuv_mul_gcb;
+	unsigned int yuv_mul_bcb;
+	unsigned int yuv_mul_rcr;
+	unsigned int yuv_mul_gcr;
+	unsigned int yuv_mul_bcr;
+	unsigned int yuv_oft_y;
+	unsigned int yuv_oft_cb;
+	unsigned int yuv_oft_cr;
+	unsigned int yuv_y_min;
+	unsigned int yuv_y_max;
+	unsigned int yuv_c_min;
+	unsigned int yuv_c_max;
+	enable_disable_t yuv_phs_lpf;
+	yuv_phs_pos_t yuv_phs_position;	
+};
+
+/* Edge Enhancer */ 
+struct ipipe_edge_enhancer {
+	enable_disable_t yee_en;
+	enable_disable_t yee_emf;
+	unsigned int yee_shf;	
+	unsigned int yee_mul_00;
+	unsigned int yee_mul_01;
+	unsigned int yee_mul_02;
+	unsigned int yee_mul_10;
+	unsigned int yee_mul_11;
+	unsigned int yee_mul_12;
+	unsigned int yee_mul_20;	
+	unsigned int yee_mul_21;
+	unsigned int yee_mul_22;
+	unsigned int *ee_table;
+};
+
+/* False Color Suppression */
+struct ipipe_false_color_suppresion {
+	enable_disable_t fcs_en;
+	fcs_typ_t fcs_typ_typ;	
+	unsigned int fcs_shf_y;
+	unsigned int fcs_shf_c;
+	unsigned int fcs_thr;
+	unsigned int fcs_sgn;
+	unsigned int fcs_lth;	
+};
+
+/* Resizer Rescale Parameters*/
+struct ipipe_resizer_rescale_param {
+	unsigned int rsz_mode;
+	unsigned int rsz_i_vst;
+	unsigned int rsz_i_vsz;
+	unsigned int rsz_i_hst;
+	unsigned int rsz_o_vsz;
+	unsigned int rsz_o_hsz;
+        unsigned int rsz_o_hst;
+	unsigned int rsz_v_phs;
+        //unsigned int rsz_v_phs_o;
+	unsigned int rsz_v_dif;
+	//unsigned int rsz_v_siz_o;
+	unsigned int rsz_h_phs;
+	unsigned int rsz_h_dif;
+	rsz_h_typ_t rsz_h_typ;
+	rsz_h_lse_t rsz_h_lse_sel;
+	unsigned int rsz_h_lpf;
+}; 
+
+/* Resizer RGB Conversion Parameters */
+struct ipipe_resize2rgb {
+	enable_disable_t rsz_rgb_en;
+	ipipe_rsz_rgb_typ_t rsz_rgb_typ;
+	ipipe_rsz_rgb_msk_t rsz_rgb_msk0;
+	ipipe_rsz_rgb_msk_t rsz_rgb_msk1;
+//	unsigned int rsz_rgb_bld;
+	unsigned int rsz_rgb_alpha_val;
+};
+
+/* Resizer External Memory Parameters */
+struct ipipe_ext_mem_param {
+	unsigned int rsz_sdr_bad_h;
+	unsigned int rsz_sdr_bad_l;
+	unsigned int rsz_sdr_sad_h;
+	unsigned int rsz_sdr_sad_l;	
+	unsigned int rsz_sdr_oft;
+	unsigned int rsz_sdr_ptr_s;
+	unsigned int rsz_sdr_ptr_e;
+};	
+/*ipipeif structures*/
+struct ipipeif {
+	/*IPPEIF config register*/
+	ipipeif_data_shift data_shift;
+	ipipeif_clock clock_select;
+	
+	ipipeif_ialaw ialaw;
+	ipipeif_pack_mode pack_mode;
+	ipipeif_avg_filter avg_filter;
+	ipipeif_clkdiv clk_div;	
+	ipipeif_input_source source;
+	ipipeif_decimation decimation;
+	operation_mode mode;
+	
+	unsigned int glob_hor_size;
+	unsigned int glob_ver_size;
+	unsigned int hnum;
+	unsigned int vnum;
+	unsigned int adofs;
+	ipipeif_rsz_ratio rsz;
+	unsigned int gain;
+};
+/* structure for all configurations */ 
+struct ipipe_params {
+	struct ipipeif ipipeif_param;
+	
+	operation_mode ipipe_mode;
+	/*input/output datapath register*/
+	ipipe_dpaths_fmt_t ipipe_dpaths_fmt;
+	ipipe_dpaths_bypass_t ipipe_dpaths_bypass;
+	
+	/*color pattern register*/
+	ipipe_colpat_t ipipe_colpat_elep;
+        ipipe_colpat_t ipipe_colpat_elop;
+        ipipe_colpat_t ipipe_colpat_olep;
+        ipipe_colpat_t ipipe_colpat_olop;
+
+	/*horizontal/vertical start, horizontal/vertical size*/
+	unsigned int ipipe_vst;
+	unsigned int ipipe_vsz;
+	unsigned int ipipe_hst;
+	unsigned int ipipe_hsz;
+	/*interupt generation after lines*/
+	
+	struct ipipe_def_cor def_cor; 
+	struct ipipe_prog_nf prog_nf;
+	struct ipipe_prefilter prefilter; 
+	struct ipipe_wb wb; 	
+	struct ipipe_rgb2rgb rgb2rgb;
+	struct ipipe_rgb2yuv rgb2yuv; 
+ 	struct ipipe_edge_enhancer edge_enhancer; 	
+	struct ipipe_false_color_suppresion false_color_suppresion;
+	
+	enable_disable_t rsz_seq_seq;
+	enable_disable_t rsz_seq_tmm;
+	enable_disable_t rsz_seq_hrv;
+	enable_disable_t rsz_seq_vrv;
+	enable_disable_t rsz_seq_crv;
+	
+	enable_disable_t rsz_aal;
+
+	struct ipipe_resizer_rescale_param rsz_rsc_param[2];	
+	struct ipipe_resize2rgb rsz2rgb[2];	
+	struct ipipe_ext_mem_param ext_mem_param[2];	
+
+	enable_disable_t rsz_en[2];
+};
+struct ipipe_convert {
+        struct ipipe_buffer in_buff;
+        struct ipipe_buffer out_buff;
+};
+#ifdef __KERNEL__
+/* device structure keeps track of global information */
+struct ipipe_device {
+        struct ipipe_params *params;
+        unsigned char opened;		/* state of the device */
+        unsigned char in_numbuffers;	/* number of input buffers */
+        unsigned char out_numbuffers;	/* number of output buffers */
+        struct ipipe_buffer *in_buff[MAX_BUFFER];  /*pointer to input buffers*/
+        struct ipipe_buffer *out_buff[MAX_BUFFER]; /*pointer to output buffers */
+        struct completion wfc;/*used to wait for frame precessing to be completed*/
+        struct semaphore sem;
+};
+
+int ipipe_hw_setup(struct ipipe_params *config);
+int default_for_raw2raw(struct ipipe_params* parameter);
+int default_for_bypass(struct ipipe_params* parameter);
+int set_dfc_regs(struct ipipe_def_cor *dfc);
+int set_d2f_regs( struct ipipe_prog_nf *noise_filter);
+int set_pre_regs(struct ipipe_prefilter *pre_amplifier);
+int set_wb_regs(struct ipipe_wb *white_balance);
+int set_rgb_2_yuv_regs(int data_format,struct ipipe_rgb2yuv *y_cr_cb);
+int set_rgb_to_rgb_regs(struct ipipe_rgb2rgb *rgb);
+int set_ee_regs(struct ipipe_edge_enhancer *edge_enhance);
+int set_fcs_regs(struct ipipe_false_color_suppresion *color_supress);
+int set_rsz_regs(struct ipipe_params *param_resize);
+int set_aal_regs(struct ipipe_params *param_resize);
+int set_rsz_structs(struct ipipe_params *params );
+int write_out_addr(int resize_no,unsigned int address);
+
+int ipipe(struct ipipe_device *device, struct ipipe_convert *);
+int request_buffer(struct ipipe_device*, struct ipipe_reqbufs*);
+int query_buffer(struct ipipe_device*, struct ipipe_buffer*);
+irqreturn_t ipipe_isr(int, void*, struct pt_regs*);
+int free_buffers(struct ipipe_device*);
+int validate_params(struct ipipe_params*);
+#endif	/* End of #ifdef __KERNEL__ */
+/* ioctls definition */
+#define IPIPE_IOC_BASE   	'P'
+#define IPIPE_REQBUF     	_IOW(IPIPE_IOC_BASE, 1, struct ipipe_reqbufs)
+#define IPIPE_QUERYBUF   	_IOR(IPIPE_IOC_BASE, 2, struct ipipe_buffer)
+#define IPIPE_SET_PARAM  	_IOWR(IPIPE_IOC_BASE, 3, struct ipipe_params*)
+#define IPIPE_GET_PARAM  	_IOWR(IPIPE_IOC_BASE, 4, struct ipipe_params*)
+#define IPIPE_START	    	_IOWR(IPIPE_IOC_BASE,5, char)
+/*
+*/
+#define IPIPE_IOC_MAXNR 5 
+/* End of ioctls */
+
+#ifdef __KERNEL__
+struct vm_struct_area;
+struct inode;
+struct file;
+/* function definition for character driver interface functions */
+int ipipe_init(void);
+void ipipe_cleanup(void);
+int ipipe_open(struct inode *inode, struct file *);
+int ipipe_release(struct inode *inode, struct file *);
+int ipipe_ioctl(struct inode *inode, struct file *, unsigned int,
+		    unsigned long);
+int ipipe_mmap(struct file *, struct vm_area_struct *);
+
+#endif	/* End of #ifdef __KERNEL__ */
+
+#endif	/* End of DM355_IPIPE_H */
Index: linux-2.6.10/include/asm-arm/arch-davinci/dm355_ipipe_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/dm355_ipipe_hw.h
@@ -0,0 +1,324 @@
+/*
+ *
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_previewer_hw.h file */
+
+#ifndef DAVINCI_IPIPE_HW_H
+#define DAVINCI_IPIPE_HW_H
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>       /* printk() */
+#include <asm/io.h>             /* For IO_ADDRESS */
+
+#define IPIPE_IOBASE_VADDR      IO_ADDRESS(0x01C71000)
+#define IPIPEIF_IOBASE_VADDR    IO_ADDRESS(0x01C70100)
+#define VPSS_BL_BASE		IO_ADDRESS(0x01C70000)
+
+
+
+
+/* Register read/write */
+#define regw_ip(val, reg)    outl(val, (reg)+IPIPE_IOBASE_VADDR)
+#define regr_ip(reg)         inl((reg)+IPIPE_IOBASE_VADDR)
+#define regw_if(val, reg)    outl(val, (reg)+ IPIPEIF_IOBASE_VADDR)
+#define regr_if(reg)         inl((reg)+ IPIPEIF_IOBASE_VADDR)
+#define regw_vpss(val,reg)	outl(val, (reg)+ VPSS_BL_BASE)
+#define regr_vpss(reg)		inl((reg)+ VPSS_BL_BASE)
+
+
+
+/* -- */
+/* macro for bit set and clear */
+#define SETBIT(reg, bit)   (reg = ((reg) | ((0x00000001)<<(bit))))
+#define RESETBIT(reg, bit) (reg = ((reg) & (~(0x00000001<<(bit)))))
+/* -to set vpss reg for ipipe- */
+#define VPSS_PCR		0x0804 
+#define VPSS_MEMCTL		0x0818
+#define VPSS_CLK   		0x0004
+
+
+
+#define SDR_ENABLE		2/*int number for IRQ_EN*/
+/* Internal RAM table addresses for defect correction */ 
+#define DEF_COR_START_ADDR	0x0000
+#define DEF_COR_END_ADDR	0x07FF
+#define DEF_COR_SIZE		1024
+
+/* Internal RAM table addresses for gamma correction */
+#define GAMMA_START_ADDR      0x0000
+#define GAMMA_END_ADDR        0x03FF
+
+/*Internal RAM table addresses for edge enhancement correction*/
+#define EDGE_ENHANCE_START_ADDR		0x0200
+#define EDGE_ENHANCE_END_ADDR		0x01FF	
+/* -- */
+
+
+
+/* IPIPE Register Offsets from the base address */
+
+#define IPIPE_EN 		0x0000
+#define IPIPE_MODE 		0x0004
+#define IPIPE_DPATHS 		0x0008
+#define IPIPE_COLPAT		0x000C
+#define IPIPE_VST		0x0010
+#define IPIPE_VSZ 		0x0014
+#define IPIPE_HST		0x0018
+#define IPIPE_HSZ 		0x001C
+/*gated clock enable*/
+#define GCL_ARM			0x0024
+#define GCL_CCD 		0x0028
+#define GCL_SDR			0x002C
+/* Internal Memory Access */
+#define RAM_MODE		0x0030
+#define RAM_ADR			0x0034
+#define RAM_WDT			0x0038
+#define RAM_RDT			0x003C
+/* Interrupts */
+#define IRQ_EN			0x0040
+#define IRQ_RZA			0x0044
+#define IRQ_RZB			0x0048
+/* Defect Correction */ 
+#define DFC_EN			0x004C
+#define DFC_SEL			0x0050
+#define DFC_ADR			0x0054
+#define DFC_SIZE		0x0058
+/* Programmable Noise Filter */
+#define D2F_EN			0x005C
+#define D2F_CFG			0x0060
+#define DFC_THR			0x0064
+#define D2F_STR			0x00E4
+/* PreFilter */
+#define PRE_EN			0x0164
+#define PRE_TYP			0x0168
+#define PRE_SHF			0x016C
+#define PRE_GAIN		0x0170
+#define PRE_THR_G		0x0174
+#define PRE_THR_B		0x0178
+#define PRE_THR_1		0x017C
+/* White Balance */
+#define WB2_DGN			0x0180
+#define WB2_WG_R		0x0184
+#define WB2_WG_GR		0x0188
+#define WB2_WG_GB		0x018C
+#define WB2_WG_B		0x0190
+
+/* RGB to RGB conversion (include GAMMA correction) */
+#define RGB_MUL_RR		0x01F4
+
+/* Defect Correction */
+#define DFC_EN                  0x004C
+#define DFC_SEL                 0x0050
+#define DFC_ADR                 0x0054
+#define DFC_SIZ                 0x0058
+/* Programmable Noise Filter */
+#define D2F_EN                  0x005C
+#define D2F_CFG                 0x0060
+#define DFC_THR                 0x0064
+#define D2F_STR                 0x00E4
+/* PreFilter */
+#define PRE_EN                  0x0164
+#define PRE_TYP                 0x0168
+#define PRE_SHF                 0x016C
+#define PRE_GAIN                0x0170
+#define PRE_THR_G               0x0174
+#define PRE_THR_B               0x0178
+#define PRE_THR_1               0x017C
+/* White Balance */
+#define WB2_DGN                 0x0180
+#define WB2_WG_R                0x0184
+#define WB2_WG_GR               0x0188
+#define WB2_WG_GB               0x018C
+#define WB2_WG_B                0x0190
+
+/* RGB to RGB conversion (include GAMMA correction) */
+#define RGB_MUL_RR              0x01F4
+#define RGB_MUL_GR              0x01F8
+#define RGB_MUL_BR              0x01FC
+#define RGB_MUL_RG		0x0200
+#define RGB_MUL_GG		0x0204
+#define RGB_MUL_BG		0x0208
+#define RGB_MUL_RB		0x020C
+
+#define RGB_MUL_GB		0x0210
+#define RGB_MUL_BB		0x0214
+#define RGB_MUL_OR		0x0218
+#define RGB_MUL_OG		0x021C
+#define RGB_MUL_OB		0x0220
+#define GMM_CFG			0x0224
+
+/* RGB to YUV(YCbCr) conversion */
+#define YUV_ADJ 		0x0228
+#define YUV_MUL_RY 		0x022C
+#define YUV_MUL_GY 		0x0230
+#define YUV_MUL_BY 		0x0234
+#define YUV_MUL_RCB 		0x0238
+#define YUV_MUL_GCB 		0x023C
+#define YUV_MUL_BCB 		0x0240
+#define YUV_MUL_RCR 		0x0244
+#define YUV_MUL_GCR 		0x0248
+#define YUV_MUL_BCR 		0x024C
+#define YUV_OFT_Y 		0x0250
+#define YUV_OFT_CB 		0x0254
+#define YUV_OFT_CR 		0x0258
+#define YUV_Y_MIN 		0x025C
+#define YUV_Y_MAX 		0x0260
+#define YUV_C_MIN 		0x0264
+#define YUV_C_MAX 		0x0268
+#define YUV_PHS 		0x026C
+
+/* Edge Enhancer */
+#define YEE_EN			0x0270
+#define YEE_EMF			0x0274
+#define YEE_SHF			0x0278
+#define YEE_MUL_00		0x027C
+#define YEE_MUL_01		0x0280
+#define YEE_MUL_02		0x0284
+#define YEE_MUL_10		0x0288
+#define YEE_MUL_11		0x028C
+#define YEE_MUL_12		0x0290
+#define YEE_MUL_20		0x0294
+#define YEE_MUL_21		0x0298
+#define YEE_MUL_22		0x029C
+
+/* False Color Suppression */
+#define FCS_EN			0x02A0
+#define FCS_TYP			0x02A4
+#define FCS_SHF_Y		0x02A8
+#define FCS_SHF_C		0x02AC
+#define FCS_THR 		0x02B0
+#define FCS_SGN			0x02B4
+#define FCS_LTH			0x02B8
+
+/* Resizer */
+#define RSZ_SEQ                 0x02BC
+#define RSZ_AAL                 0x02C0
+
+/* Resizer Rescale Parameters */
+#define RSZ_EN_0	        0x02C4
+#define RSZ_EN_1             	0x0334
+/*offset of the registers to be added with base register of either RSZ0 or RSZ1*/
+#define RSZ_MODE	        0x4
+#define RSZ_I_VST               0x8
+#define RSZ_I_VSZ               0xC
+#define RSZ_I_HST               0x10
+#define RSZ_O_VSZ               0x14
+#define RSZ_O_HST               0x18
+#define RSZ_O_HSZ		0x1C
+#define RSZ_V_PHS               0x20
+#define RSZ_V_PHS_O	        0x24
+#define RSZ_V_DIF               0x28
+#define RSZ_V_SIZ_O             0x2C
+#define RSZ_H_PHS               0x30
+#define RSZ_H_DIF               0x34
+#define RSZ_H_TYP               0x38
+#define RSZ_H_LSE               0x3C
+#define RSZ_H_LPF             	0x40 
+
+/* Resizer RGB Conversion Parameters */
+#define RSZ_RGB_EN              0x44
+#define RSZ_RGB_TYP             0x48
+#define RSZ_RGB_BLD             0x4C
+
+/* Resizer External Memory Parameters */
+#define RSZ_SDR_BAD_H           0x50
+#define RSZ_SDR_BAD_L           0x54
+#define RSZ_SDR_SAD_H           0x58
+#define RSZ_SDR_SAD_L           0x5C
+#define RSZ_SDR_OFT             0x60
+#define RSZ_SDR_PTR_S           0x64
+#define RSZ_SDR_PTR_E           0x68
+#define RSZ_SDR_PTR_O           0x6C
+
+    
+/* Macro for resizer */
+#define IPIPE_RESIZER_0(i)  (IPIPE_IOBASE_VADDR + RSZ_EN_0 + i) 
+#define IPIPE_RESIZER_1(i)  (IPIPE_IOBASE_VADDR + RSZ_EN_1 + i)
+/* --*/
+
+/* Masking fields */
+#define IPIPE_MODE_WRT 		(1 << 1)
+#define IPIPE_DPATHS_FMT	(3 << 0)
+#define IPIPE_DPATHS_BYPASS	(1 << 2)
+#define IPIPE_COLPAT_ELEP	(3 << 0)
+#define IPIPE_COLPAT_ELOP	(3 << 2)
+#define IPIPE_COLPAT_OLEP	(3 << 4)
+#define IPIPE_COLPAT_OLOP	(3 << 6)
+#define IPIPE_D2F_CFG_SPR	(3 << 0)
+#define IPIPE_D2F_CFG_SHF       (3 << 2)
+#define IPIPE_D2F_CFG_TYP       (1 << 4)
+#define IPIPE_PRE_TYP_SEL1	(1 << 1)
+#define IPIPE_PRE_TYP_EN0       (1 << 2)
+#define IPIPE_PRE_TYP_EN1       (1 << 3)
+#define IPIPE_GMM_CFG_BYPG      (1 << 1)
+#define IPIPE_GMM_CFG_BYPB      (1 << 2)
+#define IPIPE_GMM_CFG_TBL       (1 << 4)
+#define IPIPE_GMM_CFG_SIZ       (3 << 5)
+#define IPIPE_YUV_ADJ_CTR	(0Xff << 0)
+#define IPIPE_YUV_ADJ_BRT       (0Xff << 8)
+#define IPIPE_YUV_PHS_LPF	(1 << 1)
+#define IPIPE_RSZ_SEQ_TMM	(1 << 1)
+#define IPIPE_RSZ_SEQ_HRV       (1 << 2)
+#define IPIPE_RSZ_SEQ_VRV       (1 << 3)
+#define IPIPE_RSZ_SEQ_CRV       (1 << 3)
+#define IPIPE_RSZ_RGB_TYP_MSK0  (1 << 1)
+#define IPIPE_RSZ_RGB_TYP_MSK1  (1 << 2)
+
+/* BIT FIELDS */
+
+#define IPIPE_DPATHS_BYPASS_SHIFT	 2
+#define IPIPE_COLPAT_ELOP_SHIFT		 2
+#define IPIPE_COLPAT_OLEP_SHIFT		 4
+#define IPIPE_COLPAT_OLOP_SHIFT		 6
+#define IPIPE_D2F_CFG_SHF_SHIFT          2
+#define IPIPE_D2F_CFG_TYP_SHIFT          4
+#define IPIPE_PRE_TYP_SEL1_SHIFT         1
+#define IPIPE_PRE_TYP_EN0_SHIFT          2
+#define IPIPE_PRE_TYP_EN1_SHIFT          3
+#define IPIPE_GMM_CFG_BYPG_SHIFT         1
+#define IPIPE_GMM_CFG_BYPB_SHIFT         2
+#define IPIPE_GMM_CFG_TBL_SHIFT          4
+#define IPIPE_GMM_CFG_SIZ_SHIFT          5
+#define IPIPE_YUV_ADJ_BRT_SHIFT          8
+#define IPIPE_YUV_PHS_LPF_SHIFT          1
+#define IPIPE_RSZ_SEQ_TMM_SHIFT          1
+#define IPIPE_RSZ_SEQ_HRV_SHIFT          2
+#define IPIPE_RSZ_SEQ_VRV_SHIFT          3
+#define IPIPE_RSZ_SEQ_CRV_SHIFT          3
+#define IPIPE_RSZ_RGB_TYP_MSK0_SHIFT     1
+#define IPIPE_RSZ_RGB_TYP_MSK1_SHIFT     2
+
+
+
+/* IPIPEIF Register Offsets from the base address */
+#define IPIPEIF_ENABLE 	0x00
+#define IPIPEIF_GFG 	0x04
+#define IPIPEIF_PPLN	0x08
+#define IPIPEIF_LPFR	0x0C
+#define IPIPEIF_HNUM 	0x10
+#define IPIPEIF_VNUM    0x14
+#define IPIPEIF_ADDRU   0x18
+#define IPIPEIF_ADDRL   0x1C
+#define IPIPEIF_ADOFS   0x20
+#define IPIPEIF_RSZ   	0x24
+#define IPIPEIF_GAIN   0x28
+
+#endif /* End of #ifdef __KERNEL__ */
+#endif  /* End of #ifdef DAVINCI_IPIPE_HW_H */
Index: linux-2.6.10/drivers/char/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/char/Kconfig
+++ linux-2.6.10/drivers/char/Kconfig
@@ -1105,6 +1105,7 @@ config MAX_RAW_DEVS
 config RESIZER
 	tristate "DaVinci Resizer Driver"
 	default n
+	depends on MACH_DAVINCI_EVM
 	help
 		DaVinci Resizer Driver.
 
@@ -1127,6 +1128,7 @@ config MMTIMER
 config PREVIEWER
 	tristate "DaVinci Previewer Driver Support"
 	default n
+	depends on MACH_DAVINCI_EVM
 	help
 		DaVinci Previewer Driver
 
Index: linux-2.6.10/mvl_patches/pro-1695.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1695.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1695);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

