#! /usr/bin/env bash
# Patch: -common_ppc_mpc8641
# Date: Tue Oct 17 14:05:34 2006
# Source: Freescale Semiconductor
# MR: 19567
# Type: Enhancement
# Disposition: local
# Signed-off-by: Dale Farnsworth <dfarnsworth@mvista.com>
# Description:
# 	Add support for Freescale MC8641D SOC
# 
# 	Add CPU support for the Freescale MC8641D and it's on-chip devices.
# 
# 	This patch is a heavily modified backport of kernel.org commit
# 	4ca4b6274c30d53d22014fb6974efe2b3e52cfdc.  It also contains code
# 	from an earlier Freescale 2.6.15/arch/ppc tree.
# 

PATCHNUM=951
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Freescale Semiconductor
MR: 19567
Type: Enhancement
Disposition: local
Signed-off-by: Dale Farnsworth <dfarnsworth@mvista.com>
Description:
	Add support for Freescale MC8641D SOC

	Add CPU support for the Freescale MC8641D and it's on-chip devices.

	This patch is a heavily modified backport of kernel.org commit
	4ca4b6274c30d53d22014fb6974efe2b3e52cfdc.  It also contains code
	from an earlier Freescale 2.6.15/arch/ppc tree.

Index: linux-2.6.10/arch/ppc/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/ppc/Kconfig
+++ linux-2.6.10/arch/ppc/Kconfig
@@ -54,14 +54,14 @@ choice
 	default 6xx
 
 config 6xx
-	bool "6xx/7xx/74xx/52xx/82xx/83xx"
+	bool "6xx/7xx/74xx/52xx/82xx/83xx/86xx"
 	select PPC_FPU
 	help
 	  There are four types of PowerPC chips supported.  The more common
 	  types (601, 603, 604, 740, 750, 7400), the Motorola embedded
-	  versions (821, 823, 850, 855, 860, 52xx, 82xx, 83xx), the IBM embedded
-	  versions (403 and 405) and the high end 64 bit Power processors
-	  (POWER 3, POWER4, and IBM 970 also known as G5)
+	  versions (821, 823, 850, 855, 860, 52xx, 82xx, 83xx 86xx), the
+	  IBM embedded versions (403 and 405) and the high end 64 bit
+	  Power processors (POWER 3, POWER4, and IBM 970 also known as G5)
 	  Unless you are building a kernel for one of the embedded processor
 	  systems, 64 bit IBM RS/6000 or an Apple G5, choose 6xx.
 	  Note that the kernel runs in 32-bit mode even on 64-bit chips.
@@ -244,6 +244,7 @@ config PPC601_SYNC_FIX
 
 source arch/ppc/platforms/4xx/Kconfig
 source arch/ppc/platforms/85xx/Kconfig
+source arch/ppc/platforms/86xx/Kconfig
 
 config PPC64BRIDGE
 	bool
@@ -557,7 +558,7 @@ endmenu
 
 choice
 	prompt "Machine Type"
-	depends on 6xx || POWER3 || POWER4
+	depends on (6xx && !86xx) || POWER3 || POWER4
 	default PPC_MULTIPLATFORM
 	---help---
 	  Linux currently supports several different kinds of PowerPC-based
@@ -1201,8 +1202,8 @@ config MCA
 	bool
 
 config PCI
-	bool "PCI support" if 40x || CPM2 || 83xx || 85xx
-	default y if !40x && !CPM2 && !8xx && !APUS && !83xx && !85xx
+	bool "PCI support" if 40x || CPM2 || 83xx || 85xx || 86xx
+	default y if !40x && !CPM2 && !8xx && !APUS && !83xx && !85xx && !86xx
 	default PCI_PERMEDIA if !4xx && !CPM2 && !8xx && APUS
 	default PCI_QSPAN if !4xx && !CPM2 && 8xx
 	help
Index: linux-2.6.10/arch/ppc/kernel/cpu_setup_6xx.S
===================================================================
--- linux-2.6.10.orig/arch/ppc/kernel/cpu_setup_6xx.S
+++ linux-2.6.10/arch/ppc/kernel/cpu_setup_6xx.S
@@ -204,9 +204,11 @@ setup_745x_specifics:
 	 * the firmware. If any, we disable NAP capability as
 	 * it's known to be bogus on rev 2.1 and earlier
 	 */
+BEGIN_FTR_SECTION
 	mfspr	r11,SPRN_L3CR
 	andis.	r11,r11,L3CR_L3E@h
 	beq	1f
+END_FTR_SECTION_IFSET(CPU_FTR_L3CR)
 	lwz	r6,CPU_SPEC_FEATURES(r5)
 	andi.	r0,r6,CPU_FTR_L3_DISABLE_NAP
 	beq	1f
Index: linux-2.6.10/arch/ppc/kernel/ppc_ksyms.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/kernel/ppc_ksyms.c
+++ linux-2.6.10/arch/ppc/kernel/ppc_ksyms.c
@@ -323,7 +323,7 @@ EXPORT_SYMBOL(cpm_install_handler);
 EXPORT_SYMBOL(cpm_free_handler);
 #endif /* CONFIG_8xx */
 #if defined(CONFIG_8xx) || defined(CONFIG_40x) || defined(CONFIG_85xx) ||\
-	defined(CONFIG_83xx)
+	defined(CONFIG_83xx) || defined(CONFIG_86xx)
 EXPORT_SYMBOL(__res);
 #endif
 
Index: linux-2.6.10/arch/ppc/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/Makefile
+++ linux-2.6.10/arch/ppc/Makefile
@@ -58,6 +58,7 @@ core-y				+= arch/ppc/kernel/ arch/ppc/p
 core-$(CONFIG_4xx)		+= arch/ppc/platforms/4xx/
 core-$(CONFIG_83xx)		+= arch/ppc/platforms/83xx/
 core-$(CONFIG_85xx)		+= arch/ppc/platforms/85xx/
+core-$(CONFIG_86xx)		+= arch/ppc/platforms/86xx/
 core-$(CONFIG_MATH_EMULATION)	+= arch/ppc/math-emu/
 core-$(CONFIG_XMON)		+= arch/ppc/xmon/
 core-$(CONFIG_APUS)		+= arch/ppc/amiga/
Index: linux-2.6.10/arch/ppc/platforms/86xx/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/86xx/Kconfig
@@ -0,0 +1,34 @@
+config 86xx
+	bool
+	depends on 6xx
+
+config PPC_OPENPIC_BE
+	bool
+	depends on 86xx
+	default y
+
+config PPC_INDIRECT_PCI_BE
+	bool
+	depends on 86xx
+	default y
+
+config PCIE
+	bool "PCI Express support"
+	depends on PCI && 86xx
+	default y
+
+config PPC_STD_MMU
+	bool
+	depends on 86xx
+	default y
+
+menu "Freescale 86xx Options"
+	depends on 86xx
+
+config PPC_GEN550
+	bool
+	depends on MPC8641
+	default y
+
+endmenu
+
Index: linux-2.6.10/arch/ppc/syslib/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/Makefile
+++ linux-2.6.10/arch/ppc/syslib/Makefile
@@ -116,3 +116,8 @@ endif
 obj-$(CONFIG_MPC8548_CDS)	+= todc_time.o
 obj-$(CONFIG_MPC8555_CDS)	+= todc_time.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc52xx_setup.o mpc52xx_pic.o
+obj-$(CONFIG_86xx)		+= open_pic.o ppc86xx_common.o ppc86xx_setup.o \
+				   ppc_sys.o mpc86xx_sys.o mpc86xx_devices.o
+ifeq ($(CONFIG_86xx),y)
+obj-$(CONFIG_PCIE)		+= ppc86xx_pcie.o
+endif
Index: linux-2.6.10/arch/ppc/syslib/mpc86xx_devices.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/mpc86xx_devices.c
@@ -0,0 +1,285 @@
+/*
+ * arch/ppc/platforms/86xx/mpc86xx_devices.c
+ *
+ * MPC86xx Device descriptions
+ *
+ * Maintainer: Xianghua Xiao <x.xiao@freescale.com>
+ *
+ * Copyright 2006 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/serial_8250.h>
+#include <linux/fsl_devices.h>
+#include <asm/mpc86xx.h>
+#include <asm/irq.h>
+#include <asm/ppc_sys.h>
+
+/* We use offsets for IORESOURCE_MEM since we do not know at compile time
+ * what CCSRBAR is, will get fixed up by mach_mpc86xx_fixup
+ */
+struct gianfar_mdio_data mpc86xx_mdio_pdata = {
+};
+
+static struct gianfar_platform_data mpc86xx_tsec1_pdata = {
+	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+	    FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
+	    FSL_GIANFAR_DEV_HAS_MULTI_INTR,
+};
+
+static struct gianfar_platform_data mpc86xx_tsec2_pdata = {
+	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+	    FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
+	    FSL_GIANFAR_DEV_HAS_MULTI_INTR,
+};
+
+static struct gianfar_platform_data mpc86xx_tsec3_pdata = {
+	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+	    FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
+	    FSL_GIANFAR_DEV_HAS_MULTI_INTR,
+};
+
+static struct gianfar_platform_data mpc86xx_tsec4_pdata = {
+	.device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+	    FSL_GIANFAR_DEV_HAS_COALESCE | FSL_GIANFAR_DEV_HAS_RMON |
+	    FSL_GIANFAR_DEV_HAS_MULTI_INTR,
+};
+
+static struct fsl_i2c_platform_data mpc86xx_fsl_i2c_pdata = {
+	.device_flags = FSL_I2C_DEV_SEPARATE_DFSRR,
+};
+
+static struct fsl_i2c_platform_data mpc86xx_fsl_i2c2_pdata = {
+	.device_flags = FSL_I2C_DEV_SEPARATE_DFSRR,
+};
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	[0] = {
+		.mapbase	= 0x4500,
+		.irq		= MPC86xx_IRQ_UART1,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.line		= 0,
+	},
+	[1] = {
+		.mapbase	= 0x4600,
+		.irq		= MPC86xx_IRQ_UART2,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.line		= 1,
+	},
+	{},
+};
+
+struct platform_device ppc_sys_platform_devices[] = {
+	[MPC86xx_TSEC1] = {
+		.name = "fsl-gianfar",
+		.id	= 1,
+		.dev.platform_data = &mpc86xx_tsec1_pdata,
+		.num_resources	 = 4,
+		.resource = (struct resource[]) {
+			{
+				.start	= MPC86xx_ENET1_OFFSET,
+				.end	= MPC86xx_ENET1_OFFSET +
+						MPC86xx_ENET1_SIZE - 1,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.name	= "tx",
+				.start	= MPC86xx_IRQ_TSEC1_TX,
+				.end	= MPC86xx_IRQ_TSEC1_TX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "rx",
+				.start	= MPC86xx_IRQ_TSEC1_RX,
+				.end	= MPC86xx_IRQ_TSEC1_RX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "error",
+				.start	= MPC86xx_IRQ_TSEC1_ERROR,
+				.end	= MPC86xx_IRQ_TSEC1_ERROR,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC86xx_TSEC2] = {
+		.name = "fsl-gianfar",
+		.id	= 2,
+		.dev.platform_data = &mpc86xx_tsec2_pdata,
+		.num_resources	 = 4,
+		.resource = (struct resource[]) {
+			{
+				.start	= MPC86xx_ENET2_OFFSET,
+				.end	= MPC86xx_ENET2_OFFSET +
+						MPC86xx_ENET2_SIZE - 1,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.name	= "tx",
+				.start	= MPC86xx_IRQ_TSEC2_TX,
+				.end	= MPC86xx_IRQ_TSEC2_TX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "rx",
+				.start	= MPC86xx_IRQ_TSEC2_RX,
+				.end	= MPC86xx_IRQ_TSEC2_RX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "error",
+				.start	= MPC86xx_IRQ_TSEC2_ERROR,
+				.end	= MPC86xx_IRQ_TSEC2_ERROR,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC86xx_TSEC3] = {
+		.name = "fsl-gianfar",
+		.id	= 3,
+		.dev.platform_data = &mpc86xx_tsec3_pdata,
+		.num_resources	 = 4,
+		.resource = (struct resource[]) {
+			{
+				.start	= MPC86xx_ENET3_OFFSET,
+				.end	= MPC86xx_ENET3_OFFSET +
+						MPC86xx_ENET3_SIZE - 1,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.name	= "tx",
+				.start	= MPC86xx_IRQ_TSEC3_TX,
+				.end	= MPC86xx_IRQ_TSEC3_TX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "rx",
+				.start	= MPC86xx_IRQ_TSEC3_RX,
+				.end	= MPC86xx_IRQ_TSEC3_RX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "error",
+				.start	= MPC86xx_IRQ_TSEC3_ERROR,
+				.end	= MPC86xx_IRQ_TSEC3_ERROR,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC86xx_TSEC4] = {
+		.name = "fsl-gianfar",
+		.id	= 4,
+		.dev.platform_data = &mpc86xx_tsec4_pdata,
+		.num_resources	 = 4,
+		.resource = (struct resource[]) {
+			{
+				.start	= MPC86xx_ENET4_OFFSET,
+				.end	= MPC86xx_ENET4_OFFSET +
+						MPC86xx_ENET4_SIZE - 1,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.name	= "tx",
+				.start	= MPC86xx_IRQ_TSEC4_TX,
+				.end	= MPC86xx_IRQ_TSEC4_TX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "rx",
+				.start	= MPC86xx_IRQ_TSEC4_RX,
+				.end	= MPC86xx_IRQ_TSEC4_RX,
+				.flags	= IORESOURCE_IRQ,
+			},
+			{
+				.name	= "error",
+				.start	= MPC86xx_IRQ_TSEC4_ERROR,
+				.end	= MPC86xx_IRQ_TSEC4_ERROR,
+				.flags	= IORESOURCE_IRQ,
+			},
+		},
+	},
+	[MPC86xx_MDIO] = {
+		.name = "fsl-gianfar_mdio",
+		.id = 0,
+		.dev.platform_data = &mpc86xx_mdio_pdata,
+		.num_resources = 1,
+		.resource = (struct resource[]) {
+			{
+				.start  = MPC86xx_MIIM_OFFSET,
+				.end	= MPC86xx_MIIM_OFFSET +
+						MPC86xx_MIIM_SIZE - 1,
+				.flags  = IORESOURCE_MEM,
+			},
+		},
+
+	},
+	[MPC86xx_DUART] = {
+		.name = "serial8250",
+		.id = 0,
+		.dev.platform_data = serial_platform_data,
+		.num_resources = 0,
+	},
+
+	[MPC86xx_IIC1] = {
+		.name = "fsl-i2c",
+		.id = 1,
+		.dev.platform_data = &mpc86xx_fsl_i2c_pdata,
+		.num_resources	= 2,
+		.resource = (struct resource[]) {
+			{
+				.start	= MPC86xx_IIC1_OFFSET,
+				.end	= MPC86xx_IIC1_OFFSET +
+						MPC86xx_IIC1_SIZE - 1,
+				.flags	= IORESOURCE_MEM,
+			},
+			{
+				.start	= MPC86xx_IRQ_IIC,
+				.end	= MPC86xx_IRQ_IIC,
+				.flags  = IORESOURCE_IRQ,
+			}
+		}
+	},
+	[MPC86xx_IIC2] = {
+		.name = "fsl-i2c",
+		.id  = 2,
+		.dev.platform_data = &mpc86xx_fsl_i2c2_pdata,
+		.num_resources  = 2,
+		.resource = (struct resource[]) {
+			{
+				.start  = MPC86xx_IIC2_OFFSET,
+				.end	= MPC86xx_IIC2_OFFSET +
+						MPC86xx_IIC2_SIZE - 1,
+				.flags  = IORESOURCE_MEM,
+			},
+			{
+				.start  = MPC86xx_IRQ_IIC,
+				.end	= MPC86xx_IRQ_IIC,
+				.flags  = IORESOURCE_IRQ,
+			}
+		}
+	}
+
+};
+
+static int __init mach_mpc86xx_fixup(struct platform_device *pdev)
+{
+	ppc_sys_fixup_mem_resource(pdev, CCSRBAR);
+	return 0;
+}
+
+static int __init mach_mpc86xx_init(void)
+{
+	ppc_sys_device_fixup = mach_mpc86xx_fixup;
+	return 0;
+}
+
+postcore_initcall(mach_mpc86xx_init);
Index: linux-2.6.10/arch/ppc/syslib/mpc86xx_sys.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/mpc86xx_sys.c
@@ -0,0 +1,45 @@
+/*
+ * arch/ppc/platforms/86xx/mpc86xx_sys.c
+ *
+ * MPC86xx System descriptions
+ *
+ * Maintainer: Jeff Brown <jeffrey@freescale.com>
+ *
+ * Copyright 2005 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <asm/ppc_sys.h>
+
+struct ppc_sys_spec *cur_ppc_sys_spec;
+struct ppc_sys_spec ppc_sys_specs[] = {
+	{
+		.ppc_sys_name	= "MPC8641D",
+		.mask		= 0xFFFF0F00,
+		.value		= 0x80900100,
+		.num_devices	= 8,
+		.device_list	= (enum ppc_sys_devices[])
+		{
+			MPC86xx_TSEC1, MPC86xx_TSEC2, MPC86xx_TSEC3, MPC86xx_TSEC4,
+			MPC86xx_DUART, MPC86xx_MDIO,MPC86xx_IIC1, MPC86xx_IIC2,
+		},
+	},
+	{
+		.ppc_sys_name	= "MPC8641",
+		.mask		= 0xFFFF0F00,
+		.value		= 0x80900000,
+		.num_devices	= 8,
+		.device_list	= (enum ppc_sys_devices[])
+		{
+			MPC86xx_TSEC1, MPC86xx_TSEC2, MPC86xx_TSEC3, MPC86xx_TSEC4,
+			MPC86xx_DUART, MPC86xx_MDIO,MPC86xx_IIC1, MPC86xx_IIC2,
+		},
+	},
+};
Index: linux-2.6.10/arch/ppc/syslib/open_pic.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/open_pic.c
+++ linux-2.6.10/arch/ppc/syslib/open_pic.c
@@ -27,7 +27,7 @@
 
 #include "open_pic_defs.h"
 
-#if defined(CONFIG_PRPMC800) || defined(CONFIG_85xx)
+#if defined(CONFIG_PRPMC800) || defined(CONFIG_85xx) || defined(CONFIG_86xx)
 #define OPENPIC_BIG_ENDIAN
 #endif
 
Index: linux-2.6.10/arch/ppc/syslib/ppc86xx_common.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/ppc86xx_common.c
@@ -0,0 +1,33 @@
+/*
+ * arch/ppc/syslib/ppc86xx_common.c
+ *
+ * MPC86xx support routines
+ *
+ * Maintainer: Jeff Brown <jeffrey@freescale.com>
+ *
+ * Copyright 2006 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mpc86xx.h>
+#include <asm/mmu.h>
+
+/* ************************************************************************ */
+/* Return the value of CCSRBAR for the current board */
+
+phys_addr_t
+get_ccsrbar(void)
+{
+	return BOARD_CCSRBAR;
+}
+
+EXPORT_SYMBOL(get_ccsrbar);
Index: linux-2.6.10/arch/ppc/syslib/ppc86xx_common.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/ppc86xx_common.h
@@ -0,0 +1,25 @@
+/*
+ * arch/ppc/syslib/ppc86xx_common.h
+ *
+ * MPC86xx support routines
+ *
+ * Maintainer: Jeff Brown <jeffrey@freescale.com>
+ *
+ * Copyright 2006 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __PPC_SYSLIB_PPC86XX_COMMON_H
+#define __PPC_SYSLIB_PPC86XX_COMMON_H
+
+#include <linux/config.h>
+#include <linux/init.h>
+
+/* Provide access to ccsrbar for any modules, etc */
+phys_addr_t get_ccsrbar(void);
+
+#endif /* __PPC_SYSLIB_PPC86XX_COMMON_H */
Index: linux-2.6.10/arch/ppc/syslib/ppc86xx_pcie.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/ppc86xx_pcie.c
@@ -0,0 +1,171 @@
+/*
+ * Support for indirect PCI bridges.
+ *
+ * Copyright (C) 1998 Gabriel Paubert.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * "Temporary" MPC8548 Errata file -
+ * The standard indirect_pci code should work with future silicon versions.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/machdep.h>
+
+#define PCI_CFG_OUT out_be32
+
+/* ERRATA PCI-Ex 14 PCIE Controller timeout */
+#define PCIE_FIX		out_be32(hose->cfg_addr+0x4, 0x0400ffff)
+
+
+static int
+indirect_read_config_pcie(struct pci_bus *bus, unsigned int devfn, int offset,
+			   int len, u32 *val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	volatile void __iomem *cfg_data;
+	u32 temp;
+
+	if (ppc_md.pci_exclude_device)
+		if (ppc_md.pci_exclude_device(bus->number, devfn))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Possible artifact of CDCpp50937 needs further investigation */
+	if (devfn != 0x0 && bus->number == 0xff)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	PCIE_FIX;
+	if (bus->number == 0xff) {
+		PCI_CFG_OUT(hose->cfg_addr,
+			    (0x80000000 | ((offset & 0xf00) << 16) |
+			     ((bus->number - hose->bus_offset) << 16)
+			     | (devfn << 8) | ((offset & 0xfc) )));
+	} else {
+		PCI_CFG_OUT(hose->cfg_addr,
+			    (0x80000001 | ((offset & 0xf00) << 16) |
+			     ((bus->number - hose->bus_offset) << 16)
+			     | (devfn << 8) | ((offset & 0xfc) )));
+	}
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	/* ERRATA PCI-Ex 12 - Configuration Address/Data Alignment */
+	cfg_data = hose->cfg_data;
+	PCIE_FIX;
+	temp = in_le32(cfg_data);
+	switch (len) {
+	case 1:
+		*val = (temp >> (((offset & 3))*8)) & 0xff;
+		break;
+	case 2:
+		*val = (temp >> (((offset & 3))*8)) & 0xffff;
+		break;
+	default:
+		*val = temp;
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+indirect_write_config_pcie(struct pci_bus *bus, unsigned int devfn, int offset,
+			    int len, u32 val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	volatile void __iomem *cfg_data;
+	u32 temp;
+
+	if (ppc_md.pci_exclude_device)
+		if (ppc_md.pci_exclude_device(bus->number, devfn))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Possible artifact of CDCpp50937 needs further investigation */
+	if (devfn != 0x0 && bus->number == 0xff)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	PCIE_FIX;
+	if (bus->number == 0xff) {
+		PCI_CFG_OUT(hose->cfg_addr,
+			    (0x80000000 | ((offset & 0xf00) << 16) |
+			     ((bus->number - hose->bus_offset) << 16)
+			     | (devfn << 8) | ((offset & 0xfc) )));
+	} else {
+		PCI_CFG_OUT(hose->cfg_addr,
+			    (0x80000001 | ((offset & 0xf00) << 16) |
+			     ((bus->number - hose->bus_offset) << 16)
+			     | (devfn << 8) | ((offset & 0xfc) )));
+	}
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	/* ERRATA PCI-Ex 12 - Configuration Address/Data Alignment */
+	cfg_data = hose->cfg_data;
+	switch (len) {
+	case 1:
+		PCIE_FIX;
+		temp = in_le32(cfg_data);
+		temp = (temp & ~(0xff << ((offset & 3) * 8))) |
+			(val << ((offset & 3) * 8));
+		PCIE_FIX;
+		out_le32(cfg_data, temp);
+		break;
+	case 2:
+		PCIE_FIX;
+		temp = in_le32(cfg_data);
+		temp = (temp & ~(0xffff << ((offset & 3) * 8)));
+		temp |= (val << ((offset & 3) * 8)) ;
+		PCIE_FIX;
+		out_le32(cfg_data, temp);
+		break;
+	default:
+		PCIE_FIX;
+		out_le32(cfg_data, val);
+		break;
+	}
+	PCIE_FIX;
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops indirect_pcie_ops = {
+	indirect_read_config_pcie,
+	indirect_write_config_pcie
+};
+
+void __init
+setup_indirect_pcie_nomap(struct pci_controller* hose, void __iomem * cfg_addr,
+	void __iomem * cfg_data)
+{
+	hose->cfg_addr = cfg_addr;
+	hose->cfg_data = cfg_data;
+	hose->ops = &indirect_pcie_ops;
+}
+
+void __init
+setup_indirect_pcie(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data)
+{
+	unsigned long base = cfg_addr & PAGE_MASK;
+	void __iomem *mbase, *addr, *data;
+
+	mbase = ioremap(base, PAGE_SIZE);
+	addr = mbase + (cfg_addr & ~PAGE_MASK);
+	if ((cfg_data & PAGE_MASK) != base)
+		mbase = ioremap(cfg_data & PAGE_MASK, PAGE_SIZE);
+	data = mbase + (cfg_data & ~PAGE_MASK);
+	setup_indirect_pcie_nomap(hose, addr, data);
+}
Index: linux-2.6.10/arch/ppc/syslib/ppc86xx_setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/ppc86xx_setup.c
@@ -0,0 +1,285 @@
+/*
+ * arch/ppc/syslib/ppc86xx_setup.c
+ *
+ * MPC86XX common board code
+ *
+ * Maintainer: Xianghua Xiao <x.xiao@freescale.com>
+ *
+ * Copyright 2006 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/prom.h>
+#include <asm/time.h>
+#include <asm/mpc86xx.h>
+#include <asm/immap_86xx.h>
+#include <asm/mmu.h>
+#include <asm/ppc_sys.h>
+#include <asm/kgdb.h>
+
+#include <syslib/ppc86xx_setup.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(fmt, args...) printk(KERN_ERR "%s: " fmt, __FUNCTION__, ## args)
+#else
+#define DBG(fmt, args...)
+#endif
+
+extern void kgdb8250_add_port(int i, struct uart_port *serial_req);
+
+#define CONFIG_86xx_PCI2	1
+
+/* Return the amount of memory */
+unsigned long __init
+mpc86xx_find_end_of_memory(void)
+{
+	bd_t *binfo;
+
+	binfo = (bd_t *) __res;
+
+	return binfo->bi_memsize;
+}
+
+/* The decrementer counts at the system (internal) clock freq divided by 8 */
+void __init
+mpc86xx_calibrate_decr(void)
+{
+	bd_t *binfo = (bd_t *) __res;
+	unsigned int freq, divisor, temp;
+
+	/* get the core frequency */
+	freq = binfo->bi_busfreq;
+
+	/* The timebase is updated every 4 bus clocks */
+	divisor = 4;
+	tb_ticks_per_jiffy = freq / divisor / HZ;
+	tb_to_us = mulhwu_scale_factor(freq / divisor, 1000000);
+
+	/* Set the time base to zero */
+	mtspr(SPRN_TBWL, 0);
+	mtspr(SPRN_TBWU, 0);
+
+	temp = mfspr(SPRN_HID0);
+	temp |= HID0_TBEN;
+	mtspr(SPRN_HID0, temp);
+}
+
+#ifdef CONFIG_SERIAL_8250
+void __init
+mpc86xx_early_serial_map(void)
+{
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	struct uart_port serial_req;
+#endif
+	struct plat_serial8250_port *pdata;
+	bd_t *binfo = (bd_t *) __res;
+	pdata = (struct plat_serial8250_port *) ppc_sys_get_pdata(MPC86xx_DUART);
+
+	/* Setup serial port access */
+	pdata[0].uartclk = binfo->bi_busfreq;
+	pdata[0].mapbase += binfo->bi_immr_base;
+	pdata[0].membase = ioremap(pdata[0].mapbase, MPC86xx_UART0_SIZE);
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	memset(&serial_req, 0, sizeof (serial_req));
+	serial_req.iotype = UPIO_MEM; /*SERIAL_IO_MEM;*/
+	serial_req.mapbase = pdata[0].mapbase;
+	serial_req.membase = pdata[0].membase;
+	serial_req.regshift = 0;
+	serial_req.uartclk = pdata[0].uartclk;
+	serial_req.irq = pdata[0].irq;
+	serial_req.line = pdata[0].line;
+	serial_req.flags = pdata[0].flags;
+
+	if (early_serial_setup(&serial_req) != 0)
+		printk(KERN_INFO "Early serial init of port 0 failed\n");
+#endif
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG)
+	gen550_init(0, &serial_req);
+#endif
+#ifdef CONFIG_KGDB_8250
+	kgdb8250_add_port(0, &serial_req);
+#endif
+
+	pdata[1].mapbase += binfo->bi_immr_base;
+	pdata[1].membase = ioremap(pdata[1].mapbase, MPC86xx_UART1_SIZE);
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	/*
+	 * Assume gen550_init() doesn't modify serial_req
+	 * and that port 0 and 1 have the same iotype, flags and uartclk
+	 */
+
+	serial_req.mapbase = pdata[1].mapbase;
+	serial_req.membase = pdata[1].membase;
+	serial_req.irq = pdata[0].irq;
+	serial_req.line = pdata[1].line;
+
+	if (early_serial_setup(&serial_req) != 0)
+		printk(KERN_INFO "Early serial init of port 1 failed\n");
+#endif
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG)
+	gen550_init(1, &serial_req);
+#endif
+#ifdef CONFIG_KGDB_8250
+	kgdb8250_add_port(1, &serial_req);
+#endif
+}
+#endif
+
+void
+mpc86xx_restart(char *cmd)
+{
+	local_irq_disable();
+	for(;;);
+}
+
+void
+mpc86xx_power_off(void)
+{
+	local_irq_disable();
+	for(;;);
+}
+
+void
+mpc86xx_halt(void)
+{
+	local_irq_disable();
+	for(;;);
+}
+
+extern int mpc86xx_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin);
+extern int mpc86xx_exclude_device(u_char bus, u_char devfn);
+
+#ifdef CONFIG_PCIE
+
+static void __init
+mpc86xx_setup_pcie(struct pci_controller *hose)
+{
+	volatile struct ccsr_pcie *pcie;
+	u16 cmd;
+	bd_t *binfo = (bd_t *) __res;
+
+	pcie = ioremap(binfo->bi_immr_base + MPC86xx_PCIE_OFFSET,
+		MPC86xx_PCIE_SIZE);
+
+	early_read_config_word(hose, 0, 0, PCI_COMMAND, &cmd);
+	cmd |=  PCI_COMMAND_SERR   | PCI_COMMAND_MASTER |
+		PCI_COMMAND_MEMORY | PCI_COMMAND_IO;
+	early_write_config_word(hose, 0, 0, PCI_COMMAND, cmd);
+	early_write_config_byte(hose, 0, 0, PCI_LATENCY_TIMER, 0x80);
+
+	/* PCIE Bus, Fix the MPC8641D host bridge's location to bus 0xFF. */
+	early_write_config_byte(hose, 0, 0x0, PCI_PRIMARY_BUS, 0xff);
+	early_write_config_byte(hose, 0xff, 0x0, PCI_SECONDARY_BUS, 0x0);
+	early_write_config_byte(hose, 0xff, 0x0, PCI_SUBORDINATE_BUS, 0xfe);
+
+	/* Disable all windows (except pcieowar0 since its ignored) */
+	pcie->pcieowar1 = 0;
+	pcie->pcieowar2 = 0;
+	pcie->pcieowar3 = 0;
+	pcie->pcieowar4 = 0;
+	pcie->pcieiwar1 = 0;
+	pcie->pcieiwar1 = 0;
+	pcie->pcieiwar2 = 0;
+	pcie->pcieiwar3 = 0;
+
+	/* Setup Phys:PCIE 1:1 outbound mem window @ MPC86XX_PCIE_LOWER_MEM */
+	pcie->pcieotar1 = (MPC86XX_PCIE_LOWER_MEM >> 12) & 0x000fffff;
+	pcie->pcieotear1 = 0x00000000;
+	pcie->pcieowbar1 = (MPC86XX_PCIE_LOWER_MEM >> 12) & 0x000fffff;
+	/* Enable, Mem R/W */
+	pcie->pcieowar1 = 0x80044000 |
+		(__ilog2(MPC86XX_PCIE_UPPER_MEM - MPC86XX_PCIE_LOWER_MEM + 1) - 1);
+
+	/* Setup outbound IO windows @ MPC86XX_PCIE_IO_BASE */
+	pcie->pcieotar2 = (MPC86XX_PCIE_LOWER_IO >> 12) & 0x000fffff;
+	pcie->pcieotear2 = 0x00000000;
+	pcie->pcieowbar2 = (MPC86XX_PCIE_IO_BASE >> 12) & 0x000fffff;
+	/* Enable, IO R/W */
+	pcie->pcieowar2 = 0x80088000 | (__ilog2(MPC86XX_PCIE_IO_SIZE) - 1);
+
+	/* Setup 2G inbound Memory Window @ 0 */
+	pcie->pcieitar1 = 0x00000000;
+	pcie->pcieiwbar1 = 0x00000000;
+	/* Enable, Prefetch, Local Mem, Snoop R/W, 2G */
+	pcie->pcieiwar1 = 0xa0f5501e;
+}
+#endif /* CONFIG_PCIE */
+
+void __init
+mpc86xx_setup_hose(void)
+{
+#ifdef CONFIG_PCIE
+	extern void setup_indirect_pcie(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data);
+
+	bd_t *binfo = (bd_t *) __res;
+	struct pci_controller* hose_a;
+
+	DBG("Adding PCIE host bridge\n");
+
+	hose_a = pcibios_alloc_controller();
+
+	if (!hose_a)
+		return;
+
+	ppc_md.pci_swizzle = common_swizzle;
+	ppc_md.pci_map_irq = mpc86xx_map_irq;
+
+	/* last_busno = 0xfe caused by MPC8641 PCIE bug */
+	hose_a->first_busno = 0x0;
+	hose_a->bus_offset = 0;
+	hose_a->last_busno = 0xfe;
+
+	setup_indirect_pcie(hose_a, binfo->bi_immr_base + PCIE1_CFG_ADDR_OFFSET,
+		binfo->bi_immr_base + PCIE1_CFG_DATA_OFFSET);
+	hose_a->set_cfg_type = 1;
+
+	mpc86xx_setup_pcie(hose_a);
+
+	hose_a->pci_mem_offset = MPC86XX_PCIE_MEM_OFFSET;
+	hose_a->mem_space.start = MPC86XX_PCIE_LOWER_MEM;
+	hose_a->mem_space.end = MPC86XX_PCIE_UPPER_MEM;
+
+	hose_a->io_space.start = MPC86XX_PCIE_LOWER_IO;
+	hose_a->io_space.end = MPC86XX_PCIE_UPPER_IO;
+	hose_a->io_base_phys = MPC86XX_PCIE_IO_BASE;
+	hose_a->io_base_virt =  ioremap(MPC86XX_PCIE_IO_BASE,
+					MPC86XX_PCIE_IO_SIZE);
+	isa_io_base = (unsigned long) hose_a->io_base_virt;
+
+	/* setup resources */
+	pci_init_resource(&hose_a->mem_resources[0],
+		MPC86XX_PCIE_LOWER_MEM,
+		MPC86XX_PCIE_UPPER_MEM,
+		IORESOURCE_MEM, "PCI Express host bridge");
+
+	pci_init_resource(&hose_a->io_resource,
+		MPC86XX_PCIE_LOWER_IO,
+		MPC86XX_PCIE_UPPER_IO,
+		IORESOURCE_IO, "PCI Express host bridge");
+
+	ppc_md.pci_exclude_device = mpc86xx_exclude_device;
+
+	hose_a->last_busno = pciauto_bus_scan(hose_a, hose_a->first_busno);
+
+#endif /* CONFIG_PCIE */
+}
+
Index: linux-2.6.10/arch/ppc/syslib/ppc86xx_setup.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/syslib/ppc86xx_setup.h
@@ -0,0 +1,57 @@
+/*
+ * arch/ppc/syslib/ppc86xx_setup.h
+ *
+ * MPC86XX common board definitions
+ *
+ * Maintainer: Xianghua Xiao <x.xiao@freescale.com>
+ *
+ * Copyright 2006 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __PPC_SYSLIB_PPC86XX_SETUP_H
+#define __PPC_SYSLIB_PPC86XX_SETUP_H
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/ppcboot.h>
+
+extern unsigned long mpc86xx_find_end_of_memory(void) __init;
+extern void mpc86xx_calibrate_decr(void) __init;
+extern void mpc86xx_early_serial_map(void) __init;
+extern void mpc86xx_restart(char *cmd);
+extern void mpc86xx_power_off(void);
+extern void mpc86xx_halt(void);
+extern void mpc86xx_setup_hose(void) __init;
+
+#define PCIE1_CFG_ADDR_OFFSET	(0x8000)
+#define PCIE1_CFG_DATA_OFFSET	(0x8004)
+
+#define PCIE2_CFG_ADDR_OFFSET	(0x9000)
+#define PCIE2_CFG_DATA_OFFSET	(0x9004)
+
+#define MPC86xx_PCIE_OFFSET PCIE1_CFG_ADDR_OFFSET
+#define MPC86xx_PCIE_SIZE (0x1000)
+
+/* Serial Config */
+#ifdef CONFIG_SERIAL_MANY_PORTS
+#define RS_TABLE_SIZE  64
+#else
+#define RS_TABLE_SIZE  2
+#endif
+
+#ifndef BASE_BAUD
+#define BASE_BAUD 115200
+#endif
+
+#ifndef SERIAL_PORT_DFNS
+#define SERIAL_PORT_DFNS
+#endif
+
+#endif /* __PPC_SYSLIB_PPC86XX_SETUP_H */
+
Index: linux-2.6.10/drivers/i2c/busses/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/i2c/busses/Kconfig
+++ linux-2.6.10/drivers/i2c/busses/Kconfig
@@ -207,12 +207,12 @@ config I2C_KEYWEST
 	  will be called i2c-keywest.
 
 config I2C_MPC
-	tristate "MPC107/824x/85xx/52xx"
+	tristate "MPC107/824x/85xx/52xx/86xx"
 	depends on I2C && PPC
 	help
 	  If you say yes to this option, support will be included for the
 	  built-in I2C interface on the MPC107/Tsi107/MPC8240/MPC8245 and
-	  MPC85xx family processors. The driver may also work on 52xx
+	  MPC85xx/MPC8641 family processors. The driver may also work on 52xx
 	  family processors, though interrupts are known not to work.
 
 	  This driver can also be built as a module.  If so, the module
Index: linux-2.6.10/include/asm-ppc/irq.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/irq.h
+++ linux-2.6.10/include/asm-ppc/irq.h
@@ -320,6 +320,86 @@ static __inline__ int irq_canonicalize(i
 	return irq;
 }
 
+#elif defined(CONFIG_86xx)
+#include <asm/mpc86xx.h>
+#define NR_EPIC_INTS	48
+#ifndef NR_8259_INTS
+#define NR_8259_INTS	16
+#endif
+#define NUM_8259_INTERRUPTS NR_8259_INTS
+
+#ifndef I8259_OFFSET
+#define I8259_OFFSET 0
+#endif
+
+#define NR_IRQS	256
+
+/* Internal IRQs on MPC86xx OpenPIC */
+
+#ifndef MPC86xx_OPENPIC_IRQ_OFFSET
+#define MPC86xx_OPENPIC_IRQ_OFFSET NR_8259_INTS
+#endif
+
+/* The 48 internal sources */
+#define MPC86xx_IRQ_NULL	( 0 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_MCM		( 1 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_DDR		( 2 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_LBC		( 3 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_DMA0	( 4 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_DMA1	( 5 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_DMA2	( 6 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_DMA3	( 7 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_PEX1	( 8 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_PEX2	( 9 + MPC86xx_OPENPIC_IRQ_OFFSET)
+/* no 10,11 */
+#define MPC86xx_IRQ_UART2	(12 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC1_TX	(13 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC1_RX	(14 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC3_TX	(15 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC3_RX	(16 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC3_ERROR (17 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC1_ERROR (18 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC2_TX	(19 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC2_RX	(20 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC4_TX	(21 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC4_RX	(22 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC4_ERROR (23 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_TSEC2_ERROR (24 + MPC86xx_OPENPIC_IRQ_OFFSET)
+/* no 25 */
+#define MPC86xx_IRQ_UART1	(26 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_IIC		(27 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_PERFMON	(28 + MPC86xx_OPENPIC_IRQ_OFFSET)
+/* no 29,30,31 */
+#define MPC86xx_IRQ_SRIO_ERROR	(32 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_SRIO_OUT_BELL (33 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_SRIO_IN_BELL  (34 + MPC86xx_OPENPIC_IRQ_OFFSET)
+/* no 35,36 */
+#define MPC86xx_IRQ_SRIO_OUT_MSG1 (37 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_SRIO_IN_MSG1  (38 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_SRIO_OUT_MSG2 (39 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_SRIO_IN_MSG2  (40 + MPC86xx_OPENPIC_IRQ_OFFSET)
+
+/* The 12 external interrupt lines */
+#define MPC86xx_IRQ_EXT0	(48 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT1	(49 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT2	(50 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT3	(51 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT4	(52 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT5	(53 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT6	(54 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT7	(55 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT8	(56 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT9	(57 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT10	(58 + MPC86xx_OPENPIC_IRQ_OFFSET)
+#define MPC86xx_IRQ_EXT11	(59 + MPC86xx_OPENPIC_IRQ_OFFSET)
+
+#define NR_IRQS			256
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return irq;
+}
+
 #else /* CONFIG_40x + CONFIG_8xx */
 /*
  * this is the # irq's for all ppc arch's (pmac/chrp/prep)
Index: linux-2.6.10/include/asm-ppc/reg.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/reg.h
+++ linux-2.6.10/include/asm-ppc/reg.h
@@ -470,6 +470,7 @@
 #define PVR_7450	0x80000000
 #define PVR_8540	0x80200000
 #define PVR_8560	0x80200000
+#define PVR_8641	0x80040000
 /*
  * For the 8xx processors, all of them report the same PVR family for
  * the PowerPC core. The various versions of these processors must be
Index: linux-2.6.10/include/asm-ppc/immap_86xx.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-ppc/immap_86xx.h
@@ -0,0 +1,201 @@
+/*
+ * include/asm-ppc/immap_86xx.h
+ *
+ * MPC86xx Internal Memory Map
+ *
+ * Maintainer: Jeff Brown <jeffrey@freescale.com>
+ *
+ * Copyright 2004 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_IMMAP_86XX_H__
+#define __ASM_IMMAP_86XX_H__
+
+/* Eventually this should define all the IO block registers in 86xx */
+
+/* PCI Registers */
+typedef struct ccsr_pci {
+	uint	cfg_addr;	/* 0x.000 - PCI Configuration Address Register */
+	uint	cfg_data;	/* 0x.004 - PCI Configuration Data Register */
+	uint	int_ack;	/* 0x.008 - PCI Interrupt Acknowledge Register */
+	char	res1[3060];
+	uint	potar0;		/* 0x.c00 - PCI Outbound Transaction Address Register 0 */
+	uint	potear0;	/* 0x.c04 - PCI Outbound Translation Extended Address Register 0 */
+	uint	powbar0;	/* 0x.c08 - PCI Outbound Window Base Address Register 0 */
+	char	res2[4];
+	uint	powar0;		/* 0x.c10 - PCI Outbound Window Attributes Register 0 */
+	char	res3[12];
+	uint	potar1;		/* 0x.c20 - PCI Outbound Transaction Address Register 1 */
+	uint	potear1;	/* 0x.c24 - PCI Outbound Translation Extended Address Register 1 */
+	uint	powbar1;	/* 0x.c28 - PCI Outbound Window Base Address Register 1 */
+	char	res4[4];
+	uint	powar1;		/* 0x.c30 - PCI Outbound Window Attributes Register 1 */
+	char	res5[12];
+	uint	potar2;		/* 0x.c40 - PCI Outbound Transaction Address Register 2 */
+	uint	potear2;	/* 0x.c44 - PCI Outbound Translation Extended Address Register 2 */
+	uint	powbar2;	/* 0x.c48 - PCI Outbound Window Base Address Register 2 */
+	char	res6[4];
+	uint	powar2;		/* 0x.c50 - PCI Outbound Window Attributes Register 2 */
+	char	res7[12];
+	uint	potar3;		/* 0x.c60 - PCI Outbound Transaction Address Register 3 */
+	uint	potear3;	/* 0x.c64 - PCI Outbound Translation Extended Address Register 3 */
+	uint	powbar3;	/* 0x.c68 - PCI Outbound Window Base Address Register 3 */
+	char	res8[4];
+	uint	powar3;		/* 0x.c70 - PCI Outbound Window Attributes Register 3 */
+	char	res9[12];
+	uint	potar4;		/* 0x.c80 - PCI Outbound Transaction Address Register 4 */
+	uint	potear4;	/* 0x.c84 - PCI Outbound Translation Extended Address Register 4 */
+	uint	powbar4;	/* 0x.c88 - PCI Outbound Window Base Address Register 4 */
+	char	res10[4];
+	uint	powar4;		/* 0x.c90 - PCI Outbound Window Attributes Register 4 */
+	char	res11[268];
+	uint	pitar3;		/* 0x.da0 - PCI Inbound Translation Address Register 3  */
+	char	res12[4];
+	uint	piwbar3;	/* 0x.da8 - PCI Inbound Window Base Address Register 3 */
+	uint	piwbear3;	/* 0x.dac - PCI Inbound Window Base Extended Address Register 3 */
+	uint	piwar3;		/* 0x.db0 - PCI Inbound Window Attributes Register 3 */
+	char	res13[12];
+	uint	pitar2;		/* 0x.dc0 - PCI Inbound Translation Address Register 2  */
+	char	res14[4];
+	uint	piwbar2;	/* 0x.dc8 - PCI Inbound Window Base Address Register 2 */
+	uint	piwbear2;	/* 0x.dcc - PCI Inbound Window Base Extended Address Register 2 */
+	uint	piwar2;		/* 0x.dd0 - PCI Inbound Window Attributes Register 2 */
+	char	res15[12];
+	uint	pitar1;		/* 0x.de0 - PCI Inbound Translation Address Register 1  */
+	char	res16[4];
+	uint	piwbar1;	/* 0x.de8 - PCI Inbound Window Base Address Register 1 */
+	char	res17[4];
+	uint	piwar1;		/* 0x.df0 - PCI Inbound Window Attributes Register 1 */
+	char	res18[12];
+	uint	err_dr;		/* 0x.e00 - PCI Error Detect Register */
+	uint	err_cap_dr;	/* 0x.e04 - PCI Error Capture Disable Register */
+	uint	err_en;		/* 0x.e08 - PCI Error Enable Register */
+	uint	err_attrib;	/* 0x.e0c - PCI Error Attributes Capture Register */
+	uint	err_addr;	/* 0x.e10 - PCI Error Address Capture Register */
+	uint	err_ext_addr;	/* 0x.e14 - PCI Error Extended Address Capture Register */
+	uint	err_dl;		/* 0x.e18 - PCI Error Data Low Capture Register */
+	uint	err_dh;		/* 0x.e1c - PCI Error Data High Capture Register */
+	uint	gas_timr;	/* 0x.e20 - PCI Gasket Timer Register */
+	uint	pci_timr;	/* 0x.e24 - PCI Timer Register */
+	char	res19[472];
+} ccsr_pci_t;
+
+/* PCI Express Registers */
+typedef struct ccsr_pcie {
+	uint	pcie_config_addr;	/* 0x.000 - PCI Express Configuration Address Register */
+	uint	pcie_config_data;	/* 0x.004 - PCI Express Configuration Data Register */
+	char	res1[4];
+	uint	pcie_otb_cpl_tor;	/* 0x.00c - PCI Express Outbound completion timeout register */
+	uint	pcie_conf_tor;		/* 0x.010 - PCI Express configuration timeout register */
+	char	res2[12];
+	uint	pcie_pme_mes_dr;	/* 0x.020 - PCI Express PME and message detect register */
+	uint	pcie_pme_mes_disr;	/* 0x.024 - PCI Express PME and message disable register */
+	uint	pcie_pme_mes_ier;	/* 0x.028 - PCI Express PME and message interrupt enable register */
+	uint	pcie_pmcr;		/* 0x.02c - PCI Express power management command register */
+	char	res3[3024];
+	uint	pcieotar0;		/* 0x.c00 - PCI Express outbound translation address register 0 */
+	uint	pcieotear0;		/* 0x.c04 - PCI Express outbound translation extended address register 0*/
+	char	res4[8];
+	uint	pcieowar0;		/* 0x.c10 - PCI Express outbound window attributes register 0*/
+	char	res5[12];
+	uint	pcieotar1;		/* 0x.c20 - PCI Express outbound translation address register 1 */
+	uint	pcieotear1;		/* 0x.c24 - PCI Express outbound translation extended address register 1*/
+	uint	pcieowbar1;		/* 0x.c28 - PCI Express outbound window base address register 1*/
+	char	res6[4];
+	uint	pcieowar1;		/* 0x.c30 - PCI Express outbound window attributes register 1*/
+	char	res7[12];
+	uint	pcieotar2;		/* 0x.c40 - PCI Express outbound translation address register 2 */
+	uint	pcieotear2;		/* 0x.c44 - PCI Express outbound translation extended address register 2*/
+	uint	pcieowbar2;		/* 0x.c48 - PCI Express outbound window base address register 2*/
+	char	res8[4];
+	uint	pcieowar2;		/* 0x.c50 - PCI Express outbound window attributes register 2*/
+	char	res9[12];
+	uint	pcieotar3;		/* 0x.c60 - PCI Express outbound translation address register 3 */
+	uint	pcieotear3;		/* 0x.c64 - PCI Express outbound translation extended address register 3*/
+	uint	pcieowbar3;		/* 0x.c68 - PCI Express outbound window base address register 3*/
+	char	res10[4];
+	uint	pcieowar3;		/* 0x.c70 - PCI Express outbound window attributes register 3*/
+	char	res11[12];
+	uint	pcieotar4;		/* 0x.c80 - PCI Express outbound translation address register 4 */
+	uint	pcieotear4;		/* 0x.c84 - PCI Express outbound translation extended address register 4*/
+	uint	pcieowbar4;		/* 0x.c88 - PCI Express outbound window base address register 4*/
+	char	res12[4];
+	uint	pcieowar4;		/* 0x.c90 - PCI Express outbound window attributes register 4*/
+	char	res13[12];
+	char	res14[256];
+	uint	pcieitar3;		/* 0x.da0 - PCI Express inbound translation address register 3 */
+	char	res15[4];
+	uint	pcieiwbar3;		/* 0x.da8 - PCI Express inbound window base address register 3 */
+	uint	pcieiwbear3;		/* 0x.dac - PCI Express inbound window base extended address register 3 */
+	uint	pcieiwar3;		/* 0x.db0 - PCI Express inbound window attributes register 3 */
+	char	res16[12];
+	uint	pcieitar2;		/* 0x.dc0 - PCI Express inbound translation address register 2 */
+	char	res17[4];
+	uint	pcieiwbar2;		/* 0x.dc8 - PCI Express inbound window base address register 2 */
+	uint	pcieiwbear2;		/* 0x.dcc - PCI Express inbound window base extended address register 2 */
+	uint	pcieiwar2;		/* 0x.dd0 - PCI Express inbound window attributes register 2 */
+	char	res18[12];
+	uint	pcieitar1;		/* 0x.de0 - PCI Express inbound translation address register 2 */
+	char	res19[4];
+	uint	pcieiwbar1;		/* 0x.de8 - PCI Express inbound window base address register 2 */
+	uint	pcieiwbear1;		/* 0x.dec - PCI Express inbound window base extended address register 2 */
+	uint	pcieiwar1;		/* 0x.df0 - PCI Express inbound window attributes register 2 */
+	char	res20[12];
+	uint	pcie_err_dr;		/* 0x.e00 - PCI Express error detect register */
+	char	res21[4];
+	uint	pcie_err_en;		/* 0x.e08 - PCI Express error interrupt enable register */
+	char	res22[4];
+	uint	pcie_err_disr;		/* 0x.e10 - PCI Express error disable register */
+	char	res23[12];
+	uint	pcie_err_cap_stat;	/* 0x.e20 - PCI Express error capture status register */
+	char	res24[4];
+	uint	pcie_err_cap_r0;	/* 0x.e28 - PCI Express error capture register 0 */
+	uint	pcie_err_cap_r1;	/* 0x.e2c - PCI Express error capture register 0 */
+	uint	pcie_err_cap_r2;	/* 0x.e30 - PCI Express error capture register 0 */
+	uint	pcie_err_cap_r3;	/* 0x.e34 - PCI Express error capture register 0 */
+} ccsr_pcie_t;
+
+/* Global Utility Registers */
+typedef struct ccsr_guts {
+	uint	porpllsr;	/* 0x.0000 - POR PLL Ratio Status Register */
+	uint	porbmsr;	/* 0x.0004 - POR Boot Mode Status Register */
+	uint	porimpscr;	/* 0x.0008 - POR I/O Impedance Status and Control Register */
+	uint	pordevsr;	/* 0x.000c - POR I/O Device Status Register */
+	uint	pordbgmsr;	/* 0x.0010 - POR Debug Mode Status Register */
+	char	res1[12];
+	uint	gpporcr;	/* 0x.0020 - General-Purpose POR Configuration Register */
+	char	res2[12];
+	uint	gpiocr;		/* 0x.0030 - GPIO Control Register */
+	char	res3[12];
+	uint	gpoutdr;	/* 0x.0040 - General-Purpose Output Data Register */
+	char	res4[12];
+	uint	gpindr;		/* 0x.0050 - General-Purpose Input Data Register */
+	char	res5[12];
+	uint	pmuxcr;		/* 0x.0060 - Alternate Function Signal Multiplex Control */
+	char	res6[12];
+	uint	devdisr;	/* 0x.0070 - Device Disable Control */
+	char	res7[12];
+	uint	powmgtcsr;	/* 0x.0080 - Power Management Status and Control Register */
+	char	res8[12];
+	uint	mcpsumr;	/* 0x.0090 - Machine Check Summary Register */
+	char	res9[12];
+	uint	pvr;		/* 0x.00a0 - Processor Version Register */
+	uint	svr;		/* 0x.00a4 - System Version Register */
+	char	res10[3416];
+	uint	clkocr;		/* 0x.0e00 - Clock Out Select Register */
+	char	res11[12];
+	uint	ddrdllcr;	/* 0x.0e10 - DDR DLL Control Register */
+	char	res12[12];
+	uint	lbcdllcr;	/* 0x.0e20 - LBC DLL Control Register */
+	char	res13[61916];
+} ccsr_guts_t;
+
+#endif /* __ASM_IMMAP_86XX_H__ */
+#endif /* __KERNEL__ */
Index: linux-2.6.10/include/asm-ppc/io.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/io.h
+++ linux-2.6.10/include/asm-ppc/io.h
@@ -34,6 +34,8 @@
 #include <asm/mpc83xx.h>
 #elif defined(CONFIG_85xx)
 #include <asm/mpc85xx.h>
+#elif defined(CONFIG_86xx)
+#include <asm/mpc86xx.h>
 #elif defined(CONFIG_APUS)
 #define _IO_BASE	0
 #define _ISA_MEM_BASE	0
Index: linux-2.6.10/include/asm-ppc/mpc86xx.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-ppc/mpc86xx.h
@@ -0,0 +1,111 @@
+/*
+ * include/asm-ppc/mpc86xx.h
+ *
+ * MPC86xx definitions
+ *
+ * Maintainer: Jeff Brown <jeffrey@freescale.com>
+ *
+ * Copyright 2004 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_MPC86xx_H__
+#define __ASM_MPC86xx_H__
+
+#include <linux/config.h>
+#include <asm/mmu.h>
+
+#ifdef CONFIG_86xx
+
+#define _IO_BASE	isa_io_base
+#define _ISA_MEM_BASE	isa_mem_base
+#ifdef CONFIG_PCI
+#define PCI_DRAM_OFFSET pci_dram_offset
+#else
+#define PCI_DRAM_OFFSET 0
+#endif
+
+#define CPU0_BOOT_RELEASE 0x01000000
+#define CPU1_BOOT_RELEASE 0x02000000
+#define CPU_ALL_RELEASED (CPU0_BOOT_RELEASE | CPU1_BOOT_RELEASE)
+#define MCM_PORT_CONFIG_OFFSET 0x1010
+/*
+ * The "residual" board information structure the boot loader passes
+ * into the kernel.
+ */
+extern unsigned char __res[];
+
+/* Offset from CCSRBAR */
+#define MPC86xx_DMA_OFFSET	(0x21000)
+#define MPC86xx_DMA_SIZE	(0x01000)
+#define MPC86xx_DMA0_OFFSET	(0x21100)
+#define MPC86xx_DMA0_SIZE	(0x00080)
+#define MPC86xx_DMA1_OFFSET	(0x21180)
+#define MPC86xx_DMA1_SIZE	(0x00080)
+#define MPC86xx_DMA2_OFFSET	(0x21200)
+#define MPC86xx_DMA2_SIZE	(0x00080)
+#define MPC86xx_DMA3_OFFSET	(0x21280)
+#define MPC86xx_DMA3_SIZE	(0x00080)
+#define MPC86xx_ENET1_OFFSET	(0x24000)
+#define MPC86xx_ENET1_SIZE	(0x01000)
+#define MPC86xx_MIIM_OFFSET	(0x24520)
+#define MPC86xx_MIIM_SIZE	(0x00018)
+#define MPC86xx_ENET2_OFFSET	(0x25000)
+#define MPC86xx_ENET2_SIZE	(0x01000)
+#define MPC86xx_ENET3_OFFSET	(0x26000)
+#define MPC86xx_ENET3_SIZE	(0x01000)
+#define MPC86xx_ENET4_OFFSET	(0x27000)
+#define MPC86xx_ENET4_SIZE	(0x01000)
+#define MPC86xx_GUTS_OFFSET	(0xe0000)
+#define MPC86xx_GUTS_SIZE	(0x01000)
+#define MPC86XX_RSTCR_OFFSET	(0xe00b0)
+#define MPC86xx_IIC1_OFFSET	(0x03000)
+#define MPC86xx_IIC1_SIZE	(0x00100)
+#define MPC86xx_IIC2_OFFSET	(0x03100)
+#define MPC86xx_IIC2_SIZE	(0x00100)
+#define MPC86xx_OPENPIC_OFFSET	(0x40000)
+#define MPC86xx_OPENPIC_SIZE	(0x40000)
+#define MPC86xx_PCIE1_OFFSET	(0x08000)
+#define MPC86xx_PCIE1_SIZE	(0x01000)
+#define MPC86xx_PCIE2_OFFSET	(0x09000)
+#define MPC86xx_PCIE2_SIZE	(0x01000)
+#define MPC86xx_PERFMON_OFFSET	(0xe1000)
+#define MPC86xx_PERFMON_SIZE	(0x01000)
+#define MPC86xx_UART0_OFFSET	(0x04500)
+#define MPC86xx_UART0_SIZE	(0x00100)
+#define MPC86xx_UART1_OFFSET	(0x04600)
+#define MPC86xx_UART1_SIZE	(0x00100)
+#define MPC86xx_MCM_OFFSET	(0x00000)
+#define MPC86xx_MCM_SIZE	(0x02000)
+
+#define MPC86xx_CCSRBAR_SIZE	(1024*1024)
+
+/* Let modules/drivers get at CCSRBAR */
+extern phys_addr_t get_ccsrbar(void);
+
+#ifdef MODULE
+#define CCSRBAR get_ccsrbar()
+#else
+#define CCSRBAR BOARD_CCSRBAR
+#endif
+
+enum ppc_sys_devices {
+	MPC86xx_TSEC1,
+	MPC86xx_TSEC2,
+	MPC86xx_TSEC3,
+	MPC86xx_TSEC4,
+	MPC86xx_DUART,
+	MPC86xx_MDIO,
+	MPC86xx_IIC1,
+	MPC86xx_IIC2,
+	NUM_PPC_SYS_DEVS,
+};
+
+#endif /* CONFIG_86xx */
+#endif /* __ASM_MPC86xx_H__ */
+#endif /* __KERNEL__ */
Index: linux-2.6.10/include/asm-ppc/ppcboot.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ppcboot.h
+++ linux-2.6.10/include/asm-ppc/ppcboot.h
@@ -38,8 +38,8 @@ typedef struct bd_info {
 	unsigned long	bi_flashoffset; /* reserved area for startup monitor */
 	unsigned long	bi_sramstart;	/* start of SRAM memory */
 	unsigned long	bi_sramsize;	/* size	 of SRAM memory */
-#if defined(CONFIG_8xx) || defined(CONFIG_CPM2) || defined(CONFIG_85xx) ||\
-	defined(CONFIG_83xx)
+#if defined(CONFIG_8xx) || defined(CONFIG_CPM2) || defined(CONFIG_85xx) || \
+	defined(CONFIG_83xx) || defined(CONFIG_86xx)
 	unsigned long	bi_immr_base;	/* base of IMMR register */
 #endif
 #if defined(CONFIG_PPC_MPC52xx)
@@ -73,16 +73,17 @@ typedef struct bd_info {
 #if defined(CONFIG_HYMOD)
 	hymod_conf_t	bi_hymod_conf;	/* hymod configuration information */
 #endif
-#if defined(CONFIG_EVB64260) || defined(CONFIG_44x) || defined(CONFIG_85xx) ||\
-	defined(CONFIG_83xx)
+#if defined(CONFIG_EVB64260) || defined(CONFIG_44x) || defined(CONFIG_85xx) || \
+	defined(CONFIG_83xx) || defined(CONFIG_86xx)
 	/* second onboard ethernet port */
 	unsigned char	bi_enet1addr[6];
 #endif
-#if defined(CONFIG_EVB64260) || defined(CONFIG_440GX) || defined(CONFIG_85xx)
+#if defined(CONFIG_EVB64260) || defined(CONFIG_440GX) || \
+	defined(CONFIG_85xx) || defined(CONFIG_86xx)
 	/* third onboard ethernet ports */
 	unsigned char	bi_enet2addr[6];
 #endif
-#if defined(CONFIG_440GX)
+#if defined(CONFIG_440GX) || defined(CONFIG_86xx)
 	/* fourth onboard ethernet ports */
 	unsigned char	bi_enet3addr[6];
 #endif
@@ -96,5 +97,7 @@ typedef struct bd_info {
 #endif
 } bd_t;
 
+#define bi_tbfreq	bi_intfreq
+
 #endif /* __ASSEMBLY__ */
 #endif	/* __ASM_PPCBOOT_H__ */
Index: linux-2.6.10/include/asm-ppc/ppc_sys.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ppc_sys.h
+++ linux-2.6.10/include/asm-ppc/ppc_sys.h
@@ -29,6 +29,8 @@
 #include <asm/mpc83xx.h>
 #elif defined(CONFIG_85xx)
 #include <asm/mpc85xx.h>
+#elif defined(CONFIG_86xx)
+#include <asm/mpc86xx.h>
 #else
 #error "need definition of ppc_sys_devices"
 #endif
Index: linux-2.6.10/include/asm-ppc/serial.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/serial.h
+++ linux-2.6.10/include/asm-ppc/serial.h
@@ -39,6 +39,8 @@
 #include <asm/mpc83xx.h>
 #elif defined(CONFIG_85xx)
 #include <asm/mpc85xx.h>
+#elif defined(CONFIG_86xx)
+#include <asm/mpc86xx.h>
 #else
 
 /*
Index: linux-2.6.10/drivers/net/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/net/Kconfig
+++ linux-2.6.10/drivers/net/Kconfig
@@ -2140,11 +2140,11 @@ config TIGON3
 
 config GIANFAR
 	tristate "Gianfar Ethernet"
-	depends on 85xx || 83xx
+	depends on 85xx || 83xx || 86xx
 	select CRC32
 	select PHYLIB
 	help
-	  This driver supports the Gigabit TSEC on the MPC85xx 
+	  This driver supports the Gigabit TSEC on the MPC85xx/MPC86xx
 	  family of chips, and the FEC on the 8540
 
 config GFAR_NAPI
Index: linux-2.6.10/arch/ppc/kernel/setup.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/kernel/setup.c
+++ linux-2.6.10/arch/ppc/kernel/setup.c
@@ -40,7 +40,7 @@
 #include <asm/xmon.h>
 #include <asm/ocp.h>
 
-#if defined(CONFIG_85xx) || defined(CONFIG_83xx)
+#if defined(CONFIG_85xx) || defined(CONFIG_83xx) || defined(CONFIG_86xx)
 #include <asm/ppc_sys.h>
 #endif
 
@@ -246,7 +246,7 @@ int show_cpuinfo(struct seq_file *m, voi
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
 		   lpj / (500000/HZ), (lpj / (5000/HZ)) % 100);
 
-#if defined(CONFIG_85xx) || defined(CONFIG_83xx)
+#if defined(CONFIG_85xx) || defined(CONFIG_83xx) || defined(CONFIG_86xx)
 	if (cur_ppc_sys_spec->ppc_sys_name)
 		seq_printf(m, "chipset\t\t: %s\n",
 			cur_ppc_sys_spec->ppc_sys_name);
Index: linux-2.6.10/mvl_patches/pro-0951.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0951.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(951);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

