#! /usr/bin/env bash
# Patch: -common_ppc_440ep_usb_gadget
# Date: Wed Dec 28 14:59:25 2005
# Source: MontaVista Software, Inc.
# MR: 14294
# Type: Enhancement
# Disposition: submitted to linux-usb-devel mailing list
# Signed-off-by: Wade Farnsworth <wfarnsworth@mvista.com>
# Description:
#     Adds support for the USB 2.0 and 1.1 Device Controllers on the 
#     AMCC PPC 440EP.
# 

PATCHNUM=147
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 14294
Type: Enhancement
Disposition: submitted to linux-usb-devel mailing list
Signed-off-by: Wade Farnsworth <wfarnsworth@mvista.com>
Description:
    Adds support for the USB 2.0 and 1.1 Device Controllers on the 
    AMCC PPC 440EP.

Index: linux-2.6.10/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/Kconfig
+++ linux-2.6.10/drivers/usb/gadget/Kconfig
@@ -238,6 +238,19 @@ config USB_OTG
 
 	   Select this only if your OMAP board has a Mini-AB connector.
 
+config USB_GADGET_MUSBHSFC
+	boolean "Inventra MUSBHSFC"
+	depends on 440EP
+	select USB_GADGET_DUALSPEED
+	help
+	   This driver provides USB Device Controller support for the
+	   Inventra MUSBHSFC used on the IBM/AMCC 440EP.
+
+config USB_MUSBHSFC
+	tristate
+	depends on USB_GADGET_MUSBHSFC
+	default USB_GADGET
+
 endchoice
 
 config USB_GADGET_DUALSPEED
Index: linux-2.6.10/drivers/usb/gadget/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/Makefile
+++ linux-2.6.10/drivers/usb/gadget/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_USB_GOKU)		+= goku_udc.o
 obj-$(CONFIG_USB_OMAP)		+= omap_udc.o
 obj-$(CONFIG_USB_LH7A40X)	+= lh7a40x_udc.o
 obj-$(CONFIG_USB_PXA27X)	+= pxa27x_udc.o
+obj-$(CONFIG_USB_MUSBHSFC)	+= musbhsfc_udc.o
 
 #
 # USB gadget drivers
Index: linux-2.6.10/drivers/usb/gadget/ether.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/ether.c
+++ linux-2.6.10/drivers/usb/gadget/ether.c
@@ -243,6 +243,10 @@ MODULE_PARM_DESC(host_addr, "Host Ethern
 #define DEV_CONFIG_CDC
 #endif
 
+#ifdef CONFIG_USB_GADGET_MUSBHSFC
+#define DEV_CONFIG_CDC
+#endif
+
 
 /* For CDC-incapable hardware, choose the simple cdc subset.
  * Anything that talks bulk (without notable bugs) can do this.
@@ -2327,6 +2331,8 @@ eth_bind (struct usb_gadget *gadget)
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0210);
 	} else if (gadget_is_pxa27x(gadget)) {
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0211);
+	} else if (gadget_is_musbhsfc(gadget)) {
+		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0215);
 	} else {
 		/* can't assume CDC works.  don't want to default to
 		 * anything less functional on CDC-capable hardware,
Index: linux-2.6.10/drivers/usb/gadget/file_storage.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/file_storage.c
+++ linux-2.6.10/drivers/usb/gadget/file_storage.c
@@ -3741,6 +3741,8 @@ static int __init check_parameters(struc
 			mod_data.release = 0x0310;
 		else if (gadget_is_pxa27x(fsg->gadget))
 			mod_data.release = 0x0311;
+		else if (gadget_is_musbhsfc(fsg->gadget))
+			mod_data.release = 0x0315;
 		else {
 			WARN(fsg, "controller '%s' not recognized\n",
 				fsg->gadget->name);
Index: linux-2.6.10/drivers/usb/gadget/gadget_chips.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/gadget_chips.h
+++ linux-2.6.10/drivers/usb/gadget/gadget_chips.h
@@ -74,6 +74,12 @@
 #define	gadget_is_pxa27x(g)	0
 #endif
 
+#ifdef CONFIG_USB_GADGET_MUSBHSFC
+#define gadget_is_musbhsfc(g)	!strcmp("musbhsfc_udc", (g)->name)
+#else
+#define gadget_is_musbhsfc(g)	0
+#endif
+
 // CONFIG_USB_GADGET_AT91RM9200
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
Index: linux-2.6.10/drivers/usb/gadget/serial.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/serial.c
+++ linux-2.6.10/drivers/usb/gadget/serial.c
@@ -1535,6 +1535,9 @@ static int gs_bind(struct usb_gadget *ga
 	} else if (gadget_is_pxa27x(gadget)) {
 		gs_device_desc.bcdDevice =
 			__constant_cpu_to_le16(GS_VERSION_NUM|0x0011);
+	} else if (gadget_is_musbhsfc(gadget)) {
+		gs_device_desc.bcdDevice =
+			__constant_cpu_to_le16(GS_VERSION_NUM|0x0015);
 	} else {
 		printk(KERN_WARNING "gs_bind: controller '%s' not recognized\n",
 			gadget->name);
Index: linux-2.6.10/drivers/usb/gadget/zero.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/gadget/zero.c
+++ linux-2.6.10/drivers/usb/gadget/zero.c
@@ -1192,6 +1192,8 @@ autoconf_fail:
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0210);
 	} else if (gadget_is_pxa27x(gadget)) {
 		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0211);
+	} else if (gadget_is_musbhsfc(gadget)) {
+		device_desc.bcdDevice = __constant_cpu_to_le16 (0x0215);
 	} else {
 		/* gadget zero is so simple (for now, no altsettings) that
 		 * it SHOULD NOT have problems with bulk-capable hardware.
Index: linux-2.6.10/drivers/usb/gadget/musbhsfc_udc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/usb/gadget/musbhsfc_udc.c
@@ -0,0 +1,2212 @@
+/*
+ * linux/drivers/usb/gadget/musbhsfc_udc.c
+ * Inventra MUSBHSFC USB device controller used on the AMCC PPC440EP
+ *
+ * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
+ * Copyright (C) 2004 Bo Henriksen, Nordic ID
+ * Copyright (C) 2004 IBM Corp.
+ * Copyright (C) 2005 Montavista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "musbhsfc_udc.h"
+
+//DEBUG printk
+//DEBUG_EP0 printk
+//DEBUG_SETUP printk
+
+#ifndef DEBUG_EP0
+# define DEBUG_EP0(fmt,args...)
+#endif
+#ifndef DEBUG_SETUP
+# define DEBUG_SETUP(fmt,args...)
+#endif
+#ifndef DEBUG
+# define NO_STATES
+# define DEBUG(fmt,args...)
+#endif
+
+#define	DRIVER_DESC		"MUSBHSFC USB Device Controller"
+#define	DRIVER_VERSION		__DATE__
+
+#ifndef _BIT			/* FIXME - what happended to _BIT in 2.6.7bk18? */
+#define _BIT(x) (1<<(x))
+#endif
+
+struct musbhsfc_udc *the_controller;
+
+static const char driver_name[] = "musbhsfc_udc";
+static const char driver_desc[] = DRIVER_DESC;
+static const char ep0name[] = "ep0-control";
+
+#ifndef NO_STATES
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV"
+};
+#endif
+
+/*
+  Local declarations.
+*/
+static int musbhsfc_ep_enable(struct usb_ep *ep,
+			      const struct usb_endpoint_descriptor *);
+static int musbhsfc_ep_disable(struct usb_ep *ep);
+static struct usb_request *musbhsfc_alloc_request(struct usb_ep *ep, int);
+static void musbhsfc_free_request(struct usb_ep *ep, struct usb_request *);
+static void *musbhsfc_alloc_buffer(struct usb_ep *ep, unsigned, dma_addr_t *,
+				   int);
+static void musbhsfc_free_buffer(struct usb_ep *ep, void *, dma_addr_t,
+				 unsigned);
+static int musbhsfc_queue(struct usb_ep *ep, struct usb_request *, int);
+static int musbhsfc_dequeue(struct usb_ep *ep, struct usb_request *);
+static int musbhsfc_set_halt(struct usb_ep *ep, int);
+static int musbhsfc_fifo_status(struct usb_ep *ep);
+static int musbhsfc_fifo_status(struct usb_ep *ep);
+static void musbhsfc_fifo_flush(struct usb_ep *ep);
+static void musbhsfc_ep0_kick(struct musbhsfc_udc *dev, struct musbhsfc_ep *ep);
+static void musbhsfc_handle_ep0(struct musbhsfc_udc *dev, u32 intr);
+
+static void done(struct musbhsfc_ep *ep, struct musbhsfc_request *req,
+		 int status);
+static void pio_irq_enable(int bEndpointAddress);
+static void pio_irq_disable(int bEndpointAddress);
+static void stop_activity(struct musbhsfc_udc *dev,
+			  struct usb_gadget_driver *driver);
+static void flush(struct musbhsfc_ep *ep);
+static void udc_enable(struct musbhsfc_udc *dev);
+static void udc_set_address(struct musbhsfc_udc *dev, unsigned char address);
+
+static struct usb_ep_ops musbhsfc_ep_ops = {
+	.enable = musbhsfc_ep_enable,
+	.disable = musbhsfc_ep_disable,
+
+	.alloc_request = musbhsfc_alloc_request,
+	.free_request = musbhsfc_free_request,
+
+	.alloc_buffer = musbhsfc_alloc_buffer,
+	.free_buffer = musbhsfc_free_buffer,
+
+	.queue = musbhsfc_queue,
+	.dequeue = musbhsfc_dequeue,
+
+	.set_halt = musbhsfc_set_halt,
+	.fifo_status = musbhsfc_fifo_status,
+	.fifo_flush = musbhsfc_fifo_flush,
+};
+
+unsigned long phys_addr;
+unsigned long base_addr;
+unsigned long base_len;
+unsigned int device_irq;
+
+/* Inline code */
+
+static __inline__ u8 usb_readb(unsigned long offset)
+{
+	return in_8((volatile u8 *) (base_addr + offset));
+}
+
+static __inline__ u16 usb_readw(unsigned long offset)
+{
+	return in_be16((volatile u16 *) (base_addr + offset));
+}
+
+static __inline__ void usb_writeb(u8 b, unsigned long offset)
+{
+	out_8((volatile u8 *)(base_addr + offset), b);
+}
+
+static __inline__ void usb_writew(u16 b, unsigned long offset)
+{
+	out_be16((volatile u16 *)(base_addr + offset), b);
+}
+
+static __inline__ void usb_set_index(u8 ep)
+{
+	usb_writeb(ep, USB_INDEX);
+}
+
+static __inline__ void usb_setb(u8 b, unsigned long offset)
+{
+	u8 after = usb_readb(offset) | b;
+	usb_writeb(after, offset);
+}
+
+static __inline__ void usb_setw(u16 b, unsigned long offset)
+{
+	u16 after = usb_readw(offset) | b;
+	usb_writew(after, offset);
+}
+
+static __inline__ void usb_clearb(u8 b, unsigned long offset)
+{
+	u8 after = usb_readb(offset) & ~b;
+	usb_writeb(after, offset);
+}
+
+static __inline__ void usb_clearw(u16 b, unsigned long offset)
+{
+	u16 after = usb_readw(offset) & ~b;
+	usb_writew(after, offset);
+}
+
+static __inline__ int write_packet(struct musbhsfc_ep *ep,
+				   struct musbhsfc_request *req, int max)
+{
+	u8 *buf;
+	int length, count;
+
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, max);
+	req->req.actual += length;
+
+	DEBUG("Write %d (max %d)\n", length, max);
+
+	count = length;
+	while (count--) {
+		usb_writeb(*buf, ep->fifo);
+		buf++;
+	}
+
+	return length;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static const char proc_node_name[] = "driver/udc";
+
+static int
+udc_proc_read(char *page, char **start, off_t off, int count,
+	      int *eof, void *_dev)
+{
+	char *buf = page;
+	struct musbhsfc_udc *dev = _dev;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+
+	if (off != 0)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* basic device status */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n"
+		      "%s version: %s\n"
+		      "Gadget driver: %s\n"
+		      "Host: %s\n\n",
+		      driver_name, DRIVER_VERSION,
+		      dev->driver ? dev->driver->driver.name : "(none)",
+		      "full speed");
+	size -= t;
+	next += t;
+
+	local_irq_restore(flags);
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_files() 	create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
+#define remove_proc_files() 	remove_proc_entry(proc_node_name, NULL)
+
+#else	/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+unsigned char musbhsfc_check_dir(struct musbhsfc_ep *ep, 
+				 unsigned char usb_direction)
+{
+	if ((usb_direction == USB_DIR_IN) &&
+	    ((ep->desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) 
+	     == USB_DIR_IN))
+		return 1;
+	else if ((usb_direction == USB_DIR_OUT) &&
+	    ((ep->desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) 
+	     == USB_DIR_OUT))
+		return 1;
+	return 0;
+}
+
+void musbhsfc_show_regs(void)
+{
+	printk(KERN_INFO "MUSBHSFC USB device Driver - Dump Registers\n");
+	printk(KERN_INFO "USB_INTRIN    : 0x%x\n", usb_readw(USB_INTRIN));
+	printk(KERN_INFO "USB_POWER     : 0x%x\n", usb_readb(USB_POWER));
+	printk(KERN_INFO "USB_FADDR     : 0x%x\n", usb_readb(USB_FADDR));
+	printk(KERN_INFO "USB_INTRINE   : 0x%x\n", usb_readw(USB_INTRINE));
+	printk(KERN_INFO "USB_INTROUT   : 0x%x\n", usb_readw(USB_INTROUT));
+	printk(KERN_INFO "USB_INTRUSBE  : 0x%x\n", usb_readb(USB_INTRUSBE));
+	printk(KERN_INFO "USB_INTRUSB   : 0x%x\n", usb_readb(USB_INTRUSB ));
+	printk(KERN_INFO "USB_INTROUTE  : 0x%x\n", usb_readw(USB_INTROUTE));
+	printk(KERN_INFO "USB_TESTMODE  : 0x%x\n", usb_readb(USB_TESTMODE));
+	printk(KERN_INFO "USB_INDEX     : 0x%x\n", usb_readb(USB_INDEX));
+	printk(KERN_INFO "USB_FRAME     : 0x%x\n", usb_readw(USB_FRAME));
+}
+
+void musbhsfc_set_device(struct musbhsfc_udc *dev)
+{
+	if (SDR_READ(DCRN_SDR_USB0) & 0x2)
+		dev->usb2_device = 0;
+	else
+		dev->usb2_device = 1;
+}
+
+void musbhsfc_set_speed(struct musbhsfc_udc *dev)
+{
+	unsigned char high_speed = usb_readb(USB_POWER) & USB_POWER_HS_MODE;
+
+	if (dev->usb2_device) {
+		if (high_speed) {
+			printk(KERN_INFO "USB Device 2.0 : High Speed Mode\n");
+			dev->gadget.speed = USB_SPEED_HIGH;
+		} else {
+			printk(KERN_INFO "USB Device 2.0 : Full Speed Mode\n");
+			dev->gadget.speed = USB_SPEED_FULL;
+		}
+	} else {
+		printk(KERN_INFO "USB Device 1.1 : Full Speed Mode \n");
+		dev->gadget.speed = USB_SPEED_FULL;
+	}
+
+}
+
+/*
+ * 	udc_disable - disable USB device controller
+ */
+static void udc_disable(struct musbhsfc_udc *dev)
+{
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	udc_set_address(dev, 0);
+
+	/* Disable interrupts */
+	usb_writew(0, USB_INTRINE);
+	usb_writew(0, USB_INTROUTE);
+	usb_writeb(0, USB_INTRUSBE);
+
+	/* Disable the USB */
+	usb_writeb(0, USB_POWER);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+
+	dev->usb2_device = 0;
+	dev->speed_set = 0;
+}
+
+/*
+ * 	udc_reinit - initialize software state
+ */
+static void udc_reinit(struct musbhsfc_udc *dev)
+{
+	u32 i;
+
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
+		struct musbhsfc_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+	}
+
+	/* the rest was statically initialized, and is read-only */
+}
+
+#define BYTES2MAXP(x)	(x / 8)
+#define MAXP2BYTES(x)	(x * 8)
+
+/*
+ * until it's enabled, this UDC should be completely invisible
+ * to any USB host.
+ */
+static void udc_enable(struct musbhsfc_udc *dev)
+{
+	int ep;
+
+	DEBUG("%s, %p\n", __FUNCTION__, dev);
+
+	dev->usb2_device = 0;
+	dev->speed_set = 0;
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	usb_clearb(USB_POWER_FS_PHY_ENAB | USB_POWER_HS_ENAB, USB_POWER);
+
+	/* Set MAXP values for each */
+	for (ep = 0; ep < UDC_MAX_ENDPOINTS; ep++) {
+		struct musbhsfc_ep *ep_reg = &dev->ep[ep];
+		u8 csr;
+
+		usb_set_index(ep);
+
+		switch (ep_reg->ep_type) {
+		case ep_bulk_in:
+		case ep_interrupt:
+			usb_clearb(USB_INCSRH_DMAENA | USB_INCSRH_AUTOSET,
+				  ep_reg->csr2);
+			/* Fall through */
+		case ep_control:
+			usb_writeb(BYTES2MAXP(ep_maxpacket(ep_reg)),
+				  USB_INMAXP);
+			break;
+		case ep_bulk_out:
+			usb_clearb(USB_OUTCSRH_DMAENA |
+				  USB_OUTCSRH_AUTOCLR, ep_reg->csr2);
+			usb_writeb(BYTES2MAXP(ep_maxpacket(ep_reg)),
+				  USB_OUTMAXP);
+			break;
+		}
+
+		/* Read & Write CSR1, just in case */
+		csr = usb_readb(ep_reg->csr1);
+		usb_writeb(csr, ep_reg->csr1);
+
+		flush(ep_reg);
+	}
+
+	/* Clear spurious interrupts by reading these registers */
+	usb_readw(USB_INTRIN);
+	usb_readw(USB_INTROUT);
+	usb_readb(USB_INTRUSB);
+	
+	/* Enable interrupts */
+	usb_setw(USB_INTRIN_EP0, USB_INTRINE);
+	usb_setb(USB_INTRUSBE_RESET | USB_INTRUSBE_RESUME | 
+		 USB_INTRUSBE_SUSPEND, USB_INTRUSBE);
+
+	/* Enable SUSPEND */
+	usb_setb(USB_POWER_ENABLE_SUSPEND, USB_POWER);
+
+	musbhsfc_set_device(dev);
+	if (!dev->usb2_device) {
+		usb_setb(USB_POWER_FS_PHY_ENAB, USB_POWER);
+		musbhsfc_set_speed(dev);
+		dev->speed_set = 1;
+	} else
+		usb_setb(USB_POWER_HS_ENAB, USB_POWER);
+}
+
+/*
+  Register entry point for the peripheral controller driver.
+*/
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct musbhsfc_udc *dev = the_controller;
+	int retval;
+
+	DEBUG("%s: %s\n", __FUNCTION__, driver->driver.name);
+
+	if (!driver
+	    || (driver->speed < USB_SPEED_FULL) 
+	    || (driver->speed > USB_SPEED_HIGH)
+	    || !driver->bind
+	    || !driver->unbind || !driver->disconnect || !driver->setup)
+		return -EINVAL;
+	if (!dev)
+		return -ENODEV;
+	if (dev->driver)
+		return -EBUSY;
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+
+	device_add(&dev->gadget.dev);
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		printk("%s: bind to driver %s --> error %d\n", dev->gadget.name,
+		       driver->driver.name, retval);
+		device_del(&dev->gadget.dev);
+
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
+		return retval;
+	}
+
+	/* ... then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 * NOTE:  this shouldn't power up until later.
+	 */
+	printk("%s: registered gadget driver '%s'\n", dev->gadget.name,
+	       driver->driver.name);
+
+	udc_enable(dev);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/*
+  Unregister entry point for the peripheral controller driver.
+*/
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct musbhsfc_udc *dev = the_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->driver = 0;
+	stop_activity(dev, driver);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	driver->unbind(&dev->gadget);
+	device_del(&dev->gadget.dev);
+
+	udc_disable(dev);
+
+	DEBUG("unregistered gadget driver '%s'\n", driver->driver.name);
+	return 0;
+}
+
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+/** Write request to FIFO (max write == maxp size)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ *  NOTE: INDEX register must be set for EP
+ */
+static int write_fifo(struct musbhsfc_ep *ep, struct musbhsfc_request *req)
+{
+	u32 max;
+	u8 csr;
+
+	max = __constant_le16_to_cpu(ep->desc->wMaxPacketSize);
+
+	csr = usb_readb(ep->csr1);
+	DEBUG("CSR: %x %d\n", csr, csr & USB_INCSR_FIFONEMPTY);
+
+	if (!(csr & USB_INCSR_FIFONEMPTY)) {
+		unsigned count;
+		int is_last, is_short;
+
+		count = write_packet(ep, req, max);
+		usb_setb(USB_INCSR_INPKTRDY, ep->csr1);
+
+		/* last packet is usually short (or a zlp) */
+		if (unlikely(count != max))
+			is_last = is_short = 1;
+		else {
+			if (likely(req->req.length != req->req.actual)
+			    || req->req.zero)
+				is_last = 0;
+			else
+				is_last = 1;
+			/* interrupt/iso maxpacket may not fill the fifo */
+			is_short = unlikely(max < ep_maxpacket(ep));
+		}
+
+		DEBUG("%s: wrote %s %d bytes%s%s %d left %p\n", __FUNCTION__,
+		      ep->ep.name, count,
+		      is_last ? "/L" : "", is_short ? "/S" : "",
+		      req->req.length - req->req.actual, req);
+
+		/* requests complete when all IN data is in the FIFO */
+		if (is_last) {
+			done(ep, req, 0);
+			if (list_empty(&ep->queue)) {
+				pio_irq_disable(ep_index(ep));
+			}
+			return 1;
+		}
+	} else
+		DEBUG("Hmm.. %d ep FIFO is not empty!\n", ep_index(ep));
+
+	return 0;
+}
+
+/** Read to request from FIFO (max read == bytes in fifo)
+ *  Return:  0 = still running, 1 = completed, negative = errno
+ *  NOTE: INDEX register must be set for EP
+ */
+static int read_fifo(struct musbhsfc_ep *ep, struct musbhsfc_request *req)
+{
+	u8 csr;
+	u8 *buf;
+	unsigned bufferspace, count, is_short;
+
+	/* make sure there's a packet in the FIFO. */
+	csr = usb_readb(ep->csr1);
+	if (!(csr & USB_OUTCSR_OUTPKTRDY)) {
+		DEBUG("%s: Packet NOT ready!\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	count = usb_readw(USB_OUTCOUNT);
+	req->req.actual += min(count, bufferspace);
+
+	is_short = (count < ep->ep.maxpacket);
+	DEBUG("read %s %02x, %d bytes%s req %p %d/%d\n",
+	      ep->ep.name, csr, count,
+	      is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	while (likely(count-- != 0)) {
+		u8 byte = (u8) (usb_readb(ep->fifo) & 0xff);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				printk("%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace--;
+		}
+	}
+
+	usb_clearb(USB_OUTCSR_OUTPKTRDY, ep->csr1);
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		done(ep, req, 0);
+		usb_setb(USB_OUTCSR_FLUSHFIFO, ep->csr1);
+
+		if (list_empty(&ep->queue))
+			pio_irq_disable(ep_index(ep));
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/*
+ *	done - retire a request; caller blocked irqs
+ *  INDEX register is preserved to keep same
+ */
+static void done(struct musbhsfc_ep *ep, struct musbhsfc_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+	u32 index;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		DEBUG("complete %s req %p stat %d len %u/%u\n",
+		      ep->ep.name, &req->req, status,
+		      req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	/* Read current index (completion may modify it) */
+	index = usb_readb(USB_INDEX);
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+
+	/* Restore index */
+	usb_set_index(index);
+	ep->stopped = stopped;
+}
+
+/** Enable EP interrupt */
+static void pio_irq_enable(int ep)
+{
+	DEBUG("%s: %d\n", __FUNCTION__, ep);
+
+	switch (ep) {
+	case 1:
+		usb_setw(USB_INTRIN_EP1, USB_INTRINE);
+		break;
+	case 2:
+		usb_setw(USB_INTROUT_EP2, USB_INTROUTE);
+		break;
+	case 3:
+		usb_setw(USB_INTRIN_EP3, USB_INTRINE);
+		break;
+	default:
+		DEBUG("Unknown endpoint: %d\n", ep);
+		break;
+	}
+}
+
+/** Disable EP interrupt */
+static void pio_irq_disable(int ep)
+{
+	DEBUG("%s: %d\n", __FUNCTION__, ep);
+
+	switch (ep) {
+	case 1:
+		usb_clearw(USB_INTRIN_EP1, USB_INTRINE);
+		break;
+	case 2:
+		usb_clearw(USB_INTROUT_EP2, USB_INTROUTE);
+		break;
+	case 3:
+		usb_clearw(USB_INTRIN_EP3, USB_INTRINE);
+		break;
+	default:
+		DEBUG("Unknown endpoint: %d\n", ep);
+		break;
+	}
+}
+
+/*
+ * 	nuke - dequeue ALL requests
+ */
+void nuke(struct musbhsfc_ep *ep, int status)
+{
+	struct musbhsfc_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	/* Flush FIFO */
+	flush(ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct musbhsfc_request, queue);
+		done(ep, req, status);
+	}
+
+	/* Disable IRQ if EP is enabled (has descriptor) */
+	if (ep->desc)
+		pio_irq_disable(ep_index(ep));
+}
+
+/** Flush EP
+ * NOTE: INDEX register must be set before this call
+ */
+static void flush(struct musbhsfc_ep *ep)
+{
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	switch (ep->ep_type) {
+	case ep_control:
+		break;
+
+	case ep_bulk_in:
+	case ep_interrupt:
+		usb_setb(USB_INCSR_FLUSHFIFO, ep->csr1);
+		break;
+
+	case ep_bulk_out:
+		usb_setb(USB_OUTCSR_FLUSHFIFO, ep->csr1);
+		break;
+	}
+}
+
+/**
+ * musbhsfc_in_epn - handle IN interrupt
+ */
+static void musbhsfc_in_epn(struct musbhsfc_udc *dev, u32 ep_idx, u32 intr)
+{
+	u8 csr;
+	struct musbhsfc_ep *ep = &dev->ep[ep_idx];
+	struct musbhsfc_request *req;
+
+	usb_set_index(ep_idx);
+
+	csr = usb_readb(ep->csr1);
+	DEBUG("%s: %d, csr %x\n", __FUNCTION__, ep_idx, csr);
+
+	if (csr & USB_INCSR_SENTSTALL) {
+		DEBUG("USB_INCSR_SENTSTALL\n");
+		usb_clearb(USB_INCSR_SENTSTALL,
+			ep->csr1);
+		return;
+	}
+
+	if (!ep->desc) {
+		DEBUG("%s: NO EP DESC\n", __FUNCTION__);
+		return;
+	}
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct musbhsfc_request, queue);
+
+	DEBUG("req: %p\n", req);
+
+	if (!req)
+		return;
+
+	write_fifo(ep, req);
+}
+
+/* ********************************************************************************************* */
+/* Bulk OUT (recv)
+ */
+
+static void musbhsfc_out_epn(struct musbhsfc_udc *dev, u32 ep_idx, u32 intr)
+{
+	struct musbhsfc_ep *ep = &dev->ep[ep_idx];
+	struct musbhsfc_request *req;
+
+	DEBUG("%s: ep_idx: %d\n", __FUNCTION__, ep_idx);
+
+	usb_set_index(ep_idx);
+
+	if (ep->desc) {
+		u8 csr;
+		csr = usb_readb(ep->csr1);
+
+		while ((csr = usb_readb(ep-> csr1)) 
+				      & (USB_OUTCSR_OUTPKTRDY 
+				       | USB_OUTCSR_SENTSTALL)) {
+			DEBUG("%s: csr: %x\n", __FUNCTION__, csr);
+
+			if (csr & USB_OUTCSR_SENTSTALL) {
+				DEBUG("%s: stall sent, flush fifo\n",
+				      __FUNCTION__);
+				flush(ep);
+				usb_clearb(USB_OUTCSR_SENTSTALL, ep->csr1);
+			} else if (csr & USB_OUTCSR_OUTPKTRDY) {
+				if (list_empty(&ep->queue))
+					req = 0;
+				else
+					req =
+					    list_entry(ep->queue.next,
+						       struct musbhsfc_request,
+						       queue);
+
+				if (!req) {
+					printk("%s: NULL REQ %d\n",
+					       __FUNCTION__, ep_idx);
+					flush(ep);
+					break;
+				} else {
+					read_fifo(ep, req);
+				}
+			}
+
+		}
+
+	} else {
+		/* Throw packet away.. */
+		printk("%s: No descriptor?!?\n", __FUNCTION__);
+		flush(ep);
+	}
+}
+
+static void stop_activity(struct musbhsfc_udc *dev,
+			  struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++) {
+		struct musbhsfc_ep *ep = &dev->ep[i];
+		ep->stopped = 1;
+
+		usb_set_index(i);
+		nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	udc_reinit(dev);
+}
+
+/*
+ * Handle USB RESET interrupt
+ */
+static void musbhsfc_reset_intr(struct musbhsfc_udc *dev)
+{
+	musbhsfc_set_speed(dev);
+	dev->ep0state = WAIT_FOR_SETUP;
+	udc_set_address(dev, 0);	
+}
+
+/*
+ *	musbhsfc usb client interrupt handler.
+ */
+static irqreturn_t musbhsfc_udc_irq(int irq, void *_dev, struct pt_regs *r)
+{
+	struct musbhsfc_udc *dev = _dev;
+
+	DEBUG("\n\n");
+
+	spin_lock(&dev->lock);
+
+	for (;;) {
+
+		u32 intr_in = usb_readw(USB_INTRIN);
+		u32 intr_out = usb_readw(USB_INTROUT);
+		u32 intr_int = usb_readb(USB_INTRUSB);
+
+		u32 in_en = usb_readw(USB_INTRINE);
+		u32 out_en = usb_readw(USB_INTROUTE);
+
+
+		if (!intr_out && !intr_in && !intr_int)
+			break;
+
+		DEBUG("%s (on state %s)\n", __FUNCTION__,
+		      state_names[dev->ep0state]);
+		DEBUG("intr_out = %x\n", intr_out);
+		DEBUG("intr_in  = %x\n", intr_in);
+		DEBUG("intr_int = %x\n", intr_int);
+
+		if (intr_in) {
+
+			if (intr_in & USB_INTRIN_EP0) {
+				DEBUG("USB_INTRIN_EP0 (control)\n");
+				if (dev->usb2_device && 
+				    (dev->speed_set == 0)) {
+					musbhsfc_set_speed(dev);
+					dev->speed_set = 1;
+				}
+				musbhsfc_handle_ep0(dev, intr_in);
+			}
+			if ((intr_in & USB_INTRIN_EP1)
+			    && (in_en & USB_INTRIN_EP1)) {
+				DEBUG("USB_INTRIN_EP1\n");
+				musbhsfc_in_epn(dev, 1, intr_in);
+			}
+			if ((intr_in & USB_INTRIN_EP2)
+			    && (in_en & USB_INTRIN_EP2)) {
+				DEBUG("USB_INTRIN_EP2\n");
+				musbhsfc_in_epn(dev, 2, intr_int);
+			}
+			if ((intr_in & USB_INTRIN_EP3)
+			    && (in_en & USB_INTRIN_EP3)) {
+				DEBUG("USB_INTRIN_EP3\n");
+				musbhsfc_in_epn(dev, 3, intr_in);
+			}
+		}
+
+		if (intr_out) {
+			if (intr_out & USB_INTROUT_EP0) {
+				DEBUG("USB_INTROUT_EP0 (control) \n");
+				if (dev->usb2_device && 
+				    (dev->speed_set == 0)) {
+					musbhsfc_set_speed(dev);
+					dev->speed_set = 1;
+				}
+				musbhsfc_handle_ep0(dev, intr_out);
+			}
+			if ((intr_out & USB_INTROUT_EP1)
+			    && (out_en & USB_INTROUT_EP1)) {
+				DEBUG("USB_INTROUT_EP1\n");
+				musbhsfc_out_epn(dev, 1, intr_out);
+			}
+			if ((intr_out & USB_INTROUT_EP2)
+			    && (out_en & USB_INTROUT_EP2)) {
+				DEBUG("USB_INTROUT_EP2\n");
+				musbhsfc_out_epn(dev, 2, intr_out);
+			}
+			if ((intr_out & USB_INTROUT_EP3)
+			    && (out_en & USB_INTROUT_EP3)) {
+				DEBUG("USB_INTROUT_EP3\n");
+				musbhsfc_out_epn(dev, 3, intr_out);
+			}
+		}
+
+		if (intr_int) {
+
+			if (intr_int & USB_INTRUSB_RESET) {
+				musbhsfc_reset_intr(dev);
+				dev->speed_set = 0;
+			}
+
+			if (intr_int & USB_INTRUSB_RESUME) {
+				DEBUG("USB resume\n");
+
+				if (dev->gadget.speed != USB_SPEED_UNKNOWN
+				    && dev->driver
+				    && dev->driver->resume) {
+					dev->driver->resume(&dev->gadget);
+				}
+			}
+
+			if (intr_int & USB_INTRUSB_SUSPEND) {
+				DEBUG("USB suspend\n");
+				if (dev->gadget.speed !=
+				    USB_SPEED_UNKNOWN && dev->driver
+				    && dev->driver->suspend) {
+					dev->driver->suspend(&dev->gadget);
+				}
+			}
+
+		}
+	}
+
+	spin_unlock(&dev->lock);
+	DEBUG("%s: IRQ_HANDLED\n", __FUNCTION__);
+
+	return IRQ_HANDLED;
+}
+
+static int musbhsfc_ep_enable(struct usb_ep *_ep,
+			     const struct usb_endpoint_descriptor *desc)
+{
+	struct musbhsfc_ep *ep;
+	struct musbhsfc_udc *dev;
+	unsigned long flags;
+	u16 max_packet_size = __constant_le16_to_cpu(desc->wMaxPacketSize);
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress
+	    || ep_maxpacket(ep) < max_packet_size) {
+		DEBUG("%s, bad ep or descriptor\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+	     && max_packet_size != ep_maxpacket(ep)) 
+	     || !max_packet_size) {
+		DEBUG("%s, bad %s maxpacket\n", __FUNCTION__, _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DEBUG("%s, bogus device state\n", __FUNCTION__);
+		return -ESHUTDOWN;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->ep.maxpacket = max_packet_size;
+	usb_set_index(ep_index(ep));
+
+	if (musbhsfc_check_dir(ep, USB_DIR_OUT)) {
+		if (ep != 0) {
+			ep->csr1 = USB_OUTCSR;
+			ep->csr2 = USB_OUTCSRH;
+		}
+		switch (ep->desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+		case USB_ENDPOINT_XFER_BULK:
+			break;
+		case USB_ENDPOINT_XFER_INT:
+			usb_setb(USB_OUTCSRH_DISNYET, ep->csr2);
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			usb_setb(USB_OUTCSRH_ISO, ep->csr2);
+			break;
+		}
+		usb_writew(max_packet_size, USB_OUTMAXP);
+	}
+
+	if (musbhsfc_check_dir(ep, USB_DIR_IN)) {
+		if (ep != 0) {
+			ep->csr1 = USB_INCSR;
+			ep->csr2 = USB_INCSRH;
+		}
+		switch (ep->desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+		case USB_ENDPOINT_XFER_BULK:
+			usb_setb(USB_INCSRH_MODE, ep->csr2);
+			break;
+		case USB_ENDPOINT_XFER_INT:
+			usb_setb(USB_INCSRH_MODE, ep->csr2);
+			break;
+		case USB_ENDPOINT_XFER_ISOC:
+			usb_setb(USB_INCSRH_MODE | USB_INCSRH_ISO, ep->csr2);
+			break;
+		}
+		usb_writew(max_packet_size, USB_INMAXP);
+	}
+
+	/* Reset halt state (does flush) */
+	musbhsfc_set_halt(_ep, 0);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s: enabled %s\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+/** Disable EP
+ *  NOTE: Sets INDEX register
+ */
+static int musbhsfc_ep_disable(struct usb_ep *_ep)
+{
+	struct musbhsfc_ep *ep;
+	unsigned long flags;
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (!_ep || !ep->desc) {
+		DEBUG("%s, %s not enabled\n", __FUNCTION__,
+		      _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	usb_set_index(ep_index(ep));
+
+	/* Nuke all pending requests (does flush) */
+	nuke(ep, -ESHUTDOWN);
+
+	/* Disable ep IRQ */
+	pio_irq_disable(ep_index(ep));
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s: disabled %s\n", __FUNCTION__, _ep->name);
+	return 0;
+}
+
+static struct usb_request *musbhsfc_alloc_request(struct usb_ep *ep,
+						 int gfp_flags)
+{
+	struct musbhsfc_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	req = kmalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return 0;
+	memset(req, 0, sizeof *req);
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void musbhsfc_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct musbhsfc_request *req;
+
+	DEBUG("%s, %p\n", __FUNCTION__, ep);
+
+	req = container_of(_req, struct musbhsfc_request, req);
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+static void *musbhsfc_alloc_buffer(struct usb_ep *_ep, unsigned bytes,
+				  dma_addr_t * dma, int gfp_flags)
+{
+	struct musbhsfc_ep *ep;
+	char * retval;
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+
+	DEBUG("%s (%p, %d, %d)\n", __FUNCTION__, ep, bytes, gfp_flags);
+
+	retval = kmalloc(bytes, gfp_flags & ~(__GFP_DMA | __GFP_HIGHMEM));
+	if (retval)
+		*dma = virt_to_phys(retval);
+	return retval;
+}
+
+static void musbhsfc_free_buffer(struct usb_ep *_ep, void *buf, dma_addr_t dma,
+				unsigned bytes)
+{
+	struct musbhsfc_ep *ep;
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	kfree(buf);
+	
+}
+
+/** Queue one request
+ *  Kickstart transfer if needed
+ *  NOTE: Sets INDEX register
+ */
+static int musbhsfc_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 int gfp_flags)
+{
+	struct musbhsfc_request *req;
+	struct musbhsfc_ep *ep;
+	struct musbhsfc_udc *dev;
+	unsigned long flags;
+
+	DEBUG("\n\n\n%s, %p\n", __FUNCTION__, _ep);
+
+	req = container_of(_req, struct musbhsfc_request, req);
+	if (unlikely
+	    (!_req || !_req->complete || !_req->buf
+	     || !list_empty(&req->queue))) {
+		DEBUG("%s, bad params\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
+		DEBUG("%s, bogus device state %p\n", __FUNCTION__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	DEBUG("%s queue req %p, len %d buf %p\n", _ep->name, _req, _req->length,
+	      _req->buf);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* kickstart this i/o queue? */
+	DEBUG("Add to %d Q %d %d\n", ep_index(ep), list_empty(&ep->queue),
+	      ep->stopped);
+	if (list_empty(&ep->queue) && likely(!ep->stopped)) {
+		u8 csr;
+
+		if (ep_index(ep) == 0) {
+			/* EP0 */
+			list_add_tail(&req->queue, &ep->queue);
+			musbhsfc_ep0_kick(dev, ep);
+			req = 0;
+		} else if (musbhsfc_check_dir(ep, USB_DIR_IN)) {
+			usb_set_index(ep_index(ep));
+			csr = usb_readb(ep->csr1);
+			pio_irq_enable(ep_index(ep));
+			if ((csr & USB_INCSR_FIFONEMPTY) == 0) {
+				if (write_fifo(ep, req) == 1)
+					req = 0;
+			}
+		} else if (musbhsfc_check_dir(ep, USB_DIR_OUT)){
+			usb_set_index(ep_index(ep));
+			csr = usb_readb(ep->csr1);
+			pio_irq_enable(ep_index(ep));
+			if (!(csr & USB_OUTCSR_FIFOFULL)) {
+				if (read_fifo(ep, req) == 1)
+					req = 0;
+			}
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (likely(req != 0)) 
+		list_add_tail(&req->queue, &ep->queue);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* dequeue JUST ONE request */
+static int musbhsfc_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct musbhsfc_ep *ep;
+	struct musbhsfc_request *req;
+	unsigned long flags;
+
+	DEBUG("%s, %p\n", __FUNCTION__, _ep);
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+/** Halt specific EP
+ *  Return 0 if success
+ *  NOTE: Sets INDEX register to EP !
+ */
+static int musbhsfc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct musbhsfc_ep *ep;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	usb_set_index(ep_index(ep));
+
+	DEBUG("%s, ep %d, val %d\n", __FUNCTION__, ep_index(ep), value);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	if (ep_index(ep) == 0) {
+		/* EP0 */
+		usb_setb(USB_CSR0_SENDSTALL, ep->csr1);
+	} else if (musbhsfc_check_dir(ep, USB_DIR_IN)) {
+		u8 csr = usb_readb(ep->csr1);
+		if (value && ((csr & USB_INCSR_FIFONEMPTY)
+			      || !list_empty(&ep->queue))) {
+			/*
+			 * Attempts to halt IN endpoints will fail (returning -EAGAIN)
+			 * if any transfer requests are still queued, or if the controller
+			 * FIFO still holds bytes that the host hasn't collected.
+			 */
+			spin_unlock_irqrestore(&ep->dev->lock, flags);
+			DEBUG
+			    ("Attempt to halt IN endpoint failed (returning -EAGAIN) %d %d\n",
+			     (csr & USB_INCSR_FIFONEMPTY),
+			     !list_empty(&ep->queue));
+			return -EAGAIN;
+		}
+		flush(ep);
+		if (value)
+			usb_setb(USB_INCSR_SENDSTALL, ep->csr1);
+		else {
+			usb_clearb(USB_INCSR_SENDSTALL, ep->csr1);
+			usb_setb(USB_INCSR_CLRDATATOG, ep->csr1);
+		}
+
+	} else if (musbhsfc_check_dir(ep, USB_DIR_OUT)) {
+
+		flush(ep);
+		if (value)
+			usb_setb(USB_OUTCSR_SENDSTALL, ep->csr1);
+		else {
+			usb_clearb(USB_OUTCSR_SENDSTALL, ep->csr1);
+			usb_setb(USB_OUTCSR_CLRDATATOG, ep->csr1);
+		}
+	}
+
+	if (value) {
+		ep->stopped = 1;
+	} else {
+		ep->stopped = 0;
+	}
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DEBUG("%s %s halted\n", _ep->name, value == 0 ? "NOT" : "IS");
+
+	return 0;
+}
+
+/** Return bytes in EP FIFO
+ *  NOTE: Sets INDEX register to EP
+ */
+static int musbhsfc_fifo_status(struct usb_ep *_ep)
+{
+	u8 csr;
+	int count = 0;
+	struct musbhsfc_ep *ep;
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (!_ep) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	DEBUG("%s, %d\n", __FUNCTION__, ep_index(ep));
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (musbhsfc_check_dir(ep, USB_DIR_IN))
+		return -EOPNOTSUPP;
+
+	usb_set_index(ep_index(ep));
+
+	csr = usb_readb(ep->csr1);
+	if (ep->dev->gadget.speed != USB_SPEED_UNKNOWN ||
+	    csr & USB_OUTCSR_OUTPKTRDY) {
+		count = usb_readw(USB_OUTCOUNT);
+	}
+
+	return count;
+}
+
+/** Flush EP FIFO
+ *  NOTE: Sets INDEX register to EP
+ */
+static void musbhsfc_fifo_flush(struct usb_ep *_ep)
+{
+	struct musbhsfc_ep *ep;
+
+	ep = container_of(_ep, struct musbhsfc_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DEBUG("%s, bad ep\n", __FUNCTION__);
+		return;
+	}
+
+	usb_set_index(ep_index(ep));
+	flush(ep);
+}
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+
+/* return:  0 = still running, 1 = completed, negative = errno */
+static int write_fifo_ep0(struct musbhsfc_ep *ep, struct musbhsfc_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+
+	DEBUG_EP0("%s\n", __FUNCTION__);
+
+	count = write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (unlikely(count != max))
+		is_last = 1;
+	else {
+		if (likely(req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DEBUG_EP0("%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
+		  ep->ep.name, count,
+		  is_last ? "/L" : "", req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		done(ep, req, 0);
+		return 1;
+	}
+
+	return 0;
+}
+
+static __inline__ int musbhsfc_fifo_read(struct musbhsfc_ep *ep,
+					unsigned char *cp, int max)
+{
+	int bytes;
+	int count = usb_readw(USB_OUTCOUNT);
+
+	if (count > max)
+		count = max;
+	bytes = count;
+	while (count--)
+		*cp++ = usb_readb(ep->fifo) & 0xFF;
+	return bytes;
+}
+
+static __inline__ void musbhsfc_fifo_write(struct musbhsfc_ep *ep,
+					  unsigned char *cp, int count)
+{
+	DEBUG_EP0("fifo_write: %d %d\n", ep_index(ep), count);
+	while (count--) {
+		usb_writeb(*cp, ep->fifo);
+		cp++;
+	}
+}
+
+static int read_fifo_ep0(struct musbhsfc_ep *ep, struct musbhsfc_request *req)
+{
+	u8 csr;
+	u8 *buf;
+	unsigned bufferspace, count, is_short;
+
+	DEBUG_EP0("%s\n", __FUNCTION__);
+
+	csr = usb_readb(USB_CSR0);
+	if (!(csr & USB_OUTCSR_OUTPKTRDY))
+		return 0;
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	if (likely(csr & USB_CSR0_OUTPKTRDY)) {
+		count = usb_readw(USB_OUTCOUNT);
+		req->req.actual += min(count, bufferspace);
+	} else			/* zlp */
+		count = 0;
+
+	is_short = (count < ep->ep.maxpacket);
+	DEBUG_EP0("read %s %02x, %d bytes%s req %p %d/%d\n",
+		  ep->ep.name, csr, count,
+		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+	while (likely(count-- != 0)) {
+		u8 byte = (u8) (usb_readb(ep->fifo) & 0xff);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DEBUG_EP0("%s overflow %d\n", ep->ep.name,
+					  count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace--;
+		}
+	}
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		done(ep, req, 0);
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+/**
+ * udc_set_address - set the USB address for this device
+ * @address:
+ *
+ * Called from control endpoint function after it decodes a set address setup packet.
+ */
+static void udc_set_address(struct musbhsfc_udc *dev, unsigned char address)
+{
+	DEBUG_EP0("%s: %d\n", __FUNCTION__, address);
+	dev->usb_address = address;
+	usb_setb((address & USB_FADDR_ADDR_MASK), USB_FADDR);
+	usb_setb(USB_FADDR_UPDATE | (address & USB_FADDR_ADDR_MASK), USB_FADDR);
+}
+
+/*
+ * DATA_STATE_RECV (OUTPKTRDY)
+ *      - if error
+ *      	clear USB_CSR0_OUTPKTRDY
+ *              set USB_CSR0_DATAEND | USB_CSR0_SENDSTALL bits
+ *      - else
+ *              clear USB_CSR0_OUTPKTRDY bit
+ 				if last set USB_CSR0_DATAEND bit
+ */
+static void musbhsfc_ep0_out(struct musbhsfc_udc *dev, u8 csr)
+{
+	struct musbhsfc_request *req;
+	struct musbhsfc_ep *ep = &dev->ep[0];
+	int ret;
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct musbhsfc_request, queue);
+
+	if (req) {
+
+		if (req->req.length == 0) {
+			DEBUG_EP0("ZERO LENGTH OUT!\n");
+			usb_setb(USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND, 
+				 USB_CSR0);
+			dev->ep0state = WAIT_FOR_SETUP;
+			return;
+		}
+		ret = read_fifo_ep0(ep, req);
+		if (ret) {
+			/* Done! */
+			DEBUG_EP0("%s: finished, waiting for status\n",
+				  __FUNCTION__);
+
+			usb_setb(USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND, 
+				 USB_CSR0);
+			dev->ep0state = WAIT_FOR_SETUP;
+		} else {
+			/* Not done yet.. */
+			DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+			usb_setb(USB_CSR0_SVDOUTPKTRDY, USB_CSR0);
+		}
+	} else {
+		DEBUG_EP0("NO REQ??!\n");
+	}
+}
+
+/*
+ * DATA_STATE_XMIT
+ */
+static int musbhsfc_ep0_in(struct musbhsfc_udc *dev, u8 csr)
+{
+	struct musbhsfc_request *req;
+	struct musbhsfc_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct musbhsfc_request, queue);
+
+	if (!req) {
+		DEBUG_EP0("%s: NULL REQ\n", __FUNCTION__);
+		return 0;
+	}
+
+	if (req->req.length == 0) {
+
+		usb_setb((USB_CSR0_INPKTRDY | USB_CSR0_DATAEND), USB_CSR0);
+		dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+
+	if (req->req.length - req->req.actual == EP0_PACKETSIZE) {
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+
+	ret = write_fifo_ep0(ep, req);
+
+	if (ret == 1 && !need_zlp) {
+		/* Last packet */
+		DEBUG_EP0("%s: finished, waiting for status\n", __FUNCTION__);
+
+		usb_setb((USB_CSR0_INPKTRDY | USB_CSR0_DATAEND), USB_CSR0);
+		dev->ep0state = WAIT_FOR_SETUP;
+	} else {
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+		usb_setb(USB_CSR0_INPKTRDY, USB_CSR0);
+	}
+
+	if (need_zlp) {
+		DEBUG_EP0("%s: Need ZLP!\n", __FUNCTION__);
+		usb_setb(USB_CSR0_INPKTRDY, USB_CSR0);
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+
+	return 1;
+}
+
+static int musbhsfc_handle_get_status(struct musbhsfc_udc *dev,
+				     struct usb_ctrlrequest *ctrl)
+{
+	struct musbhsfc_ep *ep0 = &dev->ep[0];
+	struct musbhsfc_ep *qep;
+	int reqtype = (ctrl->bRequestType & USB_RECIP_MASK);
+	u16 val = 0;
+	u16 wIndex = le16_to_cpu(ctrl->wIndex);
+	u16 wLength = le16_to_cpu(ctrl->wLength);
+
+	if (reqtype == USB_RECIP_INTERFACE) {
+		/* This is not supported.
+		 * And according to the USB spec, this one does nothing..
+		 * Just return 0
+		 */
+		DEBUG_SETUP("GET_STATUS: USB_RECIP_INTERFACE\n");
+	} else if (reqtype == USB_RECIP_DEVICE) {
+		DEBUG_SETUP("GET_STATUS: USB_RECIP_DEVICE\n");
+		val |= (1 << 0);	/* Self powered */
+		/*val |= (1<<1); *//* Remote wakeup */
+	} else if (reqtype == USB_RECIP_ENDPOINT) {
+		int ep_num = (wIndex & ~USB_DIR_IN);
+
+		DEBUG_SETUP
+		    ("GET_STATUS: USB_RECIP_ENDPOINT (%d), wLength = %d\n",
+		     ep_num, wLength);
+
+		if (wLength > 2 || ep_num > 3)
+			return -EOPNOTSUPP;
+
+		qep = &dev->ep[ep_num];
+		if (musbhsfc_check_dir(qep, USB_DIR_IN) 
+		    != ((wIndex & USB_DIR_IN) ? 1 : 0)
+		    && ep_index(qep) != 0) {
+			return -EOPNOTSUPP;
+		}
+
+		usb_set_index(ep_index(qep));
+
+		/* Return status on next IN token */
+		switch (qep->ep_type) {
+		case ep_control:
+			val =
+			    (usb_readb(qep->csr1) & USB_CSR0_SENDSTALL) ==
+			    USB_CSR0_SENDSTALL;
+			break;
+		case ep_bulk_in:
+		case ep_interrupt:
+			val =
+			    (usb_readb(qep->csr1) & USB_INCSR_SENDSTALL) ==
+			    USB_INCSR_SENDSTALL;
+			break;
+		case ep_bulk_out:
+			val =
+			    (usb_readb(qep->csr1) & USB_OUTCSR_SENDSTALL) ==
+			    USB_OUTCSR_SENDSTALL;
+			break;
+		}
+
+		/* Back to EP0 index */
+		usb_set_index(0);
+
+		DEBUG_SETUP("GET_STATUS, ep: %d (%x), val = %d\n", ep_num,
+			    wIndex, val);
+	} else {
+		DEBUG_SETUP("Unknown REQ TYPE: %d\n", reqtype);
+		return -EOPNOTSUPP;
+	}
+
+	/* Clear "out packet ready" */
+	usb_setb(USB_CSR0_SVDOUTPKTRDY, USB_CSR0);
+	/* Put status to FIFO */
+	musbhsfc_fifo_write(ep0, (u8 *) & val, sizeof(val));
+	/* Issue "In packet ready" */
+	usb_setb((USB_CSR0_INPKTRDY | USB_CSR0_DATAEND), USB_CSR0);
+
+	return 0;
+}
+
+/*
+ * WAIT_FOR_SETUP (OUTPKTRDY)
+ *      - read data packet from EP0 FIFO
+ *      - decode command
+ *      - if error
+ *              clear USB_CSR0_OUTPKTRDY
+ *              set USB_CSR0_DATAEND | USB_CSR0_SENDSTALL bits
+ *      - else
+ *              clear USB_CSR0_OUTPKTRDY
+ *              set USB_CSR0_DATAEND bits
+ */
+static void musbhsfc_ep0_setup(struct musbhsfc_udc *dev, u8 csr)
+{
+	struct musbhsfc_ep *ep = &dev->ep[0];
+	struct usb_ctrlrequest ctrl;
+	int i, bytes, is_in;
+
+	DEBUG_SETUP("%s: %x\n", __FUNCTION__, csr);
+
+	/* Nuke all previous transfers */
+	nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	bytes = musbhsfc_fifo_read(ep, (unsigned char *)&ctrl, 8);
+
+	/* CTRL Request is LE */
+	ctrl.wLength = __le16_to_cpu(ctrl.wLength);
+	ctrl.wIndex = __le16_to_cpu(ctrl.wIndex);
+	ctrl.wValue = __le16_to_cpu(ctrl.wValue);
+
+	DEBUG_SETUP("Read CTRL REQ %d bytes\n", bytes);
+	DEBUG_SETUP("CTRL.bRequestType = %d (is_in %d)\n", ctrl.bRequestType,
+		    ctrl.bRequestType == USB_DIR_IN);
+	DEBUG_SETUP("CTRL.bRequest = %d\n", ctrl.bRequest);
+	DEBUG_SETUP("CTRL.wLength = %d\n", ctrl.wLength);
+	DEBUG_SETUP("CTRL.wValue = %d (%d)\n", ctrl.wValue, 
+		     ctrl.wValue >> 8);
+	DEBUG_SETUP("CTRL.wIndex = %d\n", ctrl.wIndex);
+
+	/* Set direction of EP0 */
+	if (likely(ctrl.bRequestType & USB_DIR_IN)) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+
+	/* Handle some SETUP packets ourselves */
+	switch (ctrl.bRequest) {
+	case USB_REQ_SET_ADDRESS:
+		if (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+
+		DEBUG_SETUP("USB_REQ_SET_ADDRESS (%d)\n", 
+			    ctrl.wValue);
+		udc_set_address(dev, ctrl.wValue);
+		usb_setb(USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND, 
+			 USB_CSR0);
+		return;
+
+	case USB_REQ_GET_STATUS:{
+			if (musbhsfc_handle_get_status(dev, &ctrl) == 0)
+				return;
+
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+			if (ctrl.bRequestType == USB_RECIP_ENDPOINT) {
+				struct musbhsfc_ep *qep;
+				int ep_num = (ctrl.wIndex 
+					      & 0x0f);
+
+				/* Support only HALT feature */
+				if (ctrl.wValue != 0 
+				    || ctrl.wLength != 0
+				    || ep_num > 3 || ep_num < 1)
+					break;
+
+				qep = &dev->ep[ep_num];
+				if (ctrl.bRequest == USB_REQ_SET_FEATURE) {
+					DEBUG_SETUP("SET_FEATURE (%d)\n",
+						    ep_num);
+					musbhsfc_set_halt(&qep->ep, 1);
+				} else {
+					DEBUG_SETUP("CLR_FEATURE (%d)\n",
+						    ep_num);
+					musbhsfc_set_halt(&qep->ep, 0);
+				}
+				usb_set_index(0);
+
+				/* Reply with a ZLP on next IN token */
+				usb_setb(USB_CSR0_SVDOUTPKTRDY | 
+					 USB_CSR0_DATAEND, USB_CSR0);
+				return;
+			}
+			break;
+		}
+
+	default:
+		break;
+	}
+
+	if (likely(dev->driver)) {
+		/* device-2-host (IN) or no data setup command, process immediately */
+		spin_unlock(&dev->lock);
+		i = dev->driver->setup(&dev->gadget, &ctrl);
+		spin_lock(&dev->lock);
+
+		if (i < 0) {
+			/* setup processing failed, force stall */
+			DEBUG_SETUP
+			    ("  --> ERROR: gadget setup FAILED (stalling), setup returned %d\n",
+			     i);
+			usb_set_index(0);
+			usb_setb((USB_CSR0_SVDOUTPKTRDY | USB_CSR0_DATAEND | 
+				  USB_CSR0_SENDSTALL), USB_CSR0);
+
+			/* ep->stopped = 1; */
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/*
+ * DATA_STATE_NEED_ZLP
+ */
+static void musbhsfc_ep0_in_zlp(struct musbhsfc_udc *dev, u8 csr)
+{
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	usb_setb((USB_CSR0_INPKTRDY | USB_CSR0_DATAEND), USB_CSR0);
+	dev->ep0state = WAIT_FOR_SETUP;
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void musbhsfc_handle_ep0(struct musbhsfc_udc *dev, u32 intr)
+{
+	struct musbhsfc_ep *ep = &dev->ep[0];
+	u8 csr;
+
+	/* Set index 0 */
+	usb_set_index(0);
+ 	csr = usb_readb(USB_CSR0);
+
+	DEBUG_EP0("%s: csr = %x\n", __FUNCTION__, csr);
+
+	/*
+	 * if SENTSTALL is set
+	 *      - clear the SENTSTALL bit
+	 */
+	if (csr & USB_CSR0_SENTSTALL) {
+		DEBUG_EP0("%s: USB_CSR0_SENTSTALL is set: %x\n", __FUNCTION__, csr);
+		usb_clearb((USB_CSR0_SENTSTALL | USB_CSR0_SENDSTALL), 
+			  USB_CSR0);
+		nuke(ep, -ECONNABORTED);
+		dev->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/*
+	 * if a transfer is in progress && INPKTRDY and OUTPKTRDY are clear
+	 *      - fill EP0 FIFO
+	 *      - if last packet
+	 *      -       set INPKTRDY | DATAEND
+	 *      - else
+	 *              set INPKTRDY
+	 */
+	if (!(csr & (USB_CSR0_INPKTRDY | USB_CSR0_OUTPKTRDY))) {
+		DEBUG_EP0("%s: INPKTRDY and OUTPKTRDY are clear\n",
+			  __FUNCTION__);
+
+		switch (dev->ep0state) {
+		case DATA_STATE_XMIT:
+			DEBUG_EP0("continue with DATA_STATE_XMIT\n");
+			musbhsfc_ep0_in(dev, csr);
+			return;
+		case DATA_STATE_NEED_ZLP:
+			DEBUG_EP0("continue with DATA_STATE_NEED_ZLP\n");
+			musbhsfc_ep0_in_zlp(dev, csr);
+			return;
+		default:
+			/* Stall? */
+			DEBUG_EP0("Odd state!! state = %s\n",
+				  state_names[dev->ep0state]);
+			dev->ep0state = WAIT_FOR_SETUP;
+			break;
+		}
+	}
+
+	/*
+	 * if SETUPEND is set
+	 *      - abort the last transfer
+	 *      - set SVDSETUPEND
+	 */
+	if (csr & USB_CSR0_SETUPEND) {
+		DEBUG_EP0("%s: USB_CSR0_SETUPEND is set: %x\n", __FUNCTION__, csr);
+
+		usb_setb(USB_CSR0_SVDSETUPEND, USB_CSR0);
+
+		nuke(ep, 0);
+		dev->ep0state = WAIT_FOR_SETUP;
+	}
+
+	/*
+	 * if USB_CSR0_OUTPKTRDY is set
+	 *      - read data packet from EP0 FIFO
+	 *      - decode command
+	 *      - if error
+	 *              set SVDOUTPKTRDY | DATAEND bits | SENDSTALL
+	 *      - else
+	 *              set SVDOUTPKTRDY | DATAEND bits
+	 */
+	if (csr & USB_CSR0_OUTPKTRDY) {
+
+		DEBUG_EP0("%s: USB_CSR0_OUTPKTRDY is set: %x\n", __FUNCTION__,
+			  csr);
+
+		switch (dev->ep0state) {
+		case WAIT_FOR_SETUP:
+			DEBUG_EP0("WAIT_FOR_SETUP\n");
+			musbhsfc_ep0_setup(dev, csr);
+			break;
+
+		case DATA_STATE_RECV:
+			DEBUG_EP0("DATA_STATE_RECV\n");
+			musbhsfc_ep0_out(dev, csr);
+			break;
+
+		default:
+			/* send stall? */
+			DEBUG_EP0("strange state!! 2. send stall? state = %d\n",
+				  dev->ep0state);
+			break;
+		}
+	}
+}
+
+static void musbhsfc_ep0_kick(struct musbhsfc_udc *dev, struct musbhsfc_ep *ep)
+{
+	u8 csr;
+
+	usb_set_index(0);
+	csr = usb_readb(USB_CSR0);
+
+	DEBUG_EP0("%s: %x\n", __FUNCTION__, csr);
+
+	/* Clear "out packet ready" */
+	usb_setb(USB_CSR0_SVDOUTPKTRDY, USB_CSR0);
+
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		musbhsfc_ep0_in(dev, csr);
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		musbhsfc_ep0_out(dev, csr);
+	}
+}
+
+/* ---------------------------------------------------------------------------
+ * 	device-scoped parts of the api to the usb controller hardware
+ * ---------------------------------------------------------------------------
+ */
+
+static int musbhsfc_udc_get_frame(struct usb_gadget *_gadget)
+{
+	return usb_readw(USB_FRAME);
+}
+
+static int musbhsfc_udc_wakeup(struct usb_gadget *_gadget)
+{
+	return -ENOTSUPP;
+}
+
+static const struct usb_gadget_ops musbhsfc_udc_ops = {
+	.get_frame = musbhsfc_udc_get_frame,
+	.wakeup = musbhsfc_udc_wakeup,
+	/* current versions must always be self-powered */
+};
+
+static void nop_release(struct device *dev)
+{
+	DEBUG("%s %s\n", __FUNCTION__, dev->bus_id);
+}
+
+static struct musbhsfc_udc udc = {
+	.usb_address = 0,
+
+	.gadget = {
+		   .ops = &musbhsfc_udc_ops,
+		   .ep0 = &udc.ep[0].ep,
+		   .name = driver_name,
+		   .dev = {
+			   .bus_id = "gadget",
+			   .release = nop_release,
+			   },
+		   },
+
+	/* control endpoint */
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &musbhsfc_ep_ops,
+			 .maxpacket = EP0_PACKETSIZE,
+			 },
+		  .dev = &udc,
+
+		  .bEndpointAddress = 0,
+		  .bmAttributes = 0,
+
+		  .ep_type = ep_control,
+		  .fifo = USB_FIFO_EP0,
+		  .csr1 = USB_CSR0,
+		  .csr2 = USB_CSR0,
+		  },
+
+	/* first group of endpoints */
+	.ep[1] = {
+		  .ep = {
+			 .name = "ep1",
+			 .ops = &musbhsfc_ep_ops,
+			 .maxpacket = 64,
+			 },
+		  .dev = &udc,
+
+		  .bEndpointAddress =  USB_DIR_IN | 1,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_in,
+		  .fifo = USB_FIFO_EP0 + 4,
+		  .csr1 = USB_INCSR,
+		  .csr2 = USB_INCSRH,
+		  },
+
+	.ep[2] = {
+		  .ep = {
+			 .name = "ep2",
+			 .ops = &musbhsfc_ep_ops,
+			 .maxpacket = 64,
+			 },
+		  .dev = &udc,
+
+		  .bEndpointAddress = 2,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_out,
+		  .fifo = USB_FIFO_EP0 + 8,
+		  .csr1 = USB_OUTCSR,
+		  .csr2 = USB_OUTCSRH,
+		  },
+
+	.ep[3] = {
+		  .ep = {
+			 .name = "ep3",
+			 .ops = &musbhsfc_ep_ops,
+			 .maxpacket = 16,
+			 },
+		  .dev = &udc,
+
+		  .bEndpointAddress = USB_DIR_IN | 3,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = USB_FIFO_EP0 + 12,
+		  .csr1 = USB_INCSR,
+		  .csr2 = USB_INCSRH,
+		  },
+};
+
+/*
+ * 	probe - binds to the platform device
+ */
+static int musbhsfc_udc_probe(struct device *_dev)
+{
+	struct musbhsfc_udc *dev = &udc;
+	int retval;
+	struct platform_device *pdev = to_platform_device(_dev);
+	struct resource *res;
+
+	DEBUG("%s: %p\n", __FUNCTION__, _dev);
+
+	device_irq = platform_get_irq_byname(pdev, "usb_device_irq");
+	if (!device_irq) {
+		DEBUG("%s: no device_irq\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		DEBUG("%s: no reg addr\n", __FUNCTION__);
+		return -ENODEV;
+	}
+	phys_addr = res->start;
+	base_len = res->end - res->start + 1;
+	
+	if (!request_mem_region(phys_addr, base_len, driver_name)) {
+		DEBUG("%s: request_mem_region failed\n", __FUNCTION__);
+		return -EBUSY;
+        }
+	
+	base_addr = (unsigned long)ioremap_nocache(phys_addr, base_len);
+	if (base_addr == 0)
+		return -EFAULT;
+	
+	spin_lock_init(&dev->lock);
+	dev->dev = _dev;
+
+	device_initialize(&dev->gadget.dev);
+	dev->gadget.dev.parent = _dev;
+
+	the_controller = dev;
+	dev_set_drvdata(_dev, dev);
+
+	udc_disable(dev);
+	udc_reinit(dev);
+
+	/* irq setup after old hardware state is cleaned up */
+	retval = request_irq(device_irq, musbhsfc_udc_irq, SA_INTERRUPT, 
+			driver_name, dev);
+	if (retval != 0) {
+		DEBUG(KERN_ERR "%s: can't get irq %i, err %d\n", driver_name,
+		      device_irq, retval);
+		return -EBUSY;
+	}
+
+	create_proc_files();
+
+	return retval;
+}
+
+static int musbhsfc_udc_remove(struct device *_dev)
+{
+	struct musbhsfc_udc *dev = &udc;
+
+	DEBUG("%s: %p\n", __FUNCTION__, dev);
+
+	udc_disable(dev);
+	remove_proc_files();
+	usb_gadget_unregister_driver(dev->driver);
+
+	free_irq(device_irq, dev);
+	
+	dev_set_drvdata(_dev, 0);
+	
+	release_mem_region(phys_addr, base_len);
+	iounmap ((void *)base_addr);
+
+	the_controller = 0;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct device_driver udc_driver = {
+	.name = (char *)driver_name,
+	.bus = &platform_bus_type,
+	.probe = musbhsfc_udc_probe,
+	.remove = musbhsfc_udc_remove
+	    /* FIXME power management support */
+	    /* .suspend = ... disable UDC */
+	    /* .resume = ... re-enable UDC */
+};
+
+static int __init udc_init(void)
+{
+	DEBUG("%s: %s version %s\n", __FUNCTION__, driver_name, DRIVER_VERSION);
+	return driver_register(&udc_driver);
+}
+
+static void __exit udc_exit(void)
+{
+	driver_unregister(&udc_driver);
+}
+
+module_init(udc_init);
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("source@mvista.com");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/usb/gadget/musbhsfc_udc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/usb/gadget/musbhsfc_udc.h
@@ -0,0 +1,234 @@
+/*
+ * linux/drivers/usb/gadget/musbhsfc_udc.h
+ * Inventra MUSBHSFC USB device controller
+ *
+ * Copyright (C) 2004 Mikko Lahteenmaki, Nordic ID
+ * Copyright (C) 2004 Bo Henriksen, Nordic ID
+ * Copyright (C) 2004 IBM Corp.
+ * Copyright (C) 2005 Montavista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MUSBHSFC_H_
+#define __MUSBHSFC_H_
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <linux/usb_ch9.h>
+#include <linux/usb_gadget.h>
+
+/*
+ * Memory map
+ */
+
+#define USB_INTRIN	0x00	/* IN interrupt register */
+#define USB_POWER	0x02	/* Power management register */
+#define USB_FADDR	0x03	/* Function address register */
+#define USB_INTRINE	0x04	/* IN interrupt enable reg */
+#define USB_INTROUT	0x06	/* OUT interrupt register */
+#define USB_INTRUSBE    0x08	/* IntrUSB interrupt en reg */
+#define USB_INTRUSB	0x09	/* Interrupt register */
+#define USB_INTROUTE	0x0A	/* OUT interrupt enable reg */
+#define USB_TESTMODE	0x0C	/* Enables the USB 2.0 test modes */
+#define USB_INDEX	0x0D	/* Index register */
+#define USB_FRAME	0x0E	/* Frame number */
+#define USB_CSR0        0x11	/* Control Status reg for EP0 */
+#define USB_INCSRH      0x10	/* Control Status reg for IN */
+#define USB_INCSR       0x11	/* Control Status reg for IN */
+#define USB_INMAXP      0x12	/* Max packet size for IN ept */
+#define USB_OUTCSRH     0x14	/* Control Status reg for OUT */
+#define USB_OUTCSR      0x15	/* Control Status reg for OUT */
+#define USB_OUTMAXP     0x16	/* Max packet size for OUT ep */
+#define USB_OUTCOUNT    0x1A	/* Num of received bytes in */
+				/* EP0 FIFO or OUT EP FIFO */
+#define USB_FIFO_EP0    0x20	/* FIFOs for Endpoint 0 */
+				/* next FIFO is at + 4bytes */
+
+/* Interrupt IN register bit masks */
+#define USB_INTRIN_EP0			1<<0
+#define USB_INTRIN_EP1			1<<1
+#define USB_INTRIN_EP2			1<<2
+#define USB_INTRIN_EP3			1<<3
+
+/* Power register bit masks */
+#define USB_POWER_ISO_UPDATE		0x80
+#define USB_POWER_FS_PHY_ENAB		0x40
+#define USB_POWER_HS_ENAB		0x20
+#define USB_POWER_HS_MODE		0x10
+#define USB_POWER_RESET			0x08
+#define USB_POWER_RESUME		0x04
+#define USB_POWER_SUSPEND_MODE		0x02
+#define USB_POWER_ENABLE_SUSPEND	0x01
+
+/* FADDR bits definitions */
+#define USB_FADDR_ADDR_MASK		0x7f  /* address */
+#define USB_FADDR_UPDATE		0x80  /* update */
+
+/* Interrupt OUT register bit masks */
+#define USB_INTROUT_EP0                  1<<0
+#define USB_INTROUT_EP1                  1<<1
+#define USB_INTROUT_EP2                  1<<2
+#define USB_INTROUT_EP3                  1<<3
+
+/* Interrupt USB register bit masks */
+#define USB_INTRUSB_SOF			0x08
+#define USB_INTRUSB_RESET		0x04
+#define USB_INTRUSB_RESUME		0x02
+#define USB_INTRUSB_SUSPEND		0x01
+
+/* Interrupt USB Enable register bit masks */
+#define USB_INTRUSBE_SOF		0x08
+#define USB_INTRUSBE_RESET		0x04
+#define USB_INTRUSBE_RESUME		0x02
+#define USB_INTRUSBE_SUSPEND		0x01
+
+/* Testmode register bits */
+#define USB_TEST_SE0NAK			0x01
+#define USB_TEST_J			0x02
+#define USB_TEST_K			0x04
+#define USB_TEST_PACKET			0x08
+
+/* CSR0 bit masks */
+#define USB_CSR0_SVDSETUPEND		0x80
+#define USB_CSR0_SVDOUTPKTRDY		0x40
+#define USB_CSR0_SENDSTALL		0x20
+#define USB_CSR0_SETUPEND		0x10
+#define USB_CSR0_DATAEND		0x08
+#define USB_CSR0_SENTSTALL		0x04
+#define USB_CSR0_INPKTRDY		0x02
+#define USB_CSR0_OUTPKTRDY		0x01
+
+/* Endpoint CSR register bits */
+/* IN CSR */
+#define USB_INCSRH_AUTOSET		0x80
+#define USB_INCSRH_ISO			0x40
+#define USB_INCSRH_MODE			0x20
+#define USB_INCSRH_DMAENA		0x10
+#define USB_INCSRH_FRCDATATOG		0x08
+#define USB_INCSR_INCOMPTX		0x80
+#define USB_INCSR_CLRDATATOG		0x40
+#define USB_INCSR_SENTSTALL		0x20
+#define USB_INCSR_SENDSTALL		0x10
+#define USB_INCSR_FLUSHFIFO		0x08
+#define USB_INCSR_UNDERRUN		0x04
+#define USB_INCSR_FIFONEMPTY		0x02
+#define USB_INCSR_INPKTRDY		0x01
+/* OUT CSR */
+#define USB_OUTCSRH_AUTOCLR		0x80
+#define USB_OUTCSRH_ISO			0x40
+#define USB_OUTCSRH_DMAENA		0x20
+#define USB_OUTCSRH_DISNYET		0x10
+#define USB_OUTCSRH_DMAMODE		0x08
+#define USB_OUTCSRH_INCOMPRX		0x01
+#define USB_OUTCSR_CLRDATATOG		0x80
+#define USB_OUTCSR_SENTSTALL		0x40
+#define USB_OUTCSR_SENDSTALL		0x20
+#define USB_OUTCSR_FLUSHFIFO		0x10
+#define USB_OUTCSR_DATA_ERROR		0x08
+#define USB_OUTCSR_OVERRUN		0x04
+#define USB_OUTCSR_FIFOFULL		0x02
+#define USB_OUTCSR_OUTPKTRDY		0x01
+
+// Max packet size
+#define EP0_PACKETSIZE          64
+#define EP0_MAXPACKETSIZE       64
+
+#define USB_MAX_BUFFER_SIZE	4096
+
+#define UDC_MAX_ENDPOINTS	4
+
+#define WAIT_FOR_SETUP		0
+#define DATA_STATE_XMIT		1
+#define DATA_STATE_NEED_ZLP	2
+#define WAIT_FOR_OUT_STATUS	3
+#define DATA_STATE_RECV		4
+
+/* ********************************************************************************************* */
+/* IO
+ */
+
+typedef enum ep_type {
+	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
+} ep_type_t;
+
+struct musbhsfc_ep {
+	struct usb_ep ep;
+	struct musbhsfc_udc *dev;
+
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+
+	u8 stopped;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+
+	ep_type_t ep_type;
+	u32 fifo;
+	u32 csr1;
+	u32 csr2;
+};
+
+struct musbhsfc_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+struct musbhsfc_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct device *dev;
+	spinlock_t lock;
+
+	int ep0state;
+	struct musbhsfc_ep ep[UDC_MAX_ENDPOINTS];
+
+	unsigned char usb_address;
+	unsigned usb2_device:1;
+	unsigned speed_set:1;
+};
+
+extern struct musbhsfc_udc *the_controller;
+
+#define ep_is_in(EP) 		(((EP)->bEndpointAddress&USB_DIR_IN)==USB_DIR_IN)
+#define ep_index(EP) 		((EP)->bEndpointAddress&0xF)
+#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
+
+#endif
Index: linux-2.6.10/mvl_patches/pro-0147.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0147.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(147);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

