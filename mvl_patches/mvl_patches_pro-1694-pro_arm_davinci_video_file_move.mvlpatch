#! /usr/bin/env bash
# Patch: -pro_arm_davinci_video_file_move
# Date: Mon Jan 21 23:07:25 2008
# Source: Texas Instruments Inc.
# MR: 26129
# Type: Enhancement
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
#  Moved original davinci video file to new directory structure due to
#  video redesign work done for DM355/DM6467
# 

PATCHNUM=1694
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments Inc.
MR: 26129
Type: Enhancement
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:
 Moved original davinci video file to new directory structure due to
 video redesign work done for DM355/DM6467

Index: linux-2.6.10/drivers/media/video/ccdc_davinci.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/ccdc_davinci.c
+++ /dev/null
@@ -1,436 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* ccdc_davinci.c */
-
-#include <linux/device.h>
-#include <media/ccdc_davinci.h>
-
-extern struct device *vpfe_dev;
-
-void ccdc_readregs(void)
-{
-	unsigned int val = 0;
-
-	val = regr(ALAW);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to ALAW...\n", val);
-	val = regr(CLAMP);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to CLAMP...\n", val);
-	val = regr(DCSUB);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to DCSUB...\n", val);
-	val = regr(BLKCMP);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP...\n", val);
-	val = regr(FPC_ADDR);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC_ADDR...\n", val);
-	val = regr(FPC);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC...\n", val);
-	val = regr(FMTCFG);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTCFG...\n", val);
-	val = regr(COLPTN);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to COLPTN...\n", val);
-	val = regr(FMT_HORZ);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_HORZ...\n", val);
-	val = regr(FMT_VERT);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_VERT...\n", val);
-	val = regr(HSIZE_OFF);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to HSIZE_OFF...\n", val);
-	val = regr(SDOFST);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to SDOFST...\n", val);
-	val = regr(VP_OUT);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to VP_OUT...\n", val);
-	val = regr(SYN_MODE);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to SYN_MODE...\n", val);
-	val = regr(HORZ_INFO);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to HORZ_INFO...\n", val);
-	val = regr(VERT_START);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_START...\n", val);
-	val = regr(VERT_LINES);
-	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_LINES...\n", val);
-}
-
-/*                                                       
- * ======== ccdc_reset  ========                        
- */
-/*This function will reset all CCDc reg */
-
-void ccdc_reset()
-{
-	int i;
-	/* disable CCDC */
-	ccdc_enable(0);
-	/* set all registers to default value */
-	for (i = 0; i <= 0x94; i += 4) {
-		regw(0, i);
-	}
-	regw(0, PCR);
-	regw(0, SYN_MODE);
-	regw(0, HD_VD_WID);
-	regw(0, PIX_LINES);
-	regw(0, HORZ_INFO);
-	regw(0, VERT_START);
-	regw(0, VERT_LINES);
-	regw(0xffff00ff, CULLING);
-	regw(0, HSIZE_OFF);
-	regw(0, SDOFST);
-	regw(0, SDR_ADDR);
-	regw(0, VDINT);
-	regw(0, REC656IF);
-	regw(0, CCDCFG);
-	regw(0, FMTCFG);
-	regw(0, VP_OUT);
-}
-
-/*                                                       
- * ======== ccdc_setwin  ========                        
- */
-/*This function will configure the window size to be capture in CCDC reg */
-void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc)
-{
-	int horz_start, horz_nr_pixels;
-	int vert_start, vert_nr_lines;
-	int val = 0, mid_img = 0;
-	dev_dbg(vpfe_dev, "\nStarting ccdc_setwin...");
-	/* configure horizonal and vertical starts and sizes */
-	/* Here, (ppc-1) will be different for raw and yuv modes */
-	horz_start = image_win->left << (ppc - 1);
-	horz_nr_pixels = (image_win->width << (ppc - 1)) - 1;
-	regw((horz_start << CCDC_HORZ_INFO_SPH_SHIFT) | horz_nr_pixels,
-	     HORZ_INFO);
-
-	vert_start = image_win->top;
-
-	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
-		vert_nr_lines = (image_win->height >> 1) - 1;
-		vert_start >>= 1;
-		/* configure VDINT0 */
-		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT);
-		regw(val, VDINT);
-
-	} else {
-		vert_nr_lines = image_win->height - 1;
-		/* configure VDINT0 and VDINT1 */
-		/* VDINT1 will be at half of image height */
-		mid_img = vert_start + (image_win->height / 2);
-		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT) |
-		    (mid_img & CCDC_VDINT_VDINT1_MASK);
-		regw(val, VDINT);
-
-	}
-	regw((vert_start << CCDC_VERT_START_SLV0_SHIFT) | vert_start,
-	     VERT_START);
-	regw(vert_nr_lines, VERT_LINES);
-	dev_dbg(vpfe_dev, "\nEnd of ccdc_setwin...");
-}
-
-/*                                
- * ======== ccdc_config_ycbcr  ======== 
- */
-/*This function will configure CCDC for YCbCr parameters*/
-void ccdc_config_ycbcr(ccdc_params_ycbcr * params)
-{
-	u32 syn_mode;
-	unsigned int val;
-
-	/* first reset the CCDC                                          */
-	/* all registers have default values after reset                 */
-	/* This is important since we assume default values to be set in */
-	/* a lot of registers that we didn't touch                       */
-	dev_dbg(vpfe_dev, "\nStarting ccdc_config_ycbcr...");
-	ccdc_reset();
-
-	/* configure pixel format */
-	syn_mode = (params->pix_fmt & 0x3) << 12;
-
-	/* configure video frame format */
-	syn_mode |= (params->frm_fmt & 0x1) << 7;
-
-	/* setup BT.656 sync mode */
-	if (params->bt656_enable) {
-		regw(3, REC656IF);
-
-		/* configure the FID, VD, HD pin polarity */
-		/* fld,hd pol positive, vd negative, 8-bit pack mode */
-		syn_mode |= 0x00000F04;
-	} else {		/* y/c external sync mode */
-		syn_mode |= ((params->fid_pol & 0x1) << 4);
-		syn_mode |= ((params->hd_pol & 0x1) << 3);
-		syn_mode |= ((params->vd_pol & 0x1) << 2);
-	}
-
-	/* configure video window */
-	ccdc_setwin(&params->win, params->frm_fmt, 2);
-
-	/* configure the order of y cb cr in SD-RAM */
-	regw((params->pix_order << 11) | 0x8000, CCDCFG);
-
-	/* configure the horizontal line offset */
-	/* this is done by rounding up width to a multiple of 16 pixels */
-	/* and multiply by two to account for y:cb:cr 4:2:2 data */
-	regw(((params->win.width * 2) + 31) & 0xffffffe0, HSIZE_OFF);
-
-	/* configure the memory line offset */
-	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
-		/* two fields are interleaved in memory */
-		regw(0x00000249, SDOFST);
-	}
-	/* enable output to SDRAM */
-	syn_mode |= (0x1 << 17);
-	/* enable internal timing generator */
-	syn_mode |= (0x1 << 16);
-
-	syn_mode |= CCDC_DATA_PACK_ENABLE;
-	regw(syn_mode, SYN_MODE);
-
-	val = (unsigned int)ccdc_sbl_reset();
-	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
-
-	dev_dbg(vpfe_dev, "\nEnd of ccdc_config_ycbcr...\n");
-	ccdc_readregs();
-}
-
-/*                                                        
- * ======== ccdc_config_raw  ========                   
- */
-/*This function will configure CCDC for Raw mode parameters*/
-void ccdc_config_raw(ccdc_params_raw * params)
-{
-
-	unsigned int syn_mode = 0;
-	unsigned int val;
-	dev_dbg(vpfe_dev, "\nStarting ccdc_config_raw...");
-	/*      Reset CCDC */
-	ccdc_reset();
-	/* Disable latching function registers on VSYNC  */
-	regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG);
-
-	/*      Configure the vertical sync polarity(SYN_MODE.VDPOL) */
-	syn_mode = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
-
-	/*      Configure the horizontal sync polarity (SYN_MODE.HDPOL) */
-	syn_mode |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
-
-	/*      Configure frame id polarity (SYN_MODE.FLDPOL) */
-	syn_mode |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
-
-	/* Configure frame format(progressive or interlace) */
-	syn_mode |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
-
-	/* Configure the data size(SYNMODE.DATSIZ) */
-	syn_mode |= (params->data_sz & CCDC_DATA_SZ_MASK) << CCDC_DATA_SZ_SHIFT;
-
-	/* Configure pixel format (Input mode) */
-	syn_mode |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
-
-	/* Configure VP2SDR bit of syn_mode = 0 */
-	syn_mode &= CCDC_VP2SDR_DISABLE;
-
-	/* Enable write enable bit */
-	syn_mode |= CCDC_WEN_ENABLE;
-
-	/* Disable output to resizer */
-	syn_mode &= CCDC_SDR2RSZ_DISABLE;
-
-	/* enable internal timing generator */
-	syn_mode |= CCDC_VDHDEN_ENABLE;
-
-	/* Enable and configure aLaw register if needed */
-	if (params->alaw.b_alaw_enable) {
-		val = (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK);
-		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
-		regw(val, ALAW);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to ALAW...\n", val);
-	}
-
-	/* configure video window */
-	ccdc_setwin(&params->win, params->frm_fmt, PPC_RAW);
-
-	if (params->blk_clamp.b_clamp_enable) {
-		val = (params->blk_clamp.sgain) & CCDC_BLK_SGAIN_MASK;	/*gain */
-		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK)
-		    << CCDC_BLK_ST_PXL_SHIFT;	/*Start pixel */
-		val |= (params->blk_clamp.sample_ln & CCDC_BLK_SAMPLE_LINE_MASK)
-		    << CCDC_BLK_SAMPLE_LINE_SHIFT;	/*No of line to be avg */
-		val |=
-		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
-		    << CCDC_BLK_SAMPLE_LN_SHIFT;	/*No of pixel/line to be avg */
-		val |= CCDC_BLK_CLAMP_ENABLE;	/*Enable the Black clamping */
-		regw(val, CLAMP);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to CLAMP...\n", val);
-		regw(DCSUB_DEFAULT_VAL, DCSUB);	/*If Black clamping is enable 
-						   then make dcsub 0 */
-		dev_dbg(vpfe_dev, "\nWriting 0x00000000 to DCSUB...\n");
-
-	} else {
-		/* configure DCSub */
-		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
-		regw(val, DCSUB);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to DCSUB...\n", val);
-		regw(CLAMP_DEFAULT_VAL, CLAMP);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x0000 to CLAMP...\n");
-	}
-
-	/*      Configure Black level compensation */
-	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
-	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
-	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
-	val |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
-	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
-	val |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
-	    << CCDC_BLK_COMP_R_COMP_SHIFT;
-
-	regw(val, BLKCMP);
-
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP...\n", val);
-	dev_dbg(vpfe_dev, "\nbelow 	regw(val, BLKCMP)...");
-	/* Initially disable FPC */
-	val = CCDC_FPC_DISABLE;
-	regw(val, FPC);
-	/* Configure Fault pixel if needed */
-	if (params->fault_pxl.fpc_enable) {
-		regw(params->fault_pxl.fpc_table_addr, FPC_ADDR);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC_ADDR...\n",
-			(params->fault_pxl.fpc_table_addr));
-		/* Write the FPC params with FPC disable */
-		val = params->fault_pxl.fp_num & CCDC_FPC_FPC_NUM_MASK;
-		regw(val, FPC);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
-		/* read the FPC register */
-		val = regr(FPC);
-		val |= CCDC_FPC_ENABLE;
-		regw(val, FPC);
-
-		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
-	}
-	/* If data size is 8 bit then pack the data */
-	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
-		syn_mode |= CCDC_DATA_PACK_ENABLE;
-	}
-#if VIDEO_PORT_ENABLE
-	val = ENABLE_VIDEO_PORT;	/* enable video port */
-#else
-	val = DISABLE_VIDEO_PORT;	/* disable video port */
-#endif
-
-	if (params->data_sz == _8BITS)
-		val |= (_10BITS & CCDC_FMTCFG_VPIN_MASK)
-		    << CCDC_FMTCFG_VPIN_SHIFT;
-	else
-		val |= (params->data_sz & CCDC_FMTCFG_VPIN_MASK)
-		    << CCDC_FMTCFG_VPIN_SHIFT;
-
-	/* Write value in FMTCFG */
-	regw(val, FMTCFG);
-
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMTCFG...\n", val);
-
-	/* Configure the color pattern according to mt9t001 sensor */
-	regw(CCDC_COLPTN_VAL, COLPTN);
-
-	dev_dbg(vpfe_dev, "\nWriting 0xBB11BB11 to COLPTN...\n");
-	/* Configure Data formatter(Video port) pixel selection 
-	 * (FMT_HORZ, FMT_VERT) 
-	 */
-	val = 0;
-	val |= ((params->win.left) & CCDC_FMT_HORZ_FMTSPH_MASK)
-	    << CCDC_FMT_HORZ_FMTSPH_SHIFT;
-	val |= (((params->win.width)) & CCDC_FMT_HORZ_FMTLNH_MASK);
-	regw(val, FMT_HORZ);
-
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_HORZ...\n", val);
-	val = 0;
-	val |= (params->win.top & CCDC_FMT_VERT_FMTSLV_MASK)
-	    << CCDC_FMT_VERT_FMTSLV_SHIFT;
-	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
-		val |= (params->win.height) & CCDC_FMT_VERT_FMTLNV_MASK;
-	else
-		val |= (params->win.height >> 1) & CCDC_FMT_VERT_FMTLNV_MASK;
-
-	dev_dbg(vpfe_dev, "\nparams->win.height  0x%x ...\n",
-		params->win.height);
-	regw(val, FMT_VERT);
-
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_VERT...\n", val);
-
-	dev_dbg(vpfe_dev, "\nbelow regw(val, FMT_VERT)...");
-
-	/* Configure Horizontal offset register */
-	/* If pack 8 is enabled then 1 pixel will take 1 byte */
-	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
-		regw(((params->win.width) + CCDC_32BYTE_ALIGN_VAL)
-		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
-
-	} else {		/* else one pixel will take 2 byte */
-
-		regw(((params->win.width * TWO_BYTES_PER_PIXEL)
-		      + CCDC_32BYTE_ALIGN_VAL)
-		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
-
-	}
-
-	/* Set value for SDOFST */
-
-	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
-		if (params->image_invert_enable) {
-			/* For intelace inverse mode */
-			regw(INTERLACED_IMAGE_INVERT, SDOFST);
-			dev_dbg(vpfe_dev, "\nWriting 0x4B6D to SDOFST...\n");
-		}
-
-		else {
-			/* For intelace non inverse mode */
-			regw(INTERLACED_NO_IMAGE_INVERT, SDOFST);
-			dev_dbg(vpfe_dev, "\nWriting 0x0249 to SDOFST...\n");
-		}
-	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
-		regw(PROGRESSIVE_NO_IMAGE_INVERT, SDOFST);
-		dev_dbg(vpfe_dev, "\nWriting 0x0000 to SDOFST...\n");
-	}
-
-	/* Configure video port pixel selection (VPOUT) */
-	/* Here -1 is to make the height value less than FMT_VERT.FMTLNV */
-	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
-		val = (((params->win.height - 1) & CCDC_VP_OUT_VERT_NUM_MASK))
-		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
-	} else {
-		val =
-		    ((((params->win.
-			height >> CCDC_INTERLACED_HEIGHT_SHIFT) -
-		       1) & CCDC_VP_OUT_VERT_NUM_MASK))
-		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
-	}
-
-	val |= ((((params->win.width))) & CCDC_VP_OUT_HORZ_NUM_MASK)
-	    << CCDC_VP_OUT_HORZ_NUM_SHIFT;
-	val |= (params->win.left) & CCDC_VP_OUT_HORZ_ST_MASK;
-	regw(val, VP_OUT);
-
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to VP_OUT...\n", val);
-	regw(syn_mode, SYN_MODE);
-	dev_dbg(vpfe_dev, "\nWriting 0x%x to SYN_MODE...\n", syn_mode);
-
-	val = (unsigned int)ccdc_sbl_reset();
-	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
-
-	dev_dbg(vpfe_dev, "\nend of ccdc_config_raw...");
-	ccdc_readregs();
-}
Index: linux-2.6.10/drivers/media/video/davinci_aew.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/davinci_aew.c
+++ /dev/null
@@ -1,885 +0,0 @@
-/* *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_aew.c file */
-
-/* Kernel specific header files */
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>	/* printk */
-#include <linux/slab.h>		/* kmalloc() */
-#include <linux/fs.h>		/* File Structure fops... */
-#include <linux/errno.h>	/* error codes */
-#include <linux/types.h>	/* Types like size_t */
-#include <linux/cdev.h>
-#include <linux/interrupt.h>	/* For interrupt */
-#include <linux/dma-mapping.h>	/* For class_simple_create */
-#include <asm/uaccess.h>
-#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
-#include <linux/devfs_fs_kernel.h>	/* for devfs */
-#include <asm/semaphore.h>
-#include <linux/device.h>
-/* Driver Header Files */
-#include <asm/arch/davinci_aew.h>	/* Local Definitions */
-#include <asm/arch/davinci_aew_hw.h>	/* Local Definitions */
-
-/*Global structure*/
-struct aew_device *aew_dev_configptr;
-struct device *aewdev = NULL;
-/* device structure to make entry in device*/
-static dev_t dev;
-static struct class_simple *aew_class = NULL;
-
-/* For registeration of charatcer device*/
-static struct cdev c_dev;
-
-/* Module License*/
-MODULE_LICENSE("GPL");
-
-/* inline function to free reserver pages  */
-void inline aew_free_pages(unsigned long addr, unsigned long bufsize)
-{
-	unsigned long tempaddr;
-	unsigned long size;
-	tempaddr = addr;
-	if (!addr)
-		return;
-	size = PAGE_SIZE << (get_order(bufsize));
-	while (size > 0) {
-		ClearPageReserved(virt_to_page(addr));
-		addr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-	free_pages(tempaddr, get_order(bufsize));
-}
-
-/* Function to check Window Parmeters */
-int aew_check_window(void)
-{
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Check Window Horizontal Count */
-	if ((aew_dev_configptr->config->window_config.hz_cnt
-	     < AEW_WINDOW_HORIZONTAL_COUNT_MIN)
-	    || (aew_dev_configptr->config->window_config.hz_cnt
-		> AEW_WINDOW_HORIZONTAL_COUNT_MAX)) {
-		dev_err(aewdev, "Error :  Horizontal Count is incorrect\n");
-		return -AEW_ERR_HZ_COUNT;
-	}
-
-	/* Check Window Vertical Count */
-	if ((aew_dev_configptr->config->window_config.vt_cnt
-	     < AEW_WINDOW_VERTICAL_COUNT_MIN)
-	    || (aew_dev_configptr->config->window_config.vt_cnt
-		> AEW_WINDOW_VERTICAL_COUNT_MAX)) {
-		dev_err(aewdev, "Error :  Vertical Count is incorrect\n");
-		return -AEW_ERR_VT_COUNT;
-	}
-
-	/* Check Window Vertical Start */
-	if ((aew_dev_configptr->config->window_config.vt_start
-	     < AEW_WINDOW_START_MIN)
-	    || (aew_dev_configptr->config->window_config.vt_start
-		> AEW_WINDOW_START_MAX)) {
-		dev_err(aewdev, "Error : Vertical Start is incorrect\n");
-		return -AEW_ERR_VT_START;
-	}
-
-	/* Check Window Horizontal Start */
-	if ((aew_dev_configptr->config->window_config.hz_start
-	     < AEW_WINDOW_START_MIN)
-	    || (aew_dev_configptr->config->window_config.hz_start
-		> AEW_WINDOW_START_MAX)) {
-		dev_err(aewdev, "Error :  Horizontal Start is incorrect\n");
-		return -AEW_ERR_HZ_START;
-	}
-
-	/*Check Horizontal Line Increment */
-	if ((aew_dev_configptr->config->window_config.hz_line_incr
-	     < AEW_WINDOW_LINE_INCREMENT_MIN)
-	    || (aew_dev_configptr->config->window_config.hz_line_incr
-		> AEW_WINDOW_LINE_INCREMENT_MAX)) {
-		dev_err(aewdev,
-			"Error :  Horizontal Line Increment value is incorrect\n");
-		return -AEW_ERR_HZ_INCR;
-	}
-
-	/* Check Vertical Line Increment */
-	if ((aew_dev_configptr->config->window_config.vt_line_incr
-	     < AEW_WINDOW_LINE_INCREMENT_MIN)
-	    || (aew_dev_configptr->config->window_config.vt_line_incr
-		> AEW_WINDOW_LINE_INCREMENT_MAX)) {
-		dev_err(aewdev,
-			"Error :  Vertical Line Increment is  incorrect\n");
-		return -AEW_ERR_VT_INCR;
-	}
-
-	/* Check Window Height */
-	if ((aew_dev_configptr->config->window_config.height
-	     < AEW_WINDOW_HEIGHT_MIN)
-	    || (aew_dev_configptr->config->window_config.height
-		> AEW_WINDOW_HEIGHT_MAX)) {
-
-		dev_err(aewdev, "Error :  Height is incorrect\n");
-		return -AEW_ERR_HEIGHT;
-	}
-
-	/* Check Window Width */
-	if ((aew_dev_configptr->config->window_config.width
-	     < AEW_WINDOW_WIDTH_MIN)
-	    || (aew_dev_configptr->config->window_config.width
-		> AEW_WINDOW_WIDTH_MAX)) {
-		dev_err(aewdev, "Error :  Width is incorrect\n");
-		return -AEW_ERR_WIDTH;
-	}
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;		/*Success */
-}
-
-/* Function to check Black Window Parmeters */
-int aew_check_black_window(void)
-{
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Check Black Window Height */
-	if ((aew_dev_configptr->config->blackwindow_config.height
-	     < AEW_WINDOW_HEIGHT_MIN)
-	    || (aew_dev_configptr->config->blackwindow_config.height
-		> AEW_WINDOW_HEIGHT_MAX)) {
-		dev_err(aewdev, "Error :  Height is incorrect\n");
-		return -AEW_ERR_BLKWIN_HEIGHT;
-	}
-
-	/* Check Black Window Vertical Start */
-	if ((aew_dev_configptr->config->blackwindow_config.vt_start
-	     < AEW_WINDOW_START_MIN)
-	    || (aew_dev_configptr->config->blackwindow_config.vt_start
-		> AEW_WINDOW_START_MAX)) {
-		dev_err(aewdev, "Error :  Vertical Start is incorrect\n");
-		return -AEW_ERR_BLKWIN_VT_START;
-	}
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;		/*Success */
-}
-
-/* Function to perform hardware Configuration */
-int aew_hardware_setup(void)
-{
-	int result;
-	/*Size for buffer in bytes */
-	int buff_size = 0;
-	unsigned long adr;
-	unsigned long size;
-	unsigned int busyaew;
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Get the value of PCR register */
-	busyaew = AEW_GET_PCR;
-
-	/* Mask with BUSYAF bit */
-	busyaew = busyaew & AEW_BUSYAEWB;
-
-	/* Shift it 18 times to get value of 1 or 0 */
-	busyaew = busyaew >> AEW_BUSYAEWB_SHIFT;
-
-	/* If H3A Engine is busy then return */
-	if (busyaew == 1) {
-		dev_err(aewdev, "\n Error : AEW Engine is busy");
-		return -AEW_ERR_ENGINE_BUSY;
-	}
-
-	/*Check Window Parameters */
-	result = aew_check_window();
-	dev_dbg(aewdev, "Result =  %d\n", result);
-	if (result < 0) {
-		dev_err(aewdev, "Error : Window Parameter are incorrect \n");
-		return result;
-	}
-
-	/*Check Black Window Parameters */
-	result = aew_check_black_window();
-	if (result < 0) {
-		dev_err(aewdev,
-			"Error : Black Window Parameters are incorrect \n");
-		return result;
-	}
-
-	/*Check Saturuation limit */
-	if (aew_dev_configptr->config->saturation_limit > AEW_SAT_LIMIT_MAX) {
-		dev_err(aewdev, "Error : Saturation limit is incorrect\n");
-		return -AEW_ERR_LIMIT;
-	}
-
-	/* Deallocate the previously allocated buffers */
-	if (aew_dev_configptr->buff_old)
-		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
-			       aew_dev_configptr->size_window);
-
-	if (aew_dev_configptr->buff_curr)
-		aew_free_pages((unsigned long)aew_dev_configptr->
-			       buff_curr, aew_dev_configptr->size_window);
-
-	if (aew_dev_configptr->buff_app)
-		aew_free_pages((unsigned long)aew_dev_configptr->
-			       buff_app, aew_dev_configptr->size_window);
-
-	/*Allocat the buffers as per the new buffer size */
-	/*Allocate memory for old buffer */
-	buff_size = (aew_dev_configptr->config->window_config.hz_cnt + 1)
-	    * (aew_dev_configptr->config->window_config.vt_cnt +
-	       1) * AEW_WINDOW_SIZE;
-
-	aew_dev_configptr->buff_old =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	if (aew_dev_configptr->buff_old == NULL)
-		return -ENOMEM;
-
-	/*Make pges reserved so that they will be swapped out */
-	adr = (unsigned long)aew_dev_configptr->buff_old;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	/*Allocate memory for current buffer */
-	aew_dev_configptr->buff_curr =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	if (aew_dev_configptr->buff_curr == NULL) {
-
-		/*Free all  buffer that are allocated */
-		if (aew_dev_configptr->buff_old)
-			aew_free_pages((unsigned long)aew_dev_configptr->
-				       buff_old, buff_size);
-		return -ENOMEM;
-	}
-
-	/*Make pges reserved so that they will be swapped out */
-	adr = (unsigned long)aew_dev_configptr->buff_curr;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	/*Allocate memory for application buffer */
-	aew_dev_configptr->buff_app =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	if (aew_dev_configptr->buff_app == NULL) {
-		/*Free all  buffer that were allocated previously */
-		if (aew_dev_configptr->buff_old)
-			aew_free_pages((unsigned long)aew_dev_configptr->
-				       buff_old, buff_size);
-		if (aew_dev_configptr->buff_curr)
-			aew_free_pages((unsigned long)aew_dev_configptr->
-				       buff_curr, buff_size);
-		return -ENOMEM;
-	}
-
-	/*Make pges reserved so that they will be swapped out */
-	adr = (unsigned long)aew_dev_configptr->buff_app;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	/* Set the registers */
-	aew_set_register(aew_dev_configptr);
-	aew_dev_configptr->size_window = buff_size;
-	aew_dev_configptr->config->aew_config = H3A_AEW_ENABLE;
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;		/*Success */
-}
-
-/* This Function is called when driver is opened */
-static int aew_open(struct inode *inode, struct file *filp)
-{
-
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/*Return if Device is in use (Single Channel Support is provided) */
-	if (aew_dev_configptr->in_use == AEW_IN_USE)
-		return -EBUSY;
-
-	/* Set the aew_dev_configptr structure */
-	aew_dev_configptr->config = NULL;
-
-	/* Allocate memory for configuration  structure of this channel */
-	aew_dev_configptr->config = (struct aew_configuration *)
-	    kmalloc(sizeof(struct aew_configuration), GFP_KERNEL);
-
-	if (aew_dev_configptr->config == NULL) {
-		dev_err(aewdev, "Error : Kmalloc fail\n");
-		return -ENOMEM;
-	}
-
-	/* Initiaze the wait queue */
-	init_waitqueue_head(&(aew_dev_configptr->aew_wait_queue));
-
-	/*Device is in use */
-	aew_dev_configptr->in_use = AEW_IN_USE;
-
-	/* No Hardware Set up done */
-	aew_dev_configptr->config->aew_config = H3A_AEW_DISABLE;
-
-	/* No statistics are available */
-	aew_dev_configptr->buffer_filled = 0;
-
-	/* Set Window Size to 0 */
-	aew_dev_configptr->size_window = 0;
-
-	/* Initialize the semaphore */
-	init_MUTEX(&(aew_dev_configptr->read_blocked));
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;
-}
-static void aew_platform_release(struct device *device)
-{
-	/* This is called when the reference count goes to zero */
-}
-static int __init aew_probe(struct device *device)
-{
-	aewdev = device;
-	return 0;
-}
-
-static int aew_remove(struct device *device)
-{
-	return 0;
-}
-
-/* This Function is called when driver is closed */
-static int aew_release(struct inode *inode, struct file *filp)
-{
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* The Application has closed device so device is not in use */
-	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
-
-	/*Release memory for configuration structure of this channel */
-	if (aew_dev_configptr->config)
-		kfree(aew_dev_configptr->config);
-
-	/* Free Old Buffer */
-	if (aew_dev_configptr->buff_old)
-		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
-			       aew_dev_configptr->size_window);
-
-	/* Free Current Buffer */
-	if (aew_dev_configptr->buff_curr)
-		aew_free_pages((unsigned long)aew_dev_configptr->
-			       buff_curr, aew_dev_configptr->size_window);
-
-	/* Free Application Buffer */
-	if (aew_dev_configptr->buff_app)
-		aew_free_pages((unsigned long)aew_dev_configptr->buff_app,
-			       aew_dev_configptr->size_window);
-
-	aew_dev_configptr->buff_old = NULL;
-	aew_dev_configptr->buff_curr = NULL;
-	aew_dev_configptr->config = NULL;
-	aew_dev_configptr->buff_app = NULL;
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;
-}
-
-/* This function will process IOCTL commands sent by the application and
- * control the devices IO operations.
- */
-static int aew_ioctl(struct inode *inode, struct file *filep,
-		     unsigned int cmd, unsigned long arg)
-{
-	/* Stores Previous Configurations */
-	struct aew_configuration aewconfig = *(aew_dev_configptr->config);
-	int result = 0;
-
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Decrement the semaphore */
-	down_interruptible(&aew_dev_configptr->read_blocked);
-
-	/*Extract the type and number bitfields, and don't decode wrong cmds: */
-	/*verify the magic number */
-	if (_IOC_TYPE(cmd) != AEW_MAGIC_NO) {
-		up(&aew_dev_configptr->read_blocked);
-		return -ENOTTY;
-	}
-
-	/*verify the command number */
-	if (_IOC_NR(cmd) > AEW_IOC_MAXNR) {
-		/* Release semaphore  in case of fault */
-		up(&aew_dev_configptr->read_blocked);
-		return -ENOTTY;
-	}
-
-	/* check for the permission of the operation */
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		result =
-		    !access_ok(VERIFY_WRITE, (void __user *)arg,
-			       _IOC_SIZE(cmd));
-	else if (_IOC_DIR(cmd) & _IOC_WRITE)
-		result =
-		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-
-	if (result) {
-		/* Release semaphore in case of fault */
-		up(&aew_dev_configptr->read_blocked);
-		return -EFAULT;
-	}
-
-	/* Switch according to IOCTL command */
-	switch (cmd) {
-		/* This ioctl is used to perform hardware set up 
-		   and will set all the regiseters */
-		/*for AF engine */
-	case AEW_S_PARAM:
-
-		/*Copy config structure passed by user */
-		if (copy_from_user(aew_dev_configptr->config,
-				   (struct aew_configuration *)arg,
-				   sizeof(struct aew_configuration))) {
-			*(aew_dev_configptr->config) = aewconfig;
-			up(&aew_dev_configptr->read_blocked);
-			return -EFAULT;
-		}
-
-		/*Call aew_hardware_setup to perform register configuration */
-		result = aew_hardware_setup();
-		if (!result) {	/* Hardware Set up is successful */
-			/*Return the no of bytes required for buffer */
-			result = aew_dev_configptr->size_window;
-		} else {
-			/*Change Configuration Structure to original */
-			*(aew_dev_configptr->config) = aewconfig;
-			dev_err(aewdev, "Error : AEW_S_PARAM  failed\n");
-		}
-
-		break;
-
-		/* This ioctl is used to return parameters in user space */
-	case AEW_G_PARAM:
-		if (aew_dev_configptr->config->aew_config == H3A_AEW_ENABLE) {
-			if (copy_to_user
-			    ((struct aew_configuration *)arg,
-			     aew_dev_configptr->config,
-			     sizeof(struct aew_configuration))) {
-				up(&aew_dev_configptr->read_blocked);
-				return -EFAULT;
-			} else
-				result = aew_dev_configptr->size_window;
-		} else {
-			dev_err(aewdev,
-				"Error : AEW Hardware is not configured.\n");
-			result = -AEW_ERR_SETUP;
-		}
-		break;
-
-		/* This ioctl is used to enable AEW Engine */
-	case AEW_ENABLE:
-		/*Enable AEW Engine if Hardware set up is done */
-		if (aew_dev_configptr->config->aew_config == H3A_AEW_DISABLE) {
-			dev_err(aewdev,
-				"Error : AEW Hardware is not configured.\n");
-			result = -AEW_ERR_SETUP;
-		} else
-			/* Enable AF Engine */
-			aew_engine_setup(1);
-		break;
-
-		/* This ioctl is used to disable AEW Engine */
-	case AEW_DISABLE:
-		/* Disable AEW Engine */
-		aew_engine_setup(0);
-		break;
-
-		/* Invalid Command */
-	default:
-		dev_err(aewdev, "Error: It should not come here!!\n");
-		result = -ENOTTY;
-		break;
-	}
-
-	/*Release the semaphore */
-	up(&aew_dev_configptr->read_blocked);
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return result;
-}
-
-/* This function will return statistics to user */
-static ssize_t aew_read(struct file *filep, char *kbuff,
-			size_t size, loff_t * offset)
-{
-	void *buffer_temp;
-	int result = 0;
-	int ret;
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Semaphore will return immediately if read call is busy */
-	ret = down_trylock(&(aew_dev_configptr->read_blocked));
-	if (ret != 0) {
-		dev_dbg(aewdev, "Read Call : busy  : %d\n", ret);
-		return -EBUSY;
-	}
-
-	/* First Check the size given by user */
-	if (size < aew_dev_configptr->size_window) {
-		/* Return Failure to applicaiton */
-		/*if size is less than required size */
-		dev_dbg(aewdev, "Error : Invalid size of buffer\n");
-		up(&(aew_dev_configptr->read_blocked));
-		return -1;
-	}
-
-	/* The value of buffer_filled flag determines 
-	   the status of statistics */
-	if (aew_dev_configptr->buffer_filled == 0) {
-		/* Decrement the semaphore */
-		dev_dbg(aewdev, "READ CALL IS BLOCKED............\n");
-		/* Block the read call */
-		wait_event_interruptible_timeout(aew_dev_configptr->
-						 aew_wait_queue,
-						 aew_dev_configptr->
-						 buffer_filled, AEW_TIMEOUT);
-		dev_dbg(aewdev, "Read Call is unbloked and waking up.......\n");
-		dev_dbg(aewdev, "Buffer Filled.... %d\n",
-			aew_dev_configptr->buffer_filled);
-	}
-
-	if (aew_dev_configptr->buffer_filled == 1) {
-		/* Disable the interrupts and then swap the buffers */
-		disable_irq(IRQ_H3AINT);
-		dev_dbg(aewdev, "READING............\n");
-
-		/* New Statistics are availaible */
-		aew_dev_configptr->buffer_filled = 0;
-
-		/*Swap application buffer and old buffer */
-		buffer_temp = aew_dev_configptr->buff_old;
-		aew_dev_configptr->buff_old = aew_dev_configptr->buff_app;
-		aew_dev_configptr->buff_app = buffer_temp;
-
-		/* Interrupts are enabled */
-		enable_irq(IRQ_H3AINT);
-
-		/* Copy the entire statistics located in application 
-		   buffer to user space */
-		if (copy_to_user(kbuff, aew_dev_configptr->buff_app,
-				 aew_dev_configptr->size_window)) {
-			dev_err(aewdev, "Error : Read Fault\n");
-			up(&(aew_dev_configptr->read_blocked));
-			return -EFAULT;
-		} else
-			result = aew_dev_configptr->size_window;
-
-		dev_dbg(aewdev, "Reading Done........................\n");
-	}
-
-	dev_dbg(aewdev, "APP BUFF VALUE %x\n",
-		(*((unsigned int *)(aew_dev_configptr->buff_app))));
-
-	/*Increment the semaphore */
-	up(&(aew_dev_configptr->read_blocked));
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return result;
-}
-
-/* This function will handle interrupt generated by H3A Engine. */
-static irqreturn_t aew_isr(int irq, void *dev_id, struct pt_regs *regs)
-{
-	/* Busy AF Bit */
-	unsigned int busyaew;
-	/* Temporary Buffer for Swapping */
-	void *buffer_temp;
-
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Get the value of PCR register */
-	busyaew = AEW_GET_PCR;
-
-	/* If AEW engine is not enabled, interrupt is not for AEW */
-	if (((busyaew & 0x10000) >> 16) == 0) {
-		/*printk("busyaf\n"); */
-		return -1;
-	}
-
-	/*Interrupt is generated by AEW, so Service the Interrupt */
-	/*Swap current buffer and old buffer */
-	buffer_temp = aew_dev_configptr->buff_curr;
-	aew_dev_configptr->buff_curr = aew_dev_configptr->buff_old;
-	aew_dev_configptr->buff_old = buffer_temp;
-
-	/* Set the AEWBUFSTAT REgister to current buffer Address */
-	aew_set_address((unsigned
-			 long)(virt_to_phys(aew_dev_configptr->buff_curr)));
-
-	/*Set buffer filled flag to indicate statistics are available */
-	aew_dev_configptr->buffer_filled = 1;
-
-	/*new statistics are available */
-	/* Wake up the read call */
-	wake_up(&(aew_dev_configptr->aew_wait_queue));
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return IRQ_HANDLED;
-}
-
-/* file Operation Structure*/
-static struct file_operations aew_fops = {
-	.owner = THIS_MODULE,
-	.open = aew_open,
-	.read = aew_read,
-	.ioctl = aew_ioctl,
-	.release = aew_release,
-};
-static struct platform_device aewdevice = {
-	.name = "davinci_aew",
-	.id = 2,
-	.dev = {
-		.release = aew_platform_release,
-		}
-};
-
-static struct device_driver aew_driver = {
-	.name = "davinci_aew",
-	.bus = &platform_bus_type,
-	.probe = aew_probe,
-	.remove = aew_remove,
-};
-
-/* Function to register Character Device driver */
-int __init aew_init(void)
-{
-	int err;
-	int result;
-
-	/* Checking CCDC Registers */
-	/* Module cannot be inserted if data flow path for 
-	   h3a is not enabled */
-	result = AEW_GET_CCDC_FMTCFG;
-	/* Mask with VPEN Bit to check path */
-	result = result & AEW_VPEN_MASK;
-	result = result >> AEW_FMTCG_VPEN;
-	if (!(result)) {
-		printk
-		    ("\n Davici AEW Driver cannot be loaded\n VIDEO PORT is not enabled");
-		printk("Data Flow path from CCDC is disabled\n");
-		return -1;
-	}
-
-	/*Register the driver in the kernel. 
-	   Get major number dynamically */
-	result = alloc_chrdev_region(&dev, AEW_MAJOR_NUMBER,
-				     AEW_NR_DEVS, DEVICE_NAME);
-	if (result < 0) {
-		printk("Error : Could not register character device\n");
-		return -ENODEV;
-
-	}
-
-	/*allocate memory for device structure and initialize it with 0 */
-	aew_dev_configptr =
-	    (struct aew_device *)kmalloc(sizeof(struct aew_device), GFP_KERNEL);
-	if (!aew_dev_configptr) {
-		printk("Error : kmalloc fail\n");
-		unregister_chrdev_region(dev, AEW_NR_DEVS);
-		return -ENOMEM;
-	}
-
-	/* Initialize of character device */
-	cdev_init(&c_dev, &aew_fops);
-	c_dev.owner = THIS_MODULE;
-	c_dev.ops = &aew_fops;
-
-	/* Add character device */
-	err = cdev_add(&c_dev, dev, 1);
-	if (err) {
-		printk("Error : Adding DavinciAEW DeviceFailed\n");
-
-		unregister_chrdev_region(dev, AEW_NR_DEVS);
-
-		if (aew_dev_configptr)
-			kfree(aew_dev_configptr);
-
-		return -err;
-	}
-
-	/* Register the character device driver */
-	register_chrdev(MAJOR(dev), DEVICE_NAME, &aew_fops);
-	/* register driver as a platform driver */
-	if (driver_register(&aew_driver) != 0) {
-		unregister_chrdev_region(dev, 1);
-		cdev_del(&c_dev);
-		return -EINVAL;
-	}
-
-	/* Register the drive as a platform device */
-	if (platform_device_register(&aewdevice) != 0) {
-		driver_unregister(&aew_driver);
-		unregister_chrdev_region(dev, 1);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-		cdev_del(&c_dev);
-		return -EINVAL;
-	}
-	aew_class = class_simple_create(THIS_MODULE, "davinci_aew");
-
-	if (!aew_class) {
-
-		printk("aew_init: error in creating device class\n");
-
-		unregister_chrdev_region(dev, AEW_NR_DEVS);
-		platform_device_unregister(&aewdevice);
-
-		if (aew_dev_configptr)
-			kfree(aew_dev_configptr);
-
-		cdev_del(&c_dev);
-
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-
-		return -EIO;
-	}
-
-	/* Make entry in the devfs */
-	result = devfs_mk_cdev(dev, S_IFCHR | S_IRUGO | S_IWUSR,
-			       "%s%d", "davinci_aew", 0);
-
-	if (result < 0) {
-		printk("Error : Error in  devfs_register_chrdev\n");
-
-		unregister_chrdev_region(dev, AEW_NR_DEVS);
-
-		if (aew_dev_configptr)
-			kfree(aew_dev_configptr);
-
-		class_simple_destroy(aew_class);
-
-		cdev_del(&c_dev);
-
-		driver_unregister(&aew_driver);
-		platform_device_unregister(&aewdevice);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-
-		return result;
-	}
-
-	/*Register simple device class */
-	class_simple_device_add(aew_class, dev, NULL, "davinci_aew");
-
-	/* Set up the Interrupt handler for H3AINT interrupt */
-	result =
-	    request_irq(IRQ_H3AINT, aew_isr, SA_SHIRQ, "dm644xh3a_aew",
-			(void *)aew_dev_configptr);
-
-	if (result < 0) {
-		unregister_chrdev_region(dev, AEW_NR_DEVS);
-
-		if (aew_dev_configptr)
-			kfree(aew_dev_configptr);
-
-		class_simple_device_remove(dev);
-
-		devfs_remove("%s%d", "davinci_aew", 0);
-
-		class_simple_destroy(aew_class);
-
-		cdev_del(&c_dev);
-
-		driver_unregister(&aew_driver);
-		platform_device_unregister(&aewdevice);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-
-		printk("\n Error : Request IRQ Failed\n");
-		return result;
-	}
-
-	/* Initialize the device structure */
-	memset(aew_dev_configptr, 0, sizeof(struct aew_device));
-
-	/* Device is not in use */
-	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
-
-	/* No statistics available */
-	aew_dev_configptr->buffer_filled = 0;
-
-	return 0;		/*Sucess */
-}
-
-/*
-=====================aew_cleanup===========================
-*/
-/* This Function is called by the kernel while unloading the driver
-This will unregister the
- Character Device Driver
-*/
-void __exit aew_cleanup(void)
-{
-	/* Device is in use */
-	if (aew_dev_configptr->in_use == AEW_IN_USE) {
-		printk("Error : Driver in use");
-		return;
-	}
-
-	/*Free device structure */
-	if (aew_dev_configptr)
-		kfree(aew_dev_configptr);
-	aew_dev_configptr = NULL;
-	unregister_chrdev_region(dev, AEW_NR_DEVS);
-
-	/* remove simple class device */
-	class_simple_device_remove(dev);
-
-	/* remove aew device from devfs */
-	devfs_remove("%s%d", "davinci_aew", 0);
-
-	/* destroy simple class */
-	class_simple_destroy(aew_class);
-
-	driver_unregister(&aew_driver);
-	platform_device_unregister(&aewdevice);
-	/* Free the interrupt Handler */
-	free_irq(IRQ_H3AINT, aew_dev_configptr);
-	cdev_del(&c_dev);
-
-	/*unregistering the driver from the kernel */
-	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-}
-
-module_init(aew_init)
-    module_exit(aew_cleanup)
Index: linux-2.6.10/drivers/media/video/davinci_aew_hw.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/davinci_aew_hw.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/* *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_aew_hw.c file */
-
-/* include driver header files */
-#include <asm/arch/davinci_aew.h>
-#include <asm/arch/davinci_aew_hw.h>
-#include <linux/device.h>
-extern struct device *aewdev;
-/* Function to set hardware configuration registers */
-int aew_set_register(struct aew_device *aew_dev)
-{
-	unsigned int pcr = 0, win1 = 0, winstart = 0, blkwin = 0, subwin = 0;
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-
-	/* Set up the registers */
-	pcr = regr(AEWPCR);
-
-	/* Enable A Law */
-	if (aew_dev->config->alaw_enable == H3A_AEW_ENABLE) {
-		pcr |= AEW_ALAW_EN;
-	} else
-		pcr &= ~AEW_ALAW_EN;
-
-	/*Configure Saturation limit */
-	pcr &= ~AVE2LMT;
-	pcr |= aew_dev->config->saturation_limit << AEW_AVE2LMT_SHIFT;
-	regw(pcr, AEWPCR);
-
-	/*Window parameter configuration */
-
-	/* Configure Window Width in AEWWIN1 register */
-	win1 = 0;
-	win1 |= (aew_dev->config->window_config).height << AEW_WINH_SHIFT;
-
-	/* Configure Window height  in AEWWIN1 register */
-	win1 |= (aew_dev->config->window_config).width << AEW_WINW_SHIFT;
-
-	/* Configure Window vertical count  in AEWWIN2 register */
-	win1 |= (aew_dev->config->window_config).vt_cnt << AEW_VT_COUNT_SHIFT;
-
-	/* Configure Window horizontal count  in AEWWIN1 register */
-	win1 |= (aew_dev->config->window_config).hz_cnt;
-
-	/* Configure Window vertical start  in AEWWIN1 register */
-	regw(win1, AEWWIN1);
-
-	/*Window Start parameter configuration */
-
-	winstart &= ~WINSV;
-	winstart |=
-	    (aew_dev->config->window_config).vt_start << AEW_VT_START_SHIFT;
-
-	/* Configure Window horizontal start  in AEWWIN2 register */
-	winstart &= ~WINSH;
-	winstart |= (aew_dev->config->window_config).hz_start;
-	regw(winstart, AEWINSTART);
-
-	/*Window Line Increment configuration */
-	/*Configure vertical line increment in AEWSUBWIN */
-	subwin &= ~AEWINCV;
-	subwin |=
-	    (aew_dev->config->window_config).
-	    vt_line_incr << AEW_LINE_INCR_SHIFT;
-
-	/* Configuring Horizontal Line increment in AEWSUBWIN */
-	subwin &= ~AEWINCH;
-	subwin |= (aew_dev->config->window_config).hz_line_incr;
-
-	regw(subwin, AEWSUBWIN);
-
-	/* Black Window Configuration */
-	/* Configure vertical start and height in AEWWINBLK */
-	blkwin &= ~BLKWINSV;
-	blkwin |=
-	    (aew_dev->config->blackwindow_config).
-	    vt_start << AEW_BLKWIN_VT_START_SHIFT;
-
-	/* Configure height in Black window */
-	blkwin &= ~BLKWINH;
-	blkwin |= (aew_dev->config->blackwindow_config).height;
-	regw(blkwin, AEWINBLK);
-
-	/* Configure AEWBUFST Register to Current Buffer Address */
-	regw((unsigned int)(virt_to_phys(aew_dev->buff_curr)), AEWBUFST);
-
-	dev_dbg(aewdev, "\n PCR is %x", regr(AEWPCR));
-	dev_dbg(aewdev, "\n SUBWIN is %x", regr(AEWSUBWIN));
-	dev_dbg(aewdev, "\n WINSTART is %x", regr(AEWINSTART));
-	dev_dbg(aewdev, "\n WINBLK is %x", regr(AEWINBLK));
-	dev_dbg(aewdev, "\n WIN1  is %x", regr(AEWWIN1));
-	dev_dbg(aewdev, "\n AEWBUST %x", regr(AEWBUFST));
-
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-	return 0;
-}
-
-/* Function to enable/ disable AEW Engine */
-inline void aew_engine_setup(int value)
-{
-	unsigned int pcr;
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-	dev_dbg(aewdev, "\nAEW_REG(PCR) Before Setting %x", regr(AEWPCR));
-
-	/* Read Pcr Register */
-	pcr = regr(AEWPCR);
-	pcr &= ~AEW_EN;
-	pcr |= (value << AEW_EN_SHIFT);
-
-	/*Set AF_EN bit in PCR Register */
-	regw(pcr, AEWPCR);
-
-	dev_dbg(aewdev, "\nAfter Setting %d : PCR VALUE %x", value,
-		regr(AEWPCR));
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-
-}
-
-/* Function used to set adddress */
-inline void aew_set_address(unsigned long address)
-{
-	dev_dbg(aewdev, __FUNCTION__ "E\n");
-	regw(address, AEWBUFST);
-	dev_dbg(aewdev, __FUNCTION__ "L\n");
-}
Index: linux-2.6.10/drivers/media/video/davinci_af.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/davinci_af.c
+++ /dev/null
@@ -1,838 +0,0 @@
-/* *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_af.c file */
-
-/* Linux specific include files */
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>	/* printk  */
-#include <linux/slab.h>		/* kmalloc() */
-#include <linux/fs.h>		/* File Structure... */
-#include <linux/errno.h>	/* error codes */
-#include <linux/types.h>	/* size_t */
-#include <linux/cdev.h>
-#include <linux/interrupt.h>	/* For interrupt */
-#include <linux/dma-mapping.h>	/* For class_simple_create */
-#include <asm/uaccess.h>
-#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
-#include <linux/devfs_fs_kernel.h>	/* for devfs */
-#include <asm/semaphore.h>	/* Semaphore */
-#include <linux/device.h>
-/* Driver include files */
-#include <asm/arch/davinci_af.h>	/*Local Definitions */
-#include <asm/arch/davinci_af_hw.h>	/* Local Definitions */
-
-/* Module License */
-MODULE_LICENSE("GPL");
-
-/*Global structure for device */
-struct af_device *af_dev_configptr;
-static struct class_simple *af_class = NULL;
-
-/* For registeration of charatcer device */
-static struct cdev c_dev;
-
-/* device structure to make entry in device */
-static dev_t dev;
-struct device *afdev = NULL;
-/* inline function to free reserver pages  */
-void inline af_free_pages(unsigned long addr, unsigned long bufsize)
-{
-	unsigned long tempaddr;
-	unsigned long size;
-	tempaddr = addr;
-	if (!addr)
-		return;
-	size = PAGE_SIZE << (get_order(bufsize));
-	while (size > 0) {
-		ClearPageReserved(virt_to_page(addr));
-		addr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-	free_pages(tempaddr, get_order(bufsize));
-}
-
-/* Function to check paxel parameters */
-int af_check_paxel(void)
-{
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Check horizontal Count */
-	if ((af_dev_configptr->config->paxel_config.hz_cnt
-	     < AF_PAXEL_HORIZONTAL_COUNT_MIN)
-	    || (af_dev_configptr->config->paxel_config.hz_cnt
-		> AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
-		dev_err(afdev, "Error : Horizontal Count is incorrect");
-		return -AF_ERR_HZ_COUNT;
-	}
-
-	/*Check Vertical Count */
-	if ((af_dev_configptr->config->paxel_config.vt_cnt
-	     < AF_PAXEL_VERTICAL_COUNT_MIN)
-	    || (af_dev_configptr->config->paxel_config.vt_cnt
-		> AF_PAXEL_VERTICAL_COUNT_MAX)) {
-		dev_err(afdev, "Error : Vertical Count is incorrect");
-		return -AF_ERR_VT_COUNT;
-	}
-
-	/*Check Height */
-	if ((af_dev_configptr->config->paxel_config.height
-	     < AF_PAXEL_HEIGHT_MIN)
-	    || (af_dev_configptr->config->paxel_config.height
-		> AF_PAXEL_HEIGHT_MAX)) {
-		dev_err(afdev, "Error : Height is incorrect");
-		return -AF_ERR_HEIGHT;
-	}
-
-	/*Check width */
-	if ((af_dev_configptr->config->paxel_config.width < AF_PAXEL_WIDTH_MIN)
-	    || (af_dev_configptr->config->paxel_config.width
-		> AF_PAXEL_WIDTH_MAX)) {
-		dev_err(afdev, "Error : Width is incorrect");
-		return -AF_ERR_WIDTH;
-	}
-
-	/*Check Line Increment */
-	if ((af_dev_configptr->config->paxel_config.line_incr
-	     < AF_PAXEL_INCREMENT_MIN)
-	    || (af_dev_configptr->config->paxel_config.line_incr
-		> AF_PAXEL_INCREMENT_MAX)) {
-		dev_err(afdev, "Error : Line Increment is incorrect");
-		return -AF_ERR_INCR;
-	}
-
-	/*Check Horizontal Start */
-	if ((af_dev_configptr->config->paxel_config.hz_start % 2 != 0)
-	    || (af_dev_configptr->config->paxel_config.hz_start
-		< (af_dev_configptr->config->iir_config.hz_start_pos + 2))
-	    || (af_dev_configptr->config->paxel_config.hz_start
-		> AF_PAXEL_HZSTART_MAX)
-	    || (af_dev_configptr->config->paxel_config.hz_start
-		< AF_PAXEL_HZSTART_MIN)) {
-		dev_err(afdev, "Error : Horizontal Start is incorrect");
-		return -AF_ERR_HZ_START;
-	}
-
-	/*Check Vertical Start */
-	if ((af_dev_configptr->config->paxel_config.vt_start
-	     < AF_PAXEL_VTSTART_MIN)
-	    || (af_dev_configptr->config->paxel_config.vt_start
-		> AF_PAXEL_VTSTART_MAX)) {
-		dev_err(afdev, "Error : Vertical Start is incorrect");
-		return -AF_ERR_VT_START;
-	}
-
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-
-	return 0;		/*Success */
-}
-
-/* Function to check IIR Coefficient */
-int af_check_iir(void)
-{
-	int index;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Check for valid values of IIR coefficients */
-	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
-		/*Check Coefficient of set 0 */
-		if ((af_dev_configptr->config->iir_config.coeff_set0[index])
-		    > AF_COEF_MAX) {
-			dev_err(afdev,
-				"Error : Coefficient for set 0 is incorrect");
-			return -AF_ERR_IIR_COEF;
-		}
-
-		/*Check coefficient of set 1 */
-		if ((af_dev_configptr->config->iir_config.coeff_set1[index])
-		    > AF_COEF_MAX) {
-			dev_err(afdev,
-				"Error : Coefficient for set 1 is incorrect");
-			return -AF_ERR_IIR_COEF;
-		}
-	}
-
-	/* Check IIRSH Value */
-	if ((af_dev_configptr->config->iir_config.hz_start_pos < AF_IIRSH_MIN)
-	    || (af_dev_configptr->config->iir_config.hz_start_pos >
-		AF_IIRSH_MAX)) {
-		dev_err(afdev, "Error : IIRSH is incorrect");
-		return -AF_ERR_IIRSH;
-	}
-
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return 0;		/*Success */
-}
-
-/* Function to perform hardware set up */
-int af_hardware_setup(void)
-{
-	int result;
-
-	/*Size for buffer in bytes */
-	int buff_size;
-	unsigned long adr, size;
-	unsigned int busyaf;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Get the value of PCR register */
-	busyaf = AF_GET_PCR;
-
-	/* Mask with BUSYAF bit */
-	busyaf = busyaf & AF_BUSYAF;
-
-	/* Shift it 15 times to get value of 1 or 0 */
-	busyaf = busyaf >> 15;
-
-	/*If busy bit is 1 then busy lock registers caanot be configured */
-	if (busyaf == 1) {
-		/* Hardware cannot be configure while engine is busy */
-		dev_err(afdev, "AF_register_setup_ERROR : Engine Bus");
-		dev_err(afdev, "\n Configuration cannot be done ");
-		return -AF_ERR_ENGINE_BUSY;
-	}
-
-	/*Check IIR Coefficient and start Values */
-	result = af_check_iir();
-	if (result < 0)
-		return result;
-
-	/*Check Paxel Values */
-	result = af_check_paxel();
-	if (result < 0)
-		return result;
-
-	/*Check HMF Threshold Values */
-	if (af_dev_configptr->config->hmf_config.threshold > AF_THRESHOLD_MAX) {
-		dev_err(afdev, "Error : HMF Threshold is incorrect");
-		return -AF_ERR_THRESHOLD;
-	}
-
-	/* Compute buffer size */
-	buff_size =
-	    (af_dev_configptr->config->paxel_config.hz_cnt + 1) *
-	    (af_dev_configptr->config->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
-
-	/*Deallocate the previosu buffers */
-	/* free old buffers */
-	if (af_dev_configptr->buff_old)
-		af_free_pages((unsigned long)af_dev_configptr->buff_old,
-			      af_dev_configptr->size_paxel);
-
-	/* Free current buffer */
-	if (af_dev_configptr->buff_curr)
-		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
-			      af_dev_configptr->size_paxel);
-
-	/* Free application buffers */
-	if (af_dev_configptr->buff_app)
-		af_free_pages((unsigned long)af_dev_configptr->buff_app,
-			      af_dev_configptr->size_paxel);
-
-	/* Reallocate the buffer as per new paxel configurations */
-	/*Allocate memory for old buffer */
-	af_dev_configptr->buff_old =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	if (af_dev_configptr->buff_old == NULL)
-		return -ENOMEM;
-
-	/* allocate the memory for storing old statistics */
-	adr = (unsigned long)af_dev_configptr->buff_old;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	/*Allocate memory for current buffer */
-	af_dev_configptr->buff_curr =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	/* Free the previously allocated buffer */
-	if (af_dev_configptr->buff_curr == NULL) {
-		if (af_dev_configptr->buff_old)
-			af_free_pages((unsigned long)af_dev_configptr->
-				      buff_old, buff_size);
-		return -ENOMEM;
-	}
-
-	adr = (unsigned long)af_dev_configptr->buff_curr;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	/*Allocate memory for old buffer */
-	af_dev_configptr->buff_app =
-	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-				     get_order(buff_size));
-
-	if (af_dev_configptr->buff_app == NULL) {
-
-		/*Free the previously allocated buffer */
-		if (af_dev_configptr->buff_curr)
-			af_free_pages((unsigned long)af_dev_configptr->
-				      buff_curr, buff_size);
-		/*Free the previously allocated buffer */
-		if (af_dev_configptr->buff_old)
-			af_free_pages((unsigned long)af_dev_configptr->
-				      buff_old, buff_size);
-		return -ENOMEM;
-	}
-
-	adr = (unsigned long)af_dev_configptr->buff_app;
-	size = PAGE_SIZE << (get_order(buff_size));
-	while (size > 0) {
-		/* make sure the frame buffers
-		   are never swapped out of memory */
-		SetPageReserved(virt_to_page(adr));
-		adr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-
-	result = af_register_setup(af_dev_configptr);
-	if (result < 0)
-		return result;
-	af_dev_configptr->size_paxel = buff_size;
-
-	/*Set configuration flag to indicate HW setup done */
-	af_dev_configptr->config->af_config = H3A_AF_ENABLE;
-
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	/*Success */
-	return 0;
-}
-
-/* This function called when driver is opened.It creates Channel
- * Configuration Structure
- */
-static int af_open(struct inode *inode, struct file *filp)
-{
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/*Return if device is in use */
-	if (af_dev_configptr->in_use == AF_IN_USE)
-		return -EBUSY;
-	af_dev_configptr->config = NULL;
-
-	/* Allocate memory for Device Structure */
-	af_dev_configptr->config = (struct af_configuration *)
-	    kmalloc(sizeof(struct af_configuration)
-		    , GFP_KERNEL);
-	if (af_dev_configptr->config == NULL) {
-		dev_err(afdev, "Error : Kmalloc fail\n");
-		return -ENOMEM;
-	}
-
-	/* Initialize the wait queue */
-	init_waitqueue_head(&(af_dev_configptr->af_wait_queue));
-
-	/* Driver is in use */
-	af_dev_configptr->in_use = AF_IN_USE;
-
-	/* Hardware is not set up */
-	af_dev_configptr->config->af_config = H3A_AF_DISABLE;
-	af_dev_configptr->buffer_filled = 0;
-
-	/* Initialize the semaphore */
-	init_MUTEX(&(af_dev_configptr->read_blocked));
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return 0;
-}
-
-/* This function called when driver is closed.
- * It will deallocate all the buffers.
- */
-static int af_release(struct inode *inode, struct file *filp)
-{
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Free all the buffers */
-	/* free current buffer */
-	if (af_dev_configptr->buff_curr)
-		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
-			      af_dev_configptr->size_paxel);
-
-	/*Free old buffer */
-	if (af_dev_configptr->buff_old)
-		af_free_pages((unsigned long)af_dev_configptr->buff_old,
-			      af_dev_configptr->size_paxel);
-
-	/* Free application buffer */
-	if (af_dev_configptr->buff_app)
-		af_free_pages((unsigned long)af_dev_configptr->buff_app,
-			      af_dev_configptr->size_paxel);
-
-	/*Release memory for configuration structure of this channel */
-	af_dev_configptr->buff_curr = NULL;
-	af_dev_configptr->buff_old = NULL;
-	af_dev_configptr->buff_app = NULL;
-	if (af_dev_configptr->config)
-		kfree(af_dev_configptr->config);
-	af_dev_configptr->config = NULL;
-
-	/*Device is not in use */
-	af_dev_configptr->in_use = AF_NOT_IN_USE;
-
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-
-	return 0;
-}
-static void af_platform_release(struct device *device)
-{
-	/* This is called when the reference count goes to zero */
-}
-static int __init af_probe(struct device *device)
-{
-	afdev = device;
-	return 0;
-}
-
-static int af_remove(struct device *device)
-{
-	return 0;
-}
-
-/* This function will process IOCTL commands sent by the application and
- * control the device IO operations.
- */
-static int af_ioctl(struct inode *inode, struct file *filep,
-		    unsigned int cmd, unsigned long arg)
-{
-	struct af_configuration afconfig = *(af_dev_configptr->config);
-	int result = 0;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Block the semaphore while ioctl is called */
-	down_interruptible(&af_dev_configptr->read_blocked);
-
-	/*Extract the type and number bitfields, and don't */
-	/* decode wrong cmds */
-	/*return ENOTTY (inappropriate ioctl) */
-	if (_IOC_TYPE(cmd) != AF_MAGIC_NO) {
-		/* Release the semaphore */
-		up(&af_dev_configptr->read_blocked);
-		return -ENOTTY;
-	}
-
-	if (_IOC_NR(cmd) > AF_IOC_MAXNR) {
-		/* Release the semaphore */
-		up(&af_dev_configptr->read_blocked);
-		return -ENOTTY;
-	}
-
-	/*Use 'access_ok' to validate user space pointer */
-	if (_IOC_DIR(cmd) & _IOC_READ)
-		result =
-		    !access_ok(VERIFY_WRITE, (void __user *)arg,
-			       _IOC_SIZE(cmd));
-	else if (_IOC_DIR(cmd) & _IOC_WRITE)
-		result =
-		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-
-	if (result) {
-		/* Release the semaphore */
-		up(&af_dev_configptr->read_blocked);
-		return -EFAULT;
-	}
-
-	switch (cmd) {
-
-		/* This ioctl is used to perform hardware */
-		/* set up for AF Engine */
-		/* It will configura all the registers. */
-	case AF_S_PARAM:
-		/*Copy params structure passed by user */
-		if (copy_from_user(af_dev_configptr->config,
-				   (struct af_configuration *)arg,
-				   sizeof(struct af_configuration))) {
-			/* Release the semaphore */
-			up(&af_dev_configptr->read_blocked);
-			return -EFAULT;
-		}
-
-		/*Call AF_hardware_setup to perform register configuration */
-		result = af_hardware_setup();
-		if (!result) {
-			result = af_dev_configptr->size_paxel;
-		} else {
-			dev_err(afdev, "Error : AF_S_PARAM failed");
-			*(af_dev_configptr->config) = afconfig;
-		}
-		break;
-
-		/* This ioctl will get the paramters from application */
-	case AF_G_PARAM:
-		/*Check if Hardware is configured or not */
-		if (af_dev_configptr->config->af_config == H3A_AF_ENABLE) {
-			if (copy_to_user((struct af_configuration *)arg,
-					 af_dev_configptr->config,
-					 sizeof(struct af_configuration))) {
-				up(&af_dev_configptr->read_blocked);
-				return -EFAULT;
-			} else
-				result = af_dev_configptr->size_paxel;
-
-		} else {
-			dev_dbg(afdev, "Error : AF Hardware not configured.");
-			result = -AF_ERR_SETUP;
-		}
-
-		break;
-
-		/* This ioctl will enable AF Engine */
-		/*if hardware configuration is done */
-	case AF_ENABLE:
-		/* Check if hardware is configured or not */
-		if (af_dev_configptr->config->af_config == H3A_AF_DISABLE) {
-			dev_err(afdev, "Error :  AF Hardware not configured.");
-			result = -AF_ERR_SETUP;
-		} else
-			af_engine_setup(1);
-		break;
-
-		/* This ioctl will disable AF Engine */
-	case AF_DISABLE:
-		af_engine_setup(0);
-		break;
-
-	default:
-		dev_err(afdev, "Error : Invalid IOCTL!");
-		result = -ENOTTY;
-		break;
-	}
-
-	/* Before returning increment semaphore */
-	up(&af_dev_configptr->read_blocked);
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return result;
-}
-
-/* Function will return the statistics to user */
-ssize_t af_read(struct file * filep, char *kbuff, size_t size, loff_t * offset)
-{
-	void *buff_temp;
-	int result = 0;
-	int ret;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Semaphore will return immediately if read call is busy */
-	ret = down_trylock(&(af_dev_configptr->read_blocked));
-	if (ret != 0) {
-		dev_err(afdev, "\n Read Call : busy");
-		return -EBUSY;
-	}
-
-	/*If no of bytes specified by the user is less */
-	/* than that of buffer return error */
-	if (size < af_dev_configptr->size_paxel) {
-		dev_err(afdev, "\n Error : Invalid buffer size");
-		up(&(af_dev_configptr->read_blocked));
-		return -1;	/* Return error to application */
-	}
-
-	/* The value of bufffer_filled flag determines
-	   the status of statistics */
-	if (af_dev_configptr->buffer_filled == 0) {
-		dev_dbg(afdev, "Read call is blocked .......................");
-		/* Block the read call until new statistics are available */
-		/* or timer expires */
-		/* Decrement the semaphore count */
-		wait_event_interruptible_timeout(af_dev_configptr->
-						 af_wait_queue,
-						 af_dev_configptr->
-						 buffer_filled, AF_TIMEOUT);
-		dev_dbg(afdev,
-			"\n Read Call Unblocked..........................");
-	}
-	if (af_dev_configptr->buffer_filled == 1) {
-		/* New Statistics are available */
-		/* Disable the interrupts while swapping the buffers */
-		disable_irq(IRQ_H3AINT);
-		dev_dbg(afdev, "\n Reading.............................");
-
-		af_dev_configptr->buffer_filled = 0;
-
-		/*Swap application buffer and old buffer */
-		buff_temp = af_dev_configptr->buff_old;
-		af_dev_configptr->buff_old = af_dev_configptr->buff_app;
-		af_dev_configptr->buff_app = buff_temp;
-
-		dev_dbg(afdev, "\n Reading Done.............................");
-
-		/* Enable the interrupts  once swapping is done */
-		enable_irq(IRQ_H3AINT);
-
-		/* New Statistics are not availaible */
-		/* copy the application buffer to user */
-		/* Return the entire statistics to user */
-		if (copy_to_user(kbuff, af_dev_configptr->buff_app,
-				 af_dev_configptr->size_paxel)) {
-			/* Release the semaphore in case of fault */
-			up(&(af_dev_configptr->read_blocked));
-			return -EFAULT;
-		} else
-			result = af_dev_configptr->size_paxel;
-	}
-
-	/* Release the seamphore */
-	up(&(af_dev_configptr->read_blocked));
-	dev_dbg(afdev, "\n Read APPLICATION  BUFFER %d",
-		*((int *)((af_dev_configptr->buff_app))));
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return result;
-}
-
-/* This function will handle the H3A interrupt. */
-static irqreturn_t af_isr(int irq, void *dev_id, struct pt_regs *regs)
-{
-	void *buff_temp;	/*Temporary buffer for swapping */
-	int busyaf;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Get the value of PCR register */
-	busyaf = AF_GET_PCR;
-
-	/* If AF Engine has enabled, interrupt is not for AF */
-	if ((busyaf & 0x01) == 0) {
-		return -1;
-	}
-
-	/*Service  the Interrupt */
-	/*Set buffer filled flag to indicate statistics are available */
-	/*Swap current buffer and old buffer */
-	buff_temp = af_dev_configptr->buff_curr;
-	af_dev_configptr->buff_curr = af_dev_configptr->buff_old;
-	af_dev_configptr->buff_old = buff_temp;
-
-	/* Set AF Buf st to current register address */
-	if (af_dev_configptr->buff_curr)
-		af_set_address((unsigned long)
-			       virt_to_phys(af_dev_configptr->buff_curr));
-
-	/* Wake up read as new statistics are available */
-	af_dev_configptr->buffer_filled = 1;
-	wake_up(&(af_dev_configptr->af_wait_queue));
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return IRQ_HANDLED;
-}
-
-/* File Operation Structure */
-static struct file_operations af_fops = {
-	.owner = THIS_MODULE,
-	.open = af_open,
-	.ioctl = af_ioctl,
-	.read = af_read,
-	.release = af_release
-};
-static struct platform_device afdevice = {
-	.name = "davinci_af",
-	.id = 2,
-	.dev = {
-		.release = af_platform_release,
-		}
-};
-
-static struct device_driver af_driver = {
-	.name = "davinci_af",
-	.bus = &platform_bus_type,
-	.probe = af_probe,
-	.remove = af_remove,
-};
-
-/* Function to register the AF character device driver. */
-int __init af_init(void)
-{
-	int err;
-	int result = 0;
-	result = AF_GET_CCDC_FMTCFG;
-	result = result & AF_VPEN_MASK;
-	result = result >> AF_FMTCG_VPEN;
-	/* H3A Module cannot be inserted if CCDC
-	   path for H3A is not registered */
-	if (!(result)) {
-		/* Module cannot be inserted if CCDC is not configured */
-		printk("\n Davinci AF driver cannot be loaded");
-		printk("\n VIDEO PORT is not enabled ");
-		printk("\n CCDC needs to be configured");
-		return -1;
-	}
-	/*Register the driver in the kernel. Get major number dynamically */
-	result = alloc_chrdev_region(&dev, AF_MAJOR_NUMBER,
-				     AF_NR_DEVS, DEVICE_NAME);
-	if (result < 0) {
-		printk("Error :  Could not register character device");
-		return -ENODEV;
-	}
-
-	/*allocate memory for device structure and initialize it with 0 */
-	af_dev_configptr =
-	    (struct af_device *)kmalloc(sizeof(struct af_device), GFP_KERNEL);
-	if (!af_dev_configptr) {
-		printk("Error : kmalloc fail");
-		unregister_chrdev_region(dev, AF_NR_DEVS);
-		return -ENOMEM;
-
-	}
-
-	/* Initialize  character device */
-	cdev_init(&c_dev, &af_fops);
-	c_dev.owner = THIS_MODULE;
-	c_dev.ops = &af_fops;
-	err = cdev_add(&c_dev, dev, 1);
-	if (err) {
-		printk("Error : Error in  Adding Davinci AF");
-		unregister_chrdev_region(dev, AF_NR_DEVS);
-		if (af_dev_configptr)
-			kfree(af_dev_configptr);
-		return -err;
-	}
-
-	/* Registe Character device */
-	register_chrdev(MAJOR(dev), DEVICE_NAME, &af_fops);
-	/* register driver as a platform driver */
-	if (driver_register(&af_driver) != 0) {
-		unregister_chrdev_region(dev, 1);
-		cdev_del(&c_dev);
-		return -EINVAL;
-	}
-
-	/* Register the drive as a platform device */
-	if (platform_device_register(&afdevice) != 0) {
-		driver_unregister(&af_driver);
-		unregister_chrdev_region(dev, 1);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-		cdev_del(&c_dev);
-		return -EINVAL;
-	}
-	af_class = class_simple_create(THIS_MODULE, "davinci_af");
-
-	if (!af_class) {
-		platform_device_unregister(&afdevice);
-		printk("Error : Error in creating device class");
-		unregister_chrdev_region(dev, AF_NR_DEVS);
-		if (af_dev_configptr)
-			kfree(af_dev_configptr);
-		class_simple_device_remove(dev);
-		class_simple_destroy(af_class);
-		cdev_del(&c_dev);
-		return -EIO;
-	}
-
-	/* make entry in the devfs */
-	result =
-	    devfs_mk_cdev(dev, S_IFCHR | S_IRUGO | S_IWUSR, "%s%d",
-			  "davinci_af", 0);
-
-	if (result < 0) {
-		printk("Error : Error in devfs_register_chrdev");
-		unregister_chrdev_region(dev, AF_NR_DEVS);
-		if (af_dev_configptr)
-			kfree(af_dev_configptr);
-		class_simple_device_remove(dev);
-		cdev_del(&c_dev);
-		driver_unregister(&af_driver);
-		platform_device_unregister(&afdevice);
-		class_simple_destroy(af_class);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-		return result;
-	}
-
-	/* register simple device class */
-	class_simple_device_add(af_class, dev, NULL, "davinci_af");
-
-	/* Set up the Interrupt handler for H3AINT interrupt */
-	result =
-	    request_irq(IRQ_H3AINT, af_isr, SA_SHIRQ, "dm644xh3a_af",
-			(void *)af_dev_configptr);
-
-	if (result != 0) {
-		printk("Error : Request IRQ Failed");
-		unregister_chrdev_region(dev, AF_NR_DEVS);
-		if (af_dev_configptr)
-			kfree(af_dev_configptr);
-		class_simple_device_remove(dev);
-		devfs_remove("%s%d", "davinci_af", 0);
-		driver_unregister(&af_driver);
-		platform_device_unregister(&afdevice);
-		class_simple_destroy(af_class);
-		cdev_del(&c_dev);
-		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-		return result;
-	}
-
-	/* Initialize device structure */
-	memset(af_dev_configptr, 0, sizeof(struct af_device));
-
-	af_dev_configptr->in_use = AF_NOT_IN_USE;
-	af_dev_configptr->buffer_filled = 0;
-
-	return 0;		/*Sucess */
-}
-
-/* This function is called by the kernel while unloading the driver.
- * It will unregister character device driver
- */
-void __exit af_cleanup(void)
-{
-
-	/* Return if driver is busy */
-	if (af_dev_configptr->in_use == AF_IN_USE) {
-		printk("Error : Driver in use. Can't remove.");
-		return;
-	}
-
-	/*Free device structure */
-	if (af_dev_configptr)
-		kfree(af_dev_configptr);
-
-	unregister_chrdev_region(dev, AF_NR_DEVS);
-
-	/* remove simple class device */
-	class_simple_device_remove(dev);
-
-	/* remove prev device from devfs */
-	devfs_remove("%s%d", "davinci_af", 0);
-
-	/* destroy simple class */
-	class_simple_destroy(af_class);
-
-	driver_unregister(&af_driver);
-	platform_device_unregister(&afdevice);
-	/*unregistering the driver from the kernel */
-	cdev_del(&c_dev);
-	/*Free interrupt line */
-	free_irq(IRQ_H3AINT, af_dev_configptr);
-	/* Unregiser Character device */
-	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
-}
-
-module_init(af_init)
-    module_exit(af_cleanup)
-    MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci_af_hw.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/davinci_af_hw.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/* *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* Include driver header file */
-#include <asm/arch/davinci_af_hw.h>
-#include <linux/device.h>
-extern struct device *afdev;
-/* Function to set register */
-int af_register_setup(struct af_device *af_dev)
-{
-	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
-	unsigned int coef = 0;
-	unsigned int base_coef_set0 = 0;
-	unsigned int base_coef_set1 = 0;
-	int index;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	/* Configure Hardware Registers */
-	/* Set PCR Register */
-	pcr = regr(AFPCR);	/* Read PCR Register */
-
-	/*Set Accumulator Mode */
-	if (af_dev->config->mode == ACCUMULATOR_PEAK)
-		pcr |= FVMODE;
-	else
-		pcr &= ~FVMODE;
-
-	/*Set A-law */
-	if (af_dev->config->alaw_enable == H3A_AF_ENABLE)
-		pcr |= AF_ALAW_EN;
-	else
-		pcr &= ~AF_ALAW_EN;
-
-	/*Set RGB Position */
-	pcr &= ~RGBPOS;
-	pcr |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
-
-	/*HMF Configurations */
-	if (af_dev->config->hmf_config.enable == H3A_AF_ENABLE) {
-		pcr &= ~AF_MED_EN;
-		/* Enable HMF */
-		pcr |= AF_MED_EN;
-
-		/* Set Median Threshold */
-		pcr &= ~MED_TH;
-		pcr |=
-		    (af_dev->config->hmf_config.threshold) << AF_MED_TH_SHIFT;
-	} else
-		pcr &= ~AF_MED_EN;
-
-	/* Set PCR Register */
-	regw(pcr, AFPCR);
-
-	/* Configure AFPAX1 */
-	/*Paxel parameter configuration */
-	/*Set Width in AFPAX1 Register */
-	pax1 &= ~PAXW;
-	pax1 |= (af_dev->config->paxel_config.width) << AF_PAXW_SHIFT;
-
-	/* Set height in AFPAX1 */
-	pax1 &= ~PAXH;
-	pax1 |= af_dev->config->paxel_config.height;
-
-	regw(pax1, AFPAX1);
-
-	/* Configure AFPAX2 Register */
-	/* Set Line Increment in AFPAX2 Register */
-	pax2 &= ~AFINCV;
-	pax2 |= (af_dev->config->paxel_config.line_incr) << AF_LINE_INCR_SHIFT;
-	/* Set Vertical Count */
-	pax2 &= ~PAXVC;
-	pax2 |= (af_dev->config->paxel_config.vt_cnt) << AF_VT_COUNT_SHIFT;
-	/* Set Horizontal Count */
-	pax2 &= ~PAXHC;
-	pax2 |= af_dev->config->paxel_config.hz_cnt;
-	regw(pax2, AFPAX2);
-
-	/* Configure PAXSTART Register */
-	/*Configure Horizontal Start */
-	paxstart &= ~PAXSH;
-	paxstart |=
-	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
-	/* Configure Vertical Start */
-	paxstart &= ~PAXSV;
-	paxstart |= af_dev->config->paxel_config.vt_start;
-	regw(paxstart, AFPAXSTART);
-
-	/*SetIIRSH Register */
-	regw(af_dev->config->iir_config.hz_start_pos, AFIIRSH);
-
-	/*Set IIR Filter0 Coefficients */
-	base_coef_set0 = AFCOEF010;
-	for (index = 0; index <= 8; index += 2) {
-		coef &= ~COEF_MASK0;
-		coef |= af_dev->config->iir_config.coeff_set0[index];
-		coef &= ~COEF_MASK1;
-		coef |=
-		    (af_dev->config->iir_config.
-		     coeff_set0[index + 1]) << AF_COEF_SHIFT;
-		regw(coef, base_coef_set0);
-		dev_dbg(afdev, "\n COEF0 %x", regr(base_coef_set0));
-		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
-	}
-
-	/* set AFCOEF0010 Register */
-	regw(af_dev->config->iir_config.coeff_set0[10], AFCOEF0010);
-
-	/*Set IIR Filter1 Coefficients */
-
-	base_coef_set1 = AFCOEF110;
-	for (index = 0; index <= 8; index += 2) {
-		coef &= ~COEF_MASK0;
-		coef |= af_dev->config->iir_config.coeff_set1[index];
-		coef &= ~COEF_MASK1;
-		coef |=
-		    (af_dev->config->iir_config.
-		     coeff_set1[index + 1]) << AF_COEF_SHIFT;
-		regw(coef, base_coef_set1);
-		dev_dbg(afdev, "\n COEF1 %x", regr(base_coef_set1));
-		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
-	}
-	/* Set AFCOEF0110 */
-	regw(af_dev->config->iir_config.coeff_set1[10], AFCOEF1010);
-
-	/*Set AFBUFST to Current buffer Physical Address */
-	regw((unsigned int)(virt_to_phys(af_dev->buff_curr)), AFBUFST);
-
-	dev_dbg(afdev, "\n PCR %x", pcr);
-	dev_dbg(afdev, "\n AFPAX1 %x", regr(AFPAX1));
-	dev_dbg(afdev, "\n PAXSTART %x", paxstart);
-	dev_dbg(afdev, "\n PAX2 %x", regr(AFPAX2));
-	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF0010));
-	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF1010));
-	dev_dbg(afdev, "\n AFBUFST %x", regr(AFBUFST));
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-	return 0;
-}
-
-/* Function to Enable/Disable AF Engine */
-inline void af_engine_setup(int enable)
-{
-	unsigned int pcr;
-	dev_dbg(afdev, __FUNCTION__ "E\n");
-
-	pcr = regr(AFPCR);
-	dev_dbg(afdev, "\n Engine Setup value before PCR : %x", pcr);
-
-	/* Set AF_EN bit in PCR Register */
-	if (enable)
-		pcr |= AF_EN;
-	else
-		pcr &= ~AF_EN;
-
-	regw(pcr, AFPCR);
-
-	dev_dbg(afdev, "\n Engine Setup value after PCR : %x", pcr);
-	dev_dbg(afdev, __FUNCTION__ "L\n");
-}
-
-/* Function to set address */
-inline void af_set_address(unsigned long address)
-{
-	regw(address, AFBUFST);
-}
Index: linux-2.6.10/drivers/media/video/davinci_vpfe.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/davinci_vpfe.c
+++ /dev/null
@@ -1,2235 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-/* davinci_vpfe.c */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/kdev_t.h>
-#include <linux/string.h>
-#include <linux/videodev.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-#include <linux/time.h>
-#include <linux/device.h>
-#include <asm/irq.h>
-#include <asm/page.h>
-#include <asm/io.h>
-#include <asm/dma-mapping.h>
-
-#include <media/davinci_vpfe.h>
-
-MODULE_LICENSE("GPL");
-
-/* Global variable for insmode command which will decide that either MT9T001
- * (device =0)  or TVP5146 (device = 1) is the device
- */
-static int device_type = TVP5146;
-
-module_param(device_type, int, 0);
-
-static struct v4l2_rect ntsc_bounds = VPFE_WIN_NTSC;
-static struct v4l2_rect pal_bounds = VPFE_WIN_PAL;
-static struct v4l2_fract ntsc_aspect = VPFE_PIXELASPECT_NTSC;
-static struct v4l2_fract pal_aspect = VPFE_PIXELASPECT_PAL;
-static struct v4l2_rect ntscsp_bounds = VPFE_WIN_NTSC_SP;
-static struct v4l2_rect palsp_bounds = VPFE_WIN_PAL_SP;
-static struct v4l2_fract sp_aspect = VPFE_PIXELASPECT_NTSC_SP;
-
-static struct v4l2_rect VGA_bounds = VPFE_WIN_VGA;
-static struct v4l2_rect SVGA_bounds = VPFE_WIN_SVGA;
-static struct v4l2_rect XGA_bounds = VPFE_WIN_XGA;
-static struct v4l2_rect P480_bounds = VPFE_WIN_480p;
-static struct v4l2_rect P576_bounds = VPFE_WIN_576p;
-static struct v4l2_rect P720_bounds = VPFE_WIN_720p;
-static struct v4l2_rect P1080_bounds = VPFE_WIN_1080p;
-static struct v4l2_fract default_aspect = VPFE_PIXELASPECT_DEFAULT;
-
-static vpfe_obj vpfe_device_ycbcr = {	/* the default format is NTSC */
-	.usrs = 0,
-	.io_usrs = 0,
-	.std = VPFE_STD_AUTO,
-	.vwin = VPFE_WIN_PAL,
-	.bounds = VPFE_WIN_PAL,
-	.pixelaspect = VPFE_PIXELASPECT_NTSC,
-	.pixelfmt = V4L2_PIX_FMT_UYVY,
-	.field = V4L2_FIELD_INTERLACED,
-	.numbuffers = VPFE_DEFNUM_FBUFS,
-	.capture_device = TVP5146,
-	.ccdc_params_ycbcr = {
-			      .pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
-			      .frm_fmt = CCDC_FRMFMT_INTERLACED,
-			      .win = VPFE_WIN_PAL,
-			      .fid_pol = CCDC_PINPOL_POSITIVE,
-			      .vd_pol = CCDC_PINPOL_POSITIVE,
-			      .hd_pol = CCDC_PINPOL_POSITIVE,
-			      .bt656_enable = TRUE,
-			      .pix_order = CCDC_PIXORDER_CBYCRY,
-			      .buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED},
-
-	.ccdc_params_raw = {0},
-	.tvp5146_params = {
-			   .mode = TVP5146_MODE_AUTO,
-			   .amuxmode = TVP5146_AMUX_COMPOSITE,
-			   .enablebt656sync = TRUE,
-			   .data_width = TVP5146_WIDTH_8BIT},
-	.irqlock = SPIN_LOCK_UNLOCKED
-};
-
-/* Initialize vpfe_device_raw. Here, blk_clamp, blk_comp, fault_pxl are
- * disabled by initialized with zero */
-static vpfe_obj vpfe_device_raw = {	/* Default is vga mode */
-	.usrs = 0,
-	.io_usrs = 0,
-	.std = V4L2_STD_MT9T001_VGA_30FPS,
-	.vwin = VPFE_WIN_VGA,
-	.bounds = VPFE_WIN_VGA,
-	.pixelaspect = VPFE_PIXELASPECT_DEFAULT,
-	.pixelfmt = V4L2_PIX_FMT_SBGGR8,
-	.field = V4L2_FIELD_NONE,
-	.numbuffers = VPFE_DEFNUM_FBUFS,
-	.capture_device = MT9T001,
-	.ccdc_params_raw = {
-			    .pix_fmt = CCDC_PIXFMT_RAW,
-			    .frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
-			    .win = VPFE_WIN_PAL,
-			    .fid_pol = CCDC_PINPOL_POSITIVE,
-			    .vd_pol = CCDC_PINPOL_POSITIVE,
-			    .hd_pol = CCDC_PINPOL_POSITIVE,
-			    .image_invert_enable = FALSE,
-			    .data_sz = _10BITS,
-			    .alaw = {
-				     .b_alaw_enable = FALSE},
-			    .blk_clamp = {
-					  .b_clamp_enable = FALSE,
-					  .dc_sub = 0},
-			    .blk_comp = {0, 0, 0, 0},
-			    .fault_pxl = {
-					  .fpc_enable = FALSE,
-					  .fp_num = 0,
-					  .fpc_table_addr = (unsigned int)NULL},
-			    },
-	.ccdc_params_ycbcr = {0},
-	.irqlock = SPIN_LOCK_UNLOCKED
-};
-
-static ccdc_frmfmt frm_format;
-static ccdc_imgwin image_window;
-static vpfe_obj vpfe_device = { 0 };
-struct device *vpfe_dev;
-
-struct v4l2_capability vpfe_drvcap = {
-	.driver = "vpfe driver",
-	.card = "DaVinci EVM",
-	.bus_info = "Platform",
-	.version = VPFE_VERSION_CODE,
-	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING
-};
-
-/* inline function to free reserved pages  */
-void inline free_reserved_pages(unsigned long bufaddr, unsigned long bufsize)
-{
-	unsigned long size, addr;
-	if (!bufaddr)
-		return;
-	addr = bufaddr;
-	size = PAGE_SIZE << (get_order(bufsize));
-	while (size > 0) {
-		ClearPageReserved(virt_to_page(addr));
-		addr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-	free_pages(bufaddr, get_order(bufsize));
-}
-
-/*
- * ======== sense_std ========
- */
-/*This function will get current input standard for TVP5146*/
-static int sense_std(v4l2_std_id * std_id)
-{
-	v4l2_std_id id = 0;
-	tvp5146_mode mode;
-	int ret;
-	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe sense_std...");
-	ret = tvp5146_ctrl(TVP5146_GET_STD, &mode);
-	if (ret < 0)
-		return ret;
-	switch (mode & 0x7) {
-	case TVP5146_MODE_NTSC:
-		id = V4L2_STD_NTSC;
-		break;
-	case TVP5146_MODE_PAL:
-		id = V4L2_STD_PAL;
-		break;
-	case TVP5146_MODE_PAL_M:
-		id = V4L2_STD_PAL_M;
-		break;
-	case TVP5146_MODE_PAL_CN:
-		id = V4L2_STD_PAL_N;
-		break;
-	case TVP5146_MODE_SECAM:
-		id = V4L2_STD_SECAM;
-		break;
-	case TVP5146_MODE_PAL_60:
-		id = V4L2_STD_PAL_60;
-		break;
-	}
-	if (mode & 0x8) {	/* square pixel mode */
-		id <<= 32;
-	}
-	if (mode == TVP5146_MODE_AUTO) {
-		id = VPFE_STD_AUTO;	/* auto-detection for all other modes */
-	} else if (mode == TVP5146_MODE_AUTO_SQP) {
-		id = VPFE_STD_AUTO_SQP;
-	}
-	if (id == 0)
-		return -EINVAL;
-	*std_id = id;
-	dev_dbg(vpfe_dev, "\nEnd of Davinci_vpfe sense_std...");
-	return 0;
-}
-
-/*
- * ======== vpfe_isr ========
- */
-/*ISR for VINT0*/
-static irqreturn_t vpfe_isr(int irq, void *dev_id, struct pt_regs *regs)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int fid;
-	unsigned long jiffies_time = get_jiffies_64();
-	struct timeval timevalue;
-	int val = 0;
-
-	val = ccdc_sbl_reset();
-
-	/*Convert time representations between jiffies and struct timeval */
-	jiffies_to_timeval(jiffies_time, &timevalue);
-
-	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe\vpfe_isr...");
-	if (frm_format == CCDC_FRMFMT_INTERLACED) {
-		/* check which field we are in hardware */
-		fid = ccdc_getfid();
-		/* switch the software maintained field id */
-		vpfe->field_id ^= 1;
-		dev_dbg(vpfe_dev, "field id = %x:%x.\n", fid, vpfe->field_id);
-		if (fid == vpfe->field_id) {	/* we are in-sync here,continue */
-			if (fid == 0) {	/* even field */
-				/*  One frame is just being captured. If the 
-				 * next frame is available, release the current 
-				 * frame and move on 
-				 */
-				if (vpfe->curFrm != vpfe->nextFrm) {
-					/* Copy frame capture time value in 
-					 * curFrm->ts 
-					 */
-					vpfe->curFrm->ts = timevalue;
-					vpfe->curFrm->state = STATE_DONE;
-					wake_up_interruptible(&vpfe->
-							      curFrm->done);
-					vpfe->curFrm = vpfe->nextFrm;
-				}
-				/* based on whether the two fields are stored  
-				 * interleavely or separately in memory, 
-				 * reconfigure the CCDC memory address 
-				 */
-				if (vpfe->field == V4L2_FIELD_SEQ_TB) {
-					u32 addr =
-					    vpfe->curFrm->boff +
-					    vpfe->field_offset;
-					ccdc_setfbaddr((unsigned long)
-						       addr);
-				}
-			} else if (fid == 1) {	/* odd field */
-				/* if one field is just being captured */
-				/* configure the next frame */
-				/* get the next frame from the empty queue */
-				/* if no frame is available, */
-				/* hold on to the current buffer */
-				if (!list_empty(&vpfe->dma_queue)
-				    && vpfe->curFrm == vpfe->nextFrm) {
-					vpfe->nextFrm =
-					    list_entry(vpfe->dma_queue.
-						       next, struct
-						       videobuf_buffer, queue);
-					list_del(&vpfe->nextFrm->queue);
-					vpfe->nextFrm->state = STATE_ACTIVE;
-					ccdc_setfbaddr((unsigned long)
-						       vpfe->nextFrm->boff);
-				}
-				if (vpfe->mode_changed) {
-					ccdc_setwin(&image_window,
-						    frm_format, 2);
-					/* update the field offset */
-					vpfe->field_offset =
-					    (vpfe->vwin.height -
-					     2) * vpfe->vwin.width;
-					vpfe->mode_changed = FALSE;
-				}
-			}
-		} else if (fid == 0) {	/* even field */
-			/* recover from any hardware out-of-sync due to */
-			/* possible switch of video source              */
-			/* for fid == 0, sync up the two fids           */
-			/* for fid == 1, no action, one bad frame will  */
-			/* go out, but it is not a big deal             */
-			vpfe->field_id = fid;
-		}
-	} else if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
-
-		dev_dbg(vpfe_dev, "\nframe format is progressive...");
-		if (vpfe->curFrm != vpfe->nextFrm) {
-			/* Copy frame capture time value in curFrm->ts */
-			vpfe->curFrm->ts = timevalue;
-			vpfe->curFrm->state = STATE_DONE;
-			wake_up_interruptible(&vpfe->curFrm->done);
-			vpfe->curFrm = vpfe->nextFrm;
-		}
-
-	}
-	dev_dbg(vpfe_dev, "interrupt returned.\n");
-	return IRQ_RETVAL(1);
-}
-
-static irqreturn_t vdint1_isr(int irq, void *dev_id, struct pt_regs *regs)
-{
-
-	vpfe_obj *vpfe = &vpfe_device;
-
-	dev_dbg(vpfe_dev, "\nInside vdint1_isr...");
-
-	if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
-		if (!list_empty(&vpfe->dma_queue)
-		    && vpfe->curFrm == vpfe->nextFrm) {
-			vpfe->nextFrm =
-			    list_entry(vpfe->dma_queue.next,
-				       struct videobuf_buffer, queue);
-			list_del(&vpfe->nextFrm->queue);
-			vpfe->nextFrm->state = STATE_ACTIVE;
-			ccdc_setfbaddr((unsigned long)vpfe->nextFrm->boff);
-		}
-	}
-	return IRQ_RETVAL(1);
-}
-
-/*
- * ======== buffer_prepare ========
- */
-/* this is the callback function called from videobuf_qbuf() function */
-/* the buffer is prepared and queued into the dma queue */
-static int buffer_prepare(struct videobuf_queue *q,
-			  struct videobuf_buffer *vb, enum v4l2_field field)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	unsigned int buf_size;
-	dev_dbg(vpfe_dev, "\nstarting buffer_prepare");
-	if (device_type == TVP5146) {
-		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
-	} else {
-		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
-	}
-	if (vb->state == STATE_NEEDS_INIT) {
-		vb->width = vpfe->vwin.width;
-		vb->height = vpfe->vwin.height;
-		vb->size = buf_size;
-		vb->field = field;
-	}
-	vb->state = STATE_PREPARED;
-	dev_dbg(vpfe_dev, "\nEnd of buffer_prepare");
-	return 0;
-
-}
-
-/*
- * ======== buffer_config ========
- */
- /* This function is responsible to queue up vpfe buffer is into video buffer
-  * queue. 
-  */
-static void buffer_config(struct videobuf_queue *q, unsigned int count)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int i;
-	dev_dbg(vpfe_dev, "\nstarting buffer_config");
-	for (i = 0; i < count; i++) {
-		q->bufs[i]->boff = virt_to_phys(vpfe->fbuffers[i]);
-		dev_dbg(vpfe_dev, "buffer address: %x\n", q->bufs[i]->boff);
-	}
-	dev_dbg(vpfe_dev, "\nEnd of buffer_config");
-}
-
-/*
- * ======== buffer_setup ========
- */
- /* This function allocate free pages and makes it sure that they will not
-  * swapped 
-  */
-static int
-buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int i;
-	unsigned int buf_size;
-	dev_dbg(vpfe_dev, "\nstarting buffer_setup");
-	if (device_type == TVP5146) {
-		*size = buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
-	} else {
-		*size = buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
-	}
-
-	for (i = VPFE_DEFNUM_FBUFS; i < *count; i++) {
-		u32 size = PAGE_SIZE << (get_order(buf_size));
-		void *mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-						     get_order(buf_size));
-		if (mem) {
-			unsigned long adr = (unsigned long)mem;
-			while (size > 0) {
-				/* make sure the frame buffers are never 
-				   swapped out of memory */
-				SetPageReserved(virt_to_page(adr));
-				adr += PAGE_SIZE;
-				size -= PAGE_SIZE;
-			}
-			vpfe->fbuffers[i] = mem;
-		} else {
-			break;
-		}
-	}
-	*count = vpfe->numbuffers = i;
-	dev_dbg(vpfe_dev, "\nEnd of buffer_setup");
-	return 0;
-}
-
-/*
- * ======== buffer_queue ========
- */
- /* This function adds the buffer to DMA queue */
-static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	/* add the buffer to the DMA queue */
-	dev_dbg(vpfe_dev, "\nstarting buffer_queue");
-	list_add_tail(&vb->queue, &vpfe->dma_queue);
-	vb->state = STATE_QUEUED;
-	dev_dbg(vpfe_dev, "\nEnding buffer_queue");
-}
-
-/*
- * ======== buffer_release ========
- */
- /* This function will free the buffer if it is not one
-  * of the 3 allocated at initialization time. 
-  */
-static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	unsigned int buf_size;
-	dev_dbg(vpfe_dev, "\nStarting buffer_release");
-	if (device_type == TVP5146) {
-		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
-	} else {
-		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
-	}
-
-	/* free the buffer if it is not one of the 3 allocated at initializaiton
-	 * time
-	 */
-	if (vb->i < vpfe_device.numbuffers
-	    && vb->i >= VPFE_DEFNUM_FBUFS && vpfe_device.fbuffers[vb->i]) {
-		free_pages((unsigned long)vpfe_device.
-			   fbuffers[vb->i], get_order(buf_size));
-		vpfe_device.fbuffers[vb->i] = NULL;
-	}
-
-	vb->state = STATE_NEEDS_INIT;
-	dev_dbg(vpfe_dev, "\nEnd of buffer_release");
-}
-
-static struct videobuf_queue_ops video_qops = {
-	.buf_setup = buffer_setup,
-	.buf_prepare = buffer_prepare,
-	.buf_queue = buffer_queue,
-	.buf_release = buffer_release,
-	.buf_config = buffer_config,
-};
-
-/*
- * ======== vpfe_doioctl ========
- */
- /* This function will provide different V4L2 commands.This function can be
-  * used to configure driver or get status of driver as per command passed 
-  * by application. 
-  */
-static int vpfe_doioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, void *arg)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	vpfe_fh *fh = file->private_data;
-	int ret = 0;
-
-	switch (cmd) {
-	case VIDIOC_S_CTRL:
-	case VIDIOC_S_FMT:
-	case VIDIOC_S_STD:
-	case VIDIOC_S_CROP:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
-		ret = v4l2_prio_check(&vpfe->prio, &fh->prio);
-		if (0 != ret) {
-			return ret;
-		}
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
-		break;
-	}
-
-	switch (cmd) {
-	case VIDIOC_QUERYCAP:
-		{
-			struct v4l2_capability *cap =
-			    (struct v4l2_capability *)arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUEYCAP ioctl");
-			memset(cap, 0, sizeof(*cap));
-			*cap = vpfe_drvcap;
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUEYCAP ioctl");
-			break;
-		}
-	case VIDIOC_ENUM_FMT:
-		{
-			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
-			u32 index = fmt->index;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_ENUM_FMT ioctl");
-			memset(fmt, 0, sizeof(*fmt));
-
-			fmt->index = index;
-			if (device_type == TVP5146) {
-				if (index == 0) {
-					/* only yuv4:2:2 format is supported 
-					 * at this point 
-					 */
-					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-					strcpy(fmt->description,
-					       "YCbCr4:2:2 Interleaved UYUV");
-					fmt->pixelformat = V4L2_PIX_FMT_UYVY;
-				} else if (index == 1) {
-					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-					strcpy(fmt->description,
-					       "YCbCr4:2:2 Interleaved YUYV");
-					fmt->pixelformat = V4L2_PIX_FMT_YUYV;
-				} else {
-					ret = -EINVAL;
-				}
-			} else if (device_type == MT9T001) {
-				if (index == 0) {
-					/* only Bayer Raw Mode format is 
-					 * supported at this point 
-					 */
-					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-					strcpy(fmt->description,
-					       "Raw Mode -Bayer Pattern GrRBGb");
-					fmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
-				} else {
-					ret = -EINVAL;
-				}
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUM_FMT ioctl");
-
-			break;
-		}
-	case VIDIOC_G_FMT:
-		{
-			struct v4l2_format *fmt = (struct v4l2_format *)arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
-			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-				ret = -EINVAL;
-			} else {
-				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-				down_interruptible(&vpfe->lock);
-				pixfmt->width = vpfe->vwin.width;
-				pixfmt->height = vpfe->vwin.height;
-				pixfmt->field = vpfe->field;
-				pixfmt->pixelformat = vpfe->pixelfmt;
-				if (device_type == TVP5146) {
-					pixfmt->bytesperline =
-					    pixfmt->width * 2;
-				} else {
-					pixfmt->bytesperline =
-					    ((vpfe->ccdc_params_raw.
-					      data_sz == _8BITS)
-					     || (vpfe->ccdc_params_raw.
-						 alaw.b_alaw_enable))
-					    ? pixfmt->width : (pixfmt->
-							       width * 2);
-				}
-				pixfmt->sizeimage =
-				    pixfmt->bytesperline * pixfmt->height;
-				pixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;
-				up(&vpfe->lock);
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
-			break;
-		}
-	case VIDIOC_S_FMT:
-		{
-			struct v4l2_format *fmt = (struct v4l2_format *)arg;
-			struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-			ccdc_imgwin *img_win;
-			ccdc_buftype *buf_type;
-			ccdc_frmfmt *frame_format;
-
-			if (device_type == TVP5146) {
-				img_win = &(vpfe->ccdc_params_ycbcr.win);
-				buf_type = &(vpfe->ccdc_params_ycbcr.buf_type);
-				frame_format =
-				    &(vpfe->ccdc_params_ycbcr.frm_fmt);
-			} else {
-				img_win = &(vpfe->ccdc_params_raw.win);
-				buf_type = &(vpfe->ccdc_params_raw.buf_type);
-				frame_format = &(vpfe->ccdc_params_raw.frm_fmt);
-
-			}
-
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_FMT ioctl");
-			if (vpfe->started) {
-				/* make sure streaming is not started */
-				ret = -EBUSY;
-				break;
-			}
-
-			down_interruptible(&vpfe->lock);
-			dev_dbg(vpfe_dev, "\nAfter down_interruptible");
-			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-				ret = -EINVAL;
-				up(&vpfe->lock);
-				break;
-			}
-
-			if ((pixfmt->width + vpfe->vwin.left <=
-			     vpfe->bounds.width)
-			    && (pixfmt->height + vpfe->vwin.top <=
-				vpfe->bounds.height)) {
-				/* this is the case when no scaling is 
-				 * supported 
-				 */
-				/* crop window is directed modified */
-				vpfe->vwin.height = pixfmt->height;
-				vpfe->vwin.width = pixfmt->width;
-				img_win->width = pixfmt->width;
-				img_win->height = pixfmt->height;
-			} else {
-				ret = -EINVAL;
-				up(&vpfe->lock);
-				break;
-			}
-
-			/* setup the CCDC parameters accordingly */
-			if (device_type == TVP5146) {
-
-				if (pixfmt->pixelformat == V4L2_PIX_FMT_YUYV) {
-					vpfe->ccdc_params_ycbcr.pix_order =
-					    CCDC_PIXORDER_YCBYCR;
-					vpfe->pixelfmt = pixfmt->pixelformat;
-				} else if (pixfmt->pixelformat ==
-					   V4L2_PIX_FMT_UYVY) {
-					vpfe->ccdc_params_ycbcr.pix_order =
-					    CCDC_PIXORDER_CBYCRY;
-					vpfe->pixelfmt = pixfmt->pixelformat;
-				} else {
-					/* not supported format */
-					ret = -EINVAL;
-					up(&vpfe->lock);
-					break;
-				}
-			} else if (device_type == MT9T001) {
-
-				if (pixfmt->pixelformat == V4L2_PIX_FMT_SBGGR8) {
-					vpfe->pixelfmt = pixfmt->pixelformat;
-				} else {
-					/* not supported format */
-					ret = -EINVAL;
-					up(&vpfe->lock);
-					break;
-				}
-			}
-
-			/* Configure buffer type and frame format as per field
-			 *  value passed 
-			 */
-			if (pixfmt->field == V4L2_FIELD_INTERLACED) {
-				*buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED;
-				*frame_format = CCDC_FRMFMT_INTERLACED;
-				vpfe->field = pixfmt->field;
-			} else if (pixfmt->field == V4L2_FIELD_SEQ_TB) {
-				*buf_type = CCDC_BUFTYPE_FLD_SEPARATED;
-				*frame_format = CCDC_FRMFMT_INTERLACED;
-				vpfe->field = pixfmt->field;
-			} else if (pixfmt->field == V4L2_FIELD_NONE) {
-				*frame_format = CCDC_FRMFMT_PROGRESSIVE;
-				vpfe->field = pixfmt->field;
-			} else {
-				ret = -EINVAL;
-			}
-
-			up(&vpfe->lock);
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_FMT ioctl");
-			break;
-		}
-	case VIDIOC_TRY_FMT:
-		{
-			struct v4l2_format *fmt = (struct v4l2_format *)arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_TRY_FMT ioctl");
-			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-				ret = -EINVAL;
-			} else {
-				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-
-				if (device_type == TVP5146) {
-					if (pixfmt->width >
-					    vpfe->bounds.width
-					    || pixfmt->height >
-					    vpfe->bounds.height
-					    || (pixfmt->pixelformat !=
-						V4L2_PIX_FMT_UYVY
-						&& pixfmt->pixelformat !=
-						V4L2_PIX_FMT_YUYV)) {
-						ret = -EINVAL;
-					}
-				} else if (device_type == MT9T001) {
-					if (pixfmt->width >
-					    vpfe->bounds.width
-					    || pixfmt->height >
-					    vpfe->bounds.height
-					    || (pixfmt->pixelformat !=
-						V4L2_PIX_FMT_SBGGR8)) {
-						ret = -EINVAL;
-					}
-				}
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_TRY_FMT ioctl");
-			break;
-		}
-	case VIDIOC_G_STD:
-		{
-			v4l2_std_id *id = (v4l2_std_id *) arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
-			*id = vpfe->std;
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
-			break;
-		}
-	case VIDIOC_S_STD:
-		{
-			v4l2_std_id id = *(v4l2_std_id *) arg;
-			tvp5146_mode mode = TVP5146_MODE_INV;
-			int sqp = 0;
-			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_S_STD ioctl");
-			/* make sure streaming is not started */
-			if (vpfe->started) {
-				ret = -EBUSY;
-				break;
-			}
-			down_interruptible(&vpfe->lock);
-
-			if (device_type == TVP5146) {
-				if (id & V4L2_STD_625_50) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = pal_bounds;
-					vpfe->pixelaspect = pal_aspect;
-					vpfe->ccdc_params_ycbcr.win =
-					    pal_bounds;
-
-				} else if (id & V4L2_STD_525_60) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = ntsc_bounds;
-					vpfe->pixelaspect = ntsc_aspect;
-					vpfe->ccdc_params_ycbcr.win =
-					    ntsc_bounds;
-				} else if (id & VPFE_STD_625_50_SQP) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin =
-					    palsp_bounds;
-					vpfe->pixelaspect = sp_aspect;
-					sqp = 1;
-					id >>= 32;
-				} else if (id & VPFE_STD_525_60_SQP) {
-					vpfe->std = id;
-					sqp = 1;
-					vpfe->std = id;
-					id >>= 32;
-					vpfe->bounds = vpfe->vwin =
-					    ntscsp_bounds;
-					vpfe->pixelaspect = sp_aspect;
-					vpfe->ccdc_params_ycbcr.win =
-					    ntscsp_bounds;
-				} else if (id & VPFE_STD_AUTO) {
-					mode = TVP5146_MODE_AUTO;
-					vpfe->bounds = vpfe->vwin = pal_bounds;
-					vpfe->pixelaspect = pal_aspect;
-					vpfe->ccdc_params_ycbcr.win =
-					    pal_bounds;
-					vpfe->std = id;
-				} else if (id & VPFE_STD_AUTO_SQP) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin =
-					    palsp_bounds;
-					vpfe->pixelaspect = sp_aspect;
-					sqp = 1;
-					mode = TVP5146_MODE_AUTO_SQP;
-					vpfe->pixelaspect = sp_aspect;
-				} else {
-					ret = -EINVAL;
-				}
-				if (id == V4L2_STD_PAL_60) {
-					mode = TVP5146_MODE_PAL_60;
-				} else if (id == V4L2_STD_PAL_M) {
-					mode = TVP5146_MODE_PAL_M;
-				} else if (id == V4L2_STD_PAL_Nc
-					   || id == V4L2_STD_PAL_N) {
-					mode = TVP5146_MODE_PAL_CN;
-				} else if (id & V4L2_STD_PAL) {
-					mode = TVP5146_MODE_PAL;
-				} else if (id & V4L2_STD_NTSC) {
-					mode = TVP5146_MODE_NTSC;
-				} else if (id & V4L2_STD_SECAM) {
-					mode = TVP5146_MODE_SECAM;
-				}
-				vpfe->tvp5146_params.mode = mode | (sqp << 3);
-				tvp5146_ctrl(TVP5146_CONFIG,
-					     &vpfe->tvp5146_params);
-			} else if (device_type == MT9T001) {
-				/* Store image window paramters and pixel 
-				 * aspect values as per standard 
-				 * passed by application 
-				 */
-				if ((id == V4L2_STD_MT9T001_VGA_30FPS)
-				    || (id == V4L2_STD_MT9T001_VGA_60FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = VGA_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = VGA_bounds;
-				} else if ((id == V4L2_STD_MT9T001_SVGA_30FPS)
-					   || (id ==
-					       V4L2_STD_MT9T001_SVGA_60FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = SVGA_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = SVGA_bounds;
-				} else if ((id == V4L2_STD_MT9T001_XGA_30FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = XGA_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = XGA_bounds;
-				} else if ((id == V4L2_STD_MT9T001_480p_30FPS)
-					   || (id ==
-					       V4L2_STD_MT9T001_480p_60FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = P480_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = P480_bounds;
-				} else if ((id == V4L2_STD_MT9T001_576p_25FPS)
-					   || (id ==
-					       V4L2_STD_MT9T001_576p_50FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = P576_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = P576_bounds;
-				} else if ((id == V4L2_STD_MT9T001_720p_24FPS)
-					   || (id ==
-					       V4L2_STD_MT9T001_720p_30FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin = P720_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win = P720_bounds;
-				} else if ((id == V4L2_STD_MT9T001_1080p_18FPS)) {
-					vpfe->std = id;
-					vpfe->bounds = vpfe->vwin =
-					    P1080_bounds;
-					vpfe->pixelaspect = default_aspect;
-					vpfe->ccdc_params_raw.win =
-					    P1080_bounds;
-				} else {
-					ret = -EINVAL;
-				}
-				if (ret != -EINVAL) {
-					/* Call device control function to 
-					 * configure video standard 
-					 */
-					ret =
-					    vpfe->
-					    config_dev_fxn(MT9T001_SET_STD,
-							   &vpfe->std,
-							   vpfe->device_params);
-				}
-			}
-			dev_dbg(vpfe_dev, "\nAbove up(&vpfe->lock)");
-			up(&vpfe->lock);
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_STD ioctl");
-			break;
-		}
-	case VIDIOC_ENUMSTD:
-		{
-			struct v4l2_standard *std = (struct v4l2_standard *)arg;
-			u32 index = std->index;
-			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_ENUMSTD ioctl");
-			memset(std, 0, sizeof(*std));
-			std->index = index;
-
-			if (device_type == TVP5146) {
-				if (index == 0) {
-					std->id = V4L2_STD_525_60;
-					strcpy(std->name, "SD-525line-30fps");
-					std->framelines = 525;
-					std->frameperiod.numerator = 1001;
-					std->frameperiod.denominator = 30000;
-				} else if (index == 1) {
-					std->id = V4L2_STD_625_50;
-					strcpy(std->name, "SD-625line-25fps");
-					std->framelines = 625;
-					std->frameperiod.numerator = 1;
-					std->frameperiod.denominator = 25;
-				} else if (index == 2) {
-					std->id = VPFE_STD_625_50_SQP;
-					strcpy(std->name,
-					       "SD-625line-25fps square pixel");
-					std->framelines = 625;
-					std->frameperiod.numerator = 1;
-					std->frameperiod.denominator = 25;
-				} else if (index == 3) {
-					std->id = VPFE_STD_525_60_SQP;
-					strcpy(std->name,
-					       "SD-525line-25fps square pixel");
-					std->framelines = 525;
-					std->frameperiod.numerator = 1001;
-					std->frameperiod.denominator = 30000;
-				} else if (index == 4) {
-					std->id = VPFE_STD_AUTO;
-					strcpy(std->name, "automatic detect");
-					std->framelines = 625;
-					std->frameperiod.numerator = 1;
-					std->frameperiod.denominator = 1;
-				} else if (index == 5) {
-					std->id = VPFE_STD_AUTO_SQP;
-					strcpy(std->name,
-					       "automatic detect square pixel");
-					std->framelines = 625;
-					std->frameperiod.numerator = 1;
-					std->frameperiod.denominator = 1;
-				} else {
-					ret = -EINVAL;
-				}
-			} else if (device_type == MT9T001) {
-				/* fill number of lines per frame and FPS value
-				 *  as per standard passed by application 
-				 */
-				if (index == 0) {
-					std->id = V4L2_STD_MT9T001_VGA_30FPS;
-					strcpy(std->name, "VGA-480line- 30fps");
-					std->framelines = FMT_VGA_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_30_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 1) {
-					std->id = V4L2_STD_MT9T001_VGA_60FPS;
-					strcpy(std->name, "VGA-480line- 60fps");
-					std->framelines = FMT_VGA_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_60_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_60_DENOMIRATOR;
-				} else if (index == 2) {
-					std->id = V4L2_STD_MT9T001_SVGA_30FPS;
-					strcpy(std->name,
-					       "SVGA-600line- 30fps");
-					std->framelines = FMT_SVGA_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_30_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 3) {
-					std->id = V4L2_STD_MT9T001_SVGA_60FPS;
-					strcpy(std->name,
-					       "SVGA-600line- 60fps");
-					std->framelines = FMT_SVGA_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_60_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 4) {
-					std->id = V4L2_STD_MT9T001_XGA_30FPS;
-					strcpy(std->name, "XGA-768line- 30fps");
-					std->framelines = FMT_XGA_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_30_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 5) {
-					std->id = V4L2_STD_MT9T001_480p_30FPS;
-					strcpy(std->name, "480p-480line-30fps");
-					std->framelines = FMT_480p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_30_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 6) {
-					std->id = V4L2_STD_MT9T001_480p_60FPS;
-					strcpy(std->name, "480p-480line-60fps");
-					std->framelines = FMT_480p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_60_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_60_DENOMIRATOR;
-				} else if (index == 7) {
-					std->id = V4L2_STD_MT9T001_576p_25FPS;
-					strcpy(std->name, "576p-576line-25fps");
-					std->framelines = FMT_576p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_25_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_25_DENOMIRATOR;
-				} else if (index == 8) {
-					std->id = V4L2_STD_MT9T001_576p_50FPS;
-					strcpy(std->name, "576p-576line-50fps");
-					std->framelines = FMT_576p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_50_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_50_DENOMIRATOR;
-				} else if (index == 9) {
-					std->id = V4L2_STD_MT9T001_720p_24FPS;
-					strcpy(std->name, "720p-720line-24fps");
-					std->framelines = FMT_720p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_24_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_24_DENOMIRATOR;
-				} else if (index == 10) {
-					std->id = V4L2_STD_MT9T001_720p_30FPS;
-					strcpy(std->name, "720p-720line-30fps");
-					std->framelines = FMT_720p_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_30_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_30_DENOMIRATOR;
-				} else if (index == 11) {
-					std->id = V4L2_STD_MT9T001_1080p_18FPS;
-					strcpy(std->name,
-					       "1080p-1080line-18fps");
-					std->framelines = FMT_1080i_NUMLINES;
-					std->frameperiod.numerator =
-					    FPS_18_NUMERATOR;
-					std->frameperiod.denominator =
-					    FPS_18_DENOMIRATOR;
-				} else {
-					ret = -EINVAL;
-				}
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMSTD ioctl");
-			break;
-		}
-	case VIDIOC_ENUMINPUT:
-		{
-			u32 index = 0;
-			struct v4l2_input *input = (struct v4l2_input *)arg;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_ENUMINPUT ioctl");
-			if (device_type != TVP5146) {
-				return -1;
-			}
-			/* only two inputs are available */
-			if (input->index > 1)
-				ret = -EINVAL;
-			index = input->index;
-			memset(input, 0, sizeof(*input));
-			input->index = index;
-			input->type = V4L2_INPUT_TYPE_CAMERA;
-			input->std = V4L2_STD_ALL;
-			if (input->index == 0) {
-				sprintf(input->name, "COMPOSITE");
-			} else if (input->index == 1) {
-				sprintf(input->name, "S-VIDEO");
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMINPUT ioctl");
-			break;
-		}
-	case VIDIOC_G_INPUT:
-		{
-			int *index = (int *)arg;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
-			if (device_type != TVP5146) {
-				return -1;
-			}
-			*index = vpfe->tvp5146_params.amuxmode;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
-			break;
-		}
-	case VIDIOC_S_INPUT:
-		{
-			int *index = (int *)arg;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
-			if (device_type != TVP5146) {
-				return -1;
-			}
-			if (*index > 1 || *index < 0) {
-				ret = -EINVAL;
-			}
-			vpfe->tvp5146_params.amuxmode = *index;
-			tvp5146_ctrl(TVP5146_SET_AMUXMODE, index);
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
-			break;
-		}
-	case VIDIOC_CROPCAP:
-		{
-			struct v4l2_cropcap *cropcap =
-			    (struct v4l2_cropcap *)arg;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_CROPCAP ioctl");
-			cropcap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-			down_interruptible(&vpfe->lock);
-			cropcap->bounds = cropcap->defrect = vpfe->vwin;
-			cropcap->pixelaspect = vpfe->pixelaspect;
-			up(&vpfe->lock);
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_CROPCAP ioctl");
-			break;
-		}
-	case VIDIOC_G_PARM:
-		{
-			struct v4l2_streamparm *parm =
-			    (struct v4l2_streamparm *)arg;
-			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_PARM ioctl");
-			if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-				/* only capture is supported */
-				ret = -EINVAL;
-			} else {
-				struct v4l2_captureparm *capparm =
-				    &parm->parm.capture;
-				memset(capparm, 0,
-				       sizeof(struct v4l2_captureparm));
-				down_interruptible(&vpfe->lock);
-
-				if (device_type == TVP5146) {
-					if (vpfe->std & V4L2_STD_625_50) {
-						/* PAL 25fps */
-						capparm->timeperframe.
-						    numerator = 1;
-						capparm->timeperframe.
-						    denominator = 25;
-					} else {
-						/*NTSC 29.97fps */
-						capparm->timeperframe.
-						    numerator = 1001;
-						capparm->timeperframe.
-						    denominator = 30000;
-					}
-				} else if (device_type == MT9T001) {
-					/* fill FPS value as per standard */
-					if (vpfe->
-					    std & V4L2_STD_MT9T001_VGA_30FPS) {
-						capparm->timeperframe.
-						    numerator =
-						    FPS_30_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_30_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_VGA_60FPS) {
-						capparm->timeperframe.
-						    numerator =
-						    FPS_60_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_60_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_SVGA_30FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_30_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_30_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_SVGA_60FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_60_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_60_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_XGA_30FPS) {
-						capparm->timeperframe.
-						    numerator =
-						    FPS_30_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_30_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_480p_30FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_30_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_30_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_480p_60FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_60_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_60_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_576p_25FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_25_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_25_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_576p_50FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_50_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_50_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_720p_24FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_24_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_24_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_720p_30FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_30_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_30_DENOMIRATOR;
-					} else if (vpfe->
-						   std &
-						   V4L2_STD_MT9T001_1080p_18FPS)
-					{
-						capparm->timeperframe.
-						    numerator =
-						    FPS_18_NUMERATOR;
-						capparm->timeperframe.
-						    denominator =
-						    FPS_18_DENOMIRATOR;
-					}
-
-				}
-
-				/* Copy number of buffers allocated to arg 
-				 * passed 
-				 */
-				capparm->readbuffers = vpfe->numbuffers;
-
-				up(&vpfe->lock);
-				dev_dbg(vpfe_dev,
-					"\nEnd of VIDIOC_G_PARM ioctl");
-			}
-			break;
-		}
-	case VIDIOC_G_CTRL:
-		dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_CTRL ioctl");
-		down_interruptible(&vpfe->lock);
-
-		if (device_type == TVP5146) {
-			tvp5146_ctrl(VIDIOC_G_CTRL, arg);
-		} else if (device_type == MT9T001) {
-			/* Call device control function to get control value */
-			ret = vpfe->config_dev_fxn(VIDIOC_G_CTRL, arg,
-						   vpfe->device_params);
-		}
-		up(&vpfe->lock);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CTRL ioctl");
-		break;
-	case VIDIOC_S_CTRL:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
-		down_interruptible(&vpfe->lock);
-
-		if (device_type == TVP5146) {
-			ret = tvp5146_ctrl(VIDIOC_S_CTRL, arg);
-		} else if (device_type == MT9T001) {
-			/* Call device control function to configure control 
-			 * value 
-			 */
-			ret = vpfe->config_dev_fxn(VIDIOC_S_CTRL, arg,
-						   vpfe->device_params);
-		}
-		up(&vpfe->lock);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
-		break;
-	case VIDIOC_QUERYCTRL:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYCTRL ioctl");
-		down_interruptible(&vpfe->lock);
-
-		if (device_type == TVP5146) {
-			tvp5146_ctrl(VIDIOC_QUERYCTRL, arg);
-		} else if (device_type == MT9T001) {
-			/* Call device control function to query about  
-			 * supported control commands 
-			 */
-			ret = vpfe->config_dev_fxn(VIDIOC_QUERYCTRL, arg,
-						   vpfe->device_params);
-		}
-
-		up(&vpfe->lock);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYCTRL ioctl");
-
-		break;
-	case VIDIOC_G_CROP:
-		{
-			struct v4l2_crop *crop = arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_CROP ioctl");
-			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-				ret = -EINVAL;
-			} else {
-				crop->c = vpfe->vwin;
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CROP ioctl");
-			break;
-		}
-	case VIDIOC_S_CROP:
-		{
-			struct v4l2_crop *crop = arg;
-			ccdc_imgwin *image_win;
-			image_win = (device_type == TVP5146)
-			    ? (&(vpfe->ccdc_params_ycbcr.win))
-			    : (&(vpfe->ccdc_params_raw.win));
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CROP ioctl");
-			if (vpfe->started) {
-				/* make sure streaming is not started */
-				ret = -EBUSY;
-				break;
-			}
-			/* adjust the width to 16 pixel boundry */
-			crop->c.width = ((crop->c.width + 15) / 16) * 16;
-
-			/* make sure parameters are valid */
-			if (crop->type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-			    && (crop->c.left + crop->c.width
-				<= vpfe->bounds.left + vpfe->bounds.width)
-			    && (crop->c.top + crop->c.height
-				<= vpfe->bounds.top + vpfe->bounds.height)) {
-
-				down_interruptible(&vpfe->lock);
-				vpfe->vwin = crop->c;
-				*image_win = vpfe->vwin;
-				up(&vpfe->lock);
-			} else {
-				ret = -EINVAL;
-			}
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CROP ioctl");
-			break;
-		}
-	case VIDIOC_QUERYSTD:
-		{
-			v4l2_std_id *id = (v4l2_std_id *) arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYSTD ioctl");
-
-			if (device_type == TVP5146) {
-				down_interruptible(&vpfe->lock);
-				ret = sense_std(id);
-				up(&vpfe->lock);
-			} else {
-				/* return -EINVAL indicating this ioctl 
-				 * is not supported 
-				 */
-				ret = -EINVAL;
-			}
-
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYSTD ioctl");
-			break;
-		}
-	case VIDIOC_G_PRIORITY:
-		{
-			enum v4l2_priority *p = arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_PRIORITY ioctl");
-			*p = v4l2_prio_max(&vpfe->prio);
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_PRIORITY ioctl");
-			break;
-		}
-	case VIDIOC_S_PRIORITY:
-		{
-			enum v4l2_priority *p = arg;
-			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_PRIORITY ioctl");
-			ret = v4l2_prio_change(&vpfe->prio, &fh->prio, *p);
-			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_PRIORITY ioctl");
-			break;
-		}
-
-	case VIDIOC_REQBUFS:
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
-		if (vpfe->io_usrs != 0) {
-			ret = -EBUSY;
-			break;
-		}
-		down_interruptible(&vpfe->lock);
-		videobuf_queue_init(&vpfe->bufqueue, &video_qops, NULL,
-				    &vpfe->irqlock,
-				    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-				    vpfe->field,
-				    sizeof(struct videobuf_buffer), fh);
-
-		videobuf_set_buftype(&vpfe->bufqueue, VIDEOBUF_BUF_LINEAR);
-
-		fh->io_allowed = TRUE;
-		vpfe->io_usrs = 1;
-		INIT_LIST_HEAD(&vpfe->dma_queue);
-		ret = videobuf_reqbufs(&vpfe->bufqueue, arg);
-		up(&vpfe->lock);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
-		break;
-	case VIDIOC_QUERYBUF:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYBUF ioctl");
-		ret = videobuf_querybuf(&vpfe->bufqueue, arg);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYBUF ioctl");
-		break;
-	case VIDIOC_QBUF:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QBUF ioctl");
-		if (!fh->io_allowed) {
-			dev_dbg(vpfe_dev, "\nfh->io_allowed");
-			ret = -EACCES;
-		} else {
-			dev_dbg(vpfe_dev, "\n else of fh->io_allowed");
-			ret = videobuf_qbuf(&vpfe->bufqueue, arg);
-		}
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QBUF ioctl");
-		break;
-
-	case VIDIOC_DQBUF:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_DQBUF ioctl");
-		if (!fh->io_allowed)
-			ret = -EACCES;
-		else
-			ret = videobuf_dqbuf(&vpfe->bufqueue, arg, 0);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_DQBUF ioctl");
-		break;
-
-	case VIDIOC_STREAMON:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMON ioctl");
-		if (!fh->io_allowed) {
-			ret = -EACCES;
-			break;
-		}
-		if (vpfe->started) {
-			ret = -EBUSY;
-			break;
-		}
-		ret = videobuf_streamon(&vpfe->bufqueue);
-		if (ret)
-			break;
-
-		down_interruptible(&vpfe->lock);
-		/* get the current and next frame buffers */
-		/* we expect at least one buffer is in driver at this point */
-		/* if not, error is returned */
-		if (list_empty(&vpfe->dma_queue)) {
-			ret = -EIO;
-			break;
-		}
-		dev_dbg(vpfe_dev, "cur frame %x.\n",
-			(unsigned int)vpfe->dma_queue.next);
-		vpfe->nextFrm = vpfe->curFrm =
-		    list_entry(vpfe->dma_queue.next,
-			       struct videobuf_buffer, queue);
-		/* remove the buffer from the queue */
-		list_del(&vpfe->curFrm->queue);
-		vpfe->curFrm->state = STATE_ACTIVE;
-
-		if (device_type == TVP5146) {
-			/* sense the current video input standard */
-			tvp5146_ctrl(TVP5146_CONFIG, &vpfe->tvp5146_params);
-			frm_format = vpfe_device.ccdc_params_ycbcr.frm_fmt;
-			image_window = vpfe_device.ccdc_params_ycbcr.win;
-			/* configure the ccdc and resizer as needed   */
-			/* start capture by enabling CCDC and resizer */
-			ccdc_config_ycbcr(&vpfe->ccdc_params_ycbcr);
-		} else {
-			frm_format = vpfe_device.ccdc_params_raw.frm_fmt;
-			image_window = vpfe_device.ccdc_params_raw.win;
-			/* configure the ccdc and resizer as needed   */
-			/* start capture by enabling CCDC and resizer */
-			ccdc_config_raw(&vpfe->ccdc_params_raw);
-			/* enable internal timing generator */
-			ccdc_vdhd_enable(TRUE);
-		}
-
-		/* setup the memory address for the frame buffer */
-		ccdc_setfbaddr(((unsigned long)(vpfe->curFrm->boff)));
-		/* enable CCDC */
-		vpfe->field_id = 0;
-		vpfe->started = TRUE;
-		vpfe->mode_changed = FALSE;
-		vpfe->field_offset = (vpfe->vwin.height - 2) * vpfe->vwin.width;
-		ccdc_enable(TRUE);
-		up(&vpfe->lock);
-		dev_dbg(vpfe_dev, "started video streaming.\n");
-		break;
-	case VIDIOC_STREAMOFF:
-		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMOFF ioctl");
-		if (!fh->io_allowed) {
-			ret = -EACCES;
-			break;
-		}
-		if (!vpfe->started) {
-			ret = -EINVAL;
-			break;
-		}
-		/* disable CCDC */
-		down_interruptible(&vpfe->lock);
-
-		if (device_type == MT9T001) {
-			ccdc_vdhd_enable(FALSE);
-		}
-		ccdc_enable(FALSE);
-		vpfe->started = FALSE;
-		up(&vpfe->lock);
-		ret = videobuf_streamoff(&vpfe->bufqueue);
-		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_STREAMOFF ioctl");
-		break;
-
-	case VPFE_CMD_CONFIG_CCDC_YCBCR:
-		/* this can be used directly and bypass the V4L2 APIs */
-		{
-			ccdc_params_ycbcr *params = &(vpfe->ccdc_params_ycbcr);
-
-			if (vpfe->started) {
-				/* only allowed if streaming is not started */
-				ret = -EBUSY;
-				break;
-			}
-			down_interruptible(&vpfe->lock);
-			/* make sure the other v4l2 related fields 
-			   have consistant settings */
-			*params = (*(ccdc_params_ycbcr *) arg);
-			vpfe->vwin = params->win;
-			if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
-				vpfe->field = V4L2_FIELD_INTERLACED;
-			} else if (params->buf_type ==
-				   CCDC_BUFTYPE_FLD_SEPARATED) {
-				vpfe->field = V4L2_FIELD_SEQ_TB;
-			}
-			if (params->pix_order == CCDC_PIXORDER_YCBYCR) {
-				vpfe->pixelfmt = V4L2_PIX_FMT_YUYV;
-			} else if (params->pix_order == CCDC_PIXORDER_CBYCRY) {
-				vpfe->pixelfmt = V4L2_PIX_FMT_UYVY;
-			}
-			up(&vpfe->lock);
-			break;
-		}
-	case VPFE_CMD_CONFIG_CCDC_RAW:
-		/* This command is used to configure driver for CCDC Raw 
-		 * mode parameters 
-		 */
-		{
-			ccdc_params_raw *ccd_params = &vpfe->ccdc_params_raw;
-			ccdc_config_params_raw *raw_params =
-			    (ccdc_config_params_raw *) arg;
-			unsigned int *fpc_virtaddr = NULL;
-			unsigned int *fpc_physaddr = NULL;
-
-			dev_dbg(vpfe_dev,
-				"\nStarting VPFE_CMD_CONFIG_CCDC_RAW ioctl");
-
-			/* copy parameter values for Raw Mode to vpfe_device, 
-			 * from arg passed by application 
-			 */
-			if ((ccd_params->frm_fmt != CCDC_FRMFMT_INTERLACED)
-			    && (raw_params->image_invert_enable == TRUE)) {
-				dev_err(vpfe_dev,
-					"\nImage invert not supported");
-				return -EINVAL;
-			}
-			ccd_params->image_invert_enable =
-			    raw_params->image_invert_enable;
-
-			dev_dbg(vpfe_dev, "\nimage_invert_enable = %d",
-				ccd_params->image_invert_enable);
-
-			ccd_params->data_sz = raw_params->data_sz;
-			dev_dbg(vpfe_dev, "\ndata_sz = %d",
-				ccd_params->data_sz);
-			ccd_params->alaw.b_alaw_enable =
-			    raw_params->alaw.b_alaw_enable;
-			dev_dbg(vpfe_dev, "\nALaw Enable = %d",
-				ccd_params->alaw.b_alaw_enable);
-			/* copy A-Law configurations to vpfe_device, from arg 
-			 * passed by application 
-			 */
-			if (ccd_params->alaw.b_alaw_enable) {
-				if ((raw_params->alaw.gama_wd > BITS_09_0)
-				    || (raw_params->alaw.gama_wd < BITS_15_6)
-				    || (raw_params->alaw.gama_wd <
-					raw_params->data_sz)) {
-					dev_err(vpfe_dev,
-						"\nInvalid data line select");
-					return -EINVAL;
-				}
-				ccd_params->alaw.gama_wd =
-				    raw_params->alaw.gama_wd;
-				dev_dbg(vpfe_dev, "\nALaw Gama width = %d",
-					ccd_params->alaw.gama_wd);
-			}
-
-			/* copy Optical Balck Clamping configurations to 
-			 * vpfe_device,from arg passed by application 
-			 */
-			ccd_params->blk_clamp.b_clamp_enable
-			    = raw_params->blk_clamp.b_clamp_enable;
-			dev_dbg(vpfe_dev, "\nb_clamp_enable = %d",
-				ccd_params->blk_clamp.b_clamp_enable);
-			if (ccd_params->blk_clamp.b_clamp_enable) {
-				/*gain */
-				ccd_params->blk_clamp.sgain =
-				    raw_params->blk_clamp.sgain;
-				dev_dbg(vpfe_dev, "\nblk_clamp.sgain = %d",
-					ccd_params->blk_clamp.sgain);
-				/*Start pixel */
-				ccd_params->blk_clamp.start_pixel
-				    = raw_params->blk_clamp.start_pixel;
-				dev_dbg(vpfe_dev,
-					"\nblk_clamp.start_pixel = %d",
-					ccd_params->blk_clamp.start_pixel);
-				/*No of line to be avg */
-				ccd_params->blk_clamp.sample_ln
-				    = raw_params->blk_clamp.sample_ln;
-				dev_dbg(vpfe_dev,
-					"\nblk_clamp.sample_ln = %d",
-					ccd_params->blk_clamp.sample_ln);
-				/*No of pixel/line to be avg */
-				ccd_params->blk_clamp.sample_pixel
-				    = raw_params->blk_clamp.sample_pixel;
-				dev_dbg(vpfe_dev,
-					"\nblk_clamp.sample_pixel  = %d",
-					ccd_params->blk_clamp.sample_pixel);
-			} else {	/* configure DCSub */
-
-				ccd_params->blk_clamp.dc_sub =
-				    raw_params->blk_clamp.dc_sub;
-				dev_dbg(vpfe_dev,
-					"\nblk_clamp.dc_sub  = %d",
-					ccd_params->blk_clamp.dc_sub);
-			}
-
-			/* copy BalckLevel Compansation configurations to 
-			 * vpfe_device,from arg passed by application 
-			 */
-			ccd_params->blk_comp.r_comp =
-			    raw_params->blk_comp.r_comp;
-			ccd_params->blk_comp.gr_comp =
-			    raw_params->blk_comp.gr_comp;
-			ccd_params->blk_comp.b_comp =
-			    raw_params->blk_comp.b_comp;
-			ccd_params->blk_comp.gb_comp =
-			    raw_params->blk_comp.gb_comp;
-			dev_dbg(vpfe_dev, "\nblk_comp.r_comp   = %d",
-				ccd_params->blk_comp.r_comp);
-			dev_dbg(vpfe_dev, "\nblk_comp.gr_comp  = %d",
-				ccd_params->blk_comp.gr_comp);
-			dev_dbg(vpfe_dev, "\nblk_comp.b_comp   = %d",
-				ccd_params->blk_comp.b_comp);
-			dev_dbg(vpfe_dev, "\nblk_comp.gb_comp  = %d",
-				ccd_params->blk_comp.gb_comp);
-
-			/* copy FPC configurations to vpfe_device,from  
-			 * arg passed by application
-			 */
-			ccd_params->fault_pxl.fpc_enable =
-			    raw_params->fault_pxl.fpc_enable;
-			dev_dbg(vpfe_dev, "\nfault_pxl.fpc_enable  = %d",
-				ccd_params->fault_pxl.fpc_enable);
-
-			if (ccd_params->fault_pxl.fpc_enable) {
-				fpc_physaddr =
-				    (unsigned int *)ccd_params->fault_pxl.
-				    fpc_table_addr;
-
-				fpc_virtaddr = (unsigned int *)
-				    phys_to_virt((unsigned long)
-						 fpc_physaddr);
-
-				/* Allocate memory for FPC table if current 
-				 * FPC table buffer is not big enough to 
-				 * accomodate FPC Number requested 
-				 */
-				if (raw_params->fault_pxl.fp_num !=
-				    ccd_params->fault_pxl.fp_num) {
-					if (fpc_physaddr != NULL) {
-						free_pages((unsigned long)
-							   fpc_virtaddr,
-							   get_order
-							   (ccd_params->
-							    fault_pxl.
-							    fp_num *
-							    FP_NUM_BYTES));
-
-					}
-
-					/* Allocate memory for FPC table */
-					fpc_virtaddr = (unsigned int *)
-					    __get_free_pages(GFP_KERNEL |
-							     GFP_DMA,
-							     get_order
-							     (raw_params->
-							      fault_pxl.
-							      fp_num *
-							      FP_NUM_BYTES));
-
-					if (fpc_virtaddr == NULL) {
-						dev_err(vpfe_dev,
-							"\n Unable to allocate \
-							memory for FPC");
-						return -1;
-					}
-					fpc_physaddr = (unsigned int *)
-					    virt_to_phys((void *)
-							 fpc_virtaddr);
-				}
-
-				/* Copy number of fault pixels and FPC table */
-				ccd_params->fault_pxl.fp_num =
-				    raw_params->fault_pxl.fp_num;
-				copy_from_user((void *)fpc_virtaddr,
-					       (void *)raw_params->
-					       fault_pxl.fpc_table_addr,
-					       (unsigned long)ccd_params->
-					       fault_pxl.fp_num * FP_NUM_BYTES);
-
-				ccd_params->fault_pxl.fpc_table_addr =
-				    (unsigned int)fpc_physaddr;
-
-			}
-			dev_dbg(vpfe_dev,
-				"\nEnd of VPFE_CMD_CONFIG_CCDC_RAW ioctl");
-			break;
-		}
-
-	case VPFE_CMD_CONFIG_TVP5146:
-		/* this can be used directly and bypass the V4L2 APIs */
-		{
-			/* the settings here must be consistant with that of
-			   the CCDC's,driver does not check the consistancy */
-			tvp5146_params *params = (tvp5146_params *) arg;
-			v4l2_std_id std = 0;
-			dev_dbg(vpfe_dev,
-				"\nStarting VPFE_CMD_CONFIG_TVP5146 ioctl");
-			if (vpfe->started) {
-				/* only allowed if streaming is not started */
-				ret = -EBUSY;
-				break;
-			}
-			down_interruptible(&vpfe->lock);
-			/* make sure the other v4l2 related fields have 
-			 * consistant settings 
-			 */
-			switch (params->mode & 0x7) {
-			case TVP5146_MODE_NTSC:
-				std = V4L2_STD_NTSC;
-				break;
-			case TVP5146_MODE_PAL:
-				std = V4L2_STD_PAL;
-				break;
-			case TVP5146_MODE_PAL_M:
-				std = V4L2_STD_PAL_M;
-				break;
-			case TVP5146_MODE_PAL_CN:
-				std = V4L2_STD_PAL_N;
-				break;
-			case TVP5146_MODE_SECAM:
-				std = V4L2_STD_SECAM;
-				break;
-			case TVP5146_MODE_PAL_60:
-				std = V4L2_STD_PAL_60;
-				break;
-			}
-			dev_dbg(vpfe_dev,
-				"\nVPFE_CMD_CONFIG_TVP5146:std = %d", (int)std);
-			if (params->mode & 0x8) {	/* square pixel mode */
-				std <<= 32;
-			}
-			/* auto-detection modes */
-			if (params->mode == TVP5146_MODE_AUTO) {
-				std = VPFE_STD_AUTO;
-			} else if (params->mode == TVP5146_MODE_AUTO_SQP) {
-				std = VPFE_STD_AUTO_SQP;
-			}
-
-			if (std & V4L2_STD_625_50) {
-				vpfe->bounds = pal_bounds;
-				vpfe->pixelaspect = pal_aspect;
-			} else if (std & V4L2_STD_525_60) {
-				vpfe->bounds = ntsc_bounds;
-				vpfe->pixelaspect = ntsc_aspect;
-			} else if (std & VPFE_STD_625_50_SQP) {
-				vpfe->bounds = palsp_bounds;
-				vpfe->pixelaspect = sp_aspect;
-			} else if (std & VPFE_STD_525_60_SQP) {
-				vpfe->bounds = ntscsp_bounds;
-				vpfe->pixelaspect = sp_aspect;
-			}
-			vpfe->std = std;
-			ret = tvp5146_ctrl(TVP5146_CONFIG, params);
-			dev_dbg(vpfe_dev,
-				"\nVPFE_CMD_CONFIG_TVP5146:ret = %d", (int)ret);
-			vpfe->tvp5146_params = *params;
-			up(&vpfe->lock);
-			dev_dbg(vpfe_dev,
-				"\nEnd VPFE_CMD_CONFIG_TVP5146 ioctl");
-			break;
-		}
-	case VPFE_CMD_S_MT9T001_PARAMS:
-		/* This command configures MT9T001 */
-		{
-			dev_dbg(vpfe_dev,
-				"\nStarting VPFE_CMD_S_MT9T001_PARAMS ioctl");
-			/* Call device control function to configure MT9T001 */
-			ret = vpfe->config_dev_fxn(MT9T001_SET_PARAMS, arg,
-						   vpfe->device_params);
-			dev_dbg(vpfe_dev,
-				"\nEnd VPFE_CMD_S_MT9T001_PARAMS ioctl");
-			break;
-		}
-	case VPFE_CMD_G_MT9T001_PARAMS:
-		/* This command returns MT9T001 configuration values to 
-		 * application. 
-		 */
-		{
-			dev_dbg(vpfe_dev,
-				"\nStarting VPFE_CMD_G_MT9T001_PARAMS ioctl");
-			/* Call device control function to get 
-			 * MT9T001 configuration values 
-			 */
-			ret = vpfe->config_dev_fxn(MT9T001_GET_PARAMS, arg,
-						   vpfe->device_params);
-			dev_dbg(vpfe_dev,
-				"\nEnd of VPFE_CMD_G_MT9T001_PARAMS ioctl");
-			break;
-		}
-	default:
-		dev_dbg(vpfe_dev, "\nDefault ioctl");
-		ret = -ENOIOCTLCMD;
-		break;
-	}			/* end switch(cmd) */
-	return ret;
-}
-
-/*
- * ======== vpfe_ioctl ========
- */
-static int vpfe_ioctl(struct inode *inode, struct file *file,
-		      unsigned int cmd, unsigned long arg)
-{
-	int ret;
-	dev_dbg(vpfe_dev, "\nStarting of vpfe_ioctl...");
-	ret = video_usercopy(inode, file, cmd, arg, vpfe_doioctl);
-	dev_dbg(vpfe_dev, "\n(vpfe_ioctl) video_usercopy done ...");
-	if ((ret >= 0) && (cmd == VIDIOC_S_FMT || cmd == VIDIOC_TRY_FMT)) {
-		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
-				     arg, vpfe_doioctl);
-	}
-	dev_dbg(vpfe_dev, "\nEnd of vpfe_ioctl...");
-	return ret;
-}
-
-/*
- * ======== vpfe_mmap ========
- */
-static int vpfe_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	dev_dbg(vpfe_dev, "\nStarting of vpfe_mmap...");
-	return videobuf_mmap_mapper(&vpfe_device.bufqueue, vma);
-}
-
-/*
- * ======== vpfe_open ========
- */
- /* Creates a file handle for video object. Initialize itwith default value */
-static int vpfe_open(struct inode *inode, struct file *filep)
-{
-	int minor = iminor(inode);
-	vpfe_obj *vpfe = NULL;
-	vpfe_fh *fh = NULL;
-
-	dev_dbg(vpfe_dev, "vpfe: open minor=%d\n", minor);
-
-	/* check to make sure the minor numbers match */
-	if (vpfe_device.video_dev && vpfe_device.video_dev->minor == minor) {
-		vpfe = &vpfe_device;
-	} else {		/* device not found here */
-		return -ENODEV;
-	}
-
-	/* allocate per filehandle data */
-	if ((fh = kmalloc(sizeof(*fh), GFP_KERNEL)) == NULL) {
-		return -ENOMEM;
-	}
-	filep->private_data = fh;
-	fh->dev = vpfe;
-	fh->io_allowed = FALSE;
-	fh->prio = V4L2_PRIORITY_UNSET;
-	v4l2_prio_open(&vpfe->prio, &fh->prio);
-	vpfe->usrs++;
-	dev_dbg(vpfe_dev, "\nvpfe_open done ...");
-	return 0;
-}
-
-/*
- * ======== vpfe_release ========
- */
- /* This function disables the CCDC, Deletes the buffer queue and frees
-  * the vpfe file handle. 
-  */
-static int vpfe_release(struct inode *inode, struct file *filep)
-{
-	vpfe_fh *fh = filep->private_data;
-	vpfe_obj *vpfe = fh->dev;
-	dev_dbg(vpfe_dev, "\nStarting of vpfe_release...");
-	down_interruptible(&vpfe->lock);
-	if (fh->io_allowed) {
-		vpfe->io_usrs = 0;
-		if (device_type == MT9T001) {
-			ccdc_vdhd_enable(FALSE);
-		}
-		ccdc_enable(FALSE);
-		vpfe->started = FALSE;
-		videobuf_queue_cancel(&vpfe->bufqueue);
-		vpfe->numbuffers = VPFE_DEFNUM_FBUFS;
-	}
-	vpfe->usrs--;
-	v4l2_prio_close(&vpfe->prio, &fh->prio);
-	filep->private_data = NULL;
-	if (fh != NULL)
-		kfree(fh);
-	up(&vpfe->lock);
-	dev_dbg(vpfe_dev, "\nEnd of vpfe_release...");
-	return 0;
-}
-
-static struct file_operations vpfe_fops = {
-	.owner = THIS_MODULE,
-	.open = vpfe_open,
-	.release = vpfe_release,
-	.ioctl = vpfe_ioctl,
-	.mmap = vpfe_mmap
-};
-
-static struct video_device vpfe_video_template = {
-	.name = "vpfe",
-	.type = VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
-	.hardware = 0,
-	.fops = &vpfe_fops,
-	.minor = -1,
-};
-
-static void vpfe_platform_release(struct device *device)
-{
-	/* This is called when the reference count goes to zero. */
-}
-
-/*
- * ======== vpfe_probe ========
- */
- /* This function will allocate video device initialize and 
-  * registers the device 
-  */
-static int __init vpfe_probe(struct device *device)
-{
-	struct video_device *vfd;
-	vpfe_obj *vpfe = &vpfe_device;
-	vpfe_dev = device;
-	dev_dbg(vpfe_dev, "\nStarting of vpfe_probe...");
-	/* alloc video device */
-	if ((vfd = video_device_alloc()) == NULL) {
-		return -ENOMEM;
-	}
-	*vfd = vpfe_video_template;
-	vfd->dev = device;
-	vfd->release = video_device_release;
-	snprintf(vfd->name, sizeof(vfd->name),
-		 "DM644X_VPFE_DRIVER_V%d.%d.%d",
-		 (VPFE_VERSION_CODE >> 16) & 0xff,
-		 (VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
-
-	vpfe->video_dev = vfd;
-	vpfe->usrs = 0;
-	vpfe->io_usrs = 0;
-	vpfe->started = FALSE;
-	vpfe->latest_only = TRUE;
-
-	v4l2_prio_init(&vpfe->prio);
-	init_MUTEX(&vpfe->lock);
-
-	/* register video device */
-	dev_dbg(vpfe_dev, "trying to register vpfe device.\n");
-	dev_dbg(vpfe_dev, "vpfe=%x,vpfe->video_dev=%x\n", (int)vpfe,
-		(int)&vpfe->video_dev);
-	if (video_register_device(vpfe->video_dev, VFL_TYPE_GRABBER, -1) < 0) {
-		video_device_release(vpfe->video_dev);
-		vpfe->video_dev = NULL;
-		return -1;
-	}
-
-	dev_dbg(vpfe_dev, "DM644X vpfe: driver version V%d.%d.%d loaded\n",
-		(VPFE_VERSION_CODE >> 16) & 0xff,
-		(VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
-
-	dev_dbg(vpfe_dev, "vpfe: registered device video%d\n",
-		vpfe->video_dev->minor & 0x1f);
-
-	/* all done */
-	return 0;
-}
-
-/*
- * ======== vpfe_remove ========
- */
-static int vpfe_remove(struct device *device)
-{
-	/* un-register device */
-	dev_dbg(vpfe_dev, "\nUnregistering device...");
-	video_unregister_device(vpfe_device.video_dev);
-
-	return 0;
-}
-
-static struct device_driver vpfe_driver = {
-	.name = "vpfe",
-	.bus = &platform_bus_type,
-	.probe = vpfe_probe,
-	.remove = vpfe_remove,
-};
-
-static struct platform_device _vpfe_device = {
-	.name = "vpfe",
-	.id = 1,
-	.dev = {
-		.release = vpfe_platform_release,
-		}
-};
-
-/*
- * ======== vpfe_init ========
- */
- /*This function allocates free pages and register the driver. Then reset the 
-  * CCDC and configure capture device with default parameters
-  */
-static int vpfe_init(void)
-{
-	int i = 0;
-	int fbuf_size;
-	ccdc_frmfmt frame_format;
-	void *mem;
-	int ret = 0;
-
-	if (device_type == TVP5146) {
-		fbuf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
-		vpfe_device = vpfe_device_ycbcr;
-		frame_format = vpfe_device.ccdc_params_ycbcr.frm_fmt;
-	}
-
-	else if (device_type == MT9T001) {
-		fbuf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
-		vpfe_device = vpfe_device_raw;
-		frame_format = vpfe_device.ccdc_params_raw.frm_fmt;
-	} else {
-		return -1;
-	}
-	/* allocate memory at initialization time to guarentee availability */
-	for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
-		mem =
-		    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-					     get_order(fbuf_size));
-		if (mem) {
-			unsigned long adr = (unsigned long)mem;
-			u32 size = PAGE_SIZE << (get_order(fbuf_size));
-			while (size > 0) {
-				/* make sure the frame buffers 
-				   are never swapped out of memory */
-				SetPageReserved(virt_to_page(adr));
-				adr += PAGE_SIZE;
-				size -= PAGE_SIZE;
-			}
-			vpfe_device.fbuffers[i] = (u8 *) mem;
-		} else {
-			while (--i >= 0) {
-				free_reserved_pages((unsigned long)
-						    vpfe_device.
-						    fbuffers[i], fbuf_size);
-			}
-			printk(KERN_INFO
-			       "frame buffer memory allocation failed.\n");
-			return -ENOMEM;
-		}
-	}
-	if (driver_register(&vpfe_driver) != 0) {
-		printk(KERN_INFO "driver registration failed\n");
-		return -1;
-	}
-	if (platform_device_register(&_vpfe_device) != 0) {
-		driver_unregister(&vpfe_driver);
-		printk(KERN_INFO "device registration failed\n");
-		return -1;
-	}
-
-	ccdc_reset();
-
-	if (device_type == TVP5146) {
-		ret = tvp5146_ctrl(TVP5146_INIT, NULL);
-		if (ret >= 0) {
-			ret = tvp5146_ctrl(TVP5146_RESET, NULL);
-			/* configure the tvp5146 to default parameters */
-			ret |=
-			    tvp5146_ctrl(TVP5146_CONFIG,
-					 &vpfe_device.tvp5146_params);
-		}
-		if (ret < 0) {
-			tvp5146_ctrl(TVP5146_CLEANUP, NULL);
-		}
-	} else if (device_type == MT9T001) {
-		/* enable video port in case of raw capture */
-		ccdc_enable_vport();
-		vpfe_device.config_dev_fxn = mt9t001_ctrl;
-		ret =
-		    vpfe_device.config_dev_fxn(MT9T001_INIT,
-					       &vpfe_device.std,
-					       &vpfe_device.device_params);
-	}
-
-	if (ret < 0) {
-		platform_device_unregister(&_vpfe_device);
-		driver_unregister(&vpfe_driver);
-		/* Free memory for all image buffers */
-		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
-			free_reserved_pages((unsigned long)
-					    vpfe_device.fbuffers[i], fbuf_size);
-		}
-		return -1;
-	}
-
-	/* setup interrupt handling */
-	/* request VDINT1 if progressive format */
-	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
-		ret = request_irq(IRQ_VDINT1, vdint1_isr, SA_INTERRUPT,
-				  "dm644xv4l2", (void *)&vpfe_device);
-		if (ret < 0) {
-			platform_device_unregister(&_vpfe_device);
-			driver_unregister(&vpfe_driver);
-			/* Free memory for all image buffers */
-			for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
-				free_reserved_pages((unsigned long)
-						    vpfe_device.
-						    fbuffers[i], fbuf_size);
-			}
-			return -1;
-		}
-	}
-	ret = request_irq(IRQ_VDINT0, vpfe_isr, SA_INTERRUPT,
-			  "dm644xv4l2", (void *)&vpfe_device);
-	if (ret < 0) {
-		platform_device_unregister(&_vpfe_device);
-		driver_unregister(&vpfe_driver);
-		/* Free memory for all image buffers */
-		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
-			free_reserved_pages((unsigned long)
-					    vpfe_device.fbuffers[i], fbuf_size);
-		}
-		free_irq(IRQ_VDINT1, &vpfe_device);
-		return -1;
-	}
-
-	printk(KERN_INFO "DaVinci v4l2 capture driver V1.0 loaded\n");
-	return 0;
-}
-
-/*
- * ======== vpfe_cleanup ========
- */
- /*This function unregisters the driver and free the allocated pages */
-static void vpfe_cleanup(void)
-{
-	int i = vpfe_device.numbuffers;
-	int buf_size;
-	ccdc_frmfmt frame_format;
-	unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
-
-	if (device_type == TVP5146) {
-		tvp5146_ctrl(TVP5146_CLEANUP, NULL);
-		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
-		frame_format = vpfe_device.ccdc_params_ycbcr.frm_fmt;
-	} else {
-		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
-		/* Free mt9t001 object memory */
-		vpfe_device.config_dev_fxn(MT9T001_CLEANUP, NULL,
-					   vpfe_device.device_params);
-		frame_format = vpfe_device.ccdc_params_raw.frm_fmt;
-	}
-
-	platform_device_unregister(&_vpfe_device);
-	driver_unregister(&vpfe_driver);
-	/* disable interrupt */
-	free_irq(IRQ_VDINT0, &vpfe_device);
-	/* Free VDINT1 if progressive format */
-	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
-		free_irq(IRQ_VDINT1, &vpfe_device);
-	}
-	fpc_physaddr = (unsigned int *)
-	    vpfe_device.ccdc_params_raw.fault_pxl.fpc_table_addr;
-
-	if (fpc_physaddr != NULL) {
-		fpc_virtaddr = (unsigned int *)
-		    phys_to_virt((unsigned long)fpc_physaddr);
-		free_pages((unsigned long)fpc_virtaddr,
-			   get_order(vpfe_device.ccdc_params_raw.fault_pxl.
-				     fp_num * FP_NUM_BYTES));
-	}
-
-	/* Free memory for all image buffers */
-	while (--i >= 0) {
-		free_reserved_pages((unsigned long)vpfe_device.
-				    fbuffers[i], buf_size);
-	}
-}
-
-module_init(vpfe_init);
-module_exit(vpfe_cleanup);
Index: linux-2.6.10/drivers/media/video/mt9t001.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/mt9t001.c
+++ /dev/null
@@ -1,1316 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-/* mt9t001.c */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/proc_fs.h>
-#include <linux/ctype.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/videodev.h>
-#include <linux/device.h>
-#include	<media/mt9t001.h>
-
-#define MT9T001_I2C_ENABLE 1
-
-/* i2c global variable for mt9t001*/
-static struct i2c_client mt9t001_i2c_client;
-static struct i2c_driver mt9t001_i2c_driver;
-static int mt9t001_i2c_registration = 0;
-struct device *mt9t001_i2c_dev;
-
-/*	Function prototype*/
-int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
-static int mt9t001_init(void *arg, void **params);
-static int mt9t001_cleanup(void *params);
-static int mt9t001_configpca9543a(void);
-static int mt9t001_setstd(void *arg, void *params);
-static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats);
-static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats);
-static int mt9t001_queryctrl(void *arg);
-static int mt9t001_setgain(int arg);
-static int mt9t001_getgain(int *arg);
-static int mt9t001_setparams(void *arg);
-static int mt9t001_getparams(void *arg);
-
-/*i2c function proto types*/
-static int i2c_read_reg(struct i2c_client *, unsigned char,
-			unsigned short *, bool);
-static int i2c_write_reg(struct i2c_client *, unsigned char,
-			 unsigned short, bool);
-static int _i2c_attach_client(struct i2c_client *, struct i2c_driver *,
-			      struct i2c_adapter *, int);
-static int _i2c_detach_client(struct i2c_client *);
-static int mt9t001_i2c_probe_adapter(struct i2c_adapter *);
-static int mt9t001_i2c_init(void);
-void mt9t001_i2c_cleanup(void);
-
-/* Parameters for  various format supported  */
-/*Format  is
-{
-	NUMBER OF PIXELS PER LINE, NUMBER OF LINES, 
-	HRIZONTAL BLANKING WIDTH, VERTICAL BLANKING WIDTH, 
-	SHUTTER WIDTH, ROW ADDRESS MODE, COL ADDRESS MODE,
-	BLACK_LEVEL,PIXEL CLOCK CONTROL, 
-	ROW START, COL START
-}
-*/
-
-const struct mt9t001_format_params MT9T001_VGA_30FPS =
-    { 1979, 1467, 21, 31, 822, 0x22, 0x22, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_VGA_60FPS =
-    { 1979, 1467, 21, 31, 582, 0x12, 0x12, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_SVGA_30FPS =
-    { 1639, 1239, 21, 31, 1042, 0x11, 0x11, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_SVGA_60FPS =
-    { 1639, 1239, 21, 31, 661, 0x01, 0x01, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_XGA_30FPS =
-    { 1039, 775, 100, 283, 783, 0x00, 0x00, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_480P_30FPS =
-    { 1471, 975, 350, 350, 898, 0x11, 0x11, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_480P_60FPS =
-    { 1471, 975, 52, 50, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_576P_25FPS =
-    { 1471, 1167, 424, 450, 500, 0x11, 0x11, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_576P_50FPS =
-    { 1471, 1167, 84, 48, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_720P_24FPS =
-    { 1299, 729, 300, 282, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_720P_30FPS =
-    { 1299, 729, 22, 220, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
-const struct mt9t001_format_params MT9T001_1080P_18FPS =
-    { 1935, 1082, 100, 25, 1095, 0x00, 0x00, 64, 0x8000, 0, 0 };
-
-void mt9t001_readregs(void)
-{
-	unsigned short temp = 0;
-	int err = 0;
-	unsigned char regcnt;
-	/* Here, 0x64 is number of registers for MT9T001 */
-	for (regcnt = 0; regcnt < 0x64; regcnt++) {
-		err = i2c_read_reg(&mt9t001_i2c_client, regcnt,
-				   &temp, MT9T001_I2C_CONFIG);
-		if (err >= 0) {
-			dev_dbg(mt9t001_i2c_dev,
-				"\nread back 0x%x = 0x%x...", regcnt, temp);
-		}
-	}
-}
-
-/*
- * ======== mt9t001_ctrl  ========
- */
-
-/*This function will provide different control commands for MT9T001 
-		configuration.*/
-int mt9t001_ctrl(unsigned int cmd, void *arg, void *params)
-{
-	int err = 0;
-	switch (cmd) {
-	case MT9T001_SET_PARAMS:
-		{
-
-			struct mt9t001_params *vpfe_mt9t001params =
-			    (struct mt9t001_params *)params;
-			struct mt9t001_params *user_mt9t001params =
-			    (struct mt9t001_params *)arg;
-
-			/* Update the global parameter of vpfe_obj */
-
-			if ((arg == NULL) || (params == NULL)) {
-				dev_err(mt9t001_i2c_dev, "Invalid argument for \
-							MT9T001_SET_PARAMS ");
-				return -1;
-			}
-
-			memcpy(vpfe_mt9t001params, user_mt9t001params,
-			       sizeof(struct mt9t001_params));
-
-			err = mt9t001_setparams(arg);
-			if (err < 0) {
-				dev_err(mt9t001_i2c_dev,
-					"\nMT9T001 set parameters fails...");
-				return err;
-			}
-			break;
-
-		}
-	case MT9T001_SET_STD:
-		{
-			err = mt9t001_setstd(arg, params);
-			if (err < 0) {
-				dev_err(mt9t001_i2c_dev,
-					"\nMT9T001 set standard fails...");
-				return err;
-			} else {
-				mt9t001_readregs();
-			}
-			break;
-		}
-	case MT9T001_GET_PARAMS:
-		{
-
-			struct mt9t001_params *vpfe_mt9t001params =
-			    (struct mt9t001_params *)params;
-			struct mt9t001_params *user_mt9t001params =
-			    (struct mt9t001_params *)arg;
-
-			err = mt9t001_getparams(arg);
-			if (err < 0) {
-				dev_err(mt9t001_i2c_dev,
-					"\nMT9T001 get parameters  fails...");
-				return err;
-			}
-			/* Update the global parameter of vpfe_obj */
-			memcpy(vpfe_mt9t001params, user_mt9t001params,
-			       sizeof(struct mt9t001_params));
-
-			break;
-		}
-	case MT9T001_INIT:
-		{
-			err = mt9t001_init(arg, params);
-			if (err < 0) {
-				printk(KERN_ERR
-				       "\n Unable to initialize MT9T001...");
-				return err;
-			}
-			break;
-		}
-	case MT9T001_CLEANUP:
-		{
-			mt9t001_cleanup(params);
-
-			break;
-		}
-	case VIDIOC_S_CTRL:
-		{
-			struct v4l2_control *ctrl = arg;
-
-			if (ctrl->id == V4L2_CID_GAIN) {
-				err = mt9t001_setgain((int)ctrl->value);
-				if (err < 0) {
-					dev_err(mt9t001_i2c_dev,
-						"\n MT9T001 set gain fails...");
-					return err;
-				}
-			} else {
-				err = -EINVAL;
-			}
-			break;
-		}
-	case VIDIOC_G_CTRL:
-		{
-			struct v4l2_control *ctrl = arg;
-
-			if (ctrl->id == V4L2_CID_GAIN) {
-				err = mt9t001_getgain((int *)
-						      &(ctrl->value));
-				if (err < 0) {
-					dev_err(mt9t001_i2c_dev,
-						"\n MT9T001 get gain fails...");
-					return err;
-				}
-			} else {
-				err = -EINVAL;
-			}
-			break;
-		}
-	case VIDIOC_QUERYCTRL:
-		{
-			err = mt9t001_queryctrl(arg);
-			break;
-		}
-	default:
-		{
-			dev_err(mt9t001_i2c_dev, "\n Undefined command");
-			return -1;
-		}
-
-	}
-	return err;
-}
-
-/*
- * ======== mt9t001_init  ========
- */
-/*	This function will set the video format standart*/
-static int mt9t001_init(void *arg, void **params)
-{
-	struct i2c_driver *driver = &mt9t001_i2c_driver;
-	struct mt9t001_params *temp_params = NULL;
-	int err = 0;
-
-#if MT9T001_I2C_ENABLE
-	/* Register MT9T001 I2C client */
-	err = i2c_add_driver(driver);
-	if (err) {
-		printk(KERN_ERR "Failed to register MT9T001 I2C client.\n");
-		return -1;
-	}
-	mt9t001_i2c_registration = MT9T001_I2C_REGISTERED;
-#endif
-	temp_params = kmalloc(sizeof(struct mt9t001_params), GFP_KERNEL);
-	if (temp_params == NULL) {
-		printk(KERN_ERR "\n Unable to allocate memory...");
-		return -1;
-	}
-	(*params) = temp_params;
-
-	err = mt9t001_configpca9543a();
-
-	/*Configure the MT9T001 in normalpower up mode */
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
-			     MT9T001_ROW_START_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
-			     MT9T001_COL_START_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
-			     MT9T001_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
-			     MT9T001_HEIGHT_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
-			     MT9T001_HBLANK_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
-			     MT9T001_VBLANK_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
-			     MT9T001_OUTPUT_CTRL_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |=
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
-			  MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT,
-			  MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
-			     MT9T001_SHUTTER_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
-			     MT9T001_PIXEL_CLK_CTRL_DEFAULT,
-			     MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESTART,
-			     MT9T001_RESTART_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_DELAY,
-			     MT9T001_SHUTTER_DELAY_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE1,
-			     MT9T001_READ_MODE1_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE2,
-			     MT9T001_READ_MODE2_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE3,
-			     MT9T001_READ_MODE3_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
-			     MT9T001_ROW_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
-			     MT9T001_COL_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
-			     MT9T001_GREEN1_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
-			     MT9T001_BLUE_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
-			     MT9T001_RED_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
-			     MT9T001_GREEN2_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
-			     MT9T001_GLOBAL_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
-			     MT9T001_BLACK_LEVEL_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
-			     MT9T001_CAL_COARSE_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
-			     MT9T001_CAL_TARGET_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
-			     MT9T001_GREEN1_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
-			     MT9T001_GREEN2_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
-			     MT9T001_RED_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
-			     MT9T001_BLUE_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
-			     MT9T001_BLK_LVL_CALIB_DEFAULT, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CHIP_ENABLE_SYNC,
-			     MT9T001_CHIP_ENABLE_SYNC_DEFAULT,
-			     MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
-			     MT9T001_RESET_ENABLE, MT9T001_I2C_CONFIG);
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
-			     MT9T001_RESET_DISABLE, MT9T001_I2C_CONFIG);
-	/* delay applying changes  */
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
-			     MT9T001_HALT_MODE, MT9T001_I2C_CONFIG);
-
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
-			     MT9T001_INVERT_PIXEL_CLK, MT9T001_I2C_CONFIG);
-
-	/*Configure the MT9T001 in normalpower up mode */
-	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
-			     MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		mt9t001_cleanup((*params));
-	} else {
-		/* Configure for default video standard */
-		err = mt9t001_setstd(arg, (*params));
-
-		if (err < 0) {
-			mt9t001_cleanup((*params));
-		}
-	}
-	return err;
-}
-
-static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats)
-{
-	int err = 0;
-	unsigned short val = 0;
-
-	/*Read the height width and blanking information required 
-	   for particular format */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
-			   &mt9tformats->row_size, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...height");
-		return err;
-	}
-
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
-			   &mt9tformats->col_size, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...width");
-		return err;
-	}
-
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
-			   &mt9tformats->h_blank, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...hblk");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
-			   &mt9tformats->v_blank, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...vblk");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...shutterwidth");
-		return err;
-	}
-	mt9tformats->shutter_width = val & MT9T001_SHUTTER_WIDTH_LOWER_MASK;
-
-	err =
-	    i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
-			 &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...upper");
-		return err;
-	}
-	mt9tformats->shutter_width |= ((val & MT9T001_SHUTTER_WIDTH_UPPER_MASK)
-				       << MT9T001_SHUTTER_WIDTH_UPPER_SHIFT);
-
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
-			   &mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmoderow");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
-			   &mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmodecol");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
-			   &mt9tformats->black_level, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...black_level");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
-			   &mt9tformats->row_start, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...rowstart");
-		return err;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_START,
-			   &mt9tformats->col_start, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...colstart");
-		return err;
-	}
-
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
-			   &mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...clkctrl");
-		return err;
-	}
-	return err;
-}
-
-static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats)
-{
-	int err = 0;
-
-	/*Write the height width and blanking information required 
-	   for particular format */
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
-			    mt9tformats->row_size, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...height");
-		return err;
-	}
-
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
-			    mt9tformats->col_size, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...width");
-		return err;
-	}
-	/* Configure for default video standard */
-
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
-			    mt9tformats->h_blank, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...hblk");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
-			    mt9tformats->v_blank, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...vblk");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
-			    (unsigned short)(mt9tformats->
-					     shutter_width &
-					     MT9T001_SHUTTER_WIDTH_LOWER_MASK),
-			    MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...shutterwidth");
-		return err;
-	}
-
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
-			  (unsigned short)(mt9tformats->
-					   shutter_width >>
-					   MT9T001_SHUTTER_WIDTH_UPPER_SHIFT),
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...upper");
-		return err;
-	}
-
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
-			    mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...addrmoderow");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
-			    mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...addrmodecol");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
-			    mt9tformats->black_level, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...black_level");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
-			    mt9tformats->row_start, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...rowstart");
-		return err;
-	}
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
-			    mt9tformats->col_start, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...colstart");
-		return err;
-	}
-
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
-			    mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...clkctrl");
-		return err;
-	}
-	/* applying changes  */
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
-			    MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
-
-	if (err < 0) {
-		printk(KERN_ERR "\n I2C write fails...outputctrl");
-		return err;
-	}
-
-	return err;
-}
-
-/*
- * ======== configPCA9543A  ========
- */
-/*	This function will configure PCA9543 control register*/
-static int mt9t001_configpca9543a()
-{
-	int err = 0;
-	/* Configure PCA9543A, here discard register address */
-	err = i2c_write_reg(&mt9t001_i2c_client, 0,
-			    PCA9543A_REGVAL, PCA9543A_I2C_CONFIG);
-	return err;
-}
-
-/*
- * ======== mt9t001_cleanup  ========
- */
-
-/*This function will free the memory allocated for mt9t001_params*/
-static int mt9t001_cleanup(void *params)
-{
-	struct i2c_driver *driver = &mt9t001_i2c_driver;
-	struct mt9t001_params *temp_params = (struct mt9t001_params *)params;
-	if (temp_params != NULL)
-		kfree(temp_params);
-	params = NULL;
-#if MT9T001_I2C_ENABLE
-	if (mt9t001_i2c_registration) {
-		i2c_detach_client(&mt9t001_i2c_client);
-		i2c_del_driver(driver);
-		mt9t001_i2c_client.adapter = NULL;
-		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
-	}
-#endif
-	return 0;
-}
-
-/*
- * ======== mt9t001_setstd  ========
- */
-
-/*	Function to set the video frame format*/
-static int mt9t001_setstd(void *arg, void *params)
-{
-	v4l2_std_id mode = *(v4l2_std_id *) arg;
-	struct mt9t001_format_params mt9tformats;
-	int err = 0;
-
-	/* Select configuration parameters as per video mode  */
-	if (mode == MT9T001_MODE_VGA_30FPS) {
-		mt9tformats = MT9T001_VGA_30FPS;
-	} else if (mode == MT9T001_MODE_VGA_60FPS) {
-		mt9tformats = MT9T001_VGA_60FPS;
-	} else if (mode == MT9T001_MODE_SVGA_30FPS) {
-		mt9tformats = MT9T001_SVGA_30FPS;
-	} else if (mode == MT9T001_MODE_SVGA_60FPS) {
-		mt9tformats = MT9T001_SVGA_60FPS;
-	} else if (mode == MT9T001_MODE_XGA_30FPS) {
-		mt9tformats = MT9T001_XGA_30FPS;
-	} else if (mode == MT9T001_MODE_480p_30FPS) {
-		mt9tformats = MT9T001_480P_30FPS;
-	} else if (mode == MT9T001_MODE_480p_60FPS) {
-		mt9tformats = MT9T001_480P_60FPS;
-	} else if (mode == MT9T001_MODE_576p_25FPS) {
-		mt9tformats = MT9T001_576P_25FPS;
-	} else if (mode == MT9T001_MODE_576p_50FPS) {
-		mt9tformats = MT9T001_576P_50FPS;
-	} else if (mode == MT9T001_MODE_720p_24FPS) {
-		mt9tformats = MT9T001_720P_24FPS;
-	} else if (mode == MT9T001_MODE_720p_30FPS) {
-		mt9tformats = MT9T001_720P_30FPS;
-	} else if (mode == MT9T001_MODE_1080p_18FPS) {
-		mt9tformats = MT9T001_1080P_18FPS;
-	} else {
-		printk(KERN_ERR "\n Invalid frame format");
-		return -1;
-	}
-
-	err = mt9t001_setformat(&mt9tformats);
-
-	return err;
-
-}
-
-/*
- * ======== mt9t001_setparams  ========
- */
-
-/* This function will configure MT9T001 for bayer pattern capture.*/
-static int mt9t001_setparams(void *arg)
-{
-	/*variable to store the return value of i2c read, write function */
-	int err = 0;
-	struct mt9t001_params *mt9t001params = (struct mt9t001_params *)arg;
-	unsigned short val;
-	if (arg == NULL) {
-		dev_err(mt9t001_i2c_dev, "Invalid argument in config MT9T001");
-		return -1;
-	}
-	/* set video format related parameters */
-	err = mt9t001_setformat(&mt9t001params->format);
-
-	/*Write the gain information */
-	val = (unsigned short)(mt9t001params->rgb_gain.green1_analog_gain
-			       & MT9T001_ANALOG_GAIN_MASK);
-
-	val |= ((mt9t001params->rgb_gain.green1_digital_gain
-		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN, val,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = (unsigned short)(mt9t001params->rgb_gain.red_analog_gain)
-	    & MT9T001_ANALOG_GAIN_MASK;
-	val |= (((mt9t001params->rgb_gain.red_digital_gain)
-		 << MT9T001_DIGITAL_GAIN_SHIFT)
-		& MT9T001_DIGITAL_GAIN_MASK);
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = (unsigned short)(mt9t001params->rgb_gain.blue_analog_gain)
-	    & MT9T001_ANALOG_GAIN_MASK;
-	val |= (((mt9t001params->rgb_gain.blue_digital_gain)
-		 << MT9T001_DIGITAL_GAIN_SHIFT)
-		& MT9T001_DIGITAL_GAIN_MASK);
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = (unsigned short)((mt9t001params->rgb_gain.green2_analog_gain)
-			       << MT9T001_ANALOG_GAIN_SHIFT) &
-	    MT9T001_ANALOG_GAIN_MASK;
-	val |= (((mt9t001params->rgb_gain.green2_digital_gain)
-		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN, val,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	/*Write the offset value in register */
-
-	val = mt9t001params->black_calib.green1_offset
-	    & MT9T001_GREEN1_OFFSET_MASK;
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = mt9t001params->black_calib.green2_offset
-	    & MT9T001_GREEN2_OFFSET_MASK;
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = mt9t001params->black_calib.red_offset & MT9T001_RED_OFFSET_MASK;
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET, val,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = mt9t001params->black_calib.blue_offset & MT9T001_BLUE_OFFSET_MASK;
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET, val,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	/*Write other black caliberation information */
-
-	val = (unsigned short)(mt9t001params->black_calib.manual_override)
-	    & MT9T001_MANUAL_OVERRIDE_MASK;
-	val |= ((mt9t001params->black_calib.disable_calibration)
-		<< MT9T001_DISABLE_CALLIBERATION_SHIFT)
-	    & MT9T001_DISABLE_CALLIBERATION_MASK;
-	val |= ((mt9t001params->black_calib.recalculate_black_level)
-		<< MT9T001_RECAL_BLACK_LEVEL_SHIFT)
-	    & MT9T001_RECAL_BLACK_LEVEL_MASK;
-	val |= ((mt9t001params->black_calib.lock_red_blue_calibration)
-		<< MT9T001_LOCK_RB_CALIBRATION_SHIFT)
-	    & MT9T001_LOCK_RB_CALLIBERATION_MASK;
-	val |= ((mt9t001params->black_calib.lock_green_calibration)
-		<< MT9T001_LOCK_GREEN_CALIBRATION_SHIFT)
-	    & MT9T001_LOCK_GREEN_CALLIBERATION_MASK;
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	/*Write Thresholds Value */
-
-	val = (unsigned short)mt9t001params->black_calib.low_coarse_thrld
-	    & MT9T001_LOW_COARSE_THELD_MASK;
-	val |= (mt9t001params->black_calib.high_coarse_thrld
-		<< MT9T001_HIGH_COARSE_THELD_SHIFT) &
-	    MT9T001_HIGH_COARSE_THELD_MASK;
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE, val,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	val = (unsigned short)mt9t001params->black_calib.low_target_thrld
-	    & MT9T001_LOW_TARGET_THELD_MASK;
-	val |= (mt9t001params->black_calib.high_target_thrld
-		<< MT9T001_HIGH_TARGET_THELD_SHIFT)
-	    & MT9T001_HIGH_TARGET_THELD_MASK;
-	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
-			    val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-
-	dev_dbg(mt9t001_i2c_dev, "\nEnd of configMT9T001...");
-	return 0;
-
-}
-
-/*
- * ======== queryctrl ========
- */
- /* This function will return parameter values for control command passed */
-static int mt9t001_queryctrl(void *arg)
-{
-	struct v4l2_queryctrl *queryctrl = arg;
-	int ret = 0;
-	int id = queryctrl->id;
-	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_queryctrl...");
-	if (queryctrl == NULL) {
-		dev_err(mt9t001_i2c_dev,
-			"\n Invalid argument in query control");
-		return -1;
-	}
-
-	/* initialize queryctrl with 0 */
-	memset(queryctrl, 0, sizeof(*queryctrl));
-	queryctrl->id = id;
-	switch (id) {
-	case V4L2_CID_GAIN:
-		strcpy(queryctrl->name, "GAIN");
-		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
-		queryctrl->minimum = MT9T001_GAIN_MINVAL;
-		queryctrl->maximum = MT9T001_GAIN_MAXVAL;
-		queryctrl->step = MT9T001_GAIN_STEP;
-		queryctrl->default_value = MT9T001_GAIN_DEFAULTVAL;
-		break;
-	default:
-		if (id < V4L2_CID_LASTP1)
-			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
-		else
-			ret = -EINVAL;
-		break;
-	}			/* end switch (id) */
-	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_queryctrl...");
-	return ret;
-}
-
-/*
- * ======== mt9t001_setgain  ========
- */
-
-/*	This function will set the global gain of MT9T001*/
-static int mt9t001_setgain(int arg)
-{
-
-	unsigned short gain = (unsigned short)arg;
-	int err = 0;
-	dev_dbg(mt9t001_i2c_dev,
-		"\nStarting mt9t001_setgain with gain = %d...", (int)gain);
-	err =
-	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN, gain,
-			  MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
-		return err;
-	}
-	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_setgain...");
-	return err;
-}
-
-/*
- * ======== mt9t001_getgain  ========
- */
-
-/*	This function will get the global gain of MT9T001*/
-static int mt9t001_getgain(int *arg)
-{
-	unsigned short gain;
-	int err = 0;
-	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getgain...");
-	if (arg == NULL) {
-		dev_err(mt9t001_i2c_dev,
-			"\nInvalid argument pointer in get gain function");
-		return -1;
-	}
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
-			   &gain, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C reads fails...");
-		return err;
-	}
-	*arg = gain;
-	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_getgain...");
-	return err;
-}
-
-/*
- * ======== mt9t001_getparams  ========
- */
-
-/*This function will get MT9T001 configuration values.*/
-
-static int mt9t001_getparams(void *arg)
-{
-
-	struct mt9t001_params *params = (struct mt9t001_params *)arg;
-	unsigned short val;
-	int err = 0;
-	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getparams");
-
-	/* get video format related parameters */
-	err = mt9t001_getformat(&params->format);
-
-	if (err < 0) {
-		return err;
-	}
-	/*      Read green1 gain */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->rgb_gain.green1_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
-	params->rgb_gain.green1_digital_gain =
-	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
-
-	/*      Read blue gain */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->rgb_gain.blue_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
-	params->rgb_gain.blue_digital_gain =
-	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
-
-	/*      Read red gain */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->rgb_gain.red_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
-	params->rgb_gain.red_digital_gain =
-	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
-
-	/*      Read green2 gain */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->rgb_gain.green2_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
-	params->rgb_gain.green2_digital_gain =
-	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
-
-	/*      Read green1 offset */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.green1_offset = val & MT9T001_GREEN1_OFFSET_MASK;
-
-	/*      Read green2 offset */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.green2_offset = val & MT9T001_GREEN2_OFFSET_MASK;
-
-	/*      Read red offset */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.red_offset = val & MT9T001_RED_OFFSET_MASK;
-
-	/*      Read blue offset */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.blue_offset = val & MT9T001_BLUE_OFFSET_MASK;
-
-	/*      Read Black level caliberation information */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.manual_override =
-	    val & MT9T001_MANUAL_OVERRIDE_MASK;
-	params->black_calib.disable_calibration =
-	    (val & MT9T001_DISABLE_CALLIBERATION_MASK)
-	    >> MT9T001_DISABLE_CALLIBERATION_SHIFT;
-	params->black_calib.recalculate_black_level =
-	    (val & MT9T001_RECAL_BLACK_LEVEL_MASK)
-	    >> MT9T001_RECAL_BLACK_LEVEL_SHIFT;
-	params->black_calib.lock_red_blue_calibration =
-	    (val & MT9T001_LOCK_RB_CALLIBERATION_MASK)
-	    >> MT9T001_LOCK_RB_CALIBRATION_SHIFT;
-	params->black_calib.lock_green_calibration =
-	    (val & MT9T001_LOCK_GREEN_CALLIBERATION_MASK)
-	    >> MT9T001_LOCK_GREEN_CALIBRATION_SHIFT;
-
-	/*      Read Black Level Caliberation Coarse Threshold Value */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.low_coarse_thrld = val
-	    & MT9T001_LOW_COARSE_THELD_MASK;
-	params->black_calib.high_coarse_thrld =
-	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
-	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
-
-	/*      Read Black Level Caliberation Target Threshold Value */
-	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
-			   &val, MT9T001_I2C_CONFIG);
-	if (err < 0) {
-		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
-		return err;
-	}
-	params->black_calib.low_target_thrld = val
-	    & MT9T001_LOW_TARGET_THELD_MASK;
-	params->black_calib.high_target_thrld =
-	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
-	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
-
-	dev_dbg(mt9t001_i2c_dev, "\nEnd of getparamsMT9T001...");
-	return 0;
-}
-
-/*
- * ======== i2c_read_reg  ========
- */
-
-/*This function is used to read value from register for i2c client. */
-
-static int i2c_read_reg(struct i2c_client *client, unsigned char reg,
-			unsigned short *val, bool configdev)
-{
-	int err = 0;
-#ifdef MT9T001_I2C_ENABLE
-	struct i2c_msg msg[1];
-	unsigned char data[2];
-
-	if (!client->adapter) {
-		err = -ENODEV;
-	} else if (configdev == PCA9543A_I2C_CONFIG) {
-		/* if device is PCA9543A then discard reg value, set PCA9543A 
-		 * address and directly read the data 
-		 */
-		msg->addr = PCA9543A_I2C_ADDR;
-		msg->flags = I2C_M_RD;
-		msg->len = I2C_ONE_BYTE_TRANSFER;
-		msg->buf = data;
-
-		err = i2c_transfer(client->adapter, msg, 1);
-
-		if (err >= 0) {
-			*val = (unsigned short)data[0];
-		} else {
-			dev_err(mt9t001_i2c_dev,
-				"\n ERROR in PCA9543A control register read\n");
-		}
-
-	} else if (configdev == MT9T001_I2C_CONFIG) {
-		msg->addr = client->addr;
-		msg->flags = 0;
-		msg->len = I2C_ONE_BYTE_TRANSFER;
-		msg->buf = data;
-		data[0] = reg;
-		err = i2c_transfer(client->adapter, msg, 1);
-		if (err >= 0) {
-			msg->flags = I2C_M_RD;
-			msg->len = I2C_TWO_BYTE_TRANSFER;	/* 2 byte read */
-			err = i2c_transfer(client->adapter, msg, 1);
-			if (err >= 0) {
-				*val = ((data[0] & I2C_TXRX_DATA_MASK)
-					<< I2C_TXRX_DATA_SHIFT)
-				    | (data[1] & I2C_TXRX_DATA_MASK);
-			}
-		}
-	}
-#endif
-	return err;
-}
-
-/*
- * ======== i2c_write_reg  ========
- */
-/*This function is used to write value into register for i2c client. */
-static int i2c_write_reg(struct i2c_client *client, unsigned char reg,
-			 unsigned short val, bool configdev)
-{
-	int err = 0;
-	int trycnt = 0;
-	unsigned short readval = 0;
-
-#ifdef MT9T001_I2C_ENABLE
-
-	struct i2c_msg msg[1];
-	unsigned char data[3];
-	err = -1;
-	while ((err < 0) && (trycnt < 5)) {
-		trycnt++;
-		if (!client->adapter) {
-			err = -ENODEV;
-		} else if (configdev == PCA9543A_I2C_CONFIG) {
-			/* if device is PCA9543A then discard reg value
-			 * and set PCA9543A I2C address 
-			 */
-			msg->addr = PCA9543A_I2C_ADDR;
-			msg->flags = 0;
-			msg->len = I2C_ONE_BYTE_TRANSFER;
-			msg->buf = data;
-			data[0] = (unsigned char)(val & I2C_TXRX_DATA_MASK);
-
-			err = i2c_transfer(client->adapter, msg, 1);
-			if (err < 0) {
-				printk
-				    ("\n ERROR in PCA9543A  register write\n");
-			}
-		} else if (configdev == MT9T001_I2C_CONFIG) {
-			msg->addr = client->addr;
-			msg->flags = 0;
-			msg->len = I2C_THREE_BYTE_TRANSFER;
-			msg->buf = data;
-			data[0] = reg;
-			data[1] = (val & I2C_TXRX_DATA_MASK_UPPER) >>
-			    I2C_TXRX_DATA_SHIFT;
-			data[2] = (val & I2C_TXRX_DATA_MASK);
-			err = i2c_transfer(client->adapter, msg, 1);
-			if (err >= 0) {
-				err =
-				    i2c_read_reg(&mt9t001_i2c_client, reg,
-						 &readval, MT9T001_I2C_CONFIG);
-				if ((err >= 0) && (val != readval)) {
-					printk
-					    ("\n ERROR: i2c readback failed\n");
-				}
-				readval = 0;
-			}
-		}
-	}
-#endif
-	if (err < 0) {
-		printk(KERN_INFO "\n I2C write failed");
-	}
-	return err;
-}
-
-/*
- * ======== _i2c_attach_client  ========
- */
-/* This function is used to attach i2c client */
-static int _i2c_attach_client(struct i2c_client *client,
-			      struct i2c_driver *driver,
-			      struct i2c_adapter *adap, int addr)
-{
-	int err = 0;
-#ifdef MT9T001_I2C_ENABLE
-	if (client->adapter) {
-		err = -EBUSY;	/* our client is already attached */
-	} else {
-		client->addr = addr;
-		client->flags = I2C_CLIENT_ALLOW_USE;
-		client->driver = driver;
-		client->adapter = adap;
-
-		err = i2c_attach_client(client);
-		if (err) {
-			client->adapter = NULL;
-		}
-	}
-#endif
-	return err;
-}
-
-/*
- * ======== _i2c_detach_client  ========
- */
-/* This function is used to detach i2c client */
-static int _i2c_detach_client(struct i2c_client *client)
-{
-	int err = 0;
-#ifdef MT9T001_I2C_ENABLE
-	if (!client->adapter) {
-		return -ENODEV;	/* our client isn't attached */
-	} else {
-		err = i2c_detach_client(client);
-		client->adapter = NULL;
-	}
-#endif
-	return err;
-}
-
-/*
- * ======== mt9t001_i2c_probe_adapter  ========
- */
-
-/*This function is used to probe adapter for i2c_client. It returns
-    0 if i2c_client is attached to adapter and error code on failure.*/
-static int mt9t001_i2c_probe_adapter(struct i2c_adapter *adap)
-{
-	mt9t001_i2c_dev = &(adap->dev);
-	return _i2c_attach_client(&mt9t001_i2c_client, &mt9t001_i2c_driver,
-				  adap, MT9T001_I2C_ADDR);
-}
-
-/*
- * ======== mt9t001_i2c_init  ========
- */
-
-/*	This function is used to initialize the i2c*/
-static int mt9t001_i2c_init(void)
-{
-	int err = 0;
-#ifdef MT9T001_I2C_ENABLE
-	struct i2c_driver *driver = &mt9t001_i2c_driver;
-
-	driver->owner = THIS_MODULE;
-	strlcpy(driver->name, "MT9T001 CMOS sensor I2C driver",
-		sizeof(driver->name));
-	driver->id = I2C_DRIVERID_EXP0;
-	driver->flags = I2C_DF_NOTIFY;
-	driver->attach_adapter = mt9t001_i2c_probe_adapter;
-	driver->detach_client = _i2c_detach_client;
-#endif
-	return err;
-}
-
-/*
- * ======== mt9t001_i2c_cleanup  ========
- */
-
-void mt9t001_i2c_cleanup(void)
-{
-#ifdef MT9T001_I2C_ENABLE
-	struct i2c_driver *driver = &mt9t001_i2c_driver;
-
-	if (mt9t001_i2c_registration) {
-		i2c_detach_client(&mt9t001_i2c_client);
-		i2c_del_driver(driver);
-		mt9t001_i2c_client.adapter = NULL;
-		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
-	}
-#endif
-}
-
-module_init(mt9t001_i2c_init);
-module_exit(mt9t001_i2c_cleanup);
-
-EXPORT_SYMBOL(mt9t001_ctrl);
-MODULE_LICENSE("GPL");
-
-/**********************************************************************/
-/* End of file                                                        */
-/**********************************************************************/
Index: linux-2.6.10/drivers/media/video/tvp5146.c
===================================================================
--- linux-2.6.10.orig/drivers/media/video/tvp5146.c
+++ /dev/null
@@ -1,795 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* tvp5146.c */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/proc_fs.h>
-#include <linux/ctype.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/videodev.h>
-#include <linux/device.h>
-#include <media/tvp5146.h>
-
-static struct i2c_client tvp5146_i2c_client;
-static struct i2c_driver tvp5146_i2c_driver;
-static int tvp5146_i2c_registration = 0;
-struct device *tvp5146_i2c_dev;
-
-static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
-static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
-
-static int configtvp5146(void *arg);
-static int clrtvp5146lostlock(void);
-static int enabletvp5146agc(int arg);
-static int getctrl(void *arg);
-static int gettvp5146status(void *arg);
-static int powerdowntvp5146(int powerdownenable);
-static int queryctrl(void *arg);
-static int resettvp5146(void);
-static int setctrl(void *arg);
-static int settvp5146amuxmode(int mode);
-static int settvp5146brightness(int arg);
-static int settvp5146contrast(int arg);
-static int settvp5146hue(int arg);
-static int settvp5146saturation(int arg);
-static int settvp5146std(int arg);
-static int setup656sync(tvp5146_params * tvp5146params);
-
-/*
- * ======== tvp5146_init  ========
- */
-/* This function is used initialize TVP5146 i2c client */
-static int tvp5146_init(void)
-{
-	int err;
-	struct i2c_driver *driver = &tvp5146_i2c_driver;
-
-	err = i2c_add_driver(driver);
-	if (err) {
-		printk(KERN_ERR "Failed to register TVP5146 I2C client.\n");
-	} else {
-		tvp5146_i2c_registration = TVP5146_I2C_REGISTERED;
-	}
-	return err;
-}
-
-/*
- * ======== tvp5146_cleanup  ========
- */
-/* This function is used detach TVP5146 i2c client */
-static void tvp5146_cleanup(void)
-{
-	struct i2c_driver *driver = &tvp5146_i2c_driver;
-	if (tvp5146_i2c_registration) {
-		i2c_detach_client(&tvp5146_i2c_client);
-		i2c_del_driver(driver);
-		tvp5146_i2c_client.adapter = NULL;
-		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
-	}
-}
-
-/*
- * ======== configtvp5146 ========
- */
-/*This function will configure TVP5146 as per arguments passed*/
-static int configtvp5146(void *arg)
-{
-	tvp5146_params *tvp5146params = (tvp5146_params *) arg;
-	int ret = 0;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting configtvp5146...");
-	ret |= setup656sync(tvp5146params);
-	ret |= settvp5146amuxmode(tvp5146params->amuxmode);
-	ret |= settvp5146std(tvp5146params->mode);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of configtvp5146...");
-	return ret;
-}
-
-/*
- * ======== clrtvp5146lostlock  ========
- */
- /*This function is used to clear lost lock bit in TVP5146 register. */
-static int clrtvp5146lostlock(void)
-{
-	int ret = 0;
-	u8 clr = 1;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting clrtvp5146lostlock...");
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x39, clr);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd clrtvp5146lostlock...");
-	return ret;
-}
-
-/*
- * ========  enabletvp5146agc ========
- */
- /* This function is used to enable automatic gain control in TVP5146 */
-static int enabletvp5146agc(int arg)
-{
-	int ret = 0;
-	int agc;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting enabletvp5146agc...");
-	if (arg == TRUE) {
-		agc = 0xF;
-	} else {
-		agc = 0xC;
-	}
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x01, agc);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd enabletvp5146agc...");
-	return ret;
-}
-
-/*
- * ========  gettvpctrl ========
- */
- /* This function is used to get control value for different control commands */
-static int getctrl(void *arg)
-{
-	struct v4l2_control *ctrl = arg;
-	int ret = 0;
-	u8 value;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting getctrl of TVP5146...");
-	switch (ctrl->id) {
-	case V4L2_CID_BRIGHTNESS:
-		ret = i2c_read_reg(&tvp5146_i2c_client, 0x09, &value);
-		ctrl->value = value;
-		break;
-	case V4L2_CID_CONTRAST:
-		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0A, &value);
-		ctrl->value = value;
-		break;
-	case V4L2_CID_SATURATION:
-		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0B, &value);
-		ctrl->value = value;
-		break;
-	case V4L2_CID_HUE:
-		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0C, &value);
-		ctrl->value = value;
-		break;
-	case V4L2_CID_AUTOGAIN:
-		ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &value);
-		if ((value & 0x3) == 3) {
-			ctrl->value = TRUE;
-		} else {
-			ctrl->value = FALSE;
-		}
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of getctrl...");
-	return ret;
-}
-
-/*
- * ========  gettvp5146std ========
- */
- /* This function returns detected TVP5146 input standard */
-static int gettvp5146std(tvp5146_mode * mode)
-{
-	int ret = 0;
-	u8 output1;
-	u8 std;
-	u8 lock_status;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting of gettvp5146std...");
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x2, &std);
-	std &= 0x7;
-	if (std == TVP5146_MODE_AUTO) {
-		ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
-	}
-	std &= 0x7;
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
-	*mode = std | ((output1 & 0x80) >> 4);	/* square pixel status */
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &lock_status);
-	if ((lock_status & 0xe) != 0xe) {
-		/* not quite locked */
-		ret = -EAGAIN;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146std...");
-	return ret;
-}
-
-/*
- * ========  gettvp5146status ========
- */
- /* This function gets TVP5146 configuration values */
-static int gettvp5146status(void *arg)
-{
-	int ret = 0;
-	tvp5146_status *status = (tvp5146_status *) arg;
-	u8 agc, brightness, contrast, hue, saturation;
-	u8 status_byte;
-	u8 std;
-	u8 output1;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting gettvp5146status...");
-	ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &agc);
-	if ((agc & 0x3) == 3) {
-		status->agc_enable = TRUE;
-	} else {
-		status->agc_enable = FALSE;
-	}
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x09, &brightness);
-	status->brightness = brightness;
-
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0A, &contrast);
-	status->contrast = contrast;
-
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0B, &saturation);
-	status->saturation = saturation;
-
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0C, &hue);
-	status->hue = hue;
-
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &status_byte);
-	status->field_rate = (status_byte & 0x20) ? 50 : 60;
-	status->lost_lock = (status_byte & 0x10) >> 4;
-	status->csubc_lock = (status_byte & 0x8) >> 3;
-	status->v_lock = (status_byte & 0x4) >> 2;
-	status->h_lock = (status_byte & 0x2) >> 1;
-
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
-	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
-	if (std | 0x80) {	/* auto switch mode */
-		status->video_std = TVP5146_MODE_AUTO;
-	} else {
-		status->video_std = std;
-	}
-	status->video_std |= ((output1 & 0x80) >> 4);	/* square pixel status */
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146status...");
-	return ret;
-}
-
-/*
- * ======== powerdowntvp5146 ========
- */
- /* This function will put TVP5146 in power down/up mode */
-static int powerdowntvp5146(int powerdownenable)
-{
-	u8 powerdownsettings = 0x01;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting powerdowntvp5146...");
-	/*Put _tvp5146 in power down mode */
-	if (!powerdownenable) {
-		powerdownsettings = 0x00;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of powerdowntvp5146...");
-	return i2c_write_reg(&tvp5146_i2c_client, 0x03, powerdownsettings);
-}
-
-/*
- * ======== resettvp5146========
- */
-  /* This function will configure TVP5146 with default values */
-static int resettvp5146(void)
-{
-	tvp5146_params tvp5146params = { 0 };
-	dev_dbg(tvp5146_i2c_dev, "\nStarting resettvp5146...");
-
-	tvp5146params.enablebt656sync = TRUE;
-	tvp5146params.data_width = TVP5146_WIDTH_8BIT;
-
-	setup656sync(&tvp5146params);
-
-	settvp5146amuxmode(TVP5146_AMUX_COMPOSITE);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of resettvp5146...");
-	return powerdowntvp5146(FALSE);
-}
-
-/*
- * ======== queryctrl ========
- */
-  /* This function will return parameter values for control command passed */
-static int queryctrl(void *arg)
-{
-	struct v4l2_queryctrl *queryctrl = arg;
-	int ret = 0;
-	int id = queryctrl->id;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting queryctrl...");
-	memset(queryctrl, 0, sizeof(*queryctrl));
-	queryctrl->id = id;
-	switch (id) {
-	case V4L2_CID_BRIGHTNESS:
-		strcpy(queryctrl->name, "BRIGHTNESS");
-		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
-		queryctrl->minimum = 0;
-		queryctrl->maximum = 255;
-		queryctrl->step = 1;
-		queryctrl->default_value = 128;
-		break;
-	case V4L2_CID_CONTRAST:
-		strcpy(queryctrl->name, "CONTRAST");
-		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
-		queryctrl->minimum = 0;
-		queryctrl->maximum = 255;
-		queryctrl->step = 1;
-		queryctrl->default_value = 128;
-		break;
-
-	case V4L2_CID_SATURATION:
-		strcpy(queryctrl->name, "SATURATION");
-		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
-		queryctrl->minimum = 0;
-		queryctrl->maximum = 255;
-		queryctrl->step = 1;
-		queryctrl->default_value = 128;
-		break;
-	case V4L2_CID_HUE:
-		strcpy(queryctrl->name, "HUE");
-		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
-		queryctrl->minimum = -128;	/* -180 DEGREE */
-		queryctrl->maximum = 127;	/* 180  DEGREE */
-		queryctrl->step = 1;
-		queryctrl->default_value = 0;	/* 0 DEGREE */
-		break;
-
-	case V4L2_CID_AUTOGAIN:
-		strcpy(queryctrl->name, "Automatic Gain Control");
-		queryctrl->type = V4L2_CTRL_TYPE_BOOLEAN;
-		queryctrl->minimum = 0;
-		queryctrl->maximum = 1;
-		queryctrl->step = 1;
-		queryctrl->default_value = 1;
-		break;
-	default:
-		if (id < V4L2_CID_LASTP1)
-			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
-		else
-			ret = -EINVAL;
-		break;
-	}			/* end switch (id) */
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of queryctrl...");
-	return ret;
-}
-
-/*
- * ======== setctrl ========
- */
-  /* This function will set parameter values for control command passed */
-static int setctrl(void *arg)
-{
-	struct v4l2_control *ctrl = arg;
-	int ret = 0;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting setctrl...");
-	switch (ctrl->id) {
-	case V4L2_CID_BRIGHTNESS:
-		ret = settvp5146brightness(ctrl->value);
-		break;
-	case V4L2_CID_CONTRAST:
-		ret = settvp5146contrast(ctrl->value);
-		break;
-	case V4L2_CID_SATURATION:
-		ret = settvp5146saturation(ctrl->value);
-		break;
-	case V4L2_CID_HUE:
-		ret = settvp5146hue(ctrl->value);
-		break;
-	case V4L2_CID_AUTOGAIN:
-		ret = enabletvp5146agc(ctrl->value);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of setctrl...");
-	return ret;
-}
-
-/*
- * ======== settvp5146amuxmode ========
- */
- /* This function is used to configure analog interface */
-static int settvp5146amuxmode(int arg)
-{
-	u8 input_sel;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146amuxmode...");
-	if (arg == TVP5146_AMUX_COMPOSITE) {	/* composite */
-		input_sel = 0x05;
-	} else if (arg == TVP5146_AMUX_SVIDEO) {	/* s-video */
-		input_sel = 0x46;
-	} else {
-		return -EINVAL;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146amuxmode...");
-	return i2c_write_reg(&tvp5146_i2c_client, 0x00, input_sel);
-}
-
-/*
- * ======== settvp5146brightness ========
- */
- /* This function is used to configure brightness */
-static int settvp5146brightness(int arg)
-{
-	int ret = 0;
-	u8 brightness = (u8) arg;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146brightness...");
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x09, brightness);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146brightness...");
-	return ret;
-}
-
-/*
-* ======== settvp5146contrast ========
-*/
- /* This function is used to configure contrast */
-static int settvp5146contrast(int arg)
-{
-	int ret = 0;
-	u8 contrast = (u8) arg;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146contrast...");
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0A, contrast);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146contrast...");
-	return ret;
-}
-
-/*
-* ======== settvp5146hue ========
-*/
- /* This function is used to configure hue value */
-static int settvp5146hue(int arg)
-{
-	int ret = 0;
-	u8 hue = (u8) arg;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146hue...");
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0C, hue);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146hue...");
-	return ret;
-}
-
-/*
-* ======== settvp5146saturation ========
-*/
- /* This function is used to configure saturation value */
-static int settvp5146saturation(int arg)
-{
-	int ret = 0;
-	u8 saturation = (u8) arg;
-	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146saturation...");
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0B, saturation);
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146saturation...");
-	return ret;
-}
-
-/*
-* ======== settvp5146std ========
-*/
-/* This function is used to configure TVP5146 for video standard passed 
-  *by application
-  */
-static int settvp5146std(int arg)
-{
-	int ret = 0;
-	u8 std = (u8) arg & 0x7;	/* the 4th-bit is for squre pixel sampling */
-	u8 output1;
-	dev_dbg(tvp5146_i2c_dev, "\nStart settvp5146std...");
-	/* setup the sampling rate: 601 or square pixel */
-	dev_dbg(tvp5146_i2c_dev, "reading i2c registers.\n");
-	ret = i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
-	output1 |= ((arg & 0x8) << 4);
-	ret = i2c_write_reg(&tvp5146_i2c_client, 0x33, output1);
-
-	/* setup the video standard */
-	ret |= i2c_write_reg(&tvp5146_i2c_client, 0x02, std);
-	/* if autoswitch mode, enable all modes for autoswitch */
-	if (std == TVP5146_MODE_AUTO) {
-		u8 mask = 0x3F;	/* enable autoswitch for  all standards */
-		ret = i2c_write_reg(&tvp5146_i2c_client, 0x04, mask);
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146std...");
-	return ret;
-}
-
-/*
- * ======== setup656sync ========
- */
- /* This function will configure TVP5146 output data formatting */
-static int setup656sync(tvp5146_params * tvp5146params)
-{
-	int output1, output2, output3, output4;
-	int output5, output6;
-	int ret = 0;
-
-	dev_dbg(tvp5146_i2c_dev, "\nStarting setup656sync...");
-	if ((tvp5146params->enablebt656sync)
-	    && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
-		/* Configuration for 8-bit BT656 mode */
-		output1 = 0x40;
-		output4 = 0xFF;
-		output5 = 0x4;
-		output6 = 0;
-		ret |=
-		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
-				  output5);
-		ret |=
-		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
-				  output6);
-	} else if ((!tvp5146params->enablebt656sync)
-		   && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
-
-		/* Configuration for 8-bit seperate sync mode */
-		output1 = 0x43;
-		output4 = 0xAF;
-		output5 = 0x4;
-		output6 = 0x1E;
-		ret |=
-		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
-				  output5);
-		ret |=
-		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
-				  output6);
-	} else if ((!tvp5146params->enablebt656sync)
-		   && (tvp5146params->data_width == TVP5146_WIDTH_16BIT)) {
-
-		/* Configuration for 16-bit seperate sync mode */
-		output1 = 0x41;
-		output4 = 0xAF;
-	} else {
-		return -EINVAL;
-	}
-
-	output2 = 0x11;		/* enable clock, enable Y[9:0] */
-	output3 = 0x0;
-
-	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT1, output1);
-	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT2, output2);
-	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT3, output3);
-	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT4, output4);
-
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of setup656sync...");
-
-	return ret;
-}
-
-/*
- * ======== tvp5146_ctrl ========
- */
- /* This function handles all TVP5146 control commands */
-int tvp5146_ctrl(tvp5146_cmd cmd, void *arg)
-{
-	int ret = 0;
-	dev_dbg(tvp5146_i2c_dev,
-		"\nStarting tvp5146_ctrl with %d command...", cmd);
-	switch (cmd) {
-	case TVP5146_CONFIG:
-		ret = configtvp5146(arg);
-		break;
-	case TVP5146_RESET:
-		ret = resettvp5146();
-		break;
-	case TVP5146_POWERDOWN:
-		ret = powerdowntvp5146(*(int *)arg);
-		break;
-	case TVP5146_SET_AMUXMODE:
-		ret = settvp5146amuxmode(*(int *)arg);
-		break;
-	case TVP5146_SET_BRIGHTNESS:
-		ret = settvp5146brightness(*(int *)arg);
-		break;
-	case TVP5146_SET_CONTRAST:
-		ret = settvp5146contrast(*(int *)arg);
-		break;
-	case TVP5146_SET_HUE:
-		ret = settvp5146hue(*(int *)arg);
-		break;
-	case TVP5146_SET_SATURATION:
-		ret = settvp5146saturation(*(int *)arg);
-		break;
-	case TVP5146_SET_AGC:
-		ret = enabletvp5146agc(*(int *)arg);
-		break;
-	case TVP5146_SET_VIDEOSTD:
-		ret = settvp5146std(*(int *)arg);
-		break;
-	case TVP5146_CLR_LOSTLOCK:
-		ret = clrtvp5146lostlock();
-		break;
-	case TVP5146_GET_STATUS:
-		ret = gettvp5146status(arg);
-		break;
-	case TVP5146_GET_STD:
-		ret = gettvp5146std(arg);
-		break;
-	case VIDIOC_QUERYCTRL:
-		ret = queryctrl(arg);
-		break;
-	case VIDIOC_G_CTRL:
-		ret = getctrl(arg);
-		break;
-	case VIDIOC_S_CTRL:
-		ret = setctrl(arg);
-		break;
-	case TVP5146_INIT:
-		ret = tvp5146_init();
-		break;
-	case TVP5146_CLEANUP:
-		tvp5146_cleanup();
-		break;
-	default:
-		ret = -EINVAL;
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146_ctrl...");
-	return ret;
-}
-
-/*
- * ======== i2c_read_reg  ========
- */
-/*This function is used to read value from register for i2c client. */
-static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
-{
-	int err = 0;
-
-	struct i2c_msg msg[1];
-	unsigned char data[1];
-	dev_dbg(tvp5146_i2c_dev, "\nStarting tvp5146 i2c read...");
-	if (!client->adapter) {
-		err = -ENODEV;
-	} else {
-		msg->addr = client->addr;
-		msg->flags = 0;
-		msg->len = 1;
-		msg->buf = data;
-		data[0] = reg;
-		err = i2c_transfer(client->adapter, msg, 1);
-		if (err >= 0) {
-			msg->flags = I2C_M_RD;
-			err = i2c_transfer(client->adapter, msg, 1);
-			if (err >= 0) {
-				*val = data[0];
-			}
-		}
-	}
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c read...");
-	return err;
-}
-
-/*
- * ======== i2c_write_reg  ========
- */
-/*This function is used to write value into register for i2c client. */
-static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
-{
-	int err = 0;
-
-	struct i2c_msg msg[1];
-	unsigned char data[2];
-
-	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c write...");
-	if (!client->adapter) {
-		err = -ENODEV;
-	} else {
-		msg->addr = client->addr;
-		msg->flags = 0;
-		msg->len = 2;
-		msg->buf = data;
-		data[0] = reg;
-		data[1] = val;
-		err = i2c_transfer(client->adapter, msg, 1);
-	}
-	dev_dbg(tvp5146_i2c_dev, " i2c data write \n");
-
-	return err;
-}
-
-/*
- * ======== _i2c_attach_client  ========
- */
-/* This function is used to attach i2c client */
-static int _i2c_attach_client(struct i2c_client *client,
-			      struct i2c_driver *driver,
-			      struct i2c_adapter *adap, int addr)
-{
-	int err = 0;
-
-	if (client->adapter) {
-		err = -EBUSY;	/* our client is already attached */
-	} else {
-		client->addr = addr;
-		client->flags = I2C_CLIENT_ALLOW_USE;
-		client->driver = driver;
-		client->adapter = adap;
-
-		err = i2c_attach_client(client);
-		if (err) {
-			client->adapter = NULL;
-		}
-	}
-	return err;
-}
-
-/*
- * ======== _i2c_detach_client  ========
- */
-/* This function is used to detach i2c client */
-static int _i2c_detach_client(struct i2c_client *client)
-{
-	int err = 0;
-
-	if (!client->adapter) {
-		return -ENODEV;	/* our client isn't attached */
-	} else {
-		err = i2c_detach_client(client);
-		client->adapter = NULL;
-	}
-	return err;
-}
-
-/*
- * ======== tvp5146_i2c_probe_adapter  ========
- */
-/* This function is used to probe i2c adapter */
-static int tvp5146_i2c_probe_adapter(struct i2c_adapter *adap)
-{
-	tvp5146_i2c_dev = &(adap->dev);
-	return _i2c_attach_client(&tvp5146_i2c_client, &tvp5146_i2c_driver,
-				  adap, TVP5146_I2C_ADDR);
-}
-
-/*
- * ======== tvp5146_i2c_init  ========
- */
-/* This function is used initialize TVP5146 i2c client */
-static int tvp5146_i2c_init(void)
-{
-	int err = 0;
-	struct i2c_driver *driver = &tvp5146_i2c_driver;
-
-	driver->owner = THIS_MODULE;
-	strlcpy(driver->name, "TVP5146 Video Decoder I2C driver",
-		sizeof(driver->name));
-	driver->id = I2C_DRIVERID_EXP0;
-	driver->flags = I2C_DF_NOTIFY;
-	driver->attach_adapter = tvp5146_i2c_probe_adapter;
-	driver->detach_client = _i2c_detach_client;
-
-	return err;
-}
-
-/*
- * ======== tvp5146_i2c_cleanup  ========
- */
-/* This function is used detach TVP5146 i2c client */
-static void tvp5146_i2c_cleanup(void)
-{
-	struct i2c_driver *driver = &tvp5146_i2c_driver;
-
-	if (tvp5146_i2c_registration) {
-		i2c_detach_client(&tvp5146_i2c_client);
-		i2c_del_driver(driver);
-		tvp5146_i2c_client.adapter = NULL;
-		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
-	}
-}
-
-module_init(tvp5146_i2c_init);
-module_exit(tvp5146_i2c_cleanup);
-
-EXPORT_SYMBOL(tvp5146_ctrl);
-MODULE_LICENSE("GPL");
-
-/**************************************************************************/
-/* End of file                                                            */
-/**************************************************************************/
Index: linux-2.6.10/drivers/media/video/davinci/ccdc_davinci.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/ccdc_davinci.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.c */
+
+#include <linux/device.h>
+#include <media/davinci/ccdc_davinci.h>
+#include <asm/page.h>
+
+/*Object for CCDC raw mode */
+ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = FALSE,
+	.data_sz = _10BITS,
+	.alaw = {
+		 .b_alaw_enable = FALSE}
+	,
+	.blk_clamp = {
+		      .b_clamp_enable = FALSE,
+		      .dc_sub = 0}
+	,
+	.blk_comp = {0, 0, 0, 0}
+	,
+	.fault_pxl = {
+		      .fpc_enable = FALSE}
+	,
+};
+
+/*Object for CCDC ycbcr mode */
+ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = TRUE,
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
+};
+
+extern struct device *vpfe_dev;
+
+void ccdc_readregs(void)
+{
+	unsigned int val = 0;
+
+	val = regr(ALAW);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to ALAW...\n", val);
+	val = regr(CLAMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CLAMP...\n", val);
+	val = regr(DCSUB);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DCSUB...\n", val);
+	val = regr(BLKCMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP...\n", val);
+	val = regr(FPC_ADDR);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC_ADDR...\n", val);
+	val = regr(FPC);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC...\n", val);
+	val = regr(FMTCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTCFG...\n", val);
+	val = regr(COLPTN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to COLPTN...\n", val);
+	val = regr(FMT_HORZ);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_HORZ...\n", val);
+	val = regr(FMT_VERT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_VERT...\n", val);
+	val = regr(HSIZE_OFF);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HSIZE_OFF...\n", val);
+	val = regr(SDOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SDOFST...\n", val);
+	val = regr(VP_OUT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VP_OUT...\n", val);
+	val = regr(SYN_MODE);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SYN_MODE...\n", val);
+	val = regr(HORZ_INFO);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HORZ_INFO...\n", val);
+	val = regr(VERT_START);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_START...\n", val);
+	val = regr(VERT_LINES);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_LINES...\n", val);
+}
+
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam)
+{
+	if ((ccdc_hw_params_raw.frm_fmt != CCDC_FRMFMT_INTERLACED)
+	    && (ccdcparam->image_invert_enable == TRUE)) {
+		dev_err(vpfe_dev, "\nImage invert not supported");
+		return -1;
+	}
+	if (ccdc_hw_params_raw.alaw.b_alaw_enable) {
+		if ((ccdcparam->alaw.gama_wd > BITS_09_0)
+		    || (ccdcparam->alaw.gama_wd < BITS_15_6)
+		    || (ccdcparam->alaw.gama_wd < ccdcparam->data_sz)) {
+			dev_err(vpfe_dev, "\nInvalid data line select");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int ccdc_update_ycbcr_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_ycbcr,
+	       (ccdc_params_ycbcr *) arg, sizeof(ccdc_params_ycbcr));
+	return 0;
+}
+
+int ccdc_update_raw_params(void *arg)
+{
+	unsigned int *fpc_virtaddr = NULL;
+	unsigned int *fpc_physaddr = NULL;
+	ccdc_params_raw *ccd_params = &ccdc_hw_params_raw;
+	ccdc_config_params_raw *raw_params = (ccdc_config_params_raw *) arg;
+	ccd_params->image_invert_enable = raw_params->image_invert_enable;
+
+	dev_dbg(vpfe_dev, "\nimage_invert_enable = %d",
+		ccd_params->image_invert_enable);
+
+	ccd_params->data_sz = raw_params->data_sz;
+	dev_dbg(vpfe_dev, "\ndata_sz = %d", ccd_params->data_sz);
+
+	ccd_params->alaw.b_alaw_enable = raw_params->alaw.b_alaw_enable;
+	dev_dbg(vpfe_dev, "\nALaw Enable = %d", ccd_params->alaw.b_alaw_enable);
+	/* copy A-Law configurations to vpfe_device, from arg
+	 * passed by application */
+	if (ccd_params->alaw.b_alaw_enable) {
+		ccd_params->alaw.gama_wd = raw_params->alaw.gama_wd;
+		dev_dbg(vpfe_dev, "\nALaw Gama width = %d",
+			ccd_params->alaw.gama_wd);
+	}
+
+	/* copy Optical Balck Clamping configurations to
+	 * vpfe_device,from arg passed by application */
+	ccd_params->blk_clamp.b_clamp_enable
+	    = raw_params->blk_clamp.b_clamp_enable;
+	dev_dbg(vpfe_dev, "\nb_clamp_enable = %d",
+		ccd_params->blk_clamp.b_clamp_enable);
+	if (ccd_params->blk_clamp.b_clamp_enable) {
+		/*gain */
+		ccd_params->blk_clamp.sgain = raw_params->blk_clamp.sgain;
+		dev_dbg(vpfe_dev, "\nblk_clamp.sgain = %d",
+			ccd_params->blk_clamp.sgain);
+		/*Start pixel */
+		ccd_params->blk_clamp.start_pixel
+		    = raw_params->blk_clamp.start_pixel;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.start_pixel = %d",
+			ccd_params->blk_clamp.start_pixel);
+		/*No of line to be avg */
+		ccd_params->blk_clamp.sample_ln
+		    = raw_params->blk_clamp.sample_ln;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.sample_ln = %d",
+			ccd_params->blk_clamp.sample_ln);
+		/*No of pixel/line to be avg */
+		ccd_params->blk_clamp.sample_pixel
+		    = raw_params->blk_clamp.sample_pixel;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.sample_pixel  = %d",
+			ccd_params->blk_clamp.sample_pixel);
+	} else {		/* configure DCSub */
+
+		ccd_params->blk_clamp.dc_sub = raw_params->blk_clamp.dc_sub;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.dc_sub  = %d",
+			ccd_params->blk_clamp.dc_sub);
+	}
+
+	/* copy BalckLevel Compansation configurations to 
+	 * vpfe_device,from arg passed by application 
+	 */
+	ccd_params->blk_comp.r_comp = raw_params->blk_comp.r_comp;
+	ccd_params->blk_comp.gr_comp = raw_params->blk_comp.gr_comp;
+	ccd_params->blk_comp.b_comp = raw_params->blk_comp.b_comp;
+	ccd_params->blk_comp.gb_comp = raw_params->blk_comp.gb_comp;
+	dev_dbg(vpfe_dev, "\nblk_comp.r_comp   = %d",
+		ccd_params->blk_comp.r_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.gr_comp  = %d",
+		ccd_params->blk_comp.gr_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.b_comp   = %d",
+		ccd_params->blk_comp.b_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.gb_comp  = %d",
+		ccd_params->blk_comp.gb_comp);
+
+	/* copy FPC configurations to vpfe_device,from  
+	 * arg passed by application
+	 */
+	ccd_params->fault_pxl.fpc_enable = raw_params->fault_pxl.fpc_enable;
+	dev_dbg(vpfe_dev, "\nfault_pxl.fpc_enable  = %d",
+		ccd_params->fault_pxl.fpc_enable);
+
+	if (ccd_params->fault_pxl.fpc_enable) {
+		fpc_physaddr =
+		    (unsigned int *)ccd_params->fault_pxl.fpc_table_addr;
+
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)
+				 fpc_physaddr);
+
+		/* Allocate memory for FPC table if current 
+		 * FPC table buffer is not big enough to 
+		 * accomodate FPC Number requested 
+		 */
+		if (raw_params->fault_pxl.fp_num !=
+		    ccd_params->fault_pxl.fp_num) {
+			if (fpc_physaddr != NULL) {
+				free_pages((unsigned long)
+					   fpc_physaddr,
+					   get_order
+					   (ccd_params->
+					    fault_pxl.fp_num * FP_NUM_BYTES));
+
+			}
+
+			/* Allocate memory for FPC table */
+			fpc_virtaddr = (unsigned int *)
+			    __get_free_pages(GFP_KERNEL |
+					     GFP_DMA,
+					     get_order
+					     (raw_params->
+					      fault_pxl.fp_num * FP_NUM_BYTES));
+
+			if (fpc_virtaddr == NULL) {
+				dev_err(vpfe_dev, "\n Unable to allocate \
+					memory for FPC");
+				return -1;
+			}
+			fpc_physaddr =
+			    (unsigned int *)virt_to_phys((void *)fpc_virtaddr);
+		}
+
+		/* Copy number of fault pixels and FPC table */
+		ccd_params->fault_pxl.fp_num = raw_params->fault_pxl.fp_num;
+		copy_from_user((void *)fpc_virtaddr,
+			       (void *)raw_params->
+			       fault_pxl.fpc_table_addr,
+			       (unsigned long)ccd_params->
+			       fault_pxl.fp_num * FP_NUM_BYTES);
+
+		ccd_params->fault_pxl.fpc_table_addr =
+		    (unsigned int)fpc_physaddr;
+	}
+	return 0;
+}
+void ccdc_init(void)
+{
+	/* Do nothing for DM6446 */
+}
+
+void ccdc_cleanup(void)
+{
+	unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
+	fpc_physaddr = (unsigned int *)
+	    ccdc_hw_params_raw.fault_pxl.fpc_table_addr;
+
+	if (fpc_physaddr != NULL) {
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)fpc_physaddr);
+		free_pages((unsigned long)fpc_virtaddr,
+			   get_order(ccdc_hw_params_raw.fault_pxl.
+				     fp_num * FP_NUM_BYTES));
+	}
+}
+
+/*                                                       
+ * ======== ccdc_reset  ========                        
+ */
+/*This function will reset all CCDc reg */
+
+void ccdc_reset()
+{
+	int i;
+
+	/* disable CCDC */
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x94; i += 4) {
+		regw(0, i);
+	}
+	regw(0, PCR);
+	regw(0, SYN_MODE);
+	regw(0, HD_VD_WID);
+	regw(0, PIX_LINES);
+	regw(0, HORZ_INFO);
+	regw(0, VERT_START);
+	regw(0, VERT_LINES);
+	regw(0xffff00ff, CULLING);
+	regw(0, HSIZE_OFF);
+	regw(0, SDOFST);
+	regw(0, SDR_ADDR);
+	regw(0, VDINT);
+	regw(0, REC656IF);
+	regw(0, CCDCFG);
+	regw(0, FMTCFG);
+	regw(0, VP_OUT);
+}
+
+/*                                                       
+ * ======== ccdc_setwin  ========                        
+ */
+/*This function will configure the window size to be capture in CCDC reg */
+void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int val = 0, mid_img = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	/* Here, (ppc-1) will be different for raw and yuv modes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = (image_win->width << (ppc - 1)) - 1;
+	regw((horz_start << CCDC_HORZ_INFO_SPH_SHIFT) | horz_nr_pixels,
+	     HORZ_INFO);
+
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		/* configure VDINT0 */
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT);
+		regw(val, VDINT);
+
+	} else {
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		/* VDINT1 will be at half of image height */
+		mid_img = vert_start + (image_win->height / 2);
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT) |
+		    (mid_img & CCDC_VDINT_VDINT1_MASK);
+		regw(val, VDINT);
+
+	}
+	regw((vert_start << CCDC_VERT_START_SLV0_SHIFT) | vert_start,
+	     VERT_START);
+	regw(vert_nr_lines, VERT_LINES);
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_setwin...");
+}
+
+/*                                
+ * ======== ccdc_config_ycbcr  ======== 
+ */
+/*This function will configure CCDC for YCbCr parameters*/
+void ccdc_config_ycbcr(void)
+{
+	u32 syn_mode;
+	unsigned int val;
+	ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_ycbcr...");
+	ccdc_reset();
+
+	/* configure pixel format */
+	syn_mode = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	syn_mode |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		syn_mode |= 0x00000F04;
+	} else {		/* y/c external sync mode */
+		syn_mode |= ((params->fid_pol & 0x1) << 4);
+		syn_mode |= ((params->hd_pol & 0x1) << 3);
+		syn_mode |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8000, CCDCFG);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((params->win.width * 2) + 31) & 0xffffffe0, HSIZE_OFF);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+	}
+	/* enable output to SDRAM */
+	syn_mode |= (0x1 << 17);
+	/* enable internal timing generator */
+	syn_mode |= (0x1 << 16);
+
+	syn_mode |= CCDC_DATA_PACK_ENABLE;
+	regw(syn_mode, SYN_MODE);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_config_ycbcr...\n");
+	ccdc_readregs();
+}
+
+/*                                                        
+ * ======== ccdc_config_raw  ========                   
+ */
+/*This function will configure CCDC for Raw mode parameters*/
+void ccdc_config_raw()
+{
+
+	ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int syn_mode = 0;
+	unsigned int val;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	ccdc_reset();
+	/* Disable latching function registers on VSYNC  */
+	regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG);
+
+	/*      Configure the vertical sync polarity(SYN_MODE.VDPOL) */
+	syn_mode = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (SYN_MODE.HDPOL) */
+	syn_mode |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (SYN_MODE.FLDPOL) */
+	syn_mode |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	syn_mode |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure the data size(SYNMODE.DATSIZ) */
+	syn_mode |= (params->data_sz & CCDC_DATA_SZ_MASK) << CCDC_DATA_SZ_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	syn_mode |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	/* Configure VP2SDR bit of syn_mode = 0 */
+	syn_mode &= CCDC_VP2SDR_DISABLE;
+
+	/* Enable write enable bit */
+	syn_mode |= CCDC_WEN_ENABLE;
+
+	/* Disable output to resizer */
+	syn_mode &= CCDC_SDR2RSZ_DISABLE;
+
+	/* enable internal timing generator */
+	syn_mode |= CCDC_VDHDEN_ENABLE;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val = (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK);
+		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
+		regw(val, ALAW);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to ALAW...\n", val);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, PPC_RAW);
+
+	if (params->blk_clamp.b_clamp_enable) {
+		val = (params->blk_clamp.sgain) & CCDC_BLK_SGAIN_MASK;	/*gain */
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK)
+		    << CCDC_BLK_ST_PXL_SHIFT;	/*Start pixel */
+		val |= (params->blk_clamp.sample_ln & CCDC_BLK_SAMPLE_LINE_MASK)
+		    << CCDC_BLK_SAMPLE_LINE_SHIFT;	/*No of line to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;	/*No of pixel/line to be avg */
+		val |= CCDC_BLK_CLAMP_ENABLE;	/*Enable the Black clamping */
+		regw(val, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to CLAMP...\n", val);
+		regw(DCSUB_DEFAULT_VAL, DCSUB);	/*If Black clamping is enable 
+						   then make dcsub 0 */
+		dev_dbg(vpfe_dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		regw(val, DCSUB);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to DCSUB...\n", val);
+		regw(CLAMP_DEFAULT_VAL, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*      Configure Black level compensation */
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	val |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+
+	regw(val, BLKCMP);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP...\n", val);
+	dev_dbg(vpfe_dev, "\nbelow 	regw(val, BLKCMP)...");
+	/* Initially disable FPC */
+	val = CCDC_FPC_DISABLE;
+	regw(val, FPC);
+	/* Configure Fault pixel if needed */
+	if (params->fault_pxl.fpc_enable) {
+		regw(params->fault_pxl.fpc_table_addr, FPC_ADDR);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC_ADDR...\n",
+			(params->fault_pxl.fpc_table_addr));
+		/* Write the FPC params with FPC disable */
+		val = params->fault_pxl.fp_num & CCDC_FPC_FPC_NUM_MASK;
+		regw(val, FPC);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
+		/* read the FPC register */
+		val = regr(FPC);
+		val |= CCDC_FPC_ENABLE;
+		regw(val, FPC);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
+	}
+	/* If data size is 8 bit then pack the data */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		syn_mode |= CCDC_DATA_PACK_ENABLE;
+	}
+#if VIDEO_PORT_ENABLE
+	val = ENABLE_VIDEO_PORT;	/* enable video port */
+#else
+	val = DISABLE_VIDEO_PORT;	/* disable video port */
+#endif
+
+	if (params->data_sz == _8BITS)
+		val |= (_10BITS & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+	else
+		val |= (params->data_sz & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+
+	/* Write value in FMTCFG */
+	regw(val, FMTCFG);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMTCFG...\n", val);
+
+	/* Configure the color pattern according to mt9t001 sensor */
+	regw(CCDC_COLPTN_VAL, COLPTN);
+
+	dev_dbg(vpfe_dev, "\nWriting 0xBB11BB11 to COLPTN...\n");
+	/* Configure Data formatter(Video port) pixel selection 
+	 * (FMT_HORZ, FMT_VERT) 
+	 */
+	val = 0;
+	val |= ((params->win.left) & CCDC_FMT_HORZ_FMTSPH_MASK)
+	    << CCDC_FMT_HORZ_FMTSPH_SHIFT;
+	val |= (((params->win.width)) & CCDC_FMT_HORZ_FMTLNH_MASK);
+	regw(val, FMT_HORZ);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_HORZ...\n", val);
+	val = 0;
+	val |= (params->win.top & CCDC_FMT_VERT_FMTSLV_MASK)
+	    << CCDC_FMT_VERT_FMTSLV_SHIFT;
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
+		val |= (params->win.height) & CCDC_FMT_VERT_FMTLNV_MASK;
+	else
+		val |= (params->win.height >> 1) & CCDC_FMT_VERT_FMTLNV_MASK;
+
+	dev_dbg(vpfe_dev, "\nparams->win.height  0x%x ...\n",
+		params->win.height);
+	regw(val, FMT_VERT);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_VERT...\n", val);
+
+	dev_dbg(vpfe_dev, "\nbelow regw(val, FMT_VERT)...");
+
+	/* Configure Horizontal offset register */
+	/* If pack 8 is enabled then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		regw(((params->win.width) + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	} else {		/* else one pixel will take 2 byte */
+
+		regw(((params->win.width * TWO_BYTES_PER_PIXEL)
+		      + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	}
+
+	/* Set value for SDOFST */
+
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For intelace inverse mode */
+			regw(INTERLACED_IMAGE_INVERT, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For intelace non inverse mode */
+			regw(INTERLACED_NO_IMAGE_INVERT, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x0249 to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		regw(PROGRESSIVE_NO_IMAGE_INVERT, SDOFST);
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to SDOFST...\n");
+	}
+
+	/* Configure video port pixel selection (VPOUT) */
+	/* Here -1 is to make the height value less than FMT_VERT.FMTLNV */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		val = (((params->win.height - 1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+	} else {
+		val =
+		    ((((params->win.
+			height >> CCDC_INTERLACED_HEIGHT_SHIFT) -
+		       1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+	}
+
+	val |= ((((params->win.width))) & CCDC_VP_OUT_HORZ_NUM_MASK)
+	    << CCDC_VP_OUT_HORZ_NUM_SHIFT;
+	val |= (params->win.left) & CCDC_VP_OUT_HORZ_ST_MASK;
+	regw(val, VP_OUT);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to VP_OUT...\n", val);
+	regw(syn_mode, SYN_MODE);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to SYN_MODE...\n", syn_mode);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
+
+	dev_dbg(vpfe_dev, "\nend of ccdc_config_raw...");
+	ccdc_readregs();
+}
Index: linux-2.6.10/drivers/media/video/davinci/davinci_aew.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_aew.c
@@ -0,0 +1,885 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_aew.c file */
+
+/* Kernel specific header files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* File Structure fops... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* Types like size_t */
+#include <linux/cdev.h>
+#include <linux/interrupt.h>	/* For interrupt */
+#include <linux/dma-mapping.h>	/* For class_simple_create */
+#include <asm/uaccess.h>
+#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
+#include <linux/devfs_fs_kernel.h>	/* for devfs */
+#include <asm/semaphore.h>
+#include <linux/device.h>
+/* Driver Header Files */
+#include <asm/arch/davinci_aew.h>	/* Local Definitions */
+#include <asm/arch/davinci_aew_hw.h>	/* Local Definitions */
+
+/*Global structure*/
+struct aew_device *aew_dev_configptr;
+struct device *aewdev = NULL;
+/* device structure to make entry in device*/
+static dev_t dev;
+static struct class_simple *aew_class = NULL;
+
+/* For registeration of charatcer device*/
+static struct cdev c_dev;
+
+/* Module License*/
+MODULE_LICENSE("GPL");
+
+/* inline function to free reserver pages  */
+void inline aew_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long tempaddr;
+	unsigned long size;
+	tempaddr = addr;
+	if (!addr)
+		return;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(tempaddr, get_order(bufsize));
+}
+
+/* Function to check Window Parmeters */
+int aew_check_window(void)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Check Window Horizontal Count */
+	if ((aew_dev_configptr->config->window_config.hz_cnt
+	     < AEW_WINDOW_HORIZONTAL_COUNT_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_cnt
+		> AEW_WINDOW_HORIZONTAL_COUNT_MAX)) {
+		dev_err(aewdev, "Error :  Horizontal Count is incorrect\n");
+		return -AEW_ERR_HZ_COUNT;
+	}
+
+	/* Check Window Vertical Count */
+	if ((aew_dev_configptr->config->window_config.vt_cnt
+	     < AEW_WINDOW_VERTICAL_COUNT_MIN)
+	    || (aew_dev_configptr->config->window_config.vt_cnt
+		> AEW_WINDOW_VERTICAL_COUNT_MAX)) {
+		dev_err(aewdev, "Error :  Vertical Count is incorrect\n");
+		return -AEW_ERR_VT_COUNT;
+	}
+
+	/* Check Window Vertical Start */
+	if ((aew_dev_configptr->config->window_config.vt_start
+	     < AEW_WINDOW_START_MIN)
+	    || (aew_dev_configptr->config->window_config.vt_start
+		> AEW_WINDOW_START_MAX)) {
+		dev_err(aewdev, "Error : Vertical Start is incorrect\n");
+		return -AEW_ERR_VT_START;
+	}
+
+	/* Check Window Horizontal Start */
+	if ((aew_dev_configptr->config->window_config.hz_start
+	     < AEW_WINDOW_START_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_start
+		> AEW_WINDOW_START_MAX)) {
+		dev_err(aewdev, "Error :  Horizontal Start is incorrect\n");
+		return -AEW_ERR_HZ_START;
+	}
+
+	/*Check Horizontal Line Increment */
+	if ((aew_dev_configptr->config->window_config.hz_line_incr
+	     < AEW_WINDOW_LINE_INCREMENT_MIN)
+	    || (aew_dev_configptr->config->window_config.hz_line_incr
+		> AEW_WINDOW_LINE_INCREMENT_MAX)) {
+		dev_err(aewdev,
+			"Error :  Horizontal Line Increment value is incorrect\n");
+		return -AEW_ERR_HZ_INCR;
+	}
+
+	/* Check Vertical Line Increment */
+	if ((aew_dev_configptr->config->window_config.vt_line_incr
+	     < AEW_WINDOW_LINE_INCREMENT_MIN)
+	    || (aew_dev_configptr->config->window_config.vt_line_incr
+		> AEW_WINDOW_LINE_INCREMENT_MAX)) {
+		dev_err(aewdev,
+			"Error :  Vertical Line Increment is  incorrect\n");
+		return -AEW_ERR_VT_INCR;
+	}
+
+	/* Check Window Height */
+	if ((aew_dev_configptr->config->window_config.height
+	     < AEW_WINDOW_HEIGHT_MIN)
+	    || (aew_dev_configptr->config->window_config.height
+		> AEW_WINDOW_HEIGHT_MAX)) {
+
+		dev_err(aewdev, "Error :  Height is incorrect\n");
+		return -AEW_ERR_HEIGHT;
+	}
+
+	/* Check Window Width */
+	if ((aew_dev_configptr->config->window_config.width
+	     < AEW_WINDOW_WIDTH_MIN)
+	    || (aew_dev_configptr->config->window_config.width
+		> AEW_WINDOW_WIDTH_MAX)) {
+		dev_err(aewdev, "Error :  Width is incorrect\n");
+		return -AEW_ERR_WIDTH;
+	}
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;		/*Success */
+}
+
+/* Function to check Black Window Parmeters */
+int aew_check_black_window(void)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Check Black Window Height */
+	if ((aew_dev_configptr->config->blackwindow_config.height
+	     < AEW_WINDOW_HEIGHT_MIN)
+	    || (aew_dev_configptr->config->blackwindow_config.height
+		> AEW_WINDOW_HEIGHT_MAX)) {
+		dev_err(aewdev, "Error :  Height is incorrect\n");
+		return -AEW_ERR_BLKWIN_HEIGHT;
+	}
+
+	/* Check Black Window Vertical Start */
+	if ((aew_dev_configptr->config->blackwindow_config.vt_start
+	     < AEW_WINDOW_START_MIN)
+	    || (aew_dev_configptr->config->blackwindow_config.vt_start
+		> AEW_WINDOW_START_MAX)) {
+		dev_err(aewdev, "Error :  Vertical Start is incorrect\n");
+		return -AEW_ERR_BLKWIN_VT_START;
+	}
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;		/*Success */
+}
+
+/* Function to perform hardware Configuration */
+int aew_hardware_setup(void)
+{
+	int result;
+	/*Size for buffer in bytes */
+	int buff_size = 0;
+	unsigned long adr;
+	unsigned long size;
+	unsigned int busyaew;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaew = AEW_GET_PCR;
+
+	/* Mask with BUSYAF bit */
+	busyaew = busyaew & AEW_BUSYAEWB;
+
+	/* Shift it 18 times to get value of 1 or 0 */
+	busyaew = busyaew >> AEW_BUSYAEWB_SHIFT;
+
+	/* If H3A Engine is busy then return */
+	if (busyaew == 1) {
+		dev_err(aewdev, "\n Error : AEW Engine is busy");
+		return -AEW_ERR_ENGINE_BUSY;
+	}
+
+	/*Check Window Parameters */
+	result = aew_check_window();
+	dev_dbg(aewdev, "Result =  %d\n", result);
+	if (result < 0) {
+		dev_err(aewdev, "Error : Window Parameter are incorrect \n");
+		return result;
+	}
+
+	/*Check Black Window Parameters */
+	result = aew_check_black_window();
+	if (result < 0) {
+		dev_err(aewdev,
+			"Error : Black Window Parameters are incorrect \n");
+		return result;
+	}
+
+	/*Check Saturuation limit */
+	if (aew_dev_configptr->config->saturation_limit > AEW_SAT_LIMIT_MAX) {
+		dev_err(aewdev, "Error : Saturation limit is incorrect\n");
+		return -AEW_ERR_LIMIT;
+	}
+
+	/* Deallocate the previously allocated buffers */
+	if (aew_dev_configptr->buff_old)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
+			       aew_dev_configptr->size_window);
+
+	if (aew_dev_configptr->buff_curr)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_curr, aew_dev_configptr->size_window);
+
+	if (aew_dev_configptr->buff_app)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_app, aew_dev_configptr->size_window);
+
+	/*Allocat the buffers as per the new buffer size */
+	/*Allocate memory for old buffer */
+	buff_size = (aew_dev_configptr->config->window_config.hz_cnt + 1)
+	    * (aew_dev_configptr->config->window_config.vt_cnt +
+	       1) * AEW_WINDOW_SIZE;
+
+	aew_dev_configptr->buff_old =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_old == NULL)
+		return -ENOMEM;
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_old;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for current buffer */
+	aew_dev_configptr->buff_curr =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_curr == NULL) {
+
+		/*Free all  buffer that are allocated */
+		if (aew_dev_configptr->buff_old)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_curr;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for application buffer */
+	aew_dev_configptr->buff_app =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (aew_dev_configptr->buff_app == NULL) {
+		/*Free all  buffer that were allocated previously */
+		if (aew_dev_configptr->buff_old)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_old, buff_size);
+		if (aew_dev_configptr->buff_curr)
+			aew_free_pages((unsigned long)aew_dev_configptr->
+				       buff_curr, buff_size);
+		return -ENOMEM;
+	}
+
+	/*Make pges reserved so that they will be swapped out */
+	adr = (unsigned long)aew_dev_configptr->buff_app;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/* Set the registers */
+	aew_set_register(aew_dev_configptr);
+	aew_dev_configptr->size_window = buff_size;
+	aew_dev_configptr->config->aew_config = H3A_AEW_ENABLE;
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;		/*Success */
+}
+
+/* This Function is called when driver is opened */
+static int aew_open(struct inode *inode, struct file *filp)
+{
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/*Return if Device is in use (Single Channel Support is provided) */
+	if (aew_dev_configptr->in_use == AEW_IN_USE)
+		return -EBUSY;
+
+	/* Set the aew_dev_configptr structure */
+	aew_dev_configptr->config = NULL;
+
+	/* Allocate memory for configuration  structure of this channel */
+	aew_dev_configptr->config = (struct aew_configuration *)
+	    kmalloc(sizeof(struct aew_configuration), GFP_KERNEL);
+
+	if (aew_dev_configptr->config == NULL) {
+		dev_err(aewdev, "Error : Kmalloc fail\n");
+		return -ENOMEM;
+	}
+
+	/* Initiaze the wait queue */
+	init_waitqueue_head(&(aew_dev_configptr->aew_wait_queue));
+
+	/*Device is in use */
+	aew_dev_configptr->in_use = AEW_IN_USE;
+
+	/* No Hardware Set up done */
+	aew_dev_configptr->config->aew_config = H3A_AEW_DISABLE;
+
+	/* No statistics are available */
+	aew_dev_configptr->buffer_filled = 0;
+
+	/* Set Window Size to 0 */
+	aew_dev_configptr->size_window = 0;
+
+	/* Initialize the semaphore */
+	init_MUTEX(&(aew_dev_configptr->read_blocked));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+static void aew_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+static int __init aew_probe(struct device *device)
+{
+	aewdev = device;
+	return 0;
+}
+
+static int aew_remove(struct device *device)
+{
+	return 0;
+}
+
+/* This Function is called when driver is closed */
+static int aew_release(struct inode *inode, struct file *filp)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* The Application has closed device so device is not in use */
+	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
+
+	/*Release memory for configuration structure of this channel */
+	if (aew_dev_configptr->config)
+		kfree(aew_dev_configptr->config);
+
+	/* Free Old Buffer */
+	if (aew_dev_configptr->buff_old)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_old,
+			       aew_dev_configptr->size_window);
+
+	/* Free Current Buffer */
+	if (aew_dev_configptr->buff_curr)
+		aew_free_pages((unsigned long)aew_dev_configptr->
+			       buff_curr, aew_dev_configptr->size_window);
+
+	/* Free Application Buffer */
+	if (aew_dev_configptr->buff_app)
+		aew_free_pages((unsigned long)aew_dev_configptr->buff_app,
+			       aew_dev_configptr->size_window);
+
+	aew_dev_configptr->buff_old = NULL;
+	aew_dev_configptr->buff_curr = NULL;
+	aew_dev_configptr->config = NULL;
+	aew_dev_configptr->buff_app = NULL;
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* This function will process IOCTL commands sent by the application and
+ * control the devices IO operations.
+ */
+static int aew_ioctl(struct inode *inode, struct file *filep,
+		     unsigned int cmd, unsigned long arg)
+{
+	/* Stores Previous Configurations */
+	struct aew_configuration aewconfig = *(aew_dev_configptr->config);
+	int result = 0;
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Decrement the semaphore */
+	down_interruptible(&aew_dev_configptr->read_blocked);
+
+	/*Extract the type and number bitfields, and don't decode wrong cmds: */
+	/*verify the magic number */
+	if (_IOC_TYPE(cmd) != AEW_MAGIC_NO) {
+		up(&aew_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/*verify the command number */
+	if (_IOC_NR(cmd) > AEW_IOC_MAXNR) {
+		/* Release semaphore  in case of fault */
+		up(&aew_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/* check for the permission of the operation */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		result =
+		    !access_ok(VERIFY_WRITE, (void __user *)arg,
+			       _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		result =
+		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (result) {
+		/* Release semaphore in case of fault */
+		up(&aew_dev_configptr->read_blocked);
+		return -EFAULT;
+	}
+
+	/* Switch according to IOCTL command */
+	switch (cmd) {
+		/* This ioctl is used to perform hardware set up 
+		   and will set all the regiseters */
+		/*for AF engine */
+	case AEW_S_PARAM:
+
+		/*Copy config structure passed by user */
+		if (copy_from_user(aew_dev_configptr->config,
+				   (struct aew_configuration *)arg,
+				   sizeof(struct aew_configuration))) {
+			*(aew_dev_configptr->config) = aewconfig;
+			up(&aew_dev_configptr->read_blocked);
+			return -EFAULT;
+		}
+
+		/*Call aew_hardware_setup to perform register configuration */
+		result = aew_hardware_setup();
+		if (!result) {	/* Hardware Set up is successful */
+			/*Return the no of bytes required for buffer */
+			result = aew_dev_configptr->size_window;
+		} else {
+			/*Change Configuration Structure to original */
+			*(aew_dev_configptr->config) = aewconfig;
+			dev_err(aewdev, "Error : AEW_S_PARAM  failed\n");
+		}
+
+		break;
+
+		/* This ioctl is used to return parameters in user space */
+	case AEW_G_PARAM:
+		if (aew_dev_configptr->config->aew_config == H3A_AEW_ENABLE) {
+			if (copy_to_user
+			    ((struct aew_configuration *)arg,
+			     aew_dev_configptr->config,
+			     sizeof(struct aew_configuration))) {
+				up(&aew_dev_configptr->read_blocked);
+				return -EFAULT;
+			} else
+				result = aew_dev_configptr->size_window;
+		} else {
+			dev_err(aewdev,
+				"Error : AEW Hardware is not configured.\n");
+			result = -AEW_ERR_SETUP;
+		}
+		break;
+
+		/* This ioctl is used to enable AEW Engine */
+	case AEW_ENABLE:
+		/*Enable AEW Engine if Hardware set up is done */
+		if (aew_dev_configptr->config->aew_config == H3A_AEW_DISABLE) {
+			dev_err(aewdev,
+				"Error : AEW Hardware is not configured.\n");
+			result = -AEW_ERR_SETUP;
+		} else
+			/* Enable AF Engine */
+			aew_engine_setup(1);
+		break;
+
+		/* This ioctl is used to disable AEW Engine */
+	case AEW_DISABLE:
+		/* Disable AEW Engine */
+		aew_engine_setup(0);
+		break;
+
+		/* Invalid Command */
+	default:
+		dev_err(aewdev, "Error: It should not come here!!\n");
+		result = -ENOTTY;
+		break;
+	}
+
+	/*Release the semaphore */
+	up(&aew_dev_configptr->read_blocked);
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* This function will return statistics to user */
+static ssize_t aew_read(struct file *filep, char *kbuff,
+			size_t size, loff_t * offset)
+{
+	void *buffer_temp;
+	int result = 0;
+	int ret;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Semaphore will return immediately if read call is busy */
+	ret = down_trylock(&(aew_dev_configptr->read_blocked));
+	if (ret != 0) {
+		dev_dbg(aewdev, "Read Call : busy  : %d\n", ret);
+		return -EBUSY;
+	}
+
+	/* First Check the size given by user */
+	if (size < aew_dev_configptr->size_window) {
+		/* Return Failure to applicaiton */
+		/*if size is less than required size */
+		dev_dbg(aewdev, "Error : Invalid size of buffer\n");
+		up(&(aew_dev_configptr->read_blocked));
+		return -1;
+	}
+
+	/* The value of buffer_filled flag determines 
+	   the status of statistics */
+	if (aew_dev_configptr->buffer_filled == 0) {
+		/* Decrement the semaphore */
+		dev_dbg(aewdev, "READ CALL IS BLOCKED............\n");
+		/* Block the read call */
+		wait_event_interruptible_timeout(aew_dev_configptr->
+						 aew_wait_queue,
+						 aew_dev_configptr->
+						 buffer_filled, AEW_TIMEOUT);
+		dev_dbg(aewdev, "Read Call is unbloked and waking up.......\n");
+		dev_dbg(aewdev, "Buffer Filled.... %d\n",
+			aew_dev_configptr->buffer_filled);
+	}
+
+	if (aew_dev_configptr->buffer_filled == 1) {
+		/* Disable the interrupts and then swap the buffers */
+		disable_irq(IRQ_H3AINT);
+		dev_dbg(aewdev, "READING............\n");
+
+		/* New Statistics are availaible */
+		aew_dev_configptr->buffer_filled = 0;
+
+		/*Swap application buffer and old buffer */
+		buffer_temp = aew_dev_configptr->buff_old;
+		aew_dev_configptr->buff_old = aew_dev_configptr->buff_app;
+		aew_dev_configptr->buff_app = buffer_temp;
+
+		/* Interrupts are enabled */
+		enable_irq(IRQ_H3AINT);
+
+		/* Copy the entire statistics located in application 
+		   buffer to user space */
+		if (copy_to_user(kbuff, aew_dev_configptr->buff_app,
+				 aew_dev_configptr->size_window)) {
+			dev_err(aewdev, "Error : Read Fault\n");
+			up(&(aew_dev_configptr->read_blocked));
+			return -EFAULT;
+		} else
+			result = aew_dev_configptr->size_window;
+
+		dev_dbg(aewdev, "Reading Done........................\n");
+	}
+
+	dev_dbg(aewdev, "APP BUFF VALUE %x\n",
+		(*((unsigned int *)(aew_dev_configptr->buff_app))));
+
+	/*Increment the semaphore */
+	up(&(aew_dev_configptr->read_blocked));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* This function will handle interrupt generated by H3A Engine. */
+static irqreturn_t aew_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* Busy AF Bit */
+	unsigned int busyaew;
+	/* Temporary Buffer for Swapping */
+	void *buffer_temp;
+
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaew = AEW_GET_PCR;
+
+	/* If AEW engine is not enabled, interrupt is not for AEW */
+	if (((busyaew & 0x10000) >> 16) == 0) {
+		/*printk("busyaf\n"); */
+		return -1;
+	}
+
+	/*Interrupt is generated by AEW, so Service the Interrupt */
+	/*Swap current buffer and old buffer */
+	buffer_temp = aew_dev_configptr->buff_curr;
+	aew_dev_configptr->buff_curr = aew_dev_configptr->buff_old;
+	aew_dev_configptr->buff_old = buffer_temp;
+
+	/* Set the AEWBUFSTAT REgister to current buffer Address */
+	aew_set_address((unsigned
+			 long)(virt_to_phys(aew_dev_configptr->buff_curr)));
+
+	/*Set buffer filled flag to indicate statistics are available */
+	aew_dev_configptr->buffer_filled = 1;
+
+	/*new statistics are available */
+	/* Wake up the read call */
+	wake_up(&(aew_dev_configptr->aew_wait_queue));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return IRQ_HANDLED;
+}
+
+/* file Operation Structure*/
+static struct file_operations aew_fops = {
+	.owner = THIS_MODULE,
+	.open = aew_open,
+	.read = aew_read,
+	.ioctl = aew_ioctl,
+	.release = aew_release,
+};
+static struct platform_device aewdevice = {
+	.name = "davinci_aew",
+	.id = 2,
+	.dev = {
+		.release = aew_platform_release,
+		}
+};
+
+static struct device_driver aew_driver = {
+	.name = "davinci_aew",
+	.bus = &platform_bus_type,
+	.probe = aew_probe,
+	.remove = aew_remove,
+};
+
+/* Function to register Character Device driver */
+int __init aew_init(void)
+{
+	int err;
+	int result;
+
+	/* Checking CCDC Registers */
+	/* Module cannot be inserted if data flow path for 
+	   h3a is not enabled */
+	result = AEW_GET_CCDC_FMTCFG;
+	/* Mask with VPEN Bit to check path */
+	result = result & AEW_VPEN_MASK;
+	result = result >> AEW_FMTCG_VPEN;
+	if (!(result)) {
+		printk
+		    ("\n Davici AEW Driver cannot be loaded\n VIDEO PORT is not enabled");
+		printk("Data Flow path from CCDC is disabled\n");
+		return -1;
+	}
+
+	/*Register the driver in the kernel. 
+	   Get major number dynamically */
+	result = alloc_chrdev_region(&dev, AEW_MAJOR_NUMBER,
+				     AEW_NR_DEVS, DEVICE_NAME);
+	if (result < 0) {
+		printk("Error : Could not register character device\n");
+		return -ENODEV;
+
+	}
+
+	/*allocate memory for device structure and initialize it with 0 */
+	aew_dev_configptr =
+	    (struct aew_device *)kmalloc(sizeof(struct aew_device), GFP_KERNEL);
+	if (!aew_dev_configptr) {
+		printk("Error : kmalloc fail\n");
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+		return -ENOMEM;
+	}
+
+	/* Initialize of character device */
+	cdev_init(&c_dev, &aew_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &aew_fops;
+
+	/* Add character device */
+	err = cdev_add(&c_dev, dev, 1);
+	if (err) {
+		printk("Error : Adding DavinciAEW DeviceFailed\n");
+
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+
+		return -err;
+	}
+
+	/* Register the character device driver */
+	register_chrdev(MAJOR(dev), DEVICE_NAME, &aew_fops);
+	/* register driver as a platform driver */
+	if (driver_register(&aew_driver) != 0) {
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+
+	/* Register the drive as a platform device */
+	if (platform_device_register(&aewdevice) != 0) {
+		driver_unregister(&aew_driver);
+		unregister_chrdev_region(dev, 1);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+	aew_class = class_simple_create(THIS_MODULE, "davinci_aew");
+
+	if (!aew_class) {
+
+		printk("aew_init: error in creating device class\n");
+
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+		platform_device_unregister(&aewdevice);
+
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+
+		cdev_del(&c_dev);
+
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+
+		return -EIO;
+	}
+
+	/* Make entry in the devfs */
+	result = devfs_mk_cdev(dev, S_IFCHR | S_IRUGO | S_IWUSR,
+			       "%s%d", "davinci_aew", 0);
+
+	if (result < 0) {
+		printk("Error : Error in  devfs_register_chrdev\n");
+
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+
+		class_simple_destroy(aew_class);
+
+		cdev_del(&c_dev);
+
+		driver_unregister(&aew_driver);
+		platform_device_unregister(&aewdevice);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+
+		return result;
+	}
+
+	/*Register simple device class */
+	class_simple_device_add(aew_class, dev, NULL, "davinci_aew");
+
+	/* Set up the Interrupt handler for H3AINT interrupt */
+	result =
+	    request_irq(IRQ_H3AINT, aew_isr, SA_SHIRQ, "dm644xh3a_aew",
+			(void *)aew_dev_configptr);
+
+	if (result < 0) {
+		unregister_chrdev_region(dev, AEW_NR_DEVS);
+
+		if (aew_dev_configptr)
+			kfree(aew_dev_configptr);
+
+		class_simple_device_remove(dev);
+
+		devfs_remove("%s%d", "davinci_aew", 0);
+
+		class_simple_destroy(aew_class);
+
+		cdev_del(&c_dev);
+
+		driver_unregister(&aew_driver);
+		platform_device_unregister(&aewdevice);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+
+		printk("\n Error : Request IRQ Failed\n");
+		return result;
+	}
+
+	/* Initialize the device structure */
+	memset(aew_dev_configptr, 0, sizeof(struct aew_device));
+
+	/* Device is not in use */
+	aew_dev_configptr->in_use = AEW_NOT_IN_USE;
+
+	/* No statistics available */
+	aew_dev_configptr->buffer_filled = 0;
+
+	return 0;		/*Sucess */
+}
+
+/*
+=====================aew_cleanup===========================
+*/
+/* This Function is called by the kernel while unloading the driver
+This will unregister the
+ Character Device Driver
+*/
+void __exit aew_cleanup(void)
+{
+	/* Device is in use */
+	if (aew_dev_configptr->in_use == AEW_IN_USE) {
+		printk("Error : Driver in use");
+		return;
+	}
+
+	/*Free device structure */
+	if (aew_dev_configptr)
+		kfree(aew_dev_configptr);
+	aew_dev_configptr = NULL;
+	unregister_chrdev_region(dev, AEW_NR_DEVS);
+
+	/* remove simple class device */
+	class_simple_device_remove(dev);
+
+	/* remove aew device from devfs */
+	devfs_remove("%s%d", "davinci_aew", 0);
+
+	/* destroy simple class */
+	class_simple_destroy(aew_class);
+
+	driver_unregister(&aew_driver);
+	platform_device_unregister(&aewdevice);
+	/* Free the interrupt Handler */
+	free_irq(IRQ_H3AINT, aew_dev_configptr);
+	cdev_del(&c_dev);
+
+	/*unregistering the driver from the kernel */
+	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+}
+
+module_init(aew_init)
+    module_exit(aew_cleanup)
Index: linux-2.6.10/drivers/media/video/davinci/davinci_aew_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_aew_hw.c
@@ -0,0 +1,140 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_aew_hw.c file */
+
+/* include driver header files */
+#include <asm/arch/davinci_aew.h>
+#include <asm/arch/davinci_aew_hw.h>
+#include <linux/device.h>
+extern struct device *aewdev;
+/* Function to set hardware configuration registers */
+int aew_set_register(struct aew_device *aew_dev)
+{
+	unsigned int pcr = 0, win1 = 0, winstart = 0, blkwin = 0, subwin = 0;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+
+	/* Set up the registers */
+	pcr = regr(AEWPCR);
+
+	/* Enable A Law */
+	if (aew_dev->config->alaw_enable == H3A_AEW_ENABLE) {
+		pcr |= AEW_ALAW_EN;
+	} else
+		pcr &= ~AEW_ALAW_EN;
+
+	/*Configure Saturation limit */
+	pcr &= ~AVE2LMT;
+	pcr |= aew_dev->config->saturation_limit << AEW_AVE2LMT_SHIFT;
+	regw(pcr, AEWPCR);
+
+	/*Window parameter configuration */
+
+	/* Configure Window Width in AEWWIN1 register */
+	win1 = 0;
+	win1 |= (aew_dev->config->window_config).height << AEW_WINH_SHIFT;
+
+	/* Configure Window height  in AEWWIN1 register */
+	win1 |= (aew_dev->config->window_config).width << AEW_WINW_SHIFT;
+
+	/* Configure Window vertical count  in AEWWIN2 register */
+	win1 |= (aew_dev->config->window_config).vt_cnt << AEW_VT_COUNT_SHIFT;
+
+	/* Configure Window horizontal count  in AEWWIN1 register */
+	win1 |= (aew_dev->config->window_config).hz_cnt;
+
+	/* Configure Window vertical start  in AEWWIN1 register */
+	regw(win1, AEWWIN1);
+
+	/*Window Start parameter configuration */
+
+	winstart &= ~WINSV;
+	winstart |=
+	    (aew_dev->config->window_config).vt_start << AEW_VT_START_SHIFT;
+
+	/* Configure Window horizontal start  in AEWWIN2 register */
+	winstart &= ~WINSH;
+	winstart |= (aew_dev->config->window_config).hz_start;
+	regw(winstart, AEWINSTART);
+
+	/*Window Line Increment configuration */
+	/*Configure vertical line increment in AEWSUBWIN */
+	subwin &= ~AEWINCV;
+	subwin |=
+	    (aew_dev->config->window_config).
+	    vt_line_incr << AEW_LINE_INCR_SHIFT;
+
+	/* Configuring Horizontal Line increment in AEWSUBWIN */
+	subwin &= ~AEWINCH;
+	subwin |= (aew_dev->config->window_config).hz_line_incr;
+
+	regw(subwin, AEWSUBWIN);
+
+	/* Black Window Configuration */
+	/* Configure vertical start and height in AEWWINBLK */
+	blkwin &= ~BLKWINSV;
+	blkwin |=
+	    (aew_dev->config->blackwindow_config).
+	    vt_start << AEW_BLKWIN_VT_START_SHIFT;
+
+	/* Configure height in Black window */
+	blkwin &= ~BLKWINH;
+	blkwin |= (aew_dev->config->blackwindow_config).height;
+	regw(blkwin, AEWINBLK);
+
+	/* Configure AEWBUFST Register to Current Buffer Address */
+	regw((unsigned int)(virt_to_phys(aew_dev->buff_curr)), AEWBUFST);
+
+	dev_dbg(aewdev, "\n PCR is %x", regr(AEWPCR));
+	dev_dbg(aewdev, "\n SUBWIN is %x", regr(AEWSUBWIN));
+	dev_dbg(aewdev, "\n WINSTART is %x", regr(AEWINSTART));
+	dev_dbg(aewdev, "\n WINBLK is %x", regr(AEWINBLK));
+	dev_dbg(aewdev, "\n WIN1  is %x", regr(AEWWIN1));
+	dev_dbg(aewdev, "\n AEWBUST %x", regr(AEWBUFST));
+
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* Function to enable/ disable AEW Engine */
+inline void aew_engine_setup(int value)
+{
+	unsigned int pcr;
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+	dev_dbg(aewdev, "\nAEW_REG(PCR) Before Setting %x", regr(AEWPCR));
+
+	/* Read Pcr Register */
+	pcr = regr(AEWPCR);
+	pcr &= ~AEW_EN;
+	pcr |= (value << AEW_EN_SHIFT);
+
+	/*Set AF_EN bit in PCR Register */
+	regw(pcr, AEWPCR);
+
+	dev_dbg(aewdev, "\nAfter Setting %d : PCR VALUE %x", value,
+		regr(AEWPCR));
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+
+}
+
+/* Function used to set adddress */
+inline void aew_set_address(unsigned long address)
+{
+	dev_dbg(aewdev, __FUNCTION__ "E\n");
+	regw(address, AEWBUFST);
+	dev_dbg(aewdev, __FUNCTION__ "L\n");
+}
Index: linux-2.6.10/drivers/media/video/davinci/davinci_af.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_af.c
@@ -0,0 +1,838 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_af.c file */
+
+/* Linux specific include files */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk  */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* File Structure... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/cdev.h>
+#include <linux/interrupt.h>	/* For interrupt */
+#include <linux/dma-mapping.h>	/* For class_simple_create */
+#include <asm/uaccess.h>
+#include <linux/wait.h>		/* FILES FOR WAIT QUEUE */
+#include <linux/devfs_fs_kernel.h>	/* for devfs */
+#include <asm/semaphore.h>	/* Semaphore */
+#include <linux/device.h>
+/* Driver include files */
+#include <asm/arch/davinci_af.h>	/*Local Definitions */
+#include <asm/arch/davinci_af_hw.h>	/* Local Definitions */
+
+/* Module License */
+MODULE_LICENSE("GPL");
+
+/*Global structure for device */
+struct af_device *af_dev_configptr;
+static struct class_simple *af_class = NULL;
+
+/* For registeration of charatcer device */
+static struct cdev c_dev;
+
+/* device structure to make entry in device */
+static dev_t dev;
+struct device *afdev = NULL;
+/* inline function to free reserver pages  */
+void inline af_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long tempaddr;
+	unsigned long size;
+	tempaddr = addr;
+	if (!addr)
+		return;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(tempaddr, get_order(bufsize));
+}
+
+/* Function to check paxel parameters */
+int af_check_paxel(void)
+{
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Check horizontal Count */
+	if ((af_dev_configptr->config->paxel_config.hz_cnt
+	     < AF_PAXEL_HORIZONTAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.hz_cnt
+		> AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
+		dev_err(afdev, "Error : Horizontal Count is incorrect");
+		return -AF_ERR_HZ_COUNT;
+	}
+
+	/*Check Vertical Count */
+	if ((af_dev_configptr->config->paxel_config.vt_cnt
+	     < AF_PAXEL_VERTICAL_COUNT_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_cnt
+		> AF_PAXEL_VERTICAL_COUNT_MAX)) {
+		dev_err(afdev, "Error : Vertical Count is incorrect");
+		return -AF_ERR_VT_COUNT;
+	}
+
+	/*Check Height */
+	if ((af_dev_configptr->config->paxel_config.height
+	     < AF_PAXEL_HEIGHT_MIN)
+	    || (af_dev_configptr->config->paxel_config.height
+		> AF_PAXEL_HEIGHT_MAX)) {
+		dev_err(afdev, "Error : Height is incorrect");
+		return -AF_ERR_HEIGHT;
+	}
+
+	/*Check width */
+	if ((af_dev_configptr->config->paxel_config.width < AF_PAXEL_WIDTH_MIN)
+	    || (af_dev_configptr->config->paxel_config.width
+		> AF_PAXEL_WIDTH_MAX)) {
+		dev_err(afdev, "Error : Width is incorrect");
+		return -AF_ERR_WIDTH;
+	}
+
+	/*Check Line Increment */
+	if ((af_dev_configptr->config->paxel_config.line_incr
+	     < AF_PAXEL_INCREMENT_MIN)
+	    || (af_dev_configptr->config->paxel_config.line_incr
+		> AF_PAXEL_INCREMENT_MAX)) {
+		dev_err(afdev, "Error : Line Increment is incorrect");
+		return -AF_ERR_INCR;
+	}
+
+	/*Check Horizontal Start */
+	if ((af_dev_configptr->config->paxel_config.hz_start % 2 != 0)
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		< (af_dev_configptr->config->iir_config.hz_start_pos + 2))
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		> AF_PAXEL_HZSTART_MAX)
+	    || (af_dev_configptr->config->paxel_config.hz_start
+		< AF_PAXEL_HZSTART_MIN)) {
+		dev_err(afdev, "Error : Horizontal Start is incorrect");
+		return -AF_ERR_HZ_START;
+	}
+
+	/*Check Vertical Start */
+	if ((af_dev_configptr->config->paxel_config.vt_start
+	     < AF_PAXEL_VTSTART_MIN)
+	    || (af_dev_configptr->config->paxel_config.vt_start
+		> AF_PAXEL_VTSTART_MAX)) {
+		dev_err(afdev, "Error : Vertical Start is incorrect");
+		return -AF_ERR_VT_START;
+	}
+
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+
+	return 0;		/*Success */
+}
+
+/* Function to check IIR Coefficient */
+int af_check_iir(void)
+{
+	int index;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Check for valid values of IIR coefficients */
+	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
+		/*Check Coefficient of set 0 */
+		if ((af_dev_configptr->config->iir_config.coeff_set0[index])
+		    > AF_COEF_MAX) {
+			dev_err(afdev,
+				"Error : Coefficient for set 0 is incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+
+		/*Check coefficient of set 1 */
+		if ((af_dev_configptr->config->iir_config.coeff_set1[index])
+		    > AF_COEF_MAX) {
+			dev_err(afdev,
+				"Error : Coefficient for set 1 is incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+	}
+
+	/* Check IIRSH Value */
+	if ((af_dev_configptr->config->iir_config.hz_start_pos < AF_IIRSH_MIN)
+	    || (af_dev_configptr->config->iir_config.hz_start_pos >
+		AF_IIRSH_MAX)) {
+		dev_err(afdev, "Error : IIRSH is incorrect");
+		return -AF_ERR_IIRSH;
+	}
+
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return 0;		/*Success */
+}
+
+/* Function to perform hardware set up */
+int af_hardware_setup(void)
+{
+	int result;
+
+	/*Size for buffer in bytes */
+	int buff_size;
+	unsigned long adr, size;
+	unsigned int busyaf;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaf = AF_GET_PCR;
+
+	/* Mask with BUSYAF bit */
+	busyaf = busyaf & AF_BUSYAF;
+
+	/* Shift it 15 times to get value of 1 or 0 */
+	busyaf = busyaf >> 15;
+
+	/*If busy bit is 1 then busy lock registers caanot be configured */
+	if (busyaf == 1) {
+		/* Hardware cannot be configure while engine is busy */
+		dev_err(afdev, "AF_register_setup_ERROR : Engine Bus");
+		dev_err(afdev, "\n Configuration cannot be done ");
+		return -AF_ERR_ENGINE_BUSY;
+	}
+
+	/*Check IIR Coefficient and start Values */
+	result = af_check_iir();
+	if (result < 0)
+		return result;
+
+	/*Check Paxel Values */
+	result = af_check_paxel();
+	if (result < 0)
+		return result;
+
+	/*Check HMF Threshold Values */
+	if (af_dev_configptr->config->hmf_config.threshold > AF_THRESHOLD_MAX) {
+		dev_err(afdev, "Error : HMF Threshold is incorrect");
+		return -AF_ERR_THRESHOLD;
+	}
+
+	/* Compute buffer size */
+	buff_size =
+	    (af_dev_configptr->config->paxel_config.hz_cnt + 1) *
+	    (af_dev_configptr->config->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
+
+	/*Deallocate the previosu buffers */
+	/* free old buffers */
+	if (af_dev_configptr->buff_old)
+		af_free_pages((unsigned long)af_dev_configptr->buff_old,
+			      af_dev_configptr->size_paxel);
+
+	/* Free current buffer */
+	if (af_dev_configptr->buff_curr)
+		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
+			      af_dev_configptr->size_paxel);
+
+	/* Free application buffers */
+	if (af_dev_configptr->buff_app)
+		af_free_pages((unsigned long)af_dev_configptr->buff_app,
+			      af_dev_configptr->size_paxel);
+
+	/* Reallocate the buffer as per new paxel configurations */
+	/*Allocate memory for old buffer */
+	af_dev_configptr->buff_old =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (af_dev_configptr->buff_old == NULL)
+		return -ENOMEM;
+
+	/* allocate the memory for storing old statistics */
+	adr = (unsigned long)af_dev_configptr->buff_old;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for current buffer */
+	af_dev_configptr->buff_curr =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	/* Free the previously allocated buffer */
+	if (af_dev_configptr->buff_curr == NULL) {
+		if (af_dev_configptr->buff_old)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	adr = (unsigned long)af_dev_configptr->buff_curr;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	/*Allocate memory for old buffer */
+	af_dev_configptr->buff_app =
+	    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				     get_order(buff_size));
+
+	if (af_dev_configptr->buff_app == NULL) {
+
+		/*Free the previously allocated buffer */
+		if (af_dev_configptr->buff_curr)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_curr, buff_size);
+		/*Free the previously allocated buffer */
+		if (af_dev_configptr->buff_old)
+			af_free_pages((unsigned long)af_dev_configptr->
+				      buff_old, buff_size);
+		return -ENOMEM;
+	}
+
+	adr = (unsigned long)af_dev_configptr->buff_app;
+	size = PAGE_SIZE << (get_order(buff_size));
+	while (size > 0) {
+		/* make sure the frame buffers
+		   are never swapped out of memory */
+		SetPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	result = af_register_setup(af_dev_configptr);
+	if (result < 0)
+		return result;
+	af_dev_configptr->size_paxel = buff_size;
+
+	/*Set configuration flag to indicate HW setup done */
+	af_dev_configptr->config->af_config = H3A_AF_ENABLE;
+
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	/*Success */
+	return 0;
+}
+
+/* This function called when driver is opened.It creates Channel
+ * Configuration Structure
+ */
+static int af_open(struct inode *inode, struct file *filp)
+{
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/*Return if device is in use */
+	if (af_dev_configptr->in_use == AF_IN_USE)
+		return -EBUSY;
+	af_dev_configptr->config = NULL;
+
+	/* Allocate memory for Device Structure */
+	af_dev_configptr->config = (struct af_configuration *)
+	    kmalloc(sizeof(struct af_configuration)
+		    , GFP_KERNEL);
+	if (af_dev_configptr->config == NULL) {
+		dev_err(afdev, "Error : Kmalloc fail\n");
+		return -ENOMEM;
+	}
+
+	/* Initialize the wait queue */
+	init_waitqueue_head(&(af_dev_configptr->af_wait_queue));
+
+	/* Driver is in use */
+	af_dev_configptr->in_use = AF_IN_USE;
+
+	/* Hardware is not set up */
+	af_dev_configptr->config->af_config = H3A_AF_DISABLE;
+	af_dev_configptr->buffer_filled = 0;
+
+	/* Initialize the semaphore */
+	init_MUTEX(&(af_dev_configptr->read_blocked));
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* This function called when driver is closed.
+ * It will deallocate all the buffers.
+ */
+static int af_release(struct inode *inode, struct file *filp)
+{
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Free all the buffers */
+	/* free current buffer */
+	if (af_dev_configptr->buff_curr)
+		af_free_pages((unsigned long)af_dev_configptr->buff_curr,
+			      af_dev_configptr->size_paxel);
+
+	/*Free old buffer */
+	if (af_dev_configptr->buff_old)
+		af_free_pages((unsigned long)af_dev_configptr->buff_old,
+			      af_dev_configptr->size_paxel);
+
+	/* Free application buffer */
+	if (af_dev_configptr->buff_app)
+		af_free_pages((unsigned long)af_dev_configptr->buff_app,
+			      af_dev_configptr->size_paxel);
+
+	/*Release memory for configuration structure of this channel */
+	af_dev_configptr->buff_curr = NULL;
+	af_dev_configptr->buff_old = NULL;
+	af_dev_configptr->buff_app = NULL;
+	if (af_dev_configptr->config)
+		kfree(af_dev_configptr->config);
+	af_dev_configptr->config = NULL;
+
+	/*Device is not in use */
+	af_dev_configptr->in_use = AF_NOT_IN_USE;
+
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+
+	return 0;
+}
+static void af_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+static int __init af_probe(struct device *device)
+{
+	afdev = device;
+	return 0;
+}
+
+static int af_remove(struct device *device)
+{
+	return 0;
+}
+
+/* This function will process IOCTL commands sent by the application and
+ * control the device IO operations.
+ */
+static int af_ioctl(struct inode *inode, struct file *filep,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct af_configuration afconfig = *(af_dev_configptr->config);
+	int result = 0;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Block the semaphore while ioctl is called */
+	down_interruptible(&af_dev_configptr->read_blocked);
+
+	/*Extract the type and number bitfields, and don't */
+	/* decode wrong cmds */
+	/*return ENOTTY (inappropriate ioctl) */
+	if (_IOC_TYPE(cmd) != AF_MAGIC_NO) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	if (_IOC_NR(cmd) > AF_IOC_MAXNR) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -ENOTTY;
+	}
+
+	/*Use 'access_ok' to validate user space pointer */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		result =
+		    !access_ok(VERIFY_WRITE, (void __user *)arg,
+			       _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		result =
+		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
+	if (result) {
+		/* Release the semaphore */
+		up(&af_dev_configptr->read_blocked);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+
+		/* This ioctl is used to perform hardware */
+		/* set up for AF Engine */
+		/* It will configura all the registers. */
+	case AF_S_PARAM:
+		/*Copy params structure passed by user */
+		if (copy_from_user(af_dev_configptr->config,
+				   (struct af_configuration *)arg,
+				   sizeof(struct af_configuration))) {
+			/* Release the semaphore */
+			up(&af_dev_configptr->read_blocked);
+			return -EFAULT;
+		}
+
+		/*Call AF_hardware_setup to perform register configuration */
+		result = af_hardware_setup();
+		if (!result) {
+			result = af_dev_configptr->size_paxel;
+		} else {
+			dev_err(afdev, "Error : AF_S_PARAM failed");
+			*(af_dev_configptr->config) = afconfig;
+		}
+		break;
+
+		/* This ioctl will get the paramters from application */
+	case AF_G_PARAM:
+		/*Check if Hardware is configured or not */
+		if (af_dev_configptr->config->af_config == H3A_AF_ENABLE) {
+			if (copy_to_user((struct af_configuration *)arg,
+					 af_dev_configptr->config,
+					 sizeof(struct af_configuration))) {
+				up(&af_dev_configptr->read_blocked);
+				return -EFAULT;
+			} else
+				result = af_dev_configptr->size_paxel;
+
+		} else {
+			dev_dbg(afdev, "Error : AF Hardware not configured.");
+			result = -AF_ERR_SETUP;
+		}
+
+		break;
+
+		/* This ioctl will enable AF Engine */
+		/*if hardware configuration is done */
+	case AF_ENABLE:
+		/* Check if hardware is configured or not */
+		if (af_dev_configptr->config->af_config == H3A_AF_DISABLE) {
+			dev_err(afdev, "Error :  AF Hardware not configured.");
+			result = -AF_ERR_SETUP;
+		} else
+			af_engine_setup(1);
+		break;
+
+		/* This ioctl will disable AF Engine */
+	case AF_DISABLE:
+		af_engine_setup(0);
+		break;
+
+	default:
+		dev_err(afdev, "Error : Invalid IOCTL!");
+		result = -ENOTTY;
+		break;
+	}
+
+	/* Before returning increment semaphore */
+	up(&af_dev_configptr->read_blocked);
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* Function will return the statistics to user */
+ssize_t af_read(struct file * filep, char *kbuff, size_t size, loff_t * offset)
+{
+	void *buff_temp;
+	int result = 0;
+	int ret;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Semaphore will return immediately if read call is busy */
+	ret = down_trylock(&(af_dev_configptr->read_blocked));
+	if (ret != 0) {
+		dev_err(afdev, "\n Read Call : busy");
+		return -EBUSY;
+	}
+
+	/*If no of bytes specified by the user is less */
+	/* than that of buffer return error */
+	if (size < af_dev_configptr->size_paxel) {
+		dev_err(afdev, "\n Error : Invalid buffer size");
+		up(&(af_dev_configptr->read_blocked));
+		return -1;	/* Return error to application */
+	}
+
+	/* The value of bufffer_filled flag determines
+	   the status of statistics */
+	if (af_dev_configptr->buffer_filled == 0) {
+		dev_dbg(afdev, "Read call is blocked .......................");
+		/* Block the read call until new statistics are available */
+		/* or timer expires */
+		/* Decrement the semaphore count */
+		wait_event_interruptible_timeout(af_dev_configptr->
+						 af_wait_queue,
+						 af_dev_configptr->
+						 buffer_filled, AF_TIMEOUT);
+		dev_dbg(afdev,
+			"\n Read Call Unblocked..........................");
+	}
+	if (af_dev_configptr->buffer_filled == 1) {
+		/* New Statistics are available */
+		/* Disable the interrupts while swapping the buffers */
+		disable_irq(IRQ_H3AINT);
+		dev_dbg(afdev, "\n Reading.............................");
+
+		af_dev_configptr->buffer_filled = 0;
+
+		/*Swap application buffer and old buffer */
+		buff_temp = af_dev_configptr->buff_old;
+		af_dev_configptr->buff_old = af_dev_configptr->buff_app;
+		af_dev_configptr->buff_app = buff_temp;
+
+		dev_dbg(afdev, "\n Reading Done.............................");
+
+		/* Enable the interrupts  once swapping is done */
+		enable_irq(IRQ_H3AINT);
+
+		/* New Statistics are not availaible */
+		/* copy the application buffer to user */
+		/* Return the entire statistics to user */
+		if (copy_to_user(kbuff, af_dev_configptr->buff_app,
+				 af_dev_configptr->size_paxel)) {
+			/* Release the semaphore in case of fault */
+			up(&(af_dev_configptr->read_blocked));
+			return -EFAULT;
+		} else
+			result = af_dev_configptr->size_paxel;
+	}
+
+	/* Release the seamphore */
+	up(&(af_dev_configptr->read_blocked));
+	dev_dbg(afdev, "\n Read APPLICATION  BUFFER %d",
+		*((int *)((af_dev_configptr->buff_app))));
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return result;
+}
+
+/* This function will handle the H3A interrupt. */
+static irqreturn_t af_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	void *buff_temp;	/*Temporary buffer for swapping */
+	int busyaf;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Get the value of PCR register */
+	busyaf = AF_GET_PCR;
+
+	/* If AF Engine has enabled, interrupt is not for AF */
+	if ((busyaf & 0x01) == 0) {
+		return -1;
+	}
+
+	/*Service  the Interrupt */
+	/*Set buffer filled flag to indicate statistics are available */
+	/*Swap current buffer and old buffer */
+	buff_temp = af_dev_configptr->buff_curr;
+	af_dev_configptr->buff_curr = af_dev_configptr->buff_old;
+	af_dev_configptr->buff_old = buff_temp;
+
+	/* Set AF Buf st to current register address */
+	if (af_dev_configptr->buff_curr)
+		af_set_address((unsigned long)
+			       virt_to_phys(af_dev_configptr->buff_curr));
+
+	/* Wake up read as new statistics are available */
+	af_dev_configptr->buffer_filled = 1;
+	wake_up(&(af_dev_configptr->af_wait_queue));
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return IRQ_HANDLED;
+}
+
+/* File Operation Structure */
+static struct file_operations af_fops = {
+	.owner = THIS_MODULE,
+	.open = af_open,
+	.ioctl = af_ioctl,
+	.read = af_read,
+	.release = af_release
+};
+static struct platform_device afdevice = {
+	.name = "davinci_af",
+	.id = 2,
+	.dev = {
+		.release = af_platform_release,
+		}
+};
+
+static struct device_driver af_driver = {
+	.name = "davinci_af",
+	.bus = &platform_bus_type,
+	.probe = af_probe,
+	.remove = af_remove,
+};
+
+/* Function to register the AF character device driver. */
+int __init af_init(void)
+{
+	int err;
+	int result = 0;
+	result = AF_GET_CCDC_FMTCFG;
+	result = result & AF_VPEN_MASK;
+	result = result >> AF_FMTCG_VPEN;
+	/* H3A Module cannot be inserted if CCDC
+	   path for H3A is not registered */
+	if (!(result)) {
+		/* Module cannot be inserted if CCDC is not configured */
+		printk("\n Davinci AF driver cannot be loaded");
+		printk("\n VIDEO PORT is not enabled ");
+		printk("\n CCDC needs to be configured");
+		return -1;
+	}
+	/*Register the driver in the kernel. Get major number dynamically */
+	result = alloc_chrdev_region(&dev, AF_MAJOR_NUMBER,
+				     AF_NR_DEVS, DEVICE_NAME);
+	if (result < 0) {
+		printk("Error :  Could not register character device");
+		return -ENODEV;
+	}
+
+	/*allocate memory for device structure and initialize it with 0 */
+	af_dev_configptr =
+	    (struct af_device *)kmalloc(sizeof(struct af_device), GFP_KERNEL);
+	if (!af_dev_configptr) {
+		printk("Error : kmalloc fail");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		return -ENOMEM;
+
+	}
+
+	/* Initialize  character device */
+	cdev_init(&c_dev, &af_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &af_fops;
+	err = cdev_add(&c_dev, dev, 1);
+	if (err) {
+		printk("Error : Error in  Adding Davinci AF");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		return -err;
+	}
+
+	/* Registe Character device */
+	register_chrdev(MAJOR(dev), DEVICE_NAME, &af_fops);
+	/* register driver as a platform driver */
+	if (driver_register(&af_driver) != 0) {
+		unregister_chrdev_region(dev, 1);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+
+	/* Register the drive as a platform device */
+	if (platform_device_register(&afdevice) != 0) {
+		driver_unregister(&af_driver);
+		unregister_chrdev_region(dev, 1);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+		cdev_del(&c_dev);
+		return -EINVAL;
+	}
+	af_class = class_simple_create(THIS_MODULE, "davinci_af");
+
+	if (!af_class) {
+		platform_device_unregister(&afdevice);
+		printk("Error : Error in creating device class");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		class_simple_device_remove(dev);
+		class_simple_destroy(af_class);
+		cdev_del(&c_dev);
+		return -EIO;
+	}
+
+	/* make entry in the devfs */
+	result =
+	    devfs_mk_cdev(dev, S_IFCHR | S_IRUGO | S_IWUSR, "%s%d",
+			  "davinci_af", 0);
+
+	if (result < 0) {
+		printk("Error : Error in devfs_register_chrdev");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		class_simple_device_remove(dev);
+		cdev_del(&c_dev);
+		driver_unregister(&af_driver);
+		platform_device_unregister(&afdevice);
+		class_simple_destroy(af_class);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+		return result;
+	}
+
+	/* register simple device class */
+	class_simple_device_add(af_class, dev, NULL, "davinci_af");
+
+	/* Set up the Interrupt handler for H3AINT interrupt */
+	result =
+	    request_irq(IRQ_H3AINT, af_isr, SA_SHIRQ, "dm644xh3a_af",
+			(void *)af_dev_configptr);
+
+	if (result != 0) {
+		printk("Error : Request IRQ Failed");
+		unregister_chrdev_region(dev, AF_NR_DEVS);
+		if (af_dev_configptr)
+			kfree(af_dev_configptr);
+		class_simple_device_remove(dev);
+		devfs_remove("%s%d", "davinci_af", 0);
+		driver_unregister(&af_driver);
+		platform_device_unregister(&afdevice);
+		class_simple_destroy(af_class);
+		cdev_del(&c_dev);
+		unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+		return result;
+	}
+
+	/* Initialize device structure */
+	memset(af_dev_configptr, 0, sizeof(struct af_device));
+
+	af_dev_configptr->in_use = AF_NOT_IN_USE;
+	af_dev_configptr->buffer_filled = 0;
+
+	return 0;		/*Sucess */
+}
+
+/* This function is called by the kernel while unloading the driver.
+ * It will unregister character device driver
+ */
+void __exit af_cleanup(void)
+{
+
+	/* Return if driver is busy */
+	if (af_dev_configptr->in_use == AF_IN_USE) {
+		printk("Error : Driver in use. Can't remove.");
+		return;
+	}
+
+	/*Free device structure */
+	if (af_dev_configptr)
+		kfree(af_dev_configptr);
+
+	unregister_chrdev_region(dev, AF_NR_DEVS);
+
+	/* remove simple class device */
+	class_simple_device_remove(dev);
+
+	/* remove prev device from devfs */
+	devfs_remove("%s%d", "davinci_af", 0);
+
+	/* destroy simple class */
+	class_simple_destroy(af_class);
+
+	driver_unregister(&af_driver);
+	platform_device_unregister(&afdevice);
+	/*unregistering the driver from the kernel */
+	cdev_del(&c_dev);
+	/*Free interrupt line */
+	free_irq(IRQ_H3AINT, af_dev_configptr);
+	/* Unregiser Character device */
+	unregister_chrdev(MAJOR(dev), DEVICE_NAME);
+}
+
+module_init(af_init)
+    module_exit(af_cleanup)
+    MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/media/video/davinci/davinci_af_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/davinci_af_hw.c
@@ -0,0 +1,178 @@
+/* *
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Include driver header file */
+#include <asm/arch/davinci_af_hw.h>
+#include <linux/device.h>
+extern struct device *afdev;
+/* Function to set register */
+int af_register_setup(struct af_device *af_dev)
+{
+	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
+	unsigned int coef = 0;
+	unsigned int base_coef_set0 = 0;
+	unsigned int base_coef_set1 = 0;
+	int index;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	/* Configure Hardware Registers */
+	/* Set PCR Register */
+	pcr = regr(AFPCR);	/* Read PCR Register */
+
+	/*Set Accumulator Mode */
+	if (af_dev->config->mode == ACCUMULATOR_PEAK)
+		pcr |= FVMODE;
+	else
+		pcr &= ~FVMODE;
+
+	/*Set A-law */
+	if (af_dev->config->alaw_enable == H3A_AF_ENABLE)
+		pcr |= AF_ALAW_EN;
+	else
+		pcr &= ~AF_ALAW_EN;
+
+	/*Set RGB Position */
+	pcr &= ~RGBPOS;
+	pcr |= (af_dev->config->rgb_pos) << AF_RGBPOS_SHIFT;
+
+	/*HMF Configurations */
+	if (af_dev->config->hmf_config.enable == H3A_AF_ENABLE) {
+		pcr &= ~AF_MED_EN;
+		/* Enable HMF */
+		pcr |= AF_MED_EN;
+
+		/* Set Median Threshold */
+		pcr &= ~MED_TH;
+		pcr |=
+		    (af_dev->config->hmf_config.threshold) << AF_MED_TH_SHIFT;
+	} else
+		pcr &= ~AF_MED_EN;
+
+	/* Set PCR Register */
+	regw(pcr, AFPCR);
+
+	/* Configure AFPAX1 */
+	/*Paxel parameter configuration */
+	/*Set Width in AFPAX1 Register */
+	pax1 &= ~PAXW;
+	pax1 |= (af_dev->config->paxel_config.width) << AF_PAXW_SHIFT;
+
+	/* Set height in AFPAX1 */
+	pax1 &= ~PAXH;
+	pax1 |= af_dev->config->paxel_config.height;
+
+	regw(pax1, AFPAX1);
+
+	/* Configure AFPAX2 Register */
+	/* Set Line Increment in AFPAX2 Register */
+	pax2 &= ~AFINCV;
+	pax2 |= (af_dev->config->paxel_config.line_incr) << AF_LINE_INCR_SHIFT;
+	/* Set Vertical Count */
+	pax2 &= ~PAXVC;
+	pax2 |= (af_dev->config->paxel_config.vt_cnt) << AF_VT_COUNT_SHIFT;
+	/* Set Horizontal Count */
+	pax2 &= ~PAXHC;
+	pax2 |= af_dev->config->paxel_config.hz_cnt;
+	regw(pax2, AFPAX2);
+
+	/* Configure PAXSTART Register */
+	/*Configure Horizontal Start */
+	paxstart &= ~PAXSH;
+	paxstart |=
+	    (af_dev->config->paxel_config.hz_start) << AF_HZ_START_SHIFT;
+	/* Configure Vertical Start */
+	paxstart &= ~PAXSV;
+	paxstart |= af_dev->config->paxel_config.vt_start;
+	regw(paxstart, AFPAXSTART);
+
+	/*SetIIRSH Register */
+	regw(af_dev->config->iir_config.hz_start_pos, AFIIRSH);
+
+	/*Set IIR Filter0 Coefficients */
+	base_coef_set0 = AFCOEF010;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set0[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set0[index + 1]) << AF_COEF_SHIFT;
+		regw(coef, base_coef_set0);
+		dev_dbg(afdev, "\n COEF0 %x", regr(base_coef_set0));
+		base_coef_set0 = base_coef_set0 + AFCOEF_OFFSET;
+	}
+
+	/* set AFCOEF0010 Register */
+	regw(af_dev->config->iir_config.coeff_set0[10], AFCOEF0010);
+
+	/*Set IIR Filter1 Coefficients */
+
+	base_coef_set1 = AFCOEF110;
+	for (index = 0; index <= 8; index += 2) {
+		coef &= ~COEF_MASK0;
+		coef |= af_dev->config->iir_config.coeff_set1[index];
+		coef &= ~COEF_MASK1;
+		coef |=
+		    (af_dev->config->iir_config.
+		     coeff_set1[index + 1]) << AF_COEF_SHIFT;
+		regw(coef, base_coef_set1);
+		dev_dbg(afdev, "\n COEF1 %x", regr(base_coef_set1));
+		base_coef_set1 = base_coef_set1 + AFCOEF_OFFSET;
+	}
+	/* Set AFCOEF0110 */
+	regw(af_dev->config->iir_config.coeff_set1[10], AFCOEF1010);
+
+	/*Set AFBUFST to Current buffer Physical Address */
+	regw((unsigned int)(virt_to_phys(af_dev->buff_curr)), AFBUFST);
+
+	dev_dbg(afdev, "\n PCR %x", pcr);
+	dev_dbg(afdev, "\n AFPAX1 %x", regr(AFPAX1));
+	dev_dbg(afdev, "\n PAXSTART %x", paxstart);
+	dev_dbg(afdev, "\n PAX2 %x", regr(AFPAX2));
+	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF0010));
+	dev_dbg(afdev, "\n COEF 10  %x", regr(AFCOEF1010));
+	dev_dbg(afdev, "\n AFBUFST %x", regr(AFBUFST));
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+	return 0;
+}
+
+/* Function to Enable/Disable AF Engine */
+inline void af_engine_setup(int enable)
+{
+	unsigned int pcr;
+	dev_dbg(afdev, __FUNCTION__ "E\n");
+
+	pcr = regr(AFPCR);
+	dev_dbg(afdev, "\n Engine Setup value before PCR : %x", pcr);
+
+	/* Set AF_EN bit in PCR Register */
+	if (enable)
+		pcr |= AF_EN;
+	else
+		pcr &= ~AF_EN;
+
+	regw(pcr, AFPCR);
+
+	dev_dbg(afdev, "\n Engine Setup value after PCR : %x", pcr);
+	dev_dbg(afdev, __FUNCTION__ "L\n");
+}
+
+/* Function to set address */
+inline void af_set_address(unsigned long address)
+{
+	regw(address, AFBUFST);
+}
Index: linux-2.6.10/drivers/media/video/davinci/mt9t001.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/mt9t001.c
@@ -0,0 +1,1347 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/device.h>
+#include <media/davinci/mt9t001.h>
+
+#define MT9T001_I2C_ENABLE 1
+/* i2c global variable for mt9t001*/
+static struct i2c_client mt9t001_i2c_client;
+static struct i2c_driver mt9t001_i2c_driver;
+static int mt9t001_i2c_registration = 0;
+struct device *mt9t001_i2c_dev;
+static int CONFIG_PCA9543A = 0;
+
+/*	Function prototype*/
+int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
+static int mt9t001_init(void *arg, void **params);
+static int mt9t001_cleanup(void *params);
+static int mt9t001_configpca9543a(void);
+static int mt9t001_setstd(void *arg, void *params);
+static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats);
+static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats);
+static int mt9t001_queryctrl(void *arg);
+static int mt9t001_setgain(int arg);
+static int mt9t001_getgain(int *arg);
+static int mt9t001_setparams(void *arg);
+static int mt9t001_getparams(void *arg);
+
+/*i2c function proto types*/
+static int i2c_read_reg(struct i2c_client *, unsigned char,
+			unsigned short *, bool);
+static int i2c_write_reg(struct i2c_client *, unsigned char,
+			 unsigned short, bool);
+static int _i2c_attach_client(struct i2c_client *, struct i2c_driver *,
+			      struct i2c_adapter *, int);
+static int _i2c_detach_client(struct i2c_client *);
+static int mt9t001_i2c_probe_adapter(struct i2c_adapter *);
+static int mt9t001_i2c_init(void);
+void mt9t001_i2c_cleanup(void);
+
+/* Parameters for  various format supported  */
+/*Format  is
+{
+	NUMBER OF PIXELS PER LINE, NUMBER OF LINES, 
+	HRIZONTAL BLANKING WIDTH, VERTICAL BLANKING WIDTH, 
+	SHUTTER WIDTH, ROW ADDRESS MODE, COL ADDRESS MODE,
+	BLACK_LEVEL,PIXEL CLOCK CONTROL, 
+	ROW START, COL START
+}
+*/
+
+const struct mt9t001_format_params MT9T001_VGA_30FPS =
+    { 1979, 1467, 21, 31, 822, 0x22, 0x22, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_VGA_60FPS =
+    { 1979, 1467, 21, 31, 582, 0x12, 0x12, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_SVGA_30FPS =
+    { 1639, 1239, 21, 31, 1042, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_SVGA_60FPS =
+    { 1639, 1239, 21, 31, 661, 0x01, 0x01, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_XGA_30FPS =
+    { 1039, 775, 100, 283, 783, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_480P_30FPS =
+    { 1471, 975, 350, 350, 898, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_480P_60FPS =
+    { 1471, 975, 52, 50, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_576P_25FPS =
+    { 1471, 1167, 424, 450, 500, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_576P_50FPS =
+    { 1471, 1167, 84, 48, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_720P_24FPS =
+    { 1299, 729, 300, 282, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_720P_30FPS =
+    { 1299, 729, 22, 220, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_1080P_18FPS =
+    { 1919, 1079, 108, 31, 1095, 0x00, 0x00, 64, 0x8000, 0, 0 };
+
+void mt9t001_readregs(void)
+{
+	unsigned short temp = 0;
+	int err = 0;
+	unsigned char regcnt;
+	/* Here, 0x64 is number of registers for MT9T001 */
+	for (regcnt = 0; regcnt < 0x64; regcnt++) {
+		err = i2c_read_reg(&mt9t001_i2c_client, regcnt,
+				   &temp, MT9T001_I2C_CONFIG);
+		if (err >= 0) {
+			dev_dbg(mt9t001_i2c_dev,
+				"\nread back 0x%x = 0x%x...", regcnt, temp);
+		}
+	}
+}
+
+/*
+ * ======== mt9t001_ctrl  ========
+ */
+
+/*This function will provide different control commands for MT9T001 
+		configuration.*/
+int mt9t001_ctrl(unsigned int cmd, void *arg, void *params)
+{
+	int err = 0;
+	switch (cmd) {
+	case MT9T001_SET_PARAMS:
+		{
+
+			struct mt9t001_params *vpfe_mt9t001params =
+			    (struct mt9t001_params *)params;
+			struct mt9t001_params *user_mt9t001params =
+			    (struct mt9t001_params *)arg;
+
+			/* Update the global parameter of vpfe_obj */
+
+			if ((arg == NULL) || (params == NULL)) {
+				dev_err(mt9t001_i2c_dev, "Invalid argument for \
+							MT9T001_SET_PARAMS ");
+				return -1;
+			}
+
+			memcpy(vpfe_mt9t001params, user_mt9t001params,
+			       sizeof(struct mt9t001_params));
+
+			err = mt9t001_setparams(arg);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 set parameters fails...");
+				return err;
+			}
+			break;
+
+		}
+	case MT9T001_SET_STD:
+		{
+			err = mt9t001_setstd(arg, params);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 set standard fails...");
+				return err;
+			} else {
+				//mt9t001_readregs();
+			}
+			break;
+		}
+	case MT9T001_GET_PARAMS:
+		{
+
+			struct mt9t001_params *vpfe_mt9t001params =
+			    (struct mt9t001_params *)params;
+			struct mt9t001_params *user_mt9t001params =
+			    (struct mt9t001_params *)arg;
+
+			err = mt9t001_getparams(arg);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 get parameters  fails...");
+				return err;
+			}
+			/* Update the global parameter of vpfe_obj */
+			memcpy(vpfe_mt9t001params, user_mt9t001params,
+			       sizeof(struct mt9t001_params));
+			break;
+		}
+	case MT9T001_ENABLE_I2C_SWITCH:
+		/* enable the i2c switch on the MT9T031 head board */
+		CONFIG_PCA9543A = 1;
+		break;
+	case MT9T001_INIT:
+		{
+			err = mt9t001_init(arg, params);
+			if (err < 0) {
+				printk(KERN_ERR
+				       "\n Unable to initialize MT9T001...");
+				return err;
+			}
+			break;
+		}
+	case MT9T001_CLEANUP:
+		{
+			mt9t001_cleanup(params);
+
+			break;
+		}
+	case VIDIOC_S_CTRL:
+		{
+			struct v4l2_control *ctrl = arg;
+
+			if (ctrl->id == V4L2_CID_GAIN) {
+				err = mt9t001_setgain((int)ctrl->value);
+				if (err < 0) {
+					dev_err(mt9t001_i2c_dev,
+						"\n MT9T001 set gain fails...");
+					return err;
+				}
+			} else {
+				err = -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_G_CTRL:
+		{
+			struct v4l2_control *ctrl = arg;
+
+			if (ctrl->id == V4L2_CID_GAIN) {
+				err = mt9t001_getgain((int *)
+						      &(ctrl->value));
+				if (err < 0) {
+					dev_err(mt9t001_i2c_dev,
+						"\n MT9T001 get gain fails...");
+					return err;
+				}
+			} else {
+				err = -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_QUERYCTRL:
+		{
+			err = mt9t001_queryctrl(arg);
+			break;
+		}
+	default:
+		{
+			dev_err(mt9t001_i2c_dev, "\n Undefined command");
+			return -1;
+		}
+
+	}
+	return err;
+}
+
+/*
+ * ======== mt9t001_init  ========
+ */
+/*	This function will set the video format standart*/
+static int mt9t001_init(void *arg, void **params)
+{
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+	struct mt9t001_params *temp_params = NULL;
+	int err = 0;
+
+#if MT9T001_I2C_ENABLE
+	/* Register MT9T001 I2C client */
+	err = i2c_add_driver(driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register MT9T001 I2C client.\n");
+		return -1;
+	}
+	mt9t001_i2c_registration = MT9T001_I2C_REGISTERED;
+#endif
+	temp_params = kmalloc(sizeof(struct mt9t001_params), GFP_KERNEL);
+	if (temp_params == NULL) {
+		printk(KERN_ERR "\n Unable to allocate memory...");
+		return -1;
+	}
+	(*params) = temp_params;
+	/* enable path from mt9t001 to */
+	err |= i2c_write_reg(&mt9t001_i2c_client, ECP_REGADDR,
+			     ECP_REGVAL, ECP_I2C_CONFIG);
+	if (CONFIG_PCA9543A)
+		mt9t001_configpca9543a();
+	/*Configure the MT9T001 in normalpower up mode */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			     MT9T001_ROW_START_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			     MT9T001_COL_START_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			     MT9T001_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			     MT9T001_HEIGHT_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			     MT9T001_HBLANK_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			     MT9T001_VBLANK_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_OUTPUT_CTRL_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |=
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			  MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT,
+			  MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			     MT9T001_SHUTTER_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			     MT9T001_PIXEL_CLK_CTRL_DEFAULT,
+			     MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESTART,
+			     MT9T001_RESTART_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_DELAY,
+			     MT9T001_SHUTTER_DELAY_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE1,
+			     MT9T001_READ_MODE1_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE2,
+			     MT9T001_READ_MODE2_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE3,
+			     MT9T001_READ_MODE3_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			     MT9T001_ROW_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			     MT9T001_COL_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
+			     MT9T001_GREEN1_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			     MT9T001_BLUE_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			     MT9T001_RED_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
+			     MT9T001_GREEN2_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
+			     MT9T001_GLOBAL_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			     MT9T001_BLACK_LEVEL_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
+			     MT9T001_CAL_COARSE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			     MT9T001_CAL_TARGET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			     MT9T001_GREEN1_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			     MT9T001_GREEN2_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
+			     MT9T001_RED_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
+			     MT9T001_BLUE_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			     MT9T001_BLK_LVL_CALIB_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CHIP_ENABLE_SYNC,
+			     MT9T001_CHIP_ENABLE_SYNC_DEFAULT,
+			     MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
+			     MT9T001_RESET_ENABLE, MT9T001_I2C_CONFIG);
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
+			     MT9T001_RESET_DISABLE, MT9T001_I2C_CONFIG);
+	/* delay applying changes  */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_HALT_MODE, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			     MT9T001_INVERT_PIXEL_CLK, MT9T001_I2C_CONFIG);
+
+	/*Configure the MT9T001 in normalpower up mode */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		mt9t001_cleanup((*params));
+	} else {
+		/* Configure for default video standard */
+		err = mt9t001_setstd(arg, (*params));
+
+		if (err < 0) {
+			mt9t001_cleanup(params);
+		}
+	}
+	return err;
+}
+
+static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats)
+{
+	int err = 0;
+	unsigned short val = 0;
+
+	/*Read the height width and blanking information required 
+	   for particular format */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			   &mt9tformats->row_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...height");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			   &mt9tformats->col_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...width");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			   &mt9tformats->h_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...hblk");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			   &mt9tformats->v_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...vblk");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...shutterwidth");
+		return err;
+	}
+	mt9tformats->shutter_width = val & MT9T001_SHUTTER_WIDTH_LOWER_MASK;
+
+	err =
+	    i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			 &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...upper");
+		return err;
+	}
+	mt9tformats->shutter_width |= ((val & MT9T001_SHUTTER_WIDTH_UPPER_MASK)
+				       << MT9T001_SHUTTER_WIDTH_UPPER_SHIFT);
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			   &mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmoderow");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			   &mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmodecol");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			   &mt9tformats->black_level, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...black_level");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			   &mt9tformats->row_start, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...rowstart");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			   &mt9tformats->col_start, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...colstart");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			   &mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...clkctrl");
+		return err;
+	}
+	return err;
+}
+
+static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats)
+{
+	int err = 0;
+
+	/*Write the height width and blanking information required 
+	   for particular format */
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			    mt9tformats->row_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...height");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			    mt9tformats->col_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...width");
+		return err;
+	}
+	/* Configure for default video standard */
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			    mt9tformats->h_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...hblk");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			    mt9tformats->v_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...vblk");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			    (unsigned short)(mt9tformats->
+					     shutter_width &
+					     MT9T001_SHUTTER_WIDTH_LOWER_MASK),
+			    MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...shutterwidth");
+		return err;
+	}
+
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			  (unsigned short)(mt9tformats->
+					   shutter_width >>
+					   MT9T001_SHUTTER_WIDTH_UPPER_SHIFT),
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...upper");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			    mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...addrmoderow");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			    mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...addrmodecol");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			    mt9tformats->black_level, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...black_level");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			    mt9tformats->row_start, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...rowstart");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			    mt9tformats->col_start, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...colstart");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			    mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...clkctrl");
+		return err;
+	}
+	/* applying changes  */
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			    MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...outputctrl");
+		return err;
+	}
+
+	return err;
+}
+
+/*
+ * ======== configPCA9543A  ========
+ */
+/*	This function will configure PCA9543 control register*/
+static int mt9t001_configpca9543a()
+{
+	int err = 0;
+	/* enable path from mt9t001 to */
+	err |= i2c_write_reg(&mt9t001_i2c_client, ECP_REGADDR,
+			     ECP_REGVAL, ECP_I2C_CONFIG);
+
+	/* Configure PCA9543A, here discard register address */
+	err = i2c_write_reg(&mt9t001_i2c_client, 0,
+			    PCA9543A_REGVAL, PCA9543A_I2C_CONFIG);
+	return err;
+}
+
+/*
+ * ======== mt9t001_cleanup  ========
+ */
+
+/*This function will free the memory allocated for mt9t001_params*/
+static int mt9t001_cleanup(void *params)
+{
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+	struct mt9t001_params *temp_params = (struct mt9t001_params *)params;
+	if (temp_params != NULL)
+		kfree(temp_params);
+	params = NULL;
+#if MT9T001_I2C_ENABLE
+	if (mt9t001_i2c_registration) {
+		i2c_detach_client(&mt9t001_i2c_client);
+		i2c_del_driver(driver);
+		mt9t001_i2c_client.adapter = NULL;
+		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * ======== mt9t001_setstd  ========
+ */
+
+/*	Function to set the video frame format*/
+static int mt9t001_setstd(void *arg, void *params)
+{
+	v4l2_std_id mode = *(v4l2_std_id *) arg;
+	struct mt9t001_format_params mt9tformats;
+	int err = 0;
+
+	/* Select configuration parameters as per video mode  */
+	if (mode == MT9T001_MODE_VGA_30FPS) {
+		mt9tformats = MT9T001_VGA_30FPS;
+	} else if (mode == MT9T001_MODE_VGA_60FPS) {
+		mt9tformats = MT9T001_VGA_60FPS;
+	} else if (mode == MT9T001_MODE_SVGA_30FPS) {
+		mt9tformats = MT9T001_SVGA_30FPS;
+	} else if (mode == MT9T001_MODE_SVGA_60FPS) {
+		mt9tformats = MT9T001_SVGA_60FPS;
+	} else if (mode == MT9T001_MODE_XGA_30FPS) {
+		mt9tformats = MT9T001_XGA_30FPS;
+	} else if (mode == MT9T001_MODE_480p_30FPS) {
+		mt9tformats = MT9T001_480P_30FPS;
+	} else if (mode == MT9T001_MODE_480p_60FPS) {
+		mt9tformats = MT9T001_480P_60FPS;
+	} else if (mode == MT9T001_MODE_576p_25FPS) {
+		mt9tformats = MT9T001_576P_25FPS;
+	} else if (mode == MT9T001_MODE_576p_50FPS) {
+		mt9tformats = MT9T001_576P_50FPS;
+	} else if (mode == MT9T001_MODE_720p_24FPS) {
+		mt9tformats = MT9T001_720P_24FPS;
+	} else if (mode == MT9T001_MODE_720p_30FPS) {
+		mt9tformats = MT9T001_720P_30FPS;
+	} else if (mode == MT9T001_MODE_1080p_18FPS) {
+		mt9tformats = MT9T001_1080P_18FPS;
+	} else {
+		printk(KERN_ERR "\n Invalid frame format");
+		return -1;
+	}
+
+	err = mt9t001_setformat(&mt9tformats);
+
+	return err;
+
+}
+
+/*
+ * ======== mt9t001_setparams  ========
+ */
+
+/* This function will configure MT9T001 for bayer pattern capture.*/
+static int mt9t001_setparams(void *arg)
+{
+	/*variable to store the return value of i2c read, write function */
+	int err = 0;
+	struct mt9t001_params *mt9t001params = (struct mt9t001_params *)arg;
+	unsigned short val;
+	if (arg == NULL) {
+		dev_err(mt9t001_i2c_dev, "Invalid argument in config MT9T001");
+		return -1;
+	}
+	/* set video format related parameters */
+	err = mt9t001_setformat(&mt9t001params->format);
+
+	/*Write the gain information */
+	val = (unsigned short)(mt9t001params->rgb_gain.green1_analog_gain
+			       & MT9T001_ANALOG_GAIN_MASK);
+
+	val |= ((mt9t001params->rgb_gain.green1_digital_gain
+		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)(mt9t001params->rgb_gain.red_analog_gain)
+	    & MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.red_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT)
+		& MT9T001_DIGITAL_GAIN_MASK);
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)(mt9t001params->rgb_gain.blue_analog_gain)
+	    & MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.blue_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT)
+		& MT9T001_DIGITAL_GAIN_MASK);
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)((mt9t001params->rgb_gain.green2_analog_gain)
+			       << MT9T001_ANALOG_GAIN_SHIFT) &
+	    MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.green2_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write the offset value in register */
+
+	val = mt9t001params->black_calib.green1_offset
+	    & MT9T001_GREEN1_OFFSET_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.green2_offset
+	    & MT9T001_GREEN2_OFFSET_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.red_offset & MT9T001_RED_OFFSET_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.blue_offset & MT9T001_BLUE_OFFSET_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write other black caliberation information */
+
+	val = (unsigned short)(mt9t001params->black_calib.manual_override)
+	    & MT9T001_MANUAL_OVERRIDE_MASK;
+	val |= ((mt9t001params->black_calib.disable_calibration)
+		<< MT9T001_DISABLE_CALLIBERATION_SHIFT)
+	    & MT9T001_DISABLE_CALLIBERATION_MASK;
+	val |= ((mt9t001params->black_calib.recalculate_black_level)
+		<< MT9T001_RECAL_BLACK_LEVEL_SHIFT)
+	    & MT9T001_RECAL_BLACK_LEVEL_MASK;
+	val |= ((mt9t001params->black_calib.lock_red_blue_calibration)
+		<< MT9T001_LOCK_RB_CALIBRATION_SHIFT)
+	    & MT9T001_LOCK_RB_CALLIBERATION_MASK;
+	val |= ((mt9t001params->black_calib.lock_green_calibration)
+		<< MT9T001_LOCK_GREEN_CALIBRATION_SHIFT)
+	    & MT9T001_LOCK_GREEN_CALLIBERATION_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write Thresholds Value */
+
+	val = (unsigned short)mt9t001params->black_calib.low_coarse_thrld
+	    & MT9T001_LOW_COARSE_THELD_MASK;
+	val |= (mt9t001params->black_calib.high_coarse_thrld
+		<< MT9T001_HIGH_COARSE_THELD_SHIFT) &
+	    MT9T001_HIGH_COARSE_THELD_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)mt9t001params->black_calib.low_target_thrld
+	    & MT9T001_LOW_TARGET_THELD_MASK;
+	val |= (mt9t001params->black_calib.high_target_thrld
+		<< MT9T001_HIGH_TARGET_THELD_SHIFT)
+	    & MT9T001_HIGH_TARGET_THELD_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of configMT9T001...");
+	return 0;
+
+}
+
+/*
+ * ======== queryctrl ========
+ */
+ /* This function will return parameter values for control command passed */
+static int mt9t001_queryctrl(void *arg)
+{
+	struct v4l2_queryctrl *queryctrl = arg;
+	int ret = 0;
+	int id = queryctrl->id;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_queryctrl...");
+	if (queryctrl == NULL) {
+		dev_err(mt9t001_i2c_dev,
+			"\n Invalid argument in query control");
+		return -1;
+	}
+
+	memset(queryctrl, 0, sizeof(*queryctrl));
+	queryctrl->id = id;
+	switch (id) {
+	case V4L2_CID_GAIN:
+		strcpy(queryctrl->name, "GAIN");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = MT9T001_GAIN_MINVAL;
+		queryctrl->maximum = MT9T001_GAIN_MAXVAL;
+		queryctrl->step = MT9T001_GAIN_STEP;
+		queryctrl->default_value = MT9T001_GAIN_DEFAULTVAL;
+		break;
+	default:
+		if (id < V4L2_CID_LASTP1)
+			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
+		else
+			ret = -EINVAL;
+		break;
+	}			/* end switch (id) */
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_queryctrl...");
+	return ret;
+}
+
+/*
+ * ======== mt9t001_setgain  ========
+ */
+
+/*	This function will set the global gain of MT9T001*/
+static int mt9t001_setgain(int arg)
+{
+
+	unsigned short gain = (unsigned short)arg;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev,
+		"\nStarting mt9t001_setgain with gain = %d...", (int)gain);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN, gain,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_setgain...");
+	return err;
+}
+
+/*
+ * ======== mt9t001_getgain  ========
+ */
+
+/*	This function will get the global gain of MT9T001*/
+static int mt9t001_getgain(int *arg)
+{
+	unsigned short gain;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getgain...");
+	if (arg == NULL) {
+		dev_err(mt9t001_i2c_dev,
+			"\nInvalid argument pointer in get gain function");
+		return -1;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
+			   &gain, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C reads fails...");
+		return err;
+	}
+	*arg = gain;
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_getgain...");
+	return err;
+}
+
+/*
+ * ======== mt9t001_getparams  ========
+ */
+
+/*This function will get MT9T001 configuration values.*/
+
+static int mt9t001_getparams(void *arg)
+{
+
+	struct mt9t001_params *params = (struct mt9t001_params *)arg;
+	unsigned short val;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getparams");
+
+	/* get video format related parameters */
+	err = mt9t001_getformat(&params->format);
+
+	if (err < 0) {
+		return err;
+	}
+	/*      Read green1 gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.green1_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.green1_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read blue gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.blue_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.blue_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read red gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.red_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.red_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read green2 gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.green2_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.green2_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read green1 offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.green1_offset = val & MT9T001_GREEN1_OFFSET_MASK;
+
+	/*      Read green2 offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.green2_offset = val & MT9T001_GREEN2_OFFSET_MASK;
+
+	/*      Read red offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.red_offset = val & MT9T001_RED_OFFSET_MASK;
+
+	/*      Read blue offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.blue_offset = val & MT9T001_BLUE_OFFSET_MASK;
+
+	/*      Read Black level caliberation information */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.manual_override =
+	    val & MT9T001_MANUAL_OVERRIDE_MASK;
+	params->black_calib.disable_calibration =
+	    (val & MT9T001_DISABLE_CALLIBERATION_MASK)
+	    >> MT9T001_DISABLE_CALLIBERATION_SHIFT;
+	params->black_calib.recalculate_black_level =
+	    (val & MT9T001_RECAL_BLACK_LEVEL_MASK)
+	    >> MT9T001_RECAL_BLACK_LEVEL_SHIFT;
+	params->black_calib.lock_red_blue_calibration =
+	    (val & MT9T001_LOCK_RB_CALLIBERATION_MASK)
+	    >> MT9T001_LOCK_RB_CALIBRATION_SHIFT;
+	params->black_calib.lock_green_calibration =
+	    (val & MT9T001_LOCK_GREEN_CALLIBERATION_MASK)
+	    >> MT9T001_LOCK_GREEN_CALIBRATION_SHIFT;
+
+	/*      Read Black Level Caliberation Coarse Threshold Value */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.low_coarse_thrld = val
+	    & MT9T001_LOW_COARSE_THELD_MASK;
+	params->black_calib.high_coarse_thrld =
+	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
+	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
+
+	/*      Read Black Level Caliberation Target Threshold Value */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.low_target_thrld = val
+	    & MT9T001_LOW_TARGET_THELD_MASK;
+	params->black_calib.high_target_thrld =
+	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
+	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
+
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of getparamsMT9T001...");
+	return 0;
+}
+
+/*
+ * ======== i2c_read_reg  ========
+ */
+
+/*This function is used to read value from register for i2c client. */
+
+static int i2c_read_reg(struct i2c_client *client, unsigned char reg,
+			unsigned short *val, bool configdev)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else if (configdev == ECP_I2C_CONFIG) {
+		msg->addr = ECP_I2C_ADDR;
+		msg->flags = 0;
+		msg->len = I2C_ONE_BYTE_TRANSFER;
+		msg->buf = data;
+		data[0] = reg;
+
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			msg->len = I2C_ONE_BYTE_TRANSFER;	/* 1 byte read */
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			} else {
+				dev_err(mt9t001_i2c_dev,
+					"\n ERROR in ECP control register read\n");
+
+			}
+		} else {
+			dev_err(mt9t001_i2c_dev,
+				"\n ERROR in ECP control register read\n");
+		}
+
+	} else if (configdev == MT9T001_I2C_CONFIG) {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = I2C_ONE_BYTE_TRANSFER;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			msg->len = I2C_TWO_BYTE_TRANSFER;	/* 2 byte read */
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = ((data[0] & I2C_TXRX_DATA_MASK)
+					<< I2C_TXRX_DATA_SHIFT)
+				    | (data[1] & I2C_TXRX_DATA_MASK);
+			}
+		}
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== i2c_write_reg  ========
+ */
+/*This function is used to write value into register for i2c client. */
+static int i2c_write_reg(struct i2c_client *client, unsigned char reg,
+			 unsigned short val, bool configdev)
+{
+	int err = 0;
+	int trycnt = 0;
+	unsigned short readval = 0;
+
+#ifdef MT9T001_I2C_ENABLE
+
+	struct i2c_msg msg[1];
+	unsigned char data[3];
+	err = -1;
+	while ((err < 0) && (trycnt < 5)) {
+		trycnt++;
+		if (!client->adapter) {
+			err = -ENODEV;
+		} else if (configdev == ECP_I2C_CONFIG) {
+			/* if device is ECP then discard reg value
+			 * and set ECP I2C address 
+			 */
+			msg->addr = ECP_I2C_ADDR;
+			msg->flags = 0;
+			msg->len = I2C_TWO_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (unsigned char)(reg & I2C_TXRX_DATA_MASK);
+			data[1] = (unsigned char)(val & I2C_TXRX_DATA_MASK);
+
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err < 0) {
+				printk(KERN_INFO
+				       "\n ERROR in ECP  register write\n");
+			}
+		} else if (configdev == PCA9543A_I2C_CONFIG) {
+			/* if device is ECP then discard reg value
+			 * and set ECP I2C address 
+			 */
+			msg->addr = PCA9543A_I2C_ADDR;
+			msg->flags = 0;
+			msg->len = I2C_ONE_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (unsigned char)(val & I2C_TXRX_DATA_MASK);
+
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err < 0) {
+				printk(KERN_INFO
+				       "\n ERROR in PCA543a  register write\n");
+			}
+		} else if (configdev == MT9T001_I2C_CONFIG) {
+			msg->addr = client->addr;
+			msg->flags = 0;
+			msg->len = I2C_THREE_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = reg;
+			data[1] = (val & I2C_TXRX_DATA_MASK_UPPER) >>
+			    I2C_TXRX_DATA_SHIFT;
+			data[2] = (val & I2C_TXRX_DATA_MASK);
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				err =
+				    i2c_read_reg(&mt9t001_i2c_client, reg,
+						 &readval, MT9T001_I2C_CONFIG);
+				if ((err >= 0) && (val != readval)) {
+					printk
+					    (KERN_INFO
+					     "\n ERROR: i2c readback failed, val = %d, readval = %d, reg = %d\n",
+					     val, readval, reg);
+				}
+				readval = 0;
+			}
+		}
+	}
+#endif
+	if (err < 0) {
+		printk(KERN_INFO "\n I2C write failed");
+	}
+	return err;
+}
+
+/*
+ * ======== _i2c_attach_client  ========
+ */
+/* This function is used to attach i2c client */
+static int _i2c_attach_client(struct i2c_client *client,
+			      struct i2c_driver *driver,
+			      struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== _i2c_detach_client  ========
+ */
+/* This function is used to detach i2c client */
+static int _i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== mt9t001_i2c_probe_adapter  ========
+ */
+
+/*This function is used to probe adapter for i2c_client. It returns
+    0 if i2c_client is attached to adapter and error code on failure.*/
+static int mt9t001_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	mt9t001_i2c_dev = &(adap->dev);
+	return _i2c_attach_client(&mt9t001_i2c_client, &mt9t001_i2c_driver,
+				  adap, MT9T001_I2C_ADDR);
+}
+
+/*
+ * ======== mt9t001_i2c_init  ========
+ */
+
+/*	This function is used to initialize the i2c*/
+static int mt9t001_i2c_init(void)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+
+	driver->owner = THIS_MODULE;
+	strlcpy(driver->name, "MT9T001 CMOS sensor I2C driver",
+		sizeof(driver->name));
+	driver->id = I2C_DRIVERID_EXP0;
+	driver->flags = I2C_DF_NOTIFY;
+	driver->attach_adapter = mt9t001_i2c_probe_adapter;
+	driver->detach_client = _i2c_detach_client;
+#endif
+	return err;
+}
+
+/*
+ * ======== mt9t001_i2c_cleanup  ========
+ */
+
+void mt9t001_i2c_cleanup(void)
+{
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+
+	if (mt9t001_i2c_registration) {
+		i2c_detach_client(&mt9t001_i2c_client);
+		i2c_del_driver(driver);
+		mt9t001_i2c_client.adapter = NULL;
+		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
+	}
+#endif
+}
+
+module_init(mt9t001_i2c_init);
+module_exit(mt9t001_i2c_cleanup);
+
+EXPORT_SYMBOL(mt9t001_ctrl);
+MODULE_LICENSE("GPL");
+
+/**********************************************************************/
+/* End of file                                                        */
+/**********************************************************************/
Index: linux-2.6.10/drivers/media/video/davinci/tvp5146.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/davinci/tvp5146.c
@@ -0,0 +1,823 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* tvp5146.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/device.h>
+#include <media/davinci/tvp5146.h>
+
+static struct i2c_client tvp5146_i2c_client;
+static struct i2c_driver tvp5146_i2c_driver;
+static int tvp5146_i2c_registration = 0;
+struct device *tvp5146_i2c_dev;
+
+static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+
+static int configtvp5146(void *arg);
+static int clrtvp5146lostlock(void);
+static int enabletvp5146agc(int arg);
+static int getctrl(void *arg);
+static int gettvp5146status(void *arg);
+static int powerdowntvp5146(int powerdownenable);
+static int queryctrl(void *arg);
+static int resettvp5146(void);
+static int setctrl(void *arg);
+static int settvp5146amuxmode(int mode);
+static int settvp5146brightness(int arg);
+static int settvp5146contrast(int arg);
+static int settvp5146hue(int arg);
+static int settvp5146saturation(int arg);
+static int settvp5146std(int arg);
+static int setup656sync(tvp5146_params * tvp5146params);
+static int enable_ccdc2tvp5146(struct i2c_client *client);
+
+#define IS_DM355 (1)
+
+/*
+ * ======== tvp5146_init  ========
+ */
+/* This function is used initialize TVP5146 i2c client */
+static int tvp5146_init(void)
+{
+	int err;
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	err = i2c_add_driver(driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register TVP5146 I2C client.\n");
+	} else {
+		tvp5146_i2c_registration = TVP5146_I2C_REGISTERED;
+	}
+	if (IS_DM355)
+		enable_ccdc2tvp5146(&tvp5146_i2c_client);
+	return err;
+}
+
+/*
+ * ======== tvp5146_cleanup  ========
+ */
+/* This function is used detach TVP5146 i2c client */
+static void tvp5146_cleanup(void)
+{
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+	if (tvp5146_i2c_registration) {
+		i2c_detach_client(&tvp5146_i2c_client);
+		i2c_del_driver(driver);
+		tvp5146_i2c_client.adapter = NULL;
+		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
+	}
+}
+
+/*
+ * ======== configtvp5146 ========
+ */
+/*This function will configure TVP5146 as per arguments passed*/
+static int configtvp5146(void *arg)
+{
+	tvp5146_params *tvp5146params = (tvp5146_params *) arg;
+	int ret = 0;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting configtvp5146...");
+	ret |= setup656sync(tvp5146params);
+	ret |= settvp5146amuxmode(tvp5146params->amuxmode);
+	ret |= settvp5146std(tvp5146params->mode);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of configtvp5146...");
+	return ret;
+}
+
+/*
+ * ======== clrtvp5146lostlock  ========
+ */
+ /*This function is used to clear lost lock bit in TVP5146 register. */
+static int clrtvp5146lostlock(void)
+{
+	int ret = 0;
+	u8 clr = 1;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting clrtvp5146lostlock...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x39, clr);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd clrtvp5146lostlock...");
+	return ret;
+}
+
+/*
+ * ========  enabletvp5146agc ========
+ */
+ /* This function is used to enable automatic gain control in TVP5146 */
+static int enabletvp5146agc(int arg)
+{
+	int ret = 0;
+	int agc;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting enabletvp5146agc...");
+	if (arg == TRUE) {
+		agc = 0xF;
+	} else {
+		agc = 0xC;
+	}
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x01, agc);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd enabletvp5146agc...");
+	return ret;
+}
+
+/*
+ * ========  gettvpctrl ========
+ */
+ /* This function is used to get control value for different control commands */
+static int getctrl(void *arg)
+{
+	struct v4l2_control *ctrl = arg;
+	int ret = 0;
+	u8 value;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting getctrl of TVP5146...");
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x09, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0A, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_SATURATION:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0B, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_HUE:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0C, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_AUTOGAIN:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &value);
+		if ((value & 0x3) == 3) {
+			ctrl->value = TRUE;
+		} else {
+			ctrl->value = FALSE;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of getctrl...");
+	return ret;
+}
+
+/*
+ * ========  gettvp5146std ========
+ */
+ /* This function returns detected TVP5146 input standard */
+static int gettvp5146std(tvp5146_mode * mode)
+{
+	int ret = 0;
+	u8 output1;
+	u8 std;
+	u8 lock_status;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting of gettvp5146std...");
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x2, &std);
+	std &= 0x7;
+	if (std == TVP5146_MODE_AUTO) {
+		ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
+	}
+	std &= 0x7;
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	*mode = std | ((output1 & 0x80) >> 4);	/* square pixel status */
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &lock_status);
+	if ((lock_status & 0xe) != 0xe) {
+		/* not quite locked */
+		ret = -EAGAIN;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146std...");
+	return ret;
+}
+
+/*
+ * ========  gettvp5146status ========
+ */
+ /* This function gets TVP5146 configuration values */
+static int gettvp5146status(void *arg)
+{
+	int ret = 0;
+	tvp5146_status *status = (tvp5146_status *) arg;
+	u8 agc, brightness, contrast, hue, saturation;
+	u8 status_byte;
+	u8 std;
+	u8 output1;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting gettvp5146status...");
+	ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &agc);
+	if ((agc & 0x3) == 3) {
+		status->agc_enable = TRUE;
+	} else {
+		status->agc_enable = FALSE;
+	}
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x09, &brightness);
+	status->brightness = brightness;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0A, &contrast);
+	status->contrast = contrast;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0B, &saturation);
+	status->saturation = saturation;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0C, &hue);
+	status->hue = hue;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &status_byte);
+	status->field_rate = (status_byte & 0x20) ? 50 : 60;
+	status->lost_lock = (status_byte & 0x10) >> 4;
+	status->csubc_lock = (status_byte & 0x8) >> 3;
+	status->v_lock = (status_byte & 0x4) >> 2;
+	status->h_lock = (status_byte & 0x2) >> 1;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	if (std | 0x80) {	/* auto switch mode */
+		status->video_std = TVP5146_MODE_AUTO;
+	} else {
+		status->video_std = std;
+	}
+	status->video_std |= ((output1 & 0x80) >> 4);	/* square pixel status */
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146status...");
+	return ret;
+}
+
+/*
+ * ======== powerdowntvp5146 ========
+ */
+ /* This function will put TVP5146 in power down/up mode */
+static int powerdowntvp5146(int powerdownenable)
+{
+	u8 powerdownsettings = 0x01;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting powerdowntvp5146...");
+	/*Put _tvp5146 in power down mode */
+	if (!powerdownenable) {
+		powerdownsettings = 0x00;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of powerdowntvp5146...");
+	return i2c_write_reg(&tvp5146_i2c_client, 0x03, powerdownsettings);
+}
+
+/*
+ * ======== resettvp5146========
+ */
+  /* This function will configure TVP5146 with default values */
+static int resettvp5146(void)
+{
+	tvp5146_params tvp5146params = { 0 };
+	dev_dbg(tvp5146_i2c_dev, "\nStarting resettvp5146...");
+
+	tvp5146params.enablebt656sync = TRUE;
+	tvp5146params.data_width = TVP5146_WIDTH_8BIT;
+
+	setup656sync(&tvp5146params);
+
+	settvp5146amuxmode(TVP5146_AMUX_COMPOSITE);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of resettvp5146...");
+	return powerdowntvp5146(FALSE);
+}
+
+/*
+ * ======== queryctrl ========
+ */
+  /* This function will return parameter values for control command passed */
+static int queryctrl(void *arg)
+{
+	struct v4l2_queryctrl *queryctrl = arg;
+	int ret = 0;
+	int id = queryctrl->id;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting queryctrl...");
+	memset(queryctrl, 0, sizeof(*queryctrl));
+	queryctrl->id = id;
+	switch (id) {
+	case V4L2_CID_BRIGHTNESS:
+		strcpy(queryctrl->name, "BRIGHTNESS");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+	case V4L2_CID_CONTRAST:
+		strcpy(queryctrl->name, "CONTRAST");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+
+	case V4L2_CID_SATURATION:
+		strcpy(queryctrl->name, "SATURATION");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+	case V4L2_CID_HUE:
+		strcpy(queryctrl->name, "HUE");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = -128;	/* -180 DEGREE */
+		queryctrl->maximum = 127;	/* 180  DEGREE */
+		queryctrl->step = 1;
+		queryctrl->default_value = 0;	/* 0 DEGREE */
+		break;
+
+	case V4L2_CID_AUTOGAIN:
+		strcpy(queryctrl->name, "Automatic Gain Control");
+		queryctrl->type = V4L2_CTRL_TYPE_BOOLEAN;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 1;
+		queryctrl->step = 1;
+		queryctrl->default_value = 1;
+		break;
+	default:
+		if (id < V4L2_CID_LASTP1)
+			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
+		else
+			ret = -EINVAL;
+		break;
+	}			/* end switch (id) */
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of queryctrl...");
+	return ret;
+}
+
+/*
+ * ======== setctrl ========
+ */
+  /* This function will set parameter values for control command passed */
+static int setctrl(void *arg)
+{
+	struct v4l2_control *ctrl = arg;
+	int ret = 0;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting setctrl...");
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ret = settvp5146brightness(ctrl->value);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = settvp5146contrast(ctrl->value);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = settvp5146saturation(ctrl->value);
+		break;
+	case V4L2_CID_HUE:
+		ret = settvp5146hue(ctrl->value);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		ret = enabletvp5146agc(ctrl->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of setctrl...");
+	return ret;
+}
+
+/*
+ * ======== settvp5146amuxmode ========
+ */
+ /* This function is used to configure analog interface */
+static int settvp5146amuxmode(int arg)
+{
+	u8 input_sel;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146amuxmode...");
+	if (arg == TVP5146_AMUX_COMPOSITE) {	/* composite */
+		input_sel = 0x05;
+	} else if (arg == TVP5146_AMUX_SVIDEO) {	/* s-video */
+		input_sel = 0x46;
+	} else {
+		return -EINVAL;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146amuxmode...");
+	return i2c_write_reg(&tvp5146_i2c_client, 0x00, input_sel);
+}
+
+/*
+ * ======== settvp5146brightness ========
+ */
+ /* This function is used to configure brightness */
+static int settvp5146brightness(int arg)
+{
+	int ret = 0;
+	u8 brightness = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146brightness...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x09, brightness);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146brightness...");
+	return ret;
+}
+
+/*
+* ======== settvp5146contrast ========
+*/
+ /* This function is used to configure contrast */
+static int settvp5146contrast(int arg)
+{
+	int ret = 0;
+	u8 contrast = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146contrast...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0A, contrast);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146contrast...");
+	return ret;
+}
+
+/*
+* ======== settvp5146hue ========
+*/
+ /* This function is used to configure hue value */
+static int settvp5146hue(int arg)
+{
+	int ret = 0;
+	u8 hue = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146hue...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0C, hue);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146hue...");
+	return ret;
+}
+
+/*
+* ======== settvp5146saturation ========
+*/
+ /* This function is used to configure saturation value */
+static int settvp5146saturation(int arg)
+{
+	int ret = 0;
+	u8 saturation = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146saturation...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0B, saturation);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146saturation...");
+	return ret;
+}
+
+/*
+* ======== settvp5146std ========
+*/
+/* This function is used to configure TVP5146 for video standard passed 
+  *by application
+  */
+static int settvp5146std(int arg)
+{
+	int ret = 0;
+	u8 std = (u8) arg & 0x7;	/* the 4th-bit is for squre pixel sampling */
+	u8 output1;
+	dev_dbg(tvp5146_i2c_dev, "\nStart settvp5146std...");
+	/* setup the sampling rate: 601 or square pixel */
+	dev_dbg(tvp5146_i2c_dev, "reading i2c registers.\n");
+	ret = i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	output1 |= ((arg & 0x8) << 4);
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x33, output1);
+
+	/* setup the video standard */
+	ret |= i2c_write_reg(&tvp5146_i2c_client, 0x02, std);
+	/* if autoswitch mode, enable all modes for autoswitch */
+	if (std == TVP5146_MODE_AUTO) {
+		u8 mask = 0x3F;	/* enable autoswitch for  all standards */
+		ret = i2c_write_reg(&tvp5146_i2c_client, 0x04, mask);
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146std...");
+	return ret;
+}
+
+/*
+ * ======== setup656sync ========
+ */
+ /* This function will configure TVP5146 output data formatting */
+static int setup656sync(tvp5146_params * tvp5146params)
+{
+	int output1, output2, output3, output4;
+	int output5, output6;
+	int ret = 0;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting setup656sync...");
+	if ((tvp5146params->enablebt656sync)
+	    && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
+		/* Configuration for 8-bit BT656 mode */
+		output1 = 0x40;
+		output4 = 0xFF;
+		output5 = 0x4;
+		output6 = 0;
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
+				  output5);
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
+				  output6);
+	} else if ((!tvp5146params->enablebt656sync)
+		   && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
+
+		/* Configuration for 8-bit seperate sync mode */
+		output1 = 0x43;
+		output4 = 0xAF;
+		output5 = 0x4;
+		output6 = 0x1E;
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
+				  output5);
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
+				  output6);
+	} else if ((!tvp5146params->enablebt656sync)
+		   && (tvp5146params->data_width == TVP5146_WIDTH_16BIT)) {
+
+		/* Configuration for 16-bit seperate sync mode */
+		output1 = 0x41;
+		output4 = 0xAF;
+	} else {
+		return -EINVAL;
+	}
+
+	output2 = 0x11;		/* enable clock, enable Y[9:0] */
+	output3 = 0x0;
+
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT1, output1);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT2, output2);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT3, output3);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT4, output4);
+
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of setup656sync...");
+
+	return ret;
+}
+
+/*
+ * ======== tvp5146_ctrl ========
+ */
+ /* This function handles all TVP5146 control commands */
+int tvp5146_ctrl(tvp5146_cmd cmd, void *arg)
+{
+	int ret = 0;
+	dev_dbg(tvp5146_i2c_dev,
+		"\nStarting tvp5146_ctrl with %d command...", cmd);
+	switch (cmd) {
+	case TVP5146_CONFIG:
+		ret = configtvp5146(arg);
+		break;
+	case TVP5146_RESET:
+		ret = resettvp5146();
+		break;
+	case TVP5146_POWERDOWN:
+		ret = powerdowntvp5146(*(int *)arg);
+		break;
+	case TVP5146_SET_AMUXMODE:
+		ret = settvp5146amuxmode(*(int *)arg);
+		break;
+	case TVP5146_SET_BRIGHTNESS:
+		ret = settvp5146brightness(*(int *)arg);
+		break;
+	case TVP5146_SET_CONTRAST:
+		ret = settvp5146contrast(*(int *)arg);
+		break;
+	case TVP5146_SET_HUE:
+		ret = settvp5146hue(*(int *)arg);
+		break;
+	case TVP5146_SET_SATURATION:
+		ret = settvp5146saturation(*(int *)arg);
+		break;
+	case TVP5146_SET_AGC:
+		ret = enabletvp5146agc(*(int *)arg);
+		break;
+	case TVP5146_SET_VIDEOSTD:
+		ret = settvp5146std(*(int *)arg);
+		break;
+	case TVP5146_CLR_LOSTLOCK:
+		ret = clrtvp5146lostlock();
+		break;
+	case TVP5146_GET_STATUS:
+		ret = gettvp5146status(arg);
+		break;
+	case TVP5146_GET_STD:
+		ret = gettvp5146std(arg);
+		break;
+	case VIDIOC_QUERYCTRL:
+		ret = queryctrl(arg);
+		break;
+	case VIDIOC_G_CTRL:
+		ret = getctrl(arg);
+		break;
+	case VIDIOC_S_CTRL:
+		ret = setctrl(arg);
+		break;
+	case TVP5146_INIT:
+		ret = tvp5146_init();
+		break;
+	case TVP5146_CLEANUP:
+		tvp5146_cleanup();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146_ctrl...");
+	return ret;
+}
+
+/*
+ * ======== i2c_read_reg  ========
+ */
+/*This function is used to read value from register for i2c client. */
+static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	dev_dbg(tvp5146_i2c_dev, "\nStarting tvp5146 i2c read...");
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c read...");
+	return err;
+}
+
+/*
+ * ======== i2c_write_reg  ========
+ */
+/*This function is used to write value into register for i2c client. */
+static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c write...");
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(tvp5146_i2c_dev, " i2c data write \n");
+
+	return err;
+}
+
+/*This function is used to write value into register for i2c client. */
+static int enable_ccdc2tvp5146(struct i2c_client *client)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = 0x25;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = 0x8;
+		data[1] = 0x0;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(tvp5146_i2c_dev, " i2c data write \n");
+
+	return err;
+}
+
+/*
+ * ======== _i2c_attach_client  ========
+ */
+/* This function is used to attach i2c client */
+static int _i2c_attach_client(struct i2c_client *client,
+			      struct i2c_driver *driver,
+			      struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->flags = I2C_CLIENT_ALLOW_USE;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/*
+ * ======== _i2c_detach_client  ========
+ */
+/* This function is used to detach i2c client */
+static int _i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/*
+ * ======== tvp5146_i2c_probe_adapter  ========
+ */
+/* This function is used to probe i2c adapter */
+static int tvp5146_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	tvp5146_i2c_dev = &(adap->dev);
+	return _i2c_attach_client(&tvp5146_i2c_client, &tvp5146_i2c_driver,
+				  adap, TVP5146_I2C_ADDR);
+}
+
+/*
+ * ======== tvp5146_i2c_init  ========
+ */
+/* This function is used initialize TVP5146 i2c client */
+static int tvp5146_i2c_init(void)
+{
+	int err = 0;
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	driver->owner = THIS_MODULE;
+	strlcpy(driver->name, "TVP5146 Video Decoder I2C driver",
+		sizeof(driver->name));
+	driver->id = I2C_DRIVERID_EXP0;
+	driver->flags = I2C_DF_NOTIFY;
+	driver->attach_adapter = tvp5146_i2c_probe_adapter;
+	driver->detach_client = _i2c_detach_client;
+
+	return err;
+}
+
+/*
+ * ======== tvp5146_i2c_cleanup  ========
+ */
+/* This function is used detach TVP5146 i2c client */
+static void tvp5146_i2c_cleanup(void)
+{
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	if (tvp5146_i2c_registration) {
+		i2c_detach_client(&tvp5146_i2c_client);
+		i2c_del_driver(driver);
+		tvp5146_i2c_client.adapter = NULL;
+		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
+	}
+}
+
+module_init(tvp5146_i2c_init);
+module_exit(tvp5146_i2c_cleanup);
+
+EXPORT_SYMBOL(tvp5146_ctrl);
+MODULE_LICENSE("GPL");
+
+/**************************************************************************/
+/* End of file                                                            */
+/**************************************************************************/
Index: linux-2.6.10/drivers/media/video/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/media/video/Makefile
+++ linux-2.6.10/drivers/media/video/Makefile
@@ -9,22 +9,14 @@ zr36067-objs	:=	zoran_procfs.o zoran_dev
 			zoran_driver.o zoran_card.o
 mstone-objs     :=      mainstone.o adcm2650.o 
 
-davinci-vpfe-objs    :=  ccdc_davinci.o davinci_vpfe.o
-
 obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
-obj-$(CONFIG_VIDEO_TVP5146) += tvp5146.o
-obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
-
-obj-$(CONFIG_VIDEO_DAVINCI) += davinci-vpfe.o
+obj-$(CONFIG_ARCH_DAVINCI)	  += davinci/
 
 obj-$(CONFIG_VIDEO_BT848) += bttv.o msp3400.o tvaudio.o \
 	tda7432.o tda9875.o ir-kbd-i2c.o ir-kbd-gpio.o
 obj-$(CONFIG_SOUND_TVMIXER) += tvmixer.o
 
-davinci_aew_driver-objs := davinci_aew_hw.o davinci_aew.o
-obj-$(CONFIG_AEW) += davinci_aew_driver.o
-
 obj-$(CONFIG_VIDEO_ZR36120) += zoran.o
 obj-$(CONFIG_VIDEO_SAA5246A) += saa5246a.o
 obj-$(CONFIG_VIDEO_SAA5249) += saa5249.o
@@ -57,10 +49,6 @@ obj-$(CONFIG_TUNER_3036) += tuner-3036.o
 
 obj-$(CONFIG_VIDEO_TUNER) += tuner.o tda9887.o
 
-
-davinci_af_driver-objs := davinci_af_hw.o davinci_af.o
-obj-$(CONFIG_AF) += davinci_af_driver.o
-
 obj-$(CONFIG_VIDEO_BUF)   += video-buf.o
 obj-$(CONFIG_VIDEO_BUF_DVB) += video-buf-dvb.o
 obj-$(CONFIG_VIDEO_BTCX)  += btcx-risc.o
@@ -72,6 +60,9 @@ obj-$(CONFIG_VIDEO_M32R_AR_M64278) += ar
 obj-$(CONFIG_VIDEO_OMAP_CAMERA) += omap/
 
 obj-$(CONFIG_VIDEO_MAINSTONE_CAMERA) += mstone.o
+
+EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
+
 obj-$(CONFIG_PXA_CAMERA_ZL)          += monahans/
 
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
Index: linux-2.6.10/drivers/video/davincifb.c
===================================================================
--- linux-2.6.10.orig/drivers/video/davincifb.c
+++ /dev/null
@@ -1,2624 +0,0 @@
-/* 
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option)any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davincifb.c	
- */
-
-/*
- * Linux includes	
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/tty.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/fb.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
-#include <linux/moduleparam.h>	/* for module_param() */
-#include <asm/system.h>
-#include <video/davincifb.h>
-#include <video/davinci_vpbe.h>
-
-/*
- * Local includes	
- */
-#include "davincifb_osd.c"
-#include "davincifb_dlcd.c"
-#include "davincifb_venc.c"
-
-/*
- *     Module parameter definations
- */
-static char *options = "";
-
-module_param(options, charp, S_IRUGO);
-
-/*
- * Globals
- */
-/*     Modelist        */
-/* 
- * First mode(0th mode) in case of composite, svideo and component are kept
- * 	dummy. This is for backward compatibility.	
- */
-struct vpbe_fb_videomode svideo[] = {
-	{"DUMMY",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 480,
-	 30,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"NTSC-SV",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 480,
-	 30,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"PAL-SV",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 576,
-	 25,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-
-struct vpbe_fb_videomode component[] = {
-	{"LCD",
-	 FB_VMODE_NONINTERLACED,
-	 720,
-	 480,
-	 60,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"NTSC-CO",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 480,
-	 30,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"PAL-CO",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 576,
-	 25,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"P525",
-	 FB_VMODE_NONINTERLACED,
-	 720,
-	 480,
-	 60,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x22,
-	 1},
-	{"P625",
-	 FB_VMODE_NONINTERLACED,
-	 720,
-	 576,
-	 60,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x22,
-	 1},
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-
-struct vpbe_fb_videomode composite[] = {
-	{"DUMMY_COM",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 480,
-	 30,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"NTSC_COM",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 480,
-	 30,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"PAL_COM",
-	 FB_VMODE_INTERLACED,
-	 720,
-	 576,
-	 25,
-	 0,
-	 0,
-	 0,
-	 0,
-	 0x80,
-	 0x12,
-	 0,
-	 0x80,
-	 0x12,
-	 1},
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode rgb[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode ycc16[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode ycc8[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-
-struct vpbe_fb_videomode prgb[] = {
-        {"PRGB_480",
-         FB_VMODE_NONINTERLACED,
-         640,
-         480,
-         60,
-         95,
-         70,
-         34,
-         11,
-         9,
-         9,
-         0,
-         0x59,
-         0x22,
-         1},
-        {"PRGB_400",
-         FB_VMODE_NONINTERLACED,
-         640,
-         400,
-         60,
-         96,
-         70,
-         40,
-         15,
-         9,
-         9,
-         1,
-         0x58,
-         0x22,
-         1},
-	{"PRGB_350",
-         FB_VMODE_NONINTERLACED,
-         640,
-         350,
-         60,
-         96,
-         70,
-         0x59,
-         0x52,
-         9,
-         9,
-         2,
-         0x58,
-         0x72,
-         1},
-        {"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-
-struct vpbe_fb_videomode srgb[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode epson[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode casio1g[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode udisp[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode stn[] = {
-	{"\0", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-};
-struct vpbe_fb_videomode *modelist[] =
-    { prgb, composite, svideo, component, rgb, ycc16, ycc8, srgb, epson,
-	casio1g, udisp, stn
-};
-
-/*
- * display controller register I/O routines
- */
-u32 dispc_reg_in(u32 offset)
-{
-	return (inl(offset));
-}
-
-u32 dispc_reg_out(u32 offset, u32 val)
-{
-	outl(val, offset);
-	return (val);
-}
-
-u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
-{
-	u32 addr = offset;
-	u32 new_val = (inl(addr) & ~mask) | (val & mask);
-	outl(new_val, addr);
-	return (new_val);
-}
-
-vpbe_dm_info_t dm_static;
-vpbe_dm_info_t *dm = &dm_static;
-static struct fb_ops davincifb_ops;
-
-/* Default resolutions		*/
-#define DISP_XRES	720
-#define DISP_YRES	480
-/*These should be set to the max resolution supported	*/
-#define	DISP_MEMX	720
-#define DISP_MEMY	576
-
-/* Random value chosen for now. Should be within the panel's supported range */
-#define LCD_PANEL_CLOCK	180000
-
-/* All window widths have to be rounded up to a multiple of 32 bytes */
-
-/* The OSD0 window has to be always within VID0. Plus, since it is in RGB565
- * mode, it _cannot_ overlap with VID1.
- * For defaults, we are setting the OSD0 window to be displayed in the top
- * left quadrant of the screen, and the VID1 in the bottom right quadrant.
- * So the default 'xres' and 'yres' are set to  half of the screen width and
- * height respectively. Note however that the framebuffer size is allocated
- * for the full screen size so the user can change the 'xres' and 'yres' by
- * using the FBIOPUT_VSCREENINFO ioctl within the limits of the screen size.
- */
-#define round_32(width)	((((width) + 31) / 32) * 32 )
-
-#define OSD0_FB_PHY	0
-#define OSD0_MAX_BPP	16
-#define	OSD0_LINELENGTH	round_32((DISP_MEMX)*OSD0_MAX_BPP/8)
-/* 16 bpp, Double buffered */
-static struct fb_var_screeninfo osd0_default_var = {
-	.xres = DISP_XRES,
-	.yres = DISP_YRES,
-	.xres_virtual = DISP_XRES,
-	.yres_virtual = DISP_MEMY * DOUBLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 16,
-	.grayscale = 0,
-	.red = {11, 5, 0},
-	.green = {5, 6, 0},
-	.blue = {0, 5, 0},
-	.transp = {0, 0, 0},
-	.nonstd = 0,
-	.activate = FB_ACTIVATE_NOW,
-	.height = -1,
-	.width = -1,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.left_margin = 40,	/* pixclocks */
-	.right_margin = 4,	/* pixclocks */
-	.upper_margin = 8,	/* line clocks */
-	.lower_margin = 2,	/* line clocks */
-	.hsync_len = 4,		/* pixclocks */
-	.vsync_len = 2,		/* line clocks */
-	.sync = 0,
-	.vmode = FB_VMODE_INTERLACED,
-};
-
-/* Using the full screen for OSD1 by default */
-#define OSD1_FB_PHY	0
-#define OSD1_MAXBPP	16
-#define	OSD1_LINELENGTH	round_32(DISP_MEMX*OSD1_MAXBPP/8)
-static struct fb_var_screeninfo osd1_default_var = {
-	.xres = DISP_XRES,
-	.yres = DISP_YRES,
-	.xres_virtual = DISP_XRES,
-	.yres_virtual = DISP_MEMY * DOUBLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 4,
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.vmode = FB_VMODE_INTERLACED,
-};
-
-/* Using the full screen for OSD0 by default */
-#define VID0_FB_PHY	0
-#define VID0_MAXBPP	24	/* RGB888       */
-#define VID0_LINELENGTH	round_32(DISP_MEMX* VID0_MAXBPP /8)
-static struct fb_var_screeninfo vid0_default_var = {
-	.xres = DISP_XRES,
-	.yres = DISP_YRES,
-	.xres_virtual = DISP_XRES,
-	.yres_virtual = DISP_MEMY * TRIPLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 16,	/*YUV 16 bits  */
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds  */
-	.vmode = FB_VMODE_INTERLACED,
-};
-
-/* Using the bottom right quadrant of the screen screen for VID1 by default,
- * but keeping the framebuffer allocated for the full screen, so the user can
- * change the 'xres' and 'yres' later using the FBIOPUT_VSCREENINFO ioctl.
- */
-#define VID1_FB_PHY	0
-#define VID1_MAXBPP	24	/* RGB888       */
-#define VID1_LINELENGTH	round_32(DISP_MEMX* VID1_MAXBPP /8)
-static struct fb_var_screeninfo vid1_default_var = {
-	.xres = DISP_XRES,
-	.yres = DISP_YRES,
-	.xres_virtual = DISP_XRES,
-	.yres_virtual = DISP_MEMY * TRIPLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 16,	/* YUV 4:2:2    */
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.vmode = FB_VMODE_INTERLACED,
-};
-
-#define x_pos(w)    ((w)->win_pos.xpos)
-#define y_pos(w)    ((w)->win_pos.ypos)
-#define	zoom(w)		((w)->zoom)
-/*
- * ======== vpbe_set_display_default ========
- */
-/* This function configures all the display registers in default state.*/
-void vpbe_set_display_default()
-{
-	dispc_reg_out(VENC_VMOD, 0);
-	dispc_reg_out(VENC_CVBS, 0);
-	dispc_reg_out(VENC_CMPNT, 0x100);
-	dispc_reg_merge(PINMUX0, 0 << PINMUX0_RGB666_SHIFT, PINMUX0_RGB666);
-	dispc_reg_merge(PINMUX0, 0 << PINMUX0_LOEEN_SHIFT, PINMUX0_LOEEN);
-	dispc_reg_out(VENC_LCDOUT, 0);
-	dispc_reg_out(VENC_VIDCTL, 0x141);
-	dispc_reg_out(VENC_DCLKCTL, 0);
-	dispc_reg_out(VENC_DCLKPTN0, 0);
-	dispc_reg_out(VENC_SYNCCTL, 0);
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-	dispc_reg_out(VPSS_CLKCTL, 0);
-	dispc_reg_out(VENC_HSPLS, 0);
-	dispc_reg_out(VENC_HSTART, 0);
-	dispc_reg_out(VENC_HVALID, 0);
-	dispc_reg_out(VENC_HINT, 0);
-	dispc_reg_out(VENC_VSPLS, 0);
-	dispc_reg_out(VENC_VSTART, 0);
-	dispc_reg_out(VENC_VVALID, 0);
-	dispc_reg_out(VENC_VINT, 0);
-	dispc_reg_out(VENC_YCCCTL, 0);
-	dispc_reg_out(VENC_DACTST, 0xF000);
-	dispc_reg_out(VENC_DACSEL, 0);
-	dispc_reg_out(VPBE_PCR, 0);
-	dispc_reg_out(VENC_VDPRO, 0);
-}
-
-/* Must do checks against the limits of the output device */
-static int
-davincifb_venc_check_mode(const vpbe_dm_win_info_t * w,
-			  const struct fb_var_screeninfo *var)
-{
-	return 0;
-}
-static void set_sdram_params(char *id, u32 addr, u32 line_length);
-static irqreturn_t davincifb_isr(int irq, void *arg, struct pt_regs *regs)
-{
-	struct vpbe_dm_info *dm = (struct vpbe_dm_info *)arg;
-	unsigned long addr = 0;
-
-	if ((dispc_reg_in(VENC_VSTAT) & 0x00000010) == 0x10) {
-		xchg(&addr, dm->osd0->sdram_address);
-		if (addr) {
-			set_sdram_params(dm->osd0->info.fix.id,
-					 dm->osd0->sdram_address,
-					 dm->osd0->info.fix.line_length);
-			dm->osd0->sdram_address = 0;
-		}
-		addr = 0;
-		xchg(&addr, dm->osd1->sdram_address);
-		if (addr) {
-			set_sdram_params(dm->osd1->info.fix.id,
-					 dm->osd1->sdram_address,
-					 dm->osd1->info.fix.line_length);
-			dm->osd1->sdram_address = 0;
-		}
-		addr = 0;
-		xchg(&addr, dm->vid0->sdram_address);
-		if (addr) {
-			set_sdram_params(dm->vid0->info.fix.id,
-					 dm->vid0->sdram_address,
-					 dm->vid0->info.fix.line_length);
-			dm->vid0->sdram_address = 0;
-		}
-		addr = 0;
-		xchg(&addr, dm->vid1->sdram_address);
-		if (addr) {
-			set_sdram_params(dm->vid1->info.fix.id,
-					 dm->vid1->sdram_address,
-					 dm->vid1->info.fix.line_length);
-			dm->vid1->sdram_address = 0;
-		}
-		return IRQ_HANDLED;
-	} else {
-		++dm->vsync_cnt;
-		wake_up_interruptible(&dm->vsync_wait);
-		return IRQ_HANDLED;
-	}
-	return IRQ_HANDLED;
-}
-
-/* Wait for a vsync interrupt.  This routine sleeps so it can only be called
- * from process context.
- */
-static int davincifb_wait_for_vsync(vpbe_dm_win_info_t * w)
-{
-	vpbe_dm_info_t *dm = w->dm;
-	wait_queue_t wq;
-	unsigned long cnt;
-	int ret;
-
-	init_waitqueue_entry(&wq, current);
-
-	cnt = dm->vsync_cnt;
-	ret = wait_event_interruptible_timeout(dm->vsync_wait,
-					       cnt != dm->vsync_cnt,
-					       dm->timeout);
-	if (ret < 0) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return ret;
-	}
-	if (ret == 0) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return -ETIMEDOUT;
-	}
-
-	return 0;
-}
-
-/* Sets a uniform attribute value over a rectangular area on the attribute
- * window. The attribute value (0 to 7) is passed through the fb_fillrect's
- * color parameter.
- */
-static int davincifb_set_attr_blend(struct fb_fillrect *r)
-{
-	struct fb_info *info = &dm->osd1->info;
-	struct fb_var_screeninfo *var = &dm->osd1->info.var;
-	unsigned long start = 0;
-	u8 blend;
-	u32 width_bytes;
-
-	if (r->dx + r->width > var->xres_virtual)
-		return -EINVAL;
-	if (r->dy + r->height > var->yres_virtual)
-		return -EINVAL;
-	if (r->color < 0 || r->color > 7)
-		return -EINVAL;
-
-	/* since bits_per_pixel = 4, this will truncate the width if it is 
-	 * not even. Similarly r->dx will be rounded down to an even pixel.
-	 * ... Do we want to return an error otherwise?
-	 */
-	width_bytes = r->width * var->bits_per_pixel / 8;
-	start = dm->osd1->fb_base + r->dy * info->fix.line_length
-	    + r->dx * var->bits_per_pixel / 8;
-
-	blend = (((u8) r->color & 0xf) << 4) | ((u8) r->color);
-	while (r->height--) {
-		start += info->fix.line_length;
-		memset((void *)start, blend, width_bytes);
-	}
-
-	return 0;
-}
-
-/* These position parameters are given through fb_var_screeninfo.
- * xp = var.reserved[0], yp = var.reserved[1],
- * xl = var.xres, yl = var.yres
- */
-void set_win_position(char *id, u32 xp, u32 yp, u32 xl, u32 yl)
-{
-	int i = 0;
-
-	if (is_win(id, VID0)) {
-		i = 0;
-	} else if (is_win(id, VID1)) {
-		i = 1;
-	} else if (is_win(id, OSD0)) {
-		i = 2;
-	} else if (is_win(id, OSD1)) {
-		i = 3;
-	}
-
-	dispc_reg_out(OSD_WINXP(i), xp);
-	dispc_reg_out(OSD_WINYP(i), yp);
-	dispc_reg_out(OSD_WINXL(i), xl);
-	dispc_reg_out(OSD_WINYL(i), yl);
-}
-
-static inline void
-get_win_position(vpbe_dm_win_info_t * w, u32 * xp, u32 * yp, u32 * xl, u32 * yl)
-{
-	struct fb_var_screeninfo *v = &w->info.var;
-
-	*xp = x_pos(w);
-	*yp = y_pos(w);
-	*xl = v->xres;
-	*yl = v->yres;
-}
-
-/* Returns 1 if the window parameters are within VID0, 0 otherwise */
-int within_vid0_limits(u32 xp, u32 yp, u32 xl, u32 yl)
-{
-	u32 vid0_xp = 0, vid0_yp = 0, vid0_xl = 0, vid0_yl = 0;
-	if (!dm->vid0)
-		return 1;
-	get_win_position(dm->vid0, &vid0_xp, &vid0_yp, &vid0_xl, &vid0_yl);
-
-	if ((xp >= vid0_xp) && (yp >= vid0_yp) && (xp + xl <= vid0_xp + vid0_xl)
-	    && (yp + yl <= vid0_yp + vid0_yl))
-		return 1;
-	return 0;
-}
-
-/* VID0 must be large enough to hold all other windows */
-static int check_new_vid0_size(u32 xp0, u32 yp0, u32 xl0, u32 yl0)
-{
-	u32 _xp = 0, _yp = 0, _xl = 0, _yl = 0;
-#define WITHIN_LIMITS 				\
-	((_xp >= xp0) && (_yp >= yp0) &&	\
-	(_xp + _xl <= xp0 + xl0) && (_yp + _yl <= yp0 + yl0))
-
-	if (dm->osd0) {
-		get_win_position(dm->osd0, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS) {
-			dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-			return -EINVAL;
-		}
-	}
-	if (dm->osd1) {
-		get_win_position(dm->osd1, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS) {
-			dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-			return -EINVAL;
-		}
-	}
-	if (dm->vid1) {
-		get_win_position(dm->vid1, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS) {
-			dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-			return -EINVAL;
-		}
-	}
-	return 0;
-
-#undef WITHIN_LIMITS
-}
-
-/*
- * ======== davincifb_check_var ========
- */
-/**
- *      davincifb_check_var - Validates a var passed in.
- *      @var: frame buffer variable screen structure
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *	Checks to see if the hardware supports the state requested by
- *	var passed in. This function does not alter the hardware state!!!
- *	This means the data stored in struct fb_info and struct xxx_par do
- *      not change. This includes the var inside of struct fb_info.
- *	Do NOT change these. This function can be called on its own if we
- *	intent to only test a mode and not actually set it.
- *	If the var passed in is slightly off by what the hardware can support
- *	then we alter the var PASSED in to what we can do.
- *
- *	Returns negative errno on error, or zero on success.
- */
-static int
-davincifb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
-{
-	vpbe_dm_win_info_t *w = (vpbe_dm_win_info_t *) info->par;
-	struct fb_var_screeninfo v;
-
-/* Rules:
- * 1) Vid1, OSD0, OSD1 and Cursor must be fully contained inside of Vid0.
- * 2) Vid0 and Vid1 are both set to accept YUV 4:2:2 (for now).
- * 3) OSD window data is always packed into 32-bit words and left justified.
- * 4) Each horizontal line of window data must be a multiple of 32 bytes.
- *    32 bytes = 32 bytes / 2 bytes per pixel = 16 pixels.
- *    This implies that 'xres' must be a multiple of 32 bytes.
- * 5) The offset registers hold the distance between the start of one line and 
- *    the start of the next. This offset value must be a multiple of 32 bytes.
- *    This implies that 'xres_virtual' is also a multiple of 32 bytes. Note 
- *    that 'xoffset' needn't be a multiple of 32 bytes.
- * 6) OSD0 is set to accept RGB565.
- * 	dispc_reg_merge(OSD_OSDWIN0ND, OSD_OSDWIN0ND_RGB0E, OSD_OSDWIN0ND_RGB0E)
- * 7) OSD1 is set to be the attribute window.
- * 8) Vid1 startX = Vid0 startX + N * 16 pixels (32 bytes)
- * 9) Vid1 width = (16*N - 8) pixels
- * 10) both the VID window can't be RGB888
- */
-	memcpy(&v, var, sizeof(v));
-	/* do board-specific checks on the var */
-	if (davincifb_venc_check_mode(w, &v)) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return -EINVAL;
-	}
-	if (is_win(info->fix.id, OSD0)
-	    || is_win(info->fix.id, OSD1)) {
-		v.xres_virtual = v.xres;
-	} else {
-		v.xres_virtual = v.xres;
-	}
-	if (v.xres_virtual < v.xres || v.yres_virtual < v.yres) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return -EINVAL;
-	}
-	if (v.xoffset > v.xres_virtual - v.xres) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return -EINVAL;
-	}
-	if (v.yoffset > v.yres_virtual - v.yres) {
-		dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-		return -EINVAL;
-	}
-
-	if (!is_win(info->fix.id, VID0)) {
-		/* Rule 1 */
-		if (!within_vid0_limits(x_pos(w), y_pos(w), v.xres, v.yres)) {
-			dev_err(dm->dev, "%s :within_vid0_limits fail. \n",
-				__FUNCTION__);
-			return -EINVAL;
-		}
-
-	}
-	if (is_win(info->fix.id, VID0)) {
-		if (check_new_vid0_size(x_pos(w), y_pos(w), v.xres, v.yres)) {
-			dev_err(dm->dev, "%s :chack_new_vid0_size fail\n",
-				__FUNCTION__);
-			return -EINVAL;
-		}
-		/* Rule 10 */
-		if ((dm->vid1->info.var.bits_per_pixel == 24)
-		    && (v.bits_per_pixel == 24)) {
-			dev_err(dm->dev, "%s :Rule violation: both VID can't be\
-			 RGB888.\n", __FUNCTION__);
-			return -EINVAL;
-		}
-	} else if (is_win(info->fix.id, VID1)) {
-		/* Video1 may be in YUV or RGB888 format */
-		if ((v.bits_per_pixel != 16) && (v.bits_per_pixel != 24)) {
-			dev_err(dm->dev, "Exited function %s \n", __FUNCTION__);
-			return -EINVAL;
-		}
-		/* Rule 10 */
-		if ((dm->vid0->info.var.bits_per_pixel == 24)
-		    && (v.bits_per_pixel == 24)) {
-			dev_err(dm->dev,
-				"%s :Rule violation: both VID can't be RGB888.\n",
-				__FUNCTION__);
-			return -EINVAL;
-		}
-	} 
-	memcpy(var, &v, sizeof(v));
-	return 0;
-}
-
-/* Interlaced = Frame mode, Non-interlaced = Field mode */
-void set_interlaced(char *id, unsigned int on)
-{
-	on = (on == 0) ? 0 : ~0;
-
-	if (is_win(id, VID0))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_VFF0);
-	else if (is_win(id, VID1))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_VFF1);
-	else if (is_win(id, OSD0))
-		dispc_reg_merge(OSD_OSDWIN0MD, on, OSD_OSDWIN0MD_OFF0);
-	else if (is_win(id, OSD1))
-		dispc_reg_merge(OSD_OSDWIN1MD, on, OSD_OSDWIN1MD_OFF1);
-}
-
-/* For zooming, we just have to set the start of framebuffer, the zoom factors 
- * and the display size. The hardware will then read only 
- * (display size / zoom factor) area of the framebuffer and  zoom and 
- * display it. In the following function, we assume that the start of 
- * framebuffer and the display size parameters are set already.
- */
-static void set_zoom(int WinID, int h_factor, int v_factor)
-{
-	switch (WinID) {
-	case VID0:
-		dispc_reg_merge(OSD_VIDWINMD,
-				h_factor << OSD_VIDWINMD_VHZ0_SHIFT,
-				OSD_VIDWINMD_VHZ0);
-		dispc_reg_merge(OSD_VIDWINMD,
-				v_factor << OSD_VIDWINMD_VVZ0_SHIFT,
-				OSD_VIDWINMD_VVZ0);
-		break;
-	case VID1:
-		dispc_reg_merge(OSD_VIDWINMD,
-				h_factor << OSD_VIDWINMD_VHZ1_SHIFT,
-				OSD_VIDWINMD_VHZ1);
-		dispc_reg_merge(OSD_VIDWINMD,
-				v_factor << OSD_VIDWINMD_VVZ1_SHIFT,
-				OSD_VIDWINMD_VVZ1);
-		break;
-	case OSD0:
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				h_factor << OSD_OSDWIN0MD_OHZ0_SHIFT,
-				OSD_OSDWIN0MD_OHZ0);
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				v_factor << OSD_OSDWIN0MD_OVZ0_SHIFT,
-				OSD_OSDWIN0MD_OVZ0);
-		break;
-	case OSD1:
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				h_factor << OSD_OSDWIN1MD_OHZ1_SHIFT,
-				OSD_OSDWIN1MD_OHZ1);
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				v_factor << OSD_OSDWIN1MD_OVZ1_SHIFT,
-				OSD_OSDWIN1MD_OVZ1);
-		break;
-	}
-}
-
-/* Chooses the ROM CLUT for now. Can be extended later. */
-void set_bg_color(u8 clut, u8 color_offset)
-{
-	clut = 0;		/* 0 = ROM, 1 = RAM */
-
-	dispc_reg_merge(OSD_MODE, OSD_MODE_BCLUT & clut, OSD_MODE_BCLUT);
-	dispc_reg_merge(OSD_MODE, color_offset << OSD_MODE_CABG_SHIFT,
-			OSD_MODE_CABG);
-}
-
-static void set_sdram_params(char *id, u32 addr, u32 line_length)
-{
-
-	/* The parameters to be written to the registers should be in 
-	 * multiple of 32 bytes
-	 */
-
-	addr = addr;		/* div by 32 */
-	line_length = line_length / 32;
-
-	if (is_win(id, VID0)) {
-		dispc_reg_out(OSD_VIDWIN0ADR, addr);
-		dispc_reg_out(OSD_VIDWIN0OFST, line_length);
-	} else if (is_win(id, VID1)) {
-		dispc_reg_out(OSD_VIDWIN1ADR, addr);
-		dispc_reg_out(OSD_VIDWIN1OFST, line_length);
-	} else if (is_win(id, OSD0)) {
-		dispc_reg_out(OSD_OSDWIN0ADR, addr);
-		dispc_reg_out(OSD_OSDWIN0OFST, line_length);
-	} else if (is_win(id, OSD1)) {
-		dispc_reg_out(OSD_OSDWIN1ADR, addr);
-		dispc_reg_out(OSD_OSDWIN1OFST, line_length);
-	}
-}
-
-void set_win_enable(char *id, unsigned int on)
-{
-	on = (on == 0) ? 0 : ~0;
-
-	if (is_win(id, VID0)) {
-		if (dm->videomode.vmode == FB_VMODE_INTERLACED)
-			/* Turning off VID0 use due to field inversion issue */
-			dispc_reg_merge(OSD_VIDWINMD, 0, OSD_VIDWINMD_ACT0);
-		else
-			dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_ACT0);
-	} else if (is_win(id, VID1))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_ACT1);
-	else if (is_win(id, OSD0))
-		dispc_reg_merge(OSD_OSDWIN0MD, on, OSD_OSDWIN0MD_OACT0);
-	else if (is_win(id, OSD1)) {
-		/* The OACT1 bit is applicable only if OSD1 is not used as 
-		 * the attribute window
-		 */
-		if (!(dispc_reg_in(OSD_OSDWIN1MD) & OSD_OSDWIN1MD_OASW))
-			dispc_reg_merge(OSD_OSDWIN1MD, on, OSD_OSDWIN1MD_OACT1);
-	}
-}
-
-static void set_win_mode(char *id)
-{
-	if (is_win(id, VID0)) {
-		if (dm->vid0->info.var.bits_per_pixel == 16) {
-			/* disable RGB888 format */
-			dispc_reg_merge(OSD_MISCCT,
-					VPBE_DISABLE <<
-					OSD_MISCCT_RGBEN_SHIFT,
-					OSD_MISCCT_RGBEN);
-		}
-		if (dm->vid0->info.var.bits_per_pixel == 24) {
-			/* set RGB888 format */
-			dispc_reg_merge(OSD_MISCCT,
-					SET_0 << OSD_MISCCT_RGBWIN_SHIFT,
-					OSD_MISCCT_RGBWIN);
-			dispc_reg_merge(OSD_MISCCT,
-					VPBE_ENABLE <<
-					OSD_MISCCT_RGBEN_SHIFT,
-					OSD_MISCCT_RGBEN);
-		}
-	}
-
-	if (is_win(id, VID1)) {
-		if (dm->vid1->info.var.bits_per_pixel == 16) {
-			/* disable RGB888 format */
-			dispc_reg_merge(OSD_MISCCT,
-					VPBE_DISABLE <<
-					OSD_MISCCT_RGBEN_SHIFT,
-					OSD_MISCCT_RGBEN);
-		}
-		if (dm->vid1->info.var.bits_per_pixel == 24) {
-			/* set RGB888 format */
-			dispc_reg_merge(OSD_MISCCT,
-					SET_1 << OSD_MISCCT_RGBWIN_SHIFT,
-					OSD_MISCCT_RGBWIN);
-			dispc_reg_merge(OSD_MISCCT,
-					VPBE_ENABLE <<
-					OSD_MISCCT_RGBEN_SHIFT,
-					OSD_MISCCT_RGBEN);
-		}
-	}
-
-	if ((is_win(id, OSD0))) {
-		if (dm->osd0->info.var.bits_per_pixel == 16) {
-			/* set RGB565 format */
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					1 << OSD_OSDWIN0MD_RGB0E_SHIFT,
-					OSD_OSDWIN0MD_RGB0E);
-		} else {
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					0 << OSD_OSDWIN0MD_RGB0E_SHIFT,
-					OSD_OSDWIN0MD_RGB0E);
-		}
-		/* Set bits per pixel */
-		if (dm->osd0->info.var.bits_per_pixel == 8) {
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					3 << OSD_OSDWIN0MD_BMW0_SHIFT,
-					OSD_OSDWIN0MD_BMW0);
-		} else if (dm->osd0->info.var.bits_per_pixel == 4) {
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					2 << OSD_OSDWIN0MD_BMW0_SHIFT,
-					OSD_OSDWIN0MD_BMW0);
-		} else if (dm->osd0->info.var.bits_per_pixel == 2) {
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					1 << OSD_OSDWIN0MD_BMW0_SHIFT,
-					OSD_OSDWIN0MD_BMW0);
-		} else if (dm->osd0->info.var.bits_per_pixel == 1) {
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					0 << OSD_OSDWIN0MD_BMW0_SHIFT,
-					OSD_OSDWIN0MD_BMW0);
-		}
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				(dm->osd0->conf_params.bitmap_params.
-				 blend_info.
-				 bf) << OSD_OSDWIN0MD_BLND0_SHIFT,
-				OSD_OSDWIN0MD_BLND0);
-	}
-	if ((is_win(id, OSD1))) {
-		if (dm->osd1->conf_params.bitmap_params.enable_attribute) {
-			dispc_reg_merge(OSD_OSDWIN1MD, OSD_OSDWIN1MD_OASW,
-					OSD_OSDWIN1MD_OASW);
-			dispc_reg_merge(OSD_OSDWIN1MD,
-					2 << OSD_OSDWIN1MD_BMW1_SHIFT,
-					OSD_OSDWIN1MD_BMW1);
-			dispc_reg_merge(OSD_OSDWIN1MD, 0x00,
-					OSD_OSDWIN1MD_OACT1);
-		} else {
-			dispc_reg_merge(OSD_OSDWIN1MD, 0x00,
-					OSD_OSDWIN1MD_OASW);
-			if (dm->osd1->info.var.bits_per_pixel == 16)
-				/* set RGB565 format */
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						1 <<
-						OSD_OSDWIN1MD_RGB1E_SHIFT,
-						OSD_OSDWIN1MD_RGB1E);
-			else {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						0 <<
-						OSD_OSDWIN1MD_RGB1E_SHIFT,
-						OSD_OSDWIN1MD_RGB1E);
-			}
-			if (dm->osd1->info.var.bits_per_pixel == 8) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						3 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 4) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						2 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 2) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						1 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 1) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						0 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			}
-			dispc_reg_merge(OSD_OSDWIN1MD,
-					(dm->osd1->conf_params.
-					 bitmap_params.blend_info.
-					 bf) << OSD_OSDWIN1MD_BLND1_SHIFT,
-					OSD_OSDWIN1MD_BLND1);
-			dispc_reg_merge(OSD_OSDWIN1MD, ~0, OSD_OSDWIN1MD_OACT1);
-		}
-	}
-}
-
-static int davincifb_set_par(struct fb_info *info)
-{
-	struct vpbe_dm_win_info *w = (struct vpbe_dm_win_info *)info->par;
-	struct fb_var_screeninfo *v = &info->var;
-	u32 start = 0, offset = 0;
-	memset(info->pseudo_palette, 0x0, sizeof(int) * 17);
-
-	/* First set everything in 'dm' */
-	if (is_win(info->fix.id, VID0)) {
-		dm->vid0->info = *info;
-	}
-	if (is_win(info->fix.id, VID1)) {
-		dm->vid1->info = *info;
-	}
-	if (is_win(info->fix.id, OSD0)) {
-		dm->osd0->info = *info;
-	}
-	if (is_win(info->fix.id, OSD1)) {
-		dm->osd1->info = *info;
-	}
-
-	offset = v->yoffset * info->fix.line_length +
-	    v->xoffset * v->bits_per_pixel / 8;
-	start = (u32) w->fb_base_phys + offset;
-	set_sdram_params(info->fix.id, start, info->fix.line_length);
-
-	set_interlaced(info->fix.id, dm->videomode.vmode);
-
-	if (dm->videomode.vmode == FB_VMODE_INTERLACED) {	/* Interlaced */
-		set_win_position(info->fix.id, x_pos(w), y_pos(w) / 2,
-				 v->xres, v->yres / 2);
-	} else {		/* Progressive */
-		set_win_position(info->fix.id, x_pos(w), y_pos(w), v->xres,
-				 v->yres);
-	}
-	set_win_mode(info->fix.id);
-	return 0;
-}
-
-/*
- * davincifb_ioctl - handler for private ioctls.
- */
-static int
-davincifb_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-		unsigned long arg, struct fb_info *info)
-{
-	struct vpbe_dm_win_info *w = (struct vpbe_dm_win_info *)info->par;
-	void __user *argp = (void __user *)arg;
-	struct fb_fillrect rect;
-	zoom_params_t zoom;
-	int retval = 0;
-	long std = 0;
-
-	char *win_id = w->info.fix.id;
-	vpbe_bitmap_blend_params_t blend_para;
-	vpbe_blink_option_t blink_option;
-	vpbe_video_config_params_t vid_conf_params;
-	vpbe_bitmap_config_params_t bitmap_conf_params;
-	vpbe_dclk_t dclk;
-	vpbe_backg_color_t backg_color;
-	struct vpbe_mode_info mode_info;
-	struct vpbe_fb_videomode vmode;
-	struct vpbe_window_position win_pos;
-	struct fb_cursor cursor;
-
-	if (!w->fb_base) {
-		dev_err(dm->dev, "ERROR: window is not enabled while inserting\
-			 the module.\n");
-		return -EINVAL;
-	}
-	switch (cmd) {
-	case FBIO_WAITFORVSYNC:
-		/* This ioctl   accepts an integer argument     to specify a
-		 * display.      We     only support one display,       so we   will
-		 * simply       ignore the argument.
-		 */
-		return davincifb_wait_for_vsync(w);
-		break;
-	case FBIO_SETATTRIBUTE:
-		if (copy_from_user(&rect, argp, sizeof(rect)))
-			return -EFAULT;
-		return davincifb_set_attr_blend(&rect);
-		break;
-	case FBIO_SETPOS:
-		if (copy_from_user(&win_pos, argp, sizeof(win_pos)))
-			return -EFAULT;
-		if (win_pos.xpos >= 0 && win_pos.xpos <= DISP_XRES) {
-			w->win_pos.xpos = win_pos.xpos;
-			if (davincifb_check_var(&w->info.var, &w->info) != 0)
-				return -EFAULT;
-			if (davincifb_set_par(&w->info) != 0)
-				return -EFAULT;
-		} else
-			return -EINVAL;
-		if (win_pos.ypos >= 0 && win_pos.ypos <= DISP_YRES) {
-			w->win_pos.ypos = win_pos.ypos;
-			if (davincifb_check_var(&w->info.var, &w->info) != 0)
-				return -EFAULT;
-			if (davincifb_set_par(&w->info) != 0)
-				return -EFAULT;
-		} else
-			return -EINVAL;
-		break;
-	case FBIO_SETZOOM:
-		if (copy_from_user(&zoom, argp, sizeof(zoom)))
-			return -EFAULT;
-		if (((zoom.zoom_h == 2) ||
-		     (zoom.zoom_h == 0) ||
-		     (zoom.zoom_h == 1)) &&
-		    ((zoom.zoom_v == 2) || (zoom.zoom_v == 0)
-		     || (zoom.zoom_v == 1))) {
-			set_zoom(zoom.window_id, zoom.zoom_h, zoom.zoom_v);
-			return 0;
-		} else {
-			return -EINVAL;
-		}
-		break;
-	case FBIO_ENABLE_DISABLE_WIN:
-		switch (arg) {
-		case 1:
-			retval = vpbe_enable_window(w);
-			break;
-		case 0:
-			retval = vpbe_disable_window(w);
-			break;
-		default:
-			retval = -VPBE_INVALID_PARA_VALUE;
-			break;
-		}
-		break;
-
-	case FBIO_SET_BITMAP_BLEND_FACTOR:
-		if ((retval =
-		     copy_from_user(&blend_para, argp, sizeof(blend_para))) < 0)
-			return retval;
-		if ((retval =
-		     vpbe_bitmap_set_blend_factor(win_id, &blend_para)) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_BITMAP_WIN_RAM_CLUT:
-		if ((retval =
-		     copy_from_user(dm->ram_clut, argp, RAM_CLUT_SIZE)) < 0)
-			return retval;
-		vpbe_bitmap_set_ram_clut();
-		break;
-
-	case FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN:
-		if ((retval = vpbe_enable_disable_attribute_window(arg)) < 0)
-			return retval;
-		break;
-
-	case FBIO_GET_BLINK_INTERVAL:
-		if ((retval = vpbe_get_blinking(win_id, &blink_option)) < 0)
-			return retval;
-		if ((retval =
-		     copy_to_user(argp, &blink_option,
-				  sizeof(blink_option))) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_BLINK_INTERVAL:
-		if ((retval =
-		     copy_from_user(&blink_option, argp,
-				    sizeof(blink_option))) < 0)
-			return retval;
-		if ((retval = vpbe_set_blinking(win_id, &blink_option)) < 0)
-			return retval;
-		break;
-
-	case FBIO_GET_VIDEO_CONFIG_PARAMS:
-		if ((retval =
-		     vpbe_get_vid_params(win_id, &vid_conf_params)) < 0)
-			return retval;
-		if ((retval =
-		     copy_to_user(argp, &vid_conf_params,
-				  sizeof(vid_conf_params))) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_VIDEO_CONFIG_PARAMS:
-		if ((retval =
-		     copy_from_user(&vid_conf_params, argp,
-				    sizeof(vid_conf_params))) < 0)
-			return retval;
-		if ((retval =
-		     vpbe_set_vid_params(win_id, &vid_conf_params)) < 0)
-			return retval;
-		break;
-
-	case FBIO_GET_BITMAP_CONFIG_PARAMS:
-		if ((retval =
-		     vpbe_bitmap_get_params(win_id, &bitmap_conf_params)) < 0)
-			return retval;
-		if ((retval =
-		     copy_to_user(argp, &bitmap_conf_params,
-				  sizeof(bitmap_conf_params))) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_BITMAP_CONFIG_PARAMS:
-		if ((retval =
-		     copy_from_user(&bitmap_conf_params, argp,
-				    sizeof(bitmap_conf_params))) < 0)
-			return retval;
-		if ((retval =
-		     vpbe_bitmap_set_params(win_id, &bitmap_conf_params)) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_DCLK:
-		if (!is_win(win_id, VID0))
-			return -EINVAL;
-		if ((retval = copy_from_user(&dclk, argp, sizeof(dclk))) < 0)
-			return retval;
-		if ((retval = vpbe_set_dclk(&dclk)) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_INTERFACE:
-		if ((retval = vpbe_set_interface(arg)) < 0)
-			return retval;
-		break;
-
-	case FBIO_GET_INTERFACE:
-		if ((retval =
-		     copy_to_user(argp, &dm->display.interface,
-				  sizeof(dm->display.interface))) < 0)
-			return retval;
-		break;
-
-	case FBIO_QUERY_TIMING:
-		if ((retval =
-		     copy_from_user(&mode_info, argp, sizeof(mode_info))) < 0)
-			return retval;
-		if ((retval = vpbe_query_mode(&mode_info)) < 0)
-			return retval;
-		if ((retval =
-		     copy_to_user(argp, &mode_info, sizeof(mode_info))) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_TIMING:
-		if ((retval = copy_from_user(&vmode, argp, sizeof(vmode))) < 0)
-			return retval;
-		if ((retval = vpbe_set_mode(&vmode)) < 0)
-			return retval;
-		break;
-
-	case FBIO_GET_TIMING:
-		if ((retval =
-		     copy_to_user(argp, &dm->videomode,
-				  sizeof(dm->videomode))) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_VENC_CLK_SOURCE:
-		if (!is_win(win_id, VID0))
-			return -EINVAL;
-		if ((retval = vpbe_set_venc_clk_source(arg)) < 0)
-			return retval;
-		break;
-
-	case FBIO_SET_BACKG_COLOR:
-		if ((retval =
-		     copy_from_user(&backg_color, argp,
-				    sizeof(backg_color))) < 0)
-			return retval;
-		if ((retval = vpbe_set_backg_color(&backg_color)) < 0)
-			return retval;
-		break;
-
-	case FBIO_ENABLE_DISPLAY:
-		if (arg) {
-			if ((davincifb_check_var
-			     (&dm->vid0->info.var, &dm->vid0->info)) < 0) {
-				dev_err(dm->dev, "Exited function %s \n",
-					__FUNCTION__);
-				return -EINVAL;
-			}
-			if ((davincifb_check_var
-			     (&dm->vid1->info.var, &dm->vid1->info)) < 0) {
-				dev_err(dm->dev, "Exited function %s \n",
-					__FUNCTION__);
-				return -EINVAL;
-			}
-			if ((davincifb_check_var
-			     (&dm->osd0->info.var, &dm->osd0->info)) < 0) {
-				dev_err(dm->dev, "Exited function %s \n",
-					__FUNCTION__);
-				return -EINVAL;
-			}
-			if ((davincifb_check_var
-			     (&dm->osd1->info.var, &dm->osd1->info)) < 0) {
-				dev_err(dm->dev, "Exited function %s \n",
-					__FUNCTION__);
-				return -EINVAL;
-			}
-			dm->display_enable = 1;
-		} else {
-			dm->display_enable = 0;
-		}
-
-		/* While enabling, enable VENC before DACs
-		   while disabling, disable DACS before VENC 
-		   to minimize corruption */
-		if (arg) 
-			vpbe_enable_venc(arg);
-
-		if (dm->display.interface == PRGB)
-			vpbe_enable_lcd(arg);
-		else if (dm->display.interface == SVIDEO ||
-			 dm->display.interface == COMPONENT ||
-			 dm->display.interface == COMPOSITE)
-			vpbe_enable_dacs(arg);
-		
-		if (!arg)
-			vpbe_enable_venc(arg);
-		break;
-
-	case FBIO_SET_CURSOR:
-		if (copy_from_user(&cursor, argp, sizeof(cursor)))
-			return -EFAULT;
-		if (vpbe_set_cursor_params(&cursor) < 0)
-			return -EFAULT;
-		break;
-		/*backported IOCTLS */
-	case FBIO_GETSTD:
-		std = ((dm->display.mode << 16) | (dm->display.interface));
-		/*(NTSC <<16) | (COPOSITE); */
-		copy_to_user(argp, &std, sizeof(u_int32_t));
-		return 0;
-		break;
-
-	case FBIO_SETPOSX:
-		if (arg >= 0 && arg <= DISP_XRES) {
-			w->win_pos.xpos = arg;
-			if (davincifb_check_var(&w->info.var, &w->info) != 0)
-				return -EFAULT;
-			if (davincifb_set_par(&w->info) != 0)
-				return -EFAULT;
-			return 0;
-		} else
-			return -EINVAL;
-		break;
-
-	case FBIO_SETPOSY:
-		if (arg >= 0 && arg <= DISP_YRES) {
-			w->win_pos.ypos = arg;
-			if (davincifb_check_var(&w->info.var, &w->info) != 0)
-				return -EFAULT;
-			if (davincifb_set_par(&w->info) != 0)
-				return -EFAULT;
-			return 0;
-		} else
-			return -EINVAL;
-		break;
-
-	default:
-		retval = -EINVAL;
-		break;
-	}
-	return retval;
-}
-
-/**
- *  	davincifb_setcolreg - Optional function. Sets a color register.
- *      @regno: Which register in the CLUT we are programming 
- *      @red: The red value which can be up to 16 bits wide 
- *	@green: The green value which can be up to 16 bits wide 
- *	@blue:  The blue value which can be up to 16 bits wide.
- *	@transp: If supported the alpha value which can be up to 16 bits wide.
- *      @info: frame buffer info structure
- * 
- *  	Set a single color register. The values supplied have a 16 bit
- *  	magnitude which needs to be scaled in this function for the hardware.
- *	Things to take into consideration are how many color registers, if
- *	any, are supported with the current color visual. With truecolor mode
- *	no color palettes are supported. Here a psuedo palette is created 
- *	which we store the value in pseudo_palette in struct fb_info. For
- *	pseudocolor mode we have a limited color palette. To deal with this
- *	we can program what color is displayed for a particular pixel value.
- *	DirectColor is similar in that we can program each color field. If
- *	we have a static colormap we don't need to implement this function. 
- * 
- *	Returns negative errno on error, or zero on success.
- */
-static int
-davincifb_setcolreg(unsigned regno, unsigned red, unsigned green,
-		    unsigned blue, unsigned transp, struct fb_info *info)
-{
-	/* only pseudo-palette (16 bpp) allowed */
-	if (regno >= 16)	/* maximum number of palette entries */
-		return 1;
-
-	if (info->var.grayscale) {
-		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
-		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
-	}
-
-	/* Truecolor has hardware-independent 16-entry pseudo-palette */
-	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
-		u32 v;
-
-		if (regno >= 16)
-			return 1;
-
-		red >>= (16 - info->var.red.length);
-		green >>= (16 - info->var.green.length);
-		blue >>= (16 - info->var.blue.length);
-
-		v = (red << info->var.red.offset) |
-		    (green << info->var.green.offset) | (blue << info->var.
-							 blue.offset);
-
-		switch (info->var.bits_per_pixel) {
-		case 16:
-			((u16 *) (info->pseudo_palette))[regno] = v;
-			break;
-		default:
-			return 1;
-		}
-		return 0;
-	}
-	return 0;
-}
-
-/**
- *      davincifb_pan_display - NOT a required function. Pans the display.
- *      @var: frame buffer variable screen structure
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *	Pan (or wrap, depending on the `vmode' field) the display using the
- *  	`xoffset' and `yoffset' fields of the `var' structure.
- *  	If the values don't fit, return -EINVAL.
- *
- *      Returns negative errno on error, or zero on success.
- */
-static int
-davincifb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
-{
-	struct vpbe_dm_win_info *w = (struct vpbe_dm_win_info *)info->par;
-	u32 start = 0, offset = 0;
-
-	if (var->xoffset > var->xres_virtual - var->xres) {
-		return -EINVAL;
-	}
-	if (var->yoffset > var->yres_virtual - var->yres) {
-		return -EINVAL;
-	}
-	offset = var->yoffset * info->fix.line_length +
-	    var->xoffset * var->bits_per_pixel / 8;
-	start = (u32) w->fb_base_phys + offset;
-	if (dm->videomode.vmode == FB_VMODE_NONINTERLACED)
-		set_sdram_params(info->fix.id, start, info->fix.line_length);
-	else {
-		if ((dispc_reg_in(VENC_VSTAT) & 0x00000010) == 0x10)
-			set_sdram_params(info->fix.id, start,
-					 info->fix.line_length);
-		else
-			w->sdram_address = start;
-	}
-	return 0;
-}
-
-/**
- *      davincifb_blank - NOT a required function. Blanks the display.
- *      @blank_mode: the blank mode we want. 
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *      Blank the screen if blank_mode != 0, else unblank. Return 0 if
- *      blanking succeeded, != 0 if un-/blanking failed due to e.g. a 
- *      video mode which doesn't support it. Implements VESA suspend
- *      and powerdown modes on hardware that supports disabling hsync/vsync:
- *      blank_mode == 2: suspend vsync
- *      blank_mode == 3: suspend hsync
- *      blank_mode == 4: powerdown
- *
- *      Returns negative errno on error, or zero on success.
- *
- */
-int davincifb_blank(int blank_mode, struct fb_info *info)
-{
-	/* ... */
-	return 0;
-}
-
-int parse_win_params(char *wp, int *xres, int *yres, int *xpos, int *ypos)
-{
-	char *s;
-
-	if ((s = strsep(&wp, "x")) == NULL)
-		return -EINVAL;
-	*xres = simple_strtoul(s, NULL, 0);
-
-	if ((s = strsep(&wp, "@")) == NULL)
-		return -EINVAL;
-	*yres = simple_strtoul(s, NULL, 0);
-
-	if ((s = strsep(&wp, ",")) == NULL)
-		return -EINVAL;
-	*xpos = simple_strtoul(s, NULL, 0);
-
-	if ((s = strsep(&wp, ":")) == NULL)
-		return -EINVAL;
-	*ypos = simple_strtoul(s, NULL, 0);
-
-	return 0;
-}
-
-struct fb_info *init_fb_info(struct vpbe_dm_win_info *w,
-			     struct fb_var_screeninfo *var, char *id)
-{
-	struct fb_info *info = &(w->info);
-	vpbe_dm_info_t *dm = w->dm;
-
-	/* initialize the fb_info structure */
-	info->flags = FBINFO_DEFAULT;
-	info->fbops = &davincifb_ops;
-	info->screen_base = (char *)(w->fb_base);
-	info->pseudo_palette = w->pseudo_palette;
-	info->par = w;
-
-	/* Initialize variable screeninfo.
-	 * The variable screeninfo can be directly specified by the user
-	 * via an ioctl.
-	 */
-	memcpy(&info->var, var, sizeof(info->var));
-	info->var.activate = FB_ACTIVATE_NOW;
-
-	/* Initialize fixed screeninfo.
-	 * The fixed screeninfo cannot be directly specified by the user, but
-	 * it may change to reflect changes to the var info.
-	 */
-	strlcpy(info->fix.id, id, sizeof(info->fix.id));
-	info->fix.smem_start = w->fb_base_phys;
-	info->fix.smem_len = w->fb_size;
-	info->fix.type = FB_TYPE_PACKED_PIXELS;
-	info->fix.visual = (info->var.bits_per_pixel <= 8) ?
-	    FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
-	info->fix.xpanstep = 0;
-	info->fix.ypanstep = 0;
-	info->fix.ywrapstep = 0;
-	info->fix.type_aux = 0;
-	info->fix.mmio_start = dm->mmio_base_phys;
-	info->fix.mmio_len = dm->mmio_size;
-	info->fix.accel = FB_ACCEL_NONE;
-	w->sdram_address = 0;
-
-	return info;
-}
-
-/* 
- * Pass boot-time options by adding the following string to the boot params:
- * 	video=dm64xxfb:options
- * Valid options:
- * 	output=[ntsc|pal|525p|625p|350p|400p|480p]
- * 	format=[composite|s-video|component|prgb]
- * 	vid0=[off|MxN@X,Y]
- * 	vid1=[off|MxN@X,Y]
- * 	osd0=[off|MxN@X,Y]
- * 	osd1=[off|MxN@X,Y]
- * 		MxN specify the window resolution (displayed size)
- * 		X,Y specify the window position
- * 		M, N, X, Y are integers
- * 		M, X should be multiples of 16
- * 
- *	For example
- *	video=dm64xxfb:output=s-video:format=ntsc:vid0=720x480@0,0
- *	:osd0=off:osd1=off	
- */
-
-int davincifb_setup(char *options)
-{
-	char *this_opt;
-	u32 xres, yres, xpos, ypos;
-	struct fb_info *info;
-	int format_yres = 480;
-	int flag = 0, flag_osd0 = 0, flag_osd1 = 0, flag_vid0 = 0, flag_vid1 =
-	    0;
-
-	/* Default settings for var_screeninfo and fix_screeninfo */
-	info = init_fb_info(dm->vid0, &vid0_default_var, VID0_FBNAME);
-	info->fix.line_length = VID0_LINELENGTH;
-	info = init_fb_info(dm->vid1, &vid1_default_var, VID1_FBNAME);
-	info->fix.line_length = VID1_LINELENGTH;
-	info = init_fb_info(dm->osd0, &osd0_default_var, OSD0_FBNAME);
-	info->fix.line_length = OSD0_LINELENGTH;
-	info = init_fb_info(dm->osd1, &osd1_default_var, OSD1_FBNAME);
-	info->fix.line_length = OSD1_LINELENGTH;
-	/* Configure default settings for video/bitmap/cursor config params */
-	set_vid0_default_conf();
-	set_vid1_default_conf();
-	set_osd0_default_conf();
-	set_osd1_default_conf();
-	set_cursor_default_conf();
-
-	/* Default setting for backg/dclk/display_interface/display_mode */
-	set_dm_default_conf();
-	switch (dm->display.interface) {
-	case SVIDEO:
-	case COMPONENT:
-	case COMPOSITE:{
-			if ((dm->display.mode == NTSC) ||
-			    (dm->display.mode == P525) ||
-			    (dm->display.mode == LCD))
-				format_yres = 480;
-			else
-				/*P625, PAL */
-				format_yres = 576;
-		}
-		break;
-	case PRGB:{
-			if (dm->display.mode == P350)
-				format_yres = 350;
-			else if (dm->display.mode == P400)
-				format_yres = 400;
-			else
-				format_yres = 480;
-		}
-		break;
-	default:
-		break;
-	}
-
-	dm->osd0->info.var.yres = osd0_default_var.yres = format_yres;
-	dm->osd1->info.var.yres = osd1_default_var.yres = format_yres;
-	dm->vid0->info.var.yres = vid0_default_var.yres = format_yres;
-	dm->vid1->info.var.yres = vid1_default_var.yres = format_yres;
-
-	dev_dbg(dm->dev, "davincifb: Options \"%s\"\n", options);
-
-	if (!options || !*options)
-		return 0;
-
-	while ((this_opt = strsep(&options, ":")) != NULL) {
-
-		if (!*this_opt)
-			continue;
-
-		if (!strncmp(this_opt, "output=", 7)) {
-			flag = 1;
-			if (!strncmp(this_opt + 7, "ntsc", 4))
-				dm->display.mode = NTSC;
-			else if (!strncmp(this_opt + 7, "pal", 3))
-				dm->display.mode = PAL;
-			else if (!strncmp(this_opt + 7, "525p", 4))
-				dm->display.mode = P525;
-			else if (!strncmp(this_opt + 7, "625p", 4))
-				dm->display.mode = P625;
-			else if (!strncmp(this_opt + 7, "480p", 4))
-				dm->display.mode = P480;
-			else if (!strncmp(this_opt + 7, "400p", 4))
-				dm->display.mode = P400;
-			else if (!strncmp(this_opt + 7, "350p", 4))
-				dm->display.mode = P350;
-			else
-				dm->display.mode = NTSC;
-		} else if (!strncmp(this_opt, "format=", 7)) {
-			flag = 1;
-			if (!strncmp(this_opt + 7, "s-video", 7))
-				dm->display.interface = SVIDEO;
-			else if (!strncmp(this_opt + 7, "component", 9))
-				dm->display.interface = COMPONENT;
-			else if (!strncmp(this_opt + 7, "composite", 9))
-				dm->display.interface = COMPOSITE;
-			else if (!strncmp(this_opt + 7, "rgb", 3))
-				dm->display.interface = RGB;
-			else if (!strncmp(this_opt + 7, "ycc16", 5))
-				dm->display.interface = YCC16;
-			else if (!strncmp(this_opt + 7, "ycc8", 4))
-				dm->display.interface = YCC8;
-			else if (!strncmp(this_opt + 7, "prgb", 4))
-				dm->display.interface = PRGB;
-			else if (!strncmp(this_opt + 7, "srgb", 4))
-				dm->display.interface = SRGB;
-			else if (!strncmp(this_opt + 7, "epson", 5))
-				dm->display.interface = EPSON;
-			else if (!strncmp(this_opt + 7, "casio1g", 7))
-				dm->display.interface = CASIO1G;
-			else if (!strncmp(this_opt + 7, "udisp", 5))
-				dm->display.interface = UDISP;
-			else if (!strncmp(this_opt + 7, "stn", 3))
-				dm->display.interface = STN;
-			else
-				dm->display.interface = COMPONENT;
-		} else if (!strncmp(this_opt, "vid0=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dm->vid0->window_enable = VPBE_DISABLE;
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				flag_vid0 = 1;
-				dm->vid0->info.var.xres = xres;
-				dm->vid0->info.var.yres = yres;
-				dm->vid0->win_pos.xpos = xpos;
-				dm->vid0->win_pos.ypos = ypos;
-				dm->vid0->window_enable = VPBE_DISABLE;
-				if ((davincifb_check_var
-				     (&dm->vid0->info.var, &dm->vid0->info))
-				    < 0) {
-
-					dm->vid0->info.var.xres =
-					    vid0_default_var.xres;
-					dm->vid0->info.var.yres =
-					    vid0_default_var.yres;
-					dm->vid0->win_pos.xpos = 0;
-					dm->vid0->win_pos.ypos = 0;
-				}
-				dm->vid0->window_enable = VPBE_ENABLE;
-			}
-		} else if (!strncmp(this_opt, "vid1=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dm->vid1->window_enable = VPBE_DISABLE;
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				flag_vid1 = 1;
-				dm->vid1->info.var.xres = xres;
-				dm->vid1->info.var.yres = yres;
-				dm->vid1->win_pos.xpos = xpos;
-				dm->vid1->win_pos.ypos = ypos;
-				dm->vid1->window_enable = VPBE_DISABLE;
-				if ((davincifb_check_var
-				     (&dm->vid1->info.var, &dm->vid1->info))
-				    < 0) {
-					dm->vid1->info.var.xres =
-					    vid1_default_var.xres;
-					dm->vid1->info.var.yres =
-					    vid1_default_var.yres;
-					dm->vid1->win_pos.xpos = 0;
-					dm->vid1->win_pos.ypos = 0;
-				}
-				dm->vid1->window_enable = VPBE_ENABLE;
-			}
-		} else if (!strncmp(this_opt, "osd0=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dm->osd0->window_enable = VPBE_DISABLE;
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				flag_osd0 = 1;
-				dm->osd0->info.var.xres = xres;
-				dm->osd0->info.var.yres = yres;
-				dm->osd0->win_pos.xpos = xpos;
-				dm->osd0->win_pos.ypos = ypos;
-				dm->osd0->window_enable = VPBE_DISABLE;
-				if ((davincifb_check_var
-				     (&dm->osd0->info.var, &dm->osd0->info))
-				    < 0) {
-					dm->osd0->info.var.xres =
-					    osd0_default_var.xres;
-					dm->osd0->info.var.yres =
-					    osd0_default_var.yres;
-					dm->osd0->win_pos.xpos = 0;
-					dm->osd0->win_pos.ypos = 0;
-				}
-				dm->osd0->window_enable = VPBE_ENABLE;
-			}
-		} else if (!strncmp(this_opt, "osd1=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dm->osd1->window_enable = VPBE_DISABLE;
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				flag_osd1 = 1;
-				dm->osd1->info.var.xres = xres;
-				dm->osd1->info.var.yres = yres;
-				dm->osd1->win_pos.xpos = xpos;
-				dm->osd1->win_pos.ypos = ypos;
-				dm->osd1->window_enable = VPBE_DISABLE;
-				if ((davincifb_check_var
-				     (&dm->osd1->info.var, &dm->osd1->info))
-				    < 0) {
-					dm->osd1->info.var.xres =
-					    osd1_default_var.xres;
-					dm->osd1->info.var.yres =
-					    osd1_default_var.yres;
-					dm->osd1->win_pos.xpos = 0;
-					dm->osd1->win_pos.ypos = 0;
-				}
-				dm->osd1->window_enable = VPBE_ENABLE;
-			}
-		}
-	}
-	if (flag) {
-		switch (dm->display.interface) {
-		case SVIDEO:
-		case COMPONENT:
-		case COMPOSITE:{
-				if ((dm->display.mode == NTSC) ||
-				    (dm->display.mode == P525) ||
-				    (dm->display.mode == LCD))
-					format_yres = 480;
-				else
-					/*P625, PAL */
-					format_yres = 576;
-			}
-			break;
-		case PRGB:{
-				if (dm->display.mode == P350)
-					format_yres = 350;
-				else if (dm->display.mode == P400)
-					format_yres = 400;
-				else
-					format_yres = 480;
-			}
-			break;
-		default:
-			break;
-		}
-		if (!flag_osd0)
-			dm->osd0->info.var.yres
-			    = osd0_default_var.yres = format_yres;
-		if (!flag_osd1)
-			dm->osd1->info.var.yres
-			    = osd1_default_var.yres = format_yres;
-		if (!flag_vid0)
-			dm->vid0->info.var.yres
-			    = vid0_default_var.yres = format_yres;
-		if (!flag_vid1)
-			dm->vid1->info.var.yres
-			    = vid1_default_var.yres = format_yres;
-	}
-
-	dev_dbg(dm->dev, "DaVinci: "
-		"Output on %s%s, Enabled windows: %s %s %s %s\n",
-		((dm->display.mode == P480)
-		 && (dm->display.interface ==
-		     PRGB)) ? "480P" : ((dm->display.mode == P400)
-					&& (dm->display.interface ==
-					    PRGB)) ? "400P" : ((dm->display.
-								mode == P350)
-							       && (dm->display.
-								   interface ==
-								   PRGB)) ?
-		"350P" : (dm->display.mode ==
-			  LCD) ? "LCD" : (dm->display.mode ==
-					  NTSC) ? "NTSC" : (dm->display.mode ==
-							    PAL) ? "PAL" : (dm->
-									    display.
-									    mode
-									    ==
-									    P525)
-		? "525P" : (dm->display.mode ==
-			    P625) ? "625P" : "unknown device!",
-		(dm->display.interface ==
-		 SVIDEO) ? " in SVIDEO format" : (dm->display.interface ==
-						  COMPONENT) ?
-		" in COMPONENT format" : (dm->display.interface ==
-					  COMPOSITE) ? " in COMPOSITE format"
-		: (dm->display.interface ==
-		   RGB) ? " in RGB format" : (dm->display.interface == YCC16)
-		? " in YCC16 format" : (dm->display.interface ==
-					YCC8) ? " in YCC8 format" : (dm->
-								     display.
-								     interface
-								     ==
-								     PRGB) ?
-		" in PRGB format" : (dm->display.interface ==
-				     SRGB) ? " in SRGB format" : (dm->display.
-								  interface ==
-								  EPSON) ?
-		" in EPSON format" : (dm->display.interface ==
-				      CASIO1G) ? " in CASIO1G format" : (dm->
-									 display.
-									 interface
-									 ==
-									 UDISP)
-		? " in UDISP format" : (dm->display.interface ==
-					STN) ? " in STN format" : "",
-		(dm->vid0->window_enable) ? "Video0" : "",
-		(dm->vid1->window_enable) ? "Video1" : "",
-		(dm->osd0->window_enable) ? "OSD0" : "",
-		(dm->osd1->window_enable) ? "OSD1" : "");
-
-	if (dm->vid0->window_enable)
-		dev_dbg(dm->dev, "Setting Video0 size %dx%d, "
-			"position (%d,%d)\n",
-			dm->vid0->info.var.xres, dm->vid0->info.var.yres,
-			dm->vid0->win_pos.xpos, dm->vid0->win_pos.ypos);
-	if (dm->vid1->window_enable)
-		dev_dbg(dm->dev, "Setting Video1 size %dx%d, "
-			"position (%d,%d)\n",
-			dm->vid1->info.var.xres, dm->vid1->info.var.yres,
-			dm->vid1->win_pos.xpos, dm->vid1->win_pos.ypos);
-	if (dm->osd0->window_enable)
-		dev_dbg(dm->dev, "Setting OSD0 size %dx%d, "
-			"position (%d,%d)\n",
-			dm->osd0->info.var.xres, dm->osd0->info.var.yres,
-			dm->osd0->win_pos.xpos, dm->osd0->win_pos.ypos);
-	if (dm->osd1->window_enable)
-		dev_dbg(dm->dev, "Setting OSD1 size %dx%d, "
-			"position (%d,%d)\n",
-			dm->osd1->info.var.xres, dm->osd1->info.var.yres,
-			dm->osd1->win_pos.xpos, dm->osd1->win_pos.ypos);
-	return 0;
-}
-
-/*
- * mem_release
- */
-int mem_release(struct vpbe_dm_win_info *w)
-{
-	if (!w->alloc_fb_mem) {
-		iounmap((void *)w->fb_base);
-		release_mem_region(w->fb_base_phys, w->fb_size);
-	} else {
-		vpbe_mem_release_window_buf(w);
-	}
-	if (w)
-		kfree(w);
-	return 0;
-}
-
-void init_display_function(struct vpbe_display_format *d)
-{
-	if (d->mode == NON_EXISTING_MODE)
-		dm->output_device_config = vpbe_davincifb_dlcd_nonstd_config;
-	else if ((d->mode == NTSC) && (d->interface == COMPOSITE))
-		dm->output_device_config = davincifb_ntsc_composite_config;
-	else if ((d->mode == NTSC) && (d->interface == SVIDEO))
-		dm->output_device_config = davincifb_ntsc_svideo_config;
-	else if ((d->mode == NTSC) && (d->interface == COMPONENT))
-		dm->output_device_config = davincifb_ntsc_component_config;
-	else if ((d->mode == PAL) && (d->interface == COMPOSITE))
-		dm->output_device_config = davincifb_pal_composite_config;
-	else if ((d->mode == PAL) && (d->interface == SVIDEO))
-		dm->output_device_config = davincifb_pal_svideo_config;
-	else if ((d->mode == PAL) && (d->interface == COMPONENT))
-		dm->output_device_config = davincifb_pal_component_config;
-	else if ((d->mode == NTSC) && (d->interface == RGB))
-		dm->output_device_config = vpbe_davincifb_ntsc_rgb_config;
-	else if ((d->mode == PAL) && (d->interface == RGB))
-		dm->output_device_config = vpbe_davincifb_pal_rgb_config;
-	else if ((d->mode == P525) && (d->interface == COMPONENT))
-		dm->output_device_config = vpbe_davincifb_525p_component_config;
-	else if ((d->mode == P625) && (d->interface == COMPONENT))
-		dm->output_device_config = vpbe_davincifb_625p_component_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == YCC16))
-		dm->output_device_config = vpbe_davincifb_default_ycc16_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == YCC8))
-		dm->output_device_config = vpbe_davincifb_default_ycc8_config;
-	else if ((d->mode == P480) && (d->interface == PRGB))
-		dm->output_device_config = vpbe_davincifb_480p_prgb_config;
-	else if ((d->mode == P400) && (d->interface == PRGB))
-		dm->output_device_config = vpbe_davincifb_400p_prgb_config;
-	else if ((d->mode == P350) && (d->interface == PRGB))
-		dm->output_device_config = vpbe_davincifb_350p_prgb_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == SRGB))
-		dm->output_device_config = vpbe_davincifb_default_srgb_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == EPSON))
-		dm->output_device_config = vpbe_davincifb_default_epson_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == CASIO1G))
-		dm->output_device_config = vpbe_davincifb_default_casio_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == UDISP))
-		dm->output_device_config = vpbe_davincifb_default_UDISP_config;
-	else if ((d->mode == DEFAULT_MODE) && (d->interface == STN))
-		dm->output_device_config = vpbe_davincifb_default_STN_config;
-	/* Add support for other displays       here */
-	else {
-		dev_err(dm->dev, "Unsupported output	device!\n");
-		dm->output_device_config = NULL;
-	}
-}
-
-/*
- * ========	vpbe_mem_alloc_max	========
- */
-/* The function	allocates max memory required for the 
-				frame buffers of the window. */
-int vpbe_mem_alloc_max(struct vpbe_dm_win_info *w)
-{
-	dev_dbg(dm->dev, "Allocating buffer of size: %x\n", w->fb_size);
-	w->fb_base = (unsigned long)dma_alloc_coherent
-	    (dm->dev, w->fb_size, &w->fb_base_phys, GFP_KERNEL | GFP_DMA);
-
-	if (!w->fb_base) {
-		dev_err(dm->dev, "%s : dma_alloc_coherent fail.\n",
-			__FUNCTION__);
-		return -ENOMEM;
-	}
-	w->info.fix.smem_start = w->fb_base_phys;
-	w->info.fix.smem_len = w->fb_size;
-
-	w->info.screen_base = (char *)(w->fb_base);
-
-	return 0;
-}
-
-/*
- * ========	vpbe_mem_release_window_buf	========
- */
-/* The function	allocates the memory required for the 
-				frame buffers of the window. */
-int vpbe_mem_release_window_buf(struct vpbe_dm_win_info *w)
-{
-	dma_free_coherent(NULL, w->fb_size, (void *)w->fb_base,
-			  w->fb_base_phys);
-	w->info.fix.smem_start = 0;
-	w->info.fix.smem_len = 0;
-	return 0;
-}
-
-/*
- * ========	vpbe_mem_alloc_struct	========
- */
-/* The function	allocate the memory required for the 
-				frame buffers of the window. */
-int vpbe_mem_alloc_struct(struct vpbe_dm_win_info **w)
-{
-	*w = kmalloc(sizeof(struct vpbe_dm_win_info), GFP_KERNEL);
-	if (!*w) {
-		return -ENOMEM;
-	}
-	memset(*w, 0, sizeof(struct vpbe_dm_win_info));
-
-	return 0;
-}
-
-/*
- * ========	set_vid0_default_conf	========
- */
-/* The function	set defaults of VID0 window. */
-void set_vid0_default_conf()
-{
-	vpbe_video_params_t *vid_par = &dm->vid0->conf_params.video_params;
-	vpbe_video_config_params_t vid_conf_params;
-
-	vid_par->cb_cr_order = SET_0;	/* default order CB-CR */
-	vid_par->exp_info.horizontal = VPBE_DISABLE;	/* Expansion disable */
-
-	dm->vid0->alloc_fb_mem = 1;
-	dm->vid0->window_enable = VPBE_ENABLE;
-	dm->vid0->zoom.window_id = VID0;
-	dm->vid0->zoom.zoom_h = 0;	/* No Zoom */
-	dm->vid0->field_frame_select = FB_VMODE_INTERLACED;
-	dm->vid0->numbufs = TRIPLE_BUF;
-
-	/* Set the defaults vid params in registers */
-	vid_conf_params.cb_cr_order = vid_par->cb_cr_order;
-	vid_conf_params.exp_info = vid_par->exp_info;
-	vpbe_set_vid_params(dm->vid0->info.fix.id, &vid_conf_params);
-
-	/* Set default zoom in register */
-	set_zoom(dm->vid0->zoom.window_id, dm->vid0->zoom.zoom_h,
-		 dm->vid0->zoom.zoom_v);
-
-	/* Set default buffer size */
-	dm->vid0->fb_size = TRIPLE_BUF * DISP_MEMY * VID0_LINELENGTH;
-}
-
-/*
- * ========	set_vid1_default_conf	========
- */
-/* The function	set defaults of VID1 window. */
-void set_vid1_default_conf()
-{
-	vpbe_video_params_t *vid_par = &dm->vid1->conf_params.video_params;
-	vpbe_video_config_params_t vid_conf_params;
-
-	vid_par->cb_cr_order = SET_0;	/* default order CB-CR */
-	vid_par->exp_info.horizontal = VPBE_DISABLE;	/* Expansion disable */
-	vid_par->exp_info.vertical = VPBE_DISABLE;
-
-	dm->vid1->alloc_fb_mem = 1;
-	dm->vid1->window_enable = VPBE_ENABLE;
-	dm->vid1->zoom.window_id = VID1;
-	dm->vid1->zoom.zoom_h = 0;	/* No Zoom */
-	dm->vid1->zoom.zoom_v = 0;
-	dm->vid1->field_frame_select = FB_VMODE_INTERLACED;
-	dm->vid1->numbufs = TRIPLE_BUF;
-
-	/* Set the defaults vid params in registers */
-	vid_conf_params.cb_cr_order = vid_par->cb_cr_order;
-	vid_conf_params.exp_info = vid_par->exp_info;
-	vpbe_set_vid_params(dm->vid1->info.fix.id, &vid_conf_params);
-
-	/* Set default zoom in register */
-	set_zoom(dm->vid1->zoom.window_id, dm->vid1->zoom.zoom_h,
-		 dm->vid1->zoom.zoom_v);
-
-	/* Set default buffer size */
-	dm->vid1->fb_size = TRIPLE_BUF * DISP_MEMY * VID1_LINELENGTH;
-}
-
-/*
- * ========	set_osd0_default_conf	========
- */
-/* The function	set defaults of OSD0 window. */
-void set_osd0_default_conf()
-{
-	vpbe_bitmap_params_t *bit_par = &dm->osd0->conf_params.bitmap_params;
-	vpbe_bitmap_config_params_t bitmap_config_params;
-
-	bit_par->attenuation_enable = SET_0;	/* Attenuation Disabled */
-	bit_par->clut_select = SET_0;	/* ROM_CLUT */
-	bit_par->enable_attribute = SET_0;
-	bit_par->blend_info.bf = 0x07;
-	bit_par->blink_info.blinking = VPBE_DISABLE;
-	bit_par->blink_info.interval = 0;
-
-	dm->osd0->alloc_fb_mem = 1;
-	dm->osd0->window_enable = VPBE_ENABLE;
-	dm->osd0->zoom.window_id = OSD0;
-	dm->osd0->zoom.zoom_h = 0;	/* No Zoom */
-	dm->osd0->zoom.zoom_v = 0;
-	dm->osd0->field_frame_select = FB_VMODE_INTERLACED;
-	dm->osd0->numbufs = DOUBLE_BUF;
-
-	bitmap_config_params.attenuation_enable = bit_par->attenuation_enable;
-	bitmap_config_params.clut_select = bit_par->clut_select;
-
-	/* Set default bitmap params in registers */
-	vpbe_bitmap_set_params(dm->osd0->info.fix.id, &bitmap_config_params);
-	/* Set default zoom in register */
-	set_zoom(dm->osd0->zoom.window_id, dm->osd0->zoom.zoom_h,
-		 dm->osd0->zoom.zoom_v);
-	/* Set default buffer size */
-	dm->osd0->fb_size = DOUBLE_BUF * DISP_MEMY * OSD0_LINELENGTH;
-}
-
-/*
- * ========	set_osd1_default_conf	========
- */
-/* The function	set defaults of OSD1 window. */
-void set_osd1_default_conf()
-{
-	vpbe_bitmap_params_t *bit_par = &dm->osd1->conf_params.bitmap_params;
-	vpbe_bitmap_config_params_t bitmap_config_params;
-
-	bit_par->attenuation_enable = SET_0;	/* Attenuation Disabled */
-	bit_par->clut_select = 2;	/* RAM CLUT */
-	bit_par->enable_attribute = SET_1;
-	bit_par->blend_info.bf = 0x07;
-	bit_par->blink_info.blinking = VPBE_DISABLE;
-	bit_par->blink_info.interval = 0;
-
-	dm->osd1->alloc_fb_mem = 1;
-	dm->osd1->window_enable = VPBE_ENABLE;
-	dm->osd1->zoom.window_id = OSD1;
-	dm->osd1->zoom.zoom_h = 0;
-	dm->osd1->zoom.zoom_v = 0;
-	dm->osd1->field_frame_select = FB_VMODE_INTERLACED;
-	dm->osd1->numbufs = DOUBLE_BUF;
-	dm->osd1->conf_params.bitmap_params.stored_bits_per_pixel = SET_0;
-
-	bitmap_config_params.attenuation_enable = bit_par->attenuation_enable;
-	bitmap_config_params.clut_select = bit_par->clut_select;
-
-	/* Set default bitmap params in registers */
-	vpbe_bitmap_set_params(dm->osd1->info.fix.id, &bitmap_config_params);
-	/* Set default zoom in register */
-	set_zoom(dm->osd1->zoom.window_id, dm->osd1->zoom.zoom_h,
-		 dm->osd1->zoom.zoom_v);
-	/* Set default buffer size */
-	dm->osd1->fb_size = DOUBLE_BUF * DISP_MEMY * OSD1_LINELENGTH;
-}
-
-/*
- * ========	set_cursor_default_conf	========
- */
-/* The function	set defaults of cursor window. */
-void set_cursor_default_conf()
-{
-	dm->cursor.enable = VPBE_DISABLE;
-	dm->cursor.image.dx = 10;
-	dm->cursor.image.dy = 10;
-	dm->cursor.image.width = 10;
-	dm->cursor.image.height = 10;
-	dm->cursor.image.fg_color = 10;
-	dm->cursor.image.depth = 10;
-
-	/* Set default cursor params in registers. */
-	vpbe_set_cursor_params(&dm->cursor);
-}
-
-/*
- * ========	set_dm_default_conf	========
- */
-/* The function	set defaults of dm structure. */
-void set_dm_default_conf()
-{
-	dm->backg.clut_select = SET_0;
-	dm->backg.color_offset = 0x80;
-
-	dm->dclk.dclk_pattern_width = 0;
-	dm->dclk.dclk_pattern0 = 0;
-	dm->dclk.dclk_pattern1 = 0;
-	dm->dclk.dclk_pattern2 = 0;
-	dm->dclk.dclk_pattern3 = 0;
-
-	dm->display.mode = NTSC;
-	dm->display.interface = COMPOSITE;
-
-	/* Configure defaults in registers */
-
-	/* Initialize the VPSS Clock Control register */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* Reset OSD registers to default. */
-	dispc_reg_out(OSD_MODE, 0);
-	dispc_reg_out(OSD_OSDWIN0MD, 0);
-
-	/* Set blue background color */
-	vpbe_set_backg_color(&dm->backg);
-
-	/* Field Inversion Workaround  */
-	dispc_reg_out(OSD_MODE, 0x200);
-}
-
-/*
- *  Cleanup
- */
-int davincifb_remove(struct device *dev)
-{
-	free_irq(IRQ_VENCINT, &dm);
-
-	/* Cleanup all framebuffers */
-	if (dm->osd0) {
-		unregister_framebuffer(&dm->osd0->info);
-		mem_release(dm->osd0);
-	}
-	if (dm->osd1) {
-		unregister_framebuffer(&dm->osd1->info);
-		mem_release(dm->osd1);
-	}
-	if (dm->vid0) {
-		unregister_framebuffer(&dm->vid0->info);
-		mem_release(dm->vid0);
-	}
-	if (dm->vid1) {
-		unregister_framebuffer(&dm->vid1->info);
-		mem_release(dm->vid1);
-	}
-
-	/* Turn OFF the output device */
-	dm->output_device_config();
-	vpbe_enable_venc(0);
-	if (dm->display.interface == PRGB)
-		vpbe_enable_lcd(0);
-	else if (dm->display.interface == SVIDEO ||
-		 dm->display.interface == COMPONENT ||
-		 dm->display.interface == COMPOSITE)
-		vpbe_enable_dacs(0);
-
-	if (dm->mmio_base)
-		iounmap((void *)dm->mmio_base);
-	release_mem_region(dm->mmio_base_phys, dm->mmio_size);
-
-	return 0;
-}
-
-/*
- * ========	vpbe_davincifb_probe ========
- */
-int vpbe_davincifb_probe(struct device *dev)
-{
-	struct platform_device *pdev;
-
-	pdev = to_platform_device(dev);
-	if (pdev->num_resources != 0) {
-		dev_err(dev, "probed for an	unknown	device\n");
-		return -ENODEV;
-	}
-
-	dm->dev = dev;
-	dm->mmio_base_phys = OSD_REG_BASE;
-	dm->mmio_size = OSD_REG_SIZE;
-
-	/* request the mem regions */
-	if (!request_mem_region
-	    (dm->mmio_base_phys, dm->mmio_size, DAVINCIFB_DRIVER)) {
-		dev_err(dev, ":	cannot reserve MMIO	region\n");
-		return -ENODEV;
-	}
-
-	/* map the regions */
-	dm->mmio_base =
-	    (unsigned long)ioremap(dm->mmio_base_phys, dm->mmio_size);
-	if (!dm->mmio_base) {
-		dev_err(dev, ":	cannot map MMIO\n");
-		goto release_mmio;
-	}
-
-	/* Do default settings for all the windows      */
-	davincifb_setup(options);
-
-	/* Set fb_videomode structure */
-	dm->videomode = modelist[dm->display.interface][dm->display.mode];
-
-	/* choose config function */
-	init_display_function(&dm->display);
-
-	/* initialize   the     vsync   wait queue */
-	init_waitqueue_head(&dm->vsync_wait);
-	dm->timeout = HZ / 5;
-
-/*
- *	WINDOW SETUP:	
- *		Perform following for all the windows
- *	a)	If window is to be enabled, allocate buffers.
- *	b)	Register fb device.
- *	c)	Call davincifb_set_par to configure all OSD registers
- *	d)	Set appropriate register to enable the window, 
- *		if command line option is given to enable the window.    
- *	e)	Initialize video output by executing configuration function.
- */
-
-	/*
-	 * OSD0 Setup
-	 */
-	/* Allocate buffers */
-	if (dm->osd0->window_enable) {
-		if (vpbe_mem_alloc_max(dm->osd0) < 0)
-			goto vpbe_probe_exit;
-		dm->osd0->info.screen_base = (char *)(dm->osd0->fb_base);
-		/* memset buffer with some value for background color */
-		memset((void *)dm->osd0->fb_base, 0x00, dm->osd0->fb_size);
-	}
-	/* Register FB device */
-	if (register_framebuffer(&dm->osd0->info) < 0) {
-		dev_err(dev,
-			OSD0_FBNAME
-			"Unable	to register	OSD0 framebuffer\n");
-		mem_release(dm->osd0);
-		goto vpbe_probe_exit;
-	}
-	/* Configure registers */
-	davincifb_set_par(&dm->osd0->info);
-	/* Enable the window */
-	set_win_enable(dm->osd0->info.fix.id, dm->osd0->window_enable);
-
-	/*
-	 * VID0 Setup
-	 */
-	/* Allocate buffers */
-	if (dm->vid0->window_enable) {
-		if (vpbe_mem_alloc_max(dm->vid0) < 0)
-			goto vpbe_probe_exit;
-
-		dm->vid0->info.screen_base = (char *)(dm->vid0->fb_base);
-
-		memset((void *)dm->vid0->fb_base, 0x80, dm->vid0->fb_size);
-	}
-	if (register_framebuffer(&dm->vid0->info) < 0) {
-		dev_err(dev,
-			VID0_FBNAME
-			"Unable	to register	VID0 framebuffer\n");
-		mem_release(dm->vid0);
-		goto vpbe_probe_exit;
-	}
-	davincifb_set_par(&dm->vid0->info);
-	set_win_enable(dm->vid0->info.fix.id, dm->vid0->window_enable);
-
-	/*
-	 * OSD1 Setup
-	 */
-	if (dm->osd1->window_enable) {
-		if (vpbe_mem_alloc_max(dm->osd1) < 0)
-			goto vpbe_probe_exit;
-		dm->osd1->info.screen_base = (char *)(dm->osd1->fb_base);
-		memset((void *)dm->osd1->fb_base, 0x77, dm->osd1->fb_size);
-	}
-	if (register_framebuffer(&dm->osd1->info) < 0) {
-		dev_err(dev,
-			OSD1_FBNAME
-			"Unable	to register	OSD1 framebuffer\n");
-		mem_release(dm->osd1);
-		goto vpbe_probe_exit;
-	}
-	davincifb_set_par(&dm->osd1->info);
-	set_win_enable(dm->osd1->info.fix.id, dm->osd1->window_enable);
-
-	/*
-	 * VID1 Setup
-	 */
-	if (dm->vid1->window_enable) {
-		if (vpbe_mem_alloc_max(dm->vid1) < 0)
-			goto vpbe_probe_exit;
-		dm->vid1->info.screen_base = (char *)(dm->vid1->fb_base);
-		memset((void *)dm->vid1->fb_base, 0x80, dm->vid1->fb_size);
-	}
-	if (register_framebuffer(&dm->vid1->info) < 0) {
-		dev_err(dev,
-			VID1_FBNAME
-			"Unable	to register	VID1 framebuffer\n");
-		mem_release(dm->vid1);
-		goto vpbe_probe_exit;
-	}
-	davincifb_set_par(&dm->vid1->info);
-	set_win_enable(dm->vid1->info.fix.id, dm->vid1->window_enable);
-
-	dm->output_device_config();
-	vpbe_enable_venc(1);
-	if (dm->display.interface == PRGB)
-		vpbe_enable_lcd(1);
-	else if (dm->display.interface == SVIDEO ||
-		 dm->display.interface == COMPONENT ||
-		 dm->display.interface == COMPOSITE)
-		vpbe_enable_dacs(1);
-
-	if (request_irq
-	    (IRQ_VENCINT, davincifb_isr, SA_SHIRQ, DAVINCIFB_DRIVER, dm)) {
-		dev_err(dev,
-			DAVINCIFB_DRIVER
-			": could not install interrupt service routine\n");
-		goto vpbe_probe_exit;
-	}
-
-	if (!dm->osd0->window_enable) {
-		memset(&dm->osd0->info.var, 0x00, sizeof(dm->osd0->info.var));
-		dm->osd0->info.fix.line_length = 0;
-	}
-	if (!dm->vid0->window_enable) {
-		memset(&dm->vid0->info.var, 0x00, sizeof(dm->vid0->info.var));
-		dm->vid0->info.fix.line_length = 0;
-	}
-	if (!dm->osd1->window_enable) {
-		memset(&dm->osd1->info.var, 0x00, sizeof(dm->osd1->info.var));
-		dm->osd1->info.fix.line_length = 0;
-	}
-	if (!dm->vid1->window_enable) {
-		memset(&dm->vid1->info.var, 0x00, sizeof(dm->vid1->info.var));
-		dm->vid1->info.fix.line_length = 0;
-	}
-
-	return 0;
-
-      vpbe_probe_exit:
-	davincifb_remove(dev);
-	return -ENODEV;
-
-      release_mmio:
-	release_mem_region(dm->mmio_base_phys, dm->mmio_size);
-	return -ENODEV;
-}
-int no_soft_cursor(struct fb_info *info, struct fb_cursor *cursor)
-{
-	return 0;
-}
-
-/*
- *  Frame buffer operations
- */
-static struct fb_ops davincifb_ops = {
-	.owner = THIS_MODULE,
-	.fb_check_var = davincifb_check_var,
-	.fb_set_par = davincifb_set_par,
-	.fb_setcolreg = davincifb_setcolreg,
-	.fb_blank = davincifb_blank,
-	.fb_pan_display = davincifb_pan_display,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	/* .fb_cursor = soft_cursor, */
-	.fb_cursor = no_soft_cursor,
-	.fb_rotate = NULL,
-	.fb_sync = NULL,
-	.fb_ioctl = davincifb_ioctl,
-};
-
-static void davincifb_release_dev(struct device *dev)
-{
-}
-
-static u64 davincifb_dmamask = ~(u32) 0;
-
-static struct platform_device davincifb_device = {
-	.name = DAVINCIFB_DEVICE,
-	.id = 0,
-	.dev = {
-		.release = davincifb_release_dev,
-		.dma_mask = &davincifb_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-		},
-	.num_resources = 0,
-};
-
-static struct device_driver davincifb_driver = {
-	.name = DAVINCIFB_DRIVER,
-	.bus = &platform_bus_type,
-	.probe = vpbe_davincifb_probe,
-	.remove = davincifb_remove,
-	.suspend = NULL,
-	.resume = NULL,
-};
-
-/*	Register both	the	driver and the device	*/
-static int __init davincifb_init(void)
-{
-	int r = 0;
-	struct device *dev = &davincifb_device.dev;
-
-	/* Allocate memory for struc 'vpbe_dm_win_info' for all the windows */
-	if (vpbe_mem_alloc_struct(&dm->vid0) < 0) {
-		r = -1;
-		goto vpbe_init_exit;
-	}
-	if (vpbe_mem_alloc_struct(&dm->vid1) < 0) {
-		r = -1;
-		goto vpbe_init_exit;
-	}
-	if (vpbe_mem_alloc_struct(&dm->osd0) < 0) {
-		r = -1;
-		goto vpbe_init_exit;
-	}
-	if (vpbe_mem_alloc_struct(&dm->osd1) < 0) {
-		r = -1;
-		goto vpbe_init_exit;
-	}
-	dm->vid0->dm = dm;
-	dm->vid1->dm = dm;
-	dm->osd0->dm = dm;
-	dm->osd1->dm = dm;
-
-#ifndef MODULE
-	{
-		/* handle options for "dm64xxfb" for backwards compatability */
-		char *names[] = { "davincifb", "dm64xxfb" };
-		int i, num_names = 2, done = 0;
-
-		for (i = 0; i < num_names && !done; i++) {
-			if (fb_get_options(names[i], &options)) {
-				dev_err(dev, " Disabled on command-line.\n");
-				r = -ENODEV;
-				goto vpbe_init_exit;
-			}
-		}
-	}
-#endif
-
-	/* Register the device with LDM */
-	if (platform_device_register(&davincifb_device)) {
-		dev_err(dev, "failed to	register davincifb device\n");
-		r = -ENODEV;
-		goto vpbe_init_exit;
-	}
-	/* Register the driver with LDM */
-	if (driver_register(&davincifb_driver)) {
-		dev_err(dev, "failed to	register davincifb driver\n");
-		platform_device_unregister(&davincifb_device);
-		r = -ENODEV;
-		goto vpbe_init_exit;
-	}
-	return 0;
-      vpbe_init_exit:
-	if (dm->vid0)
-		kfree(dm->vid0);
-	if (dm->vid1)
-		kfree(dm->vid1);
-	if (dm->osd0)
-		kfree(dm->osd0);
-	if (dm->osd1)
-		kfree(dm->osd1);
-	return r;
-}
-
-static void __exit davincifb_cleanup(void)
-{
-	driver_unregister(&davincifb_driver);
-	platform_device_unregister(&davincifb_device);
-}
-
-module_init(davincifb_init);
-module_exit(davincifb_cleanup);
-
-MODULE_DESCRIPTION("Framebuffer driver for TI DaVinci");
-MODULE_AUTHOR("Texas Instruments");
-MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/video/davincifb_dlcd.c
===================================================================
--- linux-2.6.10.orig/drivers/video/davincifb_dlcd.c
+++ /dev/null
@@ -1,317 +0,0 @@
-/* 
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option)any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davincifb_dlcd.c	
- */
-#include <video/davinci_vpbe.h>
-#include <video/davincifb.h>
-extern vpbe_dm_info_t *dm;
-
-void vpbe_enable_lcd(int on)
-{
-	if (on) {
-		/* Enable LCD out */
-                dispc_reg_out(VENC_LCDOUT, 0x1);
-	} else {
-		/* Disable LCD out */
-                dispc_reg_out(VENC_LCDOUT, 0x0);
-	}
-	
-}
-
-/*
- * vpbe_davincifb_480p_prgb_config 
- */
-void vpbe_davincifb_480p_prgb_config(void)
-{
-	volatile unsigned int venc, lcdout;
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	lcdout = dispc_reg_in(VENC_LCDOUT);
-	vpbe_set_display_default();
-	/* Clear component and composite mode registers 
-	   (applicable to Analog DACS) */
-	dispc_reg_out(VENC_CVBS, 0);
-	dispc_reg_out(VENC_CMPNT, 0);
-	/* Set PINMUX0 - RGB666 Enable */
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_RGB666_SHIFT,
-			PINMUX0_RGB666);
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_LOEEN_SHIFT,
-			PINMUX0_LOEEN);
-	/* dispc_reg_out(PINMUX1, 0x0); */
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-	/* Set VIDCTL to select VCLKE = 1, 
-	   VCLKZ =1, SYDIR = 0 (set o/p), DOMD = 0 */
-	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
-			VENC_VIDCTL_VCLKE);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
-			VENC_VIDCTL_VCLKZ);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
-			VENC_VIDCTL_SYDIR);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
-			VENC_VIDCTL_YCDIR);
-
-	dispc_reg_merge(VENC_DCLKCTL,
-			1 << VENC_DCLKCTL_DCKEC_SHIFT,
-			VENC_DCLKCTL_DCKEC);
-
-	dispc_reg_out(VENC_DCLKPTN0, 0x1);
-
-	vpbe_set_display_timing(&dm->videomode);
-	dispc_reg_out(VENC_SYNCCTL,
-		      (VENC_SYNCCTL_SYEV |
-		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
-		       | VENC_SYNCCTL_VPL));
-	/* Set OSD clock and OSD Sync Adavance registers */
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-	/* set VPSS clock */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x2010 | venc);
-	dispc_reg_out(VENC_LCDOUT, lcdout);
-
-	/* Change window parameters for progressive display */
-	change_win_param(FB_VMODE_NONINTERLACED);
-}
-
-/*
- * vpbe_davincifb_400p_prgb_config 
- */
-void vpbe_davincifb_400p_prgb_config(void)
-{
-	volatile unsigned int venc, lcdout;
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	lcdout = dispc_reg_in(VENC_LCDOUT);
-	vpbe_set_display_default();
-	/* Clear component and composite mode registers 
-	   (applicable to Analog DACS) */
-	dispc_reg_out(VENC_CVBS, 0);
-	dispc_reg_out(VENC_CMPNT, 0);
-	/* Set PINMUX0 - RGB666 Enable */
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_RGB666_SHIFT,
-			PINMUX0_RGB666);
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_LOEEN_SHIFT,
-			PINMUX0_LOEEN);
-	/* dispc_reg_out(PINMUX1, 0x0); */
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-	/* Set VIDCTL to select VCLKE = 1, VCLKZ =1, 
-	   SYDIR = 0 (set o/p), DOMD = 0 */
-	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
-			VENC_VIDCTL_VCLKE);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
-			VENC_VIDCTL_VCLKZ);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
-			VENC_VIDCTL_SYDIR);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
-			VENC_VIDCTL_YCDIR);
-
-	dispc_reg_merge(VENC_DCLKCTL,
-			1 << VENC_DCLKCTL_DCKEC_SHIFT,
-			VENC_DCLKCTL_DCKEC);
-
-	dispc_reg_out(VENC_DCLKPTN0, 0x1);
-
-	vpbe_set_display_timing(&dm->videomode);
-	dispc_reg_out(VENC_SYNCCTL,
-		      (VENC_SYNCCTL_SYEV |
-		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL));
-	/* Set OSD clock and OSD Sync Adavance registers */
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-	/* set VPSS clock */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x2010 | venc);
-	dispc_reg_out(VENC_LCDOUT, lcdout);
-
-	/* Change window parameters for progressive display */
-	change_win_param(FB_VMODE_NONINTERLACED);
-}
-
-/*
- * vpbe_davincifb_350p_prgb_config 
- */
-void vpbe_davincifb_350p_prgb_config(void)
-{
-	volatile unsigned int venc, lcdout;
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	lcdout = dispc_reg_in(VENC_LCDOUT);
-	vpbe_set_display_default();
-	/* Clear component and composite mode registers 
-	   (applicable to Analog DACS) */
-	dispc_reg_out(VENC_CVBS, 0);
-	dispc_reg_out(VENC_CMPNT, 0);
-	/* Set PINMUX0 - RGB666 Enable */
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_RGB666_SHIFT,
-			PINMUX0_RGB666);
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_LOEEN_SHIFT,
-			PINMUX0_LOEEN);
-	/* dispc_reg_out(PINMUX1, 0x0); */
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-	/* Set VIDCTL to select VCLKE = 1, VCLKZ =1, 
-	   SYDIR = 0 (set o/p), DOMD = 0 */
-	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
-			VENC_VIDCTL_VCLKE);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
-			VENC_VIDCTL_VCLKZ);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
-			VENC_VIDCTL_SYDIR);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
-			VENC_VIDCTL_YCDIR);
-
-	dispc_reg_merge(VENC_DCLKCTL,
-			1 << VENC_DCLKCTL_DCKEC_SHIFT,
-			VENC_DCLKCTL_DCKEC);
-
-	dispc_reg_out(VENC_DCLKPTN0, 0x1);
-
-	vpbe_set_display_timing(&dm->videomode);
-	dispc_reg_out(VENC_SYNCCTL,
-		      (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
-	/* Set OSD clock and OSD Sync Adavance registers */
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-	/* set VPSS clock */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x2010 | venc);
-	dispc_reg_out(VENC_LCDOUT, lcdout);
-
-	/* Change window parameters for progressive display */
-	change_win_param(FB_VMODE_NONINTERLACED);
-}
-
-/*
- * vpbe_set_display_timing 
- */
-/* This function sets the display timing from the fb_info structure*/
-void vpbe_set_display_timing(struct vpbe_fb_videomode *videomode)
-{
-	dispc_reg_out(VENC_HSPLS, videomode->hsync_len);
-	dispc_reg_out(VENC_HSTART, videomode->left_margin);
-	dispc_reg_out(VENC_HVALID, (videomode->xres));
-	dispc_reg_out(VENC_HINT,
-		      videomode->xres + videomode->left_margin +
-		      videomode->right_margin - 1);
-
-	dispc_reg_out(VENC_VSPLS, videomode->vsync_len);
-	dispc_reg_out(VENC_VSTART, videomode->upper_margin);
-	dispc_reg_out(VENC_VVALID, (videomode->yres));
-	dispc_reg_out(VENC_VINT,
-		      videomode->yres + videomode->upper_margin +
-		      videomode->lower_margin);
-
-	dispc_reg_out(VENC_VVALID, (videomode->yres));
-};
-
-void vpbe_davincifb_default_ycc16_config(void)
-{
-}
-
-void vpbe_davincifb_default_ycc8_config(void)
-{
-}
-
-void vpbe_davincifb_default_srgb_config(void)
-{
-}
-
-void vpbe_davincifb_default_epson_config(void)
-{
-}
-
-void vpbe_davincifb_default_casio_config(void)
-{
-}
-
-void vpbe_davincifb_default_UDISP_config(void)
-{
-}
-
-void vpbe_davincifb_default_STN_config(void)
-{
-}
-
-/*
- * vpbe_davincifb_dlcd_nonstd_config 
- */
-/* This function configures the digital lcd controller to 
- *	PRGB666 output setting.
- * Implementation is not tested 
- */
-void vpbe_davincifb_dlcd_nonstd_config(void)
-{
-	volatile unsigned int venc, lcdout;
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	lcdout = dispc_reg_in(VENC_LCDOUT);
-	vpbe_set_display_default();
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_RGB666_SHIFT,
-			PINMUX0_RGB666);
-	dispc_reg_merge(PINMUX0, 1 << PINMUX0_LOEEN_SHIFT,
-			PINMUX0_LOEEN);
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-	/* Set VIDCTL to select VCLKE = 1, VCLKZ =1, 
-	   SYDIR = 0 (set o/p), DOMD = 0 */
-	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
-			VENC_VIDCTL_VCLKE);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
-			VENC_VIDCTL_VCLKZ);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
-			VENC_VIDCTL_SYDIR);
-	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
-			VENC_VIDCTL_YCDIR);
-
-	dispc_reg_merge(VENC_DCLKCTL,
-			1 << VENC_DCLKCTL_DCKEC_SHIFT,
-			VENC_DCLKCTL_DCKEC);
-	dispc_reg_out(VENC_DCLKPTN0, 0x1);
-
-	vpbe_set_display_timing(&dm->videomode);
-	/* turning on horizontal and vertical syncs */
-	if (dm->videomode.yres == 350) {
-		dispc_reg_out(VENC_SYNCCTL,
-			      (VENC_SYNCCTL_SYEV |
-			       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_VPL));
-	} else if (dm->videomode.yres == 400) {
-		dispc_reg_out(VENC_SYNCCTL,
-			      (VENC_SYNCCTL_SYEV |
-			       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL));
-	} else {	/*dm->videomode.yres ==480 */
-
-		dispc_reg_out(VENC_SYNCCTL,
-			      (VENC_SYNCCTL_SYEV |
-			       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
-			       | VENC_SYNCCTL_VPL));
-	}
-	/* Set OSD clock and OSD Sync Adavance registers */
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-	/* set VPSS clock */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x2010 | venc);
-	dispc_reg_out(VENC_LCDOUT, lcdout);
-}
Index: linux-2.6.10/drivers/video/davincifb_osd.c
===================================================================
--- linux-2.6.10.orig/drivers/video/davincifb_osd.c
+++ /dev/null
@@ -1,842 +0,0 @@
-/* 
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option)any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davincifb_osd.c	
- */
-
-#include <video/davinci_vpbe.h>
-#include <video/davincifb.h>
-
-extern vpbe_dm_info_t *dm;
-extern struct vpbe_fb_videomode *modelist[];
-
-/*
- * vpbe_enable_window 
- */
-/* Enables the window */
-int vpbe_enable_window(vpbe_dm_win_info_t * win)
-{
-	int result = 0;
-
-	set_win_enable(win->info.fix.id, VPBE_ENABLE);
-
-	win->window_enable = VPBE_ENABLE;
-	return result;
-}
-
-/*
- * vpbe_disable_window	
- */
-/* The Function	disables the window */
-int vpbe_disable_window(vpbe_dm_win_info_t * win)
-{
-	int result = 0;
-
-	set_win_enable(win->info.fix.id, VPBE_DISABLE);
-	win->window_enable = VPBE_DISABLE;
-	return result;
-}
-
-/*
- * vpbe_bitmap_set_blend_factor 
- */
-/* This	is used	for setting the	blend factor for the bitmap window.*/
-int
-vpbe_bitmap_set_blend_factor(u8 * id, vpbe_bitmap_blend_params_t * blend_para)
-{
-	int result = 0;
-
-	/* If function call is not for OSD window, return error */
-	if (!is_win(id, OSD0) && !is_win(id, OSD1))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	/* Error checkingfor parameter passed */
-	if ((blend_para->enable_colorkeying > VPBE_ENABLE)
-	    || (blend_para->bf > 7) || (blend_para->colorkey > 0xFFFF))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	if (is_win(id, OSD0)) {
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				(blend_para->
-				 enable_colorkeying) <<
-				OSD_OSDWIN0MD_TE0_SHIFT, OSD_OSDWIN0MD_TE0);
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				(blend_para->
-				 bf) << OSD_OSDWIN0MD_BLND0_SHIFT,
-				OSD_OSDWIN0MD_BLND0);
-		dm->osd0->conf_params.bitmap_params.blend_info = *blend_para;
-	} else {
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				(blend_para->
-				 enable_colorkeying) <<
-				OSD_OSDWIN1MD_TE1_SHIFT, OSD_OSDWIN1MD_TE1);
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				(blend_para->
-				 bf) << OSD_OSDWIN1MD_BLND1_SHIFT,
-				OSD_OSDWIN1MD_BLND1);
-		dm->osd1->conf_params.bitmap_params.blend_info = *blend_para;
-	}
-	dispc_reg_merge(OSD_TRANSPVA,
-			(blend_para->
-			 colorkey) << OSD_TRANSPVA_RGBTRANS_SHIFT,
-			OSD_TRANSPVA_RGBTRANS);
-
-	return result;
-}
-
-/*
- * vpbe_bitmap_set_ram_clut 
- */
-/* This	function allows	user to	setup the color lookup table (CLUT)in RAM.*/
-int vpbe_bitmap_set_ram_clut()
-{
-	int result = 0;
-	int i;
-
-	for (i = 0; i < 256; i++) {
-		/* Wait for the MISCCTL.CPBSY bit to be zero */
-		while ((dispc_reg_in(OSD_MISCCT) & OSD_MISCCT_CPBSY)) ;
-		/* Set CLUTRAMCR.CADDR to current loop count */
-		dispc_reg_merge(OSD_CLUTRAMC, i, OSD_CLUTRAM_CADDR);
-		/* Write Cr value in CLUTRAMCR.CR field */
-		dispc_reg_merge(OSD_CLUTRAMC,
-				(dm->
-				 ram_clut[i][2]) << OSD_CLUTRAM_CR_SHIFT,
-				OSD_CLUTRAM_CR);
-
-		/* Write Y value in CLUTRAMYCB.Y field */
-		dispc_reg_merge(OSD_CLUTRAMYC,
-				(dm->
-				 ram_clut[i][0]) << OSD_CLUTRAMY_Y_SHIFT,
-				OSD_CLUTRAMY_Y);
-		/* Write Cb value in CLUTRAMYCB.CB field */
-		dispc_reg_merge(OSD_CLUTRAMYC,
-				(dm->
-				 ram_clut[i][1]) << OSD_CLUTRAMY_CB_SHIFT,
-				OSD_CLUTRAMY_CB);
-	}
-	return result;
-}
-
-/*
- * vpbe_bitmap_set_as_attribute 
- */
-/* Configure OSD1 as bitmap window. */
-int vpbe_enable_disable_attribute_window(u32 flag)
-{
-	int result = 0;
-	if ((flag != 0) && (flag != 1)){
-		return -VPBE_INVALID_PARA_VALUE;
-	}
-/* 'flag' must be more then 8 bit because we are going to shift it by 16 */
-	if (flag) {
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				VPBE_ENABLE << OSD_OSDWIN1MD_OASW_SHIFT,
-				OSD_OSDWIN1MD_OASW);
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				2 << OSD_OSDWIN1MD_BMW1_SHIFT,
-				OSD_OSDWIN1MD_BMW1);
-		dm->osd1->conf_params.bitmap_params.enable_attribute =
-		    VPBE_ENABLE;
-		dm->osd1->conf_params.bitmap_params.stored_bits_per_pixel =
-		    dm->osd1->info.var.bits_per_pixel;
-		dm->osd1->info.var.bits_per_pixel = VPBE_BITMAP_BIT_4;
-	} else {
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				VPBE_DISABLE << OSD_OSDWIN1MD_OASW_SHIFT,
-				OSD_OSDWIN1MD_OASW);
-		dm->osd1->conf_params.bitmap_params.enable_attribute =
-		    VPBE_DISABLE;
-		if (dm->osd1->conf_params.bitmap_params.stored_bits_per_pixel) {
-
-			if (dm->osd1->info.var.bits_per_pixel == 8) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						3 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 4) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						2 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 2) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						1 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			} else if (dm->osd1->info.var.bits_per_pixel == 1) {
-				dispc_reg_merge(OSD_OSDWIN1MD,
-						0 <<
-						OSD_OSDWIN1MD_BMW1_SHIFT,
-						OSD_OSDWIN1MD_BMW1);
-			}
-
-			dm->osd1->info.var.bits_per_pixel =
-			    dm->osd1->conf_params.bitmap_params.
-			    stored_bits_per_pixel;
-		}
-	}
-	return result;
-}
-
-/*
- *  vpbe_set_blinking 
- */
-/* Set the OSD window 0 blinking and  blink interval. */
-int vpbe_set_blinking(u8 * id, vpbe_blink_option_t * required)
-{
-	int result = 0;
-
-	if (!is_win(id, OSD1)) {
-		return -VPBE_WRONG_WINDOW_ID;
-	}
-	if ((required->blinking > VPBE_ENABLE) || (required->interval > 3))
-		return -VPBE_INVALID_PARA_VALUE;
-
-	dispc_reg_merge(OSD_OSDATRMD, required->blinking, OSD_OSDATRMD_BLNK);
-	dispc_reg_merge(OSD_OSDATRMD,
-			required->interval << OSD_OSDATRMD_BLNKINT_SHIFT,
-			OSD_OSDATRMD_BLNKINT);
-
-	dm->osd1->conf_params.bitmap_params.blink_info = *required;
-
-	return result;
-}
-
-/*
- * vpbe_get_blinking 
- */
-/* This	function is used to get	the OSD	window 0 blinking params.*/
-int vpbe_get_blinking(u8 * id, vpbe_blink_option_t * current_conf)
-{
-	int result = 0;
-
-	if (!is_win(id, OSD1)) {
-		return -VPBE_WRONG_WINDOW_ID;
-	}
-	*current_conf = dm->osd1->conf_params.bitmap_params.blink_info;
-
-	return result;
-}
-
-/*
- * vpbe_set_vid_params 
- */
-/* This	function sets the cb-cr	order in the pixel data	for video windows. */
-int vpbe_set_vid_params(u8 * id, vpbe_video_config_params_t * required)
-{
-	int result = 0;
-
-	/* Validate id. Return negative in case of error. */
-	if (!is_win(id, VID0) && !is_win(id, VID1))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	if (is_win(id, VID0)) {
-		dispc_reg_merge(OSD_MODE,
-				required->cb_cr_order << OSD_MODE_CS_SHIFT,
-				OSD_MODE_CS);
-		vpbe_set_vid_expansion(&required->exp_info);
-		dm->vid0->conf_params.video_params.cb_cr_order =
-		    required->cb_cr_order;
-		dm->vid0->conf_params.video_params.exp_info =
-		    required->exp_info;
-	} else {
-		dispc_reg_merge(OSD_MODE,
-				required->cb_cr_order << OSD_MODE_CS_SHIFT,
-				OSD_MODE_CS);
-		dm->vid1->conf_params.video_params.cb_cr_order =
-		    required->cb_cr_order;
-	}
-
-	return result;
-}
-
-/*
- * vpbe_get_vid_params
- */
-/* This	function gives video windows cb-cr order in the pixel data. */
-int vpbe_get_vid_params(u8 * id, vpbe_video_config_params_t * current_conf)
-{
-	int result = 0;
-	if (is_win(id, OSD0) || is_win(id, OSD1))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	if (is_win(id, VID0)) {
-		current_conf->cb_cr_order =
-		    dm->vid0->conf_params.video_params.cb_cr_order;
-		current_conf->exp_info.horizontal =
-		    dm->vid0->conf_params.video_params.exp_info.horizontal;
-		current_conf->exp_info.vertical =
-		    dm->vid0->conf_params.video_params.exp_info.vertical;
-	} else
-		current_conf->cb_cr_order =
-		    dm->vid1->conf_params.video_params.cb_cr_order;
-
-	return result;
-}
-
-/*
- * vpbe_bitamp_get_params
- */
-/* This	function sets the configurations of the	bitmap window. */
-int vpbe_bitmap_get_params(u8 * id, struct vpbe_bitmap_config_params *required)
-{
-	int result = 0;
-
-	if (is_win(id, VID0) || is_win(id, VID1))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	if (is_win(id, OSD0)) {
-		required->attenuation_enable =
-		    dm->osd0->conf_params.bitmap_params.attenuation_enable;
-		required->clut_idx =
-		    dm->osd0->conf_params.bitmap_params.clut_idx;
-		required->clut_select =
-		    dm->osd0->conf_params.bitmap_params.clut_select;
-	} else {
-		required->attenuation_enable =
-		    dm->osd1->conf_params.bitmap_params.attenuation_enable;
-		required->clut_idx =
-		    dm->osd1->conf_params.bitmap_params.clut_idx;
-		required->clut_select =
-		    dm->osd1->conf_params.bitmap_params.clut_select;
-	}
-
-	return result;
-}
-
-/*
- * vpbe_bitamp_set_params	
- */
-/* This	function sets the configurations of the	bitmap window. */
-int vpbe_bitmap_set_params(u8 * id, struct vpbe_bitmap_config_params *required)
-{
-	int result = 0;
-
-	if (is_win(id, VID0) || is_win(id, VID1))
-		return -VPBE_WRONG_WINDOW_ID;
-
-	if (required->clut_select > 2)
-		return -VPBE_INVALID_PARA_VALUE;
-
-	if (is_win(id, OSD0)) {
-		if (((dm->osd1->conf_params.bitmap_params.clut_select == SET_1)
-		     && (required->clut_select == SET_0))
-		    ||
-		    ((dm->osd1->conf_params.bitmap_params.clut_select == SET_0)
-		     && (required->clut_select == SET_1)))
-			return -VPBE_INVALID_PARA_VALUE;
-	} else {
-		if (((dm->osd0->conf_params.bitmap_params.clut_select == SET_1)
-		     && (required->clut_select == SET_0))
-		    ||
-		    ((dm->osd0->conf_params.bitmap_params.clut_select == SET_0)
-		     && (required->clut_select == SET_1)))
-			return -VPBE_INVALID_PARA_VALUE;
-	}
-	if (is_win(id, OSD0)) {
-		if (required->clut_select == 2) {	/* RAM CLUT */
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					SET_1 << OSD_OSDWIN0MD_CLUTS0_SHIFT,
-					OSD_OSDWIN0MD_CLUTS0);
-		} else if (required->clut_select == 1) {	/* ROM1 CLUT */
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					SET_0 << OSD_OSDWIN0MD_CLUTS0_SHIFT,
-					OSD_OSDWIN0MD_CLUTS0);
-			dispc_reg_merge(OSD_MISCCT,
-					SET_1 << OSD_MISCCT_RSEL_SHIFT,
-					OSD_MISCCT_RSEL);
-		} else {	/* ROM0 CLUT */
-			dispc_reg_merge(OSD_OSDWIN0MD,
-					SET_0 << OSD_OSDWIN0MD_CLUTS0_SHIFT,
-					OSD_OSDWIN1MD_CLUTS0);
-			dispc_reg_merge(OSD_MISCCT,
-					SET_0 << OSD_MISCCT_RSEL_SHIFT,
-					OSD_MISCCT_RSEL);
-		}
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				required->
-				attenuation_enable << OSD_OSDWIN0MD_ATN0E_SHIFT,
-				OSD_OSDWIN0MD_ATN0E);
-		if ((dm->osd0->info.var.bits_per_pixel == VPBE_BITMAP_BIT_1)
-		    || (dm->osd0->info.var.bits_per_pixel == VPBE_BITMAP_BIT_2)
-		    || (dm->osd0->info.var.bits_per_pixel == VPBE_BITMAP_BIT_4)) {
-			dispc_reg_merge(OSD_W0BMP01,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_0 <<
-					OSD_W0BMP01_PAL00_SHIFT,
-					OSD_W0BMP01_PAL00);
-			dispc_reg_merge(OSD_W0BMP01,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_1 <<
-					OSD_W0BMP01_PAL01_SHIFT,
-					OSD_W0BMP01_PAL01);
-			dispc_reg_merge(OSD_W0BMP23,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_2 <<
-					OSD_W0BMP23_PAL02_SHIFT,
-					OSD_W0BMP23_PAL02);
-			dispc_reg_merge(OSD_W0BMP23,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_3 <<
-					OSD_W0BMP23_PAL03_SHIFT,
-					OSD_W0BMP23_PAL03);
-			dispc_reg_merge(OSD_W0BMP45,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_4 <<
-					OSD_W0BMP45_PAL04_SHIFT,
-					OSD_W0BMP45_PAL04);
-			dispc_reg_merge(OSD_W0BMP45,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_5 <<
-					OSD_W0BMP45_PAL05_SHIFT,
-					OSD_W0BMP45_PAL05);
-			dispc_reg_merge(OSD_W0BMP67,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_6 <<
-					OSD_W0BMP67_PAL06_SHIFT,
-					OSD_W0BMP67_PAL06);
-			dispc_reg_merge(OSD_W0BMP67,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_7 <<
-					OSD_W0BMP67_PAL07_SHIFT,
-					OSD_W0BMP67_PAL07);
-			dispc_reg_merge(OSD_W0BMP89,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_8 <<
-					OSD_W0BMP89_PAL08_SHIFT,
-					OSD_W0BMP89_PAL08);
-			dispc_reg_merge(OSD_W0BMP89,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_9 <<
-					OSD_W0BMP89_PAL09_SHIFT,
-					OSD_W0BMP89_PAL09);
-			dispc_reg_merge(OSD_W0BMPAB,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_10 <<
-					OSD_W0BMPAB_PAL10_SHIFT,
-					OSD_W0BMPAB_PAL10);
-			dispc_reg_merge(OSD_W0BMPAB,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_11 <<
-					OSD_W0BMPAB_PAL11_SHIFT,
-					OSD_W0BMPAB_PAL11);
-			dispc_reg_merge(OSD_W0BMPCD,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_12 <<
-					OSD_W0BMPCD_PAL12_SHIFT,
-					OSD_W0BMPCD_PAL12);
-			dispc_reg_merge(OSD_W0BMPCD,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_13 <<
-					OSD_W0BMPCD_PAL13_SHIFT,
-					OSD_W0BMPCD_PAL13);
-			dispc_reg_merge(OSD_W0BMPEF,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_14 <<
-					OSD_W0BMPEF_PAL14_SHIFT,
-					OSD_W0BMPEF_PAL14);
-			dispc_reg_merge(OSD_W0BMPEF,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_15 <<
-					OSD_W0BMPEF_PAL15_SHIFT,
-					OSD_W0BMPEF_PAL15);
-		}
-		dm->osd0->conf_params.bitmap_params.clut_idx =
-		    required->clut_idx;
-		dm->osd0->conf_params.bitmap_params.attenuation_enable =
-		    required->attenuation_enable;
-		dm->osd0->conf_params.bitmap_params.clut_select =
-		    required->clut_select;
-	} else if (is_win(id, OSD1)) {
-		if (required->clut_select == 2) {	/* RAM CLUT */
-			dispc_reg_merge(OSD_OSDWIN1MD,
-					SET_1 << OSD_OSDWIN1MD_CLUTS1_SHIFT,
-					OSD_OSDWIN1MD_CLUTS1);
-		} else if (required->clut_select == 1) {	/* ROM1 CLUT */
-			dispc_reg_merge(OSD_OSDWIN1MD,
-					SET_0 << OSD_OSDWIN1MD_CLUTS1_SHIFT,
-					OSD_OSDWIN1MD_CLUTS1);
-			dispc_reg_merge(OSD_MISCCT,
-					SET_1 << OSD_MISCCT_RSEL_SHIFT,
-					OSD_MISCCT_RSEL);
-		} else {	/* ROM0 CLUT */
-			dispc_reg_merge(OSD_OSDWIN1MD,
-					SET_0 << OSD_OSDWIN1MD_CLUTS1_SHIFT,
-					OSD_OSDWIN1MD_CLUTS1);
-			dispc_reg_merge(OSD_MISCCT,
-					SET_0 << OSD_MISCCT_RSEL_SHIFT,
-					OSD_MISCCT_RSEL);
-		}
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				required->
-				attenuation_enable <<
-				OSD_OSDWIN1MD_ATN1E_SHIFT, OSD_OSDWIN1MD_ATN1E);
-		if ((dm->osd1->info.var.bits_per_pixel == VPBE_BITMAP_BIT_1)
-		    || (dm->osd1->info.var.bits_per_pixel == VPBE_BITMAP_BIT_2)
-		    || (dm->osd1->info.var.bits_per_pixel == VPBE_BITMAP_BIT_4)) {
-			dispc_reg_merge(OSD_W1BMP0,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_0 << OSD_W1BMP0_PAL00_SHIFT,
-					OSD_W1BMP0_PAL00);
-			dispc_reg_merge(OSD_W1BMP0,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_1 << OSD_W1BMP0_PAL01_SHIFT,
-					OSD_W1BMP0_PAL01);
-			dispc_reg_merge(OSD_W1BMP2,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_2 << OSD_W1BMP2_PAL02_SHIFT,
-					OSD_W1BMP2_PAL02);
-			dispc_reg_merge(OSD_W1BMP2,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_3 << OSD_W1BMP2_PAL03_SHIFT,
-					OSD_W1BMP2_PAL03);
-			dispc_reg_merge(OSD_W1BMP4,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_4 << OSD_W1BMP4_PAL04_SHIFT,
-					OSD_W1BMP4_PAL04);
-			dispc_reg_merge(OSD_W1BMP4,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_5 << OSD_W1BMP4_PAL05_SHIFT,
-					OSD_W1BMP4_PAL05);
-			dispc_reg_merge(OSD_W1BMP6,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_6 << OSD_W1BMP6_PAL06_SHIFT,
-					OSD_W1BMP6_PAL06);
-			dispc_reg_merge(OSD_W1BMP6,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_7 << OSD_W1BMP6_PAL07_SHIFT,
-					OSD_W1BMP6_PAL07);
-			dispc_reg_merge(OSD_W1BMP8,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_8 << OSD_W1BMP8_PAL08_SHIFT,
-					OSD_W1BMP8_PAL08);
-			dispc_reg_merge(OSD_W1BMP8,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_9 << OSD_W1BMP8_PAL09_SHIFT,
-					OSD_W1BMP8_PAL09);
-			dispc_reg_merge(OSD_W1BMPA,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_10 << OSD_W1BMPA_PAL10_SHIFT,
-					OSD_W1BMPA_PAL10);
-			dispc_reg_merge(OSD_W1BMPA,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_11 << OSD_W1BMPA_PAL11_SHIFT,
-					OSD_W1BMPA_PAL11);
-			dispc_reg_merge(OSD_W1BMPC,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_12 << OSD_W1BMPC_PAL12_SHIFT,
-					OSD_W1BMPC_PAL12);
-			dispc_reg_merge(OSD_W1BMPC,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_13 << OSD_W1BMPC_PAL13_SHIFT,
-					OSD_W1BMPC_PAL13);
-			dispc_reg_merge(OSD_W1BMPE,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_14 << OSD_W1BMPE_PAL14_SHIFT,
-					OSD_W1BMPE_PAL14);
-			dispc_reg_merge(OSD_W1BMPE,
-					required->clut_idx.for_4bit_bimap.
-					bitmap_val_15 << OSD_W1BMPE_PAL15_SHIFT,
-					OSD_W1BMPE_PAL15);
-		}
-		dm->osd1->conf_params.bitmap_params.clut_idx =
-		    required->clut_idx;
-		dm->osd1->conf_params.bitmap_params.attenuation_enable =
-		    required->attenuation_enable;
-		dm->osd1->conf_params.bitmap_params.clut_select =
-		    required->clut_select;
-	}
-	return result;
-}
-
-/*
- * vpbe_set_cursor_params	
- */
-/* Function to set cursor window parameters	*/
-int vpbe_set_cursor_params(struct fb_cursor *required)
-{
-	/* Validation for cursor configuration parameters */
-	/* Rule cursor must be fully contained inside vid0 window */
-	if ((!within_vid0_limits
-	     (required->image.dx, required->image.dy,
-	      required->image.width, required->image.height))
-	    || (required->image.fg_color > 0xff)
-	    || (required->image.width > MAX_CURSOR_WIDTH)
-	    || (required->image.height > MAX_CURSOR_HEIGHT)
-	    || (required->image.depth > MAX_CURSOR_LINEWIDTH))
-		return -VPBE_INVALID_PARA_VALUE;
-
-	dm->cursor = *required;
-
-	dispc_reg_merge(OSD_RECTCUR, dm->cursor.enable, OSD_RECTCUR_RCACT);
-	dispc_reg_out(OSD_CURXP, dm->cursor.image.dx);
-	dispc_reg_out(OSD_CURXL, dm->cursor.image.width);
-
-	/* Field/Frame setting for Cursor are kept as same as VID0 window. */
-	if (dm->videomode.vmode == FB_VMODE_INTERLACED) {
-		dispc_reg_out(OSD_CURYP, dm->cursor.image.dy / 2);
-		dispc_reg_out(OSD_CURYL, dm->cursor.image.height / 2);
-	} else {
-		dispc_reg_out(OSD_CURYP, dm->cursor.image.dy);
-		dispc_reg_out(OSD_CURYL, dm->cursor.image.height);
-	}
-
-	dispc_reg_merge(OSD_RECTCUR,
-			dm->cursor.image.depth << OSD_RECTCUR_RCHW_SHIFT,
-			OSD_RECTCUR_RCHW);
-	dispc_reg_merge(OSD_RECTCUR,
-			dm->cursor.image.depth << OSD_RECTCUR_RCVW_SHIFT,
-			OSD_RECTCUR_RCVW);
-
-	dispc_reg_merge(OSD_RECTCUR, 0 << OSD_RECTCUR_CLUTSR_SHIFT,
-			OSD_RECTCUR_CLUTSR);
-	dispc_reg_merge(OSD_RECTCUR,
-			dm->cursor.image.
-			fg_color << OSD_RECTCUR_RCAD_SHIFT, OSD_RECTCUR_RCAD);
-	return 0;
-}
-
-/*
- * vpbe_set_vid_expansion
- */
-/* Function to set pixel clock parameters */
-/* Note: we are setting expantion for video window only */
-int vpbe_set_vid_expansion(vpbe_win_expansion_t * required)
-{
-	int result = 0;
-
-	/*Set fields OSD_MODE.VHRSZ and OSD_MODE.VVRSZ accordingly */
-	dispc_reg_merge(OSD_MODE,
-			required->horizontal << OSD_MODE_VHRSZ_SHIFT,
-			OSD_MODE_VHRSZ);
-	dispc_reg_merge(OSD_MODE,
-			required->vertical << OSD_MODE_VVRSZ_SHIFT,
-			OSD_MODE_VVRSZ);
-
-	dm->vid0->conf_params.video_params.exp_info = *required;
-
-	return result;
-}
-
-/*
- * vpbe_set_dclk
- */
-/* Function	to set pixel clock parameters	*/
-int vpbe_set_dclk(vpbe_dclk_t * dclk)
-{
-	int result = 0;
-# if 0
-	if ((dclk->dclk_pattern_width > 0x3F) ||
-	    (dclk->dclk_pattern0 > 0xFFFF) ||
-	    (dclk->dclk_pattern1 > 0xFFFF) || (dclk->dclk_pattern2 > 0xFFFF)
-	    || (dclk->dclk_pattern3 > 0xFFFF))
-		return -VPBE_INVALID_PARA_VALUE;
-
-	dispc_reg_merge(VENC_DCLKCTL, dclk->dclk_pattern_width,
-			VENC_DCLKCTL_DCKPW);
-	dispc_reg_out(VENC_DCLKPTN0, dclk->dclk_pattern0);
-	dispc_reg_out(VENC_DCLKPTN1, dclk->dclk_pattern1);
-	dispc_reg_out(VENC_DCLKPTN2, dclk->dclk_pattern2);
-	dispc_reg_out(VENC_DCLKPTN3, dclk->dclk_pattern3);
-#endif
-	dm->dclk = *dclk;
-
-	return result;
-}
-
-/*
- * vpbe_set_backg_color 
- */
-/* Function to configure registers for background color	selection */
-int vpbe_set_backg_color(vpbe_backg_color_t * bg)
-{
-	int result = 0;
-
-	switch (bg->clut_select) {
-	case 0:		/* ROM 0 CLUT */
-		dispc_reg_merge(OSD_MODE,
-				bg->color_offset << OSD_MODE_CABG_SHIFT,
-				OSD_MODE_CABG);
-		dispc_reg_merge(OSD_MISCCT, SET_0 << OSD_MISCCT_RSEL_SHIFT,
-				OSD_MISCCT_RSEL);
-		dispc_reg_merge(OSD_MODE, SET_0 << OSD_MODE_BCLUT_SHIFT,
-				OSD_MODE_BCLUT);
-		break;
-	case 1:		/* ROM 1 CLUT */
-		dispc_reg_merge(OSD_MODE,
-				bg->color_offset << OSD_MODE_CABG_SHIFT,
-				OSD_MODE_CABG);
-		dispc_reg_merge(OSD_MISCCT, SET_1 << OSD_MISCCT_RSEL_SHIFT,
-				OSD_MISCCT_RSEL);
-		dispc_reg_merge(OSD_MODE, SET_0 << OSD_MODE_BCLUT_SHIFT,
-				OSD_MODE_BCLUT);
-		break;
-	case 2:		/* RAM CLUT */
-		dispc_reg_merge(OSD_MODE,
-				bg->color_offset << OSD_MODE_CABG_SHIFT,
-				OSD_MODE_CABG);
-		dispc_reg_merge(OSD_MODE, SET_1 << OSD_MODE_BCLUT_SHIFT,
-				OSD_MODE_BCLUT);
-		break;
-	default:
-		return -VPBE_INVALID_PARA_VALUE;
-	}
-
-	dm->backg = *bg;
-
-	return result;
-}
-
-/*
- * vpbe_set_interface 
- */
-/* To set display interface given by index. */
-int vpbe_set_interface(u8 interface)
-{
-	int result = 0;
-
-	if (interface > VPBE_MAX_INTERFACES)
-		return -VPBE_INVALID_PARA_VALUE;
-
-	/* Set Display for first mode for given interface */
-	dm->display.interface = interface;
-	dm->display.mode = 0;
-	dm->videomode = modelist[dm->display.interface][dm->display.mode];
-	/* Find appropriate display function */
-	init_display_function(&dm->display);
-
-	dm->output_device_config();
-
-	return result;
-}
-
-/*
- * vpbe_query_mode 
- */
-/*  To query whether a perticular mode given by interface 
- *  and mode index is available or not.
- *  If mode is available, set video mode structure accordingly.
- *  Else set pointer to video mode structure to NULL.	
- */
-int vpbe_query_mode(vpbe_mode_info_t * mode_info)
-{
-	int mode;
-	int supported = 1;	/* flag indicated whether mode is found ot not */
-
-	if (mode_info->interface > VPBE_MAX_INTERFACES)
-		supported = 0;
-	else {
-		for (mode = 0; mode <= mode_info->mode_idx; mode++) {
-			if (!strcmp
-			    (modelist[mode_info->interface][mode].name, "\0")) {
-				supported = 0;
-				break;
-			}
-		}
-	}
-
-	if (!supported)
-		/*If mode not found...set pointer to vpbe_fb_videomode with NULL */
-	{
-		strcpy(mode_info->vid_mode.name, "\0");
-		return 0;
-	} else {
-		mode_info->vid_mode =
-		    modelist[mode_info->interface][mode_info->mode_idx];
-	}
-	return 0;
-}
-
-/*
- * vpbe_set_mode 
- */
-/* To configure video mode structure(If mode is available).*/
-int vpbe_set_mode(struct vpbe_fb_videomode *vm)
-{
-	int interface, mode;
-	int result = 0, mode_found = 0, check_new_interface = 0;
-	if (vm->std) {
-		/* Find suitable match */
-		for (interface = 0; interface < VPBE_MAX_INTERFACES;
-		     interface++) {
-			for (mode = 0;; mode++) {
-				if (!strcmp
-				    (modelist[interface][mode].name, "\0")) {
-					check_new_interface = 1;
-					break;
-				} else
-				    if ((modelist[interface][mode].vmode ==
-					 vm->vmode)
-					&& (modelist[interface][mode].
-					    xres == vm->xres)
-					&& (modelist[interface][mode].
-					    yres == vm->yres)
-					&& (modelist[interface][mode].
-					    fps == vm->fps)
-					&&
-					(!strcmp
-					 (modelist[interface][mode].name,
-					  vm->name))) {
-					/* Mode found */
-					dm->display.interface = interface;
-					dm->display.mode = mode;
-					mode_found = 1;
-					break;
-				}
-			}
-			if (mode_found)
-				break;
-			if (check_new_interface)
-				continue;
-		}
-		if (!mode_found)	/* Required mode not found. Return -1 */
-			return -1;
-		else
-			dm->videomode =
-			    modelist[dm->display.interface][dm->display.mode];
-	} else {
-		dm->videomode = *vm;
-		/* For Non existing mode of curruntly selected interface. */
-		dm->display.mode = 255;
-	}
-	/* Find appropriate display function */
-	init_display_function(&dm->display);
-
-	dm->output_device_config();
-
-	return result;
-}
-
-/*
- * vpbe_set_venc_clk_source 
- */
-/* To select VENC module click source.	*/
-int vpbe_set_venc_clk_source(u8 muxsel)
-{
-	int result = 0;
-
-/*
- *  For CLK_SOURCE_CLK27, VPSS_MUXSEL should be 0   
- *  For CLK_SOURCE_CLK54, VPSS_MUXSEL should be 1 
- *  For CLK_SOURCE_VPBECLK, VPSS_MUXSEL should be 2
- */
-	if (muxsel > CLK_SOURCE_VPBECLK)
-		return -VPBE_INVALID_PARA_VALUE;
-
-	return result;
-}
Index: linux-2.6.10/drivers/video/davincifb_venc.c
===================================================================
--- linux-2.6.10.orig/drivers/video/davincifb_venc.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/* 
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option)any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * File: davincifb_venc.c	
- */
-
-#include <video/davinci_vpbe.h>
-#include <video/davincifb.h>
-
-extern vpbe_dm_info_t *dm;
-
-void vpbe_enable_venc(int on)
-{
-	dispc_reg_merge(VENC_VMOD, on, VENC_VMOD_VENC);
-}
-
-void vpbe_enable_dacs(int on)
-{
-	if (on) {
-		dispc_reg_out(VENC_DACTST, 0);
-	} else {
-		dispc_reg_out(VENC_DACTST, 0xF000);
-	}
-}
-
-/*
- * Function to change window parameters as per display.
- */
-void change_win_param(int flag)
-{
-	dm->vid0->win_pos.xpos = 0;
-	dm->vid0->win_pos.ypos = 0;
-	dm->vid0->info.var.xres = dm->videomode.xres;
-	dm->vid0->info.var.yres = dm->videomode.yres;
-	dm->vid0->info.var.vmode = dm->videomode.vmode;
-
-	dm->vid1->win_pos.xpos = 0;
-	dm->vid1->win_pos.ypos = 0;
-	dm->vid1->info.var.xres = dm->videomode.xres;
-	dm->vid1->info.var.yres = dm->videomode.yres;
-	dm->vid1->info.var.vmode = dm->videomode.vmode;
-
-	dm->osd0->win_pos.xpos = 0;
-	dm->osd0->win_pos.ypos = 0;
-	dm->osd0->info.var.xres = dm->videomode.xres;
-	dm->osd0->info.var.yres = dm->videomode.yres;
-	dm->osd0->info.var.vmode = dm->videomode.vmode;
-
-	dm->osd1->win_pos.xpos = 0;
-	dm->osd1->win_pos.ypos = 0;
-	dm->osd1->info.var.xres = dm->videomode.xres;
-	dm->osd1->info.var.yres = dm->videomode.yres;
-	dm->osd1->info.var.vmode = dm->videomode.vmode;
-
-	set_interlaced(dm->vid0->info.fix.id, dm->videomode.vmode);
-	set_interlaced(dm->vid1->info.fix.id, dm->videomode.vmode);
-	set_interlaced(dm->osd0->info.fix.id, dm->videomode.vmode);
-	set_interlaced(dm->osd1->info.fix.id, dm->videomode.vmode);
-
-	if (flag == FB_VMODE_INTERLACED) {
-		set_win_position(dm->vid0->info.fix.id,
-				 dm->vid0->win_pos.xpos,
-				 dm->vid0->win_pos.ypos / 2,
-				 dm->vid0->info.var.xres,
-				 dm->vid0->info.var.yres / 2);
-		set_win_position(dm->vid1->info.fix.id,
-				 dm->vid1->win_pos.xpos,
-				 dm->vid1->win_pos.ypos / 2,
-				 dm->vid1->info.var.xres,
-				 dm->vid1->info.var.yres / 2);
-		set_win_position(dm->osd0->info.fix.id,
-				 dm->osd0->win_pos.xpos,
-				 dm->osd0->win_pos.ypos / 2,
-				 dm->osd0->info.var.xres,
-				 dm->osd0->info.var.yres / 2);
-		set_win_position(dm->osd1->info.fix.id,
-				 dm->osd1->win_pos.xpos,
-				 dm->osd1->win_pos.ypos / 2,
-				 dm->osd1->info.var.xres,
-				 dm->osd1->info.var.yres / 2);
-	} else {
-		set_win_position(dm->vid0->info.fix.id,
-				 dm->vid0->win_pos.xpos,
-				 dm->vid0->win_pos.ypos,
-				 dm->vid0->info.var.xres,
-				 dm->vid0->info.var.yres);
-		set_win_position(dm->vid1->info.fix.id,
-				 dm->vid1->win_pos.xpos,
-				 dm->vid1->win_pos.ypos,
-				 dm->vid1->info.var.xres,
-				 dm->vid1->info.var.yres);
-		set_win_position(dm->osd0->info.fix.id,
-				 dm->osd0->win_pos.xpos,
-				 dm->osd0->win_pos.ypos,
-				 dm->osd0->info.var.xres,
-				 dm->osd0->info.var.yres);
-		set_win_position(dm->osd1->info.fix.id,
-				 dm->osd1->win_pos.xpos,
-				 dm->osd1->win_pos.ypos,
-				 dm->osd1->info.var.xres,
-				 dm->osd1->info.var.yres);
-	}
-}
-
-void davincifb_ntsc_composite_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-	/* to set DAC & VENC CLK to 54 MHz */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-
-	/* set OSD Divisor to 1 */
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1002 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-void davincifb_ntsc_svideo_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-	/* to set DAC & VENC CLK to 54 MHz */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-	/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-	/*  set OSD Divisor to 1 */
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1002 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Enable S-Video Output; DAC B: S-Video Y, DAC C: S-Video C  */
-	dispc_reg_out(VENC_DACSEL, 0x210);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-void davincifb_ntsc_component_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* to set DAC & VENC CLK to 54 MHz */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* To set VENC CLK DIV to 1 - final clock is 54 MHz */
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-
-	/* set OSD Divisor to 1 */
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1002 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-void davincifb_pal_composite_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-	/* to set DAC & VENC CLK to 54 MHz */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-
-	/* set OSD Divisor to 1 */
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1042 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-void davincifb_pal_svideo_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-	/* to set DAC & VENC CLK to 54 MHz */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1042 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Enable S-Video Output; DAC B: S-Video Y, DAC C: S-Video C  */
-	dispc_reg_out(VENC_DACSEL, 0x210);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-void davincifb_pal_component_config(void)
-{
-	volatile unsigned int venc, dactst;
-	dactst = dispc_reg_in(VENC_DACTST);
-	venc = dispc_reg_in(VENC_VMOD) & VENC_VMOD_VENC;
-	vpbe_set_display_default();
-
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	dispc_reg_merge(VPBE_PCR, 0, VPBE_PCR_VENC_DIV);
-
-	dispc_reg_out(VENC_OSDCLK0, 1);
-	dispc_reg_out(VENC_OSDCLK1, 2);
-
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Configure VMOD. No change in VENC bit */
-	dispc_reg_out(VENC_VMOD, 0x1042 | venc);
-	dispc_reg_out(VENC_DACTST, dactst);
-
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-
-	/* Change window parameters for interlaced display */
-	change_win_param(FB_VMODE_INTERLACED);
-}
-
-/*
- * vpbe_davincifb_ntsc_rgb_config 
- */
-/* This function configures the video encoder to NTSC RGB setting.*/
-void vpbe_davincifb_ntsc_rgb_config(void)
-{
-	vpbe_set_display_default();
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	dispc_reg_merge(VENC_CMPNT, 1 << VENC_CMPNT_MRGB_SHIFT,
-			VENC_CMPNT_MRGB);
-	/* Set VMOD to select VENC =ENABLE, SDTV_NTSC, HDMD = SDTV */
-	/* Enable Composite output and start video encoder */
-
-	dispc_reg_merge(VENC_VMOD,
-			SDTV_NTSC << VENC_VMOD_TVTYP_SHIFT,
-			VENC_VMOD_TVTYP);
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-}
-
-/*
- * vpbe_davincifb_pal_rgb_config 
- */
-/* This function configures the video encoder to PAL RGB setting.*/
-void vpbe_davincifb_pal_rgb_config(void)
-{
-	vpbe_set_display_default();
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	dispc_reg_merge(VENC_CMPNT, 1 << VENC_CMPNT_MRGB_SHIFT,
-			VENC_CMPNT_MRGB);
-	/* Set VMOD to select SDTV_NTSC, HDMD = SDTV */
-	dispc_reg_merge(VENC_VMOD,
-			SDTV_PAL << VENC_VMOD_TVTYP_SHIFT,
-			VENC_VMOD_TVTYP);
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-}
-
-/*
- * vpbe_davincifb_525p_component_config 
- */
-/* This function configures the video encoder to HDTV(525p) component setting.*/
-void vpbe_davincifb_525p_component_config(void)
-{
-	vpbe_set_display_default();
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	dispc_reg_out(VPSS_CLKCTL, 0x19);
-
-	dispc_reg_merge(VPBE_PCR, VPBE_PCR_VENC_DIV, VPBE_PCR_VENC_DIV);
-
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-
-	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
-
-	/* Enable Composite output and start video encoder */
-
-	/* Set VMOD to select  
-	   TVTYP = HDTV 525, HDMD = HDTV, ITLC = Non_interlace */
-	dispc_reg_merge(VENC_VMOD, 1<<VENC_VMOD_VIE_SHIFT, VENC_VMOD_VIE);
-	dispc_reg_merge(VENC_VMOD,
-			VENC_VMOD_VDMD_YCBCR8 <<
-			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
-	dispc_reg_merge(VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);
-
-	dispc_reg_merge(VENC_VMOD,
-			HDTV_525P << VENC_VMOD_TVTYP_SHIFT,
-			VENC_VMOD_TVTYP);
-
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Change window parameters for progressive display */
-	change_win_param(FB_VMODE_NONINTERLACED);
-}
-
-/*
- * vpbe_davincifb_625p_component_config 
- */
-/* This function configures the video encoder to HDTV(625p) component setting.*/
-void vpbe_davincifb_625p_component_config(void)
-{
-	vpbe_set_display_default();
-
-	dispc_reg_out(OSD_BASEPX, dm->videomode.basepx);
-	dispc_reg_out(OSD_BASEPY, dm->videomode.basepy);
-
-	dispc_reg_out(VPSS_CLKCTL, 0x19);
-
-	dispc_reg_merge(VPBE_PCR, VPBE_PCR_VENC_DIV, VPBE_PCR_VENC_DIV);
-
-	dispc_reg_out(VENC_OSDCLK0, 0);
-	dispc_reg_out(VENC_OSDCLK1, 1);
-
-	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
-	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
-
-	/* Enable Composite output and start video encoder */
-
-	/* Set VMOD to select  
-	   TVTYP = HDTV 525, HDMD = HDTV, ITLC = Non_interlace */
-	dispc_reg_merge(VENC_VMOD, 1<<VENC_VMOD_VIE_SHIFT, VENC_VMOD_VIE);
-	dispc_reg_merge(VENC_VMOD,
-			VENC_VMOD_VDMD_YCBCR8 <<
-			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
-	dispc_reg_merge(VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);
-
-	dispc_reg_merge(VENC_VMOD,
-			HDTV_625P << VENC_VMOD_TVTYP_SHIFT,
-			VENC_VMOD_TVTYP);
-
-	/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-	dispc_reg_out(VENC_DACSEL, 0x543);
-
-	/* Set REC656 Mode */
-	dispc_reg_out(VENC_YCCCTL, 0x1);
-
-	/* Change window parameters for progressive display */
-	change_win_param(FB_VMODE_NONINTERLACED);
-}
Index: linux-2.6.10/drivers/video/davinci/davincifb.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/video/davinci/davincifb.c
@@ -0,0 +1,2299 @@
+/*
+ * Copyright (C) 2007 MontaVista Software Inc.
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <asm/uaccess.h>
+#include <linux/moduleparam.h>	/* for module_param() */
+#include <asm/system.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <media/davinci/davinci_enc.h>
+#include <video/davincifb_ioctl.h>
+#include <video/davincifb.h>
+#include <asm/arch/cpu.h>
+
+/* return non-zero if the info structure corresponds to OSD0 or OSD1 */
+static int is_osd_win(const struct fb_info *info)
+{
+	const struct vpbe_dm_win_info *win = info->par;
+
+	if (win->layer == WIN_OSD0 || win->layer == WIN_OSD1)
+		return 1;
+	else
+		return 0;
+}
+
+/* return non-zero if the info structure corresponds to VID0 or VID1 */
+#define is_vid_win(info) (!is_osd_win(info))
+
+/*
+ * Convert a framebuffer info pointer to a davinci_osd_layer enumeration.
+ * It is up to the caller to verify that the info structure corresponds to
+ * either OSD0 or OSD1.
+ */
+static enum davinci_osd_layer fb_info_to_osd_enum(const struct fb_info *info)
+{
+	const struct vpbe_dm_win_info *win = info->par;
+
+	if (win->layer == WIN_OSD1)
+		return OSDWIN_OSD1;
+	else
+		return OSDWIN_OSD0;
+}
+
+/* macros for testing fb_var_screeninfo attributes */
+#define is_attribute_mode(var) (((var)->bits_per_pixel == 4) && \
+	((var)->nonstd != 0))
+#define is_yuv(var) (((var)->bits_per_pixel == 16) && ((var)->nonstd != 0))
+#define is_window_interlaced(var) (((var)->vmode & FB_VMODE_INTERLACED) \
+	== FB_VMODE_INTERLACED)
+
+/* macros for testing fb_videomode attributes */
+#define is_display_interlaced(mode) (((mode)->vmode & FB_VMODE_INTERLACED) \
+	== FB_VMODE_INTERLACED)
+
+/*
+ * Convert an fb_var_screeninfo struct to a Davinci display layer configuration.
+ * lconfig->xpos, lconfig->ypos, and lconfig->line_length are not modified
+ * because no information about them is contained in var.
+ * The value of the yc_pixfmt argument is returned in lconfig->pixfmt if a
+ * the var specifies a YC pixel format.  The value of yc_pixfmt must be either
+ * PIXFMT_YCbCrI or PIXFMT_YCrCbI.
+ */
+static void convert_fb_var_to_osd(const struct fb_var_screeninfo *var,
+				  struct davinci_layer_config *lconfig,
+				  enum davinci_pix_format yc_pixfmt)
+{
+	lconfig->xsize = var->xres;
+	lconfig->ysize = var->yres;
+	lconfig->interlaced = is_window_interlaced(var);
+
+	switch (var->bits_per_pixel) {
+	case 1:
+		lconfig->pixfmt = PIXFMT_1BPP;
+		break;
+	case 2:
+		lconfig->pixfmt = PIXFMT_2BPP;
+		break;
+	case 4:
+		if (is_attribute_mode(var))
+			lconfig->pixfmt = PIXFMT_OSD_ATTR;
+		else
+			lconfig->pixfmt = PIXFMT_4BPP;
+		break;
+	case 8:
+		lconfig->pixfmt = PIXFMT_8BPP;
+		break;
+	case 16:
+	default:
+		if (is_yuv(var))
+			lconfig->pixfmt = yc_pixfmt;
+		else
+			lconfig->pixfmt = PIXFMT_RGB565;
+		break;
+	case 24:
+	case 32:
+		lconfig->pixfmt = PIXFMT_RGB888;
+		break;
+	}
+}
+
+/*
+ * Convert an fb_info struct to a Davinci display layer configuration.
+ */
+static void convert_fb_info_to_osd(const struct fb_info *info,
+				   struct davinci_layer_config *lconfig)
+{
+	const struct vpbe_dm_win_info *win = info->par;
+
+	lconfig->line_length = info->fix.line_length;
+	lconfig->xpos = win->xpos;
+	lconfig->ypos = win->ypos;
+	convert_fb_var_to_osd(&info->var, lconfig, win->dm->yc_pixfmt);
+}
+
+/*
+ * Convert a Davinci display layer configuration to var info.
+ * The following members of var are not modified:
+ *	var->xres_virtual
+ *	var->yres_virtual
+ *	var->xoffset
+ *	var->yoffset
+ *	var->pixclock
+ *	var->left_margin
+ *	var->right_margin
+ *	var->upper_margin
+ *	var->lower_margin
+ *	var->hsync_len
+ *	var->vsync_len
+ *	var->sync
+ * Only bit 0 of var->vmode (FB_VMODE_INTERLACED) is modified.  All other bits
+ * of var->vmode are retained.
+ */
+static void convert_osd_to_fb_var(const struct davinci_layer_config *lconfig,
+				  struct fb_var_screeninfo *var)
+{
+	var->xres = lconfig->xsize;
+	var->yres = lconfig->ysize;
+	if (lconfig->interlaced)
+		var->vmode |= FB_VMODE_INTERLACED;
+	else
+		var->vmode &= ~FB_VMODE_INTERLACED;
+
+	var->red.offset = var->green.offset = var->blue.offset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+	var->nonstd = 0;
+
+	switch (lconfig->pixfmt) {
+	case PIXFMT_1BPP:
+		var->bits_per_pixel = 1;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_2BPP:
+		var->bits_per_pixel = 2;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_4BPP:
+		var->bits_per_pixel = 4;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_8BPP:
+		var->bits_per_pixel = 8;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		var->bits_per_pixel = 16;
+		var->red.length = var->green.length = var->blue.length = 0;
+		var->nonstd = 1;
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm644x()) {
+			var->bits_per_pixel = 24;
+			var->red.offset = 0;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 16;
+			var->blue.length = 8;
+		} else {
+			var->bits_per_pixel = 32;
+			var->red.offset = 16;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 0;
+			var->blue.length = 8;
+			var->transp.offset = 24;
+			var->transp.length = 3;
+		}
+		break;
+	case PIXFMT_OSD_ATTR:
+		var->bits_per_pixel = 4;
+		var->red.length = var->green.length = var->blue.length = 0;
+		var->nonstd = 1;
+		break;
+	}
+
+	var->grayscale = 0;
+	var->activate = FB_ACTIVATE_NOW;
+	var->height = 0;
+	var->width = 0;
+	var->accel_flags = 0;
+	var->rotate = 0;
+}
+
+/*
+ * Get the video mode from the encoder manager.
+ */
+static int get_video_mode(struct fb_videomode *mode)
+{
+	struct vid_enc_mode_info mode_info;
+	int ret;
+
+	memset(&mode_info, 0, sizeof(mode_info));
+	memset(mode, 0, sizeof(*mode));
+
+	ret = davinci_enc_get_mode(0, &mode_info);
+
+	mode->name = mode_info.name;
+	if (mode_info.fps.denominator) {
+		unsigned fps_1000;	/* frames per 1000 seconds */
+		unsigned lps;	/* lines per second */
+		unsigned pps;	/* pixels per second */
+		unsigned vtotal;	/* total lines per frame */
+		unsigned htotal;	/* total pixels per line */
+		unsigned interlace = (mode_info.interlaced) ? 2 : 1;
+
+		fps_1000 =
+		    (1000 * mode_info.fps.numerator +
+		     mode_info.fps.denominator / 2) / mode_info.fps.denominator;
+		mode->refresh = (interlace * fps_1000 + 1000 / 2) / 1000;
+
+		vtotal =
+		    mode_info.yres + mode_info.lower_margin +
+		    mode_info.vsync_len + mode_info.upper_margin;
+		lps = (fps_1000 * vtotal + 1000 / 2) / 1000;
+
+		htotal =
+		    mode_info.xres + mode_info.right_margin +
+		    mode_info.hsync_len + mode_info.left_margin;
+		pps = lps * htotal;
+
+		if (pps)
+			mode->pixclock =
+			    ((1000000000UL + pps / 2) / pps) * 1000;
+	}
+	mode->xres = mode_info.xres;
+	mode->yres = mode_info.yres;
+	mode->left_margin = mode_info.left_margin;
+	mode->right_margin = mode_info.right_margin;
+	mode->upper_margin = mode_info.upper_margin;
+	mode->lower_margin = mode_info.lower_margin;
+	mode->hsync_len = mode_info.hsync_len;
+	mode->vsync_len = mode_info.vsync_len;
+	if (mode_info.flags & (1 << 0))
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (mode_info.flags & (1 << 1))
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	if (mode_info.std)
+		mode->sync |= FB_SYNC_BROADCAST;
+	if (mode_info.interlaced)
+		mode->vmode |= FB_VMODE_INTERLACED;
+
+	return ret;
+}
+
+/*
+ * Set a video mode with the encoder manager.
+ */
+static int set_video_mode(struct fb_videomode *mode)
+{
+	struct vid_enc_mode_info mode_info;
+	int ret;
+
+	davinci_enc_get_mode(0, &mode_info);
+
+	mode_info.name = (unsigned char *)mode->name;
+	mode_info.fps.numerator = 0;
+	mode_info.fps.denominator = 0;
+	if (mode->pixclock && mode->xres && mode->yres) {
+		unsigned fps_1000;	/* frames per 1000 seconds */
+		unsigned lps;	/* lines per second */
+		unsigned pps;	/* pixels per second */
+		unsigned vtotal;	/* total lines per frame */
+		unsigned htotal;	/* total pixels per line */
+
+		pps =
+		    ((1000000000UL +
+		      mode->pixclock / 2) / mode->pixclock) * 1000;
+
+		htotal =
+		    mode->xres + mode->right_margin + mode->hsync_len +
+		    mode->left_margin;
+		lps = (pps + htotal / 2) / htotal;
+
+		vtotal =
+		    mode->yres + mode->lower_margin + mode->vsync_len +
+		    mode->upper_margin;
+		fps_1000 = (lps * 1000 + vtotal / 2) / vtotal;
+
+		mode_info.fps.numerator = fps_1000;
+		mode_info.fps.denominator = 1000;
+
+		/*
+		 * 1000 == 2*2*2*5*5*5, so factor out any common multiples of 2
+		 * or 5
+		 */
+		while ((((mode_info.fps.numerator / 2) * 2) ==
+			mode_info.fps.numerator)
+		       && (((mode_info.fps.denominator / 2) * 2) ==
+			   mode_info.fps.denominator)) {
+			mode_info.fps.numerator = mode_info.fps.numerator / 2;
+			mode_info.fps.denominator =
+			    mode_info.fps.denominator / 2;
+		}
+		while ((((mode_info.fps.numerator / 5) * 5) ==
+			mode_info.fps.numerator)
+		       && (((mode_info.fps.denominator / 5) * 5) ==
+			   mode_info.fps.denominator)) {
+			mode_info.fps.numerator = mode_info.fps.numerator / 5;
+			mode_info.fps.denominator =
+			    mode_info.fps.denominator / 5;
+		}
+	}
+	mode_info.xres = mode->xres;
+	mode_info.yres = mode->yres;
+	mode_info.left_margin = mode->left_margin;
+	mode_info.right_margin = mode->right_margin;
+	mode_info.upper_margin = mode->upper_margin;
+	mode_info.lower_margin = mode->lower_margin;
+	mode_info.hsync_len = mode->hsync_len;
+	mode_info.vsync_len = mode->vsync_len;
+	if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		mode_info.flags |= (1 << 0);
+	else
+		mode_info.flags &= ~(1 << 0);
+	if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		mode_info.flags |= (1 << 1);
+	else
+		mode_info.flags &= ~(1 << 1);
+	if (mode->sync & FB_SYNC_BROADCAST)
+		mode_info.std = 1;
+	else
+		mode_info.std = 0;
+	if (mode->vmode & FB_VMODE_INTERLACED)
+		mode_info.interlaced = 1;
+	else
+		mode_info.interlaced = 0;
+
+	ret = davinci_enc_set_mode(0, &mode_info);
+
+	return ret;
+}
+
+/*
+ * Construct an fb_var_screeninfo structure from an fb_videomode structure
+ * describing the display and a davinci_layer_config structure describing a window.
+ * The following members of var not modified:
+ *	var->xoffset
+ *	var->yoffset
+ *	var->xres_virtual
+ *	var->yres_virtual
+ * The following members of var are loaded with values derived from mode:
+ *	var->pixclock
+ *	var->left_margin
+ *	var->hsync_len
+ *	var->vsync_len
+ *	var->right_margin
+ *	var->upper_margin
+ *	var->lower_margin
+ *	var->sync
+ *	var->vmode (all bits except bit 0: FB_VMODE_INTERLACED)
+ * The following members of var are loaded with values derived from lconfig:
+ *	var->xres
+ *	var->yres
+ *	var->bits_per_pixel
+ *	var->red
+ *	var->green
+ *	var->blue
+ *	var->transp
+ *	var->nonstd
+ *	var->grayscale
+ *	var->activate
+ *	var->height
+ *	var->width
+ *	var->accel_flags
+ *	var->rotate
+ *	var->vmode (only bit 0: FB_VMODE_INTERLACED)
+ *
+ * If the display resolution (xres and yres) specified in mode matches the
+ * window resolution specified in lconfig, then the display timing info returned
+ * in var is valid and var->pixclock will be the value derived from mode.
+ * If the display resolution does not match the window resolution, then
+ * var->pixclock will be set to 0 to indicate that the display timing info
+ * returned in var is not valid.
+ *
+ * mode and lconfig are not modified.
+ */
+static void construct_fb_var(struct fb_var_screeninfo *var,
+			     struct fb_videomode *mode,
+			     struct davinci_layer_config *lconfig)
+{
+	fb_videomode_to_var(var, mode);
+	convert_osd_to_fb_var(lconfig, var);
+	if (lconfig->xsize != mode->xres || lconfig->ysize != mode->yres)
+		var->pixclock = 0;
+}
+
+/*
+ * Update the values in an fb_fix_screeninfo structure based on the values in an
+ * fb_var_screeninfo structure.
+ * The following members of fix are updated:
+ *	fix->visual
+ *	fix->xpanstep
+ *	fix->ypanstep
+ *	fix->ywrapstep
+ *	fix->line_length
+ * All other members of fix are unmodified.
+ */
+static void update_fix_info(const struct fb_var_screeninfo *var,
+			    struct fb_fix_screeninfo *fix)
+{
+	fix->visual =
+	    (var->bits_per_pixel >
+	     8) ? FB_VISUAL_TRUECOLOR : FB_VISUAL_PSEUDOCOLOR;
+	/*
+	 * xpanstep must correspond to a multiple of the 32-byte cache line size
+	 */
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 16:
+	case 32:
+		fix->xpanstep = (8 * 32) / var->bits_per_pixel;
+		break;
+	case 24:
+		fix->xpanstep = 32;	/* 32 pixels = 3 cache lines */
+		break;
+	default:
+		fix->xpanstep = 0;
+		break;
+	}
+	fix->ypanstep = 1;
+	fix->ywrapstep = 0;
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel + 7) / 8;
+	/* line_length must be a multiple of the 32-byte cache line size */
+	fix->line_length = ((fix->line_length + 31) / 32) * 32;
+}
+
+/*
+ * Determine if the window configuration specified by var will fit in a
+ * framebuffer of size fb_size.
+ * Returns 1 if the window will fit in the framebuffer, or 0 otherwise.
+ */
+static int window_will_fit_framebuffer(const struct fb_var_screeninfo *var,
+				       unsigned fb_size)
+{
+	unsigned line_length;
+
+	line_length = (var->bits_per_pixel * var->xres_virtual + 7) / 8;
+	/* line length must be a multiple of the cache line size (32) */
+	line_length = ((line_length + 31) / 32) * 32;
+
+	if (var->yres_virtual * line_length <= fb_size)
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * FBIO_WAITFORVSYNC handler
+ */
+static int davincifb_wait_for_vsync(struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	wait_queue_t wq;
+	unsigned long cnt;
+	int ret;
+
+	init_waitqueue_entry(&wq, current);
+
+	cnt = win->dm->vsync_cnt;
+	ret = wait_event_interruptible_timeout(win->dm->vsync_wait,
+					       cnt != win->dm->vsync_cnt,
+					       win->dm->timeout);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void davincifb_vsync_callback(unsigned event, void *arg)
+{
+	struct vpbe_dm_info *dm = (struct vpbe_dm_info *)arg;
+
+	++dm->vsync_cnt;
+	wake_up_interruptible(&dm->vsync_wait);
+}
+
+/*
+ * FBIO_SETATTRIBUTE handler
+ *
+ * This ioctl is deprecated.  The user can write the attribute values directly
+ * to the OSD1 framebuffer.
+ *
+ * Set a uniform attribute value over a rectangular area on the attribute
+ * window. The attribute value (0 to 15) is passed through the fb_fillrect's
+ * color parameter.  r->dx and r->width must both be even.  If not, they are
+ * rounded down.
+ */
+static int vpbe_set_attr_blend(struct fb_info *info, struct fb_fillrect *r)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	char __iomem *start;
+	u8 blend;
+	u32 width_bytes;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	if (!is_attribute_mode(var))
+		return -EINVAL;
+
+	if (r->dx + r->width > var->xres_virtual)
+		return -EINVAL;
+	if (r->dy + r->height > var->yres_virtual)
+		return -EINVAL;
+	if (r->color > 15)
+		return -EINVAL;
+
+	width_bytes = (r->width * var->bits_per_pixel) / 8;
+	start =
+	    info->screen_base + r->dy * info->fix.line_length +
+	    (r->dx * var->bits_per_pixel) / 8;
+
+	blend = (((u8) r->color & 0xf) << 4) | ((u8) r->color);
+	while (r->height--) {
+		memset(start, blend, width_bytes);
+		start += info->fix.line_length;
+	}
+
+	return 0;
+}
+
+/*
+ * FBIO_SETPOSX handler
+ */
+static int vpbe_setposx(struct fb_info *info, unsigned xpos)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_xpos = win->xpos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->xpos = xpos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->xpos = old_xpos;
+		return retval;
+	}
+
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
+}
+
+/*
+ * FBIO_SETPOSY handler
+ */
+static int vpbe_setposy(struct fb_info *info, unsigned ypos)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_ypos = win->ypos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->ypos = ypos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->ypos = old_ypos;
+		return retval;
+	}
+
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
+}
+
+/*
+ * FBIO_SETZOOM handler
+ */
+static int vpbe_set_zoom(struct fb_info *info, struct zoom_params *zoom)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_zoom_factor h_zoom, v_zoom;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	switch (zoom->zoom_h) {
+	case 0:
+		h_zoom = ZOOM_X1;
+		break;
+	case 1:
+		h_zoom = ZOOM_X2;
+		break;
+	case 2:
+		h_zoom = ZOOM_X4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (zoom->zoom_v) {
+	case 0:
+		v_zoom = ZOOM_X1;
+		break;
+	case 1:
+		v_zoom = ZOOM_X2;
+		break;
+	case 2:
+		v_zoom = ZOOM_X4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	davinci_disp_set_zoom(win->layer, h_zoom, v_zoom);
+
+	return 0;
+}
+
+/*
+ * FBIO_ENABLE_DISABLE_WIN handler
+ *
+ * This ioctl is deprecated.  Use the standard FBIOBLANK ioctl instead.
+ */
+static int vpbe_enable_disable_win(struct fb_info *info, int enable)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	int retval = 0;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (enable) {
+		win->display_window = 1;
+		retval = info->fbops->fb_check_var(&info->var, info);
+		if (retval)
+			return retval;
+		retval = info->fbops->fb_set_par(info);
+	} else {
+		win->display_window = 0;
+		davinci_disp_disable_layer(win->layer);
+	}
+
+	return retval;
+}
+
+/*
+ * FBIO_SET_BITMAP_BLEND_FACTOR handler
+ */
+static int vpbe_bitmap_set_blend_factor(struct fb_info *info, struct vpbe_bitmap_blend_params
+					*blend_para)
+{
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	if (blend_para->bf > OSD_8_VID_0)
+		return -EINVAL;
+
+	davinci_disp_set_blending_factor(osdwin, blend_para->bf);
+	if (blend_para->enable_colorkeying)
+		davinci_disp_enable_color_key(osdwin, blend_para->colorkey);
+	else
+		davinci_disp_disable_color_key(osdwin);
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_BITMAP_WIN_RAM_CLUT handler
+ *
+ * This ioctl is deprecated.  Use the standard framebuffer ioctl FBIOPUTCMAP
+ * instead.  Note that FBIOPUTCMAP colors are expressed in RGB space instead of
+ * YCbCr space.
+ */
+static int vpbe_bitmap_set_ram_clut(struct fb_info *info,
+				    unsigned char ram_clut[256][3])
+{
+	int i;
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	for (i = 0; i < 256; i++) {
+		davinci_disp_set_clut_ycbcr(i, ram_clut[i][0], ram_clut[i][1],
+					    ram_clut[i][2]);
+	}
+	return 0;
+}
+
+/*
+ * FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN handler
+ *
+ * This ioctl is deprecated.  Attribute mode can be enabled via the standard
+ * framebuffer ioctl FBIOPUT_VSCREENINFO by setting var->bits_per_pixel to 4
+ * and var->nonstd to a non-zero value.  Attribute mode can be disabled by using
+ * FBIOPUT_VSCREENINFO to set a standard pixel format.
+ *
+ * The enabled/disabled status of OSD1 is unchanged by this ioctl.  To avoid
+ * display glitches, you should disable OSD1 prior to calling this ioctl.
+ *
+ * When enabling attribute mode, var->bits_per_pixel is set to 4.  var->xres,
+ * var->yres, var->xres_virtual, var->yres_virtual, win->xpos, and win->ypos are
+ * all copied from OSD0.  var->xoffset and var->yoffset are set to 0.
+ * fix->line_length is updated to be consistent with 4 bits per pixel.  No
+ * changes are made to the OSD1 configuration if OSD1 is already in attribute
+ * mode.
+ *
+ * When disabling attribute mode, the window geometry is unchanged.
+ * var->bits_per_pixel remains set to 4.  No changes are made to the OSD1
+ * configuration if OSD1 is not in attribute mode.
+ */
+static int vpbe_enable_disable_attribute_window(struct fb_info *info, u32 flag)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	struct davinci_layer_config lconfig;
+	int retval;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	/* return with no error if there is nothing to do */
+	if ((is_attribute_mode(var) && flag)
+	    || (!is_attribute_mode(var) && !flag))
+		return 0;
+
+	/* start with the current OSD1 var */
+	memcpy(&v, var, sizeof(v));
+
+	if (flag) {		/* enable attribute mode */
+		const struct vpbe_dm_win_info *osd0 = &win->dm->win[WIN_OSD0];
+		const struct fb_var_screeninfo *osd0_var = &osd0->info->var;
+		unsigned old_xpos = win->xpos;
+		unsigned old_ypos = win->ypos;
+
+		/* get the OSD0 window configuration */
+		convert_fb_var_to_osd(osd0_var, &lconfig, win->dm->yc_pixfmt);
+		/* change the pixfmt to attribute mode */
+		lconfig.pixfmt = PIXFMT_OSD_ATTR;
+		/* update the var for OSD1 */
+		convert_osd_to_fb_var(&lconfig, &v);
+		/* copy xres_virtual and yres_virtual from OSD0 */
+		v.xres_virtual = osd0_var->xres_virtual;
+		v.yres_virtual = osd0_var->yres_virtual;
+		/* zero xoffset and yoffset */
+		v.xoffset = 0;
+		v.yoffset = 0;
+		/* copy xpos and ypos from OSD0 */
+		win->xpos = osd0->xpos;
+		win->ypos = osd0->ypos;
+
+		retval = info->fbops->fb_check_var(&v, info);
+		if (retval) {
+			win->xpos = old_xpos;
+			win->ypos = old_ypos;
+			return retval;
+		}
+
+		/*
+		 * Enable attribute mode by replacing info->var and calling
+		 * the fb_set_par method to activate it.
+		 */
+		memcpy(var, &v, sizeof(v));
+		retval = info->fbops->fb_set_par(info);
+	} else {		/* disable attribute mode */
+		/* get the current OSD1 window configuration */
+		convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
+		/* change the pixfmt to 4-bits-per-pixel bitmap */
+		lconfig.pixfmt = PIXFMT_4BPP;
+		/* update the var for OSD1 */
+		convert_osd_to_fb_var(&lconfig, &v);
+
+		retval = info->fbops->fb_check_var(&v, info);
+		if (retval)
+			return retval;
+
+		/*
+		 * Disable attribute mode by replacing info->var and calling
+		 * the fb_set_par method to activate it.
+		 */
+		memcpy(var, &v, sizeof(v));
+		retval = info->fbops->fb_set_par(info);
+	}
+
+	return retval;
+}
+
+/*
+ * FBIO_GET_BLINK_INTERVAL handler
+ */
+static int vpbe_get_blinking(struct fb_info *info,
+			     struct vpbe_blink_option *blink_option)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_blink_interval blink;
+	int enabled;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	davinci_disp_get_blink_attribute(&enabled, &blink);
+	blink_option->blinking = enabled;
+	blink_option->interval = blink;
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_BLINK_INTERVAL handler
+ */
+static int vpbe_set_blinking(struct fb_info *info,
+			     struct vpbe_blink_option *blink_option)
+{
+	struct vpbe_dm_win_info *win = info->par;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	if (blink_option->interval > BLINK_X4)
+		return -EINVAL;
+
+	davinci_disp_set_blink_attribute(blink_option->blinking,
+					 blink_option->interval);
+
+	return 0;
+}
+
+/*
+ * FBIO_GET_VIDEO_CONFIG_PARAMS handler
+ *
+ * Despite the name, this ioctl can be used on both video windows and OSD
+ * (bitmap) windows.
+ */
+static int vpbe_get_vid_params(struct fb_info *info,
+			       struct vpbe_video_config_params *vid_conf_params)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (is_vid_win(info))
+		davinci_disp_get_vid_expansion(&h_exp, &v_exp);
+	else
+		davinci_disp_get_osd_expansion(&h_exp, &v_exp);
+
+	vid_conf_params->cb_cr_order =
+	    (win->dm->yc_pixfmt == PIXFMT_YCbCrI) ? 0 : 1;
+	vid_conf_params->exp_info.horizontal = h_exp;
+	vid_conf_params->exp_info.vertical = v_exp;
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_VIDEO_CONFIG_PARAMS handler
+ *
+ * Despite the name, this ioctl can be used on both video windows and OSD
+ * (bitmap) windows.
+ *
+ * NOTE: If the cb_cr_order is changed, it won't take effect until an
+ * FBIOPUT_VSCREENINFO ioctl is executed on a window with a YC pixel format.
+ */
+static int vpbe_set_vid_params(struct fb_info *info,
+			       struct vpbe_video_config_params *vid_conf_params)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (vid_conf_params->exp_info.horizontal > H_EXP_3_OVER_2)
+		return -EINVAL;
+
+	if (vid_conf_params->exp_info.vertical > V_EXP_6_OVER_5)
+		return -EINVAL;
+
+	win->dm->yc_pixfmt =
+	    vid_conf_params->cb_cr_order ? PIXFMT_YCrCbI : PIXFMT_YCbCrI;
+
+	h_exp = vid_conf_params->exp_info.horizontal;
+	v_exp = vid_conf_params->exp_info.vertical;
+	if (is_vid_win(info))
+		davinci_disp_set_vid_expansion(h_exp, v_exp);
+	else
+		davinci_disp_set_osd_expansion(h_exp, v_exp);
+
+	return 0;
+}
+
+/*
+ * FBIO_GET_BITMAP_CONFIG_PARAMS handler
+ */
+static int vpbe_bitmap_get_params(struct fb_info *info, struct vpbe_bitmap_config_params
+				  *bitmap_conf_params)
+{
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+	enum davinci_clut clut;
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	clut = davinci_disp_get_osd_clut(osdwin);
+	if (clut == ROM_CLUT)
+		bitmap_conf_params->clut_select = davinci_disp_get_rom_clut();
+	else
+		bitmap_conf_params->clut_select = 2;
+
+	bitmap_conf_params->attenuation_enable =
+	    davinci_disp_get_rec601_attenuation(osdwin);
+
+	memset(&bitmap_conf_params->clut_idx, 0,
+	       sizeof(bitmap_conf_params->clut_idx));
+
+	switch (info->var.bits_per_pixel) {
+	case 1:
+		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
+		break;
+	case 2:
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_2 =
+		    davinci_disp_get_palette_map(osdwin, 2);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_3 =
+		    davinci_disp_get_palette_map(osdwin, 3);
+		break;
+	case 4:
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_2 =
+		    davinci_disp_get_palette_map(osdwin, 2);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_3 =
+		    davinci_disp_get_palette_map(osdwin, 3);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_4 =
+		    davinci_disp_get_palette_map(osdwin, 4);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_5 =
+		    davinci_disp_get_palette_map(osdwin, 5);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_6 =
+		    davinci_disp_get_palette_map(osdwin, 6);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_7 =
+		    davinci_disp_get_palette_map(osdwin, 7);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_8 =
+		    davinci_disp_get_palette_map(osdwin, 8);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_9 =
+		    davinci_disp_get_palette_map(osdwin, 9);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_10 =
+		    davinci_disp_get_palette_map(osdwin, 10);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_11 =
+		    davinci_disp_get_palette_map(osdwin, 11);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_12 =
+		    davinci_disp_get_palette_map(osdwin, 12);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_13 =
+		    davinci_disp_get_palette_map(osdwin, 13);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_14 =
+		    davinci_disp_get_palette_map(osdwin, 14);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_15 =
+		    davinci_disp_get_palette_map(osdwin, 15);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_BITMAP_CONFIG_PARAMS handler
+ *
+ * The palette map is ignored unless the color depth is set to 1, 2, or 4 bits
+ * per pixel.  A default palette map is supplied for these color depths where
+ * the clut index is equal to the pixel value.  It is not necessary to change
+ * the default palette map when using the RAM clut, because the RAM clut values
+ * can be changed.  It is only necessary to modify the default palette map when
+ * using a ROM clut.
+ */
+static int vpbe_bitmap_set_params(struct fb_info *info, struct vpbe_bitmap_config_params
+				  *bitmap_conf_params)
+{
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+	enum davinci_clut clut = ROM_CLUT;
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	if (bitmap_conf_params->clut_select == 0)
+		davinci_disp_set_rom_clut(ROM_CLUT0);
+	else if (bitmap_conf_params->clut_select == 1)
+		davinci_disp_set_rom_clut(ROM_CLUT1);
+	else if (bitmap_conf_params->clut_select == 2)
+		clut = RAM_CLUT;
+	else
+		return -EINVAL;
+
+	davinci_disp_set_osd_clut(osdwin, clut);
+	davinci_disp_set_rec601_attenuation(osdwin,
+					    bitmap_conf_params->
+					    attenuation_enable);
+
+	switch (info->var.bits_per_pixel) {
+	case 1:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_1bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_1bit_bitmap.bitmap_val_1);
+		break;
+	case 2:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_1);
+		davinci_disp_set_palette_map(osdwin, 2,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_2);
+		davinci_disp_set_palette_map(osdwin, 3,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_3);
+		break;
+	case 4:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_1);
+		davinci_disp_set_palette_map(osdwin, 2,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_2);
+		davinci_disp_set_palette_map(osdwin, 3,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_3);
+		davinci_disp_set_palette_map(osdwin, 4,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_4);
+		davinci_disp_set_palette_map(osdwin, 5,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_5);
+		davinci_disp_set_palette_map(osdwin, 6,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_6);
+		davinci_disp_set_palette_map(osdwin, 7,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_7);
+		davinci_disp_set_palette_map(osdwin, 8,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_8);
+		davinci_disp_set_palette_map(osdwin, 9,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_9);
+		davinci_disp_set_palette_map(osdwin, 10,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_10);
+		davinci_disp_set_palette_map(osdwin, 11,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_11);
+		davinci_disp_set_palette_map(osdwin, 12,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_12);
+		davinci_disp_set_palette_map(osdwin, 13,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_13);
+		davinci_disp_set_palette_map(osdwin, 14,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_14);
+		davinci_disp_set_palette_map(osdwin, 15,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_15);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_BACKG_COLOR handler
+ */
+static int vpbe_set_backg_color(struct fb_info *info,
+				struct vpbe_backg_color *backg_color)
+{
+	enum davinci_clut clut = ROM_CLUT;
+
+	if (backg_color->clut_select == 0)
+		davinci_disp_set_rom_clut(ROM_CLUT0);
+	else if (backg_color->clut_select == 1)
+		davinci_disp_set_rom_clut(ROM_CLUT1);
+	else if (backg_color->clut_select == 2)
+		clut = RAM_CLUT;
+	else
+		return -EINVAL;
+
+	davinci_disp_set_background(clut, backg_color->color_offset);
+
+	return 0;
+}
+
+/*
+ * FBIO_SETPOS handler
+ */
+static int vpbe_setpos(struct fb_info *info,
+		       struct vpbe_window_position *win_pos)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_xpos = win->xpos;
+	unsigned old_ypos = win->ypos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->xpos = win_pos->xpos;
+	win->ypos = win_pos->ypos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->xpos = old_xpos;
+		win->ypos = old_ypos;
+		return retval;
+	}
+
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
+}
+
+/*
+ * FBIO_SET_CURSOR handler
+ */
+static int vpbe_set_cursor_params(struct fb_info *info,
+				  struct fb_cursor *fbcursor)
+{
+	struct davinci_cursor_config cursor;
+
+	if (!fbcursor->enable) {
+		davinci_disp_cursor_disable();
+		return 0;
+	}
+
+	cursor.xsize = fbcursor->image.width;
+	cursor.ysize = fbcursor->image.height;
+	cursor.xpos = fbcursor->image.dx;
+	cursor.ypos = fbcursor->image.dy;
+	cursor.interlaced = is_window_interlaced(&info->var);
+	cursor.h_width =
+	    (fbcursor->image.depth > 7) ? 7 : fbcursor->image.depth;
+	cursor.v_width = cursor.h_width;
+	cursor.clut = ROM_CLUT;
+	cursor.clut_index = fbcursor->image.fg_color;
+
+	davinci_disp_set_cursor_config(&cursor);
+
+	davinci_disp_cursor_enable();
+
+	return 0;
+}
+
+/*
+ * fb_ioctl method
+ */
+static int
+davincifb_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg, struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	void __user *argp = (void __user *)arg;
+	struct fb_fillrect rect;
+	struct zoom_params zoom;
+	int retval = 0;
+	struct vpbe_bitmap_blend_params blend_para;
+	struct vpbe_blink_option blink_option;
+	struct vpbe_video_config_params vid_conf_params;
+	struct vpbe_bitmap_config_params bitmap_conf_params;
+	struct vpbe_backg_color backg_color;
+	struct vpbe_window_position win_pos;
+	struct fb_cursor cursor;
+
+	switch (cmd) {
+	case FBIO_WAITFORVSYNC:
+		/* This ioctl accepts an integer argument to specify a
+		 * display.  We only support one display, so we will
+		 * simply ignore the argument.
+		 */
+		return davincifb_wait_for_vsync(info);
+
+	case FBIO_SETATTRIBUTE:
+		if (copy_from_user(&rect, argp, sizeof(rect)))
+			return -EFAULT;
+		return vpbe_set_attr_blend(info, &rect);
+
+	case FBIO_SETPOSX:
+		return vpbe_setposx(info, arg);
+
+	case FBIO_SETPOSY:
+		return vpbe_setposy(info, arg);
+
+	case FBIO_SETZOOM:
+		if (copy_from_user(&zoom, argp, sizeof(zoom)))
+			return -EFAULT;
+		return vpbe_set_zoom(info, &zoom);
+
+	case FBIO_ENABLE_DISABLE_WIN:
+		return vpbe_enable_disable_win(info, arg);
+
+	case FBIO_SET_BITMAP_BLEND_FACTOR:
+		if (copy_from_user(&blend_para, argp, sizeof(blend_para)))
+			return -EFAULT;
+		return vpbe_bitmap_set_blend_factor(info, &blend_para);
+
+	case FBIO_SET_BITMAP_WIN_RAM_CLUT:
+		if (copy_from_user(win->dm->ram_clut[0], argp, RAM_CLUT_SIZE))
+			return -EFAULT;
+		return vpbe_bitmap_set_ram_clut(info, win->dm->ram_clut);
+
+	case FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN:
+		return vpbe_enable_disable_attribute_window(info, arg);
+
+	case FBIO_GET_BLINK_INTERVAL:
+		if ((retval = vpbe_get_blinking(info, &blink_option)) < 0)
+			return retval;
+		if (copy_to_user(argp, &blink_option, sizeof(blink_option)))
+			return -EFAULT;
+		return 0;
+
+	case FBIO_SET_BLINK_INTERVAL:
+		if (copy_from_user(&blink_option, argp, sizeof(blink_option)))
+			return -EFAULT;
+		return vpbe_set_blinking(info, &blink_option);
+
+	case FBIO_GET_VIDEO_CONFIG_PARAMS:
+		if ((retval = vpbe_get_vid_params(info, &vid_conf_params)) < 0)
+			return retval;
+		if (copy_to_user
+		    (argp, &vid_conf_params, sizeof(vid_conf_params)))
+			return -EFAULT;
+		return 0;
+
+	case FBIO_SET_VIDEO_CONFIG_PARAMS:
+		if (copy_from_user
+		    (&vid_conf_params, argp, sizeof(vid_conf_params)))
+			return -EFAULT;
+		return vpbe_set_vid_params(info, &vid_conf_params);
+
+	case FBIO_GET_BITMAP_CONFIG_PARAMS:
+		if ((retval =
+		     vpbe_bitmap_get_params(info, &bitmap_conf_params)) < 0)
+			return retval;
+		if (copy_to_user
+		    (argp, &bitmap_conf_params, sizeof(bitmap_conf_params)))
+			return -EFAULT;
+		return 0;
+
+	case FBIO_SET_BITMAP_CONFIG_PARAMS:
+		if (copy_from_user
+		    (&bitmap_conf_params, argp, sizeof(bitmap_conf_params)))
+			return -EFAULT;
+		return vpbe_bitmap_set_params(info, &bitmap_conf_params);
+
+	case FBIO_SET_BACKG_COLOR:
+		if (copy_from_user(&backg_color, argp, sizeof(backg_color)))
+			return -EFAULT;
+		return vpbe_set_backg_color(info, &backg_color);
+
+	case FBIO_SETPOS:
+		if (copy_from_user(&win_pos, argp, sizeof(win_pos)))
+			return -EFAULT;
+		return vpbe_setpos(info, &win_pos);
+
+	case FBIO_SET_CURSOR:
+		if (copy_from_user(&cursor, argp, sizeof(cursor)))
+			return -EFAULT;
+		return vpbe_set_cursor_params(info, &cursor);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * fb_check_var method
+ */
+static int
+davincifb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_videomode *mode = &win->dm->mode;
+	struct davinci_layer_config lconfig;
+	struct fb_fix_screeninfo fix;
+
+	/*
+	 * Get an updated copy of the video mode from the encoder manager, just
+	 * in case the display has been switched.
+	 */
+	get_video_mode(mode);
+
+	/*
+	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
+	 * a special case.  It indicates that the window should be disabled.  If
+	 * the window is a video window, it will also be released.
+	 */
+	if (var->xres == 0 || var->yres == 0 || var->xres_virtual == 0
+	    || var->yres_virtual == 0) {
+		var->xres = 0;
+		var->yres = 0;
+		var->xres_virtual = 0;
+		var->yres_virtual = 0;
+		return 0;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 16:
+		break;
+	case 24:
+		if (cpu_is_davinci_dm355())
+			return -EINVAL;
+		break;
+	case 32:
+		if (cpu_is_davinci_dm644x())
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (var->xres_virtual < var->xres || var->yres_virtual < var->yres)
+		return -EINVAL;
+	if (var->xoffset > var->xres_virtual - var->xres)
+		return -EINVAL;
+	if (var->yoffset > var->yres_virtual - var->yres)
+		return -EINVAL;
+	if (mode->xres < var->xres || mode->yres < var->yres)
+		return -EINVAL;
+	if (win->xpos > mode->xres - var->xres)
+		return -EINVAL;
+	if (win->ypos > mode->yres - var->yres)
+		return -EINVAL;
+
+	convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
+	update_fix_info(var, &fix);
+	lconfig.line_length = fix.line_length;
+	lconfig.xpos = win->xpos;
+	lconfig.ypos = win->ypos;
+
+	/* xoffset must be a multiple of xpanstep */
+	if (var->xoffset & ~(fix.xpanstep - 1))
+		return -EINVAL;
+
+	/* check if we have enough video memory to support this mode */
+	if (!window_will_fit_framebuffer(var, info->fix.smem_len))
+		return -EINVAL;
+
+	/* see if the OSD manager approves of this configuration */
+	if (davinci_disp_try_layer_config(win->layer, &lconfig))
+		return -EINVAL;
+
+	/*
+	 * Reject this var if the OSD manager would have to modify the window
+	 * geometry to make it work.
+	 */
+	if (lconfig.xsize != var->xres || lconfig.ysize != var->yres)
+		return -EINVAL;
+	if (lconfig.xpos != win->xpos || lconfig.ypos != win->ypos)
+		return -EINVAL;
+
+	/*
+	 * At this point we have accepted the var, so now we convert our layer
+	 * configuration struct back to the var in order to make all of the
+	 * pixel format and geometry values consistent.  The var timing values
+	 * will be unmodified, as we have no way to verify them.
+	 */
+	convert_osd_to_fb_var(&lconfig, var);
+
+	return 0;
+}
+
+/*
+ * fb_set_par method
+ */
+static int davincifb_set_par(struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct davinci_layer_config lconfig;
+	struct fb_videomode mode;
+	unsigned start;
+
+	/* update the fix info to be consistent with the var */
+	update_fix_info(var, &info->fix);
+	convert_fb_info_to_osd(info, &lconfig);
+
+	/* See if we need to pass the timing values to the encoder manager. */
+	memcpy(&mode, &win->dm->mode, sizeof(mode));
+	fb_var_to_videomode(&mode, var);
+	mode.name = win->dm->mode.name;
+	if (mode.xres == win->dm->mode.xres && mode.yres == win->dm->mode.yres
+	    && mode.pixclock != 0) {
+		/*
+		 * If the timing parameters from the var are different than the
+		 * timing parameters from the encoder, try to update the
+		 * timing parameters with the encoder manager.
+		 */
+		if (!fb_mode_is_equal(&mode, &win->dm->mode))
+			set_video_mode(&mode);
+	}
+	/* update our copy of the encoder video mode */
+	get_video_mode(&win->dm->mode);
+	/*
+	 * Update the var with the encoder timing info.  The window geometry
+	 * will be preserved.
+	 */
+	construct_fb_var(var, &win->dm->mode, &lconfig);
+
+	/*
+	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
+	 * a special case.  It indicates that the window should be disabled.  If
+	 * the window is a video window, it will also be released.
+	 * Note that we disable the window, but we do not set the
+	 * win->disable_window flag.  This allows the window to be re-enabled
+	 * simply by using the FBIOPUT_VSCREENINFO ioctl to set a valid
+	 * configuration.
+	 */
+	if (lconfig.xsize == 0 || lconfig.ysize == 0) {
+		if (win->own_window) {
+			davinci_disp_disable_layer(win->layer);
+			if (is_vid_win(info)) {
+				win->own_window = 0;
+				davinci_disp_release_layer(win->layer);
+			}
+		}
+		return 0;
+	}
+
+	/*
+	 * If we don't currently own this window, we must claim it from the OSD
+	 * manager.
+	 */
+	if (!win->own_window) {
+		if (davinci_disp_request_layer(win->layer))
+			return -ENODEV;
+		win->own_window = 1;
+	}
+
+	start =
+	    info->fix.smem_start + (var->xoffset * var->bits_per_pixel) / 8 +
+	    var->yoffset * info->fix.line_length;
+	davinci_disp_set_layer_config(win->layer, &lconfig);
+	davinci_disp_start_layer(win->layer, start);
+	if (win->display_window)
+		davinci_disp_enable_layer(win->layer);
+
+	return 0;
+}
+
+/*
+ * This macro converts a 16-bit color passed to fb_setcolreg to the width
+ * supported by the pixel format.
+ */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+
+/*
+ * fb_setcolreg method
+ */
+static int davincifb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			       unsigned blue, unsigned transp,
+			       struct fb_info *info)
+{
+	unsigned r, g, b, t;
+
+	if (regno >= 256)	/* no. of hw registers */
+		return -EINVAL;
+
+	/*
+	 * An RGB color palette isn't applicable to a window with a YUV pixel
+	 * format or to a window in attribute mode.
+	 */
+	if (is_yuv(&info->var) || is_attribute_mode(&info->var))
+		return -EINVAL;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		r = CNVT_TOHW(red, info->var.red.length);
+		g = CNVT_TOHW(green, info->var.green.length);
+		b = CNVT_TOHW(blue, info->var.blue.length);
+		t = CNVT_TOHW(transp, info->var.transp.length);
+		break;
+	case FB_VISUAL_PSEUDOCOLOR:
+	default:
+		r = CNVT_TOHW(red, 8);
+		g = CNVT_TOHW(green, 8);
+		b = CNVT_TOHW(blue, 8);
+		t = 0;
+		break;
+	}
+
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+		u32 v;
+
+		if (regno >= 16)
+			return -EINVAL;
+
+		v = (r << info->var.red.offset) |
+		    (g << info->var.green.offset) |
+		    (b << info->var.blue.offset) |
+		    (t << info->var.transp.offset);
+
+		switch (info->var.bits_per_pixel) {
+		case 16:
+			((u16 *) (info->pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:
+			((u32 *) (info->pseudo_palette))[regno] = v;
+			break;
+		}
+		return 0;
+	}
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	davinci_disp_set_clut_rgb(regno, r, g, b);
+
+	return 0;
+}
+
+/*
+ * fb_pan_display method
+ *
+ * Pan the display using the `xoffset' and `yoffset' fields of the `var'
+ * structure.  We don't support wrapping and ignore the FB_VMODE_YWRAP flag.
+ */
+static int
+davincifb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	unsigned start;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (var->xoffset > info->var.xres_virtual - info->var.xres)
+		return -EINVAL;
+	if (var->yoffset > info->var.yres_virtual - info->var.yres)
+		return -EINVAL;
+
+	/* xoffset must be a multiple of xpanstep */
+	if (var->xoffset & ~(info->fix.xpanstep - 1))
+		return -EINVAL;
+
+	start =
+	    info->fix.smem_start +
+	    (var->xoffset * info->var.bits_per_pixel) / 8 +
+	    var->yoffset * info->fix.line_length;
+	davinci_disp_start_layer(win->layer, start);
+
+	return 0;
+}
+
+/*
+ * fb_blank method
+ *
+ * Blank the screen if blank_mode != 0, else unblank.
+ */
+int davincifb_blank(int blank_mode, struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	int retval = 0;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (!blank_mode) {
+		win->display_window = 1;
+		retval = info->fbops->fb_check_var(&info->var, info);
+		if (retval)
+			return retval;
+		retval = info->fbops->fb_set_par(info);
+	} else {
+		win->display_window = 0;
+		davinci_disp_disable_layer(win->layer);
+	}
+
+	return retval;
+}
+
+/*
+ *  Frame buffer operations
+ */
+static struct fb_ops davincifb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = davincifb_check_var,
+	.fb_set_par = davincifb_set_par,
+	.fb_setcolreg = davincifb_setcolreg,
+	.fb_blank = davincifb_blank,
+	.fb_pan_display = davincifb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = soft_cursor,
+	.fb_rotate = NULL,
+	.fb_sync = NULL,
+	.fb_ioctl = davincifb_ioctl,
+};
+
+static void davincifb_release_window(struct device *dev,
+				     struct vpbe_dm_win_info *win)
+{
+	struct fb_info *info = win->info;
+
+	if (info) {
+		unregister_framebuffer(info);
+		win->info = NULL;
+	}
+
+	if (win->own_window) {
+		davinci_disp_release_layer(win->layer);
+		win->own_window = 0;
+	}
+	win->display_window = 0;
+
+	if (info) {
+		dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+				  info->fix.smem_start);
+		fb_dealloc_cmap(&info->cmap);
+		kfree(info);
+	}
+}
+
+static int davincifb_init_window(struct device *dev,
+				 struct vpbe_dm_win_info *win,
+				 struct davinci_layer_config *lconfig,
+				 unsigned fb_size, const char *name)
+{
+	struct fb_info *info;
+	int err;
+
+	if (!fb_size)
+		return 0;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(dev, "%s: Can't allocate memory for fb_info struct.\n",
+			name);
+		return -ENOMEM;
+	}
+	win->info = info;
+
+	/* initialize fb_info */
+	info->par = win;
+	info->flags =
+	    FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |
+	    FBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_XPAN |
+	    FBINFO_HWACCEL_YPAN;
+	info->fbops = &davincifb_ops;
+	info->screen_size = fb_size;
+	info->pseudo_palette = win->pseudo_palette;
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		dev_err(dev, "%s: Can't allocate color map.\n", name);
+		err = -ENODEV;
+		goto cmap_out;
+	}
+
+	/* initialize fb_fix_screeninfo */
+	strlcpy(info->fix.id, name, sizeof(info->fix.id));
+	info->fix.smem_len = fb_size;
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+
+	/* allocate the framebuffer */
+	info->screen_base =
+	    dma_alloc_coherent(dev, info->fix.smem_len,
+			       (dma_addr_t *) & info->fix.smem_start,
+			       GFP_KERNEL | GFP_DMA);
+	if (!info->screen_base) {
+		dev_err(dev, "%s: dma_alloc_coherent failed when allocating "
+			"framebuffer.\n", name);
+		err = -ENOMEM;
+		goto fb_alloc_out;
+	}
+
+	/*
+	 * Fill the framebuffer with zeros unless it is an OSD1 window in
+	 * attribute mode, in which case we fill it with 0x77 to make the OSD0
+	 * pixels opaque.
+	 */
+	memset(info->screen_base,
+	       (lconfig->pixfmt == PIXFMT_OSD_ATTR) ? 0x77 : 0,
+	       info->fix.smem_len);
+
+	/* initialize fb_var_screeninfo */
+	construct_fb_var(&info->var, &win->dm->mode, lconfig);
+	win->xpos = lconfig->xpos;
+	win->ypos = lconfig->ypos;
+	info->var.xres_virtual = info->var.xres;
+	info->var.yres_virtual = info->var.yres;
+
+	/* update the fix info to be consistent with the var */
+	update_fix_info(&info->var, &info->fix);
+
+	/*
+	 * Request ownership of the window from the OSD manager unless this is
+	 * a video window and the window size is 0.
+	 */
+	if (is_osd_win(info) || (info->var.xres != 0 && info->var.yres != 0)) {
+		if (!davinci_disp_request_layer(win->layer))
+			win->own_window = 1;
+	}
+	/* bail out if this is an OSD window and we don't own it */
+	if (is_osd_win(info) && !win->own_window) {
+		dev_err(dev, "%s: Failed to obtain ownership of OSD "
+			"window.\n", name);
+		err = -ENODEV;
+		goto own_out;
+	}
+
+	win->display_window = 1;
+
+	if (win->own_window) {
+		/* check if our initial window configuration is valid */
+		if (info->fbops->fb_check_var(&info->var, info)) {
+			dev_warn(dev, "%s: Initial window configuration is "
+				 "invalid.\n", name);
+		} else
+			info->fbops->fb_set_par(info);
+	}
+
+	/* register the framebuffer */
+	if (register_framebuffer(info)) {
+		dev_err(dev, "%s: Failed to register framebuffer.\n", name);
+		err = -ENODEV;
+		goto register_out;
+	}
+
+	dev_info(dev, "%s: %dx%dx%d@%d,%d with framebuffer size %dKB\n",
+		 info->fix.id, info->var.xres, info->var.yres,
+		 info->var.bits_per_pixel, win->xpos, win->ypos,
+		 info->fix.smem_len >> 10);
+
+	return 0;
+
+      register_out:
+	if (win->own_window)
+		davinci_disp_release_layer(win->layer);
+	win->own_window = 0;
+      own_out:
+	dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+			  info->fix.smem_start);
+      fb_alloc_out:
+	fb_dealloc_cmap(&info->cmap);
+      cmap_out:
+	kfree(info);
+
+	return err;
+}
+
+static int davincifb_remove(struct device *dev)
+{
+	struct vpbe_dm_info *dm = dev_get_drvdata(dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	davinci_disp_unregister_callback(&dm->vsync_callback);
+
+	davincifb_release_window(dev, &dm->win[WIN_VID1]);
+	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
+	davincifb_release_window(dev, &dm->win[WIN_VID0]);
+	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
+
+	kfree(dm);
+
+	return 0;
+}
+
+/*
+ * Return the maximum number of bytes per screen for a display layer at a
+ * resolution specified by an fb_videomode struct.
+ */
+static unsigned davincifb_max_screen_size(enum davinci_disp_layer layer,
+					  const struct fb_videomode *mode)
+{
+	unsigned max_bpp = 32;
+	unsigned line_length;
+	unsigned size;
+
+	switch (layer) {
+	case WIN_OSD0:
+	case WIN_OSD1:
+		if (cpu_is_davinci_dm355())
+			max_bpp = 32;
+		else
+			max_bpp = 16;
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		if (cpu_is_davinci_dm355())
+			max_bpp = 16;
+		else
+			max_bpp = 24;
+		break;
+	}
+
+	line_length = (mode->xres * max_bpp + 7) / 8;
+	line_length = ((line_length + 31) / 32) * 32;
+	size = mode->yres * line_length;
+
+	return size;
+}
+
+static void parse_win_params(struct vpbe_dm_win_info *win,
+			     struct davinci_layer_config *lconfig,
+			     unsigned *fb_size, char *opt)
+{
+	char *s, *p, c = 0;
+	unsigned bits_per_pixel;
+
+	if (!opt)
+		return;
+
+	/* xsize */
+	p = strpbrk(opt, "x,@");
+	if (p)
+		c = *p;
+	if ((s = strsep(&opt, "x,@")) == NULL)
+		return;
+	if (*s)
+		lconfig->xsize = simple_strtoul(s, NULL, 0);
+	if (!p || !opt)
+		return;
+
+	/* ysize */
+	if (c == 'x') {
+		p = strpbrk(opt, "x,@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, "x,@")) == NULL)
+			return;
+		if (*s)
+			lconfig->ysize = simple_strtoul(s, NULL, 0);
+		if (!p || !opt)
+			return;
+	}
+
+	/* bits per pixel */
+	if (c == 'x') {
+		p = strpbrk(opt, ",@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, ",@")) == NULL)
+			return;
+		if (*s) {
+			bits_per_pixel = simple_strtoul(s, NULL, 0);
+			switch (bits_per_pixel) {
+			case 1:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_1BPP;
+				break;
+			case 2:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_2BPP;
+				break;
+			case 4:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_4BPP;
+				break;
+			case 8:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_8BPP;
+				break;
+			case 16:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_RGB565;
+				else
+					lconfig->pixfmt = win->dm->yc_pixfmt;
+				break;
+			case 24:
+				if (cpu_is_davinci_dm644x()
+				    && (win->layer == WIN_VID0
+					|| win->layer == WIN_VID1))
+					lconfig->pixfmt = PIXFMT_RGB888;
+				break;
+			case 32:
+				if (cpu_is_davinci_dm355()
+				    && (win->layer == WIN_OSD0
+					|| win->layer == WIN_OSD1))
+					lconfig->pixfmt = PIXFMT_RGB888;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!p || !opt)
+			return;
+	}
+
+	/* framebuffer size */
+	if (c == ',') {
+		p = strpbrk(opt, "@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, "@")) == NULL)
+			return;
+		if (*s) {
+			*fb_size = simple_strtoul(s, &s, 0);
+			if (*s == 'K')
+				*fb_size <<= 10;
+			if (*s == 'M')
+				*fb_size <<= 20;
+		}
+		if (!p || !opt)
+			return;
+	}
+
+	/* xpos */
+	if (c == '@') {
+		p = strpbrk(opt, ",");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, ",")) == NULL)
+			return;
+		if (*s)
+			lconfig->xpos = simple_strtoul(s, NULL, 0);
+		if (!p || !opt)
+			return;
+	}
+
+	/* ypos */
+	if (c == ',') {
+		s = opt;
+		if (*s)
+			lconfig->ypos = simple_strtoul(s, NULL, 0);
+	}
+
+	return;
+}
+
+/*
+ * Pass boot-time options by adding the following string to the boot params:
+ *	video=davincifb:options
+ * Valid options:
+ *	osd0=[MxNxP,S@X,Y]
+ *      osd1=[MxNxP,S@X,Y]
+ *	vid0=[off|MxNxP,S@X,Y]
+ *	vid1=[off|MxNxP,S@X,Y]
+ *		MxN are the horizontal and vertical window size
+ *		P is the color depth (bits per pixel)
+ *		S is the framebuffer size with a size suffix such as 'K' or 'M'
+ *		X,Y are the window position
+ *
+ * Only video windows can be turned off.  Turning off a video window means that
+ * no framebuffer device will be registered for it,
+ *
+ * To cause a window to be supported by the framebuffer driver but not displayed
+ * initially, pass a value of 0 for the window size.
+ *
+ * For example:
+ *      video=davincifb:osd0=720x480x16@0,0:osd1=720x480:vid0=off:vid1=off
+ *
+ * This routine returns 1 if the window is to be turned off, or 0 otherwise.
+ */
+static int davincifb_get_default_win_config(struct device *dev,
+					    struct vpbe_dm_win_info *win,
+					    struct davinci_layer_config
+					    *lconfig, unsigned *fb_size,
+					    const char *options)
+{
+	const char *win_names[] = { "osd0=", "vid0=", "osd1=", "vid1=" };
+	const char *this_opt, *next_opt;
+	int this_len, opt_len;
+	static char opt_buf[128];
+
+	/* supply default values for lconfig and fb_size */
+	switch (win->layer) {
+	case WIN_OSD0:
+		lconfig->pixfmt = PIXFMT_RGB565;
+		lconfig->xsize = win->dm->mode.xres;
+		lconfig->ysize = win->dm->mode.yres;
+		break;
+	case WIN_OSD1:
+		lconfig->pixfmt = PIXFMT_OSD_ATTR;
+		lconfig->xsize = win->dm->mode.xres;
+		lconfig->ysize = win->dm->mode.yres;
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		lconfig->pixfmt = win->dm->yc_pixfmt;
+		lconfig->xsize = 0;
+		lconfig->ysize = 0;
+		break;
+	}
+	lconfig->xpos = 0;
+	lconfig->ypos = 0;
+	lconfig->interlaced = is_display_interlaced(&win->dm->mode);
+	*fb_size = davincifb_max_screen_size(win->layer, &win->dm->mode);
+
+	next_opt = options;
+	while ((this_opt = next_opt)) {
+		this_len = strcspn(this_opt, ":");
+		next_opt = strpbrk(this_opt, ":");
+		if (next_opt)
+			++next_opt;
+
+		opt_len = strlen(win_names[win->layer]);
+		if (this_len >= opt_len) {
+			if (strncmp(this_opt, win_names[win->layer], opt_len))
+				continue;
+			this_len -= opt_len;
+			this_opt += opt_len;
+			if ((this_len >= strlen("off"))
+			    && !strncmp(this_opt, "off", strlen("off")))
+				return 1;
+			else {
+				strlcpy(opt_buf, this_opt,
+					min_t(int, sizeof(opt_buf),
+					      this_len + 1));
+				parse_win_params(win, lconfig, fb_size,
+						 opt_buf);
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ *     Module parameter definitions
+ */
+static char *options = "";
+
+module_param(options, charp, S_IRUGO);
+
+static int davincifb_probe(struct device *dev)
+{
+	struct vpbe_dm_info *dm;
+	struct davinci_layer_config lconfig;
+	unsigned fb_size;
+	int err;
+
+	dm = kzalloc(sizeof(*dm), GFP_KERNEL);
+	if (!dm) {
+		dev_err(dev, "Can't allocate memory for driver state.\n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(dev, dm);
+
+	/* get the video mode from the encoder manager */
+	get_video_mode(&dm->mode);
+
+	/* set the default Cb/Cr order */
+	dm->yc_pixfmt = PIXFMT_YCbCrI;
+
+	/* initialize OSD0 */
+	dm->win[WIN_OSD0].layer = WIN_OSD0;
+	dm->win[WIN_OSD0].dm = dm;
+	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD0], &lconfig,
+					 &fb_size, options);
+	err =
+	    davincifb_init_window(dev, &dm->win[WIN_OSD0], &lconfig, fb_size,
+				  OSD0_FBNAME);
+	if (err)
+		goto osd0_out;
+
+	/* initialize VID0 */
+	dm->win[WIN_VID0].layer = WIN_VID0;
+	dm->win[WIN_VID0].dm = dm;
+	if (!davincifb_get_default_win_config
+	    (dev, &dm->win[WIN_VID0], &lconfig, &fb_size, options)) {
+		err =
+		    davincifb_init_window(dev, &dm->win[WIN_VID0], &lconfig,
+					  fb_size, VID0_FBNAME);
+		if (err)
+			goto vid0_out;
+	}
+
+	/* initialize OSD1 */
+	dm->win[WIN_OSD1].layer = WIN_OSD1;
+	dm->win[WIN_OSD1].dm = dm;
+	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD1], &lconfig,
+					 &fb_size, options);
+	err =
+	    davincifb_init_window(dev, &dm->win[WIN_OSD1], &lconfig, fb_size,
+				  OSD1_FBNAME);
+	if (err)
+		goto osd1_out;
+
+	/* initialize VID1 */
+	dm->win[WIN_VID1].layer = WIN_VID1;
+	dm->win[WIN_VID1].dm = dm;
+	if (!davincifb_get_default_win_config
+	    (dev, &dm->win[WIN_VID1], &lconfig, &fb_size, options)) {
+		err =
+		    davincifb_init_window(dev, &dm->win[WIN_VID1], &lconfig,
+					  fb_size, VID1_FBNAME);
+		if (err)
+			goto vid1_out;
+	}
+
+	/* initialize the vsync wait queue */
+	init_waitqueue_head(&dm->vsync_wait);
+	dm->timeout = HZ / 5;
+
+	/* register the end-of-frame callback */
+	dm->vsync_callback.mask = DAVINCI_DISP_END_OF_FRAME;
+	dm->vsync_callback.handler = davincifb_vsync_callback;
+	dm->vsync_callback.arg = dm;
+	davinci_disp_register_callback(&dm->vsync_callback);
+
+	return 0;
+
+      vid1_out:
+	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
+      osd1_out:
+	davincifb_release_window(dev, &dm->win[WIN_VID0]);
+      vid0_out:
+	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
+      osd0_out:
+	kfree(dm);
+
+	return err;
+}
+
+static void davincifb_release_dev(struct device *dev)
+{
+}
+
+static u64 davincifb_dmamask = ~(u32) 0;
+
+/* FIXME: move to board setup file */
+static struct platform_device davincifb_device = {
+	.name = DAVINCIFB_NAME,
+	.id = 0,
+	.dev = {
+		.release = davincifb_release_dev,
+		.dma_mask = &davincifb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.num_resources = 0,
+};
+
+static struct device_driver davincifb_driver = {
+	.name = DAVINCIFB_NAME,
+	.bus = &platform_bus_type,
+	.probe = davincifb_probe,
+	.remove = davincifb_remove,
+	.suspend = NULL,
+	.resume = NULL,
+};
+
+static int __init davincifb_init(void)
+{
+	struct device *dev = &davincifb_device.dev;
+
+#ifndef MODULE
+	{
+		char *names[] = { "davincifb", "dm64xxfb", "dm355fb" };
+		int i, num_names = 3;
+
+		for (i = 0; i < num_names; i++) {
+			if (fb_get_options(names[i], &options)) {
+				dev_err(dev, " Disabled on command-line.\n");
+				return -ENODEV;
+			}
+			if (options)
+				break;
+		}
+	}
+#endif
+
+	/* Register the device with LDM */
+	if (platform_device_register(&davincifb_device)) {
+		dev_err(dev, "failed to register davincifb device\n");
+		return -ENODEV;
+	}
+	/* Register the driver with LDM */
+	if (driver_register(&davincifb_driver)) {
+		dev_err(dev, "failed to register davincifb driver\n");
+		platform_device_unregister(&davincifb_device);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit davincifb_cleanup(void)
+{
+	driver_unregister(&davincifb_driver);
+	platform_device_unregister(&davincifb_device);
+}
+
+module_init(davincifb_init);
+module_exit(davincifb_cleanup);
+
+MODULE_DESCRIPTION("Framebuffer driver for TI DaVinci");
+MODULE_AUTHOR("MontaVista Software");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/include/media/ccdc_davinci.h
===================================================================
--- linux-2.6.10.orig/include/media/ccdc_davinci.h
+++ /dev/null
@@ -1,368 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* ccdc_davinci.h */
-
-#ifndef CCDC_DAVINCI_H
-#define CCDC_DAVINCI_H
-#include <asm/io.h>
-#include <linux/videodev.h>
-
-#ifndef TYPES
-#define TYPES
-typedef unsigned char bool;
-#endif
-
-/* Define to enable/disable video port */
-#define VIDEO_PORT_ENABLE	(1)
-
-typedef enum ccdc_pixfmt {
-	CCDC_PIXFMT_RAW = 0,
-	CCDC_PIXFMT_YCBCR_16BIT = 1,
-	CCDC_PIXFMT_YCBCR_8BIT = 2
-} ccdc_pixfmt;
-
-typedef enum ccdc_frmfmt {
-	CCDC_FRMFMT_PROGRESSIVE = 0,
-	CCDC_FRMFMT_INTERLACED = 1
-} ccdc_frmfmt;
-
-typedef enum ccdc_pinpol {
-	CCDC_PINPOL_POSITIVE = 0,
-	CCDC_PINPOL_NEGATIVE = 1
-} ccdc_pinpol;
-
-/* PIXEL ORDER IN MEMORY from LSB to MSB */
-/* only applicable for 8-bit input mode  */
-typedef enum ccdc_pixorder {
-	CCDC_PIXORDER_CBYCRY = 1,
-	CCDC_PIXORDER_YCBYCR = 0
-} ccdc_pixorder;
-
-typedef enum ccdc_buftype {
-	CCDC_BUFTYPE_FLD_INTERLEAVED,
-	CCDC_BUFTYPE_FLD_SEPARATED
-} ccdc_buftype;
-
-/* enum for No of pixel per line to be avg. in Black Clamping*/
-enum sample_length {
-	_1PIXELS = 0,
-	_2PIXELS,
-	_4PIXELS,
-	_8PIXELS,
-	_16PIXELS
-};
-
-/* enum for No of lines in Black Clamping */
-enum sample_line {
-	_1LINES = 0,
-	_2LINES,
-	_4LINES,
-	_8LINES,
-	_16LINES
-};
-
-/* enum for Alaw gama width */
-enum gama_width {
-	BITS_15_6 = 0,
-	BITS_14_5,
-	BITS_13_4,
-	BITS_12_3,
-	BITS_11_2,
-	BITS_10_1,
-	BITS_09_0
-};
-
-enum data_size {
-	_16BITS = 0,
-	_15BITS,
-	_14BITS,
-	_13BITS,
-	_12BITS,
-	_11BITS,
-	_10BITS,
-	_8BITS
-};
-
-typedef struct v4l2_rect ccdc_imgwin;
-
-/* structure for ALaw */
-struct a_law {
-	bool b_alaw_enable;	/* Enable/disable A-Law */
-	enum gama_width gama_wd;	/*Gama Width Input */
-};
-
-/* structure for Black Clamping */
-struct black_clamp {
-	bool b_clamp_enable;
-	enum sample_length sample_pixel;	/* only if bClampEnable is TRUE */
-	enum sample_line sample_ln;	/* only if bClampEnable is TRUE */
-	unsigned short start_pixel;	/* only if bClampEnable is TRUE */
-	unsigned short sgain;	/* only if bClampEnable is TRUE */
-	unsigned short dc_sub;	/* only if bClampEnable is FALSE */
-};
-
-/* structure for Black Level Compensation */
-struct black_compensation {
-	char r_comp;		/* Constant value to subtract from Red component */
-	char gr_comp;		/* Constant value to subtract from Gr component */
-	char b_comp;		/* Constant value to subtract from Blue component */
-	char gb_comp;		/* Constant value to subtract from Gb component */
-};
-
-/* structure for fault pixel correction */
-struct fault_pixel {
-	bool fpc_enable;	/*Enable or Disable fault pixel correction */
-	unsigned short fp_num;	/*Number of fault pixel */
-	unsigned int fpc_table_addr;	/*Address of fault pixel table */
-
-};
-
-/* Structure for CCDC configuration parameters for raw capture mode passed 
- * by application
- */
-typedef struct ccdc_config_params_raw {
-
-	ccdc_pinpol fid_pol;	/* field id polarity */
-	ccdc_pinpol vd_pol;	/* vertical sync polarity */
-	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
-	bool image_invert_enable;	/* enable to store the image in inverse
-					   order in memory(bottom to top) */
-	enum data_size data_sz;	/* data size value from 8 to 16 bits */
-	struct a_law alaw;	/* Structure for Optional A-Law */
-	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
-	struct black_compensation blk_comp;	/* Structure for 
-						   Black Compensation */
-	struct fault_pixel fault_pxl;	/* Structure for Fault Pixel 
-					   Module Configuration */
-} ccdc_config_params_raw;
-
-typedef struct ccdc_params_ycbcr {
-	ccdc_pixfmt pix_fmt;	/* pixel format */
-	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
-	ccdc_imgwin win;	/* video window */
-	ccdc_pinpol fid_pol;	/* field id polarity */
-	ccdc_pinpol vd_pol;	/* vertical sync polarity */
-	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
-	int bt656_enable;	/* enable BT.656 embedded sync mode */
-	ccdc_pixorder pix_order;	/* cb:y:cr:y or y:cb:y:cr in memory */
-	ccdc_buftype buf_type;	/* interleaved or separated fields  */
-
-} ccdc_params_ycbcr;
-
-#ifdef __KERNEL__
-
-/* Structure for CCDC configuration parameters for raw capture mode */
-typedef struct ccdc_params_raw {
-
-	ccdc_pixfmt pix_fmt;	/* pixel format */
-	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
-	ccdc_imgwin win;	/* video window */
-	ccdc_pinpol fid_pol;	/* field id polarity */
-	ccdc_pinpol vd_pol;	/* vertical sync polarity */
-	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
-	ccdc_buftype buf_type;	/* interleaved or separated fields */
-	bool image_invert_enable;	/* enable to store the image in inverse 
-					   order in memory(bottom to top) */
-	enum data_size data_sz;	/* data size value from 8 to 16 bits */
-	struct a_law alaw;	/* Structure for Optional A-Law */
-	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
-	struct black_compensation blk_comp;	/* Structure for 
-						   Black Compensation */
-	struct fault_pixel fault_pxl;	/* Structure for Fault Pixel 
-					   Module Configuration */
-} ccdc_params_raw;
-
-/**************************************************************************\
-* Register OFFSET Definitions
-\**************************************************************************/
-#define PID                             (0x0)
-#define PCR                             (0x4)
-#define SYN_MODE                        (0x8)
-#define HD_VD_WID                       (0xc)
-#define PIX_LINES                       (0x10)
-#define HORZ_INFO                       (0x14)
-#define VERT_START                      (0x18)
-#define VERT_LINES                      (0x1c)
-#define CULLING                         (0x20)
-#define HSIZE_OFF                       (0x24)
-#define SDOFST                          (0x28)
-#define SDR_ADDR                        (0x2c)
-#define CLAMP                           (0x30)
-#define DCSUB                           (0x34)
-#define COLPTN                          (0x38)
-#define BLKCMP                          (0x3c)
-#define FPC                             (0x40)
-#define FPC_ADDR                        (0x44)
-#define VDINT                           (0x48)
-#define ALAW                            (0x4c)
-#define REC656IF                        (0x50)
-#define CCDCFG                          (0x54)
-#define FMTCFG                          (0x58)
-#define FMT_HORZ                        (0x5c)
-#define FMT_VERT                        (0x60)
-#define FMT_ADDR0                       (0x64)
-#define FMT_ADDR1                       (0x68)
-#define FMT_ADDR2                       (0x6c)
-#define FMT_ADDR3                       (0x70)
-#define FMT_ADDR4                       (0x74)
-#define FMT_ADDR5                       (0x78)
-#define FMT_ADDR6                       (0x7c)
-#define FMT_ADDR7                       (0x80)
-#define PRGEVEN_0                       (0x84)
-#define PRGEVEN_1                       (0x88)
-#define PRGODD_0                        (0x8c)
-#define PRGODD_1                        (0x90)
-#define VP_OUT                          (0x94)
-
-#define CCDC_IOBASE_VADDR               IO_ADDRESS(0x01c70400)
-
-#define regw(val, reg)    		outl(val, (reg)+CCDC_IOBASE_VADDR)
-#define regr(reg)         		inl((reg)+CCDC_IOBASE_VADDR)
-
-#define VPSS_SB_IOBASE_VADDR		IO_ADDRESS(0x01c73400)
-#define regw_sb(val, reg)    		outl(val, (reg)+VPSS_SB_IOBASE_VADDR)
-#define regr_sb(reg)         		inl((reg)+VPSS_SB_IOBASE_VADDR)
-
-/***************************************************************
-*	Define for various register bit mask and shifts for CCDC
-****************************************************************/
-#define CCDC_FID_POL_MASK			(0x01)
-#define CCDC_FID_POL_SHIFT			(4)
-#define CCDC_HD_POL_MASK			(0x01)
-#define CCDC_HD_POL_SHIFT			(3)
-#define CCDC_VD_POL_MASK			(0x01)
-#define CCDC_VD_POL_SHIFT			(2)
-#define CCDC_HSIZE_OFF_MASK			(0xffffffe0)
-#define CCDC_32BYTE_ALIGN_VAL			(31)
-#define CCDC_FRM_FMT_MASK			(0x01)
-#define CCDC_FRM_FMT_SHIFT			(7  )
-#define CCDC_DATA_SZ_MASK			(0x07)
-#define CCDC_DATA_SZ_SHIFT			(8)
-#define CCDC_PIX_FMT_MASK			(0x03)
-#define CCDC_PIX_FMT_SHIFT			(12)
-#define CCDC_VP2SDR_DISABLE			(0xFFFBFFFF)
-#define CCDC_WEN_ENABLE				(0x01 << 17)
-#define CCDC_SDR2RSZ_DISABLE			(0xFFF7FFFF)
-#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
-#define CCDC_LPF_ENABLE				(0x01 << 14)
-#define CCDC_ALAW_ENABLE			(0x01 << 3 )
-#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
-#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 31)
-#define CCDC_BLK_SGAIN_MASK			(0x1F )
-#define CCDC_BLK_ST_PXL_MASK			(0x7FFF)
-#define CCDC_BLK_ST_PXL_SHIFT			(10)
-#define CCDC_BLK_SAMPLE_LN_MASK			(0x07)
-#define CCDC_BLK_SAMPLE_LN_SHIFT		(28)
-#define CCDC_BLK_SAMPLE_LINE_MASK		(0x07)
-#define CCDC_BLK_SAMPLE_LINE_SHIFT		(25)
-#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
-#define CCDC_BLK_COMP_MASK			(0x000000FF)
-#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
-#define CCDC_BLK_COMP_GR_COMP_SHIFT		(16)
-#define CCDC_BLK_COMP_R_COMP_SHIFT		(24)
-#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
-#define CCDC_FPC_ENABLE				(0x01 << 15)
-#define CCDC_FPC_DISABLE			(0x0)
-#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
-#define CCDC_DATA_PACK_ENABLE			(0x01<<11)
-#define CCDC_FMTCFG_VPIN_MASK			(0x07)
-#define CCDC_FMTCFG_VPIN_SHIFT			(12)
-#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
-#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
-#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16 )
-#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
-#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
-#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16 )
-#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
-#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
-#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
-#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
-#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
-#define CCDC_HORZ_INFO_SPH_SHIFT		(16)
-#define CCDC_VERT_START_SLV0_SHIFT		(16)
-#define CCDC_VDINT_VDINT0_SHIFT			(16)
-#define CCDC_VDINT_VDINT1_MASK			(0xFFFF)
-
-/* SBL register and mask defination */
-#define SBL_PCR_VPSS				(4)
-#define SBL_PCR_CCDC_WBL_O			(0xFF7FFFFF)
-
-#define PPC_RAW					(1)
-#define DCSUB_DEFAULT_VAL			(0)
-#define CLAMP_DEFAULT_VAL			(0)
-#define ENABLE_VIDEO_PORT			(0x00008000)
-#define DISABLE_VIDEO_PORT			(0)
-#define CCDC_COLPTN_VAL				(0xBB11BB11)
-#define TWO_BYTES_PER_PIXEL			(2)
-#define INTERLACED_IMAGE_INVERT			(0x4B6D)
-#define INTERLACED_NO_IMAGE_INVERT		(0x0249)
-#define PROGRESSIVE_IMAGE_INVERT		(0x4000)
-#define PROGRESSIVE_NO_IMAGE_INVERT		(0)
-#define CCDC_INTERLACED_HEIGHT_SHIFT		(1)
-
-extern void ccdc_reset(void);
-extern void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc);
-void ccdc_config_ycbcr(ccdc_params_ycbcr * params);
-void ccdc_config_raw(ccdc_params_raw * params);
-
-/* inline functions that must be fast because they are called frequently */
-static inline void ccdc_vdhd_enable(int flag)
-{
-	unsigned int syn_mode;
-	syn_mode = regr(SYN_MODE);
-	syn_mode =
-	    (flag) ? (syn_mode | CCDC_VDHDEN_ENABLE) : (syn_mode &
-							(!CCDC_VDHDEN_ENABLE));
-
-	/* configure internal timing generator */
-	regw(syn_mode, SYN_MODE);
-}
-
-static inline void ccdc_enable(int flag)
-{
-	regw(flag, PCR);
-}
-
-static inline void ccdc_setfbaddr(unsigned long paddr)
-{
-	regw(paddr & 0xffffffe0, SDR_ADDR);
-}
-
-static inline int ccdc_getfid(void)
-{
-	int fid = (regr(SYN_MODE) >> 15) & 0x1;
-	return fid;
-}
-
-static inline int ccdc_sbl_reset(void)
-{
-	int sb_reset;
-	sb_reset = regr_sb(SBL_PCR_VPSS);
-	regw_sb((sb_reset & SBL_PCR_CCDC_WBL_O), SBL_PCR_VPSS);
-	return sb_reset;
-}
-
-static inline void ccdc_enable_vport(void)
-{
-	/* enable video port */
-	regw(ENABLE_VIDEO_PORT, FMTCFG);
-}
-
-#endif
-
-#endif				/* CCDC_DAVINCI_H */
Index: linux-2.6.10/include/media/davinci_vpfe.h
===================================================================
--- linux-2.6.10.orig/include/media/davinci_vpfe.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_vpfe.h */
-
-#ifndef DAVINCI_VPFE_H
-#define DAVINCI_VPFE_H
-
-#include <media/ccdc_davinci.h>
-#include <media/tvp5146.h>
-#include <media/mt9t001.h>
-
-#define TRUE 1
-#define FALSE 0
-
-/* vpfe specific video standards */
-#define VPFE_STD_625_50_SQP ((V4L2_STD_625_50)<<32)
-#define VPFE_STD_525_60_SQP ((V4L2_STD_525_60)<<32)
-#define VPFE_STD_AUTO ((v4l2_std_id)(0x1000000000000000ULL))
-#define VPFE_STD_AUTO_SQP ((v4l2_std_id)(0x2000000000000000ULL))
-
-#define VPFE_CMD_CONFIG_CCDC_YCBCR \
-			_IOW('V',BASE_VIDIOC_PRIVATE + 1,ccdc_params_ycbcr)
-#define VPFE_CMD_LATEST_FRM_ONLY \
-			_IOW('V',BASE_VIDIOC_PRIVATE + 2,int)
-#define VPFE_CMD_CONFIG_TVP5146 \
-			_IOW('V',BASE_VIDIOC_PRIVATE + 3,tvp5146_params)
-
-#define VPFE_CMD_CONFIG_CCDC_RAW \
-			_IOW('V',BASE_VIDIOC_PRIVATE + 4,ccdc_config_params_raw)
-#define VPFE_CMD_S_MT9T001_PARAMS \
-			_IOW('V',BASE_VIDIOC_PRIVATE + 5,struct mt9t001_params)
-#define VPFE_CMD_G_MT9T001_PARAMS \
-			_IOR('V',BASE_VIDIOC_PRIVATE + 6,struct mt9t001_params)
-
-/* Define for extra pixel/line and extra lines/frame */
-#define NUM_EXTRAPIXELS		16
-#define NUM_EXTRALINES		8
-
-/* settings for commonly used video formats */
-#define VPFE_WIN_NTSC    {0,0,720,480}
-#define VPFE_WIN_PAL     {0,0,720,576}
-#define VPFE_WIN_NTSC_SP {0,0,640,480}	/* ntsc square pixel */
-#define VPFE_WIN_PAL_SP  {0,0,768,576}	/* pal square pixel */
-#define VPFE_WIN_CIF     {0,0,352,288}
-#define VPFE_WIN_QCIF    {0,0,176,144}
-#define VPFE_WIN_QVGA    {0,0,320,240}
-#define VPFE_WIN_SIF     {0,0,352,240}
-
-#define VPFE_WIN_VGA	{0,0,(640 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
-#define VPFE_WIN_SVGA 	{0,0,(800 + NUM_EXTRAPIXELS),(600 + NUM_EXTRALINES)}
-#define VPFE_WIN_XGA	{0,0,(1024+ NUM_EXTRAPIXELS),(768 + NUM_EXTRALINES)}
-#define VPFE_WIN_480p	{0,0,(720 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
-#define VPFE_WIN_576p	{0,0,(720 + NUM_EXTRAPIXELS),(576 + NUM_EXTRALINES)}
-#define VPFE_WIN_720p 	{0,0,(1280+ NUM_EXTRAPIXELS),(720 + NUM_EXTRALINES)}
-#define VPFE_WIN_1080p 	{0,0,(1936),(1083)}
-
-/* V4L2 defines added for new standards, 
-					  these will be moved to videodev2.h */
-#define V4L2_STD_MT9T001_VGA_30FPS	(10)
-#define V4L2_STD_MT9T001_VGA_60FPS	(11)
-#define V4L2_STD_MT9T001_SVGA_30FPS	(12)
-#define V4L2_STD_MT9T001_SVGA_60FPS	(13)
-#define V4L2_STD_MT9T001_XGA_30FPS	(14)
-#define V4L2_STD_MT9T001_480p_30FPS	(15)
-#define V4L2_STD_MT9T001_480p_60FPS	(16)
-#define V4L2_STD_MT9T001_576p_25FPS	(17)
-#define V4L2_STD_MT9T001_576p_50FPS	(18)
-#define V4L2_STD_MT9T001_720p_24FPS	(19)
-#define V4L2_STD_MT9T001_720p_30FPS	(20)
-#define V4L2_STD_MT9T001_1080p_18FPS	(21)
-
-/* Define for device type to be passed in init */
-#define 	MT9T001	0
-#define		TVP5146	1
-
-#ifdef __KERNEL__
-
-#include <media/video-buf.h>
-
-#define VPFE_MAJOR_RELEASE 0
-#define VPFE_MINOR_RELEASE 0
-#define VPFE_BUILD         1
-
-#define VPFE_VERSION_CODE \
-     (VPFE_MAJOR_RELEASE<<16)  | (VPFE_MINOR_RELEASE<<8) | VPFE_BUILD
-
-/* By default, the driver is setup for auto-swich mode */
-#define VPFE_DEFAULT_STD VPFE_STD_AUTO
-
-#define VPFE_PIXELASPECT_NTSC 		{11, 10}
-#define VPFE_PIXELASPECT_PAL  		{54, 59}
-#define VPFE_PIXELASPECT_NTSC_SP    	{1, 1}
-#define VPFE_PIXELASPECT_PAL_SP     	{1, 1}
-#define VPFE_PIXELASPECT_DEFAULT    	{1, 1}
-
-/* Buffer size defines for TVP5146 and MT9T001 */
-#define VPFE_TVP5146_MAX_FRAME_WIDTH      768	/* for PAL Sqpixel mode */
-#define VPFE_TVP5146_MAX_FRAME_HEIGHT     576	/* for PAL              */
-/* 4:2:2 data */
-#define VPFE_TVP5146_MAX_FBUF_SIZE      \
-		 (VPFE_TVP5146_MAX_FRAME_WIDTH*VPFE_TVP5146_MAX_FRAME_HEIGHT*2)
-
-#define VPFE_MT9T001_MAX_FRAME_WIDTH     (1936)
-#define VPFE_MT9T001_MAX_FRAME_HEIGHT    (1083)
-/* 2 BYTE FOR EACH PIXEL */
-#define VPFE_MT9T001_MAX_FBUF_SIZE       \
-		(VPFE_MT9T001_MAX_FRAME_WIDTH*VPFE_MT9T001_MAX_FRAME_HEIGHT*2)
-
-/* frame buffers allocate at driver initialization time */
-#define VPFE_DEFNUM_FBUFS             3
-
-/* Defines for number of lines for all formats */
-#define FMT_VGA_NUMLINES				(480 + NUM_EXTRALINES)
-#define FMT_SVGA_NUMLINES				(600 + NUM_EXTRALINES)
-#define FMT_XGA_NUMLINES				(768 + NUM_EXTRALINES)
-#define FMT_480p_NUMLINES				(480 + NUM_EXTRALINES)
-#define FMT_576p_NUMLINES				(576 + NUM_EXTRALINES)
-#define FMT_720p_NUMLINES				(720 + NUM_EXTRALINES)
-#define FMT_1080i_NUMLINES				(1083)
-
-/* Defines for FPS values */
-#define FPS_18_NUMERATOR				(1)
-#define FPS_18_DENOMIRATOR				(18)
-#define FPS_24_NUMERATOR				(1)
-#define FPS_24_DENOMIRATOR  				(24)
-#define FPS_25_NUMERATOR				(1)
-#define FPS_25_DENOMIRATOR  				(25)
-#define FPS_30_NUMERATOR				(1)
-#define FPS_30_DENOMIRATOR  				(30)
-#define FPS_50_NUMERATOR    				(1)
-#define FPS_50_DENOMIRATOR  				(50)
-#define FPS_60_NUMERATOR    				(1)
-#define FPS_60_DENOMIRATOR  				(60)
-
-#define FP_NUM_BYTES					(4)
-/* Device configuration function pointer */
-typedef int (*device_cfg_fxn) (unsigned int cmd, void *arg, void *params);
-
-typedef struct vpfe_obj {
-	struct video_device *video_dev;
-	struct videobuf_queue bufqueue;	/* queue with frame buffers      */
-	struct list_head dma_queue;
-	u32 latest_only;	/* indicate whether to return the most */
-	/* recent captured buffers only        */
-	u32 usrs;
-	u32 io_usrs;
-	struct v4l2_prio_state prio;
-	v4l2_std_id std;
-	struct v4l2_rect vwin;
-	struct v4l2_rect bounds;
-	struct v4l2_fract pixelaspect;
-	spinlock_t irqlock;
-	struct semaphore lock;
-	enum v4l2_field field;
-	u32 pixelfmt;
-	u32 numbuffers;
-	u8 *fbuffers[VIDEO_MAX_FRAME];
-	struct videobuf_buffer *curFrm;
-	struct videobuf_buffer *nextFrm;
-	int field_id;
-	int mode_changed;
-	int started;
-	int field_offset;
-	unsigned char capture_device;	/*set in vpfe_init()
-					   (1=TVP5146, 0=MT9T001) */
-	tvp5146_params tvp5146_params;
-	void *device_params;	/*Pointer for video device. (MT9T001) */
-	ccdc_params_raw ccdc_params_raw;	/*Object for CCDC raw mode */
-	ccdc_params_ycbcr ccdc_params_ycbcr;	/*Object for CCDC ycbcr mode */
-	device_cfg_fxn config_dev_fxn;	/*where,typedef int(*deviceCfg_Fxn)
-					   (Uns cmd, void *arg, void *params); */
-
-} vpfe_obj;
-
-/* file handle */
-typedef struct vpfe_fh {
-	struct vpfe_obj *dev;
-	int io_allowed;
-	enum v4l2_priority prio;
-} vpfe_fh;
-#endif
-
-#endif				/* DAVINCI_VPFE_H */
Index: linux-2.6.10/include/media/mt9t001.h
===================================================================
--- linux-2.6.10.orig/include/media/mt9t001.h
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/*mt9t001.h*/
-
-#ifndef	MT9T001_H
-#define	MT9T001_H
-
-/*********************************
- * Defines and Macros and globals
- ********************************/
-
-#ifdef	TRUE
-#undef	TRUE
-#endif
-
-#ifdef	FALSE
-#undef	FALSE
-#endif
-
-#define	TRUE 	1
-#define	FALSE	0
-
-#ifdef DEBUG
-#undef DEBUG
-#endif
-
-#ifndef TYPES
-#define TYPES
-typedef unsigned char bool;
-#endif
-
-#define DEBUG
-
-#ifdef __KERNEL__
-
-extern int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
-
-/* defines for extra pixels/line added */
-#define MT9T001_EXTRAPIXELS 16
-#define MT9T001_EXTRALINES	  8
-
-/* Definitions to access the various sensor registers */
-#define MT9T001_CHIP_VERSION			(0x00)
-#define MT9T001_ROW_START			(0x01)
-#define MT9T001_COL_START			(0x02)
-#define MT9T001_HEIGHT				(0x03)
-#define MT9T001_WIDTH				(0x04)
-#define MT9T001_HBLANK				(0x05)
-#define MT9T001_VBLANK				(0x06)
-#define MT9T001_OUTPUT_CTRL			(0x07)
-#define MT9T001_SHUTTER_WIDTH_UPPER		(0x08)
-#define MT9T001_SHUTTER_WIDTH			(0x09)
-#define MT9T001_PIXEL_CLK_CTRL			(0x0A)
-#define MT9T001_RESTART				(0x0B)
-#define MT9T001_SHUTTER_DELAY			(0x0C)
-#define MT9T001_RESET				(0x0D)
-#define MT9T001_READ_MODE1			(0x1E)
-#define MT9T001_READ_MODE2			(0x20)
-#define MT9T001_READ_MODE3			(0x21)
-#define MT9T001_ROW_ADDR_MODE			(0x22)
-#define MT9T001_COL_ADDR_MODE			(0x23)
-#define MT9T001_RESERVED_27_REG                 (0x27)
-#define MT9T001_GREEN1_GAIN			(0x2B)
-#define MT9T001_BLUE_GAIN			(0x2C)
-#define MT9T001_RED_GAIN			(0x2D)
-#define MT9T001_GREEN2_GAIN			(0x2E)
-#define MT9T001_GLOBAL_GAIN			(0x35)
-#define MT9T001_BLACK_LEVEL			(0x49)
-#define MT9T001_ROW_BLK_DEF_OFFSET		(0x4B)
-#define MT9T001_RESERVED_4E_REG                 (0x4e)
-#define MT9T001_RESERVED_50_REG                 (0x50)
-#define MT9T001_RESERVED_51_REG                 (0x51)
-#define MT9T001_RESERVED_52_REG                 (0x52)
-#define MT9T001_RESERVED_53_REG                 (0x53)
-#define MT9T001_CAL_COARSE			(0x5D)
-#define MT9T001_CAL_TARGET			(0x5F)
-#define MT9T001_GREEN1_OFFSET			(0x60)
-#define MT9T001_GREEN2_OFFSET			(0x61)
-#define MT9T001_BLK_LVL_CALIB			(0x62)
-#define MT9T001_RED_OFFSET			(0x63)
-#define MT9T001_BLUE_OFFSET			(0x64)
-#define MT9T001_CHIP_ENABLE_SYNC		(0xF8)
-#define MT9T001_CHIP_VERSION_END		(0xFF)
-
-/* Define Shift and Mask for gain register*/
-
-#define	MT9T001_ANALOG_GAIN_SHIFT	(0x0000)
-#define	MT9T001_DIGITAL_GAIN_SHIFT	(8)
-#define	MT9T001_ANALOG_GAIN_MASK	(0x007F)
-#define	MT9T001_DIGITAL_GAIN_MASK	(0x7F00)
-
-/* Define Shift and Mask for black level caliberation register*/
-
-#define	MT9T001_MANUAL_OVERRIDE_MASK		(0x0001)
-#define	MT9T001_DISABLE_CALLIBERATION_SHIFT	(1)
-#define	MT9T001_DISABLE_CALLIBERATION_MASK	(0x0002)
-#define	MT9T001_RECAL_BLACK_LEVEL_SHIFT		(12)
-#define	MT9T001_RECAL_BLACK_LEVEL_MASK		(0x1000)
-#define	MT9T001_LOCK_RB_CALIBRATION_SHIFT	(13)
-#define	MT9T001_LOCK_RB_CALLIBERATION_MASK	(0x2000)
-#define	MT9T001_LOCK_GREEN_CALIBRATION_SHIFT	(14)
-#define	MT9T001_LOCK_GREEN_CALLIBERATION_MASK	(0x4000)
-#define	MT9T001_LOW_COARSE_THELD_MASK		(0x007F)
-#define	MT9T001_HIGH_COARSE_THELD_SHIFT		(8)
-#define	MT9T001_HIGH_COARSE_THELD_MASK		(0x7F00)
-#define	MT9T001_LOW_TARGET_THELD_MASK		(0x007F)
-#define	MT9T001_HIGH_TARGET_THELD_SHIFT		(8)
-#define	MT9T001_HIGH_TARGET_THELD_MASK		(0x7F00)
-#define	MT9T001_SHUTTER_WIDTH_LOWER_MASK	(0xFFFF)
-#define	MT9T001_SHUTTER_WIDTH_UPPER_SHIFT	(16)
-#define	MT9T001_SHUTTER_WIDTH_UPPER_MASK	(0xFFFF)
-#define	MT9T001_ROW_START_MASK			(0x07FF)
-#define	MT9T001_COL_START_MASK			(0x0FFF)
-#define	 MT9T001_GREEN1_OFFSET_MASK 		(0x01FF)
-#define	 MT9T001_GREEN2_OFFSET_MASK 		(0x01FF)
-#define	 MT9T001_RED_OFFSET_MASK 		(0x01FF)
-#define	 MT9T001_BLUE_OFFSET_MASK 		(0x01FF)
-
-/* defines for MT9T001 register values */
-#define	MT9T001_NORMAL_OPERATION_MODE		(0x0002)
-#define	MT9T001_HALT_MODE			(0x0003)
-#define MT9T001_RESET_ENABLE			(0x0001)
-#define MT9T001_RESET_DISABLE			(0x0000)
-#define	MT9T001_INVERT_PIXEL_CLK		(0x8000)
-#define MT9T001_GAIN_MINVAL			(0)
-#define MT9T001_GAIN_MAXVAL			(128)
-#define MT9T001_GAIN_STEP			(1)
-#define MT9T001_GAIN_DEFAULTVAL			(8)
-
-/* Default values for MT9T001 registers */
-#define MT9T001_ROW_START_DEFAULT		(0x14)
-#define MT9T001_COL_START_DEFAULT		(0x20)
-#define MT9T001_HEIGHT_DEFAULT			(0x5FF)
-#define MT9T001_WIDTH_DEFAULT			(0x7FF)
-#define MT9T001_HBLANK_DEFAULT			(0x8E)
-#define MT9T001_VBLANK_DEFAULT			(0x19)
-#define MT9T001_OUTPUT_CTRL_DEFAULT		(0x02)
-#define MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT	(0x0)
-#define MT9T001_SHUTTER_WIDTH_DEFAULT		(0x619)
-#define MT9T001_PIXEL_CLK_CTRL_DEFAULT		(0x0)
-#define MT9T001_RESTART_DEFAULT			(0x0)
-#define MT9T001_SHUTTER_DELAY_DEFAULT		(0x0)
-#define MT9T001_READ_MODE1_DEFAULT		(0xC040)
-#define MT9T001_READ_MODE2_DEFAULT		(0x0)
-#define MT9T001_READ_MODE3_DEFAULT		(0x0)
-#define MT9T001_ROW_ADDR_MODE_DEFAULT		(0x0)
-#define MT9T001_COL_ADDR_MODE_DEFAULT		(0x0)
-#define MT9T001_GREEN1_GAIN_DEFAULT		(0x08)
-#define MT9T001_BLUE_GAIN_DEFAULT		(0x08)
-#define MT9T001_RED_GAIN_DEFAULT		(0x08)
-#define MT9T001_GREEN2_GAIN_DEFAULT		(0x08)
-#define MT9T001_GLOBAL_GAIN_DEFAULT		(0x08)
-#define MT9T001_BLACK_LEVEL_DEFAULT		(0xA8)
-#define MT9T001_CAL_COARSE_DEFAULT		(0x2D13)
-#define MT9T001_CAL_TARGET_DEFAULT		(0x231D)
-#define MT9T001_GREEN1_OFFSET_DEFAULT		(0x20)
-#define MT9T001_GREEN2_OFFSET_DEFAULT		(0x20)
-#define MT9T001_BLK_LVL_CALIB_DEFAULT		(0x0)
-#define MT9T001_RED_OFFSET_DEFAULT		(0x20)
-#define MT9T001_BLUE_OFFSET_DEFAULT		(0x20)
-#define MT9T001_CHIP_ENABLE_SYNC_DEFAULT	(0x01)
-
-#define MT9T001_I2C_REGISTERED			(1)
-#define MT9T001_I2C_UNREGISTERED		(0)
-
-/*	Defines for mt9t001_ctrl() functions command*/
-
-#define	MT9T001_SET_PARAMS	1
-#define	MT9T001_GET_PARAMS	2
-#define	MT9T001_SET_GAIN	3
-#define	MT9T001_SET_STD		4
-#define	MT9T001_INIT		5
-#define	MT9T001_CLEANUP		6
-
-/* define for various video format supported by MT9T001 driver */
-/* Here all mode defines will be assigned values of v4l2 mode defines */
-#define	MT9T001_MODE_VGA_30FPS  	(10)
-#define	MT9T001_MODE_VGA_60FPS		(11)
-#define	MT9T001_MODE_SVGA_30FPS		(12)
-#define	MT9T001_MODE_SVGA_60FPS		(13)
-#define	MT9T001_MODE_XGA_30FPS		(14)
-#define	MT9T001_MODE_480p_30FPS		(15)
-#define	MT9T001_MODE_480p_60FPS		(16)
-#define	MT9T001_MODE_576p_25FPS		(17)
-#define	MT9T001_MODE_576p_50FPS		(18)
-#define	MT9T001_MODE_720p_24FPS		(19)
-#define	MT9T001_MODE_720p_30FPS		(20)
-#define	MT9T001_MODE_1080p_18FPS	(21)
-
-/*i2c adress for MT9T001*/
-#define MT9T001_I2C_ADDR  (0xBA >>1)
-/*i2c adress for PCA9543A*/
-#define PCA9543A_I2C_ADDR  (0x70)
-
-#define PCA9543A_I2C_CONFIG		(0)
-#define MT9T001_I2C_CONFIG		(1)
-#define PCA9543A_REGVAL			(0x01)
-#define I2C_ONE_BYTE_TRANSFER		(1)
-#define I2C_TWO_BYTE_TRANSFER		(2)
-#define I2C_THREE_BYTE_TRANSFER		(3)
-#define I2C_TXRX_DATA_MASK		(0x00FF)
-#define I2C_TXRX_DATA_MASK_UPPER	(0xFF00)
-#define I2C_TXRX_DATA_SHIFT		(8)
-
-#endif				/* endif of __KERNEL__ */
-
-/* Structure containing video standard dependent settings */
-struct mt9t001_format_params {
-	unsigned short col_size;	/* width */
-	unsigned short row_size;	/* Height */
-	unsigned short h_blank;
-	unsigned short v_blank;
-	unsigned int shutter_width;
-	unsigned short row_addr_mode;
-	unsigned short col_addr_mode;
-	unsigned short black_level;
-	unsigned short pixel_clk_control;
-	unsigned short row_start;
-	unsigned short col_start;
-};
-
-/* Structure for gain settings */
-struct mt9t001_rgb_gain {
-	unsigned char green1_analog_gain;
-	unsigned char red_analog_gain;
-	unsigned char blue_analog_gain;
-	unsigned char green2_analog_gain;
-	unsigned char green1_digital_gain;
-	unsigned char red_digital_gain;
-	unsigned char blue_digital_gain;
-	unsigned char green2_digital_gain;
-};
-/* structure for black level calibration setttings*/
-struct mt9t001_black_level_calibration {
-	bool manual_override;
-	bool disable_calibration;
-	bool recalculate_black_level;
-	bool lock_red_blue_calibration;
-	bool lock_green_calibration;
-	unsigned char low_coarse_thrld;
-	unsigned char high_coarse_thrld;
-	unsigned char low_target_thrld;
-	unsigned char high_target_thrld;
-	unsigned short green1_offset;
-	unsigned short green2_offset;
-	unsigned short red_offset;
-	unsigned short blue_offset;
-};
-
-/* structure for MT9T001 configuration setttings passed by application*/
-struct mt9t001_params {
-	struct mt9t001_format_params format;
-	struct mt9t001_rgb_gain rgb_gain;
-	struct mt9t001_black_level_calibration black_calib;
-};
-
-#endif				/*for  ifndef MT9T001 */
Index: linux-2.6.10/include/media/tvp5146.h
===================================================================
--- linux-2.6.10.orig/include/media/tvp5146.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* tvp5146.h file */
-
-#ifndef TVP5146_H
-#define TVP5146_H
-
-#ifdef TRUE
-#undef TRUE
-#endif
-#ifdef FALSE
-#undef FALSE
-#endif
-
-#define TRUE 1
-#define FALSE 0
-
-/* analog muxing mode */
-#define    TVP5146_AMUX_COMPOSITE  0
-#define    TVP5146_AMUX_SVIDEO     1
-
-typedef enum {
-	TVP5146_MODE_INV = -1,
-	TVP5146_MODE_AUTO = 0,	/* autoswitch mode (default)   */
-	TVP5146_MODE_NTSC = 1,	/* (M, J) NTSC      525-line   */
-	TVP5146_MODE_PAL = 2,	/* (B, D, G, H, I, N) PAL      */
-	TVP5146_MODE_PAL_M = 3,	/* (M) PAL          525-line   */
-	TVP5146_MODE_PAL_CN = 4,	/* (Combination-N) PAL         */
-	TVP5146_MODE_NTSC_443 = 5,	/* NTSC 4.43        525-line   */
-	TVP5146_MODE_SECAM = 6,	/* SECAM                       */
-	TVP5146_MODE_PAL_60 = 7,	/* PAL 60          525-line    */
-	TVP5146_MODE_AUTO_SQP = 8,	/* autoswitch mode (default)   */
-	TVP5146_MODE_NTSC_SQP = 9,	/* (M, J) NTSC      525-line   */
-	TVP5146_MODE_PAL_SQP = 0xA,	/* (B, D, G, H, I, N) PAL      */
-	TVP5146_MODE_PAL_M_SQP = 0xB,	/* (M) PAL          525-line   */
-	TVP5146_MODE_PAL_CN_SQP = 0xC,	/* (Combination-N) PAL         */
-	TVP5146_MODE_NTSC_443_SQP = 0xD,	/* NTSC 4.43 525-line   */
-	TVP5146_MODE_SECAM_SQP = 0xE,	/* SECAM                       */
-	TVP5146_MODE_PAL_60_SQP = 0xF,	/* PAL 60          525-line    */
-} tvp5146_mode;
-
- /* Enum for TVP5146 output data width */
-typedef enum tvp5146_datawidth {
-	TVP5146_WIDTH_16BIT,
-	TVP5146_WIDTH_8BIT
-} tvp5146_datawidth_t;
-
-typedef struct {
-	tvp5146_mode mode;
-	int amuxmode;
-	int enablebt656sync;
-	tvp5146_datawidth_t data_width;
-} tvp5146_params;
-
-#ifdef __KERNEL__
-
-typedef struct {
-	int agc_enable;
-	tvp5146_mode video_std;
-	int brightness;
-	int contrast;
-	int saturation;
-	int hue;
-	int field_rate;		/* 50 or 60 in Hz */
-	int lost_lock;
-	int csubc_lock;
-	int v_lock;
-	int h_lock;
-} tvp5146_status;
-
-typedef unsigned int tvp5146_cmd;
-
-/* commands for setup the decoder */
-#define TVP5146_SET_AMUXMODE        4
-#define TVP5146_SET_BRIGHTNESS      5
-#define TVP5146_SET_CONTRAST        6
-#define TVP5146_SET_HUE             7
-#define TVP5146_SET_SATURATION      8
-#define TVP5146_SET_AGC             9
-#define TVP5146_SET_VIDEOSTD        10
-#define TVP5146_CLR_LOSTLOCK        11
-#define TVP5146_CONFIG              12
-#define TVP5146_RESET               13
-#define TVP5146_POWERDOWN           14
-
-#define TVP5146_GET_STATUS          15
-#define TVP5146_GET_STD             16
-#define TVP5146_INIT                17
-#define TVP5146_CLEANUP             18
-
-#define TVP5146_I2C_ADDR (0xBA >> 1)
-
-/* Defines for TVP5146 register address */
-#define TVP5146_OUTPUT1                 	(0x33)
-#define TVP5146_OUTPUT2                 	(0x34)
-#define TVP5146_OUTPUT3				(0x35)
-#define TVP5146_OUTPUT4				(0x36)
-#define TVP5146_OUTPUT5				(0x37)
-#define TVP5146_OUTPUT6				(0x38)
-
-#define TVP5146_I2C_REGISTERED			(1)
-#define TVP5146_I2C_UNREGISTERED		(0)
-
-extern int tvp5146_ctrl(tvp5146_cmd cmd, void *arg);
-
-#endif
-#endif
Index: linux-2.6.10/include/media/davinci/ccdc_davinci.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/ccdc_davinci.h
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.h */
+
+#ifndef CCDC_DAVINCI_H
+#define CCDC_DAVINCI_H
+#include <asm/io.h>
+#include <linux/videodev.h>
+
+#ifndef TYPES
+#define TYPES
+typedef unsigned char bool;
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+/* Define to enable/disable video port */
+#define VIDEO_PORT_ENABLE	(1)
+
+typedef enum ccdc_pixfmt {
+	CCDC_PIXFMT_RAW = 0,
+	CCDC_PIXFMT_YCBCR_16BIT = 1,
+	CCDC_PIXFMT_YCBCR_8BIT = 2
+} ccdc_pixfmt;
+
+typedef enum ccdc_frmfmt {
+	CCDC_FRMFMT_PROGRESSIVE = 0,
+	CCDC_FRMFMT_INTERLACED = 1
+} ccdc_frmfmt;
+
+typedef enum ccdc_pinpol {
+	CCDC_PINPOL_POSITIVE = 0,
+	CCDC_PINPOL_NEGATIVE = 1
+} ccdc_pinpol;
+
+/* PIXEL ORDER IN MEMORY from LSB to MSB */
+/* only applicable for 8-bit input mode  */
+typedef enum ccdc_pixorder {
+	CCDC_PIXORDER_CBYCRY = 1,
+	CCDC_PIXORDER_YCBYCR = 0
+} ccdc_pixorder;
+
+typedef enum ccdc_buftype {
+	CCDC_BUFTYPE_FLD_INTERLEAVED,
+	CCDC_BUFTYPE_FLD_SEPARATED
+} ccdc_buftype;
+
+/* enum for No of pixel per line to be avg. in Black Clamping*/
+enum sample_length {
+	_1PIXELS = 0,
+	_2PIXELS,
+	_4PIXELS,
+	_8PIXELS,
+	_16PIXELS
+};
+
+#define FP_NUM_BYTES					(4)
+/* Define for extra pixel/line and extra lines/frame */
+#define NUM_EXTRAPIXELS	    8
+#define NUM_EXTRALINES		8
+
+/* settings for commonly used video formats */
+#define VPFE_WIN_NTSC    {0,0,720,480}
+#define VPFE_WIN_PAL     {0,0,720,576}
+#define VPFE_WIN_NTSC_SP {0,0,640,480}	/* ntsc square pixel */
+#define VPFE_WIN_PAL_SP  {0,0,768,576}	/* pal square pixel */
+#define VPFE_WIN_CIF     {0,0,352,288}
+#define VPFE_WIN_QCIF    {0,0,176,144}
+#define VPFE_WIN_QVGA    {0,0,320,240}
+#define VPFE_WIN_SIF     {0,0,352,240}
+
+#define VPFE_WIN_VGA	{0,0,(640 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_SVGA 	{0,0,(800 + NUM_EXTRAPIXELS),(600 + NUM_EXTRALINES)}
+#define VPFE_WIN_XGA	{0,0,(1024+ NUM_EXTRAPIXELS),(768 + NUM_EXTRALINES)}
+#define VPFE_WIN_480p	{0,0,(720 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_576p	{0,0,(720 + NUM_EXTRAPIXELS),(576 + NUM_EXTRALINES)}
+#define VPFE_WIN_720p 	{0,0,(1280+ NUM_EXTRAPIXELS),(720 + NUM_EXTRALINES)}
+#define VPFE_WIN_1080p 	{0,0,(1920),(1080)}
+
+/* enum for No of lines in Black Clamping */
+enum sample_line {
+	_1LINES = 0,
+	_2LINES,
+	_4LINES,
+	_8LINES,
+	_16LINES
+};
+
+enum hw_frame {
+	CCDC_RAW,
+	CCDC_YCBCR
+};
+
+/* enum for Alaw gama width */
+enum gama_width {
+	BITS_15_6 = 0,
+	BITS_14_5,
+	BITS_13_4,
+	BITS_12_3,
+	BITS_11_2,
+	BITS_10_1,
+	BITS_09_0
+};
+
+enum data_size {
+	_16BITS = 0,
+	_15BITS,
+	_14BITS,
+	_13BITS,
+	_12BITS,
+	_11BITS,
+	_10BITS,
+	_8BITS
+};
+
+typedef struct v4l2_rect ccdc_imgwin;
+
+/* structure for ALaw */
+struct a_law {
+	bool b_alaw_enable;	/* Enable/disable A-Law */
+	enum gama_width gama_wd;	/*Gama Width Input */
+};
+
+/* structure for Black Clamping */
+struct black_clamp {
+	bool b_clamp_enable;
+	enum sample_length sample_pixel;	/* only if bClampEnable is TRUE */
+	enum sample_line sample_ln;	/* only if bClampEnable is TRUE */
+	unsigned short start_pixel;	/* only if bClampEnable is TRUE */
+	unsigned short sgain;	/* only if bClampEnable is TRUE */
+	unsigned short dc_sub;	/* only if bClampEnable is FALSE */
+};
+
+/* structure for Black Level Compensation */
+struct black_compensation {
+	char r_comp;		/* Constant value to subtract from Red component */
+	char gr_comp;		/* Constant value to subtract from Gr component */
+	char b_comp;		/* Constant value to subtract from Blue component */
+	char gb_comp;		/* Constant value to subtract from Gb component */
+};
+
+/* structure for fault pixel correction */
+struct fault_pixel {
+	bool fpc_enable;	/*Enable or Disable fault pixel correction */
+	unsigned short fp_num;	/*Number of fault pixel */
+	unsigned int fpc_table_addr;	/*Address of fault pixel table */
+
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode passed 
+ * by application
+ */
+typedef struct ccdc_config_params_raw {
+
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	bool image_invert_enable;	/* enable to store the image in inverse
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for 
+						   Black Compensation */
+	struct fault_pixel fault_pxl;	/* Structure for Fault Pixel 
+					   Module Configuration */
+} ccdc_config_params_raw;
+
+typedef struct ccdc_params_ycbcr {
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	int bt656_enable;	/* enable BT.656 embedded sync mode */
+	ccdc_pixorder pix_order;	/* cb:y:cr:y or y:cb:y:cr in memory */
+	ccdc_buftype buf_type;	/* interleaved or separated fields  */
+
+} ccdc_params_ycbcr;
+
+#define VPFE_CMD_CONFIG_CCDC_YCBCR \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 1,ccdc_params_ycbcr)
+#define VPFE_CMD_CONFIG_CCDC_RAW \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 4,ccdc_config_params_raw)
+
+#ifdef __KERNEL__
+
+/* Structure for CCDC configuration parameters for raw capture mode */
+typedef struct ccdc_params_raw {
+
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	ccdc_buftype buf_type;	/* interleaved or separated fields */
+	bool image_invert_enable;	/* enable to store the image in inverse 
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for 
+						   Black Compensation */
+	struct fault_pixel fault_pxl;	/* Structure for Fault Pixel 
+					   Module Configuration */
+} ccdc_params_raw;
+
+extern ccdc_params_raw ccdc_hw_params_raw;
+extern ccdc_params_ycbcr ccdc_hw_params_ycbcr;
+
+static inline enum data_size ccdc_raw_data_size(void)
+{
+	return ccdc_hw_params_raw.data_sz;
+}
+
+static inline bool ccdc_alaw_enable(void)
+{
+	return ccdc_hw_params_raw.alaw.b_alaw_enable;
+}
+
+static inline void ccdc_set_frame_format(enum hw_frame frame_type,
+					 ccdc_frmfmt frame_format)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.frm_fmt = frame_format;
+	else
+		ccdc_hw_params_raw.frm_fmt = frame_format;
+}
+
+static inline ccdc_frmfmt ccdc_get_frame_format(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.frm_fmt;
+	else
+		return ccdc_hw_params_raw.frm_fmt;
+}
+
+static inline void ccdc_set_buf_type(enum hw_frame frame_type,
+				     ccdc_buftype buf_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.buf_type = buf_type;
+	else
+		ccdc_hw_params_raw.buf_type = buf_type;
+}
+
+static inline ccdc_buftype ccdc_get_buf_type(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.buf_type;
+	else
+		return ccdc_hw_params_raw.buf_type;
+}
+
+static inline void ccdc_get_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin * win)
+{
+	if (frame_type == CCDC_YCBCR)
+		*win = ccdc_hw_params_ycbcr.win;
+	else
+		*win = ccdc_hw_params_raw.win;
+}
+
+static inline void ccdc_set_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin win)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.win = win;
+	else
+		ccdc_hw_params_raw.win = win;
+}
+
+static inline void ccdc_set_pix_order(ccdc_pixorder order)
+{
+	ccdc_hw_params_ycbcr.pix_order = order;
+}
+static inline ccdc_pixorder ccdc_get_pix_order(void)
+{
+	return ccdc_hw_params_ycbcr.pix_order;
+}
+
+/**************************************************************************\
+* Register OFFSET Definitions
+\**************************************************************************/
+#define PID                             (0x0)
+#define PCR                             (0x4)
+#define SYN_MODE                        (0x8)
+#define HD_VD_WID                       (0xc)
+#define PIX_LINES                       (0x10)
+#define HORZ_INFO                       (0x14)
+#define VERT_START                      (0x18)
+#define VERT_LINES                      (0x1c)
+#define CULLING                         (0x20)
+#define HSIZE_OFF                       (0x24)
+#define SDOFST                          (0x28)
+#define SDR_ADDR                        (0x2c)
+#define CLAMP                           (0x30)
+#define DCSUB                           (0x34)
+#define COLPTN                          (0x38)
+#define BLKCMP                          (0x3c)
+#define FPC                             (0x40)
+#define FPC_ADDR                        (0x44)
+#define VDINT                           (0x48)
+#define ALAW                            (0x4c)
+#define REC656IF                        (0x50)
+#define CCDCFG                          (0x54)
+#define FMTCFG                          (0x58)
+#define FMT_HORZ                        (0x5c)
+#define FMT_VERT                        (0x60)
+#define FMT_ADDR0                       (0x64)
+#define FMT_ADDR1                       (0x68)
+#define FMT_ADDR2                       (0x6c)
+#define FMT_ADDR3                       (0x70)
+#define FMT_ADDR4                       (0x74)
+#define FMT_ADDR5                       (0x78)
+#define FMT_ADDR6                       (0x7c)
+#define FMT_ADDR7                       (0x80)
+#define PRGEVEN_0                       (0x84)
+#define PRGEVEN_1                       (0x88)
+#define PRGODD_0                        (0x8c)
+#define PRGODD_1                        (0x90)
+#define VP_OUT                          (0x94)
+
+#define CCDC_IOBASE_VADDR               IO_ADDRESS(0x01c70400)
+
+#define regw(val, reg)    		outl(val, (reg)+CCDC_IOBASE_VADDR)
+#define regr(reg)         		inl((reg)+CCDC_IOBASE_VADDR)
+
+#define VPSS_SB_IOBASE_VADDR		IO_ADDRESS(0x01c73400)
+#define regw_sb(val, reg)    		outl(val, (reg)+VPSS_SB_IOBASE_VADDR)
+#define regr_sb(reg)         		inl((reg)+VPSS_SB_IOBASE_VADDR)
+
+/***************************************************************
+*	Define for various register bit mask and shifts for CCDC
+****************************************************************/
+#define CCDC_FID_POL_MASK			(0x01)
+#define CCDC_FID_POL_SHIFT			(4)
+#define CCDC_HD_POL_MASK			(0x01)
+#define CCDC_HD_POL_SHIFT			(3)
+#define CCDC_VD_POL_MASK			(0x01)
+#define CCDC_VD_POL_SHIFT			(2)
+#define CCDC_HSIZE_OFF_MASK			(0xffffffe0)
+#define CCDC_32BYTE_ALIGN_VAL			(31)
+#define CCDC_FRM_FMT_MASK			(0x01)
+#define CCDC_FRM_FMT_SHIFT			(7  )
+#define CCDC_DATA_SZ_MASK			(0x07)
+#define CCDC_DATA_SZ_SHIFT			(8)
+#define CCDC_PIX_FMT_MASK			(0x03)
+#define CCDC_PIX_FMT_SHIFT			(12)
+#define CCDC_VP2SDR_DISABLE			(0xFFFBFFFF)
+#define CCDC_WEN_ENABLE				(0x01 << 17)
+#define CCDC_SDR2RSZ_DISABLE			(0xFFF7FFFF)
+#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
+#define CCDC_LPF_ENABLE				(0x01 << 14)
+#define CCDC_ALAW_ENABLE			(0x01 << 3 )
+#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
+#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 31)
+#define CCDC_BLK_SGAIN_MASK			(0x1F )
+#define CCDC_BLK_ST_PXL_MASK			(0x7FFF)
+#define CCDC_BLK_ST_PXL_SHIFT			(10)
+#define CCDC_BLK_SAMPLE_LN_MASK			(0x07)
+#define CCDC_BLK_SAMPLE_LN_SHIFT		(28)
+#define CCDC_BLK_SAMPLE_LINE_MASK		(0x07)
+#define CCDC_BLK_SAMPLE_LINE_SHIFT		(25)
+#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
+#define CCDC_BLK_COMP_MASK			(0x000000FF)
+#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
+#define CCDC_BLK_COMP_GR_COMP_SHIFT		(16)
+#define CCDC_BLK_COMP_R_COMP_SHIFT		(24)
+#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
+#define CCDC_FPC_ENABLE				(0x01 << 15)
+#define CCDC_FPC_DISABLE			(0x0)
+#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
+#define CCDC_DATA_PACK_ENABLE			(0x01<<11)
+#define CCDC_FMTCFG_VPIN_MASK			(0x07)
+#define CCDC_FMTCFG_VPIN_SHIFT			(12)
+#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16 )
+#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16 )
+#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
+#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
+#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
+#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
+#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
+#define CCDC_HORZ_INFO_SPH_SHIFT		(16)
+#define CCDC_VERT_START_SLV0_SHIFT		(16)
+#define CCDC_VDINT_VDINT0_SHIFT			(16)
+#define CCDC_VDINT_VDINT1_MASK			(0xFFFF)
+
+/* SBL register and mask defination */
+#define SBL_PCR_VPSS				(4)
+#define SBL_PCR_CCDC_WBL_O			(0xFF7FFFFF)
+
+#define PPC_RAW					(1)
+#define DCSUB_DEFAULT_VAL			(0)
+#define CLAMP_DEFAULT_VAL			(0)
+#define ENABLE_VIDEO_PORT			(0x00008000)
+#define DISABLE_VIDEO_PORT			(0)
+#define CCDC_COLPTN_VAL				(0xBB11BB11)
+#define TWO_BYTES_PER_PIXEL			(2)
+#define INTERLACED_IMAGE_INVERT			(0x4B6D)
+#define INTERLACED_NO_IMAGE_INVERT		(0x0249)
+#define PROGRESSIVE_IMAGE_INVERT		(0x4000)
+#define PROGRESSIVE_NO_IMAGE_INVERT		(0)
+#define CCDC_INTERLACED_HEIGHT_SHIFT		(1)
+
+extern void ccdc_reset(void);
+extern void ccdc_init(void);
+extern void ccdc_cleanup(void);
+
+extern void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc);
+void ccdc_config_ycbcr(void);
+void ccdc_config_raw(void);
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam);
+int ccdc_update_ycbcr_params(void *);
+int ccdc_update_raw_params(void *);
+
+/* inline functions that must be fast because they are called frequently */
+static inline void ccdc_vdhd_enable(int flag)
+{
+	unsigned int syn_mode;
+	syn_mode = regr(SYN_MODE);
+	syn_mode =
+	    (flag) ? (syn_mode | CCDC_VDHDEN_ENABLE) : (syn_mode &
+							(!CCDC_VDHDEN_ENABLE));
+
+	/* configure internal timing generator */
+	regw(syn_mode, SYN_MODE);
+}
+
+static inline void ccdc_enable(int flag)
+{
+	regw(flag, PCR);
+}
+
+static inline void ccdc_setfbaddr(unsigned long paddr)
+{
+	regw(paddr & 0xffffffe0, SDR_ADDR);
+}
+
+static inline int ccdc_getfid(void)
+{
+	int fid = (regr(SYN_MODE) >> 15) & 0x1;
+	return fid;
+}
+
+static inline int ccdc_sbl_reset(void)
+{
+	int sb_reset;
+	sb_reset = regr_sb(SBL_PCR_VPSS);
+	regw_sb((sb_reset & SBL_PCR_CCDC_WBL_O), SBL_PCR_VPSS);
+	return sb_reset;
+}
+
+static inline void ccdc_enable_vport(void)
+{
+	/* enable video port */
+	regw(ENABLE_VIDEO_PORT, FMTCFG);
+}
+
+#endif
+
+#endif				/* CCDC_DAVINCI_H */
Index: linux-2.6.10/include/media/davinci/davinci_vpfe.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/davinci_vpfe.h
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_vpfe.h */
+
+#ifndef DAVINCI_VPFE_H
+#define DAVINCI_VPFE_H
+
+#include <media/davinci/tvp5146.h>
+#include <media/davinci/mt9t001.h>
+#include <linux/videodev.h>
+
+/* vpfe specific video standards */
+#define VPFE_STD_625_50_SQP ((V4L2_STD_625_50)<<32)
+#define VPFE_STD_525_60_SQP ((V4L2_STD_525_60)<<32)
+#define VPFE_STD_AUTO ((v4l2_std_id)(0x1000000000000000ULL))
+#define VPFE_STD_AUTO_SQP ((v4l2_std_id)(0x2000000000000000ULL))
+
+#define VPFE_CMD_LATEST_FRM_ONLY \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 2,int)
+#define VPFE_CMD_CONFIG_TVP5146 \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 3,tvp5146_params)
+#define VPFE_CMD_S_MT9T001_PARAMS \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 5,struct mt9t001_params)
+#define VPFE_CMD_G_MT9T001_PARAMS \
+			_IOR('V',BASE_VIDIOC_PRIVATE + 6,struct mt9t001_params)
+
+/* V4L2 defines added for new standards, 
+					  these will be moved to videodev2.h */
+#define V4L2_STD_MT9T001_VGA_30FPS	(10)
+#define V4L2_STD_MT9T001_VGA_60FPS	(11)
+#define V4L2_STD_MT9T001_SVGA_30FPS	(12)
+#define V4L2_STD_MT9T001_SVGA_60FPS	(13)
+#define V4L2_STD_MT9T001_XGA_30FPS	(14)
+#define V4L2_STD_MT9T001_480p_30FPS	(15)
+#define V4L2_STD_MT9T001_480p_60FPS	(16)
+#define V4L2_STD_MT9T001_576p_25FPS	(17)
+#define V4L2_STD_MT9T001_576p_50FPS	(18)
+#define V4L2_STD_MT9T001_720p_24FPS	(19)
+#define V4L2_STD_MT9T001_720p_30FPS	(20)
+#define V4L2_STD_MT9T001_1080p_18FPS	(21)
+
+/* Define for device type to be passed in init */
+#define 	MT9T001	0
+#define		TVP5146	1
+#define 	MT9T031	2
+
+#ifdef __KERNEL__
+
+#include <media/video-buf.h>
+
+#define VPFE_MAJOR_RELEASE 0
+#define VPFE_MINOR_RELEASE 0
+#define VPFE_BUILD         1
+
+#define VPFE_VERSION_CODE \
+     (VPFE_MAJOR_RELEASE<<16)  | (VPFE_MINOR_RELEASE<<8) | VPFE_BUILD
+
+/* By default, the driver is setup for auto-swich mode */
+#define VPFE_DEFAULT_STD VPFE_STD_AUTO
+
+#define VPFE_PIXELASPECT_NTSC 		{11, 10}
+#define VPFE_PIXELASPECT_PAL  		{54, 59}
+#define VPFE_PIXELASPECT_NTSC_SP    	{1, 1}
+#define VPFE_PIXELASPECT_PAL_SP     	{1, 1}
+#define VPFE_PIXELASPECT_DEFAULT    	{1, 1}
+
+/* Buffer size defines for TVP5146 and MT9T001 */
+#define VPFE_TVP5146_MAX_FRAME_WIDTH      768	/* for PAL Sqpixel mode */
+#define VPFE_TVP5146_MAX_FRAME_HEIGHT     576	/* for PAL              */
+/* 4:2:2 data */
+#define VPFE_TVP5146_MAX_FBUF_SIZE      \
+		 (VPFE_TVP5146_MAX_FRAME_WIDTH*VPFE_TVP5146_MAX_FRAME_HEIGHT*2)
+
+#define VPFE_MT9T001_MAX_FRAME_WIDTH     (1920)
+#define VPFE_MT9T001_MAX_FRAME_HEIGHT    (1080)
+/* 2 BYTE FOR EACH PIXEL */
+#define VPFE_MT9T001_MAX_FBUF_SIZE       \
+		(VPFE_MT9T001_MAX_FRAME_WIDTH*VPFE_MT9T001_MAX_FRAME_HEIGHT*2)
+
+/* frame buffers allocate at driver initialization time */
+#define VPFE_DEFNUM_FBUFS             3
+
+/* Defines for number of lines for all formats */
+#define FMT_VGA_NUMLINES				(480 + NUM_EXTRALINES)
+#define FMT_SVGA_NUMLINES				(600 + NUM_EXTRALINES)
+#define FMT_XGA_NUMLINES				(768 + NUM_EXTRALINES)
+#define FMT_480p_NUMLINES				(480 + NUM_EXTRALINES)
+#define FMT_576p_NUMLINES				(576 + NUM_EXTRALINES)
+#define FMT_720p_NUMLINES				(720 + NUM_EXTRALINES)
+#define FMT_1080i_NUMLINES				(1080)
+
+/* Defines for FPS values */
+#define FPS_18_NUMERATOR				(1)
+#define FPS_18_DENOMIRATOR				(18)
+#define FPS_24_NUMERATOR				(1)
+#define FPS_24_DENOMIRATOR  				(24)
+#define FPS_25_NUMERATOR				(1)
+#define FPS_25_DENOMIRATOR  				(25)
+#define FPS_30_NUMERATOR				(1)
+#define FPS_30_DENOMIRATOR  				(30)
+#define FPS_50_NUMERATOR    				(1)
+#define FPS_50_DENOMIRATOR  				(50)
+#define FPS_60_NUMERATOR    				(1)
+#define FPS_60_DENOMIRATOR  				(60)
+
+/* Device configuration function pointer */
+typedef int (*device_cfg_fxn) (unsigned int cmd, void *arg, void *params);
+
+typedef struct vpfe_obj {
+	struct video_device *video_dev;
+	struct videobuf_queue bufqueue;	/* queue with frame buffers      */
+	struct list_head dma_queue;
+	u32 latest_only;	/* indicate whether to return the most */
+	/* recent captured buffers only        */
+	u32 usrs;
+	u32 io_usrs;
+	struct v4l2_prio_state prio;
+	v4l2_std_id std;
+	struct v4l2_rect vwin;
+	struct v4l2_rect bounds;
+	struct v4l2_fract pixelaspect;
+	spinlock_t irqlock;
+	struct semaphore lock;
+	enum v4l2_field field;
+	u32 pixelfmt;
+	u32 numbuffers;
+	u8 *fbuffers[VIDEO_MAX_FRAME];
+	struct videobuf_buffer *curFrm;
+	struct videobuf_buffer *nextFrm;
+	int field_id;
+	int mode_changed;
+	int started;
+	int field_offset;
+	unsigned char capture_device;	/*set in vpfe_init()
+					   (1=TVP5146, 0=MT9T001) */
+	tvp5146_params tvp5146_params;
+	void *device_params;	/*Pointer for video device. (MT9T001) */
+	//ccdc_params_raw ccdc_params_raw;      /*Object for CCDC raw mode */
+	//ccdc_params_ycbcr ccdc_params_ycbcr;  /*Object for CCDC ycbcr mode */
+	device_cfg_fxn config_dev_fxn;	/*where,typedef int(*deviceCfg_Fxn)
+					   (Uns cmd, void *arg, void *params); */
+
+} vpfe_obj;
+
+/* file handle */
+typedef struct vpfe_fh {
+	struct vpfe_obj *dev;
+	int io_allowed;
+	enum v4l2_priority prio;
+} vpfe_fh;
+#endif
+
+#endif				/* DAVINCI_VPFE_H */
Index: linux-2.6.10/include/media/davinci/mt9t001.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/mt9t001.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*mt9t001.h*/
+
+#ifndef	MT9T001_H
+#define	MT9T001_H
+
+/*********************************
+ * Defines and Macros and globals
+ ********************************/
+
+#ifdef	TRUE
+#undef	TRUE
+#endif
+
+#ifdef	FALSE
+#undef	FALSE
+#endif
+
+#define	TRUE 	1
+#define	FALSE	0
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+
+#ifndef TYPES
+#define TYPES
+typedef unsigned char bool;
+#endif
+
+#define DEBUG
+
+#ifdef __KERNEL__
+
+extern int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
+
+/* defines for extra pixels/line added */
+#define MT9T001_EXTRAPIXELS 16
+#define MT9T001_EXTRALINES	  8
+
+/* Definitions to access the various sensor registers */
+#define MT9T001_CHIP_VERSION			(0x00)
+#define MT9T001_ROW_START			(0x01)
+#define MT9T001_COL_START			(0x02)
+#define MT9T001_HEIGHT				(0x03)
+#define MT9T001_WIDTH				(0x04)
+#define MT9T001_HBLANK				(0x05)
+#define MT9T001_VBLANK				(0x06)
+#define MT9T001_OUTPUT_CTRL			(0x07)
+#define MT9T001_SHUTTER_WIDTH_UPPER		(0x08)
+#define MT9T001_SHUTTER_WIDTH			(0x09)
+#define MT9T001_PIXEL_CLK_CTRL			(0x0A)
+#define MT9T001_RESTART				(0x0B)
+#define MT9T001_SHUTTER_DELAY			(0x0C)
+#define MT9T001_RESET				(0x0D)
+#define MT9T001_READ_MODE1			(0x1E)
+#define MT9T001_READ_MODE2			(0x20)
+#define MT9T001_READ_MODE3			(0x21)
+#define MT9T001_ROW_ADDR_MODE			(0x22)
+#define MT9T001_COL_ADDR_MODE			(0x23)
+#define MT9T001_RESERVED_27_REG                 (0x27)
+#define MT9T001_GREEN1_GAIN			(0x2B)
+#define MT9T001_BLUE_GAIN			(0x2C)
+#define MT9T001_RED_GAIN			(0x2D)
+#define MT9T001_GREEN2_GAIN			(0x2E)
+#define MT9T001_GLOBAL_GAIN			(0x35)
+#define MT9T001_BLACK_LEVEL			(0x49)
+#define MT9T001_ROW_BLK_DEF_OFFSET		(0x4B)
+#define MT9T001_RESERVED_4E_REG                 (0x4e)
+#define MT9T001_RESERVED_50_REG                 (0x50)
+#define MT9T001_RESERVED_51_REG                 (0x51)
+#define MT9T001_RESERVED_52_REG                 (0x52)
+#define MT9T001_RESERVED_53_REG                 (0x53)
+#define MT9T001_CAL_COARSE			(0x5D)
+#define MT9T001_CAL_TARGET			(0x5F)
+#define MT9T001_GREEN1_OFFSET			(0x60)
+#define MT9T001_GREEN2_OFFSET			(0x61)
+#define MT9T001_BLK_LVL_CALIB			(0x62)
+#define MT9T001_RED_OFFSET			(0x63)
+#define MT9T001_BLUE_OFFSET			(0x64)
+#define MT9T001_CHIP_ENABLE_SYNC		(0xF8)
+#define MT9T001_CHIP_VERSION_END		(0xFF)
+
+/* Define Shift and Mask for gain register*/
+
+#define	MT9T001_ANALOG_GAIN_SHIFT	(0x0000)
+#define	MT9T001_DIGITAL_GAIN_SHIFT	(8)
+#define	MT9T001_ANALOG_GAIN_MASK	(0x007F)
+#define	MT9T001_DIGITAL_GAIN_MASK	(0x7F00)
+
+/* Define Shift and Mask for black level caliberation register*/
+
+#define	MT9T001_MANUAL_OVERRIDE_MASK		(0x0001)
+#define	MT9T001_DISABLE_CALLIBERATION_SHIFT	(1)
+#define	MT9T001_DISABLE_CALLIBERATION_MASK	(0x0002)
+#define	MT9T001_RECAL_BLACK_LEVEL_SHIFT		(12)
+#define	MT9T001_RECAL_BLACK_LEVEL_MASK		(0x1000)
+#define	MT9T001_LOCK_RB_CALIBRATION_SHIFT	(13)
+#define	MT9T001_LOCK_RB_CALLIBERATION_MASK	(0x2000)
+#define	MT9T001_LOCK_GREEN_CALIBRATION_SHIFT	(14)
+#define	MT9T001_LOCK_GREEN_CALLIBERATION_MASK	(0x4000)
+#define	MT9T001_LOW_COARSE_THELD_MASK		(0x007F)
+#define	MT9T001_HIGH_COARSE_THELD_SHIFT		(8)
+#define	MT9T001_HIGH_COARSE_THELD_MASK		(0x7F00)
+#define	MT9T001_LOW_TARGET_THELD_MASK		(0x007F)
+#define	MT9T001_HIGH_TARGET_THELD_SHIFT		(8)
+#define	MT9T001_HIGH_TARGET_THELD_MASK		(0x7F00)
+#define	MT9T001_SHUTTER_WIDTH_LOWER_MASK	(0xFFFF)
+#define	MT9T001_SHUTTER_WIDTH_UPPER_SHIFT	(16)
+#define	MT9T001_SHUTTER_WIDTH_UPPER_MASK	(0xFFFF)
+#define	MT9T001_ROW_START_MASK			(0x07FF)
+#define	MT9T001_COL_START_MASK			(0x0FFF)
+#define	 MT9T001_GREEN1_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_GREEN2_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_RED_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_BLUE_OFFSET_MASK 		(0x01FF)
+
+/* defines for MT9T001 register values */
+#define	MT9T001_NORMAL_OPERATION_MODE		(0x0002)
+#define	MT9T001_HALT_MODE			(0x0003)
+#define MT9T001_RESET_ENABLE			(0x0001)
+#define MT9T001_RESET_DISABLE			(0x0000)
+#define	MT9T001_INVERT_PIXEL_CLK		(0x8000)
+#define MT9T001_GAIN_MINVAL			(0)
+#define MT9T001_GAIN_MAXVAL			(128)
+#define MT9T001_GAIN_STEP			(1)
+#define MT9T001_GAIN_DEFAULTVAL			(8)
+
+/* Default values for MT9T001 registers */
+#define MT9T001_ROW_START_DEFAULT		(0x14)
+#define MT9T001_COL_START_DEFAULT		(0x20)
+#define MT9T001_HEIGHT_DEFAULT			(0x5FF)
+#define MT9T001_WIDTH_DEFAULT			(0x7FF)
+#define MT9T001_HBLANK_DEFAULT			(0x8E)
+#define MT9T001_VBLANK_DEFAULT			(0x19)
+#define MT9T001_OUTPUT_CTRL_DEFAULT		(0x02)
+#define MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT	(0x0)
+#define MT9T001_SHUTTER_WIDTH_DEFAULT		(0x619)
+#define MT9T001_PIXEL_CLK_CTRL_DEFAULT		(0x0)
+#define MT9T001_RESTART_DEFAULT			(0x0)
+#define MT9T001_SHUTTER_DELAY_DEFAULT		(0x0)
+#define MT9T001_READ_MODE1_DEFAULT		(0xC040)
+#define MT9T001_READ_MODE2_DEFAULT		(0x0)
+#define MT9T001_READ_MODE3_DEFAULT		(0x0)
+#define MT9T001_ROW_ADDR_MODE_DEFAULT		(0x0)
+#define MT9T001_COL_ADDR_MODE_DEFAULT		(0x0)
+#define MT9T001_GREEN1_GAIN_DEFAULT		(0x08)
+#define MT9T001_BLUE_GAIN_DEFAULT		(0x08)
+#define MT9T001_RED_GAIN_DEFAULT		(0x08)
+#define MT9T001_GREEN2_GAIN_DEFAULT		(0x08)
+#define MT9T001_GLOBAL_GAIN_DEFAULT		(0x08)
+#define MT9T001_BLACK_LEVEL_DEFAULT		(0xA8)
+#define MT9T001_CAL_COARSE_DEFAULT		(0x2D13)
+#define MT9T001_CAL_TARGET_DEFAULT		(0x231D)
+#define MT9T001_GREEN1_OFFSET_DEFAULT		(0x20)
+#define MT9T001_GREEN2_OFFSET_DEFAULT		(0x20)
+#define MT9T001_BLK_LVL_CALIB_DEFAULT		(0x0)
+#define MT9T001_RED_OFFSET_DEFAULT		(0x20)
+#define MT9T001_BLUE_OFFSET_DEFAULT		(0x20)
+#define MT9T001_CHIP_ENABLE_SYNC_DEFAULT	(0x01)
+
+#define MT9T001_I2C_REGISTERED			(1)
+#define MT9T001_I2C_UNREGISTERED		(0)
+
+/*	Defines for mt9t001_ctrl() functions command*/
+
+#define	MT9T001_SET_PARAMS	1
+#define	MT9T001_GET_PARAMS	2
+#define	MT9T001_SET_GAIN	3
+#define	MT9T001_SET_STD		4
+#define	MT9T001_INIT		5
+#define	MT9T001_CLEANUP		6
+#define MT9T001_ENABLE_I2C_SWITCH 7
+
+/* define for various video format supported by MT9T001 driver */
+/* Here all mode defines will be assigned values of v4l2 mode defines */
+#define	MT9T001_MODE_VGA_30FPS  	(10)
+#define	MT9T001_MODE_VGA_60FPS		(11)
+#define	MT9T001_MODE_SVGA_30FPS		(12)
+#define	MT9T001_MODE_SVGA_60FPS		(13)
+#define	MT9T001_MODE_XGA_30FPS		(14)
+#define	MT9T001_MODE_480p_30FPS		(15)
+#define	MT9T001_MODE_480p_60FPS		(16)
+#define	MT9T001_MODE_576p_25FPS		(17)
+#define	MT9T001_MODE_576p_50FPS		(18)
+#define	MT9T001_MODE_720p_24FPS		(19)
+#define	MT9T001_MODE_720p_30FPS		(20)
+#define	MT9T001_MODE_1080p_18FPS	(21)
+
+/*i2c adress for MT9T001*/
+#define MT9T001_I2C_ADDR  		(0xBA >>1)
+
+/*i2c adress for ECP*/
+#define ECP_I2C_ADDR  			(0x25)
+#define ECP_I2C_CONFIG			(2)
+#define ECP_REGADDR			(0x08)
+#define ECP_REGVAL			(0x80)
+#define ECP_RSTADDR			(0x02)
+
+/*i2c adress for PCA9543A*/
+#define PCA9543A_I2C_ADDR  		(0x73)
+#define PCA9543A_I2C_CONFIG		(0)
+#define PCA9543A_REGVAL			(0x01)
+
+#define MT9T001_I2C_CONFIG		(1)
+#define I2C_ONE_BYTE_TRANSFER		(1)
+#define I2C_TWO_BYTE_TRANSFER		(2)
+#define I2C_THREE_BYTE_TRANSFER		(3)
+#define I2C_TXRX_DATA_MASK		(0x00FF)
+#define I2C_TXRX_DATA_MASK_UPPER	(0xFF00)
+#define I2C_TXRX_DATA_SHIFT		(8)
+
+#endif				/* endif of __KERNEL__ */
+
+/* Structure containing video standard dependent settings */
+struct mt9t001_format_params {
+	unsigned short col_size;	/* width */
+	unsigned short row_size;	/* Height */
+	unsigned short h_blank;
+	unsigned short v_blank;
+	unsigned int shutter_width;
+	unsigned short row_addr_mode;
+	unsigned short col_addr_mode;
+	unsigned short black_level;
+	unsigned short pixel_clk_control;
+	unsigned short row_start;
+	unsigned short col_start;
+};
+
+/* Structure for gain settings */
+struct mt9t001_rgb_gain {
+	unsigned char green1_analog_gain;
+	unsigned char red_analog_gain;
+	unsigned char blue_analog_gain;
+	unsigned char green2_analog_gain;
+	unsigned char green1_digital_gain;
+	unsigned char red_digital_gain;
+	unsigned char blue_digital_gain;
+	unsigned char green2_digital_gain;
+};
+/* structure for black level calibration setttings*/
+struct mt9t001_black_level_calibration {
+	bool manual_override;
+	bool disable_calibration;
+	bool recalculate_black_level;
+	bool lock_red_blue_calibration;
+	bool lock_green_calibration;
+	unsigned char low_coarse_thrld;
+	unsigned char high_coarse_thrld;
+	unsigned char low_target_thrld;
+	unsigned char high_target_thrld;
+	unsigned short green1_offset;
+	unsigned short green2_offset;
+	unsigned short red_offset;
+	unsigned short blue_offset;
+};
+
+/* structure for MT9T001 configuration setttings passed by application*/
+struct mt9t001_params {
+	struct mt9t001_format_params format;
+	struct mt9t001_rgb_gain rgb_gain;
+	struct mt9t001_black_level_calibration black_calib;
+};
+
+#endif				/*for  ifndef MT9T001 */
Index: linux-2.6.10/include/media/davinci/tvp5146.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/media/davinci/tvp5146.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* tvp5146.h file */
+
+#ifndef TVP5146_H
+#define TVP5146_H
+
+#ifdef TRUE
+#undef TRUE
+#endif
+#ifdef FALSE
+#undef FALSE
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+/* analog muxing mode */
+#define    TVP5146_AMUX_COMPOSITE  0
+#define    TVP5146_AMUX_SVIDEO     1
+
+typedef enum {
+	TVP5146_MODE_INV = -1,
+	TVP5146_MODE_AUTO = 0,	/* autoswitch mode (default)   */
+	TVP5146_MODE_NTSC = 1,	/* (M, J) NTSC      525-line   */
+	TVP5146_MODE_PAL = 2,	/* (B, D, G, H, I, N) PAL      */
+	TVP5146_MODE_PAL_M = 3,	/* (M) PAL          525-line   */
+	TVP5146_MODE_PAL_CN = 4,	/* (Combination-N) PAL         */
+	TVP5146_MODE_NTSC_443 = 5,	/* NTSC 4.43        525-line   */
+	TVP5146_MODE_SECAM = 6,	/* SECAM                       */
+	TVP5146_MODE_PAL_60 = 7,	/* PAL 60          525-line    */
+	TVP5146_MODE_AUTO_SQP = 8,	/* autoswitch mode (default)   */
+	TVP5146_MODE_NTSC_SQP = 9,	/* (M, J) NTSC      525-line   */
+	TVP5146_MODE_PAL_SQP = 0xA,	/* (B, D, G, H, I, N) PAL      */
+	TVP5146_MODE_PAL_M_SQP = 0xB,	/* (M) PAL          525-line   */
+	TVP5146_MODE_PAL_CN_SQP = 0xC,	/* (Combination-N) PAL         */
+	TVP5146_MODE_NTSC_443_SQP = 0xD,	/* NTSC 4.43 525-line   */
+	TVP5146_MODE_SECAM_SQP = 0xE,	/* SECAM                       */
+	TVP5146_MODE_PAL_60_SQP = 0xF,	/* PAL 60          525-line    */
+} tvp5146_mode;
+
+ /* Enum for TVP5146 output data width */
+typedef enum tvp5146_datawidth {
+	TVP5146_WIDTH_16BIT,
+	TVP5146_WIDTH_8BIT
+} tvp5146_datawidth_t;
+
+typedef struct {
+	tvp5146_mode mode;
+	int amuxmode;
+	int enablebt656sync;
+	tvp5146_datawidth_t data_width;
+} tvp5146_params;
+
+#ifdef __KERNEL__
+
+typedef struct {
+	int agc_enable;
+	tvp5146_mode video_std;
+	int brightness;
+	int contrast;
+	int saturation;
+	int hue;
+	int field_rate;		/* 50 or 60 in Hz */
+	int lost_lock;
+	int csubc_lock;
+	int v_lock;
+	int h_lock;
+} tvp5146_status;
+
+typedef unsigned int tvp5146_cmd;
+
+/* commands for setup the decoder */
+#define TVP5146_SET_AMUXMODE        4
+#define TVP5146_SET_BRIGHTNESS      5
+#define TVP5146_SET_CONTRAST        6
+#define TVP5146_SET_HUE             7
+#define TVP5146_SET_SATURATION      8
+#define TVP5146_SET_AGC             9
+#define TVP5146_SET_VIDEOSTD        10
+#define TVP5146_CLR_LOSTLOCK        11
+#define TVP5146_CONFIG              12
+#define TVP5146_RESET               13
+#define TVP5146_POWERDOWN           14
+
+#define TVP5146_GET_STATUS          15
+#define TVP5146_GET_STD             16
+#define TVP5146_INIT                17
+#define TVP5146_CLEANUP             18
+
+#define TVP5146_I2C_ADDR (0xBA >> 1)
+
+/* Defines for TVP5146 register address */
+#define TVP5146_OUTPUT1                 	(0x33)
+#define TVP5146_OUTPUT2                 	(0x34)
+#define TVP5146_OUTPUT3				(0x35)
+#define TVP5146_OUTPUT4				(0x36)
+#define TVP5146_OUTPUT5				(0x37)
+#define TVP5146_OUTPUT6				(0x38)
+
+#define TVP5146_I2C_REGISTERED			(1)
+#define TVP5146_I2C_UNREGISTERED		(0)
+
+extern int tvp5146_ctrl(tvp5146_cmd cmd, void *arg);
+
+#endif
+#endif
Index: linux-2.6.10/mvl_patches/pro-1694.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1694.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1694);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

