#! /usr/bin/env bash
# Patch: -ppc_mpc7448_mvsata
# Date: Fri Feb 16 17:32:41 2007
# Source: Marvell International Ltd., via Freescale Semiconductor, Inc.
# MR: 19074
# Type: Enhancement
# Disposition: local, has been superseded by sata_mv driver in current 2.6 tree
# Signed-off-by: Dale Farnsworth <dfarnsworth@mvista.com
# Description:
# 
# This patch adds support for the Marvell 88SX50XX SATA controllers.
# 

PATCHNUM=1115
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Marvell International Ltd., via Freescale Semiconductor, Inc.
MR: 19074
Type: Enhancement
Disposition: local, has been superseded by sata_mv driver in current 2.6 tree
Signed-off-by: Dale Farnsworth <dfarnsworth@mvista.com
Description:

This patch adds support for the Marvell 88SX50XX SATA controllers.

Index: linux-2.6.10/drivers/scsi/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/scsi/Kconfig
+++ linux-2.6.10/drivers/scsi/Kconfig
@@ -250,6 +250,12 @@ config SCSI_3W_9XXX
 	  Please read the comments at the top of
 	  <file:drivers/scsi/3w-9xxx.c>.
 
+config SCSI_MVSATA
+	tristate "Marvell 88SX50XX SATA support"
+	depends on PCI && SCSI
+	help
+	  This driver supports the 85SX50XX series SATA chip from Marvell
+
 config SCSI_7000FASST
 	tristate "7000FASST SCSI support"
 	depends on ISA && SCSI
Index: linux-2.6.10/drivers/scsi/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/scsi/Makefile
+++ linux-2.6.10/drivers/scsi/Makefile
@@ -111,6 +111,7 @@ obj-$(CONFIG_SCSI_PLUTO)	+= pluto.o
 obj-$(CONFIG_SCSI_DECNCR)	+= NCR53C9x.o	dec_esp.o
 obj-$(CONFIG_BLK_DEV_3W_XXXX_RAID) += 3w-xxxx.o
 obj-$(CONFIG_SCSI_3W_9XXX)	+= 3w-9xxx.o
+obj-$(CONFIG_SCSI_MVSATA)       += mvsata/
 obj-$(CONFIG_SCSI_PPA)		+= ppa.o
 obj-$(CONFIG_SCSI_IMM)		+= imm.o
 obj-$(CONFIG_JAZZ_ESP)		+= NCR53C9x.o	jazz_esp.o
Index: linux-2.6.10/drivers/scsi/mvsata/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/Makefile
@@ -0,0 +1,13 @@
+#EXTRA_CFLAGS                   += -DDEBUG=1 -DMV_LOG_DEBUG -DLINUX -Idrivers/scsi
+EXTRA_CFLAGS                   += -DLINUX -Idrivers/scsi
+obj-$(CONFIG_SCSI_MVSATA)      += mvsata.o
+mvsata-y	               += mvLinuxIalLib.o \
+                                  mvLinuxIalHt.o \
+                                  mvLinuxIalOs.o \
+                                  mvIALCommon.o \
+                                  mvIALCommonUtils.o \
+                                  mvLinuxIalSmart.o \
+                                  mvSata.o \
+                                  mvStorageDev.o \
+                                  mvLog.o \
+                                  mvScsiAtaLayer.o
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALCommon.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALCommon.c
@@ -0,0 +1,2914 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvIALCommon.c
+*
+* DESCRIPTION:
+*       C implementation for IAL's common functions.
+*
+* DEPENDENCIES:
+*   mvIALCommon.h
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvOs.h"
+#include "mvScsiAtaLayer.h"
+#include "mvIALCommon.h"
+#include "mvIALCommonUtils.h"
+#include "mvStorageDev.h"
+
+
+/* defines */
+#undef DISABLE_PM_SCC
+/* typedefs */
+
+/*Static functions*/
+static MV_BOOLEAN mvGetEDMAAllowedModes(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_SAL_ADAPTER_EXTENSION *pScsiAdapterExt,
+                                        MV_U8 channelIndex,
+                                        MV_BOOLEAN *TCQ,
+                                        MV_BOOLEAN *NCQ,
+                                        MV_U8   *queueDepth,
+                                        MV_U8   *numOfDrives);
+
+static void mvFlushSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex);
+
+static void mvAddToSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex,
+                                    MV_SATA_SCSI_CMD_BLOCK *Scb);
+
+static MV_BOOLEAN mvAdapterStateMachine(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static MV_BOOLEAN mvChannelStateMachine(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex,
+                                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static void mvSetChannelState(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex,
+                              MV_CHANNEL_STATE state);
+
+
+/*PM related*/
+static MV_BOOLEAN mvPMCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                                          MV_U8 channelIndex,
+                                          MV_COMPLETION_TYPE comp_type,
+                                          MV_VOID_PTR commandId,
+                                          MV_U16 responseFlags,
+                                          MV_U32 timeStamp,
+                                          MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+
+static MV_BOOLEAN mvQueuePMAccessRegisterCommand(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_U8 PMPort,
+                                                MV_U8 PMReg,
+                                                MV_U32 Value,
+                                                MV_BOOLEAN isRead);
+
+
+
+
+static MV_BOOLEAN mvPMEstablishSataComm(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex);
+
+static MV_BOOLEAN mvPMCheckForConnectedDevices(
+                                              MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                              MV_U8 channelIndex,
+                                              MV_BOOLEAN* bIsChannelReady);
+
+
+static MV_BOOLEAN mvInitPMDevice(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                 MV_U8 channelIndex,
+                                 MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                 MV_BOOLEAN* bIsChannelReady,
+                                 MV_BOOLEAN* isDeviceReconnected,
+                                 MV_BOOLEAN* bPMErrorDetected);
+
+static MV_BOOLEAN mvPMEnableCommStatusChangeBits(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                 MV_U8 channelIndex,
+                                                 MV_BOOLEAN enable);
+
+static MV_BOOLEAN mvPMEnableAsyncNotify(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex);
+
+
+static void mvCheckPMForError(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex);
+
+/*End PM related*/
+
+static MV_BOOLEAN mvStartChannelInit(MV_SATA_ADAPTER *pSataAdapter,
+                                     MV_U8 channelIndex,
+                                     MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                     MV_BOOLEAN *isChannelReady);
+
+static MV_BOOLEAN mvChannelSRSTFinished(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_SATA_CHANNEL *pSataChannel,
+                                        MV_U8 channelIndex,
+                                        MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                        MV_BOOLEAN* bIsChannelReady,
+                                        MV_BOOLEAN* bFatalError);
+
+static MV_BOOLEAN mvConfigChannelQueuingMode(
+                                            MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                            MV_U8 channelIndex,
+                                            MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static MV_BOOLEAN mvConfigChannelDMA(
+                                    MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                    MV_U8 channelIndex,
+                                    MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static void mvSetChannelTimer(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex,
+                              MV_U32 timeout);
+static void mvDecrementChannelTimer(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex);
+static MV_BOOLEAN mvIsChannelTimerExpired(
+                                         MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                         MV_U8 channelIndex);
+
+
+/*Channel state machine*/
+
+
+static MV_BOOLEAN mvChannelNotConnectedStateHandler(
+                                                   MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                   MV_U8 channelIndex,
+                                                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+
+static MV_BOOLEAN mvChannelConnectedStateHandler(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+MV_BOOLEAN mvChannelInSrstStateHandler(
+                                      MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                      MV_U8 channelIndex,
+                                      MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static MV_BOOLEAN mvChannelPMStaggeredSpinUpStateHandler(
+                                                        MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                        MV_U8 channelIndex,
+                                                        MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static MV_BOOLEAN mvChannelPMSrstDeviceStateHandler(
+                                                   MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                   MV_U8 channelIndex,
+                                                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+static MV_BOOLEAN mvChannelReadyStateHandler(
+                                            MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                            MV_U8 channelIndex);
+
+static MV_BOOLEAN mvChannelPMHotPlugStateHandler(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+
+
+static void mvDrivesInfoSaveAll(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex);
+
+static void mvDrivesInfoFlushAll(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex);
+
+static void mvDrivesInfoFlushSingleDrive(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex, MV_U8 PMPort);
+
+static void mvDrivesInfoSaveSingleDrive(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                      MV_U8 channelIndex,
+                                      MV_U8 PMPort,
+                                      MV_BOOLEAN  isDriveAdded,
+                                      MV_U16_PTR identifyBuffer);
+
+static void mvSetDriveReady(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                            MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                            MV_U8 channelIndex,
+                            MV_U8 PMPort,
+                            MV_BOOLEAN  isReady,
+                            MV_U16_PTR identifyBuffer);
+
+static void mvDrivesInfoGetChannelRescanParams(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                              MV_U8 channelIndex,
+                                              MV_U16 *drivesToRemove,
+                                              MV_U16 *drivesToAdd);
+
+
+
+#ifdef DISABLE_PM_SCC
+MV_BOOLEAN mvPMDisableSSC(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex);
+#endif
+
+MV_BOOLEAN mvPMEnableLocking(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex);
+
+
+
+/*Public functions*/
+
+/*******************************************************************************
+* mvAdapterStartInitialization - start adapter initialization
+*
+* DESCRIPTION:
+*  Starts adapter initialization after driver load.
+*  State - machine related data structure is initialized for adapter
+*  and its channels. Begin staggered spin-up.
+*  Adapter state is changed to ADAPTER_READY.
+* INPUT:
+*    pAdapter    - pointer to the adapter data structure.
+*    scsiAdapterExt  - SCSI to ATA layer adapter extension data structure
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*    MV_TRUE on success
+*    MV_FALSE on error
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvAdapterStartInitialization(MV_SATA_ADAPTER *pSataAdapter,
+                                        MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_U8 channelIndex;
+    ialExt->pSataAdapter = pSataAdapter;
+    ialExt->adapterState = ADAPTER_INITIALIZING;
+    for (channelIndex = 0; channelIndex < MV_SATA_CHANNELS_NUM; channelIndex++)
+    {
+        ialExt->channelState[channelIndex] = CHANNEL_NOT_CONNECTED;
+        ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold = 0;
+        ialExt->IALChannelExt[channelIndex].SRSTTimerValue = 0;
+        ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue = NULL;
+        ialExt->IALChannelExt[channelIndex].completionError = MV_FALSE;
+        ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress = MV_FALSE;
+        ialExt->IALChannelExt[channelIndex].devInSRST =
+        MV_SATA_PM_CONTROL_PORT + 1;
+        ialExt->IALChannelExt[channelIndex].PMdevsToInit = 0;
+        ialExt->IALChannelExt[channelIndex].PMnumberOfPorts = 0;
+        ialExt->IALChannelExt[channelIndex].pmAccessType = 0;
+        ialExt->IALChannelExt[channelIndex].pmReg = 0;
+        ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled = MV_FALSE;
+        ialExt->IALChannelExt[channelIndex].bHotPlug = MV_FALSE;
+        memset(&ialExt->IALChannelExt[channelIndex].drivesInfo, 0, sizeof(MV_DRIVES_INFO));
+    }
+    return mvAdapterStateMachine(ialExt, scsiAdapterExt);
+}
+
+
+/*******************************************************************************
+* mvRestartChannel - restart specific channel
+*
+* DESCRIPTION:
+*  The function is used in channel hot-plug to restart the channel
+*  initialization sequence. The channel stated is changed to
+*  CHANNEL_CONNECTED and any pending command in software queue are flushed
+* INPUT:
+*    pAdapter    - pointer to the adapter data structure.
+*    channelIndex  - channel number
+*    scsiAdapterExt  - SCSI to ATA layer adapter extension data structure
+*    bBusReset       - MV_TRUE if the faunction is called because of bus reset,
+*                       MV_FALSE otherwise
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*    MV_TRUE on success
+*    MV_FALSE on error
+*
+*******************************************************************************/
+
+void mvRestartChannel(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                      MV_U8 channelIndex,
+                      MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                      MV_BOOLEAN bBusReset)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_BOOLEAN bBusChangeNotify = MV_FALSE;
+    ialExt->IALChannelExt[channelIndex].bHotPlug = MV_TRUE;
+    mvSetDriveReady(ialExt,
+                    scsiAdapterExt,
+                    channelIndex, 0xFF, MV_FALSE, NULL);
+    if (pSataAdapter->sataChannel[channelIndex] != NULL)
+    {
+        if (mvStorageDevGetDeviceType(pSataAdapter,channelIndex)
+            == MV_SATA_DEVICE_TYPE_PM)
+        {
+            bBusChangeNotify = MV_TRUE;
+        }
+        mvSataDisableChannelDma(pSataAdapter, channelIndex);
+        mvSataFlushDmaQueue (pSataAdapter, channelIndex,
+                             MV_FLUSH_TYPE_CALLBACK);
+    }
+    mvFlushSCSICommandQueue(ialExt, channelIndex);
+    ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold = 0;
+    ialExt->IALChannelExt[channelIndex].SRSTTimerValue = 0;
+    ialExt->channelState[channelIndex] = CHANNEL_CONNECTED;
+    if (bBusReset == MV_TRUE)
+    {
+        if (bBusChangeNotify == MV_TRUE)
+        {
+            /*Notify about bus change*/
+            IALBusChangeNotify(pSataAdapter, channelIndex);
+        }
+    }
+    else
+    {
+        /*Notify about bus change*/
+        IALBusChangeNotify(pSataAdapter, channelIndex);
+    }
+}
+
+
+
+/*******************************************************************************
+* mvPMHotPlugDetected - restart specific channel
+*
+* DESCRIPTION:
+*  The function is used in PM hot-plug to wait for empty EDMA command queue
+*  and then restart the channel initialization sequence.
+*  The channel stated is changed to CHANNEL_PM_HOT_PLUG if there are any
+*  pending command in EDMA queue
+* INPUT:
+*    pAdapter    - pointer to the adapter data structure.
+*    channelIndex  - channel number
+
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*    None
+*
+*******************************************************************************/
+
+void mvPMHotPlugDetected(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                         MV_U8 channelIndex,
+                         MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    if (ialExt->channelState[channelIndex] == CHANNEL_NOT_CONNECTED ||
+        ialExt->channelState[channelIndex] == CHANNEL_CONNECTED ||
+        ialExt->channelState[channelIndex] == CHANNEL_IN_SRST)
+    {
+        return;
+    }
+    mvSataDisableChannelDma(ialExt->pSataAdapter, channelIndex);
+    mvSataFlushDmaQueue (ialExt->pSataAdapter,
+                         channelIndex, MV_FLUSH_TYPE_CALLBACK);
+    mvSataChannelHardReset(ialExt->pSataAdapter, channelIndex);
+    mvRestartChannel(ialExt, channelIndex, scsiAdapterExt, MV_FALSE);
+}
+
+/*******************************************************************************
+* mvStopChannel - stop channel
+*
+* DESCRIPTION:
+*  The function is used when the channel is unplugged.
+*  The channel stated is changed to CHANNEL_NOT_CONNECTED
+*  until further connection.
+* INPUT:
+*    pAdapter    - pointer to the adapter data structure.
+*    channelIndex  - channel number
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*    None
+*******************************************************************************/
+void mvStopChannel(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                   MV_U8 channelIndex,
+                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_U16 drivesSnapshot =
+        ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotSaved;
+    mvDrivesInfoFlushAll(ialExt, channelIndex);
+    mvSetDriveReady(ialExt, scsiAdapterExt, channelIndex, 0xFF, MV_FALSE, NULL);
+    mvSetChannelState(ialExt, channelIndex, CHANNEL_NOT_CONNECTED);
+    if (pSataAdapter->sataChannel[channelIndex] != NULL)
+    {
+        mvSataDisableChannelDma(ialExt->pSataAdapter, channelIndex);
+        mvSataFlushDmaQueue (ialExt->pSataAdapter, channelIndex,
+                             MV_FLUSH_TYPE_CALLBACK);
+    }
+    mvFlushSCSICommandQueue(ialExt, channelIndex);
+    if (pSataAdapter->sataChannel[channelIndex] != NULL)
+    {
+        mvSataRemoveChannel(pSataAdapter,channelIndex);
+        IALReleaseChannel(pSataAdapter, channelIndex);
+    }
+    pSataAdapter->sataChannel[channelIndex] = NULL;
+    /*Notify about bus change*/
+    IALBusChangeNotify(pSataAdapter, channelIndex);
+    if (drivesSnapshot != 0)
+    {
+        IALBusChangeNotifyEx(pSataAdapter, channelIndex, drivesSnapshot, 0);
+    }
+}
+
+
+/*******************************************************************************
+* mvExecuteScsiCommand - execute SCSI command
+*
+* DESCRIPTION:
+*  IAL common layer wrapper of mvSataExecuteScsiCommand function.
+*  If either the adapter state is either other than ADAPTER_READY
+*  or the channel is connected but channel state is not CHANNEL_READY,
+*  the current SCSI command is queued in channel's SCSI commands
+*  software queue until channel initialization sequence completed.
+*  If channel is found in CHANNEL ready state the SCSI command is passed to
+*  SCSI ATA translation layer.
+* INPUT:
+*    pScb    - SCSI command block structure.
+*
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*    Return MV_SCSI_COMMAND_STATUS_COMPLETED if the command has been added
+*    to channel software queue. Otherwise return the result of
+*    mvSataExecuteScsiCommand function call
+*******************************************************************************/
+MV_SCSI_COMMAND_STATUS_TYPE mvExecuteScsiCommand(MV_SATA_SCSI_CMD_BLOCK *pScb,
+                                                 MV_BOOLEAN canQueue)
+{
+    MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt = pScb->pIalAdapterExtension;
+    MV_U8 channelIndex = pScb->bus;
+
+    if ((ialExt->adapterState == ADAPTER_READY) &&
+        (ialExt->channelState[channelIndex] == CHANNEL_READY))
+    {
+        mvCheckPMForError(ialExt, channelIndex);
+    }
+
+    if ((ialExt->adapterState == ADAPTER_READY) &&
+        ((ialExt->channelState[channelIndex] == CHANNEL_READY) ||
+         (ialExt->channelState[channelIndex] == CHANNEL_NOT_CONNECTED)))
+    {
+        return mvSataExecuteScsiCommand(pScb);
+    }
+    if (canQueue == MV_FALSE)
+    {
+        pScb->ScsiStatus = MV_SCSI_STATUS_BUSY;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_QUEUE_FULL;
+        if (pScb->completionCallBack)
+        {
+            pScb->completionCallBack(ialExt->pSataAdapter, pScb);
+        }
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    else
+    {
+        mvAddToSCSICommandQueue(ialExt, channelIndex, pScb);
+        return MV_SCSI_COMMAND_STATUS_QUEUED_BY_IAL;
+    }
+}
+
+
+/*******************************************************************************
+* mvIALTimerCallback - IAL timer callback
+*
+* DESCRIPTION:
+*  The adapter/channel state machine is timer-driven.
+*  After being loaded, the IAL must call this callback every 0.5 seconds
+* INPUT:
+*    pSataAdapter    - pointer to the adapter data structure.
+*    scsiAdapterExt  - SCSI to ATA layer adapter extension data structure
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvIALTimerCallback(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+
+    return mvAdapterStateMachine(ialExt,
+                                 scsiAdapterExt);
+}
+
+/*******************************************************************************
+* mvCommandCompletionErrorHandler - IAL common command completion error handler
+*
+* DESCRIPTION:
+*  Called by whether SAL completion of SMART completion function. Check whether
+*  command is failed because of PM hot plug
+*
+* INPUT:
+*    pSataAdapter    - pointer to the adapter data structure.
+*    channelIndex    - channelNumber
+* OUTPUT:
+*    None.
+*
+* RETURN:
+*
+*******************************************************************************/
+
+void mvCommandCompletionErrorHandler(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                     MV_U8 channelIndex)
+{
+    MV_SATA_ADAPTER* pSataAdapter = ialExt->pSataAdapter;
+    if (pSataAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+                 "Invalid channel data structure pointer.\n",
+                 pSataAdapter->adapterId, channelIndex);
+    }
+
+    if ((ialExt->channelState[channelIndex] != CHANNEL_READY) ||
+        (mvStorageDevGetDeviceType(pSataAdapter,channelIndex) !=
+         MV_SATA_DEVICE_TYPE_PM) ||
+        (ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled == MV_TRUE))
+    {
+        return;
+    }
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+             "Set completion error to MV_TRUE.\n",
+             pSataAdapter->adapterId, channelIndex);
+    ialExt->IALChannelExt[channelIndex].completionError = MV_TRUE;
+}
+
+/*Static functions*/
+
+
+static void printAtaDeviceRegisters(
+                                   MV_STORAGE_DEVICE_REGISTERS *mvStorageDevRegisters)
+{
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "ATA Drive Registers:\n");
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","Error",
+             mvStorageDevRegisters->errorRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","SectorCount",
+             mvStorageDevRegisters->sectorCountRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Low",
+             mvStorageDevRegisters->lbaLowRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Mid",
+             mvStorageDevRegisters->lbaMidRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA High",
+             mvStorageDevRegisters->lbaHighRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","Device",
+             mvStorageDevRegisters->deviceRegister);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%20s : %04x\n","Status",
+             mvStorageDevRegisters->statusRegister);
+}
+
+
+
+static void mvDrivesInfoSaveAll(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex)
+{
+    /*Save disk drives information for channel*/
+    ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotSaved =
+        ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent;
+    memcpy(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialSaved,
+        ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent,
+        sizeof(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent));
+    /*Reset current disk drives information*/
+    ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent = 0;
+    memset(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent,
+            0,
+        sizeof(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent));
+
+}
+
+static void mvDrivesInfoFlushAll(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex)
+{
+    /*Flush drives info*/
+    memset(&ialExt->IALChannelExt[channelIndex].drivesInfo, 0,
+            sizeof(ialExt->IALChannelExt[channelIndex].drivesInfo));
+}
+
+static void mvDrivesInfoFlushSingleDrive(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex, MV_U8 PMPort)
+{
+    /*Clear bit in disk drive drive snapshot*/
+    ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent &=
+        ~(1 << PMPort);
+    ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotSaved &=
+        ~(1 << PMPort);
+    /*Clear disk drive serial number string*/
+    ialExt->
+       IALChannelExt[channelIndex].drivesInfo.driveSerialSaved[PMPort].serial[0] = 0;
+    ialExt->
+        IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent[PMPort].serial[0] = 0;
+}
+
+
+static void mvDrivesInfoSaveSingleDrive(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                      MV_U8 channelIndex,
+                                      MV_U8 PMPort,
+                                      MV_BOOLEAN  isDriveAdded,
+                                      MV_U16_PTR identifyBuffer)
+{
+    if (MV_TRUE == isDriveAdded)
+    {
+        /*Set bit in disk drive snapshot for current disk drive*/
+        ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent |=
+                1 << PMPort;
+        /*Save serial number for current disk drive*/
+        memcpy(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent[PMPort].serial,
+               &identifyBuffer[IDEN_SERIAL_NUM_OFFSET], IDEN_SERIAL_NUM_SIZE);
+    }
+    else
+    {
+        if (0xFF == PMPort)
+        {
+            ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent
+                 = 0;
+            memset(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent,
+               0,
+               sizeof(ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent));
+        }
+        else
+        {
+            ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent
+                    &= ~(1 << PMPort);
+            ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent[PMPort].serial[0] = 0;
+        }
+    }
+}
+
+static void mvSetDriveReady(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                            MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                            MV_U8 channelIndex,
+                            MV_U8 PMPort,
+                            MV_BOOLEAN  isReady,
+                            MV_U16_PTR identifyBuffer)
+{
+    mvDrivesInfoSaveSingleDrive(ialExt,
+                            channelIndex,
+                            PMPort,
+                            isReady,
+                            identifyBuffer);
+    mvSataScsiSetDriveReady(scsiAdapterExt,
+                            channelIndex, PMPort, isReady);
+}
+
+
+static void mvDrivesInfoGetChannelRescanParams(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                              MV_U8 channelIndex,
+                                              MV_U16 *drivesToRemove,
+                                              MV_U16 *drivesToAdd)
+{
+    MV_U8 PMPort;
+
+    *drivesToRemove = 0;
+    *drivesToAdd = 0;
+
+    for (PMPort = 0; PMPort < MV_SATA_PM_MAX_PORTS; PMPort++)
+    {
+        if (ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotCurrent
+            & (1 << PMPort))
+        {
+            if (ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotSaved
+                & (1 << PMPort))
+            {
+                if (memcmp(&ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialCurrent[PMPort].serial,
+                    &ialExt->IALChannelExt[channelIndex].drivesInfo.driveSerialSaved[PMPort].serial,
+                        IDEN_SERIAL_NUM_SIZE))
+                {
+                    /*Disk drive connected to port is replaced*/
+                    *drivesToAdd |= (1 << PMPort);
+                    *drivesToRemove |= (1 << PMPort);
+                }
+            }
+            else
+            {
+                /*New drive connected to port*/
+                *drivesToAdd |= (1 << PMPort);
+            }
+        }
+        else
+        {
+            /*Drive removed from Port*/
+            if (ialExt->IALChannelExt[channelIndex].drivesInfo.drivesSnapshotSaved
+                & (1 << PMPort))
+            {
+                *drivesToRemove |= (1 << PMPort);
+            }
+        }
+    }
+}
+
+
+
+/*SCSI command queue functions*/
+static void mvAddToSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex,
+                                    MV_SATA_SCSI_CMD_BLOCK *pScb)
+{
+
+    MV_SATA_SCSI_CMD_BLOCK *cmdBlock = (MV_SATA_SCSI_CMD_BLOCK *)
+                                       ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue;
+    pScb->pNext = NULL;
+    if (cmdBlock)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d] Adding next command to SW queue\n",
+                 ialExt->pSataAdapter->adapterId, channelIndex);
+        while (cmdBlock->pNext)
+        {
+            cmdBlock = cmdBlock->pNext;
+        }
+        cmdBlock->pNext = pScb;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d] Adding first command to SW queue\n",
+                 ialExt->pSataAdapter->adapterId, channelIndex);
+        ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue =
+        (MV_VOID_PTR)pScb;
+    }
+}
+
+MV_BOOLEAN mvRemoveFromSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex,
+                                        MV_SATA_SCSI_CMD_BLOCK *pScb)
+{
+
+    MV_SATA_SCSI_CMD_BLOCK *cmdBlock = (MV_SATA_SCSI_CMD_BLOCK *)
+                                       ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue;
+    pScb->pNext = NULL;
+    if (cmdBlock)
+    {
+        if (cmdBlock == pScb)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d] Removing command"
+                     " %p from head of SW queue\n",
+                     ialExt->pSataAdapter->adapterId,channelIndex, pScb);
+            ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue =
+            (MV_VOID_PTR) cmdBlock->pNext;
+            return MV_TRUE;
+        }
+        else
+        {
+            while (cmdBlock->pNext)
+            {
+                if (cmdBlock->pNext == pScb)
+                {
+                    break;
+                }
+                cmdBlock = cmdBlock->pNext;
+            }
+            if (cmdBlock->pNext == NULL)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d] Removing"
+                         " command %p from SW queue failed. command not found\n",
+                         ialExt->pSataAdapter->adapterId,channelIndex, pScb);
+                return MV_FALSE;
+            }
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d] Removing command"
+                     " %p from SW queue\n", ialExt->pSataAdapter->adapterId,
+                     channelIndex, pScb);
+            cmdBlock->pNext = cmdBlock->pNext->pNext;
+            return MV_TRUE;
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d] Removing"
+                 " command %p from SW queue failed. queue empty\n",
+                 ialExt->pSataAdapter->adapterId,channelIndex, pScb);
+        return MV_FALSE;
+    }
+    return MV_FALSE;
+}
+
+static void mvFlushSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex)
+{
+    /*Abort all pending commands in SW queue*/
+    MV_SATA_SCSI_CMD_BLOCK *cmdBlock = (MV_SATA_SCSI_CMD_BLOCK *)
+                                       ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue;
+
+    while (cmdBlock)
+    {
+        MV_SATA_SCSI_CMD_BLOCK *nextBlock = cmdBlock->pNext;
+        if (cmdBlock->completionCallBack)
+        {
+            cmdBlock->ScsiStatus = MV_SCSI_STATUS_BUSY;
+            cmdBlock->dataTransfered = 0;
+            cmdBlock->ScsiCommandCompletion = MV_SCSI_COMPLETION_QUEUE_FULL;
+            cmdBlock->completionCallBack(ialExt->pSataAdapter, cmdBlock);
+        }
+        cmdBlock = nextBlock;
+    }
+    ialExt->IALChannelExt[channelIndex].IALChannelPendingCmdQueue = NULL;
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: Flush command queue is done\n",
+             ialExt->pSataAdapter->adapterId, channelIndex);
+}
+
+
+/*Port Multilier related functions*/
+static MV_BOOLEAN mvPMCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                                          MV_U8 channelIndex,
+                                          MV_COMPLETION_TYPE comp_type,
+                                          MV_VOID_PTR commandId,
+                                          MV_U16 responseFlags,
+                                          MV_U32 timeStamp,
+                                          MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_U32 value;
+    MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt =
+    (MV_IAL_COMMON_ADAPTER_EXTENSION *)commandId;
+    ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress = MV_FALSE;
+    switch (comp_type)
+    {
+    case MV_COMPLETION_TYPE_NORMAL:
+        if (ialExt->IALChannelExt[channelIndex].pmAccessType
+            == MV_ATA_COMMAND_PM_READ_REG)
+        {
+            value = registerStruct->sectorCountRegister;
+            value |= (registerStruct->lbaLowRegister << 8);
+            value |= (registerStruct->lbaMidRegister << 16);
+            value |= (registerStruct->lbaMidRegister << 24);
+            if (ialExt->IALChannelExt[channelIndex].pmReg
+                == MV_SATA_GSCR_ERROR_REG_NUM)
+            {
+                if (value != 0)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: PM GSCR[32] = 0x%X\n",
+                             pSataAdapter->adapterId, channelIndex, value);
+                    ialExt->IALChannelExt[channelIndex].PMdevsToInit =
+                    (MV_U16)(value & 0x7FFF);
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: "
+                             "PM Hot plug detected "
+                             "Bitmask = 0x%X\n",
+                             pSataAdapter->adapterId, channelIndex,
+                             ialExt->IALChannelExt[channelIndex].PMdevsToInit);
+                    mvSetChannelState(ialExt, channelIndex,
+                                      CHANNEL_PM_HOT_PLUG);
+                }
+            }
+        }
+        break;
+    case MV_COMPLETION_TYPE_ABORT:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: read PM register aborted!\n",
+                 pSataAdapter->adapterId, channelIndex);
+
+        break;
+    case MV_COMPLETION_TYPE_ERROR:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: read PM register error!\n",
+                 pSataAdapter->adapterId, channelIndex);
+        break;
+    default:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Unknown completion type (%d)\n",
+                 pSataAdapter->adapterId, channelIndex, comp_type);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvQueuePMAccessRegisterCommand(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_U8 PMPort,
+                                                MV_U8 PMReg,
+                                                MV_U32 Value,
+                                                MV_BOOLEAN isRead)
+{
+    MV_QUEUE_COMMAND_INFO commandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    memset(&commandParams, 0, sizeof(commandParams));
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.commandParams.NoneUdmaCommand.protocolType =
+    MV_NON_UDMA_PROTOCOL_NON_DATA;
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+    commandParams.PMPort = MV_SATA_PM_CONTROL_PORT;
+    commandParams.commandParams.NoneUdmaCommand.count = 0;
+    commandParams.commandParams.NoneUdmaCommand.features = PMReg;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)PMPort;
+    commandParams.commandParams.NoneUdmaCommand.callBack =
+    mvPMCommandCompletionCB;
+
+    ialExt->IALChannelExt[channelIndex].pmReg = PMReg;
+
+    if (isRead == MV_TRUE)
+    {
+        ialExt->IALChannelExt[channelIndex].pmAccessType =
+        MV_ATA_COMMAND_PM_READ_REG;
+        commandParams.commandParams.NoneUdmaCommand.command =
+        MV_ATA_COMMAND_PM_READ_REG;
+        commandParams.commandParams.NoneUdmaCommand.commandId =
+        (MV_VOID_PTR)ialExt;
+        commandParams.commandParams.NoneUdmaCommand.sectorCount = 0;
+        commandParams.commandParams.NoneUdmaCommand.lbaLow = 0;
+        commandParams.commandParams.NoneUdmaCommand.lbaMid = 0;
+        commandParams.commandParams.NoneUdmaCommand.lbaHigh = 0;
+    }
+    else
+    {
+        ialExt->IALChannelExt[channelIndex].pmAccessType =
+        MV_ATA_COMMAND_PM_WRITE_REG;
+        commandParams.commandParams.NoneUdmaCommand.command =
+        MV_ATA_COMMAND_PM_WRITE_REG;
+        commandParams.commandParams.NoneUdmaCommand.commandId =
+        (MV_VOID_PTR)ialExt;
+        commandParams.commandParams.NoneUdmaCommand.sectorCount =
+        (MV_U16)((Value) & 0xff),
+        commandParams.commandParams.NoneUdmaCommand.lbaLow =
+        (MV_U16)(((Value) & 0xff00) >> 8);
+        commandParams.commandParams.NoneUdmaCommand.lbaMid =
+        (MV_U16)(((Value) & 0xff0000) >> 16);
+        commandParams.commandParams.NoneUdmaCommand.lbaHigh =
+        (MV_U16)(((Value) & 0xff000000) >> 24);
+    }
+    ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress = MV_TRUE;
+    result = mvSataQueueCommand(pSataAdapter,
+                                channelIndex,
+                                &commandParams);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        switch (result)
+        {
+        case MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, ": Queue PM command failed. Bad LBA "
+                     "\n");
+            break;
+        case MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, ": Queue PM command failed. EDMA"
+                     " disabled adapter %d channel %d\n",
+                     pSataAdapter->adapterId, channelIndex);
+            break;
+        case MV_QUEUE_COMMAND_RESULT_FULL:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, ": Queue PM command failed. Queue is"
+                     " Full adapter %d channel %d\n",
+                     pSataAdapter->adapterId, channelIndex);
+
+            break;
+        case MV_QUEUE_COMMAND_RESULT_BAD_PARAMS:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, ": Queue PM command failed. (Bad "
+                     "Params), pMvSataAdapter: %p, pSataChannel: %p.\n",
+                     pSataAdapter, pSataAdapter->sataChannel[channelIndex]);
+            break;
+        default:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, ": Queue PM command bad result value (%d) "
+                     "from queue command\n",
+                     result);
+        }
+        ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress = MV_FALSE;
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvPMEnableCommStatusChangeBits(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                 MV_U8 channelIndex,
+                                                 MV_BOOLEAN enable)
+{
+    MV_U32 regVal;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+
+    if (enable == MV_TRUE)
+    {
+        regVal = MV_BIT16 | MV_BIT26;
+    }
+    else
+    {
+        regVal = 0;
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: Set PM "
+             "GSCR[33] register to 0x%X\n",
+             pSataAdapter->adapterId, channelIndex, regVal);
+    /*Set N & X bits reflection in PM GSCR*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex,
+                        MV_SATA_PM_CONTROL_PORT,
+                        MV_SATA_GSCR_ERROR_ENABLE_REG_NUM,
+                        regVal, NULL) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to set "
+                 "PortMultiplier Features Enable register\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+static MV_BOOLEAN mvPMEnableAsyncNotify(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_U8 channelIndex)
+{
+    MV_U32 regVal1, regVal2;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    /*Features register*/
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_FEATURES_REG_NUM,
+                       &regVal1, NULL) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to get Port Multiplier Features"
+                 " supported register\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: Port Multiplier features supported: 0x%X\n",
+             pSataAdapter->adapterId, channelIndex, regVal1);
+
+    /*PM asynchronous notification supported*/
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM,
+                       &regVal2 ,NULL) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to get Port Multiplier Features"
+                 " register\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: Port Multiplier features enabled "
+             "register: 0x%X\n",
+             pSataAdapter->adapterId, channelIndex, regVal2);
+    if (regVal1 & MV_BIT3)
+    {
+        regVal2 |= MV_BIT3;
+        if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                            MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM,
+                            regVal2 ,NULL) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to set "
+                     "PortMultiplier Features Enable register\n",
+                     pSataAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+
+        }
+        ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled = MV_TRUE;
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: PM asynchronous notification is "
+                 "enabled.\n", pSataAdapter->adapterId, channelIndex);
+    }
+    else
+    {
+        regVal2 &= ~MV_BIT3;
+        if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                            MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM,
+                            regVal2 ,NULL) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to set "
+                     "PortMultiplier Features Enable register\n",
+                     pSataAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+
+        }
+        ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled = MV_FALSE;
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: PM asynchronous notification is "
+                 "disabled.\n", pSataAdapter->adapterId, channelIndex);
+    }
+    return MV_TRUE;
+}
+
+
+
+
+static MV_BOOLEAN mvConfigurePMDevice(
+                                     MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                     MV_U8 channelIndex)
+{
+    MV_SATA_PM_DEVICE_INFO PMInfo;
+    ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled = MV_FALSE;
+
+    if (mvGetPMDeviceInfo(ialExt->pSataAdapter, channelIndex, &PMInfo)
+        == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Failed to get PortMultiplier Info\n",
+                 ialExt->pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: PM of %d ports found\n",
+             ialExt->pSataAdapter->adapterId, channelIndex,
+             PMInfo.numberOfPorts);
+    ialExt->IALChannelExt[channelIndex].PMnumberOfPorts = PMInfo.numberOfPorts;
+#ifdef DISABLE_PM_SCC
+    if (PMInfo.vendorId == 0x11AB)
+    {
+
+        if (mvPMDisableSSC(ialExt->pSataAdapter, channelIndex) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: cannot disable SSC for PM.\n"
+                     "unknown vendor.\n",
+                     ialExt->pSataAdapter->adapterId, channelIndex);
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: cannot disable SSC for PM - "
+                 "unknown vendor.\n",
+                 ialExt->pSataAdapter->adapterId, channelIndex);
+    }
+#endif
+    if (mvPMEnableCommStatusChangeBits(ialExt,
+                                       channelIndex,
+                                       MV_FALSE) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMEnableAsyncNotify(ialExt, channelIndex) == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+static MV_BOOLEAN mvPMEstablishSataComm(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_IAL_COMMON_CHANNEL_EXTENSION* channelExt =
+    &ialExt->IALChannelExt[channelIndex];
+    if (mvConfigurePMDevice(ialExt, channelIndex) == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+
+    if (mvPMDevEnableStaggeredSpinUpAll(pSataAdapter,
+                                        channelIndex,
+                                        channelExt->PMnumberOfPorts,
+                                        &channelExt->PMdevsToInit) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: PM Enable Staggered Spin-Up Failed\n",
+                 pSataAdapter->adapterId, channelIndex);
+        channelExt->PMdevsToInit = 0;
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+
+
+static MV_BOOLEAN mvPMCheckForConnectedDevices(
+                                              MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                              MV_U8 channelIndex,
+                                              MV_BOOLEAN* bIsChannelReady)
+{
+    MV_U8 PMPort;
+    MV_U32 SStatus;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_IAL_COMMON_CHANNEL_EXTENSION* channelExt =
+    &ialExt->IALChannelExt[channelIndex];
+    *bIsChannelReady = MV_FALSE;
+    channelExt->devInSRST = MV_SATA_PM_CONTROL_PORT+1;
+
+    for (PMPort = 0; PMPort < channelExt->PMnumberOfPorts; PMPort++)
+    {
+        if (!(channelExt->PMdevsToInit & (1 << PMPort)))
+        {
+            continue;
+        }
+        channelExt->PMdevsToInit &= ~(1 << PMPort);
+        if (mvPMDevReadReg(pSataAdapter, channelIndex, PMPort,
+                           MV_SATA_PSCR_SSTATUS_REG_NUM, &SStatus, NULL) ==
+            MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: mvPMDevReadReg Failed\n",
+                     pSataAdapter->adapterId, channelIndex, PMPort);
+            if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                               MV_SATA_PM_CONTROL_PORT, NULL) == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]:failed to Soft Reset PM control "
+                         "port\n",
+                         pSataAdapter->adapterId, channelIndex);
+                return MV_FALSE;
+            }
+            continue;
+        }
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: S-Status: 0x%x\n",
+                 pSataAdapter->adapterId,
+                 channelIndex, PMPort, SStatus);
+
+        if ((SStatus & 0xf) != 3)
+        {
+            if (mvPMDevWriteReg(pSataAdapter, channelIndex, PMPort,
+                                MV_SATA_PSCR_SERROR_REG_NUM, 0xffffffff, NULL) ==
+                MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,
+                         "[%d %d %d]: PM Write SERROR Failed\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+            }
+            continue;
+        }
+
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Start reset PM connected device.\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+
+        /*Set first connected PM port for further SRST*/
+        channelExt->PMdevsToInit |= (1 << PMPort);
+        if (channelExt->devInSRST == MV_SATA_PM_CONTROL_PORT+1)
+        {
+            channelExt->devInSRST = PMPort;
+        }
+    }
+
+    /*PM is connected but no device is present*/
+    if (!channelExt->PMdevsToInit)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: "
+                 "No more devices connected to PM.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvPMEnableCommStatusChangeBits(ialExt,
+                                           channelIndex,
+                                           MV_TRUE) != MV_TRUE)
+        {
+            return MV_FALSE;
+        }
+
+        *bIsChannelReady = MV_TRUE;
+        return MV_TRUE;
+    }
+
+
+    for (PMPort = channelExt->devInSRST;
+        PMPort < channelExt->PMnumberOfPorts;
+        PMPort++)
+    {
+        if (channelExt->PMdevsToInit & (1 << PMPort))
+        {
+            channelExt->devInSRST = PMPort;
+            /*Clear SError on PM port*/
+            if (mvPMDevWriteReg(pSataAdapter, channelIndex, PMPort,
+                                MV_SATA_PSCR_SERROR_REG_NUM, 0xFFFFFFFF, NULL) ==
+                MV_FALSE)
+            {
+                if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                                   MV_SATA_PM_CONTROL_PORT, NULL) == MV_FALSE)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+                             "failed to Soft Reset PM control port\n",
+                             pSataAdapter->adapterId, channelIndex);
+                    return MV_FALSE;
+                }
+            }
+            if (mvStorageDevATAStartSoftResetDevice(pSataAdapter,
+                                                    channelIndex,
+                                                    channelExt->devInSRST)
+                == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: "
+                         "failed to Soft Reset PM device port.\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                channelExt->PMdevsToInit &= ~(1 << PMPort);
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    if (PMPort == channelExt->PMnumberOfPorts)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+                 "SRST failed for all PM connected devices.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvPMEnableCommStatusChangeBits(ialExt,
+                                           channelIndex,
+                                           MV_TRUE) != MV_TRUE)
+        {
+            return MV_FALSE;
+        }
+        *bIsChannelReady = MV_TRUE;
+    }
+    return MV_TRUE;
+}
+
+static MV_BOOLEAN hasSataLinkStatusChanged(MV_SATA_ADAPTER *pSataAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_U8 PMPort,
+                                           MV_U32 *connectStatus)
+{
+    MV_U32 regVal;
+    /*No change in sttatus*/
+    *connectStatus = 0;
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: "
+             "Before sending PIO to drive: "
+             "looking for any change in port status.\n",
+             pSataAdapter->adapterId,
+             channelIndex,
+             PMPort);
+
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, PMPort,
+                       MV_SATA_PSCR_SERROR_REG_NUM, &regVal, NULL)
+        == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                 "mvPMDevReadReg SCR-ERROR Failed",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+        if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                           MV_SATA_PM_CONTROL_PORT,
+                                           NULL) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: failed to Soft Reset PM "
+                     "control port\n",
+                     pSataAdapter->adapterId, channelIndex);
+
+        }
+        return MV_FALSE;
+    }
+    /*clear X bit and N bitin S-Error*/
+    if ((regVal != 0) && mvPMDevWriteReg(pSataAdapter, channelIndex, PMPort,
+                                         MV_SATA_PSCR_SERROR_REG_NUM, 0xFFFFFFFF, NULL)
+        == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                 "mvStorageDevPMWriteReg SCR-ERROR Failed",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+        if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                           MV_SATA_PM_CONTROL_PORT,
+                                           NULL) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: failed to Soft Reset PM "
+                     "control port\n",
+                     pSataAdapter->adapterId, channelIndex);
+        }
+        return MV_FALSE;
+    }
+
+    if (!(regVal & MV_BIT16))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: "
+                 "N Bit is zero in SError register - no change in status "
+                 "of PM ports.\n",
+                 pSataAdapter->adapterId,
+                 channelIndex,
+                 PMPort);
+
+    }
+    else
+    {
+        /*Disconnected*/
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                 "Unexpected device disconnect.\n",
+                 pSataAdapter->adapterId,
+                 channelIndex,
+                 PMPort);
+        *connectStatus = 1;
+    }
+
+    if (!(regVal & MV_BIT26))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: X Bit is zero in SError register\n",
+                 pSataAdapter->adapterId,
+                 channelIndex,
+                 PMPort);
+    }
+    else
+    {
+        /*Reconnected*/
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                 "Device reconnected while before SRST status was probed\n",
+                 pSataAdapter->adapterId,
+                 channelIndex,
+                 PMPort);
+        *connectStatus = 2;
+    }
+
+    if (*connectStatus < 2)
+    {
+        return MV_TRUE;
+    }
+
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, PMPort,
+                       MV_SATA_PSCR_SSTATUS_REG_NUM, &regVal, NULL) ==
+        MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: mvPMDevReadReg SStatus "
+                 "Failed\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+        if (mvStorageDevATASoftResetDevice(pSataAdapter,
+                                           channelIndex,
+                                           MV_SATA_PM_CONTROL_PORT,
+                                           NULL) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: failed to Soft Reset PM "
+                     "control port\n",
+                     pSataAdapter->adapterId, channelIndex);
+
+        }
+        return MV_FALSE;
+    }
+    if ((regVal & 0xf) != 0x3)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: No reconnected device found\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+        *connectStatus = 1;
+    }
+    return MV_TRUE;
+}
+
+static MV_BOOLEAN mvInitPMDevice(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                 MV_U8 channelIndex,
+                                 MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                 MV_BOOLEAN* bIsChannelReady,
+                                 MV_BOOLEAN* isDeviceReconnected,
+                                 MV_BOOLEAN* bPMErrorDetected)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_U8 PMPort = ialExt->IALChannelExt[channelIndex].devInSRST;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData;
+    MV_STORAGE_DEVICE_REGISTERS mvStorageDevRegisters;
+    MV_U32 deviceConnectionStatus = 0;
+    MV_IAL_COMMON_CHANNEL_EXTENSION *channelExt =
+    &ialExt->IALChannelExt[channelIndex];
+    *bIsChannelReady = MV_FALSE;
+    *isDeviceReconnected = MV_FALSE;
+    *bPMErrorDetected = MV_FALSE;
+    if (PMPort == MV_SATA_PM_CONTROL_PORT+1)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Buggy call fo InitPMDevice()\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    PMPort = channelExt->devInSRST;
+
+    if (mvStorageIsDeviceBsyBitOff(pSataAdapter,
+                                   channelIndex,
+                                   &mvStorageDevRegisters)
+        == MV_FALSE)
+    {
+        if (mvIsChannelTimerExpired(ialExt, channelIndex) !=
+            MV_TRUE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d] - disk not ready: wait a "
+                     "little more\n",
+                     pSataAdapter->adapterId,
+                     channelIndex, PMPort);
+            printAtaDeviceRegisters(&mvStorageDevRegisters);
+            return MV_FALSE;
+        }
+        /*Skip current PM port*/
+        channelExt->PMdevsToInit &= ~(1 << PMPort);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: failed to Soft Reset PM port\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+        /*Try do do synchronous software reset tp PM*/
+        mvStorageDevATASoftResetDevice(pSataAdapter,
+                                       channelIndex,
+                                       MV_SATA_PM_CONTROL_PORT,
+                                       NULL);
+    }
+    else
+    {
+        printAtaDeviceRegisters(&mvStorageDevRegisters);
+        channelExt->PMdevsToInit &= ~(1 << PMPort);
+        if (hasSataLinkStatusChanged(pSataAdapter,
+                                     channelIndex,
+                                     PMPort,
+                                     &deviceConnectionStatus) == MV_TRUE)
+        {
+            switch (deviceConnectionStatus)
+            {
+            case 1:
+                /*Skip current PM port*/
+                channelExt->PMdevsToInit &= ~(1 << PMPort);
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                         "PM port unexpected disconnection detected\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                break;
+            case 2:
+                *isDeviceReconnected = MV_TRUE;
+                return MV_TRUE;
+                break;
+            }
+        }
+        else
+        {
+            *bPMErrorDetected = MV_TRUE;
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: failed to check SATA link "
+                     "status\n",
+                     pSataAdapter->adapterId, channelIndex, PMPort);
+            return MV_FALSE;
+        }
+        if (deviceConnectionStatus == 0)
+        {
+            channelExt->PMdevsToInit &= ~(1 << PMPort);
+            pDriveData = &scsiAdapterExt->ataDriveData[channelIndex][PMPort];
+            if (mvInitSataDisk(pSataAdapter,
+                               channelIndex ,
+                               PMPort, &pDriveData->identifyInfo,
+                               pDriveData->identifyBuffer) == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: Failed to initialize disk\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                mvDrivesInfoFlushSingleDrive(ialExt, channelIndex, PMPort);
+            }
+            else
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Disk ready\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                mvSetDriveReady(ialExt,
+                                scsiAdapterExt,
+                                channelIndex, PMPort,
+                                MV_TRUE,
+                                pDriveData->identifyBuffer);
+                mvSataScsiNotifyUA(scsiAdapterExt, channelIndex, PMPort);
+            }
+        }
+    }
+    if (!channelExt->PMdevsToInit)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+                 "No more devices connected to PM.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvPMEnableCommStatusChangeBits(ialExt,
+                                           channelIndex,
+                                           MV_TRUE) != MV_TRUE)
+        {
+            return MV_FALSE;
+        }
+
+        *bIsChannelReady = MV_TRUE;
+        return MV_TRUE;
+    }
+    for (PMPort = channelExt->devInSRST;
+        PMPort < channelExt->PMnumberOfPorts;
+        PMPort++)
+    {
+        if (channelExt->PMdevsToInit & (1 << PMPort))
+        {
+            channelExt->devInSRST = PMPort;
+            /*Clear SError on PM port*/
+            if (mvPMDevWriteReg(pSataAdapter, channelIndex, PMPort,
+                                MV_SATA_PSCR_SERROR_REG_NUM, 0xffffffff, NULL) ==
+                MV_FALSE)
+            {
+                *bPMErrorDetected = MV_TRUE;
+                if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                                   MV_SATA_PM_CONTROL_PORT, NULL) == MV_FALSE)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: failed to Soft Reset PM control"
+                             " port\n", pSataAdapter->adapterId, channelIndex);
+                }
+                return MV_FALSE;
+            }
+
+            if (mvStorageDevATAStartSoftResetDevice(pSataAdapter,
+                                                    channelIndex,
+                                                    PMPort)
+                == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: failed to Soft Reset "
+                         "PM port\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                channelExt->PMdevsToInit &= ~(1 << PMPort);
+                continue;
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    if (PMPort == channelExt->PMnumberOfPorts)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+                 "SRST failed for some PM connected devices.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvPMEnableCommStatusChangeBits(ialExt,
+                                           channelIndex,
+                                           MV_TRUE) != MV_TRUE)
+        {
+            return MV_FALSE;
+        }
+        *bIsChannelReady = MV_TRUE;
+    }
+    return MV_TRUE;
+}
+
+
+static void mvCheckPMForError(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    if (ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled == MV_TRUE)
+    {
+        ialExt->IALChannelExt[channelIndex].completionError = MV_FALSE;
+        return;
+    }
+    if (pSataAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: "
+                 "Invalid channel data structure pointer.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return;
+    }
+    if (ialExt->IALChannelExt[channelIndex].completionError == MV_TRUE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: "
+                 "Set completion error to MV_FALSE.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        ialExt->IALChannelExt[channelIndex].completionError = MV_FALSE;
+
+        if (mvStorageDevGetDeviceType(pSataAdapter,channelIndex)
+            == MV_SATA_DEVICE_TYPE_PM)
+        {
+            MV_U32 value;
+
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+                     "Probe PM GSCR[32] register to detect possible device"
+                     " hot plug.\n",
+                     pSataAdapter->adapterId, channelIndex);
+
+            mvSataDisableChannelDma(pSataAdapter, channelIndex);
+            if (mvPMDevReadReg(pSataAdapter, channelIndex,
+                               MV_SATA_PM_CONTROL_PORT,
+                               MV_SATA_GSCR_ERROR_REG_NUM,
+                               &value ,NULL) == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: "
+                         "Failed to read GSCR register value.\n",
+                         pSataAdapter->adapterId, channelIndex);
+                mvSataEnableChannelDma(pSataAdapter, channelIndex);
+                return;
+                /*Do nothing*/
+            }
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+                     "PM error information GSCR[32] register value = 0x%X\n",
+                     pSataAdapter->adapterId, channelIndex, value);
+
+            if (value != 0)
+            {
+                ialExt->IALChannelExt[channelIndex].PMdevsToInit =
+                (MV_U16)(value & 0x7FFF);
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: PM Hot plug detected "
+                         "Bitmask = 0x%X\n",
+                         pSataAdapter->adapterId, channelIndex,
+                         ialExt->IALChannelExt[channelIndex].PMdevsToInit);
+                mvSetChannelState(ialExt, channelIndex,
+                                  CHANNEL_PM_HOT_PLUG);
+            }
+            else
+            {
+                mvSataEnableChannelDma(pSataAdapter, channelIndex);
+            }
+        }
+    }
+}
+
+MV_BOOLEAN mvPMEnableLocking(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex)
+{
+    MV_STORAGE_DEVICE_REGISTERS regs;
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex,
+                        MV_SATA_PM_CONTROL_PORT,
+                        0x89,
+                        0x8000003F,
+                        &regs) == MV_TRUE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: NCQ lock is enabled for PM.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_TRUE;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: cannot enable NCQ lock for PM.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+#ifdef DISABLE_PM_SCC
+MV_BOOLEAN mvPMDisableSSC(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex)
+{
+    MV_STORAGE_DEVICE_REGISTERS regs;
+    MV_U32 regVal = 0;
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: "
+             "Disable SSC for all PM ports.\n",
+             pSataAdapter->adapterId, channelIndex);
+
+    if (mvPMDevReadReg(pSataAdapter,channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM,
+                       &regVal,
+                       &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+
+    /*Host SSC disable*/
+    regVal &= ~MV_BIT2;
+    if (mvPMDevWriteReg(pSataAdapter,channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM,
+                        regVal,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+
+    /* disable ssc for port 0*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x8C,
+                        0,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x92,
+                        0xb02a402a,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    /* disable ssc for port 1*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x8C,
+                        1,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x92,
+                        0xb02a402a,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    /* disable ssc for port 2*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x8C,
+                        2,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x92,
+                        0xb02a402a,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+
+    /* disable ssc for port 3*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x8C,
+                        3,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x92,
+                        0xb02a402a,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+
+    /* disable ssc for port 15*/
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x8C,
+                        MV_SATA_PM_CONTROL_PORT,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (mvPMDevWriteReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                        0x92,
+                        0xb02a402a,
+                        &regs) != MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+#endif
+
+static MV_BOOLEAN mvConfigChannelQueuingMode(
+                                            MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                            MV_U8 channelIndex,
+                                            MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_EDMA_MODE mode = MV_EDMA_MODE_NOT_QUEUED;
+    MV_BOOLEAN isTCQSupported = MV_FALSE;
+    MV_BOOLEAN isNCQSupported = MV_FALSE;
+    MV_U8    queueDepth = 0;
+    MV_U8    numOfDrives = 0;
+
+    if (mvGetEDMAAllowedModes(ialExt,
+                              scsiAdapterExt,
+                              channelIndex,
+                              &isTCQSupported,
+                              &isNCQSupported,
+                              &queueDepth,
+                              &numOfDrives) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: There is no queing mode supported.\n"
+                 ,pSataAdapter->adapterId, channelIndex);
+        isTCQSupported = MV_FALSE;
+        isNCQSupported = MV_FALSE;
+        queueDepth = 0;
+    }
+    else
+    {
+
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: Supported queing mode: TCQ = %s, "
+                 "NCQ = %s.\n", pSataAdapter->adapterId, channelIndex,
+                 (isTCQSupported == MV_TRUE) ? "Yes" : "No",
+                 (isNCQSupported == MV_TRUE) ? "Yes" : "No");
+    }
+    if (isTCQSupported == MV_TRUE)
+    {
+        mode = MV_EDMA_MODE_QUEUED;
+    }
+    if (isNCQSupported == MV_TRUE)
+    {
+        if ((pSataAdapter->sataChannel[channelIndex] != NULL) &&
+            (pSataAdapter->sataChannel[channelIndex]->deviceType ==
+             MV_SATA_DEVICE_TYPE_PM))
+        {
+
+            MV_SATA_PM_DEVICE_INFO PMDeviceInfo;
+            if (mvGetPMDeviceInfo(pSataAdapter,
+                                  channelIndex,
+                                  &PMDeviceInfo) == MV_TRUE)
+            {
+                if (PMDeviceInfo.vendorId == 0x11AB)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: Marvell PM found, "
+                             "NCQ lock is supported.\n",
+                             pSataAdapter->adapterId, channelIndex);
+                }
+                else
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: NCQ lock not supported by current "
+                             "PM. Vendor Id = 0x%X\n",
+                             pSataAdapter->adapterId,
+                             channelIndex,
+                             PMDeviceInfo.vendorId);
+                    if (numOfDrives > 1)
+                    {
+                        isNCQSupported = MV_FALSE;
+                    }
+                }
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: Enable NCQ locking for PM.\n",
+                         pSataAdapter->adapterId, channelIndex);
+                if (mvPMEnableLocking(pSataAdapter, channelIndex) == MV_FALSE)
+                {
+                    isNCQSupported = MV_FALSE;
+                }
+            }
+            else
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: unable to get PM info.\n",
+                         pSataAdapter->adapterId, channelIndex);
+                isNCQSupported = MV_FALSE;
+            }
+
+        }
+        if (isNCQSupported == MV_TRUE)
+        {
+            mode = MV_EDMA_MODE_NATIVE_QUEUING;
+        }
+        else
+        {
+            mode = MV_EDMA_MODE_NOT_QUEUED;
+            queueDepth = 0;
+        }
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: EDMA mode %d, queue depth = %d.\n",
+             pSataAdapter->adapterId, channelIndex, mode, queueDepth);
+    IALConfigQueuingMode(pSataAdapter,
+                         channelIndex,
+                         mode,
+                         queueDepth);
+    return MV_TRUE;
+}
+
+
+
+/*Channel related functions*/
+
+static void mvSetChannelState(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex,
+                              MV_CHANNEL_STATE state)
+{
+    if (ialExt->channelState[channelIndex] != state)
+    {
+        if ((state == CHANNEL_READY) || (state == CHANNEL_NOT_CONNECTED))
+        {
+            ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold = 0;
+            ialExt->IALChannelExt[channelIndex].SRSTTimerValue = 0;
+        }
+        if (state == CHANNEL_READY)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: CHANNEL_READY\n",
+                     ialExt->pSataAdapter->adapterId,
+                     channelIndex);
+            ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress
+            = MV_FALSE;
+            ialExt->IALChannelExt[channelIndex].completionError = MV_FALSE;
+            ialExt->channelState[channelIndex] = state;
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] flush pending queue\n",
+                     ialExt->pSataAdapter->adapterId, channelIndex);
+            /*Abort all pending commands in SW queue*/
+            mvFlushSCSICommandQueue(ialExt, channelIndex);
+            if (MV_TRUE == ialExt->IALChannelExt[channelIndex].bHotPlug)
+            {
+                MV_U16 drivesToRemove;
+                MV_U16 drivesToAdd;
+                ialExt->IALChannelExt[channelIndex].bHotPlug = MV_FALSE;
+                mvDrivesInfoGetChannelRescanParams(ialExt,
+                                                   channelIndex,
+                                                   &drivesToRemove,
+                                                   &drivesToAdd);
+                if (drivesToRemove != 0 || drivesToAdd != 0)
+                {
+
+                    IALBusChangeNotifyEx(ialExt->pSataAdapter,
+                                        channelIndex,
+                                        drivesToRemove,
+                                        drivesToAdd);
+                }
+            }
+            mvDrivesInfoSaveAll(ialExt, channelIndex);
+        }
+        else
+        {
+            ialExt->channelState[channelIndex] = state;
+        }
+    }
+}
+
+
+static MV_BOOLEAN mvStartChannelInit(MV_SATA_ADAPTER *pSataAdapter,
+                                     MV_U8 channelIndex,
+                                     MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                     MV_BOOLEAN* bIsChannelReady)
+{
+    *bIsChannelReady = MV_FALSE;
+
+    if (mvSataConfigureChannel(pSataAdapter, channelIndex) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: configure channel failed\n",
+                 pSataAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: start channel\n",
+             pSataAdapter->adapterId,
+             channelIndex);
+    /*Just check SStatus in case of SATA I adapter*/
+    if (pSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: starting SATA I channel.\n",
+                 pSataAdapter->adapterId, channelIndex);
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: starting SATA II channel.\n",
+                 pSataAdapter->adapterId, channelIndex);
+    }
+
+    return mvStorageDevATAStartSoftResetDevice(pSataAdapter,
+                                               channelIndex,
+                                               MV_SATA_PM_CONTROL_PORT);
+}
+
+static MV_BOOLEAN mvChannelSRSTFinished(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_SATA_CHANNEL *pSataChannel,
+                                        MV_U8 channelIndex,
+                                        MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                                        MV_BOOLEAN* bIsChannelReady,
+                                        MV_BOOLEAN* bFatalError)
+{
+    MV_SATA_DEVICE_TYPE deviceType;
+    MV_STORAGE_DEVICE_REGISTERS mvStorageDevRegisters;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData;
+    *bIsChannelReady = MV_FALSE;
+    *bFatalError = MV_FALSE;
+    if (pSataAdapter->sataAdapterGeneration != MV_SATA_GEN_I)
+    {
+        if (mvStorageIsDeviceBsyBitOff(pSataAdapter,
+                                       channelIndex,
+                                       &mvStorageDevRegisters)
+            == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: soft Reset PM control port "
+                     "in progress\n",
+                     pSataAdapter->adapterId, channelIndex);
+            printAtaDeviceRegisters(&mvStorageDevRegisters);
+            return MV_FALSE;
+        }
+        deviceType = mvGetSataDeviceType(&mvStorageDevRegisters);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: soft reset SATA II channel - "
+                 "device ready.\n",
+                 pSataAdapter->adapterId, channelIndex);
+    }
+    else
+    {
+        if (mvStorageIsDeviceBsyBitOff(pSataAdapter,
+                                       channelIndex,
+                                       &mvStorageDevRegisters)
+            == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: soft reset of SATA I channel "
+                     "in progress\n",
+                     pSataAdapter->adapterId, channelIndex);
+            printAtaDeviceRegisters(&mvStorageDevRegisters);
+            return MV_FALSE;
+        }
+        deviceType = mvGetSataDeviceType(&mvStorageDevRegisters);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: soft reset SATA I channel - "
+                 "device ready.\n",
+                 pSataAdapter->adapterId, channelIndex);
+        deviceType = mvGetSataDeviceType(&mvStorageDevRegisters);
+        if (deviceType != MV_SATA_DEVICE_TYPE_ATA_DISK)
+        {
+            deviceType = MV_SATA_DEVICE_TYPE_UNKNOWN;
+        }
+
+    }
+    switch (deviceType)
+    {
+    case MV_SATA_DEVICE_TYPE_ATA_DISK:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: ATA disk found\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvStorageDevSetDeviceType(pSataAdapter,channelIndex, deviceType) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Failed to initialize disk\n",
+                     pSataAdapter->adapterId, channelIndex);
+            *bFatalError = MV_TRUE;
+            return MV_FALSE;
+
+        }
+        pDriveData = &scsiAdapterExt->ataDriveData[channelIndex][0];
+        if (mvInitSataDisk(pSataAdapter,
+                           channelIndex,
+                           0,
+                           &pDriveData->identifyInfo,
+                           pDriveData->identifyBuffer) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Failed to initialize disk\n",
+                     pSataAdapter->adapterId, channelIndex);
+            *bFatalError = MV_TRUE;
+            mvDrivesInfoFlushSingleDrive(ialExt,
+                                             channelIndex,
+                                             0);
+            return MV_FALSE;
+        }
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: Disk ready\n",
+                 pSataAdapter->adapterId, channelIndex);
+        mvSetDriveReady(ialExt,
+                        scsiAdapterExt,
+                        channelIndex,
+                        0,
+                        MV_TRUE,
+                        pDriveData->identifyBuffer);
+        mvSataScsiNotifyUA(scsiAdapterExt, channelIndex, 0);
+        *bIsChannelReady = MV_TRUE;
+        return MV_TRUE;
+        break;
+    case MV_SATA_DEVICE_TYPE_PM:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: PortMultiplier device found\n",
+                 pSataAdapter->adapterId, channelIndex);
+        if (mvStorageDevSetDeviceType(pSataAdapter,channelIndex, deviceType) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Failed to initialize PM\n",
+                     pSataAdapter->adapterId, channelIndex);
+            *bFatalError = MV_TRUE;
+            return MV_FALSE;
+
+        }
+        break;
+    case MV_SATA_DEVICE_TYPE_ATAPI_DISK:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: ERROR: ATAPI device was found!!! "
+                 "(not supported)\n", pSataAdapter->adapterId,
+                 channelIndex);
+        *bFatalError = MV_TRUE;
+        return MV_FALSE;
+        break;
+    default:
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: ERROR: unknown device type\n",
+                 pSataAdapter->adapterId, channelIndex);
+        *bFatalError    =    MV_TRUE;
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+
+
+static MV_BOOLEAN mvConfigChannelDMA(
+                                    MV_IAL_COMMON_ADAPTER_EXTENSION* ialExt,
+                                    MV_U8 channelIndex,
+                                    MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] config queueing mode\n",
+             pSataAdapter->adapterId, channelIndex);
+
+
+    if (mvConfigChannelQueuingMode(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt)
+        == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] Failed to config DMA queuing\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    /* Enable EDMA */
+    if (mvSataEnableChannelDma(pSataAdapter, channelIndex) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d] Failed to enable DMA, channel=%d\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d]: channel started successfully\n",
+             pSataAdapter->adapterId, channelIndex);
+    return MV_TRUE;
+}
+
+
+
+
+
+static void mvSetChannelTimer(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                              MV_U8 channelIndex,
+                              MV_U32 timeout)
+{
+    ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold = timeout;
+    ialExt->IALChannelExt[channelIndex].SRSTTimerValue = 1;
+}
+
+static void mvDecrementChannelTimer(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                    MV_U8 channelIndex)
+{
+    if (ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold > 0)
+    {
+        ialExt->IALChannelExt[channelIndex].SRSTTimerValue +=
+        MV_IAL_ASYNC_TIMER_PERIOD;
+    }
+}
+
+static MV_BOOLEAN mvIsChannelTimerExpired(
+                                         MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                         MV_U8 channelIndex)
+{
+    if (ialExt->IALChannelExt[channelIndex].SRSTTimerValue >
+        ialExt->IALChannelExt[channelIndex].SRSTTimerThreshold)
+    {
+        return MV_TRUE;
+    }
+    else
+    {
+        return MV_FALSE;
+    }
+}
+
+/*******************************************************************************
+*State Machine related functions:
+*  Return MV_TRUE to proceed to the next channel
+*  Return MV_FALSE to proceed to the next state on current channel
+*******************************************************************************/
+
+static MV_BOOLEAN mvChannelNotConnectedStateHandler(
+                                                   MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                   MV_U8 channelIndex,
+                                                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    if (pSataAdapter->sataChannel[channelIndex] != NULL)
+    {
+        mvSataRemoveChannel(pSataAdapter,channelIndex);
+        pSataAdapter->sataChannel[channelIndex] = NULL;
+        mvSetDriveReady(ialExt,
+                        scsiAdapterExt,
+                        channelIndex,
+                        0xFF, MV_FALSE, NULL);
+        mvFlushSCSICommandQueue(ialExt, channelIndex);
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvChannelConnectedStateHandler(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_BOOLEAN res = MV_FALSE;
+    MV_BOOLEAN isChannelReady;
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] CHANNEL_CONNECTED\n",
+             ialExt->pSataAdapter->adapterId, channelIndex);
+    if (pSataAdapter->sataChannel[channelIndex] == NULL)
+    {
+        if (IALInitChannel(pSataAdapter, channelIndex) == MV_FALSE)
+        {
+            IALReleaseChannel(pSataAdapter, channelIndex);
+            mvDrivesInfoFlushAll(ialExt, channelIndex);
+            mvSetChannelState(ialExt, channelIndex, CHANNEL_NOT_CONNECTED);
+            return MV_TRUE;
+        }
+    }
+    pSataChannel = pSataAdapter->sataChannel[channelIndex];
+    res = mvStartChannelInit(pSataAdapter,
+                             channelIndex,
+                             scsiAdapterExt,
+                             &isChannelReady);
+    if (res == MV_TRUE)
+    {
+        if (isChannelReady == MV_FALSE)
+        {
+            /*SRST channel, Set polling timer*/
+            mvSetChannelTimer(ialExt, channelIndex,
+                              MV_IAL_SRST_TIMEOUT);
+            mvSetChannelState(ialExt,
+                              channelIndex,
+                              CHANNEL_IN_SRST);
+        }
+        else
+        {
+            if (mvConfigChannelDMA(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt) == MV_TRUE)
+            {
+                mvSetChannelState(ialExt,
+                                  channelIndex,
+                                  CHANNEL_READY);
+            }
+            else
+            {
+                mvStopChannel(ialExt,
+                              channelIndex,
+                              scsiAdapterExt);
+            }
+        }
+    }
+    else
+    {
+        mvStopChannel(ialExt,
+                      channelIndex,
+                      scsiAdapterExt);
+    }
+    return MV_TRUE;
+}
+
+
+MV_BOOLEAN mvChannelInSrstStateHandler(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex,
+                                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_BOOLEAN bFatalError;
+    MV_BOOLEAN res = MV_FALSE;
+    MV_BOOLEAN isChannelReady;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    MV_SATA_CHANNEL *pSataChannel = pSataAdapter->sataChannel[channelIndex];
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] CHANNEL_IN_SRST\n",
+             pSataAdapter->adapterId, channelIndex);
+    mvDecrementChannelTimer(ialExt, channelIndex);
+    res = mvChannelSRSTFinished(ialExt,
+                                pSataChannel,
+                                channelIndex,
+                                scsiAdapterExt,
+                                &isChannelReady,
+                                &bFatalError);
+    if (res == MV_TRUE)
+    {
+        /*Finishing channel initialization*/
+        if (isChannelReady == MV_TRUE)
+        {
+            if (mvConfigChannelDMA(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt) == MV_TRUE)
+            {
+                mvSetChannelState(ialExt,
+                                  channelIndex,
+                                  CHANNEL_READY);
+            }
+            else
+            {
+                mvStopChannel(ialExt,
+                              channelIndex,
+                              scsiAdapterExt);
+            }
+        }
+        else
+        {/*If channel not ready and function call succeed -> PM is found*/
+            if (mvPMEstablishSataComm(ialExt, channelIndex) == MV_FALSE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Failed to "
+                         "staggered spinup PM\n",
+                         pSataAdapter->adapterId,channelIndex);
+                mvStopChannel(ialExt,
+                              channelIndex,
+                              scsiAdapterExt);
+            }
+            else
+            {
+                mvSetChannelState(ialExt, channelIndex,
+                                  CHANNEL_PM_STAGGERED_SPIN_UP);
+                return MV_FALSE;
+            }
+        }
+    }
+    else
+    {
+        if (bFatalError == MV_TRUE)
+        {
+            mvStopChannel(ialExt,
+                          channelIndex,
+                          scsiAdapterExt);
+        }
+        else
+        {
+            if (mvIsChannelTimerExpired(ialExt, channelIndex) == MV_TRUE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,
+                         "[%d %d]: SW reset Failed, timer expired\n",
+                         pSataAdapter->adapterId,channelIndex);
+                mvStopChannel(ialExt,
+                              channelIndex,
+                              scsiAdapterExt);
+            }
+        }
+    }
+    return MV_TRUE;
+}
+
+
+
+
+static MV_BOOLEAN mvChannelPMStaggeredSpinUpStateHandler(
+                                                        MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                        MV_U8 channelIndex,
+                                                        MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_BOOLEAN isChannelReady;
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] CHANNEL_PM_STAGGERED_SPIN_UP\n",
+             ialExt->pSataAdapter->adapterId, channelIndex);
+
+    if (mvPMCheckForConnectedDevices(ialExt,
+                                     channelIndex,
+                                     &isChannelReady) == MV_TRUE)
+    {
+        if (isChannelReady == MV_TRUE)
+        {
+            if (mvConfigChannelDMA(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt) == MV_TRUE)
+            {
+                mvSetChannelState(ialExt, channelIndex, CHANNEL_READY);
+
+            }
+            else
+            {
+                mvStopChannel(ialExt, channelIndex, scsiAdapterExt);
+            }
+        }
+        else
+        {
+            /*SRST first PM port, Set polling timer*/
+            mvSetChannelTimer(ialExt, channelIndex, MV_IAL_SRST_TIMEOUT);
+            mvSetChannelState(ialExt, channelIndex, CHANNEL_PM_SRST_DEVICE);
+        }
+    }
+    else
+    {
+        mvStopChannel(ialExt, channelIndex, scsiAdapterExt);
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvChannelPMSrstDeviceStateHandler(
+                                                   MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                   MV_U8 channelIndex,
+                                                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+
+    MV_BOOLEAN isChannelReady;
+    MV_BOOLEAN isDeviceReconnected;
+    MV_BOOLEAN isPMErrorDetected;
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] CHANNEL_PM_SRST_DEVICE\n",
+             ialExt->pSataAdapter->adapterId, channelIndex);
+    mvDecrementChannelTimer(ialExt, channelIndex);
+    if (mvInitPMDevice(ialExt,
+                       channelIndex,
+                       scsiAdapterExt,
+                       &isChannelReady,
+                       &isDeviceReconnected,
+                       &isPMErrorDetected) == MV_TRUE)
+    {
+        if (isDeviceReconnected == MV_TRUE)
+        {
+            mvRestartChannel(ialExt, channelIndex, scsiAdapterExt, MV_FALSE);
+            return MV_TRUE;
+        }
+        if (isChannelReady == MV_TRUE)
+        {
+            if (mvConfigChannelDMA(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt) == MV_TRUE)
+            {
+                mvSetChannelState(ialExt, channelIndex, CHANNEL_READY);
+            }
+            else
+            {
+                mvStopChannel(ialExt, channelIndex, scsiAdapterExt);
+            }
+        }
+        else
+        {
+            /*PM port is initialized, SRST next PM Port,
+            Set polling timer*/
+            mvSetChannelTimer(ialExt, channelIndex, MV_IAL_SRST_TIMEOUT);
+        }
+    }
+    else
+    {
+        /*SRST timeout is expired*/
+        if (mvIsChannelTimerExpired(ialExt, channelIndex) == MV_TRUE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] PM device "
+                     "SRST timeout detected.\n",
+                     ialExt->pSataAdapter->adapterId, channelIndex);
+            if (mvConfigChannelDMA(ialExt,
+                                   channelIndex,
+                                   scsiAdapterExt) == MV_TRUE)
+            {
+                mvSetChannelState(ialExt, channelIndex, CHANNEL_READY);
+            }
+            else
+            {
+                mvStopChannel(ialExt, channelIndex, scsiAdapterExt);
+            }
+        }
+        else
+        {
+            if (isPMErrorDetected == MV_TRUE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] unable "
+                         "to configure PM\n.", ialExt->pSataAdapter->adapterId,
+                         channelIndex);
+                mvStopChannel(ialExt, channelIndex, scsiAdapterExt);
+            }
+        }
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvChannelReadyStateHandler(
+                                            MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                            MV_U8 channelIndex)
+{
+
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    if ((ialExt->IALChannelExt[channelIndex].pmRegAccessInProgress == MV_FALSE) &&
+        (mvStorageDevGetDeviceType (pSataAdapter, channelIndex) == MV_SATA_DEVICE_TYPE_PM) &&
+        (ialExt->IALChannelExt[channelIndex].pmAsyncNotifyEnabled == MV_FALSE))
+    {
+        if (mvQueuePMAccessRegisterCommand(ialExt,
+                                           channelIndex,
+                                           MV_SATA_PM_CONTROL_PORT,
+                                           MV_SATA_GSCR_ERROR_REG_NUM,
+                                           0,
+                                           MV_TRUE) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] error reading "
+                     " PM GSCR_ERROR register.\n",
+                     pSataAdapter->adapterId, channelIndex);
+        }
+    }
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvChannelPMHotPlugStateHandler(
+                                                MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                                MV_U8 channelIndex,
+                                                MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d] CHANNEL_PM_HOT_PLUG\n",
+             ialExt->pSataAdapter->adapterId, channelIndex);
+    mvSataDisableChannelDma(ialExt->pSataAdapter, channelIndex);
+    mvSataFlushDmaQueue (ialExt->pSataAdapter,
+                         channelIndex, MV_FLUSH_TYPE_CALLBACK);
+    mvSataChannelHardReset(ialExt->pSataAdapter, channelIndex);
+    mvRestartChannel(ialExt, channelIndex, scsiAdapterExt, MV_FALSE);
+    return MV_TRUE;
+}
+
+static MV_BOOLEAN mvChannelStateMachine(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_U8 channelIndex,
+                                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_BOOLEAN res = MV_FALSE;
+    do
+    {
+        switch (ialExt->channelState[channelIndex])
+        {
+        case CHANNEL_NOT_CONNECTED:
+            res = mvChannelNotConnectedStateHandler(ialExt,
+                                                    channelIndex,
+                                                    scsiAdapterExt);
+            break;
+        case CHANNEL_CONNECTED:
+            res = mvChannelConnectedStateHandler(ialExt,
+                                                 channelIndex,
+                                                 scsiAdapterExt);
+            break;
+        case CHANNEL_IN_SRST:
+            res = mvChannelInSrstStateHandler(ialExt,
+                                              channelIndex,
+                                              scsiAdapterExt);
+            break;
+        case CHANNEL_PM_STAGGERED_SPIN_UP:
+            res = mvChannelPMStaggeredSpinUpStateHandler(ialExt,
+                                                         channelIndex,
+                                                         scsiAdapterExt);
+            break;
+        case CHANNEL_PM_SRST_DEVICE:
+            res = mvChannelPMSrstDeviceStateHandler(ialExt,
+                                                    channelIndex,
+                                                    scsiAdapterExt);
+            break;
+        case CHANNEL_READY:
+            res = mvChannelReadyStateHandler(ialExt,
+                                             channelIndex);
+            break;
+        case CHANNEL_PM_HOT_PLUG:
+            res = mvChannelPMHotPlugStateHandler(ialExt,
+                                                 channelIndex,
+                                                 scsiAdapterExt);
+            break;
+        default:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Unknown channel state.\n",
+                     ialExt->pSataAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+        }
+    } while (res == MV_FALSE);
+
+    return MV_TRUE;
+}
+
+
+static MV_BOOLEAN mvAdapterStateMachine(
+                                       MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt)
+{
+    MV_BOOLEAN res = MV_TRUE;
+    MV_U8 channelIndex;
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    switch (ialExt->adapterState)
+    {
+    case ADAPTER_INITIALIZING:     {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d] ADAPTER_INITIALIZING\n",
+                     pSataAdapter->adapterId);
+
+            res = mvSataEnableStaggeredSpinUpAll(pSataAdapter);
+            if (res == MV_TRUE)
+            {
+                if (pSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+                {
+                    if (mvSataUnmaskAdapterInterrupt(pSataAdapter) == MV_FALSE)
+                    {
+                        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d]: "
+                                 "mvSataUnmaskAdapterInterrupt failed\n",
+                                 pSataAdapter->adapterId);
+                        ialExt->adapterState = ADAPTER_FATAL_ERROR;
+                        return MV_FALSE;
+                    }
+                    ialExt->adapterState = ADAPTER_READY;
+                }
+                else
+                {
+                    if (mvSataUnmaskAdapterInterrupt(pSataAdapter) == MV_FALSE)
+                    {
+                        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d]:"
+                                 "mvSataUnmaskAdapterInterrupt failed\n",
+                                 pSataAdapter->adapterId);
+                        ialExt->adapterState = ADAPTER_FATAL_ERROR;
+                        return MV_FALSE;
+                    }
+                    ialExt->adapterState = ADAPTER_READY;
+                }
+            }
+        }
+        break;
+    case ADAPTER_READY:
+        for (channelIndex = 0;
+            channelIndex < pSataAdapter->numberOfChannels; channelIndex++)
+        {
+
+            mvChannelStateMachine(ialExt,
+                                  channelIndex,
+                                  scsiAdapterExt);
+        }
+        return MV_TRUE;
+        break;
+    default:
+        break;
+    }
+
+    if (ialExt->adapterState != ADAPTER_READY)
+    {
+        return res;
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d] ADAPTER_READY\n",
+             pSataAdapter->adapterId);
+
+    /*Start channel initialization for connected channels*/
+    for (channelIndex = 0;
+        channelIndex < pSataAdapter->numberOfChannels;
+        channelIndex++)
+    {
+        mvFlushSCSICommandQueue(ialExt, channelIndex);
+        if (mvSataIsStorageDeviceConnected(pSataAdapter, channelIndex) ==
+            MV_FALSE)
+        {
+            mvSetChannelState(ialExt,
+                              channelIndex,
+                              CHANNEL_NOT_CONNECTED);
+            continue;
+        }
+
+        mvSetChannelState(ialExt,
+                          channelIndex,
+                          CHANNEL_CONNECTED);
+        if (mvChannelStateMachine(ialExt,
+                                  channelIndex,
+                                  scsiAdapterExt) == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]: Failed to "
+                     "start channel.\n", pSataAdapter->adapterId, channelIndex);
+            mvSetChannelState(ialExt,
+                              channelIndex,
+                              CHANNEL_NOT_CONNECTED);
+            mvFlushSCSICommandQueue(ialExt, channelIndex);
+            mvSataRemoveChannel(pSataAdapter,channelIndex);
+            IALReleaseChannel(pSataAdapter, channelIndex);
+            pSataAdapter->sataChannel[channelIndex] = NULL;
+            mvDrivesInfoFlushAll(ialExt, channelIndex);
+            mvSetDriveReady(ialExt,
+                            scsiAdapterExt,
+                            channelIndex,
+                            0xFF, MV_FALSE, NULL);
+            continue;
+        }
+    }
+    return res;
+}
+
+
+static MV_BOOLEAN mvGetEDMAAllowedModes(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                        MV_SAL_ADAPTER_EXTENSION *pScsiAdapterExt,
+                                        MV_U8 channelIndex,
+                                        MV_BOOLEAN *TCQ,
+                                        MV_BOOLEAN *NCQ,
+                                        MV_U8   *queueDepth,
+                                        MV_U8   *numOfDrives)
+{
+    MV_SATA_ADAPTER *pSataAdapter = ialExt->pSataAdapter;
+    *numOfDrives = 0;
+    if ((pSataAdapter == NULL) || (pScsiAdapterExt == NULL))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d]"
+                 " mvGetEMDAAllowedModes failed, bad pointer\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    if ((ialExt->adapterState != ADAPTER_READY) ||
+        (ialExt->channelState[channelIndex] == CHANNEL_NOT_CONNECTED))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] "
+                 "mvGetEMDAAllowedModes failed,Bad Adapter or Channel State\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    if (pSataAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] "
+                 "mvGetEMDAAllowedModes failed, channel not configured\n",
+                 pSataAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    if (mvStorageDevGetDeviceType (pSataAdapter, channelIndex) ==
+        MV_SATA_DEVICE_TYPE_ATA_DISK)
+    {
+        *numOfDrives = 1;
+    }
+
+    if (TCQ)
+    {
+        MV_U8  PMPort = 0;
+        MV_SATA_DEVICE_TYPE devType =
+        mvStorageDevGetDeviceType (pSataAdapter, channelIndex);
+        *TCQ = MV_FALSE;
+        switch (devType)
+        {
+        /*allow TCQ mode only if one drive connected*/
+        case MV_SATA_DEVICE_TYPE_PM:{
+                MV_U8  i;
+                MV_U8  numOFDrives = 0;
+                for (i = 0; i < MV_SATA_PM_MAX_PORTS; i++)
+                {
+                    if (pScsiAdapterExt->
+                        ataDriveData[channelIndex][i].driveReady == MV_TRUE)
+                    {
+                        PMPort = i;
+                        numOFDrives++;
+                    }
+                }
+                *numOfDrives = numOFDrives;
+                if (numOFDrives != 1)
+                {
+                    break;
+                }
+            }
+            /*the drive connected to PM on device port number PMPort*/
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: "
+                     "mvGetEMDAAllowedModes one drive connected - check if TCQ"
+                     " allowed\n", pSataAdapter->adapterId, channelIndex,
+                     PMPort);
+        case MV_SATA_DEVICE_TYPE_ATA_DISK:
+
+            if (pScsiAdapterExt->ataDriveData[channelIndex][PMPort].driveReady
+                != MV_TRUE)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d] "
+                         "mvGetEMDAAllowedModes failed, channel not ready\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                return MV_FALSE;
+            }
+            *TCQ =
+            pScsiAdapterExt->ataDriveData[channelIndex][PMPort].
+            identifyInfo.DMAQueuedModeSupported;
+            if (queueDepth == NULL)
+            {
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d] "
+                         "mvGetEMDAAllowedModes failed, bad pointer to queueDepth\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+                return MV_FALSE;
+            }
+            *queueDepth = pScsiAdapterExt->ataDriveData[channelIndex][PMPort].
+                          identifyInfo.DMAQueuedModeDepth;
+            break;
+        default:
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] "
+                     "mvGetEMDAAllowedModes failed, bad device type\n",
+                     pSataAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+        }
+    }
+    if (NCQ)
+    {
+        MV_U8  PMPort = 0;
+        MV_BOOLEAN allNCQ = MV_TRUE;
+        MV_U8 minQueueDepth = 32;
+        if (pSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            *NCQ = MV_FALSE;
+        }
+        else
+        {
+            MV_SATA_DEVICE_TYPE devType =
+            mvStorageDevGetDeviceType (pSataAdapter, channelIndex);
+
+
+            switch (devType)
+            {
+            case MV_SATA_DEVICE_TYPE_PM:{
+                    MV_U8  i;
+                    MV_U8  numOFDrives = 0;
+                    for (i = 0; i < MV_SATA_PM_MAX_PORTS; i++)
+                    {
+                        if (pScsiAdapterExt->
+                            ataDriveData[channelIndex][i].driveReady == MV_TRUE)
+                        {
+                            PMPort = i;
+                            numOFDrives++;
+                            if (pScsiAdapterExt->
+                                ataDriveData[channelIndex][i].identifyInfo.
+                                SATACapabilities.NCQSupported == MV_FALSE)
+                            {
+                                allNCQ = MV_FALSE;
+                            }
+                            else
+                            {
+                                if (minQueueDepth > pScsiAdapterExt->
+                                    ataDriveData[channelIndex][PMPort].
+                                    identifyInfo.DMAQueuedModeDepth)
+                                {
+                                    minQueueDepth = pScsiAdapterExt->
+                                                    ataDriveData[channelIndex][PMPort].
+                                                    identifyInfo.DMAQueuedModeDepth;
+                                }
+                            }
+                        }
+                    }
+                    *numOfDrives = numOFDrives;
+                    if ((numOFDrives != 1) && (allNCQ == MV_FALSE))
+                    {
+                        break;
+                    }
+                    if (numOFDrives == 0)
+                    {
+                        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d  ]: "
+                                 " No drives connected\n",
+                                 pSataAdapter->adapterId, channelIndex);
+                        break;
+                    }
+
+                    if (numOFDrives > 1 && allNCQ == MV_TRUE)
+                    {
+                        *queueDepth = minQueueDepth;
+                        *NCQ = MV_TRUE;
+                        /*the drive connected to PM on device port number PMPort*/
+                        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: "
+                                 "%d NCQ drives connected. Minimum queue "
+                                 "depth = %d\n",
+                                 pSataAdapter->adapterId, channelIndex,
+                                 PMPort, numOFDrives, *queueDepth);
+                        break;
+                    }
+                }
+                /*the drive connected to PM on device port number PMPort*/
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: mvGetEMDAAllowedModes, "
+                         "one drive connected - check if NCQ allowed\n",
+                         pSataAdapter->adapterId, channelIndex, PMPort);
+
+            case MV_SATA_DEVICE_TYPE_ATA_DISK:
+
+                if (pScsiAdapterExt->
+                    ataDriveData[channelIndex][PMPort].driveReady != MV_TRUE)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d] "
+                             "mvGetEMDAAllowedModes failed, "
+                             "channel not ready\n",
+                             pSataAdapter->adapterId, channelIndex, PMPort);
+                    return MV_FALSE;
+                }
+                *NCQ = pScsiAdapterExt->
+                       ataDriveData[channelIndex][PMPort].identifyInfo.
+                       SATACapabilities.NCQSupported;
+                if (queueDepth == NULL)
+                {
+                    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d] "
+                             "mvGetEMDAAllowedModes failed, "
+                             "bad pointer to queueDepth\n",
+                             pSataAdapter->adapterId, channelIndex, PMPort);
+                    return MV_FALSE;
+                }
+                *queueDepth = pScsiAdapterExt->
+                              ataDriveData[channelIndex][PMPort].
+                              identifyInfo.DMAQueuedModeDepth;
+                break;
+            default:
+                mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d] "
+                         "mvGetEMDAAllowedModes failed, bad device type\n",
+                         pSataAdapter->adapterId, channelIndex);
+                return MV_FALSE;
+            }
+        }
+    }
+    return MV_TRUE;
+}
+
+
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALCommon.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALCommon.h
@@ -0,0 +1,172 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvIALCommon.h
+*
+* DESCRIPTION:
+*       H implementation for IAL's extension utility functions.
+*
+* DEPENDENCIES:
+*   mvSata.h
+*   mvStorageDev.h
+*
+*******************************************************************************/
+#ifndef __INCmvIALCommonh
+#define __INCmvIALCommonh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "mvSata.h"
+#include "mvStorageDev.h"
+
+/* defines  */
+
+/*Timer period in milliseconds*/
+#define MV_IAL_ASYNC_TIMER_PERIOD       500
+#define MV_IAL_SRST_TIMEOUT             31000
+
+/* typedefs */
+
+
+
+    typedef enum mvAdapterState
+    {
+        ADAPTER_INITIALIZING,
+        ADAPTER_READY,
+        ADAPTER_FATAL_ERROR
+    } MV_ADAPTER_STATE;
+
+    typedef enum mvChannelState
+    {
+        CHANNEL_NOT_CONNECTED,
+        CHANNEL_CONNECTED,
+        CHANNEL_IN_SRST,
+        CHANNEL_PM_STAGGERED_SPIN_UP,
+        CHANNEL_PM_SRST_DEVICE,
+        CHANNEL_READY,
+        CHANNEL_PM_HOT_PLUG,
+    } MV_CHANNEL_STATE;
+
+typedef struct mvDriveSerialNumber
+{
+    MV_U8 serial[IDEN_SERIAL_NUM_SIZE];
+}   MV_DRIVE_SERIAL_NUMBER;
+
+
+typedef struct mvDrivesInfo
+{
+    MV_U16                      drivesSnapshotSaved;
+    MV_DRIVE_SERIAL_NUMBER      driveSerialSaved[MV_SATA_PM_MAX_PORTS];
+    MV_U16                      drivesSnapshotCurrent;
+    MV_DRIVE_SERIAL_NUMBER      driveSerialCurrent[MV_SATA_PM_MAX_PORTS];
+}   MV_DRIVES_INFO;
+
+
+    typedef struct mvIALChannelExtension
+    {
+        MV_U8                       PMnumberOfPorts;
+        MV_U16                      PMdevsToInit;
+        MV_U8                       devInSRST;
+        MV_BOOLEAN                  completionError;
+        MV_U8                       pmAccessType;
+        MV_U8                       pmReg;
+        MV_BOOLEAN                  pmRegAccessInProgress;
+        MV_BOOLEAN                  pmAsyncNotifyEnabled;
+        MV_U32                      SRSTTimerThreshold;
+        MV_U32                      SRSTTimerValue;
+        MV_VOID_PTR                 IALChannelPendingCmdQueue;
+    MV_BOOLEAN                  bHotPlug;
+    MV_DRIVES_INFO              drivesInfo;
+} MV_IAL_COMMON_CHANNEL_EXTENSION;
+
+
+    typedef struct mvIALCommonAdapterExtension
+    {
+        MV_SATA_ADAPTER   *pSataAdapter;
+        MV_ADAPTER_STATE  adapterState;
+        MV_CHANNEL_STATE  channelState[MV_SATA_CHANNELS_NUM];
+        MV_IAL_COMMON_CHANNEL_EXTENSION IALChannelExt[MV_SATA_CHANNELS_NUM];
+    } MV_IAL_COMMON_ADAPTER_EXTENSION;
+
+
+/*Public functions*/
+    MV_BOOLEAN mvAdapterStartInitialization(MV_SATA_ADAPTER* pSataAdapter,
+                                            MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                            MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+    void mvRestartChannel(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                          MV_U8 channelIndex,
+                          MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt,
+                          MV_BOOLEAN    bBusReset);
+
+    void mvStopChannel(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                       MV_U8 channelIndex,
+                       MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+    void mvPMHotPlugDetected(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                             MV_U8 channelIndex,
+                             MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+
+    MV_SCSI_COMMAND_STATUS_TYPE mvExecuteScsiCommand(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                                     MV_BOOLEAN canQueue);
+
+    MV_BOOLEAN  mvIALTimerCallback(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                   MV_SAL_ADAPTER_EXTENSION *scsiAdapterExt);
+
+    void mvCommandCompletionErrorHandler(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                         MV_U8 channelIndex);
+
+    MV_BOOLEAN mvRemoveFromSCSICommandQueue(MV_IAL_COMMON_ADAPTER_EXTENSION *ialExt,
+                                            MV_U8 channelIndex,
+                                            MV_SATA_SCSI_CMD_BLOCK *pScb);
+
+/*The following functions which must be implemented in IAL*/
+
+    MV_BOOLEAN IALConfigQueuingMode(MV_SATA_ADAPTER *pSataAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_EDMA_MODE mode,
+                                    MV_U8 queueDepth);
+
+
+    MV_BOOLEAN IALInitChannel(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex);
+
+    void IALReleaseChannel(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex);
+    MV_BOOLEAN IALBusChangeNotify(MV_SATA_ADAPTER *pSataAdapter,
+                                  MV_U8 channelIndex);
+    MV_BOOLEAN IALBusChangeNotifyEx(MV_SATA_ADAPTER *pSataAdapter,
+                              MV_U8 channelIndex,
+                              MV_U16 targetsToRemove,
+                              MV_U16 targetsToAdd);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvIALCommonh */
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALCommonUtils.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALCommonUtils.c
@@ -0,0 +1,848 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvOs.h"
+#include "mvIALCommonUtils.h"
+
+
+static MV_BOOLEAN mvConfigSataDisk(MV_SATA_ADAPTER *pSataAdapter,
+                                   MV_U8 channelIndex,
+                                   MV_U8 PMPort,
+                                   ATA_IDENTIFY_INFO   *pIdentifyInfo,
+                                   MV_U16_PTR identifyBuffer);
+
+
+static MV_VOID mvAta2HostString(MV_U16 *source, MV_U16 *target,
+                                MV_U32 wordsCount)
+{
+    MV_U32 i;
+    for (i=0 ; i < wordsCount; i++)
+    {
+        /* Big to little*/
+        target[i] = (source[i] >> 8) | ((source[i] & 0xff) << 8);
+        /* Little to cpu*/
+        target[i] = MV_LE16_TO_CPU(target[i]);
+    }
+}
+
+/******************************************************************************
+ *  Name: ParseIdentifyResult
+ *
+ *  Description:    this functions parses the identify command results, checks
+ *                  that the connected deives can be accesed by device EDMA,
+ *                  and updates the ATA drive parameters stucture accordingly.
+ *
+ *  Parameters:     pSataChannel - pointer to the channel data structure.
+ *                  pIdentifyInfo- pointer to the ATA parameters structure.
+ *
+ *  Returns:        MV_TRUE if the ATA drive supported by device.
+ *
+ ******************************************************************************/
+MV_BOOLEAN mvParseIdentifyResult(MV_U16_PTR  iden,
+                                 ATA_IDENTIFY_INFO   *pIdentifyInfo)
+{
+    char    temp[80];
+    MV_U8  version;
+    MV_BOOLEAN  udmaModeEnabled = MV_FALSE;
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "Parse IDENTIFY data:\n");
+
+    mvAta2HostString( iden + IDEN_MODEL_OFFSET, (MV_U16_PTR)temp, 24);
+    temp[25] = '\0';
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n","Model", temp);
+    memcpy(&pIdentifyInfo->model[0], iden + IDEN_MODEL_OFFSET, 24);
+    memcpy(&pIdentifyInfo->firmware[0], iden + IDEN_FIRMWARE_OFFSET, 4);
+    /* ATA version supported*/
+    if (iden[IDEN_ATA_VERSION] & MV_BIT7)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %d\n", "ATA version supported", 7);
+        version = 7;
+    }
+    else if (iden[IDEN_ATA_VERSION] & MV_BIT6)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %d\n", "ATA version supported", 6);
+        version = 6;
+    }
+    else if (iden[IDEN_ATA_VERSION] & MV_BIT5)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %d\n", "ATA version supported", 5);
+        version = 5;
+    }
+    else if (iden[IDEN_ATA_VERSION] & MV_BIT4)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %d\n", "ATA version supported", 4);
+        version = 4;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, " IDENTIFY info: ATA "
+                 "version(%d) not supported\n", iden[IDEN_ATA_VERSION]);
+        return MV_FALSE;
+    }
+    pIdentifyInfo->version = version;
+    /*LBA addressing*/
+    if ((version >= 6) && (!(iden[IDEN_CAPACITY_1_OFFSET] & MV_BIT9)))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, " IDENTIFY info: LBA not supported\n");
+        return MV_FALSE;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "Capabilities",
+                 "LBA supported");
+    }
+    /* 48 bit address */
+    if ((version >= 6) && (iden[IDEN_SUPPORTED_COMMANDS2] & MV_BIT10))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "LBA48 addressing", "supported");
+        pIdentifyInfo->LBA48Supported = MV_TRUE;
+
+        if ((iden[103]) || (iden[102]))
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "WARNING Disk size more "
+                     "than 32 bit sectors - setting to 0xffffffff sectors\n");
+            pIdentifyInfo->ATADiskSize = 0xffffffff;
+        }
+        else
+        {
+            pIdentifyInfo->ATADiskSize = ((MV_U32)iden[101] << 16) |
+                                         ((MV_U32)iden[100]);
+        }
+
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - 0x%x%04x%04x%04x sectors\n",
+                 "Number of sectors", iden[103] , iden[102], iden[101],
+                 iden[100]);
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "LBA48 addressing", "Not supported");
+        pIdentifyInfo->LBA48Supported = MV_FALSE;
+        pIdentifyInfo->ATADiskSize = ((MV_U32)iden[IDEN_NUM_OF_ADDRESSABLE_SECTORS + 1] << 16) |
+                                     ((MV_U32)iden[IDEN_NUM_OF_ADDRESSABLE_SECTORS]);
+
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - 0x%x sectors\n",
+                 "Number of sectors",
+                 (iden[IDEN_NUM_OF_ADDRESSABLE_SECTORS + 1] << 16) |
+                 ((MV_U32)iden[IDEN_NUM_OF_ADDRESSABLE_SECTORS]));
+
+
+    }
+    /*DMA support*/
+    if ((version >= 6) && (!(iden[IDEN_CAPACITY_1_OFFSET] & MV_BIT8)))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "IDENTIFY info: DMA not "
+                 "supported\n");
+        return MV_FALSE;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "Capabilities",
+                 "DMA supported");
+    }
+    /* PIO */
+    if ((iden[IDEN_VALID] & MV_BIT1) == 0)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, " IDENTIFY info: not "
+                 "able to find PIO mode\n");
+        return MV_FALSE;
+    }
+    else if (iden[IDEN_PIO_MODE_SPPORTED] & MV_BIT0)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "PIO mode 3",
+                 "supported");
+        pIdentifyInfo->PIOMode = MV_ATA_TRANSFER_PIO_3;
+    }
+    else if (iden[IDEN_PIO_MODE_SPPORTED] & MV_BIT1)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "PIO mode 4",
+                 "supported");
+        pIdentifyInfo->PIOMode = MV_ATA_TRANSFER_PIO_4;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "IDENTIFY info: PIO "
+                 "modes 3 and 4 not supported\n");
+        pIdentifyInfo->PIOMode = MV_ATA_TRANSFER_PIO_SLOW;
+        return MV_FALSE;
+    }
+
+
+    /*UDMA*/
+    if ((iden[IDEN_VALID] & MV_BIT2) == 0)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, " IDENTIFY info: not "
+                 "able to find UDMA mode\n");
+        return MV_FALSE;
+    }
+
+
+    if ((version >= 7) && (iden[IDEN_UDMA_MODE] & MV_BIT6))
+    {
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_6;
+        if (iden[IDEN_UDMA_MODE] & MV_BIT14)
+        {
+            udmaModeEnabled = MV_TRUE;
+        }
+    }
+    else if ((version >= 6) && (iden[IDEN_UDMA_MODE] & MV_BIT5))
+    {
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_5;
+        if (iden[IDEN_UDMA_MODE] & MV_BIT13)
+        {
+            udmaModeEnabled = MV_TRUE;
+        }
+    }
+    else if ((version >= 5) && (iden[IDEN_UDMA_MODE] & MV_BIT4))
+    {
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_4;
+        if (iden[IDEN_UDMA_MODE] & MV_BIT12)
+        {
+            udmaModeEnabled = MV_TRUE;
+        }
+    }
+    else if ((version >= 4) && (iden[IDEN_UDMA_MODE] & MV_BIT3))
+    {
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_3;
+        if (iden[IDEN_UDMA_MODE] & MV_BIT11)
+        {
+            udmaModeEnabled = MV_TRUE;
+        }
+    }
+    else if (iden[IDEN_UDMA_MODE] & MV_BIT2)
+    {
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_2;
+        if (iden[IDEN_UDMA_MODE] & MV_BIT10)
+        {
+            udmaModeEnabled = MV_TRUE;
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "IDENTIFY info: Ultra"
+                 " DMA mode < 2 not supported IDENTIFY[88] 0x%04x\n",
+                 iden[IDEN_UDMA_MODE]);
+        pIdentifyInfo->UdmaMode = MV_ATA_TRANSFER_UDMA_0;
+        return MV_FALSE;
+    }
+    if (udmaModeEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s%d%s\n",
+                 "Ultra DMA mode","UDMA mode ",
+                 pIdentifyInfo->UdmaMode - MV_ATA_TRANSFER_UDMA_0,
+                 " supported and enabled");
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s%d%s\n",
+                 "Ultra DMA mode","UDMA mode ",
+                 pIdentifyInfo->UdmaMode - MV_ATA_TRANSFER_UDMA_0,
+                 " supported but disabled");
+    }
+
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT13))
+    {
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT13)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "READ BUFFER", "supported and enabled");
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "READ BUFFER", "supported and disabled");
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "READ BUFFER",
+                 " Not supported");
+    }
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT12))
+    {
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT12)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "WRITE BUFFER", "supported and enabled");
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "WRITE BUFFER", "supported and disabled");
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "WRITE BUFFER",
+                 "Not supported");
+    }
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT6))
+    {
+        pIdentifyInfo->readAheadSupported = MV_TRUE;
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT6)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "READ LOOK-AHEAD", "supported and enabled");
+            pIdentifyInfo->readAheadEnabled = MV_TRUE;
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "READ LOOK-AHEAD", "supported and disabled");
+            pIdentifyInfo->readAheadEnabled = MV_FALSE;
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "READ LOOK-AHEAD","Not supported");
+        pIdentifyInfo->readAheadSupported = MV_FALSE;
+        pIdentifyInfo->readAheadEnabled = MV_FALSE;
+    }
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT5))
+    {
+        pIdentifyInfo->writeCacheSupported = MV_TRUE;
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT5)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "WRITE CACHE", "supported and enabled");
+            pIdentifyInfo->writeCacheEnabled = MV_TRUE;
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "WRITE CACHE", "supported and disabled");
+            pIdentifyInfo->writeCacheEnabled = MV_FALSE;
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "WRITE CACHE",
+                 "Not supported");
+        pIdentifyInfo->writeCacheSupported = MV_FALSE;
+        pIdentifyInfo->writeCacheEnabled = MV_FALSE;
+    }
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT3))
+    {
+
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT3)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "POWER MANAGMENT", "supported and enabled");
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n",
+                     "POWER MANAGMENT", "supported and disabled");
+        }
+
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "POWER MANAGMENT","Not supported");
+    }
+
+    if ((iden[IDEN_SUPPORTED_COMMANDS1] & MV_BIT0))
+    {
+
+        if (iden[IDEN_ENABLED_COMMANDS1] & MV_BIT0)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n", "SMART",
+                     "supported and enabled");
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %20s\n", "SMART",
+                     "supported and disabled");
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "SMART",
+                 "Not supported");
+    }
+
+
+    /* check if REAd/WRITE DMA QUEUE commands supported */
+    pIdentifyInfo->DMAQueuedModeDepth = (iden[IDEN_QUEUE_DEPTH] & 0x1f) + 1;
+    if ((version >= 5) &&(iden[IDEN_SUPPORTED_COMMANDS2] & MV_BIT1))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %15s Queue Depth %d\n",
+                 "READ/WRITE DMA QUEUE","supported",
+                 (iden[IDEN_QUEUE_DEPTH] & 0x1f) + 1);
+        pIdentifyInfo->DMAQueuedModeSupported = MV_TRUE;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "READ/WRITE DMA QUEUE", "not supported");
+        pIdentifyInfo->DMAQueuedModeSupported = MV_FALSE;
+    }
+
+    /*check that the non-UDMA ATA commands supported*/
+
+    /*FLUSH CHACHE*/
+    if ((version >=6) && ((iden[IDEN_SUPPORTED_COMMANDS2] & MV_BIT12) == 0))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "FLUSH CACHE command", "not supported");
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n",
+                 "FLUSH CACHE command", "supported");
+    }
+
+    pIdentifyInfo->SATACapabilities.SATA_GEN_I_supported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.SATA_GEN_II_supported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.NCQSupported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.RxHostInitiatedPMSupported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.TxDeviceInitiatedPMSupported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.TxDeviceInitiatedPMEnabled = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.DMASetupAutoActiveSupported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.DMASetupAutoActiveEnables = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.NonZeroBufferOffsetSupported = MV_FALSE;
+    pIdentifyInfo->SATACapabilities.NonZeroBufferOffsetEnabled = MV_FALSE;
+
+    if (version >= 6)
+    {
+        if (iden[IDEN_SATA_CAPABILITIES] & MV_BIT1)
+        {
+            pIdentifyInfo->SATACapabilities.SATA_GEN_I_supported = MV_TRUE;
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "SATA Gen I",
+                     "not supported");
+        }
+        if (iden[IDEN_SATA_CAPABILITIES] & MV_BIT2)
+        {
+            pIdentifyInfo->SATACapabilities.SATA_GEN_II_supported = MV_TRUE;
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "SATA Gen II",
+                     "supported");
+        }
+
+        if (iden[IDEN_SATA_CAPABILITIES] & MV_BIT8)
+        {
+            pIdentifyInfo->SATACapabilities.NCQSupported = MV_TRUE;
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %s\n", "NCQ",
+                     "supported");
+        }
+
+        if (iden[IDEN_SATA_CAPABILITIES] & MV_BIT9)
+        {
+            pIdentifyInfo->SATACapabilities.RxHostInitiatedPMSupported = MV_TRUE;
+        }
+
+        if (iden[IDEN_SATA_FEATURES_SUPPORTED] & MV_BIT1)
+        {
+            pIdentifyInfo->SATACapabilities.NonZeroBufferOffsetSupported = MV_TRUE;
+            if (iden[IDEN_SATA_FEATURES_ENABLED] & MV_BIT1)
+            {
+                pIdentifyInfo->SATACapabilities.NonZeroBufferOffsetEnabled = MV_TRUE;
+            }
+        }
+        if (iden[IDEN_SATA_FEATURES_SUPPORTED] & MV_BIT2)
+        {
+            pIdentifyInfo->SATACapabilities.DMASetupAutoActiveSupported = MV_TRUE;
+            if (iden[IDEN_SATA_FEATURES_ENABLED] & MV_BIT2)
+            {
+                pIdentifyInfo->SATACapabilities.DMASetupAutoActiveEnables = MV_TRUE;
+            }
+        }
+        if (iden[IDEN_SATA_FEATURES_SUPPORTED] & MV_BIT3)
+        {
+            pIdentifyInfo->SATACapabilities.TxDeviceInitiatedPMSupported = MV_TRUE;
+            if (iden[IDEN_SATA_FEATURES_ENABLED] & MV_BIT3)
+            {
+                pIdentifyInfo->SATACapabilities.TxDeviceInitiatedPMEnabled = MV_TRUE;
+            }
+        }
+    }
+
+    return MV_TRUE;
+}
+/*******************************************************************************
+* mvGetSataDeviceType - short description
+*
+* DESCRIPTION:
+*       None.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_SATA_DEVICE_TYPE mvGetSataDeviceType(
+                                       MV_STORAGE_DEVICE_REGISTERS *mvStorageDevRegisters)
+{
+    if (((mvStorageDevRegisters->sectorCountRegister & 0xff) != 1) ||
+        ((mvStorageDevRegisters->lbaLowRegister & 0xff) != 1))
+    {
+        return MV_SATA_DEVICE_TYPE_UNKNOWN;
+    }
+    if ((((mvStorageDevRegisters->lbaMidRegister & 0xff) == 0) &&
+         ((mvStorageDevRegisters->lbaHighRegister & 0xff) == 0)) ||
+        (((mvStorageDevRegisters->lbaMidRegister & 0xff) == 0x3C) &&/*ATA-7*/
+         ((mvStorageDevRegisters->lbaHighRegister & 0xff) == 0xC3)))
+    {
+        return MV_SATA_DEVICE_TYPE_ATA_DISK;
+    }
+    if ((((mvStorageDevRegisters->lbaMidRegister & 0xff) == 0x14) &&
+         ((mvStorageDevRegisters->lbaHighRegister & 0xff) == 0xEB))/* ||
+         (((mvStorageDevRegisters->lbaMidRegister & 0xff) == 0x69) &&
+         ((mvStorageDevRegisters->lbaHighRegister & 0xff) == 0x96))*/)
+    {
+        return MV_SATA_DEVICE_TYPE_ATAPI_DISK;
+    }
+    if (((mvStorageDevRegisters->lbaMidRegister & 0xff) == 0x69) &&
+        ((mvStorageDevRegisters->lbaHighRegister & 0xff) == 0x96))
+    {
+        return MV_SATA_DEVICE_TYPE_PM;
+    }
+    return MV_SATA_DEVICE_TYPE_UNKNOWN;
+}
+
+#ifdef MV_LOG_DEBUG
+static void printIdentifyBuffer(MV_U16_PTR identifyBuffer)
+{
+    MV_U8 i,j;
+    /*Print Identify buffer*/
+    for (i = 0; i < 0x20; i++)
+    {
+        mvLogMsg(MV_RAW_MSG_ID,  0, "Words [%03d-%03d]: ", i*8, i*8+7);
+        for (j = 0; j < 0x8; j++)
+        {
+            mvLogMsg(MV_RAW_MSG_ID,  0, "0x%04X ", identifyBuffer[i*8+j]);
+        }
+        mvLogMsg(MV_RAW_MSG_ID,  0, "\n");
+    }
+}
+#endif
+
+/*******************************************************************************
+* mvConfigSataDisk - short description
+*
+* DESCRIPTION:
+*       None.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvConfigSataDisk(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex,
+                            MV_U8 PMPort, ATA_IDENTIFY_INFO   *pIdentifyInfo,
+                            MV_U16_PTR identifyBuffer)
+{
+    MV_STORAGE_DEVICE_REGISTERS inATARegs;
+    MV_STORAGE_DEVICE_REGISTERS outATARegs;
+    /* identify device*/
+    memset(&inATARegs, 0, sizeof(inATARegs));
+    inATARegs.commandRegister = MV_ATA_COMMAND_IDENTIFY;
+    if (mvStorageDevATAIdentifyDevice(pSataAdapter, channelIndex, PMPort,
+                                      identifyBuffer)
+        == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: failed "
+                 "to perform ATA Identify command\n", pSataAdapter->adapterId,
+                 channelIndex, PMPort);
+        return MV_FALSE;
+    }
+#ifdef MV_LOG_DEBUG
+    mvLogMsg(MV_RAW_MSG_ID, 0, "Drive [%d,%d,%d] Identify Buffer:\n",
+             pSataAdapter->adapterId, channelIndex, PMPort);
+
+    printIdentifyBuffer(identifyBuffer);
+#endif
+    if (mvParseIdentifyResult(identifyBuffer, pIdentifyInfo) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: in "
+                 "parsing ATA Identify Data\n", pSataAdapter->adapterId,
+                 channelIndex, PMPort);
+        return MV_FALSE;
+    }
+    if ((pIdentifyInfo->writeCacheSupported == MV_TRUE) &&
+        (pIdentifyInfo->writeCacheEnabled == MV_FALSE))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG,"[%d %d %d]: Write Cache "
+                 "supported but disabled\n", pSataAdapter->adapterId,
+                 channelIndex, PMPort);
+        memset(&inATARegs, 0, sizeof(inATARegs));
+        inATARegs.commandRegister = MV_ATA_COMMAND_SET_FEATURES;
+        inATARegs.featuresRegister = MV_ATA_SET_FEATURES_ENABLE_WCACHE;
+
+        if (mvStorageDevExecutePIO(pSataAdapter, channelIndex, PMPort,
+                                   MV_NON_UDMA_PROTOCOL_NON_DATA,
+                                   MV_FALSE, NULL,0, &inATARegs, &outATARegs)
+            == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                     "Set Features failed(ENABLE WCACHE)\n",
+                     pSataAdapter->adapterId, channelIndex, PMPort);
+            return MV_FALSE;
+        }
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Write Cache "
+                 "enabled\n", pSataAdapter->adapterId, channelIndex, PMPort);
+    }
+    if ((pIdentifyInfo->readAheadSupported == MV_TRUE) &&
+        (pIdentifyInfo->readAheadEnabled == MV_FALSE))
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Read Look "
+                 "Ahead supported but disabled\n", pSataAdapter->adapterId,
+                 channelIndex, PMPort);
+        memset(&inATARegs, 0, sizeof(inATARegs));
+        inATARegs.commandRegister = MV_ATA_COMMAND_SET_FEATURES;
+        inATARegs.featuresRegister = MV_ATA_SET_FEATURES_ENABLE_RLA;
+        if (mvStorageDevExecutePIO(pSataAdapter, channelIndex, PMPort,
+                                   MV_NON_UDMA_PROTOCOL_NON_DATA,
+                                   MV_FALSE, NULL,0, &inATARegs, &outATARegs)
+            == MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"[%d %d %d]: "
+                     "Set Features failed(ENABLE RLA)\n",
+                     pSataAdapter->adapterId, channelIndex, PMPort);
+            return MV_FALSE;
+        }
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Read Look "
+                 "Ahead enabled\n", pSataAdapter->adapterId, channelIndex,
+                 PMPort);
+    }
+    /* mvStorageDevATASetFeatures */
+
+    /* Set transfer mode */
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Set transfer mode "
+             "XFER_PIO_SLOW\n", pSataAdapter->adapterId, channelIndex, PMPort);
+    memset(&inATARegs, 0, sizeof(inATARegs));
+    inATARegs.commandRegister = MV_ATA_COMMAND_SET_FEATURES;
+    inATARegs.featuresRegister = MV_ATA_SET_FEATURES_TRANSFER;
+    inATARegs.sectorCountRegister = MV_ATA_TRANSFER_PIO_SLOW;
+    if (mvStorageDevExecutePIO(pSataAdapter, channelIndex, PMPort,
+                               MV_NON_UDMA_PROTOCOL_NON_DATA,
+                               MV_FALSE, NULL,0, &inATARegs, &outATARegs) ==
+        MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: "
+                 "Set Features failed to set XFER PIO SLOW\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+
+        return MV_FALSE;
+    }
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Set transfer mode "
+             "XFER_PIO_%d\n", pSataAdapter->adapterId, channelIndex, PMPort,
+             pIdentifyInfo->PIOMode - MV_ATA_TRANSFER_PIO_0);
+
+    memset(&inATARegs, 0, sizeof(inATARegs));
+    inATARegs.commandRegister = MV_ATA_COMMAND_SET_FEATURES;
+    inATARegs.featuresRegister = MV_ATA_SET_FEATURES_TRANSFER;
+    inATARegs.sectorCountRegister = pIdentifyInfo->PIOMode;
+    if (mvStorageDevExecutePIO(pSataAdapter, channelIndex, PMPort,
+                               MV_NON_UDMA_PROTOCOL_NON_DATA,
+                               MV_FALSE, NULL,0, &inATARegs, &outATARegs) ==
+        MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: "
+                 "Set Features failed to set XFER PIO %d\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort,
+                 pIdentifyInfo->PIOMode - MV_ATA_TRANSFER_PIO_0);
+        return MV_FALSE;
+    }
+
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d %d]: Set transfer mode"
+             " XFER_UDMA_%d\n", pSataAdapter->adapterId, channelIndex, PMPort,
+             pIdentifyInfo->UdmaMode & 0xf);
+    memset(&inATARegs, 0, sizeof(inATARegs));
+    inATARegs.commandRegister = MV_ATA_COMMAND_SET_FEATURES;
+    inATARegs.featuresRegister = MV_ATA_SET_FEATURES_TRANSFER;
+    inATARegs.sectorCountRegister = pIdentifyInfo->UdmaMode;
+    if (mvStorageDevExecutePIO(pSataAdapter, channelIndex, PMPort,
+                               MV_NON_UDMA_PROTOCOL_NON_DATA,
+                               MV_FALSE, NULL,0, &inATARegs, &outATARegs) ==
+        MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: "
+                 "Set Features failed to set XFER UDMA %d\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort,
+                 pIdentifyInfo->UdmaMode & 0xf);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvInitSataDisk - short description
+*
+* DESCRIPTION:
+*       None.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvInitSataDisk(MV_SATA_ADAPTER   *pSataAdapter, MV_U8 channelIndex,
+                          MV_U8 PMPort, ATA_IDENTIFY_INFO   *pIdentifyInfo,
+                          MV_U16_PTR identifyBuffer
+                         )
+{
+#if 0
+    MV_STORAGE_DEVICE_REGISTERS mvStorageDevRegisters;
+    MV_SATA_DEVICE_TYPE deviceType;
+
+    /* Software reset channel */
+    if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex, PMPort,
+                                       &mvStorageDevRegisters)== MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: Software reset "
+                 "failed\n", pSataAdapter->adapterId, channelIndex, PMPort);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR," ATA Drive Registers:\n");
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","Error", mvStorageDevRegisters.errorRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","SectorCount", mvStorageDevRegisters.sectorCountRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","LBA Low", mvStorageDevRegisters.lbaLowRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","LBA Mid", mvStorageDevRegisters.lbaMidRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","LBA High", mvStorageDevRegisters.lbaHighRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","Device", mvStorageDevRegisters.deviceRegister);
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR,"%20s : %04x\n","Status", mvStorageDevRegisters.statusRegister);
+        /* Software reset PM */
+        mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                       MV_SATA_PM_CONTROL_PORT, NULL);
+        /*if sw reset of the drive didn't finished, estabisl sama comm  */
+        /*again and don't clear s-error so D2H Fis will be blocked      */
+        mvPMDevEnableStaggeredSpinUp(pSataAdapter,channelIndex , PMPort);
+        return MV_FALSE;
+    }
+
+    if (mvStorageDevRegisters.errorRegister != 1)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: Device Diagnostics "
+                 "failed\n", pSataAdapter->adapterId, channelIndex, PMPort);
+        return MV_FALSE;
+    }
+
+
+    deviceType = mvGetSataDeviceType(&mvStorageDevRegisters);
+    if (deviceType != MV_SATA_DEVICE_TYPE_ATA_DISK)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: Bad Device"
+                 " Type (%d) failed\n", pSataAdapter->adapterId, channelIndex,
+                 PMPort, deviceType);
+        return MV_FALSE;
+    }
+#endif
+    if (mvConfigSataDisk(pSataAdapter, channelIndex, PMPort, pIdentifyInfo,
+                         identifyBuffer) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: Failed to"
+                 " Config Device\n", pSataAdapter->adapterId, channelIndex,
+                 PMPort);
+        if (mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex, PMPort,
+                                           NULL)== MV_FALSE)
+        {
+            mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: "
+                     "Software reset failed\n", pSataAdapter->adapterId,
+                     channelIndex, PMPort);
+            /* Software reset PM */
+            mvStorageDevATASoftResetDevice(pSataAdapter, channelIndex,
+                                           MV_SATA_PM_CONTROL_PORT, NULL);
+
+        }
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+MV_BOOLEAN  mvGetPMDeviceInfo(MV_SATA_ADAPTER   *pSataAdapter,
+                              MV_U8 channelIndex,
+                              MV_SATA_PM_DEVICE_INFO *pPMDeviceInfo)
+{
+    MV_U32  regVal;
+
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_ID_REG_NUM, &regVal, NULL) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+                 "mvGetPMDeviceInfo Failed", pSataAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+    pPMDeviceInfo->vendorId = (MV_U16)(regVal & 0xffff);
+    pPMDeviceInfo->deviceId = (MV_U16)((regVal & 0xffff0000) >> 16);
+
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_REVISION_REG_NUM, &regVal, NULL)== MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+                 "mvGetPMDeviceInfo Failed", pSataAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+
+    pPMDeviceInfo->PMSpecRevision = (MV_U8)(regVal & 0xff);
+    pPMDeviceInfo->productRevision = (MV_U8)((regVal & 0xff00) >> 8);
+
+    if (mvPMDevReadReg(pSataAdapter, channelIndex, MV_SATA_PM_CONTROL_PORT,
+                       MV_SATA_GSCR_INFO_REG_NUM, &regVal, NULL)== MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: "
+                 "mvGetPMDeviceInfo Failed", pSataAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+    pPMDeviceInfo->numberOfPorts = (MV_U8)(regVal & 0xf);
+
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "[%d %d]: PM Information:\n",
+             pSataAdapter->adapterId,channelIndex);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %04x\n", "Vendor Id", pPMDeviceInfo->vendorId);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %04x\n", "Device Id", pPMDeviceInfo->deviceId);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %02x\n", "Product Revision", pPMDeviceInfo->productRevision);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %02x\n", "Spec Revision", pPMDeviceInfo->PMSpecRevision);
+    mvLogMsg(MV_IAL_COMMON_LOG_ID, MV_DEBUG, "%25s - %02x\n", "Fan-out ports", pPMDeviceInfo->numberOfPorts);
+    return MV_TRUE;
+}
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALCommonUtils.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALCommonUtils.h
@@ -0,0 +1,117 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvIALCommonUtils.h
+*
+* DESCRIPTION:
+*       H implementation for IAL's extension utility functions.
+*
+* DEPENDENCIES:
+*   mvSata.h
+*   mvStorageDev.h
+*
+*******************************************************************************/
+#ifndef __INCmvIALCommonUtilsh
+#define __INCmvIALCommonUtilsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "mvSata.h"
+#include "mvStorageDev.h"
+
+/* defines */
+#define MV_IAL_COMMON_LOG_ID            2
+
+/* typedefs */
+    typedef struct serialATACapabilites
+    {
+        MV_BOOLEAN  SATA_GEN_I_supported:1;
+        MV_BOOLEAN  SATA_GEN_II_supported:1;
+        MV_BOOLEAN  NCQSupported:1;/*native command queuing*/
+        MV_BOOLEAN  RxHostInitiatedPMSupported:1;/* Supports receipt of host-initiated
+                                                  interface power management
+                                                  requests*/
+        MV_BOOLEAN  TxDeviceInitiatedPMSupported:1;/* device supports initiating
+                                                    interface power management*/
+        MV_BOOLEAN  TxDeviceInitiatedPMEnabled:1;
+        MV_BOOLEAN  DMASetupAutoActiveSupported:1;/* supports DMA Setup Auto-Activate
+                                                   optimization*/
+        MV_BOOLEAN  DMASetupAutoActiveEnables:1;
+        MV_BOOLEAN  NonZeroBufferOffsetSupported:1;/* supports non-zero buffer offsets
+                                                    in DMA Setup FIS*/
+        MV_BOOLEAN  NonZeroBufferOffsetEnabled:1;
+    }SERIAL_ATA_CAPABILITIES;
+
+    typedef struct ATAIdentifyInfo
+    {
+        MV_U8           version;
+        MV_U8           model[24];
+        MV_U8           firmware[4];
+        MV_U8           UdmaMode;
+        MV_U8           PIOMode;
+        MV_BOOLEAN      LBA48Supported:1;/* used for READ/WRITE commands*/
+        MV_BOOLEAN      writeCacheSupported:1;
+        MV_BOOLEAN      writeCacheEnabled:1;
+        MV_BOOLEAN      readAheadSupported:1;
+        MV_BOOLEAN      readAheadEnabled:1;
+        MV_BOOLEAN      DMAQueuedModeSupported:1;
+        MV_U8           DMAQueuedModeDepth;
+        MV_U32          ATADiskSize;
+        SERIAL_ATA_CAPABILITIES SATACapabilities;/*valid only for ATA-7 or higher*/
+    } ATA_IDENTIFY_INFO;
+
+
+    typedef struct mvSataPMDeviceInfo
+    {
+        MV_U16      vendorId;
+        MV_U16      deviceId;
+        MV_U8       productRevision;
+        MV_U8       PMSpecRevision:4;
+        MV_U8       numberOfPorts:4;
+    } MV_SATA_PM_DEVICE_INFO;
+
+
+    MV_BOOLEAN mvParseIdentifyResult(MV_U16_PTR  iden,ATA_IDENTIFY_INFO *pIdentifyInfo);
+
+    MV_SATA_DEVICE_TYPE mvGetSataDeviceType(MV_STORAGE_DEVICE_REGISTERS *mvStorageDevRegisters);
+
+    MV_BOOLEAN mvInitSataDisk(MV_SATA_ADAPTER   *pSataAdapter, MV_U8 channelIndex,
+                              MV_U8 PMPort, ATA_IDENTIFY_INFO   *pIdentifyInfo,
+                              MV_U16_PTR identifyBuffer
+                             );
+
+    MV_BOOLEAN  mvGetPMDeviceInfo(MV_SATA_ADAPTER   *pSataAdapter,
+                                  MV_U8 channelIndex,
+                                  MV_SATA_PM_DEVICE_INFO *pPMDeviceInfo);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvIALCommonh */
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALTWSI.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALTWSI.c
@@ -0,0 +1,414 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+
+/*includes*/
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvIALTWSI.h"
+
+MV_BOOLEAN waitForInterrupt (MV_SATA_ADAPTER *pAdapter)
+{
+    /* Timeout after 1 second */
+    MV_U32 timeout = 10000;
+    while ((!(MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET) & MV_BIT24)) &&
+           timeout)
+    {
+        mvMicroSecondsDelay (pAdapter, 100);
+        timeout --;
+    }
+    if (timeout == 0)
+    {
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+MV_BOOLEAN waitForStopBit (MV_SATA_ADAPTER *pAdapter)
+{
+    /* Timeout after 1 second */
+    MV_U32 timeout = 10000;
+    while ((MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, TWSI_CONTROL) & MV_BIT4) &&
+           timeout)
+    {
+        mvMicroSecondsDelay (pAdapter, 100);
+        timeout --;
+    }
+    if (timeout == 0)
+    {
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+
+/*******************************************************************************
+* mvSataTWSIMasterInit - Initializes the TWSI mechanism integrated in the MV.
+*
+* DESCRIPTION:
+*       This function initialize the TWSI mechanism and must be called before
+*       any attemp to use the TWSI bus ( use this function on both master or
+*       slave mode to initialize the TWSI mechanism).The function calculates the
+*       parameters needed for the TWSI's freuency registers, resets the TWSI and
+*       then enables it.
+*
+* INPUT:
+*       i2cFreq - the desired frequency , values defind in mvSataTWSI.h and can be
+*                 either _100KHZ or _400KHZ.
+*       tclk    - The system's Tclock.
+*
+* OUTPUT:
+*       TWSI mechanism is enabled.
+*       mvSataTWSITclock is set to tclk value.
+*
+* RETURN:
+*       the actual frequancy calculated and assigned to the TWSI baude - rate
+*       register (for more details please see the TWSI section in the MV
+*       datasheet).
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataTWSIMasterInit(MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32    actualN = 0,actualM = 0, val;
+
+    if (pAdapter == NULL)
+    {
+        return MV_FALSE;
+    }
+
+    /* Not a 60X1 adapter ? */
+    if (pAdapter->sataAdapterGeneration != MV_SATA_GEN_II)
+    {
+        return MV_FALSE;
+    }
+
+    /* Disable the TWSI and slave */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,0);
+    /* Dummy read */
+    MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET);
+    /* Reset the TWSI logic */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_SOFT_RESET,0);
+
+    /* Dummy read */
+    MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET);
+    /* Clear control register */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,0);
+
+    /* Set the baud-rate */
+    val = 0;
+    actualM = 4;
+    actualN = 4;
+    val |= ((actualM<<3) | actualN);
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE,val);
+    /* Remove me - Why TWSI_ENABLE below ??!! --> this is only for slave */
+    val = (TWSI_ENABLE | TWSI_ACK | TWSI_INT_ENABLE);
+    /* Enable the TWSI and slave */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,val);
+    return MV_TRUE;
+}
+
+MV_BOOLEAN twsiSend8bit (MV_SATA_ADAPTER *pAdapter, MV_U8 data, MV_U32 statusToCheck)
+{
+    MV_U32 regVal;
+    /* Now Write the data (8-bit)*/
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_DATA,data);
+    regVal = (TWSI_ENABLE | TWSI_ACK | TWSI_INT_ENABLE);
+    /* Clear the interrupt */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,regVal);
+    /* Poll for interrupt */
+    if (waitForInterrupt(pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - twsiSend8bit line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* We have got interrupt */
+    PRINT_DBG("Interrupt for ack received - status = %lx\n",
+              MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE));
+    /* Check that status is */
+    if (MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE) != statusToCheck)
+    {
+        PRINT_DBG("Error - twsiSend8bit line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+MV_BOOLEAN mvSataSendStartBit (MV_SATA_ADAPTER *pAdapter,
+                               MV_BOOLEAN repeated)
+{
+    MV_U32 regVal;
+    MV_U32 exitStatus;
+    regVal = (TWSI_ENABLE | TWSI_ACK | TWSI_INT_ENABLE | TWSI_START_BIT);
+
+    /* Enable the TWSI and slave and ack and send start bit*/
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,regVal);
+
+    /* Poll for interrupt */
+    if (waitForInterrupt(pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataSendStartBit line %d\n",__LINE__);
+    }
+
+    /* OK - Start bit is out, now lets send the EEPROM Address */
+    PRINT_DBG("Interrupt for ack received - status = %lx\n",
+              MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE));
+
+    exitStatus = (repeated == MV_TRUE) ? 0x10 : 0x8;
+
+    /* Check that status is equals exit status (0x10 for repeated start bit) */
+    if (MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE) != exitStatus)
+    {
+        PRINT_DBG("Error - mvSataSendStartBit line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+MV_BOOLEAN mvSataSendEEPromAddr (MV_SATA_ADAPTER *pAdapter,
+                                 MV_U8 deviceAddress,
+                                 MV_BOOLEAN readOperation,
+                                 MV_U32 exitStatus)
+{
+    MV_U32 regVal;
+    /* Now Write the address (7-bit)*/
+    if (readOperation == MV_TRUE)
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_DATA,(deviceAddress << 1) | MV_BIT0);
+    }
+    else
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_DATA,deviceAddress << 1);
+    }
+
+    regVal = (TWSI_ENABLE | TWSI_ACK | TWSI_INT_ENABLE);
+    /* Clear the interrupt */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,regVal);
+
+    /* Poll for interrupt */
+    if (waitForInterrupt(pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataSendEEPromAddr line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* OK - EEProm address is out, now lets send the EEPROM internal Address */
+    PRINT_DBG("Interrupt for ack received - status = %lx\n",MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE));
+    /* Check that status is 0x18 */
+    if (MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE) != exitStatus)
+    {
+        PRINT_DBG("Error - mvSataSendEEPromAddr line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+MV_BOOLEAN mvSataSendStartBitAllAddresses (MV_SATA_ADAPTER *pAdapter,
+                                           MV_U32 deviceAddress,
+                                           MV_U32 address,
+                                           MV_BOOLEAN addrRange)
+{
+    if (mvSataSendStartBit (pAdapter,MV_FALSE) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataSendStartBitAllAddresses line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    if (mvSataSendEEPromAddr (pAdapter,(MV_U8)deviceAddress, MV_FALSE, 0x18) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataSendStartBitAllAddresses line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    if (addrRange == MV_TRUE)
+    {
+        if (twsiSend8bit (pAdapter, (address >> 8) & 0xff, 0x28) == MV_FALSE)
+        {
+            PRINT_DBG("Error - mvSataSendStartBitAllAddresses line %d\n",__LINE__);
+            return MV_FALSE;
+        }
+    }
+    if (twsiSend8bit (pAdapter, address, 0x28) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataSendStartBitAllAddresses line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataTWSIMasterEEPROMread - Read data from an EEPROM device
+*
+* DESCRIPTION:
+*       This function reads data ( byte size ) from an EEPROM device and return
+*       with the 'TWSI_DATA_STRUCT' structure.The data is valid only if the
+*       structure's field 'errorCode' has the value 'TWSI_NO_ERROR'.
+*
+* INPUT:
+*       deviceAddress - The target EEPROM device address(7 bit only) .
+*       address - The desired offset to be read from ( can be 8 bit or more
+*                 depending on the EEPROM device).
+*       addrRange - TWSI_ADDR_RANGE value ( defined in i2c.h ) to indicate the
+*                   EEPROM address range.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       TWSI_DATA_STRUCT struct containing the read data and the error-code.
+*      NOTE:
+*       Data is valid only if the errorCode is TWSI_NO_ERROR.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataTWSIMasterEEPROMRead(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 deviceAddress,
+                                      MV_U16 address,
+                                      MV_U8_PTR data,
+                                      MV_BOOLEAN addrRange)
+{
+    MV_U32 regVal;
+    if (mvSataSendStartBitAllAddresses(pAdapter,deviceAddress,address,addrRange) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMRead line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* Must wait ~5us before any new transaction - EEPROM restrications */
+    mvMicroSecondsDelay(pAdapter, 5);
+    /* Send again start bit */
+    if (mvSataSendStartBit (pAdapter,MV_TRUE) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMRead line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    /* Send again eeprom address, but with read indication */
+    if (mvSataSendEEPromAddr (pAdapter,deviceAddress, MV_TRUE, 0x40) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMRead line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* Now wait for the data */
+    regVal = (TWSI_ENABLE | TWSI_INT_ENABLE);
+    /* Clear the interrupt and no ack */
+    MV_REG_WRITE_DWORD(pAdapter,TWSI_CONTROL,regVal);
+    /* Poll for interrupt */
+    if (waitForInterrupt(pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMRead line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* OK - EEProm address is out, now lets send the EEPROM internal Address */
+    PRINT_DBG("Interrupt for ack received - status = %lx\n",
+              MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE));
+    /* Check that status is 0x58 */
+    if (MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_STATUS_BAUDE_RATE) != 0x58)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMRead line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    *data = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,TWSI_DATA);
+    /* Send stop bit */
+    regVal = (TWSI_ENABLE | TWSI_INT_ENABLE | TWSI_STOP_BIT);
+    /* Clear the interrupt */
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,TWSI_CONTROL,regVal);
+
+
+    if (waitForStopBit (pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMWrite line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+
+    /* Must wait ~10ms before any new transaction - EEPROM restrications */
+    mvMicroSecondsDelay (pAdapter, 10000);
+    return MV_TRUE;
+
+}
+
+
+
+/*******************************************************************************
+* mvSataTWSIMasterEEPROMwrite - write data to an EEPROM device.
+*
+* DESCRIPTION:
+*       This function writes to an EEPROM device the data ( byte size ) within
+*       the i2cData struct .
+*
+* INPUT:
+*       deviceAddress - The target device address to be written.
+*       *pTWSIData     - struct containing the data to be written.
+*       address       - The desired offset to be written within the EEPROM.
+*       addrRange     - The address range of the target EEPROM ( values defined
+*                       in mvSataTWSI.h).
+*       counterNum    - The counter-timer number (one out of 8 possible values
+*                       defined in mvCntmr.h) needed for the delay between each
+*                       write transaction.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataTWSIMasterEEPROMWrite(MV_SATA_ADAPTER *pAdapter,
+                                       MV_U8 deviceAddress,
+                                       MV_U8 data,
+                                       MV_U16 address,
+                                       MV_BOOLEAN addrRange)
+{
+    MV_U32 regVal;
+
+    if (mvSataSendStartBitAllAddresses(pAdapter,deviceAddress,address,addrRange) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMWrite line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    if (twsiSend8bit (pAdapter, data, 0x28) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMWrite line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+
+    /* Send stop bit */
+    regVal = (TWSI_ENABLE | TWSI_ACK | TWSI_INT_ENABLE | TWSI_STOP_BIT);
+    /* Clear the interrupt */
+    MV_REG_WRITE_DWORD(pAdapter,TWSI_CONTROL,regVal);
+
+
+    if (waitForStopBit (pAdapter) == MV_FALSE)
+    {
+        PRINT_DBG("Error - mvSataTWSIMasterEEPROMWrite line %d\n",__LINE__);
+        return MV_FALSE;
+    }
+    /* Need to wait 10ms before next write (EEPROM restrications)*/
+    mvMicroSecondsDelay (pAdapter, 10000);
+    return MV_TRUE;
+}
+
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvIALTWSI.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvIALTWSI.h
@@ -0,0 +1,133 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+*******************************************************************************/
+
+#ifndef __INCmvIALTWSIh
+#define __INCmvIALTWSIh
+
+/* includes */
+#include "mvRegs.h"
+
+
+#undef DEBUG
+
+#ifdef DEBUG
+    #define PRINT_DBG printf
+#else
+    #define PRINT_DBG
+#endif
+
+
+
+/* defines */
+#define TWSI_TIMEOUT_VALUE               2000000
+#define TWSI_ENABLE                      MV_BIT6
+#define TWSI_INT_ENABLE                  MV_BIT7
+#define TWSI_ACK                         MV_BIT2
+#define TWSI_INT_FLAG                    MV_BIT3
+#define TWSI_STOP_BIT                    MV_BIT4
+#define TWSI_START_BIT                   MV_BIT5
+#define TWSI_READ                        MV_BIT0
+#define TWSI_EEPROM_DELAY                10 /* Mili sec */
+#define TWSI_10BIT_ADDR                  MV_BIT31
+
+/* Error codes */
+#define TWSI_TIME_OUT_ERROR              0xFF
+#define TWSI_NO_DEVICE_WITH_SUCH_ADDR    0x01
+#define TWSI_GENERAL_ERROR               0x02
+#define TWSI_NO_ERROR                    0x03
+#define TWSI_INT_FLAG_STUCK_AT_0         0x04
+
+/* TWSI status codes */
+/*  ShomvRtcuts-
+    RECEIVED    -> REC
+    TRANSMITED  -> TRA
+    MASTER      -> MAS
+    SLAVE       -> SLA
+    ACKNOWLEDGE -> ACK
+    ARBITRATION -> ARB
+    ADDR        -> ADDR
+*/
+
+/****************************************/
+/* TWSI Registers                        */
+/****************************************/
+
+#define TWSI_SLAVE_ADDR                                      0x11000UL
+#define TWSI_EXTENDED_SLAVE_ADDR                             0x11010UL
+#define TWSI_DATA                                            0x11004UL
+#define TWSI_CONTROL                                         0x11008UL
+#define TWSI_STATUS_BAUDE_RATE                               0x1100CUL
+#define TWSI_SOFT_RESET                                      0x1101cUL
+
+
+#define TWSI_BUS_ERROR                                                       0X00
+#define TWSI_START_CONDITION_TRA                                             0X08
+#define TWSI_REPEATED_START_CONDITION_TRA                                    0X10
+#define TWSI_ADDR_PLUS_WRITE_BIT_TRA_ACK_REC                                 0X18
+#define TWSI_ADDR_PLUS_WRITE_BIT_TRA_ACK_NOT_REC                             0X20
+#define TWSI_MAS_TRAN_DATA_BYTE_ACK_REC                                      0X28
+#define TWSI_MAS_TRAN_DATA_BYTE_ACK_NOT_REC                                  0X30
+#define TWSI_MAS_LOST_ARB_DURING_ADDR_OR_DATA_TRA                            0X38
+#define TWSI_ADDR_PLUS_READ_BIT_TRA_ACK_REC                                  0X40
+#define TWSI_ADDR_PLUS_READ_BIT_TRA_ACK_NOT_REC                              0X48
+#define TWSI_MAS_REC_READ_DATA_ACK_TRA                                       0X50
+#define TWSI_MAS_REC_READ_DATA_ACK_NOT_TRA                                   0X58
+#define TWSI_SLA_REC_ADDR_PLUS_WRITE_BIT_ACK_TRA                             0X60
+#define TWSI_MAS_LOST_ARB_DURING_ADDR_TRA_ADDR_IS_TARGETED_TO_SLA_ACK_TRA_W  0X68
+#define TWSI_GENERAL_CALL_REC_ACK_TRA                                        0X70
+#define TWSI_MAS_LOST_ARB_DURING_ADDR_TRA_GENERAL_CALL_ADDR_REC_ACK_TRA      0X78
+#define TWSI_SLA_REC_WRITE_DATA_AFTER_REC_SLA_ADDR_ACK_TRAN                  0X80
+#define TWSI_SLA_REC_WRITE_DATA_AFTER_REC_SLA_ADDR_ACK_NOT_TRAN              0X88
+#define TWSI_SLA_REC_WRITE_DATA_AFTER_REC_GENERAL_CALL_ACK_TRAN              0X90
+#define TWSI_SLA_REC_WRITE_DATA_AFTER_REC_GENERAL_CALL_ACK_NOT_TRAN          0X98
+#define TWSI_SLA_REC_STOP_OR_REPEATED_START_CONDITION                        0XA0
+#define TWSI_SLA_REC_ADDR_PLUS_READ_BIT_ACK_TRA                              0XA8
+#define TWSI_MAS_LOST_ARB_DURING_ADDR_TRA_ADDR_IS_TARGETED_TO_SLA_ACK_TRA_R  0XB0
+#define TWSI_SLA_TRA_READ_DATA_ACK_REC                                       0XB8
+#define TWSI_SLA_TRA_READ_DATA_ACK_NOT_REC                                   0XC0
+#define TWSI_SLA_TRA_LAST_READ_DATA_ACK_REC                                  0XC8
+#define TWSI_SECOND_ADDR_PLUS_WRITE_BIT_TRA_ACK_REC                          0XD0
+#define TWSI_SECOND_ADDR_PLUS_WRITE_BIT_TRA_ACK_NOT_REC                      0XD8
+#define TWSI_SECOND_ADDR_PLUS_READ_BIT_TRA_ACK_REC                           0XE0
+#define TWSI_SECOND_ADDR_PLUS_READ_BIT_TRA_ACK_NOT_REC                       0XE8
+#define TWSI_NO_RELEVANT_STATUS_INTERRUPT_FLAG_IS_KEPT_0                     0XF8
+
+/* typedefs */
+
+MV_BOOLEAN mvSataTWSIMasterInit(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataTWSIMasterEEPROMRead(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 deviceAddress,
+                                      MV_U16 address,
+                                      MV_U8_PTR data,
+                                      MV_BOOLEAN addrRange);
+
+MV_BOOLEAN mvSataTWSIMasterEEPROMWrite(MV_SATA_ADAPTER *pAdapter,
+                                       MV_U8    deviceAddress,
+                                       MV_U8     data,
+                                       MV_U16    address,
+                                       MV_BOOLEAN  addrRange);
+
+#endif /* __INCmvIALTWSIh */
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalHt.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalHt.c
@@ -0,0 +1,1452 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxIalHt.c
+*
+* DESCRIPTION:  implementation for Linux IAL.
+*
+* DEPENDENCIES:
+*   mvLinuxIalHt.h
+*   mvLinuxIalLib.h
+*   Linux Os header files
+*   Core driver header files
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+
+/* includes */
+
+#ifndef LINUX_VERSION_CODE
+    #include <linux/version.h>
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+    #error "This driver works only with kernel 2.4.0 or higher!"
+#endif
+
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)))
+    #error "This driver does not support kernel 2.5!"
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/kdev_t.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/blk.h>
+#include "scsi.h"
+#include "hosts.h"
+#else
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#endif
+
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <asm/dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "mvLinuxIalHt.h"
+#include "mvRegs.h"
+#include "mvIALCommon.h"
+#include "mvLinuxIalSmart.h"
+
+extern struct scsi_host_template driver_template;
+
+static void mv_ial_init_log(void);
+
+static char mv_ial_proc_version[]="Version_1_0";
+extern void release_ata_mem(struct mv_comp_info * pInfo);
+extern MV_BOOLEAN IALCompletion(struct mvSataAdapter *pSataAdapter,
+                                MV_SATA_SCSI_CMD_BLOCK *pCmdBlock);
+
+static struct pci_device_id mvSata_pci_table[] =
+{
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_5080, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_5081, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_5040, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_5041, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_6081, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {MV_SATA_VENDOR_ID, MV_SATA_DEVICE_ID_6041, PCI_ANY_ID, PCI_ANY_ID, 0, 0},
+    {0,}
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+#ifndef __devexit_p
+#define __devexit_p(x)  x
+#endif
+static void mv_ial_ht_select_queue_depths (struct Scsi_Host* pHost,
+                                           struct scsi_device* pDevs);
+
+
+static inline struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *t, size_t s)
+{
+    return scsi_register(t, s);
+}
+static inline void scsi_host_put(struct Scsi_Host *h)
+{
+    scsi_unregister(h);
+}
+
+#define scsi_scan_host(x...)
+#define scsi_remove_host(x...)
+
+#else
+
+static int mv_ial_ht_slave_configure (struct scsi_device* pDevs);
+static int __devinit  mv_ial_probe_device(struct pci_dev *pci_dev, const struct pci_device_id *ent);
+static void __devexit mv_ial_remove_device(struct pci_dev *pci_dev);
+
+
+MODULE_DEVICE_TABLE(pci, mvSata_pci_table);
+
+static char mv_hot_plug_name[] = "mvSata";
+
+static struct pci_driver mv_ial_pci_driver =
+{
+    .name       = mv_hot_plug_name,
+    .id_table   = mvSata_pci_table,
+    .probe      = mv_ial_probe_device,
+    .remove     = __devexit_p(mv_ial_remove_device),
+};
+
+
+
+
+static int __init mv_ial_init(void)
+{
+    mv_ial_init_log();
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "mvSata init.\n");
+    driver_template.module = THIS_MODULE;
+    return (int)pci_module_init(&mv_ial_pci_driver);
+}
+
+static void __exit mv_ial_exit(void)
+{
+    pci_unregister_driver(&mv_ial_pci_driver);
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "mvSata exit.\n");
+}
+
+module_init(mv_ial_init);
+module_exit(mv_ial_exit);
+
+#endif
+
+
+static void mv_ial_init_log(void)
+{
+#ifdef MV_LOGGER
+    char *szModules[] = {"Core Driver",
+        "SAL",
+        "Common IAL",
+        "Linux IAL"
+    };
+#if defined (MV_LOG_DEBUG)
+    mvLogRegisterModule(MV_CORE_DRIVER_LOG_ID, 0x1FF,
+                        szModules[MV_CORE_DRIVER_LOG_ID]);
+    mvLogRegisterModule(MV_SAL_LOG_ID, 0x1FF,
+                        szModules[MV_SAL_LOG_ID]);
+    mvLogRegisterModule(MV_IAL_COMMON_LOG_ID, 0x1FF,
+                        szModules[MV_IAL_COMMON_LOG_ID]);
+    mvLogRegisterModule(MV_IAL_LOG_ID, 0x1FF,
+                        szModules[MV_IAL_LOG_ID]);
+#elif defined (MV_LOG_ERROR)
+    mvLogRegisterModule(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_ERROR,
+                        szModules[MV_CORE_DRIVER_LOG_ID]);
+    mvLogRegisterModule(MV_SAL_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_ERROR,
+                        szModules[MV_SAL_LOG_ID]);
+    mvLogRegisterModule(MV_IAL_COMMON_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_ERROR,
+                        szModules[MV_IAL_COMMON_LOG_ID]);
+    mvLogRegisterModule(MV_IAL_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_ERROR,
+                        szModules[MV_IAL_LOG_ID]);
+#endif
+#endif
+}
+
+/****************************************************************
+ *  Name: set_device_regs
+ *
+ *  Description:    initialize the device registers.
+ *
+ *  Parameters:     pMvSataAdapter, pointer to the Device data structure.
+ *          pcidev, pointer to the pci device data structure.
+ *
+ *  Returns:        =0 ->success, < 0 ->failure.
+ *
+ ****************************************************************/
+static int set_device_regs(MV_SATA_ADAPTER *pMvSataAdapter,
+                           struct pci_dev   *pcidev)
+{
+    pMvSataAdapter->intCoalThre[0]= MV_IAL_HT_SACOALT_DEFAULT;
+    pMvSataAdapter->intCoalThre[1]= MV_IAL_HT_SACOALT_DEFAULT;
+    pMvSataAdapter->intTimeThre[0] = MV_IAL_HT_SAITMTH_DEFAULT;
+    pMvSataAdapter->intTimeThre[1] = MV_IAL_HT_SAITMTH_DEFAULT;
+    pMvSataAdapter->pciCommand = MV_PCI_COMMAND_REG_DEFAULT;
+    pMvSataAdapter->pciSerrMask = MV_PCI_SERR_MASK_REG_ENABLE_ALL;
+    pMvSataAdapter->pciInterruptMask = MV_PCI_INTERRUPT_MASK_REG_ENABLE_ALL;
+    pMvSataAdapter->mvSataEventNotify = mv_ial_lib_event_notify;
+
+    return 0;
+}
+
+
+static int mv_ial_get_num_of_ports(const struct pci_device_id *id)
+{
+    switch(id->device)
+    {
+        case MV_SATA_DEVICE_ID_5080:
+        case MV_SATA_DEVICE_ID_5081:
+        case MV_SATA_DEVICE_ID_6081:
+            return 8;
+        case MV_SATA_DEVICE_ID_5040:
+        case MV_SATA_DEVICE_ID_5041:
+        case MV_SATA_DEVICE_ID_6041:
+            return 4;
+        default:
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                     "getMaxNumberOfPorts() Unknown device ID.\n");
+            return 0;
+    }
+}
+
+static void mv_ial_free_scsi_hosts(IAL_ADAPTER_T *pAdapter, MV_BOOLEAN freeAdapter)
+{
+    int i;
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        if (pAdapter->host[i] != NULL)
+        {
+            mv_ial_lib_prd_destroy(pAdapter->host[i]);
+            scsi_host_put(pAdapter->host[i]->scsihost);
+            pAdapter->host[i] = NULL;
+        }
+    }
+    pAdapter->activeHosts = 0;
+    if (MV_TRUE == freeAdapter)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG,
+                     "[%d] freeing Adapter data structure.\n", pAdapter->mvSataAdapter.adapterId);
+        kfree(pAdapter);
+    }
+}
+
+
+
+
+static int __devinit  mv_ial_probe_device(struct pci_dev *pcidev,
+                                          const struct pci_device_id *id)
+{
+
+    MV_SATA_ADAPTER     *pMvSataAdapter;
+    IAL_ADAPTER_T       *pAdapter;
+    MV_U8                 i;
+    static int          adapterId = 0;
+
+    pci_set_drvdata(pcidev, NULL);
+
+    if (pci_enable_device(pcidev))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,
+                 "pci_enable_device() failed\n");
+        return -ENODEV;
+    }
+
+    pci_set_master(pcidev);
+    if (0 == pci_set_dma_mask(pcidev, 0xfffffffffffffffULL))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG,"using 64-bit DMA.\n");
+    }
+    else if (0 == pci_set_dma_mask(pcidev, 0xffffffffUL))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "using 32-bit DMA.\n");
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "DMA 32-bit not supported"
+                 " in the system\n");
+        pci_disable_device(pcidev);
+        return -ENODEV;
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (pci_request_regions(pcidev, mv_hot_plug_name) != 0)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "pci_request_regions() failed\n");
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+#endif
+
+
+    pAdapter = (IAL_ADAPTER_T*)kmalloc(sizeof(IAL_ADAPTER_T), GFP_ATOMIC);
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "IAL Adapter allocation failed\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    memset(pAdapter, 0, sizeof(IAL_ADAPTER_T));
+    pAdapter->activeHosts = 0;
+    pAdapter->maxHosts = mv_ial_get_num_of_ports(id);
+    if (pAdapter->maxHosts == 0)
+    {
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "mv_ial_get_num_of_ports() failed\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        struct Scsi_Host    *pshost = scsi_host_alloc(&driver_template, sizeof(IAL_HOST_T));
+        if (pshost == NULL)
+        {
+            mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Scsi_Host allocation failed\n");
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+            pci_release_regions(pcidev);
+ #endif
+            pci_disable_device(pcidev);
+            return -ENOMEM;
+        }
+        pAdapter->host[i] = HOSTDATA(pshost);
+        memset(pAdapter->host[i], 0, sizeof(IAL_HOST_T));
+        pAdapter->host[i]->scsihost = pshost;
+        pAdapter->host[i]->pAdapter = pAdapter;
+        pAdapter->host[i]->channelIndex = (MV_U8)i;
+        pAdapter->activeHosts |= (1 << i);
+    }
+    pAdapter->pcidev = pcidev;
+    pMvSataAdapter = &(pAdapter->mvSataAdapter);
+    pMvSataAdapter->IALData = pAdapter;
+    spin_lock_init (&pAdapter->adapter_lock);
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        pAdapter->host[i]->scsi_cmnd_done_head = NULL;
+        pAdapter->host[i]->scsi_cmnd_done_tail = NULL;
+    }
+    if (mv_ial_lib_allocate_edma_queues(pAdapter))
+    {
+        mvLogMsg(MV_IAL_LOG_ID,MV_DEBUG_ERROR, "Failed to allocate memory for EDMA queues\n");
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    pAdapter->host[0]->scsihost->base = pci_resource_start(pcidev, 0);
+    for (i = 1; i < pAdapter->maxHosts; i++)
+    {
+        if (pAdapter->host[i] != NULL)
+            pAdapter->host[i]->scsihost->base = pAdapter->host[0]->scsihost->base;
+    }
+    pMvSataAdapter->adapterIoBaseAddress =
+        (MV_BUS_ADDR_T)ioremap(pAdapter->host[0]->scsihost->base,
+                               pci_resource_len(pcidev, 0));
+    if (!pMvSataAdapter->adapterIoBaseAddress)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Failed to remap memory io spcae\n");
+        mv_ial_lib_free_edma_queues(pAdapter);
+
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "io base address 0x%08lx\n",
+                 (ulong)pMvSataAdapter->adapterIoBaseAddress);
+    }
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        if ((pAdapter->activeHosts & (1 << i)) == 0)
+        {
+            continue;
+        }
+        if (mv_ial_lib_prd_init(pAdapter->host[i]))
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,   "Failed to init PRD memory manager - host %d\n", i);
+            iounmap(pMvSataAdapter->adapterIoBaseAddress);
+            mv_ial_lib_free_edma_queues(pAdapter);
+            mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+            pci_release_regions(pcidev);
+#endif
+            pci_disable_device(pcidev);
+            return -ENOMEM;
+        }
+    }
+    pMvSataAdapter->adapterId = adapterId++;
+    /* get the revision ID */
+    if (pci_read_config_byte(pcidev, PCI_REVISION_ID, &pAdapter->rev_id))
+    {
+        printk(KERN_WARNING "mvSata: Failed to get revision id.\n");
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    pMvSataAdapter->pciConfigRevisionId = pAdapter->rev_id;
+    pMvSataAdapter->pciConfigDeviceId = id->device;
+    if (set_device_regs(pMvSataAdapter, pcidev))
+    {
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    /*Do not allow hotplug handler to work*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    init_MUTEX(&pAdapter->rescan_mutex);
+    atomic_set(&pAdapter->stopped, 1);
+#endif
+
+    if (mvSataInitAdapter(pMvSataAdapter) == MV_FALSE)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: core failed to initialize the adapter\n",
+                 pMvSataAdapter->adapterId);
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    pAdapter->ataScsiAdapterExt = (MV_SAL_ADAPTER_EXTENSION*)kmalloc(sizeof(MV_SAL_ADAPTER_EXTENSION),
+                                                                     GFP_ATOMIC);
+    if (pAdapter->ataScsiAdapterExt == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,"[%d]: out of memory, failed to allocate MV_SAL_ADAPTER_EXTENSION\n",
+                 pAdapter->mvSataAdapter.adapterId);
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    mvSataScsiInitAdapterExt(pAdapter->ataScsiAdapterExt,
+                             pMvSataAdapter);
+    /* let SAL report only the BUS RESET UA event*/
+    pAdapter->ataScsiAdapterExt->UAMask = MV_BIT0;
+    /* enable device interrupts even if no storage devices connected now*/
+    if (request_irq(pcidev->irq, mv_ial_lib_int_handler,
+                    (SA_INTERRUPT | SA_SAMPLE_RANDOM | SA_SHIRQ), "mvSata",
+                    pAdapter) < 0)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: unable to allocate IRQ for controler\n",
+                 pMvSataAdapter->adapterId);
+        kfree(pAdapter->ataScsiAdapterExt);
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        if ((pAdapter->activeHosts & (1 << i)) == 0)
+        {
+            continue;
+        }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        scsi_set_device(pAdapter->host[i]->scsihost, &pcidev->dev);
+#else
+        scsi_set_pci_device(pAdapter->host[i]->scsihost, pcidev);
+#endif
+        pAdapter->host[i]->scsihost->irq = pcidev->irq;
+        /* each SATA channel will emulate scsi host !!!*/
+        if (pMvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            pAdapter->host[i]->scsihost->max_id = 1;
+        }
+        else
+        {
+            pAdapter->host[i]->scsihost->max_id = MV_SATA_PM_MAX_PORTS;
+        }
+        pAdapter->host[i]->scsihost->max_lun = 1;
+        pAdapter->host[i]->scsihost->max_channel = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        pAdapter->host[i]->scsihost->select_queue_depths = mv_ial_ht_select_queue_depths;
+#endif
+    }
+    if (MV_FALSE == mvAdapterStartInitialization(pMvSataAdapter,
+                                                 &pAdapter->ialCommonExt,
+                                                 pAdapter->ataScsiAdapterExt))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: mvAdapterStartInitialization"
+                 " Failed\n", pMvSataAdapter->adapterId);
+        free_irq (pcidev->irq, pMvSataAdapter);
+        kfree(pAdapter->ataScsiAdapterExt);
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pci_release_regions(pcidev);
+#endif
+        pci_disable_device(pcidev);
+        return -ENOMEM;
+    }
+    pci_set_drvdata(pcidev, pAdapter);
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        if ((pAdapter->activeHosts & (1 << i)) == 0)
+        {
+            continue;
+        }
+        mv_ial_block_requests(pAdapter, i);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        if (scsi_add_host(pAdapter->host[i]->scsihost, &pcidev->dev) != 0)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: scsi_add_host() failed.\n"
+                     , pMvSataAdapter->adapterId);
+            free_irq (pcidev->irq, pMvSataAdapter);
+            kfree(pAdapter->ataScsiAdapterExt);
+            iounmap(pMvSataAdapter->adapterIoBaseAddress);
+            mv_ial_lib_free_edma_queues(pAdapter);
+            mv_ial_free_scsi_hosts(pAdapter, MV_TRUE);
+            pci_release_regions(pcidev);
+            pci_disable_device(pcidev);
+            return -ENODEV;
+        }
+#endif
+    }
+
+    pAdapter->stopAsyncTimer = MV_FALSE;
+    init_timer(&pAdapter->asyncStartTimer);
+    pAdapter->asyncStartTimer.data = (unsigned long)pAdapter;
+    pAdapter->asyncStartTimer.function = asyncStartTimerFunction;
+    pAdapter->asyncStartTimer.expires = jiffies + MV_LINUX_ASYNC_TIMER_PERIOD;
+    add_timer (&pAdapter->asyncStartTimer);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        if ((pAdapter->activeHosts & (1 << i)) != 0)
+        {
+            scsi_scan_host(pAdapter->host[i]->scsihost);
+        }
+    }
+    /*Enable hotplug handler*/
+    atomic_set(&pAdapter->stopped, 0);
+#endif
+    return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/****************************************************************
+ *  Name: mv_ial_ht_detect
+ *
+ *  Description:    Detect and initialize our boards.
+ *
+ *  Parameters:     tpnt - Pointer to SCSI host template structure.
+ *
+ *  Returns:        Number of adapters installed.
+ *
+ ****************************************************************/
+int mv_ial_ht_detect (struct scsi_host_template *tpnt)
+{
+    int                 num_hosts=0;
+    struct pci_dev      *pcidev = NULL;
+    int                 index;
+    struct pci_device_id *id = &mvSata_pci_table[0];
+
+    mv_ial_init_log();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    if (!pci_present())
+    {
+        printk ("mvSata: PCI BIOS not present\n");
+        return 0;
+    }
+#endif
+
+    if (sizeof(struct mv_comp_info) > sizeof(Scsi_Pointer))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "WARNING mv_comp_info must be "
+                 "re-defined - its too big");
+        return -1;
+    }
+    index = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_unlock_irq (&io_request_lock);
+#endif
+
+    while (1)
+    {
+        if (id[index].device == 0)
+        {
+            break;
+        }
+        pcidev = NULL;
+
+        while ((pcidev = pci_find_device (MV_SATA_VENDOR_ID,
+                                          id[index].device, pcidev)) != NULL)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "PCI device found, DeviceId 0x%x "
+                     "BAR0=%lx\n",
+                      id[index].device, pci_resource_start(pcidev,0));
+            if (mv_ial_probe_device(pcidev, &id[index]) == 0)
+            {
+                IAL_ADAPTER_T *pAdapter = pci_get_drvdata(pcidev);
+                num_hosts += pAdapter->maxHosts;
+            }
+        }
+        index ++;
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_lock_irq (&io_request_lock);
+#endif
+    return num_hosts;
+}
+#endif
+
+/****************************************************************
+ *  Name:   mv_ial_ht_release
+ *
+ *  Description:   release scsi host
+ *
+ *  Parameters:     SCpnt - Pointer to SCSI host structure.
+ *
+ *  Returns:          0 on success, otherwise of failure.
+ *
+ ****************************************************************/
+int mv_ial_ht_release (struct Scsi_Host *pHost)
+{
+    IAL_ADAPTER_T *pAdapter = MV_IAL_ADAPTER (pHost);
+    MV_U8 channel;
+    MV_SATA_ADAPTER * pMvSataAdapter = &pAdapter->mvSataAdapter;
+    unsigned long lock_flags;
+    struct scsi_cmnd *cmnds_done_list = NULL;
+    IAL_HOST_T          *ial_host = HOSTDATA(pHost);
+
+    channel = ial_host->channelIndex;
+    pAdapter->activeHosts &= ~ (1 << channel);
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, ": release host %d\n", pHost->host_no);
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    if (pAdapter->stopAsyncTimer != MV_TRUE)
+    {
+        /* Delete any pending timers */
+        pAdapter->stopAsyncTimer = MV_TRUE;
+        del_timer_sync(&pAdapter->asyncStartTimer);
+    }
+#endif
+
+    if (pMvSataAdapter->sataChannel[channel])
+    {
+        mvSataDisableChannelDma(pMvSataAdapter, channel);
+
+        mvSataFlushDmaQueue(pMvSataAdapter, channel,
+                            MV_FLUSH_TYPE_CALLBACK);
+        mv_ial_lib_free_channel(pAdapter, channel);
+   }
+     /* Check if there are commands in the done queue to be completed */
+
+    cmnds_done_list = mv_ial_lib_get_first_cmnd (pAdapter, channel);
+    if (cmnds_done_list)
+    {
+        unsigned long flags_io_request_lock;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        spin_lock_irqsave(&io_request_lock, flags_io_request_lock);
+#else
+        spin_lock_irqsave(ial_host->scsihost->host_lock, flags_io_request_lock);
+#endif
+        mv_ial_lib_do_done(cmnds_done_list);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        spin_unlock_irqrestore(&io_request_lock, flags_io_request_lock);
+#else
+        spin_unlock_irqrestore(ial_host->scsihost->host_lock, flags_io_request_lock);
+#endif
+    }
+    if (0 == pAdapter->activeHosts)
+    {
+      mvSataShutdownAdapter(pMvSataAdapter);
+    }
+    pAdapter->host[channel] = NULL;
+    mv_ial_lib_prd_destroy(ial_host);
+    spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+    scsi_remove_host(pHost);
+    scsi_host_put(pHost);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    if (0 == pAdapter->activeHosts)
+    {
+        struct pci_dev *dev = pAdapter->pcidev;
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG,
+                     "[%d] freeing Adapter resources.\n", pAdapter->mvSataAdapter.adapterId);
+        free_irq (pAdapter->pcidev->irq, pMvSataAdapter);
+        kfree(pAdapter->ataScsiAdapterExt);
+        iounmap(pMvSataAdapter->adapterIoBaseAddress);
+        mv_ial_lib_free_edma_queues(pAdapter);
+        kfree(pAdapter);
+	pci_disable_device(dev);
+    }
+#endif
+    return 0;
+}
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static void __devexit mv_ial_remove_device(struct pci_dev *pdev)
+{
+    IAL_ADAPTER_T       *pAdapter = pci_get_drvdata(pdev);
+    int numhosts;
+    int i;
+    unsigned long lock_flags;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                     "mv_ial_remove_device() No valid Adapter IAL structure found.\n");
+        return;
+    }
+
+    numhosts           = pAdapter->maxHosts;
+    /*flush hotplug rescan worker*/
+    atomic_inc(&pAdapter->stopped);
+    flush_scheduled_work();
+    /* Delete any pending timers */
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+    pAdapter->stopAsyncTimer = MV_TRUE;
+    del_timer_sync(&pAdapter->asyncStartTimer);
+    spin_unlock_irqrestore(&pAdapter->adapter_lock, lock_flags);
+
+    for (i = 0; i < numhosts; i++)
+    {
+        if (pAdapter->host[i] != NULL)
+        {
+            mv_ial_ht_release (pAdapter->host[i]->scsihost);
+        }
+    }
+
+    free_irq (pAdapter->pcidev->irq, &pAdapter->mvSataAdapter);
+    kfree(pAdapter->ataScsiAdapterExt);
+    iounmap(pAdapter->mvSataAdapter.adapterIoBaseAddress);
+    mv_ial_lib_free_edma_queues(pAdapter);
+    kfree(pAdapter);
+    pci_release_regions(pdev);
+    pci_disable_device(pdev);
+}
+#endif
+
+/****************************************************************
+ *  Name:   mv_ial_ht_queuecommand
+ *
+ *  Description:    Process a queued command from the SCSI manager.
+ *
+ *  Parameters:     SCpnt - Pointer to SCSI command structure.
+ *                  done  - Pointer to done function to call.
+ *
+ *  Returns:        Status code.
+ *
+ ****************************************************************/
+int mv_ial_ht_queuecommand (struct scsi_cmnd * SCpnt, void (*done) (struct scsi_cmnd *))
+{
+    IAL_ADAPTER_T   *pAdapter = MV_IAL_ADAPTER(SCpnt->device->host);
+    MV_SATA_ADAPTER *pMvSataAdapter;
+    IAL_HOST_T      *pHost = HOSTDATA(SCpnt->device->host);
+    MV_U8            channel = pHost->channelIndex;
+
+    unchar *cmd = (unchar *) SCpnt->cmnd;
+    dma_addr_t busaddr = 0;
+    dma_addr_t PRD_dma_address;
+    struct mv_comp_info *completion_info;
+    MV_SATA_EDMA_PRD_ENTRY *pPRD_table;
+    unsigned int prd_size;
+    unsigned long lock_flags;
+
+    struct scsi_cmnd   *cmnds_done_list = NULL;
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, " :queuecommand host=%d, bus=%d, channel=%d\n",
+             SCpnt->device->host->host_no,
+             SCpnt->device->channel,
+             channel);
+    if (done == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, ": in queuecommand, done function can't be NULL\n");
+        return 0;
+    }
+
+    if ((pAdapter == NULL) || (channel >= MV_SATA_CHANNELS_NUM)||
+        (pAdapter->host[channel] == NULL))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_FATAL_ERROR,": in queuecommand, "
+                 "command queued for released host!!\n");
+        SCpnt->result = DID_NO_CONNECT << 16;
+        done(SCpnt);
+        return 0;
+    }
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_unlock_irq (&io_request_lock);
+#else
+    spin_unlock_irq(pHost->scsihost->host_lock);
+#endif
+
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+
+    if (SCpnt->retries > 0)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,": retry command host=%d, bus=%d"
+                 " SCpnt = %p\n", SCpnt->device->host->host_no, channel, SCpnt);
+    }
+
+    if (MV_TRUE == pAdapter->host[channel]->hostBlocked)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,": command received for "
+                 "blocked host=%d, bus=%d, channel=%d, SCpnt = %p\n",
+                 SCpnt->device->host->host_no,
+                 SCpnt->device->channel,
+                 channel, SCpnt);
+#if 0
+        spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        spin_lock_irq (&io_request_lock);
+#else
+        spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+        return SCSI_MLQUEUE_HOST_BUSY;
+#endif
+    }
+
+    pMvSataAdapter = &pAdapter->mvSataAdapter;
+
+    SCpnt->result = DID_ERROR << 16;
+    SCpnt->scsi_done = done;
+
+    completion_info = ( struct mv_comp_info *) &(SCpnt->SCp);
+    completion_info->pSALBlock =
+    (MV_SATA_SCSI_CMD_BLOCK *) kmalloc(sizeof(MV_SATA_SCSI_CMD_BLOCK),
+                                       GFP_ATOMIC);
+    if (completion_info->pSALBlock == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,  "in queuecommand: Failed to allocate SAL Block\n");
+        spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        spin_lock_irq (&io_request_lock);
+#else
+        spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+        return -1;
+    }
+    /* prepare the SAL Block paramters*/
+    if ((*cmd == READ_6) || (*cmd == READ_10) || (*cmd == WRITE_6) ||
+        (*cmd == WRITE_10))
+    {
+        if (mv_ial_lib_generate_prd(pMvSataAdapter, SCpnt, &pPRD_table, &PRD_dma_address,
+                                    &prd_size, &busaddr))
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "in queuecommand: illegal requested buffer\n");
+            spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+            spin_lock_irq (&io_request_lock);
+#else
+            spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+            return -1;
+        }
+        completion_info->cpu_PRDpnt = pPRD_table;
+        completion_info->dma_PRDpnt = PRD_dma_address;
+        completion_info->allocated_entries = prd_size;
+        completion_info->single_buff_busaddr = busaddr;
+        completion_info->pSALBlock->PRDTableLowPhyAddress = pci64_dma_lo32(PRD_dma_address);
+        completion_info->pSALBlock->PRDTableHighPhyAddress = pci64_dma_hi32(PRD_dma_address);
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "pPRD_table %p PRD_dma_address %p, PRDTableLowPhyAddress %p\n",
+            pPRD_table, PRD_dma_address, completion_info->pSALBlock->PRDTableLowPhyAddress);
+
+    }
+    else
+    {
+        completion_info->cpu_PRDpnt = NULL;
+    }
+    completion_info->SCpnt = SCpnt;
+
+    completion_info->pSALBlock->bus = channel;
+
+    completion_info->pSALBlock->target = SCpnt->device->id;
+    completion_info->pSALBlock->lun = SCpnt->device->lun;
+    completion_info->pSALBlock->pSalAdapterExtension = pAdapter->ataScsiAdapterExt;
+    completion_info->pSALBlock->pIalAdapterExtension = &pAdapter->ialCommonExt;
+    completion_info->pSALBlock->completionCallBack = IALCompletion;
+    completion_info->pSALBlock->dataBufferLength = SCpnt->request_bufflen;
+    completion_info->pSALBlock->IALData = SCpnt;
+    completion_info->pSALBlock->pDataBuffer = SCpnt->request_buffer;
+    completion_info->pSALBlock->pSenseBuffer = SCpnt->sense_buffer;
+    completion_info->pSALBlock->ScsiCdb = SCpnt->cmnd;
+    completion_info->pSALBlock->ScsiCdbLength = SCpnt->cmd_len;
+    completion_info->pSALBlock->senseBufferLength = SCSI_SENSE_BUFFERSIZE;
+    if (*cmd != SCSI_OPCODE_MVSATA_SMART)
+    {
+        mvExecuteScsiCommand(completion_info->pSALBlock, MV_TRUE);
+    }
+    else
+    {
+        mvScsiAtaSendSmartCommand(pMvSataAdapter, completion_info->pSALBlock);
+    }
+
+    /*
+     * Check if there is valid commands to be completed. This is usually
+     * an immediate completed commands such as INQUIRY etc...
+     */
+    cmnds_done_list = mv_ial_lib_get_first_cmnd(pAdapter, channel);
+    spin_unlock_irqrestore(&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_lock_irq (&io_request_lock);
+#else
+    spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+    if (cmnds_done_list)
+    {
+        mv_ial_lib_do_done(cmnds_done_list);
+    }
+    return 0;
+}
+/****************************************************************
+ *  Name:   mv_ial_ht_bus_reset
+ *
+ *  Description:    reset given devise, all pending commands will be aborted
+ *                  with status DID_RESET.
+ *
+ *  Parameters:     SCpnt - Pointer to SCSI command structure.
+ *
+ *  Returns:        Status code.
+ *
+ ****************************************************************/
+int mv_ial_ht_bus_reset (struct scsi_cmnd *SCpnt)
+{
+    IAL_ADAPTER_T   *pAdapter = MV_IAL_ADAPTER(SCpnt->device->host);
+    MV_SATA_ADAPTER *pMvSataAdapter = &pAdapter->mvSataAdapter;
+    IAL_HOST_T      *pHost = HOSTDATA(SCpnt->device->host);
+    MV_U8 channel = pHost->channelIndex;
+
+    unsigned long lock_flags;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_unlock_irq (&io_request_lock);
+#else
+    spin_unlock_irq(pHost->scsihost->host_lock);
+#endif
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Bus Reset: host=%d, channel=%d, target=%d\n",
+             SCpnt->device->host->host_no, SCpnt->device->channel, SCpnt->device->id);
+    if (pMvSataAdapter->sataChannel[channel] == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "trying to reset disabled channel, host=%d, channel=%d\n",
+                 SCpnt->device->host->host_no, channel);
+        spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        spin_lock_irq(&io_request_lock);
+#else
+        spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+        return FAILED;
+    }
+
+    mvSataDisableChannelDma(pMvSataAdapter, channel);
+
+    /* Flush pending commands */
+    mvSataFlushDmaQueue (pMvSataAdapter, channel, MV_FLUSH_TYPE_CALLBACK);
+
+    /* Hardware reset channel */
+    mvSataChannelHardReset(pMvSataAdapter, channel);
+
+    if (pMvSataAdapter->sataChannel[channel])
+    {
+        mvRestartChannel(&pAdapter->ialCommonExt, channel,
+                         pAdapter->ataScsiAdapterExt, MV_TRUE);
+        mv_ial_block_requests(pAdapter, channel);
+    }
+    /* don't call scsi done for the commands on this channel*/
+    mv_ial_lib_get_first_cmnd(pAdapter, channel);
+    spin_unlock_irqrestore(&pAdapter->adapter_lock, lock_flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_lock_irq(&io_request_lock);
+#else
+    spin_lock_irq(pHost->scsihost->host_lock);
+#endif
+    return SUCCESS;
+}
+
+
+
+/****************************************************************
+ *  Name:   mv_ial_ht_proc_info
+ *
+ *  Description:   /proc file
+ *
+ *  Parameters:
+ *
+ *  Returns:
+ *
+ ****************************************************************/
+int mv_ial_ht_proc_info(struct Scsi_Host *pshost,
+                        char *buffer, char **start, off_t offset,
+                        int length, int inout)
+{
+    int len = 0, temp, pmPort;
+    IAL_ADAPTER_T       *pAdapter;
+    MV_SATA_ADAPTER *pMvSataAdapter;
+    IAL_HOST_T       *pHost = HOSTDATA(pshost);
+
+    unsigned long lock_flags;
+
+    pAdapter = MV_IAL_ADAPTER(pshost);
+    pMvSataAdapter = &pAdapter->mvSataAdapter;
+
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+    if (inout == 1)
+    {                     /* Writing to file */
+        /* The format is 'int_coal <sata unit> <coal_threshold> <timeout>' */
+        int i;
+        /* Check signature 'int_coal' at start of buffer */
+        if (!strncmp (buffer, "int_coal", strlen ("int_coal")))
+        {
+            int sata_unit;
+            u32 time_thre, coal_thre;
+            i = sscanf (buffer + strlen ("int_coal"), "%d %d %d\n",
+                        &sata_unit, &coal_thre, &time_thre);
+            if (i == 3)
+            {        /* Three matched inputs */
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d]: Modifying interrupt coalescing of unit %d to %d threshold and %d timer\n",pMvSataAdapter->adapterId, sata_unit, coal_thre, time_thre);
+                mvSataSetIntCoalParams (pMvSataAdapter, sata_unit, coal_thre, time_thre);
+            }
+            else
+            {
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d]: Error in interrupt coalescing parameters\n",
+                         pMvSataAdapter->adapterId);
+            }
+        }
+        /* Check signature 'sata_phy_shutdown' at start of buffer */
+        else if (!strncmp (buffer, "sata_phy_shutdown", strlen ("sata_phy_shutdown")))
+        {
+            int sata_phy;
+            i = sscanf (buffer + strlen ("sata_phy_shutdown"), "%d\n", &sata_phy);
+            if (i == 1)
+            {        /* Three matched inputs */
+
+                if (mvSataIsStorageDeviceConnected (pMvSataAdapter, sata_phy) == MV_TRUE)
+                {
+                    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: Warning - shutting down a phy that is connected to a storage device\n", pMvSataAdapter->adapterId, sata_phy);
+                }
+                if (mvSataChannelPhyShutdown (pMvSataAdapter, sata_phy) == MV_TRUE)
+                {
+                    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: Shutting down SATA phy\n", pMvSataAdapter->adapterId, sata_phy);
+                }
+            }
+            else
+            {
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d]: Error in shutting down SATA phy parameters\n",
+                         pMvSataAdapter->adapterId);
+            }
+        }
+        else if (!strncmp (buffer, "sata_phy_powerup", strlen ("sata_phy_powerup")))
+        {
+            int sata_phy;
+            i = sscanf (buffer + strlen ("sata_phy_powerup"), "%d\n", &sata_phy);
+            if (i == 1)
+            {        /* Three matched inputs */
+                if (mvSataChannelPhyPowerOn (pMvSataAdapter, sata_phy) == MV_TRUE)
+                {
+                    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d,%d]: Turning on SATA phy\n", pMvSataAdapter->adapterId, sata_phy);
+                }
+            }
+            else
+            {
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG,"[%d]: Error in powering up SATA phy parameters\n",
+                         pMvSataAdapter->adapterId);
+            }
+        }
+        spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+        return length;
+    }
+    else
+    {      /* Reading from file */
+        int i;
+        /*
+         * Write to the file the time stamp which is difference between last
+         * jiffies and current one. Next to it write the HZ parameter which
+         * indicates how many time jiffies parameter is incremented in a
+         * second.
+         */
+        len += snprintf (buffer + len,length - len, "%s\n", mv_ial_proc_version);
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len, "\nTimeStamp :\n%ld\t%d\n",
+                         jiffies, HZ);
+        if (len >= length)
+        {
+            goto out;
+        }
+        /* Write the number of interrupts this adapter generated within the
+         * sampling time.
+         */
+        len += snprintf (buffer + len,length - len, "\nNumber of interrupts generated by the adapter is : \n%d\n",
+                         pAdapter->procNumOfInterrupts);
+        if (len >= length)
+        {
+            goto out;
+        }
+
+        len += snprintf (buffer + len, length - len, "\nPCI location: Bus %d, Slot %d\n",
+                         pAdapter->pcidev->bus->number,
+                         PCI_SLOT(pAdapter->pcidev->devfn));
+        if (len >= length)
+        {
+            goto out;
+        }
+
+        /*
+         * Check if channel connected.
+         * If not connected write -1 on a line
+         * If connected, write a line that has -
+         * 1.. Adapter number
+         * 2.. SCSI channel number (equivalent to SATA channel number).
+         * 3.. ID
+         * 4.. LUN (always 0)
+         * 5.. vendor name
+         * 6.. number of outstanding commands accumulated
+         * 7.. total sampling of outstanding commands
+         * 8.. total sectors transferred
+         * 9.. flag if queued / non-queued (1/0)
+         * 10. flag if LBA 48 or not (1/0)
+         * 11. flag if the storage device can be removed or not
+         *  (1 means can't be removed / 0 can be removed).
+         */
+        len += snprintf (buffer + len,length - len,"\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t\t%s\t%s\n",
+                         "Adapter", "Channel", "Id", "LUN", "TO", "TS", "Vendor",
+                         "QD", "LBA48");
+        if (len >= length)
+        {
+            goto out;
+        }
+        if ((len + 100) >= length)
+        {
+            goto out;
+        }
+        for (i = 0 ; i < 80 ; i++)
+            buffer [len + i] = '-';
+        len += i;
+        len += snprintf (buffer + len,length - len, "\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+        temp = pHost->channelIndex;
+        if (pMvSataAdapter->sataChannel[temp])
+        {
+            for (pmPort = 0; pmPort < MV_SATA_PM_MAX_PORTS; pmPort++)
+            {
+                if (pmPort > 0 &&
+                    (pMvSataAdapter->sataChannel[temp]->deviceType != MV_SATA_DEVICE_TYPE_PM))
+                {
+                    break;
+                }
+                if (pAdapter->ataScsiAdapterExt->ataDriveData[temp][pmPort].driveReady == MV_FALSE)
+                {
+                    continue;
+                }
+
+                len += snprintf (buffer + len,length - len, "%d\t%d\t%d\t%d\t%u\t%u\t",
+                                 pAdapter->mvSataAdapter.adapterId, temp, pmPort, 0,
+                                 pAdapter->ataScsiAdapterExt->ataDriveData[temp][pmPort].stats.totalIOs,
+                                 pAdapter->ataScsiAdapterExt->ataDriveData[temp][pmPort].stats.totalSectorsTransferred);
+                if (len >= length)
+                {
+                    goto out;
+                }
+                /*
+                 * Copy first 10 characters of the vendor name from the IDENTIFY
+                 * DEVICE ATA command result buffer
+                 */
+                if ((len+10) >= length)
+                {
+                    goto out;
+                }
+                memcpy (buffer+len,
+                        pAdapter->ataScsiAdapterExt->ataDriveData[temp][pmPort].identifyInfo.model, 10);
+                /*
+                 * Clean spaces in vendor name and swap odd and even characters.
+                 * The swap is due to the format of the IDENTIFY DEVICE command
+                 */
+                for (i=0 ; i<10 ; i+=2)
+                {
+                    char ch = buffer[len + i];
+                    buffer[len + i] = buffer[len+1 + i];
+                    buffer[len+1 + i] = ch;
+                    if (buffer[len + i] == ' ')
+                    {
+                        buffer[len + i + 1] = ' ';
+                        break;
+                    }
+                    if (buffer[len+1 + i] == ' ')
+                    {
+                        break;
+                    }
+                }
+                if ((len + 10) >= length)
+                {
+                    goto out;
+                }
+                for (; i < 10; i++)
+                {
+                    buffer[len + i] = ' ';
+                }
+
+                len += 10;
+                len += snprintf (buffer + len,length - len, "\t%d\t%d\n",
+                                 (pMvSataAdapter->sataChannel[temp]->queuedDMA == MV_EDMA_MODE_NOT_QUEUED) ? 0 : 1,
+                                 (pAdapter->ataScsiAdapterExt->ataDriveData[temp][pmPort].identifyInfo.LBA48Supported == MV_TRUE)  ? 1 : 0);
+                if (len >= length)
+                {
+                    goto out;
+                }
+            }
+        }
+        if ((!pMvSataAdapter->sataChannel[temp]) &&
+            (mvSataIsStorageDeviceConnected (pMvSataAdapter, temp) == MV_TRUE))
+            len += snprintf (buffer + len,length - len, "Storage device connected to channel %d is malfunction\n", temp);
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len,"\n\n\nTO           - Total Outstanding commands accumulated\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len,"TSA          - Total number of IOs accumulated\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len,"TS           - Total number of sectors transferred (both read/write)\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len,"QD           - Queued DMA feature set enabled\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+        len += snprintf (buffer + len,length - len,"LBA48        - Large Block Address 48 feature set enabled\n");
+        if (len >= length)
+        {
+            goto out;
+        }
+    }
+    out:
+    spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+    return(len);
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/****************************************************************
+ *  Name:   mv_ial_ht_proc_info (kernel version < 2.6)
+ *
+ *  Description:   /proc file
+ *
+ *  Parameters:
+ *
+ *  Returns:
+ *
+ ****************************************************************/
+int mv_ial_ht_proc_info24(char *buffer, char **start, off_t offset,
+                        int length, int inode, int inout)
+{
+    struct Scsi_Host *pshost = 0;
+
+    for (pshost = scsi_hostlist; pshost; pshost = pshost->next)
+    {
+        if (pshost->host_no == inode)
+        {
+            return mv_ial_ht_proc_info(pshost, buffer, start,
+                                       offset,length, inout);
+        }
+    }
+    return -EINVAL;
+}
+#endif
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+static int mv_ial_ht_slave_configure (struct scsi_device* pDevs)
+{
+    IAL_HOST_T *pHost = HOSTDATA (pDevs->host);
+    struct Scsi_Host* scsiHost = pDevs->host;
+    struct scsi_device*    pDevice = NULL;
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d]: slave configure\n",
+                        pHost->pAdapter->mvSataAdapter.adapterId);
+    shost_for_each_device(pDevice, scsiHost)
+    {
+        if (pHost->queueDepth > 0)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d %d]: adjust queue depth to %d\n",
+                        pHost->pAdapter->mvSataAdapter.adapterId, pDevice->id, pHost->queueDepth);
+            scsi_adjust_queue_depth(pDevice, MSG_SIMPLE_TAG, pHost->queueDepth);
+        }
+    }
+    return 0;
+}
+#else
+static void mv_ial_ht_select_queue_depths (struct Scsi_Host* pHost,
+                                           struct scsi_device* pDevs)
+{
+    IAL_HOST_T *ial_host = HOSTDATA (pHost);
+    struct scsi_device* pDevice;
+    if (ial_host != NULL && ial_host->queueDepth > 0)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d %d]: adjust queue depth to %d\n",
+            ial_host->pAdapter->mvSataAdapter.adapterId,
+            ial_host->channelIndex,
+            ial_host->queueDepth);
+        /* linux 2.4 queue depth is not tunable, so we set the device queue */
+        /* to the max value (MV_SATA_SW_QUEUE_SIZE), and limit the number queued */
+        /* commands using the cmd_per_lun */
+
+        /* set can_queue to the max number of queued commands per host (sata */
+        /* channel). This may casue startvation if PortMultiplier is connected*/
+        pHost->can_queue = ial_host->queueDepth;
+        pHost->cmd_per_lun = ial_host->queueDepth;
+
+        /*always allocate the max number of commands */
+        for (pDevice = pDevs; pDevice; pDevice = pDevice->next)
+        {
+            if (pDevice->host == pHost)
+            {
+                pDevice->queue_depth = MV_SATA_SW_QUEUE_SIZE;
+            }
+        }
+    }
+}
+#endif
+
+int mv_ial_ht_abort(struct scsi_cmnd *SCpnt)
+{
+    IAL_ADAPTER_T   *pAdapter;
+    IAL_HOST_T      *pHost;
+
+    MV_SATA_ADAPTER *pMvSataAdapter;
+    MV_U8           channel;
+    unsigned long lock_flags;
+    struct scsi_cmnd *cmnds_done_list = NULL;
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "abort command %p\n", SCpnt);
+    if (SCpnt == NULL)
+    {
+        return FAILED;
+    }
+    pHost = HOSTDATA(SCpnt->device->host);
+    channel = pHost->channelIndex;
+    pAdapter = MV_IAL_ADAPTER(SCpnt->device->host);
+    pMvSataAdapter = &pAdapter->mvSataAdapter;
+    if (SCpnt->serial_number != SCpnt->serial_number_at_timeout)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: abort failed, "
+                 "serial number mismatch\n",SCpnt->device->host->host_no,
+                 channel, SCpnt->device->id);
+        return FAILED;
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_unlock_irq (&io_request_lock);
+#else
+    spin_unlock_irq (pHost->scsihost->host_lock);
+#endif
+    spin_lock_irqsave (&pAdapter->adapter_lock, lock_flags);
+
+    mvRestartChannel(&pAdapter->ialCommonExt, channel,
+                     pAdapter->ataScsiAdapterExt, MV_TRUE);
+    mv_ial_block_requests(pAdapter, channel);
+
+    cmnds_done_list = mv_ial_lib_get_first_cmnd(pAdapter, channel);
+
+    spin_unlock_irqrestore (&pAdapter->adapter_lock, lock_flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    spin_lock_irq(&io_request_lock);
+#else
+    spin_lock_irq (pHost->scsihost->host_lock);
+#endif
+
+    if (cmnds_done_list)
+    {
+        scsi_report_bus_reset(SCpnt->device->host, SCpnt->device->channel);
+        mv_ial_lib_do_done(cmnds_done_list);
+        return SUCCESS;
+    }
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d %d %d]: command abort failed\n",
+             SCpnt->device->host->host_no, SCpnt->device->channel, SCpnt->device->id);
+    return FAILED;
+}
+
+
+struct scsi_host_template driver_template = mvSata;
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Marvell Serial ATA PCI-X Adapter");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include "scsi_module.c"
+#endif
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalHt.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalHt.h
@@ -0,0 +1,234 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxIalHt.h
+*
+* DESCRIPTION: header file for the layer that emulates SCSI adapter on the
+*           SATA adapter
+*
+*
+* DEPENDENCIES:
+*   None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+******************************************************************************/
+#ifndef __INCmvLinuxIalHth
+#define __INCmvLinuxIalHth
+
+#include <linux/version.h>
+#include <linux/autoconf.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#else
+#include <linux/blk.h>
+#include "scsi.h"
+#include "hosts.h"
+#endif
+
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvStorageDev.h"
+#include "mvScsiAtaLayer.h"
+#include "mvLinuxIalLib.h"
+#include "mvIALCommon.h"
+
+#include <linux/blkdev.h>
+#include <linux/spinlock.h>
+/* Common forward declarations for all Linux-versions: */
+
+/* Interfaces to the midlevel Linux SCSI driver */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+extern int mv_ial_ht_detect (struct scsi_host_template *);
+#endif
+extern int mv_ial_ht_release (struct Scsi_Host *);
+extern int mv_ial_ht_queuecommand (struct scsi_cmnd *, void (*done) (struct scsi_cmnd *));
+extern int mv_ial_ht_bus_reset (struct scsi_cmnd *);
+extern int mv_ial_ht_abort(struct scsi_cmnd *SCpnt);
+
+#define HOSTDATA(host) ((IAL_HOST_T *)&host->hostdata)
+#define MV_IAL_ADAPTER(host) (HOSTDATA(host)->pAdapter)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define mvSata                                                          \
+{                                                                           \
+    module:     THIS_MODULE,\
+    proc_name:          "mvSata",                   /* proc_name */     \
+    proc_info:          mv_ial_ht_proc_info,    /*proc info fn */   \
+    slave_configure:    mv_ial_ht_slave_configure,\
+    name:               "Marvell SCSI to SATA adapter", /*name*/            \
+    release:            mv_ial_ht_release,              /*release fn*/      \
+    queuecommand:       mv_ial_ht_queuecommand,         /*queuecommand fn*/ \
+    bios_param:         NULL    /*mv_ial_ht_biosparam*/,/*bios fn*/     \
+    eh_device_reset_handler: NULL/*mv_ial_ht_dev_reset*/,                   \
+    eh_bus_reset_handler: mv_ial_ht_bus_reset,                              \
+    eh_abort_handler:   mv_ial_ht_abort,                                    \
+    can_queue:          MV_SATA_SW_QUEUE_SIZE,           /* unlimited */     \
+    this_id:            MV_SATA_PM_MAX_PORTS,                          /*set by detect*/   \
+    sg_tablesize:       64,                             /*sg_tablesize*/    \
+    max_sectors:        256,                                                \
+    cmd_per_lun:        MV_SATA_SW_QUEUE_SIZE,           /*cmd_per_lun*/     \
+    unchecked_isa_dma:  0,                              /*32-Bit Busmaster*/\
+    emulated:           1,                      /* not real scsi adapter */ \
+    use_clustering:     ENABLE_CLUSTERING               /*use_clustering*/  \
+}
+#else
+#define mvSata                                                          \
+{                                                                           \
+    proc_name:          "mvSata",                   /* proc_name */     \
+    proc_info:          mv_ial_ht_proc_info24,  /*proc info fn */   \
+    select_queue_depths: NULL,              \
+    name:               "Marvell SCSI to SATA adapter", /*name*/            \
+    detect:             mv_ial_ht_detect,               /*detect fn*/       \
+    release:            mv_ial_ht_release,              /*release fn*/      \
+    command:            NULL,                           /*command fn*/      \
+    queuecommand:       mv_ial_ht_queuecommand,         /*queuecommand fn*/ \
+    bios_param:         NULL    /*mv_ial_ht_biosparam*/,/*bios fn*/     \
+    eh_device_reset_handler: NULL/*mv_ial_ht_dev_reset*/,                   \
+    eh_bus_reset_handler: mv_ial_ht_bus_reset,                              \
+    eh_abort_handler:   mv_ial_ht_abort,                                    \
+    can_queue:          MV_SATA_SW_QUEUE_SIZE,                         /* unlimited */     \
+    this_id:            MV_SATA_PM_MAX_PORTS,                              /*set by detect*/   \
+    sg_tablesize:       64,                             /*sg_tablesize*/    \
+    max_sectors:        256,                                                \
+    cmd_per_lun:        MV_SATA_SW_QUEUE_SIZE,           /*cmd_per_lun*/     \
+    unchecked_isa_dma:  0,                              /*32-Bit Busmaster*/\
+    emulated:           1,                      /* not real scsi adapter */ \
+    use_new_eh_code:    1,                                                  \
+    highmem_io:         1,                           /*highmem_io enabled*/\
+    use_clustering:     ENABLE_CLUSTERING               /*use_clustering*/  \
+}
+#endif
+
+
+#define MV_IAL_HT_SACOALT_DEFAULT   4
+#define MV_IAL_HT_SAITMTH_DEFAULT   (150 * 50)
+
+/****************************************/
+/*          GENERAL Definitions         */
+/****************************************/
+
+#define REQUESTS_ARRAY_SIZE         (9 * MV_EDMA_REQUEST_QUEUE_SIZE) /* 9 K bytes */
+#define RESPONSES_ARRAY_SIZE        (12 * MV_EDMA_RESPONSE_QUEUE_SIZE) /* 3 K bytes */
+
+
+struct IALHost;
+
+/*struct prdPool;*/
+typedef struct IALAdapter
+{
+    MV_SATA_ADAPTER     mvSataAdapter;
+    MV_U8               activeHosts;
+    int                 maxHosts;
+    struct IALHost      *host[MV_SATA_CHANNELS_NUM];
+    struct pci_dev      *pcidev;
+    u8                  rev_id; /* adapter revision id */
+    u8                  *requestsArrayBaseAddr;
+    u8                  *requestsArrayBaseAlignedAddr;
+    dma_addr_t          requestsArrayBaseDmaAddr;
+    dma_addr_t          requestsArrayBaseDmaAlignedAddr;
+    u8                  *responsesArrayBaseAddr;
+    u8                  *responsesArrayBaseAlignedAddr;
+    dma_addr_t          responsesArrayBaseDmaAddr;
+    dma_addr_t          responsesArrayBaseDmaAlignedAddr;
+    u32                 procNumOfInterrupts;
+    MV_IAL_COMMON_ADAPTER_EXTENSION ialCommonExt;
+    MV_BOOLEAN          stopAsyncTimer;
+    struct timer_list   asyncStartTimer;
+    MV_SAL_ADAPTER_EXTENSION  *ataScsiAdapterExt;
+    spinlock_t          adapter_lock;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    struct semaphore    rescan_mutex;
+    atomic_t            stopped;
+#endif
+} IAL_ADAPTER_T;
+
+typedef struct IALHost
+{
+    struct Scsi_Host* scsihost;
+    MV_U8 channelIndex;
+    IAL_ADAPTER_T* pAdapter;
+    u8  queueDepth;
+    void  *prdPool[MV_SATA_SW_QUEUE_SIZE];
+    void  *prdPoolAligned[MV_SATA_SW_QUEUE_SIZE];
+    MV_U32  freePRDsNum;
+    struct scsi_cmnd *scsi_cmnd_done_head, *scsi_cmnd_done_tail;
+    MV_BOOLEAN  hostBlocked;
+} IAL_HOST_T;
+
+/******************************************************************************
+* We use the Scsi_Pointer structure that's included with each command
+* SCSI_Cmnd as a scratchpad for our SRB. This allows us to accept
+* an unlimited number of commands.
+*
+* SCp will always point to mv_comp_info structure
+*******************************************************************************/
+
+/* UDMA command completion info */
+struct mv_comp_info
+{
+    struct scsi_cmnd           *SCpnt;
+    MV_SATA_EDMA_PRD_ENTRY  *cpu_PRDpnt;
+    dma_addr_t      dma_PRDpnt;
+    dma_addr_t      single_buff_busaddr;
+    unsigned int        allocated_entries;
+    unsigned int        seq_number;
+    MV_SATA_SCSI_CMD_BLOCK  *pSALBlock;
+    struct scsi_cmnd           *next_done;
+};
+
+
+/* Once pci64_ DMA mapping interface is in, kill this. */
+/*#define pci64_alloc_consistent(d,s,p) pci_alloc_consistent((d),(s),(p))*/
+/*#define pci64_free_consistent(d,s,c,a) pci_free_consistent((d),(s),(c),(a))*/
+
+#define pci64_map_single(d,c,s,dir) pci_map_single((d),(c),(s),(dir))
+#define pci64_map_sg(d,s,n,dir) pci_map_sg((d),(s),(n),(dir))
+#define pci64_unmap_single(d,a,s,dir) pci_unmap_single((d),(a),(s),(dir))
+#define pci64_unmap_sg(d,s,n,dir) pci_unmap_sg((d),(s),(n),(dir))
+
+#if (BITS_PER_LONG > 32) || defined(CONFIG_HIGHMEM64G)
+#define pci64_dma_hi32(a) ((u32) (0xffffffff & (((u64)(a))>>32)))
+#define pci64_dma_lo32(a) ((u32) (0xffffffff & (((u64)(a)))))
+#else
+#define pci64_dma_hi32(a) 0
+#define pci64_dma_lo32(a) (a)
+#endif  /* BITS_PER_LONG */
+#define sg_dma64_address(s) sg_dma_address(s)
+#define sg_dma64_len(s) sg_dma_len(s)
+
+
+#endif /* __INCmvLinuxIalHth */
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalLib.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalLib.c
@@ -0,0 +1,1263 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxIalLib.c
+*
+* DESCRIPTION:
+*   implementation for linux IAL lib functions.
+*
+* DEPENDENCIES:
+*   mvLinuxIalLib.h
+*   mvLinuxIalHt.h
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+
+/* includes */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    #include <linux/workqueue.h>
+#endif
+
+#include "mvLinuxIalLib.h"
+#include "mvIALCommon.h"
+
+#ifndef scsi_to_pci_dma_dir
+    #define scsi_to_pci_dma_dir(scsi_dir) ((int)(scsi_dir))
+#endif
+
+
+/* Connect / disconnect timers. */
+/* Note that the disconnect timer should be smaller than the SCSI */
+/* subsystem timer. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+struct rescan_wrapper
+{
+    struct work_struct     work;
+    IAL_ADAPTER_T       *pAdapter;
+    MV_U8                  channelIndex;
+    MV_U16                 targetsToRemove;
+    MV_U16                 targetsToAdd;
+};
+#endif
+
+
+static void *mv_ial_lib_prd_allocate(IAL_HOST_T *pHost);
+
+static int mv_ial_lib_add_buffer_to_prd_table(MV_SATA_ADAPTER   *pMvSataAdapter,
+                                              MV_SATA_EDMA_PRD_ENTRY *pPRD_table,
+                                              int table_size,
+                                              int *count, dma_addr_t buf_addr,
+                                              unsigned int buf_len, int isEOT);
+
+void release_ata_mem(struct mv_comp_info * pInfo);
+
+dma_addr_t inline pci64_map_page(struct pci_dev *hwdev, void* address,
+                                 size_t size, int direction)
+
+{
+    dma_addr_t mm = pci_map_page(hwdev, virt_to_page(address),
+                                 ((unsigned long)address & ~PAGE_MASK),
+                                 size, direction);
+    return mm;
+}
+
+
+void inline pci64_unmap_page(struct pci_dev *hwdev, dma_addr_t address,
+                             size_t size, int direction)
+{
+    pci_unmap_page(hwdev, address, size, direction);
+}
+
+
+int mv_ial_lib_prd_init(IAL_HOST_T *pHost)
+{
+    MV_U8  i;
+    /*
+     * Allocate PRD Pool for 8 channels and 31 outstanding commands -
+     * Since the driver supports 64 SG table, then each PRD table can go upto
+     * 1KByte (64 entries * 16byte)
+     */
+    for (i = 0 ; i < MV_SATA_SW_QUEUE_SIZE; i++)
+    {
+        pHost->prdPool[i] = kmalloc ((MV_EDMA_PRD_ENTRY_SIZE * MV_PRD_TABLE_SIZE)+16,
+                    GFP_KERNEL);
+        if (pHost->prdPool[i] == NULL)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: Could not allocate PRD pool\n",
+                pHost->pAdapter->mvSataAdapter.adapterId, pHost->channelIndex);
+            return -1;
+        }
+        pHost->prdPoolAligned[i] = (void *)(((ulong)(pHost->prdPool[i]) + 15 ) & ~0xf);
+    }
+
+    pHost->freePRDsNum = MV_SATA_SW_QUEUE_SIZE;
+
+    return 0;
+}
+
+static void *mv_ial_lib_prd_allocate(IAL_HOST_T *pHost)
+{
+    return pHost->prdPoolAligned[--pHost->freePRDsNum];
+}
+
+int mv_ial_lib_prd_free(IAL_HOST_T *pHost, int size, dma_addr_t dmaPtr,
+                        void *cpuPtr)
+{
+    pci64_unmap_page(pHost->pAdapter->pcidev,
+                     dmaPtr,
+                     size * MV_EDMA_PRD_ENTRY_SIZE,
+                     PCI_DMA_TODEVICE);
+
+    pHost->prdPoolAligned[pHost->freePRDsNum++] = cpuPtr;
+    return 0;
+}
+
+
+int mv_ial_lib_prd_destroy(IAL_HOST_T *pHost)
+{
+    MV_U8 temp;
+    for (temp = 0; temp < MV_SATA_SW_QUEUE_SIZE; temp++)
+    {
+        if (pHost->prdPool[temp] != NULL)
+    {
+            kfree (pHost->prdPool[temp]);
+    }
+    }
+    return 0;
+}
+
+
+/*******************************************************************************
+ *  Name:   mv_ial_lib_add_done_queue
+ *
+ *  Description:    Add scsi_cmnd to done list. Caller must take care of
+ *                  adapter_lock locking.
+ *
+ *  Parameters:     pAdapter - Adapter data structure
+ *                  scsi_cmnd - SCSI command data sturcture
+ *
+ ******************************************************************************/
+void mv_ial_lib_add_done_queue (struct IALAdapter *pAdapter,
+                                MV_U8 channel,
+                                struct scsi_cmnd   *scsi_cmnd)
+{
+    /* Put new command in the tail of the queue and make it point to NULL */
+    ((struct mv_comp_info *)(&scsi_cmnd->SCp))->next_done = NULL;
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Adding command @ %p to done queue, "
+             "channel %d\n",scsi_cmnd, channel);
+    if ((channel >= MV_SATA_CHANNELS_NUM) || (pAdapter->host[channel] == NULL))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_FATAL_ERROR, "Adding command @ %p to "
+                 " invalid channel (%d)\n",scsi_cmnd, channel);
+    }
+    if (pAdapter->host[channel]->scsi_cmnd_done_head == NULL)
+    {
+        /* First command to the queue */
+        pAdapter->host[channel]->scsi_cmnd_done_head = scsi_cmnd;
+        pAdapter->host[channel]->scsi_cmnd_done_tail = scsi_cmnd;
+    }
+    else
+    {
+        /* We already have commands in the queue ; put this command in the tail */
+        ((struct mv_comp_info *)(&pAdapter->host[channel]->scsi_cmnd_done_tail->SCp))->next_done = scsi_cmnd;
+        pAdapter->host[channel]->scsi_cmnd_done_tail = scsi_cmnd;
+    }
+}
+
+/*******************************************************************************
+ *  Name:   mv_ial_lib_get_first_cmnd
+ *
+ *  Description:    Gets first scsi_cmnd from a chain of scsi commands to be
+ *                  completed, then sets NULL to head and tail.
+ *                  Caller must take care of adapter_lock locking.
+ *
+ *  Parameters:     pAdapter - Adapter data structure
+ *
+ *  Return Value:   Pointer to first scsi command in chain
+ ******************************************************************************/
+struct scsi_cmnd * mv_ial_lib_get_first_cmnd (struct IALAdapter *pAdapter, MV_U8 channel)
+{
+    if (pAdapter->host[channel] != NULL)
+    {
+    struct scsi_cmnd *cmnd = pAdapter->host[channel]->scsi_cmnd_done_head;
+    pAdapter->host[channel]->scsi_cmnd_done_head = NULL;
+    pAdapter->host[channel]->scsi_cmnd_done_tail = NULL;
+    return cmnd;
+}
+    return NULL;
+}
+
+/*******************************************************************************
+ *  Name:   mv_ial_lib_do_done
+ *
+ *  Description:    Calls scsi_done of chain of scsi commands.
+ *                  Note that adapter_lock can be locked or unlocked, but
+ *                  caller must take care that io_request_lock is locked.
+ *
+ *  Parameters:     cmnd - First command in scsi commands chain
+ *
+ ******************************************************************************/
+void mv_ial_lib_do_done (struct scsi_cmnd *cmnd)
+{
+    /* Call done function for all commands in queue */
+    while (cmnd)
+    {
+        struct scsi_cmnd *temp;
+        temp = ((struct mv_comp_info *)(&cmnd->SCp))->next_done;
+
+        if (cmnd->scsi_done == NULL)
+        {
+            return;
+        }
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Calling done to command @ %p "
+                 "scsi_done = %p\n",cmnd, cmnd->scsi_done);
+        cmnd->scsi_done(cmnd);
+        cmnd = temp;
+    }
+}
+
+
+/*******************************************************************************
+ *  Name:   mv_ial_lib_free_channel
+ *
+ *  Description:    free allocated queues for the given channel
+ *
+ *  Parameters:     pMvSataAdapter - pointer to the adapter controler this
+ *                  channel connected to.
+ *          channelNum - channel number.
+ *
+ ******************************************************************************/
+void mv_ial_lib_free_channel(IAL_ADAPTER_T *pAdapter, MV_U8 channelNum)
+{
+    MV_SATA_CHANNEL *pMvSataChannel;
+
+    if (channelNum >= pAdapter->mvSataAdapter.numberOfChannels)
+    {
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR, "[%d]: Bad channelNum=%d\n",
+                 pAdapter->mvSataAdapter.adapterId, channelNum);
+        return;
+    }
+
+    pMvSataChannel = pAdapter->mvSataAdapter.sataChannel[channelNum];
+    kfree(pMvSataChannel);
+    pAdapter->mvSataAdapter.sataChannel[channelNum] = NULL;
+    return;
+}
+/****************************************************************
+ *  Name:   mv_ial_lib_init_channel
+ *
+ *  Description:    allocate request and response queues for the EDMA of the
+ *                  given channel and sets other fields.
+ *
+ *  Parameters:
+ *      pAdapter - pointer to the emulated adapter data structure
+ *      channelNum - channel number.
+ *  Return: 0 on success, otherwise on failure
+ ****************************************************************/
+int mv_ial_lib_init_channel(IAL_ADAPTER_T *pAdapter, MV_U8 channelNum)
+{
+    MV_SATA_CHANNEL *pMvSataChannel;
+    dma_addr_t    req_dma_addr;
+    dma_addr_t    rsp_dma_addr;
+
+    if (channelNum >= pAdapter->mvSataAdapter.numberOfChannels)
+    {
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR, "[%d]: Bad channelNum=%d",
+                 pAdapter->mvSataAdapter.adapterId, channelNum);
+        return -1;
+    }
+
+    pMvSataChannel = (MV_SATA_CHANNEL *)kmalloc(sizeof(MV_SATA_CHANNEL),
+                                                GFP_ATOMIC);
+    if (pMvSataChannel == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: out of memory\n",
+                 pAdapter->mvSataAdapter.adapterId);
+        return -1;
+    }
+    pAdapter->mvSataAdapter.sataChannel[channelNum] = pMvSataChannel;
+    pMvSataChannel->channelNumber = channelNum;
+
+    pMvSataChannel->requestQueue = (struct mvDmaRequestQueueEntry *)
+                                   (pAdapter->requestsArrayBaseAlignedAddr +
+                                    (channelNum * MV_EDMA_REQUEST_QUEUE_SIZE));
+    req_dma_addr = pAdapter->requestsArrayBaseDmaAlignedAddr +
+                   (channelNum * MV_EDMA_REQUEST_QUEUE_SIZE);
+
+/* check the 1K alignment of the request queue*/
+    if (((u64)req_dma_addr) & 0x3ffULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: request queue allocated isn't 1 K aligned,"
+                 " dma_addr=%x.%x channel=%d\n", pAdapter->mvSataAdapter.adapterId,
+                 (unsigned int)pci64_dma_hi32(req_dma_addr),
+                 (unsigned int)pci64_dma_lo32(req_dma_addr),
+                 channelNum);
+        return -1;
+    }
+    pMvSataChannel->requestQueuePciLowAddress = pci64_dma_lo32(req_dma_addr);
+    pMvSataChannel->requestQueuePciHiAddress = pci64_dma_hi32(req_dma_addr);
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d,%d]: request queue allocated: 0x%p\n",
+             pAdapter->mvSataAdapter.adapterId, channelNum,
+             pMvSataChannel->requestQueue);
+    pMvSataChannel->responseQueue = (struct mvDmaResponseQueueEntry *)
+                                    (pAdapter->responsesArrayBaseAlignedAddr +
+                                     (channelNum * MV_EDMA_RESPONSE_QUEUE_SIZE));
+    rsp_dma_addr = pAdapter->responsesArrayBaseDmaAlignedAddr +
+                   (channelNum * MV_EDMA_RESPONSE_QUEUE_SIZE);
+
+/* check the 256 alignment of the response queue*/
+    if (((u64)rsp_dma_addr) & 0xff)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d,%d]: response queue allocated isn't 256 byte "
+                 "aligned, dma_addr=%x.%x\n",
+                 pAdapter->mvSataAdapter.adapterId, (unsigned int)pci64_dma_hi32(rsp_dma_addr),
+                 (unsigned int)pci64_dma_lo32(rsp_dma_addr), channelNum);
+        return -1;
+    }
+    pMvSataChannel->responseQueuePciLowAddress = pci64_dma_lo32(rsp_dma_addr);
+    pMvSataChannel->responseQueuePciHiAddress = pci64_dma_hi32(rsp_dma_addr);
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d,%d]: response queue allocated: 0x%p\n",
+             pAdapter->mvSataAdapter.adapterId, channelNum,
+             pMvSataChannel->responseQueue);
+    return 0;
+}
+
+/****************************************************************
+ *  Name:   mv_ial_lib_int_handler
+ *
+ *  Description:    Interrupt handler.
+ *
+ *  Parameters:     irq - Hardware IRQ number.assume that different cards will have
+ *                  different IRQ's TBD
+ *                  dev_id  - points to the mvxxxxxxDeviceStruct that generated
+ *                    the interrupt
+ *                  regs    -
+ *
+ *
+ ****************************************************************/
+irqreturn_t mv_ial_lib_int_handler (int irq, void *dev_id, struct pt_regs *regs)
+{
+    IAL_ADAPTER_T       *pAdapter;
+    unsigned long       flags;
+    int                 handled = 0;
+    struct scsi_cmnd *cmnds_done_list = NULL;
+    pAdapter = (IAL_ADAPTER_T *)dev_id;
+
+/*
+ * Acquire the adapter spinlock. Meantime all completed commands will be added
+ * to done queue.
+ */
+    spin_lock_irqsave(&pAdapter->adapter_lock, flags);
+
+    if (mvSataInterruptServiceRoutine(&pAdapter->mvSataAdapter) == MV_TRUE)
+    {
+        handled = 1;
+        pAdapter->procNumOfInterrupts ++;
+        mvSataScsiPostIntService(pAdapter->ataScsiAdapterExt);
+    }
+    /* Unlock adapter lock */
+    spin_unlock_irqrestore(&pAdapter->adapter_lock, flags);
+    /* Check if there are commands in the done queue to be completed */
+    if (handled == 1)
+    {
+        MV_U8 i;
+
+        for (i = 0; i < pAdapter->maxHosts; i++)
+        {
+            spin_lock_irqsave(&pAdapter->adapter_lock, flags);
+            cmnds_done_list = mv_ial_lib_get_first_cmnd(pAdapter, i);
+            spin_unlock_irqrestore(&pAdapter->adapter_lock, flags);
+            if (cmnds_done_list)
+            {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                spin_lock_irqsave(&io_request_lock, flags);
+#else
+                spin_lock_irqsave(pAdapter->host[i]->scsihost->host_lock, flags);
+#endif
+                mv_ial_lib_do_done(cmnds_done_list);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                spin_unlock_irqrestore(&io_request_lock, flags);
+#else
+                spin_unlock_irqrestore(pAdapter->host[i]->scsihost->host_lock, flags);
+#endif
+            }
+        }
+    }
+    return IRQ_RETVAL(handled);
+}
+
+/****************************************************************
+ *  Name: mv_ial_lib_add_buffer_to_prd_table
+ *
+ *  Description:    insert one buffer into number of entries in the PRD table,
+ *                  keeping 64KB boundaries
+ *
+ *  Parameters:     pPRD_table: pointer to the PRD table.
+ *          table_size: number of entries in the PRD table.
+ *          count: index of the next entry to add, should be updated by this
+ *          function
+ *          buf_addr,buf_len: the dma address and the size of the buffer to add.
+ *          isEOT: 1 if this is the last entry
+ *  Returns:        0 on success, otherwise onfailure.
+ *
+ ****************************************************************/
+
+static int mv_ial_lib_add_buffer_to_prd_table(MV_SATA_ADAPTER   *pMvSataAdapter,
+                                              MV_SATA_EDMA_PRD_ENTRY *pPRD_table,
+                                              int table_size, int *count,
+                                              dma_addr_t buf_addr,
+                                              unsigned int buf_len,
+                                              int isEOT)
+{
+    unsigned int    entry = *count;
+    u64             xcount = 0;
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG,"insert to PRD table, count=%d, buf_addr=%x, buf_len=%x\n",
+             *count,(unsigned int) buf_addr, buf_len);
+
+
+
+    /*
+    The buffer is splitted in case then either the buffer size exceeds 64 KB
+    or 2 high address bits of all data in the buffer are not identical
+    */
+    while (buf_len)
+    {
+        if (entry >= table_size)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,"PRD table too small (entry %d, table_size %d\n",
+                     entry, table_size);
+            mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,"[%d] insert to PRD table, count=%d,"
+                     " buf_addr=%x, buf_len=%x\n",
+                     pMvSataAdapter->adapterId,
+                     *count,(unsigned int) buf_addr, buf_len);
+            return -1;
+        }
+        else
+        {
+            u64 bcount = buf_len;
+            /*buffer size exceeds 64K*/
+            if (bcount > 0x10000)
+                bcount = 0x10000;
+            if (buf_addr & 0x1)
+            {
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, " PRD entry low address is not 1 bit aligned\n");
+                return -1;
+            }
+#if (BITS_PER_LONG > 32) || defined(CONFIG_HIGHMEM64G)
+            /*Split the buffer if 2 high address bits of all
+            data in the buffer are not the same*/
+            if ((buf_addr | 0xFFFFFFFF)  !=
+                ((buf_addr + bcount - 1) | 0xFFFFFFFF))
+            {
+                bcount = 0x100000000ULL - (buf_addr & 0xFFFFFFFF);
+            }
+#endif
+            /*In case then buffer size is 64K
+            PRD entry byte count is set to zero*/
+            xcount = bcount & 0xffff;
+            pPRD_table[entry].lowBaseAddr =
+            cpu_to_le32(pci64_dma_lo32(buf_addr));
+            pPRD_table[entry].highBaseAddr =
+            cpu_to_le32(pci64_dma_hi32(buf_addr));
+            pPRD_table[entry].byteCount = cpu_to_le16(xcount);
+            pPRD_table[entry].reserved = 0;
+            /* enable snoop on data buffers */
+            pPRD_table[entry].flags = 0;/*cpu_to_le16(MV_EDMA_PRD_NO_SNOOP_FLAG);*/
+            if (xcount & 0x1)
+            {
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR," PRD entry byte count is not 1 bit aligned\n");
+                return -1;
+            }
+            buf_addr += bcount;
+            buf_len -= bcount;
+            entry++;
+        }
+    }
+
+    if (entry)
+    {
+        if (isEOT)/* enable snoop on data buffers */
+            pPRD_table[entry-1].flags = cpu_to_le16(MV_EDMA_PRD_EOT_FLAG /*|
+                                                    MV_EDMA_PRD_NO_SNOOP_FLAG*/);
+
+        *count = entry;
+        return 0;
+    }
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "insert zero entries to PRD table \n");
+    return -1;
+}
+
+/* map to pci */
+int mv_ial_lib_generate_prd(MV_SATA_ADAPTER *pMvSataAdapter, struct scsi_cmnd *SCpnt,
+                            MV_SATA_EDMA_PRD_ENTRY **ppPRD_table,
+                            dma_addr_t *pPRD_dma_address,
+                            unsigned int *pPrd_size, dma_addr_t *pBusaddr)
+{
+    IAL_ADAPTER_T   *pAdapter = MV_IAL_ADAPTER(SCpnt->device->host);
+    IAL_HOST_T      *pHost = HOSTDATA(SCpnt->device->host);
+
+    struct scatterlist *sg;
+    unsigned int prd_count;
+    /*should be removed*/
+
+    if (SCpnt->request_bufflen > (SCpnt->device->host->max_sectors << 9))
+    {
+        printk("ERROR: request length exceeds the maximum alowed value, %x %x\n",
+               pMvSataAdapter->pciConfigDeviceId,
+               pMvSataAdapter->pciConfigRevisionId);
+    }
+
+    if (SCpnt->use_sg)
+    {
+        unsigned int sg_count;
+        unsigned int i;
+
+        sg = (struct scatterlist *) SCpnt->request_buffer;
+
+        sg_count = pci64_map_sg(pAdapter->pcidev, sg,
+                                SCpnt->use_sg,
+                                scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+
+        if (sg_count != SCpnt->use_sg)
+            printk("WARNING sg_count(%d) != SCpnt->use_sg(%d)\n",
+                   (unsigned int)sg_count, SCpnt->use_sg);
+
+        *pPrd_size = MV_PRD_TABLE_SIZE;
+        *ppPRD_table = (MV_SATA_EDMA_PRD_ENTRY*)mv_ial_lib_prd_allocate(pHost);
+        if (ppPRD_table == NULL)
+        {
+            mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR, "Failed to allocate PRD table, requested size=%d\n"
+                     , *pPrd_size);
+            pci64_unmap_sg(pAdapter->pcidev, sg, SCpnt->use_sg,
+                           scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+            return -1;
+        }
+        prd_count=0;
+        for (i=0; (i < sg_count) && (sg_dma_len(sg)); i++, sg++)
+        {
+            int isEOT;
+
+            isEOT =((i+1 < sg_count) && (sg_dma_len(&sg[1]))) ? 0 : 1;
+
+            if (mv_ial_lib_add_buffer_to_prd_table(pMvSataAdapter,
+                                                   *ppPRD_table,
+                                                   *pPrd_size,
+                                                   &prd_count,
+                                                   sg_dma_address(sg),
+                                                   sg_dma_len(sg),
+                                                   isEOT))
+            {
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR," in building PRD table from scatterlist, "
+                         "prd_size=%d, prd_count=%d\n", *pPrd_size,
+                         prd_count);
+                pci64_unmap_sg(pAdapter->pcidev,
+                               (struct scatterlist *)SCpnt->request_buffer,
+                               SCpnt->use_sg,
+                               scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+
+                return -1;
+            }
+        }
+        *pPRD_dma_address = pci64_map_page(pAdapter->pcidev,
+                                           *ppPRD_table,
+                                           MV_EDMA_PRD_ENTRY_SIZE * (*pPrd_size),
+                                           PCI_DMA_TODEVICE);
+    }
+    else
+        if (SCpnt->request_bufflen && SCpnt->sc_data_direction != PCI_DMA_NONE)
+    {
+        *pPrd_size = MV_PRD_TABLE_SIZE;
+        *ppPRD_table = (MV_SATA_EDMA_PRD_ENTRY*)mv_ial_lib_prd_allocate(pHost);
+        if (*ppPRD_table == NULL)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Failed to allocate PRD table, requested size=%d\n",
+                     *pPrd_size);
+            return -1;
+        }
+
+        *pBusaddr = pci64_map_page(pAdapter->pcidev, SCpnt->request_buffer,
+                                   SCpnt->request_bufflen,
+                                   scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+        prd_count = 0;
+        if (mv_ial_lib_add_buffer_to_prd_table(pMvSataAdapter,
+                                               *ppPRD_table,
+                                               *pPrd_size,
+                                               &prd_count, *pBusaddr,
+                                               SCpnt->request_bufflen, 1))
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, " in building PRD table from buffer\n");
+            pci64_unmap_page(pAdapter->pcidev, *pBusaddr, SCpnt->request_bufflen,
+                             scsi_to_pci_dma_dir(SCpnt->sc_data_direction));
+            return -1;
+        }
+        *pPRD_dma_address = pci64_map_page(pAdapter->pcidev,
+                                           *ppPRD_table,
+                                           MV_EDMA_PRD_ENTRY_SIZE* (*pPrd_size),
+                                           PCI_DMA_TODEVICE);
+    }
+    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "PRD table allocated %p\n", *ppPRD_table);
+    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "PRD table allocated (dma) %x \n", *pPRD_dma_address);
+    return 0;
+}
+
+
+/****************************************************************
+ *  Name: mv_ial_block_requests
+ *
+ *  Description:    Blocks request from SCSI mid layer while channel
+ *                  initialization is in progress
+ *
+ *  Parameters:     pAdapter, pointer to the IAL adapter data structure.
+ *                  channelIndex, channel number
+ *
+ *  Returns:        None.
+ *
+ ****************************************************************/
+
+void mv_ial_block_requests(struct IALAdapter *pAdapter, MV_U8 channelIndex)
+{
+    if (MV_TRUE == pAdapter->host[channelIndex]->hostBlocked)
+    {
+        return;
+    }
+
+    if ((pAdapter->ialCommonExt.channelState[channelIndex] != CHANNEL_READY) &&
+         (pAdapter->ialCommonExt.channelState[channelIndex] != CHANNEL_NOT_CONNECTED))
+    {
+        pAdapter->host[channelIndex]->hostBlocked = MV_TRUE;
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: blocking SCSI host.\n",
+                 pAdapter->mvSataAdapter.adapterId, channelIndex);
+        scsi_block_requests(pAdapter->host[channelIndex]->scsihost);
+    }
+    else
+    {
+        pAdapter->host[channelIndex]->hostBlocked = MV_FALSE;
+    }
+}
+
+/****************************************************************
+ *  Name: mv_ial_unblock_requests
+ *
+ *  Description:    Unblocks request from SCSI mid layer for non connected
+ *                  channels or channels whose initialization is finished
+ *
+ *  Parameters:     pAdapter -  pointer to the IAL adapter data structure.
+ *                  channelIndex -  channel number
+ *
+ *  Returns:        None.
+ *
+ ****************************************************************/
+static void mv_ial_unblock_requests(struct IALAdapter *pAdapter, MV_U8 channelIndex)
+{
+    if ((CHANNEL_NOT_CONNECTED == pAdapter->ialCommonExt.channelState[channelIndex]) ||
+        (CHANNEL_READY == pAdapter->ialCommonExt.channelState[channelIndex]))
+    {
+        pAdapter->host[channelIndex]->hostBlocked = MV_FALSE;
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: unblocking SCSI host.\n",
+                 pAdapter->mvSataAdapter.adapterId, channelIndex);
+        scsi_unblock_requests(pAdapter->host[channelIndex]->scsihost);
+    }
+}
+
+
+
+
+/****************************************************************
+ *  Name: mv_ial_lib_event_notify
+ *
+ *  Description:    this function called by the low  level to notify a certain event
+ *
+ *  Parameters:     pMvSataAdapter, pointer to the Device data structure.
+ *
+ *  Returns:        MV_TRUE on success, MV_FALSE on failure.
+ *
+ ****************************************************************/
+MV_BOOLEAN mv_ial_lib_event_notify(MV_SATA_ADAPTER *pMvSataAdapter, MV_EVENT_TYPE eventType,
+                                   MV_U32 param1, MV_U32 param2)
+{
+    IAL_ADAPTER_T   *pAdapter = pMvSataAdapter->IALData;
+    MV_U8   channel = param2;
+
+    switch (eventType)
+    {
+    case MV_EVENT_TYPE_SATA_CABLE:
+        {
+
+
+            if (param1 == MV_SATA_CABLE_EVENT_CONNECT)
+            {
+
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: device connected event received\n",
+                         pMvSataAdapter->adapterId, channel);
+                mvRestartChannel(&pAdapter->ialCommonExt, channel,
+                                 pAdapter->ataScsiAdapterExt, MV_FALSE);
+                mv_ial_block_requests(pAdapter, channel);
+            }
+            else if (param1 == MV_SATA_CABLE_EVENT_DISCONNECT)
+            {
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: device disconnected event received \n",
+                         pMvSataAdapter->adapterId, channel);
+                if (mvSataIsStorageDeviceConnected(pMvSataAdapter, channel) ==
+                    MV_FALSE)
+                {
+                    mvStopChannel(&pAdapter->ialCommonExt, channel,
+                                  pAdapter->ataScsiAdapterExt);
+                }
+                else
+                {
+                    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG, "[%d,%d]: device disconnected event ignored.\n",
+                             pMvSataAdapter->adapterId, channel);
+                }
+
+            }
+            else if (param1 == MV_SATA_CABLE_EVENT_PM_HOT_PLUG)
+            {
+                mvPMHotPlugDetected(&pAdapter->ialCommonExt, channel,
+                                    pAdapter->ataScsiAdapterExt);
+                mv_ial_block_requests(pAdapter, channel);
+            }
+            else
+            {
+
+                mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "illegal value for param1(%d) at "
+                         "connect/disconect event, host=%d\n", param1,
+                         pMvSataAdapter->adapterId );
+            }
+        }
+        break;
+    case MV_EVENT_TYPE_ADAPTER_ERROR:
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR, "DEVICE error event received, pci cause "
+                 "reg=%x, don't know how to handle this\n", param1);
+        return MV_TRUE;
+    case MV_EVENT_TYPE_SATA_ERROR:
+        switch (param1)
+        {
+            case MV_SATA_RECOVERABLE_COMMUNICATION_ERROR:
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,
+                     " [%d %d] sata recoverable error occured\n",
+                     pMvSataAdapter->adapterId, channel);
+            break;
+            case MV_SATA_UNRECOVERABLE_COMMUNICATION_ERROR:
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,
+                     " [%d %d] sata unrecoverable error occured, restart channel\n",
+                     pMvSataAdapter->adapterId, channel);
+                mvSataChannelHardReset(pMvSataAdapter, channel);
+                mvRestartChannel(&pAdapter->ialCommonExt, channel,
+                                pAdapter->ataScsiAdapterExt, MV_TRUE);
+                mv_ial_block_requests(pAdapter, channel);
+                break;
+            case MV_SATA_DEVICE_ERROR:
+                mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,
+                     " [%d %d] device error occured\n",
+                     pMvSataAdapter->adapterId, channel);
+                break;
+        }
+        break;
+    default:
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG_ERROR,  " adapter %d unknown event %d"
+                 " param1= %x param2 = %x\n", pMvSataAdapter->adapterId,
+                 eventType - MV_EVENT_TYPE_ADAPTER_ERROR, param1, param2);
+        return MV_FALSE;
+
+    }/*switch*/
+    return MV_TRUE;
+}
+
+MV_BOOLEAN IALConfigQueuingMode(MV_SATA_ADAPTER *pSataAdapter,
+                                MV_U8 channelIndex,
+                                MV_EDMA_MODE mode,
+                                MV_U8 queueDepth)
+
+{
+    IAL_ADAPTER_T   *pAdapter = pSataAdapter->IALData;
+    if (mode != MV_EDMA_MODE_NOT_QUEUED)
+    {
+        if (queueDepth > MV_SATA_SW_QUEUE_SIZE)
+        {
+            pAdapter->host[channelIndex]->queueDepth =
+                                MV_SATA_SW_QUEUE_SIZE;
+        }
+        else
+        {
+            pAdapter->host[channelIndex]->queueDepth = queueDepth;
+        }
+    }
+    else
+    {
+        pAdapter->host[channelIndex]->queueDepth = MV_DEFAULT_QUEUE_DEPTH;
+    }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG,   "[%d %d]: software queue depth = %d\n",
+                pSataAdapter->adapterId, channelIndex,
+                pAdapter->host[channelIndex]->queueDepth);
+#endif
+    if (mvSataConfigEdmaMode(pSataAdapter, channelIndex,
+                                 mode, queueDepth) == MV_FALSE)
+    {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d %d]: mvSataConfigEdmaMode failed\n",
+                     pSataAdapter->adapterId, channelIndex);
+            return -1;
+    }
+    return MV_TRUE;
+}
+
+MV_BOOLEAN IALInitChannel(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex)
+{
+    if (mv_ial_lib_init_channel(pSataAdapter->IALData, channelIndex) == 0)
+    {
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+void IALReleaseChannel(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex)
+{
+    mv_ial_lib_free_channel(pSataAdapter->IALData, channelIndex);
+}
+
+void IALChannelCommandsQueueFlushed(MV_SATA_ADAPTER *pSataAdapter, MV_U8 channelIndex)
+{
+
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+static void channel_rescan(void *data)
+{
+    struct rescan_wrapper* rescan = (struct rescan_wrapper*)data;
+    struct Scsi_Host *host;
+    struct scsi_device *sdev = NULL;
+    MV_U16 target;
+    if (rescan->pAdapter->host[rescan->channelIndex] == NULL)
+    {
+        kfree(rescan);
+        return;
+    }
+    host = rescan->pAdapter->host[rescan->channelIndex]->scsihost;
+    down(&rescan->pAdapter->rescan_mutex);
+    if (atomic_read(&rescan->pAdapter->stopped) > 0)
+    {
+        up(&rescan->pAdapter->rescan_mutex);
+        kfree(rescan);
+        return;
+    }
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "[%d %d] channel_rescan(): "
+             "targets to add 0x%X, targets to remove 0x%X\n",
+                                rescan->pAdapter->mvSataAdapter.adapterId,
+                                rescan->channelIndex,
+                                rescan->targetsToRemove,
+                                rescan->targetsToAdd);
+
+    for (target = 0; (rescan->targetsToRemove != 0) && (target < host->max_id); target++)
+    {
+        if (rescan->targetsToRemove & (1 << target))
+        {
+            sdev = scsi_device_lookup(host, 0, target, 0);
+            if (sdev != NULL)
+            {
+                scsi_device_cancel(sdev, 0);
+                scsi_remove_device(sdev);
+                scsi_device_put(sdev);
+            }
+        }
+    }
+    sdev = NULL;
+    for (target = 0; (rescan->targetsToAdd != 0) && (target < host->max_id); target++)
+    {
+        if (rescan->targetsToAdd & (1 << target))
+        {
+            sdev = scsi_add_device(host, 0, target, 0);
+            if (NULL == sdev)
+            {
+                mvLogMsg(MV_IAL_LOG_ID,
+                MV_DEBUG_ERROR,
+                "[%d %d %d] Error adding scsi device\n",
+                         rescan->pAdapter->mvSataAdapter.adapterId,
+                         rescan->channelIndex,
+                         target);
+            }
+        }
+    }
+    up(&rescan->pAdapter->rescan_mutex);
+    kfree(rescan);
+}
+#endif
+
+MV_BOOLEAN IALBusChangeNotify(MV_SATA_ADAPTER *pSataAdapter,
+                              MV_U8 channelIndex)
+{
+    return MV_TRUE;
+}
+
+MV_BOOLEAN IALBusChangeNotifyEx(MV_SATA_ADAPTER *pSataAdapter,
+                              MV_U8 channelIndex,
+                              MV_U16 targetsToRemove,
+                              MV_U16 targetsToAdd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    IAL_ADAPTER_T   *pAdapter = pSataAdapter->IALData;
+    if (0 == atomic_read(&pAdapter->stopped))
+    {
+        struct rescan_wrapper* rescan =
+            kmalloc(sizeof(struct rescan_wrapper), GFP_ATOMIC);
+        if (rescan != NULL)
+        {
+            INIT_WORK(&rescan->work, channel_rescan, (void *)rescan);
+            rescan->pAdapter = pAdapter;
+            rescan->channelIndex = channelIndex;
+            rescan->targetsToRemove = targetsToRemove;
+            rescan->targetsToAdd = targetsToAdd;
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,
+                 "[%d %d] Rescan bus: remove 0x%X, add 0x%X.\n",
+                 pSataAdapter->adapterId,
+                 channelIndex, targetsToRemove, targetsToAdd);
+            if (schedule_work(&rescan->work) == 0)
+            {
+                    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,
+                     "[%d %d] Rescan bus: schedule_work() failed.\n",
+                     pSataAdapter->adapterId,
+                     channelIndex);
+                kfree(rescan);
+            }
+        }
+        else
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,
+                 "[%d %d] Rescan bus: memory allocation error.\n",
+                 pSataAdapter->adapterId,
+                 channelIndex);
+        }
+   }
+#endif
+   return MV_TRUE;
+}
+
+
+void asyncStartTimerFunction(unsigned long data)
+{
+    IAL_ADAPTER_T   *pAdapter = (IAL_ADAPTER_T *)data;
+    unsigned long       flags;
+    struct scsi_cmnd *cmnds_done_list = NULL;
+    MV_U8 i;
+
+    spin_lock_irqsave(&pAdapter->adapter_lock, flags);
+    if (pAdapter->stopAsyncTimer == MV_FALSE)
+    {
+        mvIALTimerCallback(&pAdapter->ialCommonExt,
+                           pAdapter->ataScsiAdapterExt);
+        for (i = 0; i < pAdapter->maxHosts; i++)
+        {
+            if (MV_TRUE == pAdapter->host[i]->hostBlocked)
+            {
+                spin_unlock_irqrestore(&pAdapter->adapter_lock, flags);
+                mv_ial_unblock_requests(pAdapter, i);
+                spin_lock_irqsave(&pAdapter->adapter_lock, flags);
+            }
+        }
+        pAdapter->asyncStartTimer.expires = jiffies + MV_LINUX_ASYNC_TIMER_PERIOD;
+        add_timer (&pAdapter->asyncStartTimer);
+    }
+    else
+    {
+        mvLogMsg(MV_IAL_LOG_ID,  MV_DEBUG,   "[%d]: Async timer stopped\n",
+                 pAdapter->mvSataAdapter.adapterId);
+    }
+    spin_unlock_irqrestore(&pAdapter->adapter_lock, flags);
+    /* Check if there are commands in the done queue to be completed */
+    for (i = 0; i < pAdapter->maxHosts; i++)
+    {
+        spin_lock_irqsave(&pAdapter->adapter_lock, flags);
+        cmnds_done_list = mv_ial_lib_get_first_cmnd(pAdapter, i);
+        spin_unlock_irqrestore(&pAdapter->adapter_lock, flags);
+        if (cmnds_done_list)
+        {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+            spin_lock_irqsave(&io_request_lock, flags);
+#else
+            spin_lock_irqsave(pAdapter->host[i]->scsihost->host_lock, flags);
+#endif
+            mv_ial_lib_do_done(cmnds_done_list);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+            spin_unlock_irqrestore(&io_request_lock, flags);
+#else
+            spin_unlock_irqrestore(pAdapter->host[i]->scsihost->host_lock, flags);
+#endif
+        }
+    }
+}
+
+/****************************************************************
+ *  Name: release_ata_mem
+ *
+ *  Description:   free memory allocated to the PRD table
+ *          unmap the data buffers of the scsi command
+ *          free completion_info data structure.
+ *  Parameters:     pInfo: pointer to the data structure returned by the
+ *          completion call back function to identify the origial command
+ *
+ ****************************************************************/
+void release_ata_mem(struct mv_comp_info * pInfo)
+{
+    IAL_ADAPTER_T   *pAdapter = MV_IAL_ADAPTER(pInfo->SCpnt->device->host);
+    IAL_HOST_T      *pHost = HOSTDATA(pInfo->SCpnt->device->host);
+    if (pInfo->cpu_PRDpnt)
+    {
+        mv_ial_lib_prd_free(pHost,
+                            pInfo->allocated_entries,
+                            pInfo->dma_PRDpnt,
+                            pInfo->cpu_PRDpnt);
+
+        if (pInfo->SCpnt->use_sg)
+        {
+            pci64_unmap_sg(pAdapter->pcidev,
+                           (struct scatterlist *)pInfo->SCpnt->request_buffer,
+                           pInfo->SCpnt->use_sg,
+                           scsi_to_pci_dma_dir(pInfo->SCpnt->sc_data_direction));
+        }
+        else
+        {
+            pci64_unmap_page(pAdapter->pcidev,
+                             pInfo->single_buff_busaddr,
+                             pInfo->SCpnt->request_bufflen,
+                 scsi_to_pci_dma_dir(pInfo->SCpnt->sc_data_direction));
+        }
+    }
+    pInfo->cpu_PRDpnt = NULL;
+    kfree(pInfo->pSALBlock);
+}
+
+int mv_ial_lib_allocate_edma_queues(IAL_ADAPTER_T *pAdapter)
+{
+    ulong *tmp;
+    ulong   requests_array_size;
+    ulong   responses_array_size;
+
+    requests_array_size = (pAdapter->maxHosts + 1) * (MV_EDMA_REQUEST_QUEUE_SIZE);
+    responses_array_size =(pAdapter->maxHosts + 1) * (MV_EDMA_RESPONSE_QUEUE_SIZE);
+
+    pAdapter->requestsArrayBaseAddr =
+    pci_alloc_consistent(pAdapter->pcidev,
+                         requests_array_size,
+                         &(pAdapter->requestsArrayBaseDmaAddr));
+    if (pAdapter->requestsArrayBaseAddr == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: Failed to allocate memory for EDMA request"
+                 " queues\n", pAdapter->mvSataAdapter.adapterId);
+        return -1;
+    }
+    pAdapter->requestsArrayBaseAlignedAddr = pAdapter->requestsArrayBaseAddr +
+                                             MV_EDMA_REQUEST_QUEUE_SIZE;
+    tmp = (ulong*)&pAdapter->requestsArrayBaseAlignedAddr;
+    *tmp &= ~(MV_EDMA_REQUEST_QUEUE_SIZE - 1);
+
+    pAdapter->requestsArrayBaseDmaAlignedAddr =
+    pAdapter->requestsArrayBaseDmaAddr + MV_EDMA_REQUEST_QUEUE_SIZE;
+    pAdapter->requestsArrayBaseDmaAlignedAddr &=
+    ~(MV_EDMA_REQUEST_QUEUE_SIZE - 1);
+
+    if ((pAdapter->requestsArrayBaseDmaAlignedAddr - pAdapter->requestsArrayBaseDmaAddr) !=
+        (pAdapter->requestsArrayBaseAlignedAddr - pAdapter->requestsArrayBaseAddr))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: Error in Request Queues Alignment\n",
+                 pAdapter->mvSataAdapter.adapterId
+                );
+        pci_free_consistent(pAdapter->pcidev, requests_array_size,
+                            pAdapter->requestsArrayBaseAddr,
+                            pAdapter->requestsArrayBaseDmaAddr);
+        return -1;
+    }
+/* response queues */
+    pAdapter->responsesArrayBaseAddr =
+    pci_alloc_consistent(pAdapter->pcidev,
+                         responses_array_size,
+                         &(pAdapter->responsesArrayBaseDmaAddr));
+    if (pAdapter->responsesArrayBaseAddr == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: Failed to allocate memory for EDMA response"
+                 " queues\n", pAdapter->mvSataAdapter.adapterId);
+        pci_free_consistent(pAdapter->pcidev, requests_array_size,
+                            pAdapter->requestsArrayBaseAddr,
+                            pAdapter->requestsArrayBaseDmaAddr);
+        return -1;
+    }
+    pAdapter->responsesArrayBaseAlignedAddr = pAdapter->responsesArrayBaseAddr
+                                              + MV_EDMA_RESPONSE_QUEUE_SIZE;
+    tmp = (ulong*)&pAdapter->responsesArrayBaseAlignedAddr;
+    *tmp &= ~(MV_EDMA_RESPONSE_QUEUE_SIZE - 1);
+
+    pAdapter->responsesArrayBaseDmaAlignedAddr =
+    pAdapter->responsesArrayBaseDmaAddr + MV_EDMA_RESPONSE_QUEUE_SIZE;
+    pAdapter->responsesArrayBaseDmaAlignedAddr &=
+    ~(MV_EDMA_RESPONSE_QUEUE_SIZE - 1);
+
+
+    if ((pAdapter->responsesArrayBaseDmaAlignedAddr - pAdapter->responsesArrayBaseDmaAddr) !=
+        (pAdapter->responsesArrayBaseAlignedAddr - pAdapter->responsesArrayBaseAddr))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "[%d]: Error in Response Quueues Alignment\n",
+                 pAdapter->mvSataAdapter.adapterId);
+        pci_free_consistent(pAdapter->pcidev, responses_array_size,
+                            pAdapter->responsesArrayBaseAddr,
+                            pAdapter->responsesArrayBaseDmaAddr);
+        pci_free_consistent(pAdapter->pcidev, requests_array_size,
+                            pAdapter->requestsArrayBaseAddr,
+                            pAdapter->requestsArrayBaseDmaAddr);
+        return -1;
+    }
+    return 0;
+}
+
+void mv_ial_lib_free_edma_queues(IAL_ADAPTER_T *pAdapter)
+{
+    pci_free_consistent(pAdapter->pcidev,
+                        (pAdapter->maxHosts + 1) * (MV_EDMA_RESPONSE_QUEUE_SIZE),
+                        pAdapter->responsesArrayBaseAddr,
+                        pAdapter->responsesArrayBaseDmaAddr);
+    pci_free_consistent(pAdapter->pcidev,
+                        (pAdapter->maxHosts + 1) * (MV_EDMA_REQUEST_QUEUE_SIZE),
+                        pAdapter->requestsArrayBaseAddr,
+                        pAdapter->requestsArrayBaseDmaAddr);
+}
+
+MV_BOOLEAN IALCompletion(struct mvSataAdapter *pSataAdapter,
+                         MV_SATA_SCSI_CMD_BLOCK *pCmdBlock)
+{
+    struct scsi_cmnd   *SCpnt = (struct scsi_cmnd *)pCmdBlock->IALData;
+    struct mv_comp_info *pInfo = ( struct mv_comp_info *) &(SCpnt->SCp);
+    MV_U8       host_status;
+
+
+    switch (pCmdBlock->ScsiCommandCompletion)
+    {
+    case MV_SCSI_COMPLETION_SUCCESS:
+        host_status = DID_OK;
+        break;
+    case MV_SCSI_COMPLETION_BAD_SCSI_COMMAND:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with BAD_SCSI_COMMAND\n");
+        host_status = DID_OK;
+        break;
+    case MV_SCSI_COMPLETION_ATA_FAILED:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with ATA FAILED\n");
+        host_status = DID_OK;
+        break;
+    case MV_SCSI_COMPLETION_UA_RESET:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with UA BUS"
+                 " RESET\n");
+        scsi_report_bus_reset(pInfo->SCpnt->device->host, pInfo->SCpnt->device->channel);
+        host_status = DID_OK;
+        break;
+    case MV_SCSI_COMPLETION_UA_PARAMS_CHANGED:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with UA "
+                 "PARAMETERS CHANGED\n");
+        scsi_report_bus_reset(pInfo->SCpnt->device->host, pInfo->SCpnt->device->channel);
+        host_status = DID_OK;
+        break;
+
+    case MV_SCSI_COMPLETION_QUEUE_FULL:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with QUEUE FULL\n");
+        /* flushed from ial common*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+        if (pCmdBlock->ScsiStatus == MV_SCSI_STATUS_BUSY)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Host status: DID_RESET\n");
+            host_status = DID_RESET;
+
+            pInfo->SCpnt->flags |= IS_RESETTING;
+        }
+        else
+#endif
+        {
+            host_status = DID_OK;
+        }
+        break;
+
+    case MV_SCSI_COMPLETION_ABORTED:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with ABORTED\n");
+        host_status = DID_ERROR;
+        break;
+
+    case MV_SCSI_COMPLETION_OVERRUN:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with OVERRUN\n");
+        if (pInfo->SCpnt->underflow > pCmdBlock->dataTransfered)
+        {
+            host_status = DID_ERROR;
+        }
+        else
+        {
+            host_status = DID_OK;
+        }
+        break;
+    case MV_SCSI_COMPLETION_UNDERRUN:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with UNDERRUN\n");
+        host_status = DID_ERROR;
+        break;
+
+    case MV_SCSI_COMPLETION_PARITY_ERROR:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Scsi command completed with PARITY ERROR\n");
+        host_status = DID_PARITY;
+        break;
+    case MV_SCSI_COMPLETION_INVALID_BUS:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with INVALID BUS\n");
+        host_status = DID_BAD_TARGET;
+        break;
+    case MV_SCSI_COMPLETION_NO_DEVICE:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "Scsi command completed with NO DEVICE\n");
+        host_status = DID_NO_CONNECT;
+        break;
+    case MV_SCSI_COMPLETION_INVALID_STATUS:
+    case MV_SCSI_COMPLETION_BAD_SCB:
+    case MV_SCSI_COMPLETION_NOT_READY:
+    case MV_SCSI_COMPLETION_DISCONNECT:
+    case MV_SCSI_COMPLETION_BUS_RESET:
+    case MV_SCSI_COMPLETION_BUSY:
+    default:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR,"Bad Scsi completion status %d\n",
+                 pCmdBlock->ScsiCommandCompletion);
+        host_status = DID_ERROR;
+
+    }
+    if ((pCmdBlock->senseDataLength == 0) && (pCmdBlock->senseBufferLength))
+    {
+        pCmdBlock->pSenseBuffer[0] = 0;
+    }
+    pInfo->SCpnt->result = host_status << 16 | (pCmdBlock->ScsiStatus & 0x3f);
+    {
+        MV_U8   channelIndex = pCmdBlock->bus;
+    release_ata_mem(pInfo);
+        mv_ial_lib_add_done_queue (pSataAdapter->IALData, channelIndex, SCpnt);
+    }
+    return MV_TRUE;
+}
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalLib.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalLib.h
@@ -0,0 +1,107 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvLinuxIalLib - Header File for Linux IAL Lib.
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+#ifndef __INCmvLinuxIalLibh
+#define __INCmvLinuxIalLibh
+
+#include "mvLinuxIalHt.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION (2,4,23)
+#define irqreturn_t         void
+#define IRQ_RETVAL(foo)
+#endif
+#define MV_LINUX_ASYNC_TIMER_PERIOD       ((MV_IAL_ASYNC_TIMER_PERIOD * HZ) / 1000)
+
+struct pci_dev;
+struct IALAdapter;
+struct IALHost;
+
+
+/* Adapter Initialization */
+int mv_ial_lib_allocate_edma_queues(struct IALAdapter *pAdapter);
+
+void mv_ial_lib_free_edma_queues(struct IALAdapter *pAdapter);
+
+int mv_ial_lib_init_channel(struct IALAdapter *pAdapter, MV_U8 channelNum);
+
+void mv_ial_lib_free_channel(struct IALAdapter *pAdapter, MV_U8 channelNum);
+
+
+/* PRD Table Generation */
+#define MV_PRD_TABLE_SIZE                   64 /* 64 entries max in PRD table */
+
+
+int mv_ial_lib_prd_destroy(struct IALHost *pHost);
+int mv_ial_lib_prd_init(struct IALHost *);
+
+
+
+int mv_ial_lib_generate_prd(MV_SATA_ADAPTER *pMvSataAdapter, struct scsi_cmnd *SCpnt,
+                            MV_SATA_EDMA_PRD_ENTRY **ppPRD_table,
+                            dma_addr_t *pPRD_dma_address,
+                            unsigned int *pPrd_size, dma_addr_t *pBusaddr);
+
+
+/* Interrupt Service Routine*/
+irqreturn_t mv_ial_lib_int_handler (int irq, void *dev_id, struct pt_regs *regs);
+
+
+/* Event Notification */
+MV_BOOLEAN mv_ial_lib_udma_command_completion_call_back(MV_SATA_ADAPTER *pMvSataAdapter,
+                                           MV_U8 channelNum,
+                                           MV_COMPLETION_TYPE comp_type,
+                                           void *commandId,
+                                           MV_U16 responseFlags,
+                                           MV_U32 timeStamp,
+                                           MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+MV_BOOLEAN mv_ial_lib_event_notify(MV_SATA_ADAPTER *pMvSataAdapter, MV_EVENT_TYPE eventType,
+                             MV_U32 param1, MV_U32 param2);
+void asyncStartTimerFunction(unsigned long data);
+
+/* SCSI done queuing and callback */
+void mv_ial_lib_add_done_queue (struct IALAdapter *pAdapter,
+                                MV_U8 channel,
+                                struct scsi_cmnd   *scsi_cmnd);
+
+struct scsi_cmnd * mv_ial_lib_get_first_cmnd (struct IALAdapter *pAdapter,
+                                       MV_U8 channel);
+
+void mv_ial_lib_do_done (struct scsi_cmnd *cmnd);
+
+void mv_ial_block_requests(struct IALAdapter *pAdapter, MV_U8 channelIndex);
+
+#endif /* __INCmvLinuxIalLibh */
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalOs.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalOs.c
@@ -0,0 +1,53 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxOs.c
+*
+* DESCRIPTION:  implementation for Linux Os layer
+*
+*
+* DEPENDENCIES:
+*   mvLinuxOs.h
+*   Linux header files.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+/* Includes */
+#include "mvOs.h"
+
+void mvMicroSecondsDelay(MV_VOID_PTR pSataAdapter, MV_U32 usecs)
+{
+    MV_U32 msecs = usecs / 1000;
+    MV_U32 i;
+    MV_U32 tmp = usecs % 1000;
+    for (i = 0; i < msecs; i++)
+    {
+        udelay(1000);
+    }
+    if (tmp > 0)
+        udelay(tmp);
+}
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalSmart.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalSmart.c
@@ -0,0 +1,347 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxIALSmart.c
+*
+* DESCRIPTION: C file for S.M.A.R.T. features - smartmontools app
+*
+* DEPENDENCIES:
+*   None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/kdev_t.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <asm/dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#else
+#include <linux/blk.h>
+#include "scsi.h"
+#include "hosts.h"
+#endif
+#include "mvScsiAtaLayer.h"
+#include "mvLinuxIalHt.h"
+#include "mvRegs.h"
+#include "mvIALCommon.h"
+#include "mvLinuxIalSmart.h"
+
+
+extern MV_VOID handleNoneUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                   MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+extern MV_VOID handleUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                               MV_U32 responseFlags,
+                               MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+extern MV_VOID  checkQueueCommandResult(MV_SATA_SCSI_CMD_BLOCK *pScb,
+                                        MV_QUEUE_COMMAND_RESULT result);
+
+extern MV_VOID setSenseData(IN MV_SATA_SCSI_CMD_BLOCK *pScb, IN MV_U8 SenseKey,
+                            IN MV_U8 AdditionalSenseCode);
+
+static MV_BOOLEAN
+SmartCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                         MV_U8 channelNum,
+                         MV_COMPLETION_TYPE comp_type,
+                         MV_VOID_PTR commandId,
+                         MV_U16 responseFlags,
+                         MV_U32 timeStamp,
+                         MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+
+MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendSmartCommand(IN  MV_SATA_ADAPTER* pSataAdapter,
+                                                       IN  MV_SATA_SCSI_CMD_BLOCK *pScb)
+{
+    MV_U8 *buff = (MV_U8*)pScb->pDataBuffer;
+    MV_NON_UDMA_PROTOCOL protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+    MV_QUEUE_COMMAND_RESULT result = MV_QUEUE_COMMAND_RESULT_OK;
+    MV_QUEUE_COMMAND_INFO   qCommandInfo;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "SMART command: command received, bufflen = %d.\n",
+             pScb->dataBufferLength);
+    pScb->dataTransfered = 0;
+    pScb->senseDataLength = 0;
+    if (pScb->bus >= pSataAdapter->numberOfChannels)
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_INVALID_BUS;
+        pScb->dataTransfered = 0;
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if ((pScb->target >= MV_SATA_PM_MAX_PORTS) ||
+        (pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target].driveReady == MV_FALSE))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_NO_DEVICE;
+        pScb->dataTransfered = 0;
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if (pScb->dataBufferLength <= 6 || /*six byte opcode*/
+        (buff[SMART_BUF_COMMAND_OFFSET] != WIN_IDENTIFY &&
+         buff[SMART_BUF_COMMAND_OFFSET] != WIN_SMART))
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "invalid SMART command received");
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                     SCSI_ADSENSE_NO_SENSE);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if (buff[SMART_BUF_COMMAND_OFFSET] == WIN_IDENTIFY)
+    {
+        if (pScb->dataBufferLength < MV_ATA_IDENTIFY_DEV_DATA_LENGTH*2 + 6)
+        {
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "WIN_IDENTIFY: "
+                     "invalid buffer length.%d\n", pScb->dataBufferLength);
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_NO_SENSE);
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+        protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_IN;
+        buff[SMART_BUF_COMMAND_OFFSET] = MV_ATA_COMMAND_IDENTIFY;
+        buff[SMART_BUF_SECTORCOUNT_OFFSET] = 0;
+        buff[SMART_BUF_LBALOW_OFFSET] = 0;
+        buff[SMART_BUF_LBAMID_OFFSET] = 0;
+        buff[SMART_BUF_LBAHIGH_OFFSET] = 0;
+        buff[SMART_BUF_FEATURES_OFFSET] = 0;
+    }
+    else
+    {
+        buff[SMART_BUF_LBAMID_OFFSET] = 0x4F;
+        buff[SMART_BUF_LBAHIGH_OFFSET] = 0xC2;
+        switch (buff[SMART_BUF_FEATURES_OFFSET])
+        {
+        case SMART_READ_VALUES:
+        case SMART_READ_THRESHOLDS:
+        case SMART_READ_LOG_SECTOR:
+            if (pScb->dataBufferLength < ATA_SECTOR_SIZE + 6)
+            {
+                setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                             SCSI_ADSENSE_NO_SENSE);
+                pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+                pScb->ScsiCommandCompletion =
+                MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+                pScb->completionCallBack(pSataAdapter, pScb);
+                return MV_SCSI_COMMAND_STATUS_COMPLETED;
+            }
+            protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_IN;
+            break;
+        case SMART_ENABLE:
+        case SMART_DISABLE:
+        case SMART_AUTO_OFFLINE:
+        case SMART_AUTOSAVE:
+        case SMART_IMMEDIATE_OFFLINE:
+        case SMART_STATUS:
+            protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+            break;
+        default:
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_NO_SENSE);
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+    }
+    qCommandInfo.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    qCommandInfo.commandParams.NoneUdmaCommand.protocolType = protocolType;
+    qCommandInfo.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    qCommandInfo.PMPort = pScb->target;
+    if (protocolType == MV_NON_UDMA_PROTOCOL_NON_DATA)
+    {
+        qCommandInfo.commandParams.NoneUdmaCommand.bufPtr = NULL;
+        qCommandInfo.commandParams.NoneUdmaCommand.count = 0;
+    }
+    else
+    {
+        qCommandInfo.commandParams.NoneUdmaCommand.bufPtr =
+        (MV_U16_PTR)&buff[6];
+        qCommandInfo.commandParams.NoneUdmaCommand.count =
+        (MV_U32)(ATA_SECTOR_SIZE/2);
+        /*in words*/
+    }
+    qCommandInfo.commandParams.NoneUdmaCommand.features =
+    (MV_U16)buff[SMART_BUF_FEATURES_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.sectorCount =
+    (MV_U16)buff[SMART_BUF_SECTORCOUNT_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.lbaLow =
+    (MV_U16)buff[SMART_BUF_LBALOW_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.lbaMid =
+    (MV_U16)buff[SMART_BUF_LBAMID_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.lbaHigh =
+    (MV_U16)buff[SMART_BUF_LBAHIGH_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+    qCommandInfo.commandParams.NoneUdmaCommand.command =
+    buff[SMART_BUF_COMMAND_OFFSET];
+    qCommandInfo.commandParams.NoneUdmaCommand.callBack =
+    SmartCommandCompletionCB;
+    qCommandInfo.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, &qCommandInfo);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    pDriveData->stats.totalIOs++;
+
+    mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "SMART command: SMART command %02X, queued\n",
+             buff[SMART_BUF_FEATURES_OFFSET]);
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+
+static void SmartFillReturnBuffer(IN MV_U8* buff,
+                                  IN MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+
+    /*For PIO non-data return registers' values*/
+    if (buff[SMART_BUF_COMMAND_OFFSET] == WIN_SMART &&
+        buff[SMART_BUF_FEATURES_OFFSET] != SMART_READ_VALUES &&
+        buff[SMART_BUF_FEATURES_OFFSET] != SMART_READ_THRESHOLDS &&
+        buff[SMART_BUF_FEATURES_OFFSET] != SMART_READ_LOG_SECTOR)
+    {
+        buff[6+SMART_BUF_COMMAND_OFFSET] =
+        buff[SMART_BUF_COMMAND_OFFSET];
+        buff[6+SMART_BUF_FEATURES_OFFSET] =
+        buff[SMART_BUF_FEATURES_OFFSET];
+        buff[6+SMART_BUF_LBALOW_OFFSET] =
+        registerStruct->lbaLowRegister & 0xFF;
+        buff[6+SMART_BUF_SECTORCOUNT_OFFSET] =
+        registerStruct->sectorCountRegister & 0xFF;
+        buff[6+SMART_BUF_LBAMID_OFFSET] =
+        registerStruct->lbaMidRegister & 0xFF;
+        buff[6+SMART_BUF_LBAHIGH_OFFSET] =
+        registerStruct->lbaHighRegister & 0xFF;
+        buff[6+SMART_BUF_DEVICE_OFFSET] =
+        registerStruct->deviceRegister & 0xFF;
+        buff[6+SMART_BUF_ERROR_OFFSET] =
+        registerStruct->errorRegister & 0xFF;
+    }
+}
+
+static MV_BOOLEAN
+SmartCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                         MV_U8 channelNum,
+                         MV_COMPLETION_TYPE comp_type,
+                         MV_VOID_PTR commandId,
+                         MV_U16 responseFlags,
+                         MV_U32 timeStamp,
+                         MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_SATA_SCSI_CMD_BLOCK  *pScb;
+
+    if (commandId == NULL)
+    {
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, " commandId is NULL, can't hanlde this !!!,adapterId=%d,"
+                 " channel=%d \n", pSataAdapter->adapterId, channelNum);
+        return MV_FALSE;
+    }
+
+    pScb = commandId;
+    switch (comp_type)
+    {
+    case MV_COMPLETION_TYPE_NORMAL:
+        if (pScb->ScsiCdb[0] == SCSI_OPCODE_MVSATA_SMART)
+        {
+            SmartFillReturnBuffer(pScb->pDataBuffer, registerStruct);
+            mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "SMART PIO command completed: "
+                     "dev=%04X, Low=%04X, Mid=%04X, High=%04X, "
+                     "SC=%04X, status = %04X,\n",
+                     registerStruct->deviceRegister,
+                     registerStruct->lbaLowRegister,
+                     registerStruct->lbaMidRegister,
+                     registerStruct->lbaHighRegister,
+                     registerStruct->sectorCountRegister,
+                     registerStruct->statusRegister);
+        }
+        pScb->dataTransfered = MV_ATA_IDENTIFY_DEV_DATA_LENGTH*2;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "command completed. pScb %p\n", pScb);
+        break;
+    case MV_COMPLETION_TYPE_ABORT:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, " command Aborted. Cdb: %02x %02x %02x %02x %02x "
+                 "%02x %02x %02x %02x %02x\n", pScb->ScsiCdb[0],
+                 pScb->ScsiCdb[1], pScb->ScsiCdb[2], pScb->ScsiCdb[3],
+                 pScb->ScsiCdb[4], pScb->ScsiCdb[5], pScb->ScsiCdb[6],
+                 pScb->ScsiCdb[7], pScb->ScsiCdb[8], pScb->ScsiCdb[9]);
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_ABORTED;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+        break;
+    case MV_COMPLETION_TYPE_ERROR:
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_ATA_FAILED;
+
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, " completion error, adapter =%d, channel=%d, flags=%x\n"
+                 ,pSataAdapter->adapterId, channelNum, responseFlags);
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Failed command Cdb: %02x %02x %02x %02x %02x "
+                 "%02x %02x %02x %02x %02x\n", pScb->ScsiCdb[0],
+                 pScb->ScsiCdb[1], pScb->ScsiCdb[2], pScb->ScsiCdb[3],
+                 pScb->ScsiCdb[4], pScb->ScsiCdb[5], pScb->ScsiCdb[6],
+                 pScb->ScsiCdb[7], pScb->ScsiCdb[8], pScb->ScsiCdb[9]);
+        /* here the  eDMA will be stopped, so we have to flush  */
+        /* the pending commands                                 */
+        handleNoneUdmaError(pScb, registerStruct);
+        break;
+    default:
+        mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG_ERROR, "Unknown completion type (%d)\n", comp_type);
+        return MV_FALSE;
+    }
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_TRUE;
+}
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalSmart.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLinuxIalSmart.h
@@ -0,0 +1,107 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* file_name - mvLinuxIALSmart.h
+*
+* DESCRIPTION: C header file for S.M.A.R.T. features - smartmontools app
+*
+*
+* DEPENDENCIES:
+*
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*
+*******************************************************************************/
+#ifndef __INCmvScsiSmart
+#define __INCmvScsiSmart
+
+/*Proprietary opcode to support smartmontools app*/
+#define SCSI_OPCODE_MVSATA_SMART            0x0C
+
+
+/*S.M.A.R.T ATA commands used*/
+#ifndef WIN_IDENTIFY
+#define WIN_IDENTIFY                        0xEC
+#endif
+#ifndef WIN_SMART
+#define WIN_SMART                           0xB0
+#endif
+#ifndef SMART_READ_VALUES
+#define SMART_READ_VALUES                   0xD0
+#endif
+#ifndef SMART_READ_THRESHOLDS
+#define SMART_READ_THRESHOLDS               0xD1
+#endif
+#ifndef SMART_AUTOSAVE
+#define SMART_AUTOSAVE                      0xD2
+#endif
+#ifndef SMART_SAVE
+#define SMART_SAVE                          0xD3
+#endif
+#ifndef SMART_IMMEDIATE_OFFLINE
+#define SMART_IMMEDIATE_OFFLINE             0xD4
+#endif
+#ifndef SMART_READ_LOG_SECTOR
+#define SMART_READ_LOG_SECTOR               0xD5
+#endif
+#ifndef SMART_WRITE_LOG_SECTOR
+#define SMART_WRITE_LOG_SECTOR              0xD6
+#endif
+/* The following is obsolete -- don't use it!*/
+#ifndef SMART_WRITE_THRESHOLDS
+#define SMART_WRITE_THRESHOLDS              0xD7
+#endif
+#ifndef SMART_ENABLE
+#define SMART_ENABLE                        0xD8
+#endif
+#ifndef SMART_DISABLE
+#define SMART_DISABLE                       0xD9
+#endif
+#ifndef SMART_STATUS
+#define SMART_STATUS                        0xDA
+#endif
+
+/* The following is also marked obsolete in ATA-5*/
+#ifndef SMART_AUTO_OFFLINE
+#define SMART_AUTO_OFFLINE                  0xDB
+#endif
+
+/*Definitions of S.M.A.R.T. command buffer offsets*/
+#define SMART_BUF_COMMAND_OFFSET                0
+#define SMART_BUF_LBALOW_OFFSET                 1
+#define SMART_BUF_FEATURES_OFFSET               2
+#define SMART_BUF_SECTORCOUNT_OFFSET            3
+#define SMART_BUF_LBAMID_OFFSET                 4
+#define SMART_BUF_LBAHIGH_OFFSET                5
+#define SMART_BUF_DEVICE_OFFSET                 6
+#define SMART_BUF_ERROR_OFFSET                  7
+
+
+MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendSmartCommand
+                (IN  MV_SATA_ADAPTER* pSataAdapter,
+                 IN  MV_SATA_SCSI_CMD_BLOCK *pScb);
+
+
+#endif
Index: linux-2.6.10/drivers/scsi/mvsata/mvLog.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLog.c
@@ -0,0 +1,153 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvLog - C File for implementation of the core driver logger
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+#include "mvOs.h"
+
+
+
+#if defined (MV_LOG_DEBUG) || defined (MV_LOG_ERROR)
+
+char* mvLogMsgType[MV_MAX_MESSAGE_TYPE] = {
+    " (FATAL_ERROR) ",
+    " (ERROR) ",
+    " (DEBUG INIT) ",
+    " (DEBUG_INTERRUPTS) ",
+    " (DEBUG SATA LINK) ",
+    " (DEBUG UDMA COMMAND) ",
+    " (DEBUG NON UDMA COMMAND) ",
+    " (DEBUG_PM) ",
+    " (DEBUG) ",
+};
+
+static MV_LOG_FILTER_HEADER mvLogInstance[MV_MAX_LOG_MODULES] =
+{
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+    {MV_FALSE, 0, NULL},
+};
+
+static char szMessageBuffer[1024];
+
+
+MV_BOOLEAN mvLogRegisterModule(MV_U8 moduleId, MV_U32 filterMask, char* name)
+{
+    if (moduleId >= MV_MAX_LOG_MODULES)
+    {
+        return MV_FALSE;
+    }
+    if (mvLogInstance[moduleId].used == MV_TRUE)
+    {
+        return MV_FALSE;
+    }
+    if (name == NULL)
+    {
+        return MV_FALSE;
+    }
+    mvLogInstance[moduleId].filterMask = filterMask;
+    mvLogInstance[moduleId].name = name;
+    mvLogInstance[moduleId].used = MV_TRUE;
+    return MV_TRUE;
+}
+
+MV_BOOLEAN mvLogSetModuleFilter(MV_U8 moduleId, MV_U32 filterMask)
+{
+    if (moduleId >= MV_MAX_LOG_MODULES)
+    {
+        return MV_FALSE;
+    }
+    if (mvLogInstance[moduleId].used == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+    mvLogInstance[moduleId].filterMask = filterMask;
+    return MV_TRUE;
+}
+
+
+MV_U32 mvLogGetModuleFilter(MV_U8 moduleId)
+{
+    if (moduleId >= MV_MAX_LOG_MODULES)
+    {
+        return 0;
+    }
+    if (mvLogInstance[moduleId].used == MV_FALSE)
+    {
+        return 0;
+    }
+    return mvLogInstance[moduleId].filterMask;
+}
+
+void mvLogMsg(MV_U8 moduleId, MV_U32 type, char* format, ...)
+{
+    int len;
+    va_list args;
+
+    if (moduleId >= MV_MAX_LOG_MODULES)
+    {
+        return;
+    }
+    if ((moduleId != MV_RAW_MSG_ID) &&
+        ((mvLogInstance[moduleId].used == MV_FALSE) ||
+         ((mvLogInstance[moduleId].filterMask & type) == 0)))
+    {
+        return;
+    }
+    if ((moduleId != MV_RAW_MSG_ID) && (type & 0x1ff))
+    {
+        MV_U8 msgType = 0;
+        /* find least significant 1*/
+        while (msgType < MV_MAX_MESSAGE_TYPE)
+        {
+            if (type & ( 1 << msgType))
+            {
+                break;
+            }
+            msgType++;
+        }
+        len = sprintf(szMessageBuffer, "%s%s",
+                      mvLogInstance[moduleId].name, mvLogMsgType[msgType]);
+    }
+    else
+    {
+        len = 0;
+    }
+    va_start(args, format);
+    vsprintf(&szMessageBuffer[len], format, args);
+    va_end(args);
+    MV_LOG_PRINT(szMessageBuffer);
+}
+#endif
Index: linux-2.6.10/drivers/scsi/mvsata/mvLog.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvLog.h
@@ -0,0 +1,124 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvLog.h - Header File for CORE driver logger
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+#ifndef __INCmvLogh
+#define __INCmvLogh
+
+#ifdef __cplusplus
+extern "C" /*{*/
+#endif /* __cplusplus */
+
+/*-------------H file-----------------------------*/
+#define MV_DEBUG_FATAL_ERROR                    0x01
+#define MV_DEBUG_ERROR                          0x02
+#define MV_DEBUG_INIT                           0x04
+#define MV_DEBUG_INTERRUPTS                     0x08
+#define MV_DEBUG_SATA_LINK                      0x10
+#define MV_DEBUG_UDMA_COMMAND                   0x20
+#define MV_DEBUG_NON_UDMA_COMMAND               0x40
+#define MV_DEBUG_PM                             0x80
+#define MV_DEBUG                                0x100
+
+
+
+#define MV_MAX_LOG_MODULES         16
+#define MV_MAX_MESSAGE_TYPE        9
+#define MV_RAW_MSG_ID              0xF
+
+typedef struct
+{
+    MV_BOOLEAN      used;
+    MV_U32          filterMask;
+    char            *name;
+    char            *filters;
+} MV_LOG_FILTER_HEADER;
+
+
+#if defined (MV_LOG_DEBUG) || defined (MV_LOG_ERROR)
+    #define MV_LOGGER       1
+    #if defined (WIN32)
+ULONG
+_cdecl
+DbgPrint(
+        PCH Format,
+        ...
+        );
+        #define MV_LOG_PRINT    DbgPrint
+    #elif defined (LINUX)
+        #define MV_LOG_PRINT    printk
+    #else
+        #define MV_LOG_PRINT	printf
+    #endif
+
+
+MV_BOOLEAN mvLogRegisterModule(MV_U8 moduleId, MV_U32 filterMask, char* name);
+MV_BOOLEAN mvLogSetModuleFilter(MV_U8 moduleId, MV_U32 filterMask);
+MV_U32 mvLogGetModuleFilter(MV_U8 moduleId);
+void mvLogMsg(MV_U8 moduleId, MV_U32 type, char* format, ...);
+
+#else /*defined (MV_LOG_DEBUG) || defined (MV_LOG_ERROR)*/
+
+    #undef MV_LOGGER
+
+    #if defined (WIN32)
+        #define MV_LOG_PRINT
+        #define mvLogRegisterModule
+        #define mvLogGetModuleFilter
+        #define mvLogRegisterAllModules
+        #define mvLogMsg
+
+    #elif defined (LINUX)
+        #define MV_LOG_PRINT(x...)
+        #define mvLogRegisterModule(x...)
+        #define mvLogSetModuleFilter(x...)
+        #define mvLogGetModuleFilter(x...)
+        #define mvLogRegisterAllModules(x...)
+        #define mvLogMsg(x...)
+
+    #else
+        #define MV_LOG_PRINT
+        #define mvLogRegisterModule
+        #define mvLogSetModuleFilter
+        #define mvLogGetModuleFilter
+        #define mvLogRegisterAllModules
+        #define mvLogMsg
+    #endif
+
+#endif /*!defined (MV_LOG_DEBUG) && !defined (MV_LOG_ERROR)*/
+
+#ifdef __cplusplus
+
+/*}*/
+#endif /* __cplusplus */
+
+#endif
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvOs.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvOs.h
@@ -0,0 +1,132 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvOsLinux.h - O.S. interface header file for Linux
+*
+* DESCRIPTION:
+*       This header file contains OS dependent definition under Linux
+*
+* DEPENDENCIES:
+*       Linux kernel header files.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*******************************************************************************/
+
+#ifndef __INCmvOsLinuxh
+#define __INCmvOsLinuxh
+
+/* Includes */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/pci.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+/* Definitions */
+
+#define MV_DEFAULT_QUEUE_DEPTH 2
+/* System dependent macro for flushing CPU write cache */
+#define MV_CPU_WRITE_BUFFER_FLUSH()     wmb()
+
+/* System dependent little endian from / to CPU conversions */
+#define MV_CPU_TO_LE16(x)   cpu_to_le16(x)
+#define MV_CPU_TO_LE32(x)   cpu_to_le32(x)
+
+#define MV_LE16_TO_CPU(x)   le16_to_cpu(x)
+#define MV_LE32_TO_CPU(x)   le32_to_cpu(x)
+
+/* System dependent register read / write in byte/word/dword variants */
+#define MV_REG_WRITE_BYTE(base, offset, val)    writeb(val, base + offset)
+#define MV_REG_WRITE_WORD(base, offset, val)    writew(val, base + offset)
+#define MV_REG_WRITE_DWORD(base, offset, val)   writel(val, base + offset)
+#define MV_REG_READ_BYTE(base, offset)          readb(base + offset)
+#define MV_REG_READ_WORD(base, offset)          readw(base + offset)
+#define MV_REG_READ_DWORD(base, offset)         readl(base + offset)
+
+
+/* Typedefs    */
+typedef enum mvBoolean{MV_FALSE, MV_TRUE} MV_BOOLEAN;
+
+/* System dependant typedefs */
+typedef void            MV_VOID;
+typedef u32             MV_U32;
+typedef u16             MV_U16;
+typedef u8              MV_U8;
+typedef void            *MV_VOID_PTR;
+typedef u32             *MV_U32_PTR;
+typedef u16             *MV_U16_PTR;
+typedef u8              *MV_U8_PTR;
+typedef char            *MV_CHAR_PTR;
+typedef void            *MV_BUS_ADDR_T;
+typedef unsigned long   MV_CPU_FLAGS;
+
+
+/* Structures  */
+/* System dependent structure */
+typedef struct mvOsSemaphore
+{
+  int notUsed;
+} MV_OS_SEMAPHORE;
+
+
+/* Functions (User implemented)*/
+
+/* Semaphore init, take and release */
+#define mvOsSemInit(x) MV_TRUE
+#define mvOsSemTake(x)
+#define mvOsSemRelease(x)
+
+/* Interrupt masking and unmasking functions */
+MV_CPU_FLAGS mvOsSaveFlagsAndMaskCPUInterrupts(MV_VOID);
+MV_VOID      mvOsRestoreFlags(MV_CPU_FLAGS);
+
+/* Delay function in micro seconds resolution */
+void mvMicroSecondsDelay(MV_VOID_PTR, MV_U32);
+
+/* System logging function */
+#include "mvLog.h"
+/* Enable READ/WRITE Long SCSI command only when driver is compiled for debugging */
+#ifdef MV_LOGGER
+#define MV_SATA_SUPPORT_READ_WRITE_LONG
+#endif
+
+#define MV_IAL_LOG_ID       3
+
+#endif /* __INCmvOsLinuxh */
Index: linux-2.6.10/drivers/scsi/mvsata/mvOsLinux.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvOsLinux.h
@@ -0,0 +1,132 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvOsLinux.h - O.S. interface header file for Linux
+*
+* DESCRIPTION:
+*       This header file contains OS dependent definition under Linux
+*
+* DEPENDENCIES:
+*       Linux kernel header files.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1.1 $
+*******************************************************************************/
+
+#ifndef __INCmvOsLinuxh
+#define __INCmvOsLinuxh
+
+/* Includes */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/genhd.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/pci.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+/* Definitions */
+
+#define MV_DEFAULT_QUEUE_DEPTH 2
+/* System dependent macro for flushing CPU write cache */
+#define MV_CPU_WRITE_BUFFER_FLUSH()     wmb()
+
+/* System dependent little endian from / to CPU conversions */
+#define MV_CPU_TO_LE16(x)   cpu_to_le16(x)
+#define MV_CPU_TO_LE32(x)   cpu_to_le32(x)
+
+#define MV_LE16_TO_CPU(x)   le16_to_cpu(x)
+#define MV_LE32_TO_CPU(x)   le32_to_cpu(x)
+
+/* System dependent register read / write in byte/word/dword variants */
+#define MV_REG_WRITE_BYTE(base, offset, val)    writeb(val, base + offset)
+#define MV_REG_WRITE_WORD(base, offset, val)    writew(val, base + offset)
+#define MV_REG_WRITE_DWORD(base, offset, val)   writel(val, base + offset)
+#define MV_REG_READ_BYTE(base, offset)          readb(base + offset)
+#define MV_REG_READ_WORD(base, offset)          readw(base + offset)
+#define MV_REG_READ_DWORD(base, offset)         readl(base + offset)
+
+
+/* Typedefs    */
+typedef enum mvBoolean{MV_FALSE, MV_TRUE} MV_BOOLEAN;
+
+/* System dependant typedefs */
+typedef void            MV_VOID;
+typedef u32             MV_U32;
+typedef u16             MV_U16;
+typedef u8              MV_U8;
+typedef void            *MV_VOID_PTR;
+typedef u32             *MV_U32_PTR;
+typedef u16             *MV_U16_PTR;
+typedef u8              *MV_U8_PTR;
+typedef char            *MV_CHAR_PTR;
+typedef void            *MV_BUS_ADDR_T;
+typedef unsigned long   MV_CPU_FLAGS;
+
+
+/* Structures  */
+/* System dependent structure */
+typedef struct mvOsSemaphore
+{
+  int notUsed;
+} MV_OS_SEMAPHORE;
+
+
+/* Functions (User implemented)*/
+
+/* Semaphore init, take and release */
+#define mvOsSemInit(x) MV_TRUE
+#define mvOsSemTake(x)
+#define mvOsSemRelease(x)
+
+/* Interrupt masking and unmasking functions */
+MV_CPU_FLAGS mvOsSaveFlagsAndMaskCPUInterrupts(MV_VOID);
+MV_VOID      mvOsRestoreFlags(MV_CPU_FLAGS);
+
+/* Delay function in micro seconds resolution */
+void mvMicroSecondsDelay(MV_VOID_PTR, MV_U32);
+
+/* System logging function */
+#include "mvLog.h"
+/* Enable READ/WRITE Long SCSI command only when driver is compiled for debugging */
+#ifdef MV_LOGGER
+#define MV_SATA_SUPPORT_READ_WRITE_LONG
+#endif
+
+#define MV_IAL_LOG_ID       3
+
+#endif /* __INCmvOsLinuxh */
Index: linux-2.6.10/drivers/scsi/mvsata/mvRegs.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvRegs.h
@@ -0,0 +1,348 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvRegs.h - Header file that includes the regs addresses
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvRegs
+#define __INCmvRegs
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* General Definitions */
+#define MV_BIT0                                 0x00000001
+#define MV_BIT1                                 0x00000002
+#define MV_BIT2                                 0x00000004
+#define MV_BIT3                                 0x00000008
+#define MV_BIT4                                 0x00000010
+#define MV_BIT5                                 0x00000020
+#define MV_BIT6                                 0x00000040
+#define MV_BIT7                                 0x00000080
+#define MV_BIT8                                 0x00000100
+#define MV_BIT9                                 0x00000200
+#define MV_BIT10                                0x00000400
+#define MV_BIT11                                0x00000800
+#define MV_BIT12                                0x00001000
+#define MV_BIT13                                0x00002000
+#define MV_BIT14                                0x00004000
+#define MV_BIT15                                0x00008000
+#define MV_BIT16                                0x00010000
+#define MV_BIT17                                0x00020000
+#define MV_BIT18                                0x00040000
+#define MV_BIT19                                0x00080000
+#define MV_BIT20                                0x00100000
+#define MV_BIT21                                0x00200000
+#define MV_BIT22                                0x00400000
+#define MV_BIT23                                0x00800000
+#define MV_BIT24                                0x01000000
+#define MV_BIT25                                0x02000000
+#define MV_BIT26                                0x04000000
+#define MV_BIT27                                0x08000000
+#define MV_BIT28                                0x10000000
+#define MV_BIT29                                0x20000000
+#define MV_BIT30                                0x40000000
+#define MV_BIT31                                0x80000000
+
+
+#define MV_PCI_REGS_OFFSET                      0x0
+
+/* PCI registers */
+
+#define MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET      0x1d60
+
+#define MV_MAIN_INTERRUPT_MASK_REG_OFFSET       0x1d64
+#define MV_MAIN_INTERRUPT_MASK_REG_ALL_BITS     0x7ffff
+#define MV_MAIN_INTERRUPT_MASK_REG_PCIERR_BIT   MV_BIT18
+#define MV_MAIN_INTERRUPT_HOST_SELF_INT_BIT     MV_BIT23
+
+#define MV_PCI_CONTROL_REG_OFFSET               0x1d68
+#define MV_PCI_CONTROL_REG_H2H_INT_BIT          MV_BIT1
+
+/* enable ports error, coalescing done and pci error*/
+#define MV_MAIN_INTERRUPT_MASK_ENABLE_ALL       0x6ab55
+
+#define MV_PCI_DLL_STATUS_CONTROL_REG_OFFSET    0x1d20
+#define MV_PCI_COMMAND_REG_OFFSET               0xc00
+#define MV_PCI_COMMAND_REG_DEFAULT              0x0107E371
+#define MV_PCI_COMMAND_PCI_CONVENTIONAL_ONLY            \
+    (MV_BIT5|MV_BIT6|MV_BIT7|MV_BIT8|MV_BIT9|MV_BIT31)
+#define MV_PCI_MWRITE_COMBINE_BIT               MV_BIT4
+#define MV_PCI_MREAD_COMBINE_BIT                MV_BIT5
+
+#define MV_PCI_MODE_REG_OFFSET                  0xd00
+#define MV_PCI_MODE_MASK                        0x30
+#define MV_PCI_MODE_OFFSET                      4
+
+#define MV_PCI_DISCARD_TIMER_REG_OFFSET         0xd04
+
+#define MV_PCI_MSI_TRIGGER_REG_OFFSET           0xc38
+
+#define MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET 0xd2c
+
+#define MV_PCI_XBAR_IF_TIMEOUT_REG_OFFSET       0x1d04
+
+#define MV_PCI_SERR_MASK_REG_OFFSET             0xc28
+#define MV_PCI_SERR_MASK_REG_ENABLE_ALL         0xd77fe6
+
+#define MV_PCI_INTERRUPT_CAUSE_REG_OFFSET       0x1d58
+
+#define MV_PCI_INTERRUPT_MASK_REG_OFFSET        0x1d5c
+
+#define MV_PCI_INTERRUPT_MASK_REG_ENABLE_ALL    MV_PCI_SERR_MASK_REG_ENABLE_ALL
+
+#define MV_PCI_ERROR_LOW_ADDRESS_REG_OFFSET     0x1d40
+
+#define MV_PCI_ERROR_HIGH_ADDRESS_REG_OFFSET    0x1d44
+
+#define MV_PCI_ERROR_ATTRIBUTE_REG_OFFSET       0x1d48
+
+#define MV_PCI_ERROR_COMMAND_REG_OFFSET         0x1d50
+
+#define MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET   0xd30 /*Relevant for 60x1 only*/
+#define MV_PCI_MAIN_COMMAND_DIS_CORE_CLK_MASK   MV_BIT0
+#define MV_PCI_MAIN_COMMAND_DIS_SHC1_CLK_MASK   MV_BIT0
+#define MV_PCI_MAIN_COMMAND_STOP_MASTER_MASK    MV_BIT2
+#define MV_PCI_MAIN_COMMAND_MASTER_EMPTY_MASK   MV_BIT3
+#define MV_PCI_MAIN_COMMAND_GLOBAL_RESET_MASK   MV_BIT4
+
+/* Flash interface registers */
+#define MV_FLASH_PARAMS_REG_OFFSET              0x1046c
+
+#define MV_FLASH_GPIO_PORT_CONTROL_OFFSET       0x104f0
+
+#define MV_RESET_CONFIG_REG_OFFSET              0x180d8
+#define MV_RESET_CONFIG_TWSI_INIT_MASK          MV_BIT0
+#define MV_SATA_II_ALL_PORTS_INT_COAL_CMND_THR_REG_OFFSET 0x180cc
+
+#define MV_SATA_II_ALL_PORTS_INT_COAL_TIME_THR_REG_OFFSET 0x180d0
+
+#define MV_SATA_II_ALL_PORTS_INT_CAUSE_REG_OFFSET 0x18008
+
+/* SATAHC registers*/
+#define MV_SATAHC_0_REGS_BASE_OFFSET            0x20000 /* 128KByte offset */
+
+#define MV_SATAHC_1_REGS_BASE_OFFSET            0x30000 /* 192KByte offset */
+
+#define MV_SATAHC_REGS_BASE_OFFSET(unit)        ((unit)?(MV_SATAHC_1_REGS_BASE_OFFSET):(MV_SATAHC_0_REGS_BASE_OFFSET))
+
+#define MV_SATAHC_XBAR_CONF_REG_OFFSET          0x000
+
+#define MV_SATAHC_RESPONSE_Q_IN_POINTER_OFFSET  0x008
+
+#define MV_SATAHC_INT_COAL_THRE_REG_OFFSET      0x00c
+
+#define MV_SATAHC_INT_TIME_THRE_REG_OFFSET      0x010
+
+#define MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET    0x014
+
+#define MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET    0x018
+#define MV_SATA_I_TEST_CONTROL_PATTERN_MASK         0x7
+#define MV_SATA_I_TEST_CONTROL_PATTERN_OFFSET           10
+#define MV_SATA_I_TEST_CONTROL_PORT_MASK                0x3
+#define MV_SATA_I_TEST_CONTROL_PORT_OFFSET              13
+#define MV_SATA_I_TEST_CONTROL_PHY_SHUTDOWN_MASK(port)  ((MV_U32)1 << (24 + (port)))
+
+#define MV_SATA_I_HC_BRIDGES_TEST_STATUS_REG_OFFSET 0x01c
+#define MV_SATA_I_TEST_STATUS_LOOPBACK_PASS_BIT     MV_BIT8
+
+#define MV_SATA_I_HC_BRIDGES_PINS_CONFIG_REG_OFFSET 0x020
+
+#define MV_SATA_I_HC_R00_STATUS_BRIDGE_PORT_OFFSET(port)        \
+    (0x100 + (port)*0x100)
+
+#define MV_SATA_I_HC_R00_STATUS_BRIDGE_DET_OFFSET  0x0
+#define MV_SATA_I_HC_R00_STATUS_BRIDGE_DET_MASK 0xf
+
+#define MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port)    \
+    (0x108 + (port)*0x100)
+
+#define MV_SATA_I_HC_PHY_CONTROL_BRIDGE_PORT_OFFSET(port)   \
+    (0x10C + (port)*0x100)
+
+#define MV_SATA_I_HC_R04_STATUS_BRIDGE_PORT_OFFSET(port)    \
+    (0x110 + (port)*0x100)
+#define MV_SATA_I_HC_R05_STATUS_BRIDGE_PORT_OFFSET(port)    \
+    (0x114 + (port)*0x100)
+#define MV_SATA_I_HC_R06_STATUS_BRIDGE_PORT_OFFSET(port)    \
+    (0x118 + (port)*0x100)
+#define MV_SATA_I_HC_R0F_STATUS_BRIDGE_PORT_OFFSET(port)    \
+    (0x13c + (port)*0x100)
+#define MV_SATA_I_HC_LT_MODES_PORT_REG_OFFSET(port)         \
+    (0x130 + ((port) * 0x100))
+#define MV_SATA_I_HC_PHY_MODE_BRIDGE_PORT_REG_OFFSET(port)  \
+    (0x174 + ((port) * 0x100))
+#define MV_SATA_I_PHY_MODE_AMP_MASK             0xe0
+#define MV_SATA_I_PHY_MODE_AMP_OFFSET               5
+#define MV_SATA_I_PHY_MODE_PRE_MASK             0x1800
+#define MV_SATA_I_PHY_MODE_PRE_OFFSET               11
+
+#define MV_SATA_II_PHY_MODE_1_REG_OFFSET        0x32c
+
+#define MV_SATA_II_PHY_MODE_2_REG_OFFSET        0x330
+#define MV_SATA_II_PHY_MODE_2_AMP_MASK          0x700
+#define MV_SATA_II_PHY_MODE_2_AMP_OFFSET        8
+#define MV_SATA_II_PHY_MODE_2_PRE_MASK          0xe0
+#define MV_SATA_II_PHY_MODE_2_PRE_OFFSET        5
+
+#define MV_SATA_II_PHY_MODE_4_REG_OFFSET        0x314
+
+#define MV_SATA_II_IF_CONTROL_REG_OFFSET        0x344
+#define MV_SATA_II_IF_CONTROL_PMTX_OFFSET       0
+#define MV_SATA_II_IF_CONTROL_PMTX_MASK         0xf
+
+#define MV_SATA_II_IF_TEST_CTRL_REG_OFFSET		0x348
+
+#define MV_SATA_II_IF_STATUS_REG_OFFSET         0x34c
+#define MV_SATA_II_IF_STATUS_VUQ_DONE_MASK      MV_BIT12
+#define MV_SATA_II_IF_STATUS_VUQ_ERR_MASK       MV_BIT13
+#define MV_SATA_II_IF_STATUS_FSM_STATUS_MASK    0x3f000000
+
+
+#define MV_SATA_II_VENDOR_UQ_REG_OFFSET         0x35c
+
+#define MV_SATA_II_S_STATUS_REG_OFFSET          0x300
+
+#define MV_SATA_II_S_ERROR_REG_OFFSET           0x304
+
+#define MV_SATA_II_S_CONTROL_REG_OFFSET         0x308
+
+#define MV_SATA_II_SATA_CONFIG_REG_OFFSET       0x50
+
+/* EDMA registers */
+
+#define MV_EDMA_PORT_BASE_OFFSET(port)          ( 0x2000UL * ((port) + 1))
+
+#define MV_EDMA_CONFIG_REG_OFFSET               0x000
+#define MV_EDMA_CONFIG_Q_DEPTH_MASK             0x1f
+#define MV_EDMA_CONFIG_NATIVE_QUEUING_MASK      MV_BIT5 /* Relevant for 60x1 */
+#define MV_EDMA_CONFIG_BURST_SIZE_MASK          MV_BIT8
+#define MV_EDMA_CONFIG_EQUEUE_ENABLED_MASK      MV_BIT9
+#define MV_EDMA_CONFIG_STOP_ON_ERROR_MASK       MV_BIT10
+#define MV_EDMA_CONFIG_BURST_SIZE_EXT_MASK      MV_BIT11
+#define MV_EDMA_CONFIG_CONONDEVERR_MASK			MV_BIT14
+
+#define MV_EDMA_TIMER_REG_OFFSET                0x004
+
+#define MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET 0x008
+
+#define MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET  0x00c
+
+/* unrecoverable EDMA errors*/
+#define MV_EDMA_GEN_I_UNRECOVERABLE_EDMA_ERROR		0x00001E63
+#define MV_EDMA_GEN_I_RECOVERABLE_EDMA_ERROR		0x00000000
+#define MV_EDMA_GEN_I_ERROR_MASK					0x00001118
+
+#define MV_EDMA_GEN_II_UNRECOVERABLE_EDMA_ERROR		0xFC1E9E03
+#define MV_EDMA_GEN_II_RECOVERABLE_EDMA_ERROR		0x03E16020
+#define MV_EDMA_GEN_II_NORMAL_RCVRBL_EDMA_ERROR		0x02200000
+
+/*don't enable rcvrbl errors that occur too often*/
+#define MV_EDMA_GEN_II_ERROR_MASK					0xFDDFF198
+
+
+#define MV_EDMA_REQUEST_Q_BAH_REG_OFFSET        0x010
+
+#define MV_EDMA_REQUEST_Q_INP_REG_OFFSET        0x014
+#define MV_EDMA_REQUEST_Q_INP_MASK              0x000003e0
+#define MV_EDMA_REQUEST_Q_INP_OFFSET            5
+#define MV_EDMA_REQUEST_Q_BA_MASK               0xfffffc00
+
+#define MV_EDMA_REQUEST_Q_OUTP_REG_OFFSET       0x018
+#define MV_EDMA_REQUEST_Q_OUTP_MASK             0x000003e0
+
+#define MV_EDMA_RESPONSE_Q_BAH_REG_OFFSET       0x01c
+
+#define MV_EDMA_RESPONSE_Q_INP_REG_OFFSET       0x020
+#define MV_EDMA_RESPONSE_Q_INP_MASK             0x000000f8
+
+#define MV_EDMA_RESPONSE_Q_OUTP_REG_OFFSET      0x024
+#define MV_EDMA_RESPONSE_Q_OUTP_MASK            0x000000f8
+#define MV_EDMA_RESPONSE_Q_OUTP_OFFSET          3
+
+#define MV_EDMA_RESPONSE_Q_BA_MASK              0xffffff00
+
+
+#define MV_EDMA_COMMAND_REG_OFFSET              0x028
+#define MV_EDMA_COMMAND_ENABLE_MASK             MV_BIT0
+#define MV_EDMA_COMMAND_DISABLE_MASK            MV_BIT1
+#define MV_EDMA_COMMAND_HARD_RST_MASK           MV_BIT2
+
+#define MV_EDMA_TEST_CONTROL_REG_OFFSET         0x02c
+#define MV_EDMA_LOOPBACK_MODE_BIT               MV_BIT1
+
+#define MV_EDMA_STATUS_REG_OFFSET               0x030
+#define MV_EDMA_STATUS_TAG_MASK                 0x1f
+#define MV_EDMA_STATUS_TAG_OFFSET               0
+
+#define MV_EDMA_IORDY_TIMEOUT_REG_OFFSET        0x034
+
+#define MV_EDMA_ARBITER_CNFG_REG_OFFSET         0x038
+#define MV_EDMA_NO_SNOOP_BIT                    MV_BIT6
+
+#define MV_EDMA_CMD_DELAY_THRE_REG_OFFSET       0x040
+
+
+/* C2C */
+/* BM DMA */
+#define MV_BMDMA_COMMAND_OFFSET                 0x224
+#define MV_BMDMA_STATUS_OFFSET                  0x228
+#define MV_BMDMA_PRD_TABLE_LOW_ADDRESS_OFFSET   0x22c
+#define MV_BMDMA_PRD_TABLE_HIGH_ADDRESS_OFFSET  0x230
+
+/* storage device registers*/
+
+#define MV_ATA_DEVICE_PIO_DATA_REG_OFFSET       0x100
+#define MV_ATA_DEVICE_FEATURES_REG_OFFSET       0x104
+#define MV_ATA_DEVICE_ERROR_REG_OFFSET          MV_ATA_DEVICE_FEATURES_REG_OFFSET
+#define MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET   0x108
+#define MV_ATA_DEVICE_LBA_LOW_REG_OFFSET        0x10c
+#define MV_ATA_DEVICE_LBA_MID_REG_OFFSET        0x110
+#define MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET       0x114
+#define MV_ATA_DEVICE_HEAD_REG_OFFSET           0x118
+#define MV_ATA_DEVICE_COMMAND_REG_OFFSET        0x11c
+#define MV_ATA_DEVICE_STATUS_REG_OFFSET         MV_ATA_DEVICE_COMMAND_REG_OFFSET
+#define MV_ATA_DEVICE_CONTROL_REG_OFFSET        0x120
+#define MV_ATA_DEVICE_ALTERNATE_REG_OFFSET      MV_ATA_DEVICE_CONTROL_REG_OFFSET
+
+#define MV_IOG_TRANS_LOW_BIT      (MV_BIT19)
+#define MV_IOG_TRANS_HIGH_BIT     (MV_BIT20)
+#define MV_IOG_TRANS_INT_MASK     (MV_IOG_TRANS_LOW_BIT | MV_IOG_TRANS_HIGH_BIT)
+#define MV_IOG_TRANS_LOW_REG_OFFSET  0x18088
+#define MV_IOG_TRANS_HIGH_REG_OFFSET 0x1808C
+#define MV_IOG_TRANS_CTRL_REG_OFFSET 0x18048
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvRegs */
Index: linux-2.6.10/drivers/scsi/mvsata/mvSata.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvSata.c
@@ -0,0 +1,7813 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvSata - C File for implementation of the core driver for MV88SX50XX.
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*   mvOs.h
+*   mvSata.h.
+*   mvStorageDev.h
+*   mvRegs.h
+*
+*******************************************************************************/
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvStorageDev.h"
+#include "mvRegs.h"
+
+/* Defines */
+#define MV_SATA_PORT_PER_UNIT                   4
+
+#define MV_PHY_DET_STATE_NO_DEVICE              0
+#define MV_PHY_DET_STATE_DEVICE_NO_PHY_COM      1
+#define MV_PHY_DET_STATE_DEVICE_AND_PHY_COM     3
+#define MV_PHY_DET_STATE_PHY_OFFLINE            4
+#define MV_PHY_DET_CONTROL_START_NEGOTIATION    1
+#define MV_PHY_DET_CONTROL_SHUTDOWN             4
+#define MV_NEAR_END_LOOPBACK_TEST_WAIT_TIME     100 /* 100 uSec */
+#define MV_FAR_END_LOOPBACK_TEST_WAIT_TIME      5   /* 5 uSec */
+#define MV_PHY_COM_SETUP_WAIT                   5000 /* 5 mili seconds */
+#define MV_HARD_RESET_WAIT_ASSERT               25    /* 25 uSec */
+#define MV_HARD_RESET_WAIT_NEGATE               1000  /* 1  mSec*/
+#define MV_HARD_RESET_WAIT_READY                2000 /* ms to wait after HR*/
+/* before disk access */
+#define MV_HARD_RESET_WAIT_FOR_BUSY_LOOPS       10000
+#define MV_HARD_RESET_WAIT_FOR_BUSY_LOOP_DELAY  1000
+
+/* for the command result */
+#define MV_EDMA_REQUEST_COMMANDS_NUM            11
+
+
+/* Fix the watermark to the following default value */
+#define MV_WATER_MARK_FIX                       29 /* write 5'b11101 to bits 12:8*/
+
+extern MV_BOOLEAN waitWhileStorageDevIsBusy(MV_SATA_ADAPTER *pAdapter,
+                                            MV_BUS_ADDR_T ioBaseAddr,
+                                            MV_U32 eDmaRegsOffset, MV_U32 loops,
+                                            MV_U32 delay);
+
+extern void dumpAtaDeviceRegisters(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex, MV_BOOLEAN isEXT,
+                                   MV_STORAGE_DEVICE_REGISTERS *pRegisters);
+
+extern MV_BOOLEAN _doSoftReset(MV_SATA_CHANNEL *pSataChannel);
+
+MV_BOOLEAN isStorageDevReadyForPIO(MV_SATA_CHANNEL *pSataChannel);
+
+MV_BOOLEAN executeNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
+                                 MV_U8 channelIndex,
+                                 MV_NON_UDMA_PROTOCOL protocolType,
+                                 MV_BOOLEAN  isEXT,
+                                 MV_U16_PTR bufPtr, MV_U32 count,
+                                 MV_U16 features,
+                                 MV_U16 sectorCount,
+                                 MV_U16 lbaLow, MV_U16 lbaMid,
+                                 MV_U16 lbaHigh, MV_U8 device,
+                                 MV_U8 command);
+
+extern MV_BOOLEAN waitForDRQ(MV_SATA_ADAPTER* pAdapter,
+                             MV_BUS_ADDR_T ioBaseAddr,
+                             MV_U32 eDmaRegsOffset, MV_U32 loops,
+                             MV_U32 delay);
+
+static MV_BOOLEAN _checkSStatusAfterHReset(MV_SATA_ADAPTER* pAdapter,
+                                           MV_U8 channelIndex);
+#ifdef MV_LOGGER
+void _dumpPCIRegs(MV_SATA_ADAPTER *pAdapter);
+
+void _dumpEDMARegs(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+void _dumpChannelQueues(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+void _dumpSataRegs(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+void _printATARegs(MV_STORAGE_DEVICE_REGISTERS   *pDeviceRegs);
+
+#else
+
+    #define _dumpPCIRegs(p)
+    #define _dumpEDMARegs(p,i)
+    #define _dumpChannelQueues(p,i)
+    #define _dumpSataRegs(p,i)
+    #define _printATARegs(p)
+#endif
+
+/* write ATA command register entry in a request entry */
+#define WRITE_ATA_COMMAND_REG(addr, data, reg, isLast)              \
+do{                                                                 \
+    *(addr) = MV_CPU_TO_LE16((((MV_U8)(data)) & 0xff) | ((reg) << 8) | (isLast));   \
+} while(0)
+
+#define MV_CHANNEL_INDEX(unit, port)    (((unit) << 2) | (port))
+
+
+/* Typedefs */
+
+typedef struct mvDmaRequestQueueEntry
+{
+    /* Fields set by CORE driver */
+    volatile MV_U32       prdLowAddr;
+    volatile MV_U32       prdHighAddr;
+    volatile MV_U16       controlFlags;
+    volatile MV_U16       command[MV_EDMA_REQUEST_COMMANDS_NUM];
+
+} MV_DMA_REQUEST_QUEUE_ENTRY;
+
+typedef struct mvDmaResponseQueueEntry
+{
+    /* Fields set by  hardware */
+    volatile MV_U16 commandTag;
+    volatile MV_U16 responseFlags;
+    volatile MV_U32 timeStamp;
+} MV_DMA_RESPONSE_QUEUE_ENTRY;
+
+
+/* local functions  */
+
+/*static*/ MV_BOOLEAN waitForBusyAfterHReset(MV_SATA_ADAPTER *pAdapter,
+                                             MV_U8 channelIndex);
+
+static void unmaskEdmaInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void maskEdmaInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void writeEdmaRequestEntry(MV_DMA_REQUEST_QUEUE_ENTRY *pReqEntry,
+                                  MV_SATA_CHANNEL *mvSataChannel,
+                                  MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                                  MV_UDMA_COMMAND_PARAMS  *pUdmaParams);
+
+static void handleEdmaFailedCommand(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex, MV_U16 eDmaErrorCause);
+
+static void handleEdmaResponse(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                               MV_DMA_RESPONSE_QUEUE_ENTRY *eDmaResponse);
+
+#ifdef MV_SATA_C2C_COMM
+static void handleBmDMAInterrupt(MV_SATA_ADAPTER *pAdapter,
+                                 MV_BUS_ADDR_T   ioBaseAddr,
+                                 MV_SATA_CHANNEL *pSataChannel,
+                                 MV_U8   channelIndex,
+                                 MV_U32 edmaError);
+#endif
+
+static void handleEdmaInterrupt(MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                MV_U8 port, MV_U32 rspInPtr,MV_U32 responseDone,
+                                MV_U32 edmaError, MV_U32 unitCause);
+
+static void handleDeviceInterrupt(MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                  MV_U8 port);
+
+static void handleEdmaError(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static MV_VOID handleDisconnect(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static MV_VOID handleConnect(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static MV_BOOLEAN handleUnrecoverableError(MV_SATA_ADAPTER *pAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_U32 eDmaErrorCause);
+
+static MV_BOOLEAN handleRecoverableError(MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex,
+                                         MV_U32 eDmaErrorCause);
+
+static MV_BOOLEAN handleAsyncNotify(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_U32 eDmaErrorCause);
+
+static MV_BOOLEAN handleSelfDisable(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_U32 eDmaErrorCause);
+
+static MV_BOOLEAN handleDevErr(MV_SATA_ADAPTER *pAdapter,
+                               MV_U8 channelIndex,
+                               MV_U32 eDmaErrorCause);
+
+#ifdef MV_SATA_C2C_COMM
+static void handleC2CInterrupt(MV_SATA_CHANNEL *pSataChannel);
+#endif
+
+static void handlePIOInterrupt(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry);
+
+static MV_BOOLEAN transferPIOData(MV_SATA_CHANNEL *pSataChannel,
+                                  MV_NONE_UDMA_COMMAND_PARAMS   *pNoneUdmaCommandParams);
+
+static void completePIOCommand(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                               MV_BOOLEAN failed);
+
+static MV_BOOLEAN _resetEdmaQPointers(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_BOOLEAN resetEdmaChannel(MV_SATA_CHANNEL *pSataChannel);
+
+static void flushDmaQueue(MV_SATA_CHANNEL *pSataChannel,
+                          MV_FLUSH_TYPE flushType, MV_COMPLETION_TYPE, MV_U16);
+
+static void _fixPhyParams(MV_SATA_ADAPTER *pMvSataAdapter, MV_U8 channelIndex);
+
+static void _channelHardReset(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void _establishSataComm(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void _establishSataCommAll(MV_SATA_ADAPTER *pAdapter);
+
+void _setActivePMPort(MV_SATA_CHANNEL *pSataChannel, MV_U8 PMPort);
+
+static void revertSataHCRegs (MV_SATA_ADAPTER *pAdapter);
+
+static void revertFlashInterfaceRegs (MV_SATA_ADAPTER *pAdapter);
+
+static void revertPCIInterfaceRegs (MV_SATA_ADAPTER *pAdapter);
+
+static void commandsQueueAddTail(MV_SATA_CHANNEL *pSataChannel,
+                                 MV_QUEUED_COMMAND_ENTRY *pCommandEntry);
+
+static void commandsQueueRemove(MV_SATA_CHANNEL *pSataChannel,
+                                MV_QUEUED_COMMAND_ENTRY *pCommandEntry);
+
+static void addCommand(MV_SATA_CHANNEL *pSataChannel,
+                       MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                       MV_QUEUE_COMMAND_INFO *pCommandInfo);
+
+static void removeCommand(MV_SATA_CHANNEL *pSataChannel,
+                          MV_QUEUED_COMMAND_ENTRY *pCommandEntry);
+
+static void enableSaDevInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+void disableSaDevInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void _checkATAStatus(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void activateEdma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void deactivateEdma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+static void EdmaReqQueueInsert(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                               MV_UDMA_COMMAND_PARAMS  *pUdmaParams);
+
+static MV_BOOLEAN sendNoneUdmaCommand(MV_SATA_CHANNEL *pSataChannel,
+                                      MV_QUEUED_COMMAND_ENTRY *pCommandEntry);
+
+static MV_BOOLEAN isGoodCompletionsExpected(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_VOID updatePortsWithErrors(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_VOID enterRequestSenseState(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_BOOLEAN parseReadLogExtOutPut(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_BOOLEAN
+ReadLogExtCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                       MV_U8 channelNum,
+                       MV_COMPLETION_TYPE comp_type,
+                       MV_VOID_PTR commandId,
+                       MV_U16 responseFlags,
+                       MV_U32 timeStamp,
+                       MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+static MV_VOID setReadLogExtCmndPointers(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_VOID insertReadLogExtCmnd(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_VOID handlePortNCQError(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_VOID _insertQCommandsIntoEdma(MV_SATA_CHANNEL *pSataChannel);
+
+static MV_BOOLEAN _doDevErrorRecovery(MV_SATA_CHANNEL *pSataChannel);
+
+#ifdef MV_SATA_C2C_COMM
+
+/* Channel 2 Channel */
+static MV_BOOLEAN sendVendorUniqueFIS(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_U32 *vendorUniqueBuffer,
+                                      MV_U8 numOfDWords);
+
+static void activateBMDmaMode(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                              MV_U32 prdTableHi, MV_U32 prdTableLow,
+                              MV_UDMA_TYPE dmaType);
+#endif
+
+#ifdef MV_SATA_IO_GRANULARITY
+
+static void setIoGranularityCount(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 transId,
+                                  MV_U8 counter);
+static MV_U8 readIoGranularityCount(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 transId);
+static void iogInterrupt(MV_SATA_ADAPTER *pAdapter,
+                         MV_BUS_ADDR_T ioBaseAddr,
+                         MV_U32 mainCause);
+static void checkIogCompletion(MV_SATA_ADAPTER *pAdapter,
+                               MV_U32 iogCause, MV_U8 offset);
+static void checkIogBit(MV_SATA_ADAPTER *pAdapter,
+                        MV_U8 bitOffset,
+                        MV_U8 value);
+
+static MV_BOOLEAN iogReset(MV_SATA_ADAPTER *pAdapter);
+#endif
+
+
+/* Calculate the base address of the registers for a SATA channel */
+MV_U32 edmaRegOffst[MV_SATA_CHANNELS_NUM] = {0x22000, 0x24000, 0x26000, 0x28000,
+    0x32000, 0x34000, 0x36000, 0x38000};
+
+#define getEdmaRegOffset(x) edmaRegOffst[(x)]
+
+
+
+
+MV_BOOLEAN waitForBusyAfterHReset(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex)
+{
+    MV_U32 i;
+    MV_U8       ATAstatus;
+    mvMicroSecondsDelay(pAdapter, MV_HARD_RESET_WAIT_READY);
+    for (i = MV_HARD_RESET_WAIT_READY; i < 5000000; i+= 10000)
+    {
+        ATAstatus = MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress,
+                                     getEdmaRegOffset(channelIndex) +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+        {
+            return MV_TRUE;
+        }
+        mvMicroSecondsDelay(pAdapter, 10000);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: in Channel Hard Rese"
+             "t wait for busy, ATA STATUS=0x%02x\n", pAdapter->adapterId,
+             channelIndex, ATAstatus);
+    return MV_FALSE;
+}
+
+static void unmaskEdmaInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       getEdmaRegOffset(channelIndex) +
+                       MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET,
+                       0);
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        /* Unmask EDMA self disable (bit 8), mask errors that cause self disable */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           getEdmaRegOffset(channelIndex) +
+                           MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET,
+                           MV_EDMA_GEN_I_ERROR_MASK);
+    }
+    else
+    {
+        /* Unmask EDMA self disable (bit 7), mask errors that cause self disable */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           getEdmaRegOffset(channelIndex) +
+                           MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET,
+                           MV_EDMA_GEN_II_ERROR_MASK);
+    }
+}
+
+static void maskEdmaInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       getEdmaRegOffset(                           channelIndex)                            +
+                       MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET,
+                       0);
+}
+
+/*******************************************************************************
+* writeEdmaRequestEntry  - Write a CRQB (COMMAND REQUEST QUEUE BLOCK)
+*
+* DESCRIPTION:
+*       write one CRQB for an EDMA request queue.
+*
+* INPUT:
+*       pReqEntry     - pointer to the CRQB area on the system memory
+*                       (HW reqeust Queue).
+*       mvSataChannel - pointer to the channel data structure
+*       pCommandEntry - pointer to the command entry data structure
+*                       (SW request Queue).
+*
+* RETURN:
+*       None
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static void writeEdmaRequestEntry(MV_DMA_REQUEST_QUEUE_ENTRY *pReqEntry,
+                                  MV_SATA_CHANNEL *mvSataChannel,
+                                  MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                                  MV_UDMA_COMMAND_PARAMS  *pUdmaParams)
+{
+    MV_U16           ControlFlags = 0;
+    volatile MV_U16  *pCommand = &pReqEntry->command[0];
+    MV_U8            ATACommand = 0;
+
+    pReqEntry->prdLowAddr  = MV_CPU_TO_LE32(pUdmaParams->prdLowAddr);
+    pReqEntry->prdHighAddr = MV_CPU_TO_LE32(pUdmaParams->prdHighAddr);
+
+    /* Set the direction of the transaction (read/write) */
+    if (pUdmaParams->readWrite == MV_UDMA_TYPE_READ)
+    {
+        ControlFlags |= 0x1; /* Device to system memory */
+    }
+    ControlFlags |= (pCommandEntry->commandTag << 1);   /* the tag will be used also */
+#ifdef MV_SATA_IO_GRANULARITY
+
+    /*If valid IO Granularity transaction Id*/
+    if (pUdmaParams->iogCurrentTransId < MV_IOG_INVALID_COMMAND_ID)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_UDMA_COMMAND, "%d %d: "
+                 "Edma request with IO granularity Id = 0x%x\n",
+                 mvSataChannel->mvSataAdapter->adapterId,
+                 mvSataChannel->channelNumber, pUdmaParams->iogCurrentTransId);
+        ControlFlags |= (((MV_U16)pUdmaParams->iogCurrentTransId) << 6);
+    }
+#endif
+    /* in Non-queue EDMA mode    */
+    ControlFlags |= (pCommandEntry->commandInfo.PMPort << 12);
+
+    pReqEntry->controlFlags =  MV_CPU_TO_LE16(ControlFlags);
+
+    if ((mvSataChannel->queuedDMA == MV_EDMA_MODE_QUEUED) ||
+        (mvSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING))
+    {
+        if (pUdmaParams->isEXT == MV_TRUE) /* Read/Write DMA QUEUED EXT */
+        {
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->numOfSectors & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_FEATURES_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->numOfSectors) & 0xFF,
+                                  MV_EDMA_ATA_FEATURES_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pCommandEntry->commandTag << 3) & 0xF8,
+                                  MV_EDMA_ATA_SECTOR_COUNT_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF000000)
+                                  >> 24, MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress) & 0xFF,
+                                  MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,(pUdmaParams->highLBAAddress &
+                                              0xFF),
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->highLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF0000) >>
+                                  16, MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            if ((mvSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING) &&
+                (pUdmaParams->FUA == MV_TRUE))
+            {
+                WRITE_ATA_COMMAND_REG(pCommand++, MV_BIT7 | MV_BIT6 ,
+                                      MV_EDMA_ATA_DEVICE_ADDR,0);
+            }
+            else
+            {
+                WRITE_ATA_COMMAND_REG(pCommand++, MV_BIT6 ,
+                                      MV_EDMA_ATA_DEVICE_ADDR,0);
+            }
+
+            if (pUdmaParams->readWrite == MV_UDMA_TYPE_READ)
+            {
+                if (mvSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING)
+                {
+                    ATACommand = MV_ATA_COMMAND_READ_FPDMA_QUEUED_EXT;
+                }
+                else
+                {
+                    ATACommand = MV_ATA_COMMAND_READ_DMA_QUEUED_EXT;
+                }
+            }
+            else
+            {
+                if (mvSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING)
+                {
+                    ATACommand = MV_ATA_COMMAND_WRITE_FPDMA_QUEUED_EXT;
+                }
+                else
+                {
+                    ATACommand = MV_ATA_COMMAND_WRITE_DMA_QUEUED_EXT;
+                }
+            }
+        }
+        else /* Read/Write DMA QUEUED */
+        {
+            WRITE_ATA_COMMAND_REG(pCommand++, (pUdmaParams->numOfSectors) &
+                                  0xFF, MV_EDMA_ATA_FEATURES_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pCommandEntry->commandTag << 3) & 0xF8,
+                                  MV_EDMA_ATA_SECTOR_COUNT_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress) & 0xFF,
+                                  MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF0000)
+                                  >> 16, MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++, MV_BIT6 |
+                                  (MV_U8)((pUdmaParams->lowLBAAddress & 0xF000000)
+                                          >> 24), MV_EDMA_ATA_DEVICE_ADDR, 0);
+
+            if (pUdmaParams->readWrite == MV_UDMA_TYPE_READ)
+            {
+                ATACommand = MV_ATA_COMMAND_READ_DMA_QUEUED;
+            }
+            else
+            {
+                ATACommand = MV_ATA_COMMAND_WRITE_DMA_QUEUED;
+            }
+        }
+    }
+    else
+    {
+        if (pUdmaParams->isEXT == MV_TRUE)
+        {   /* READ/WRITE DMA EXT */
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->numOfSectors & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_SECTOR_COUNT_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->numOfSectors) & 0xFF,
+                                  MV_EDMA_ATA_SECTOR_COUNT_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF000000)
+                                  >> 24,
+                                  MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress) &0xFF,
+                                  MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->highLBAAddress & 0xFF),
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->highLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF0000)
+                                  >> 16,
+                                  MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++, MV_BIT6, MV_EDMA_ATA_DEVICE_ADDR,
+                                  0);
+
+            if (pUdmaParams->readWrite == MV_UDMA_TYPE_READ)
+            {
+                ATACommand = MV_ATA_COMMAND_READ_DMA_EXT;
+            }
+            else
+            {
+                ATACommand = MV_ATA_COMMAND_WRITE_DMA_EXT;
+            }
+        }
+        else /* READ/WRITE DMA */
+        {
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->numOfSectors) & 0xFF,
+                                  MV_EDMA_ATA_SECTOR_COUNT_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress) & 0xFF,
+                                  MV_EDMA_ATA_LBA_LOW_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF00) >> 8,
+                                  MV_EDMA_ATA_LBA_MID_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  (pUdmaParams->lowLBAAddress & 0xFF0000)
+                                  >> 16,
+                                  MV_EDMA_ATA_LBA_HIGH_ADDR, 0);
+
+            WRITE_ATA_COMMAND_REG(pCommand++,
+                                  MV_BIT6 | (MV_U8)((pUdmaParams->lowLBAAddress &
+                                                     0xF000000) >> 24),
+                                  MV_EDMA_ATA_DEVICE_ADDR, 0);
+
+            if (pUdmaParams->readWrite == MV_UDMA_TYPE_READ)
+            {
+                ATACommand = MV_ATA_COMMAND_READ_DMA;
+            }
+            else
+            {
+                ATACommand = MV_ATA_COMMAND_WRITE_DMA;
+            }
+        }
+    }
+    WRITE_ATA_COMMAND_REG(pCommand++, ATACommand, MV_EDMA_ATA_COMMAND_ADDR,
+                          MV_BIT15);
+}
+
+/*******************************************************************************
+* handleEdmaFailedCommand - Handle failed EDMA command which didn't commpleted.
+*
+* DESCRIPTION:
+*       This function handles the completion of failed EDMA command when no
+*       response received for that command.
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX50XX adapter data structure.
+*       channelIndex - The index of the channel where the response received.
+*       eDmaErrorCause - the value of the channel EDMA error cause register.
+*
+* RETURN:
+*       None
+*
+* COMMENTS:
+*       This function assumes that the channel semaphore is locked.
+*
+*******************************************************************************/
+static void handleEdmaFailedCommand(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex, MV_U16 eDmaErrorCause)
+{
+    MV_QUEUED_COMMAND_ENTRY       *pCommandEntry;
+    MV_UDMA_COMMAND_PARAMS        *pUdmaCommandParams;
+    MV_SATA_CHANNEL               *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_STORAGE_DEVICE_REGISTERS   deviceRegs;
+    MV_U32      eDmaStatus;
+    MV_U32      commandTag;
+
+    eDmaStatus = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   pSataChannel->eDmaRegsOffset +
+                                   MV_EDMA_STATUS_REG_OFFSET);
+
+    commandTag = (eDmaStatus & MV_EDMA_STATUS_TAG_MASK) >>
+                 MV_EDMA_STATUS_TAG_OFFSET;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Handle failed command,"
+             "tag 0x%02x, error cause 0x%02x\n", pAdapter->adapterId,
+             channelIndex, commandTag, eDmaErrorCause);
+
+    pCommandEntry = &(pSataChannel->commandsQueue[commandTag]);
+    if (pCommandEntry->isFreeEntry == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "%d %d: Received response on a non"
+                 "-valid tag (%x)\n", pAdapter->adapterId, channelIndex,
+                 commandTag);
+
+        _dumpSataRegs(pAdapter,channelIndex);
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, MV_TRUE, &deviceRegs);
+        _printATARegs(&deviceRegs);
+        return;
+    }
+    if (pSataChannel->PMSupported == MV_TRUE)
+    {
+        _setActivePMPort(pSataChannel, pCommandEntry->commandInfo.PMPort);
+    }
+    pUdmaCommandParams = &pCommandEntry->commandInfo.commandParams.udmaCommand;
+    dumpAtaDeviceRegisters(pAdapter, channelIndex, pUdmaCommandParams->isEXT,
+                           &deviceRegs);
+
+    pSataChannel->EdmaQueuedCommands--;
+    pUdmaCommandParams->callBack(pSataChannel->mvSataAdapter, channelIndex,
+                                 MV_COMPLETION_TYPE_ERROR,
+                                 pUdmaCommandParams->commandId, eDmaErrorCause,
+                                 0, &deviceRegs);
+    removeCommand(pSataChannel,pCommandEntry);
+}
+
+/*******************************************************************************
+* handleEdmaResponse - Handle an EDMA response queue entry.
+*
+* DESCRIPTION:
+*       This function handles the completion of EDMA command when a response
+*       entry is received.
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX50XX adapter data structure.
+*       channelIndex - The index of the channel where the response received.
+*       response     - Pointer to the received EDMA response block structure.
+*
+* RETURN:
+*       None
+*
+* COMMENTS:
+*       This function assumes that the channel semaphore is locked.
+*
+*******************************************************************************/
+static void handleEdmaResponse(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                               MV_DMA_RESPONSE_QUEUE_ENTRY *eDmaResponse)
+{
+    MV_QUEUED_COMMAND_ENTRY       *pCommandEntry;
+    MV_UDMA_COMMAND_PARAMS        *pUdmaCommandParams;
+    MV_STORAGE_DEVICE_REGISTERS   deviceRegs;
+    MV_COMPLETION_TYPE            compType = MV_COMPLETION_TYPE_NORMAL;
+    MV_SATA_CHANNEL         *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_DMA_RESPONSE_QUEUE_ENTRY   response;
+    MV_U16                        eDmaCause = 0;
+
+    response.commandTag    = MV_LE16_TO_CPU(eDmaResponse->commandTag);
+    response.responseFlags = MV_LE16_TO_CPU(eDmaResponse->responseFlags);
+    response.timeStamp     = MV_LE32_TO_CPU(eDmaResponse->timeStamp);
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "%d %d: New Response Received. ptr %p, "
+             "tag 0x%02x, flags 0x%x ts 0x%08x\n", pAdapter->adapterId,
+             channelIndex, eDmaResponse, response.commandTag,
+             response.responseFlags, response.timeStamp);
+
+    pCommandEntry = &(pSataChannel->commandsQueue[response.commandTag & 0x1f]);
+    if (response.responseFlags & 0xff)  /* response with errors */
+    {
+        pSataChannel->queueCommandsEnabled = MV_FALSE;
+        pSataChannel->EdmaActive = MV_FALSE;
+        compType = MV_COMPLETION_TYPE_ERROR;
+
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Response with Error. "
+                 "outstanding commands %d, response flags 0x%x\n",
+                 pAdapter->adapterId, channelIndex,
+                 pSataChannel->outstandingCommands, response.responseFlags);
+
+        /* in NCQ mode no responses are completed with error*/
+        if (pSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "%d %d: Response "
+                     "with Error in NCQ mode !!!!\n",
+                     pAdapter->adapterId, channelIndex);
+            return;
+        }
+        /*
+         * link & phy layers unrecoverable errors may be the reason for a
+         * device errors, so we first check if any unrecoverable errors occured,
+         * except PCI/internal parity, if yes then we don't count this response
+         * the PCI/internal parity errors excluded since we want to complete
+         * the commands with error indication so higher layers can receive it
+         */
+        {
+            MV_U32  edmaErrorCause = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                                       pSataChannel->eDmaRegsOffset +
+                                                       MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET);
+            MV_U32  unrecoverableErrorMask;
+            if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+            {
+                unrecoverableErrorMask = MV_EDMA_GEN_I_UNRECOVERABLE_EDMA_ERROR;
+            }
+            else
+            {
+                unrecoverableErrorMask = MV_EDMA_GEN_II_UNRECOVERABLE_EDMA_ERROR;
+            }
+            unrecoverableErrorMask &= ~(MV_BIT1|MV_BIT0);
+            if (edmaErrorCause & unrecoverableErrorMask)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Response"
+                         " ignored due to unrecoverable error, EDMA Error Cause"
+                         ": 0x%08x\n", pAdapter->adapterId, channelIndex,
+                         edmaErrorCause);
+                return;
+            }
+        }
+
+        /*
+         * responseFlags will hold the low 8 bit of the EDMA error cause
+         * regiter. For 88SX50XX set bit 8 sence each error causes to
+         * eDmaSelfDisable.
+         */
+        eDmaCause = (response.responseFlags & 0xff);
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            eDmaCause |= MV_BIT8;
+        }
+        else
+        {
+            eDmaCause |= MV_BIT7;
+        }
+        if (pSataChannel->PMSupported == MV_TRUE)
+        {
+            _setActivePMPort(pSataChannel, pCommandEntry->commandInfo.PMPort);
+        }
+    }
+    pUdmaCommandParams = &pCommandEntry->commandInfo.commandParams.udmaCommand;
+    if (response.responseFlags & MV_BIT2) /*device error */
+    {
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, pUdmaCommandParams->isEXT,
+                               &deviceRegs);
+    }
+
+    if (pCommandEntry->isFreeEntry == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "%d %d: Received response on a non"
+                 "-valid tag (%x), ts 0x%08x, address %p\n", pAdapter->adapterId, channelIndex,
+                 response.commandTag, response.timeStamp, eDmaResponse);
+        _dumpEDMARegs(pAdapter, channelIndex);
+        _dumpChannelQueues(pAdapter, channelIndex);
+    }
+    else
+    {
+        pSataChannel->EdmaQueuedCommands--;
+
+        pUdmaCommandParams->callBack(pSataChannel->mvSataAdapter, channelIndex,
+                                     compType, pUdmaCommandParams->commandId,
+                                     eDmaCause, response.timeStamp, &deviceRegs);
+        removeCommand(pSataChannel,pCommandEntry);
+        if (pSataChannel->queueCommandsEnabled == MV_FALSE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_UDMA_COMMAND,
+                     "%d %d: Commands queuing is disabled\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+            return;
+        }
+        if (pSataChannel->commandsQueueHead == NULL)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_UDMA_COMMAND,
+                     "%d %d: Commands queue is empty\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+            return;
+        }
+        if (pSataChannel->NCQErrHandlingInfo.state != MV_NCQ_ERROR_HANDLING_STATE_IDLE)
+        {
+            if (isGoodCompletionsExpected(pSataChannel) == MV_FALSE)
+            {
+                enterRequestSenseState(pSataChannel);
+                return;
+            }
+        }
+        if (pSataChannel->commandsQueueHead->commandInfo.type ==
+            MV_QUEUED_COMMAND_TYPE_NONE_UDMA)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_UDMA_COMMAND,
+                     "%d %d: Next Command is PIO\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+            deactivateEdma(pAdapter,channelIndex);
+            if (pSataChannel->PMSupported == MV_TRUE)
+            {
+                _setActivePMPort(pSataChannel,
+                                 pSataChannel->commandsQueueHead->commandInfo.PMPort);
+            }
+            if (sendNoneUdmaCommand(pSataChannel,
+                                    pSataChannel->commandsQueueHead) == MV_FALSE)
+            {
+                completePIOCommand(pSataChannel, pSataChannel->commandsQueueHead,
+                                   MV_TRUE);
+            }
+
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_UDMA_COMMAND,
+                     "%d %d: Next Command is UDMA nothing to do\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+
+        }
+    }
+}
+
+
+#ifdef MV_SATA_C2C_COMM
+/*******************************************************************************
+* handleBmDmaInterrupt - handle DMA interrupt received for a given channel
+*
+* DESCRIPTION:
+*   This function is called when response interrupt is issued when C2C DMA
+*   completion event occurs.
+*
+* INPUT:
+*   pAdapter   - pointer to the MV88SX50XX adapter data structure
+*   ioBaseAddr  - adapter rbase address
+*   pSataChannel  - SATA channel structure
+*   channelIndex  - SATA channel index
+*   edmaError   - if != zero then EDMA error happened.
+*
+* RETURN:
+*   None.
+*
+* COMMENTS:
+*   None
+*
+*******************************************************************************/
+
+static void handleBmDMAInterrupt(MV_SATA_ADAPTER *pAdapter,
+                                 MV_BUS_ADDR_T   ioBaseAddr,
+                                 MV_SATA_CHANNEL *pSataChannel,
+                                 MV_U8   channelIndex,
+                                 MV_U32 edmaError)
+{
+    MV_U32  val;
+    MV_U32  eDmaErrorCause = 0;
+    mvOsSemTake(&pSataChannel->semaphore);
+    /*Reset BM dma*/
+    val = MV_REG_READ_DWORD (ioBaseAddr,
+                             getEdmaRegOffset(channelIndex) +
+                             MV_BMDMA_COMMAND_OFFSET);
+    val &= ~MV_BIT0;
+    MV_REG_WRITE_DWORD (ioBaseAddr,
+                        getEdmaRegOffset(channelIndex) +
+                        MV_BMDMA_COMMAND_OFFSET, val);
+
+    MV_REG_WRITE_DWORD(ioBaseAddr,
+                       getEdmaRegOffset(channelIndex) +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET,
+                       0);
+    if (edmaError)
+    {
+        eDmaErrorCause = (MV_U16)MV_REG_READ_DWORD(ioBaseAddr,
+                                                   getEdmaRegOffset(channelIndex) +
+                                                   MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET);
+    }
+    mvOsSemRelease(&pSataChannel->semaphore);
+    if (pSataChannel->C2CCallback)
+    {
+        if (!edmaError)
+        {
+            pSataChannel->C2CCallback(pAdapter,
+                                      pSataChannel,
+                                      MV_C2C_BM_DMA_DONE,
+                                      0,
+                                      NULL);
+        }
+        else
+        {
+            if (eDmaErrorCause & (MV_BIT17 | MV_BIT26))
+            {
+                pSataChannel->C2CCallback(pAdapter,
+                                          pSataChannel,
+                                          MV_C2C_BM_DMA_ERROR,
+                                          0,
+                                          NULL);
+            }
+            if (eDmaErrorCause & (MV_BIT13 | MV_BIT21))
+            {
+                pSataChannel->C2CCallback(pAdapter,
+                                          pSataChannel,
+                                          MV_C2C_REGISTER_DEVICE_TO_HOST_FIS_ERROR,
+                                          0,
+                                          NULL);
+            }
+        }
+    }
+}
+#endif
+
+
+/*******************************************************************************
+* handleEdmaInterrupt - handle EDMA interrupt receivd for a given channel
+*
+* DESCRIPTION:
+*   this function called when response interrupt issuesed for a channel and it
+*    handles all EDMA responses.
+*
+* INPUT:
+*   *pAdapter   - pointer to the MV88SX50XX adapter data structure
+*   sataUnit    - the SATAHC unit this channel belongs to
+*   port        - the port number of the channel
+*   rspInPtr    - the value of eRPQIP of the channel
+*   responseDone   - if != zero then responses received on this channel
+*   edmaError   - if != zero then EDMA error happened.
+*
+* RETURN:
+*   None.
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+static void handleEdmaInterrupt(MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                MV_U8 port,MV_U32 rspInPtr, MV_U32 responseDone,
+                                MV_U32 edmaError, MV_U32 unitCause)
+{
+    MV_U32  rspOutPtr;
+    MV_U8   channelIndex;
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    MV_U32  eDmaRegsOffset;
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BOOLEAN responseWithErr = MV_FALSE;
+
+    channelIndex = MV_CHANNEL_INDEX(sataUnit, port);
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+
+
+    if (responseDone && (pSataChannel != NULL))/* port Done*/
+    {
+        mvOsSemTake(&pSataChannel->semaphore);
+        pSataChannel->recoveredErrorsCounter = 0;
+#ifdef MV_SATA_C2C_COMM
+        if (MV_FALSE == pSataChannel->C2CmodeEnabled)
+        {
+#endif
+            eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+            rspOutPtr = pSataChannel->rspOutPtr;
+            /* here we should update the response out pointer though we didn't*/
+            /* handled the new responses, these response entries will not be  */
+            /* accessed again by the EDMA sinse the number of queued commands */
+            /* (outstandingCommands) will be updated only after we handle each*/
+            /* response entry                                                 */
+            MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                               MV_EDMA_RESPONSE_Q_OUTP_REG_OFFSET,
+                               pSataChannel->responseQueuePciLowAddress |
+                               (rspInPtr << MV_EDMA_RESPONSE_Q_OUTP_OFFSET));
+            while (rspOutPtr != rspInPtr)
+            {
+                handleEdmaResponse(pAdapter, channelIndex,
+                                   &(pSataChannel->responseQueue[rspOutPtr]));
+                rspOutPtr++;
+                rspOutPtr &= MV_EDMA_QUEUE_MASK;
+            }
+            /*
+             * Check if queueCommandsEnabled flag is disabled.
+             * If so, then an error has occured and auto flush must be triggered.
+             * Basically it is enough to trigger auto flush upon edmaError flag,
+             * but since edmaError is set before handleEdmaResponse is called
+             * there could be a racing condition between the time edmaError is checked
+             * and the response queue is checked.
+             * The racing condition is that an error does not occur when setting
+             * edmaError to MV_FALSE, but in handlEdmaResponse, the hardware
+             * has completed a command with error.
+             * The racing condition will complete the error command (through callback)
+             * but will prevent the auto flush of all outstanding commands.
+             */
+            if (pSataChannel->queueCommandsEnabled == MV_FALSE)
+            {
+                responseWithErr = MV_TRUE;
+            }
+
+            pSataChannel->rspOutPtr = rspOutPtr;
+            mvOsSemRelease(&pSataChannel->semaphore);
+#ifdef MV_SATA_C2C_COMM
+        }
+        else
+        {
+            mvOsSemRelease(&pSataChannel->semaphore);
+            handleBmDMAInterrupt(pAdapter,
+                                 ioBaseAddr,
+                                 pSataChannel,
+                                 channelIndex,
+                                 edmaError);
+        }
+#endif
+    }
+
+    if ((edmaError) ||  (responseWithErr == MV_TRUE))   /* EDMA error interrupt*/
+    {
+        handleEdmaError(pAdapter,channelIndex );
+    }
+}
+
+static void handleEdmaError(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_U32 eDmaErrorCause = 0;
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    eDmaErrorCause = MV_REG_READ_DWORD(ioBaseAddr,
+                                       getEdmaRegOffset(channelIndex) +
+                                       MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET);
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%d %d: Edma Error Reg 0x%x\n", pAdapter->adapterId,
+             channelIndex, MV_REG_READ_DWORD(ioBaseAddr,
+                                             getEdmaRegOffset(channelIndex) +
+                                             MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET));
+    /* clear the channel's error cause register */
+    MV_REG_WRITE_DWORD(ioBaseAddr,
+                       getEdmaRegOffset(channelIndex) +
+                       MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET,
+                       ~eDmaErrorCause);
+    /*if PM connected, connect/disconnect interrupts storm could happen*/
+    if (MV_REG_READ_DWORD(ioBaseAddr,
+                          getEdmaRegOffset(channelIndex) +
+                          MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET) &
+                          (MV_BIT3 & MV_BIT4))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 "%d %d: Edma Error Reg 0x%x still set!!!!!!!!\n",
+                 pAdapter->adapterId, channelIndex,
+                 MV_REG_READ_DWORD(ioBaseAddr,
+                                   getEdmaRegOffset(channelIndex) +
+                                   MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET));
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            /*wait 20ms till diconnect/connect interrupts finish*/
+            mvMicroSecondsDelay(pAdapter, 20000);
+            eDmaErrorCause |= MV_REG_READ_DWORD(ioBaseAddr,
+                                                getEdmaRegOffset(channelIndex) +
+                                                MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET);
+            MV_REG_WRITE_DWORD(ioBaseAddr,
+                               getEdmaRegOffset(channelIndex) +
+                               MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET,
+                               ~eDmaErrorCause);
+        }
+    }
+    /* dump in case any kind of parity error*/
+    if (eDmaErrorCause & (MV_BIT11 | MV_BIT10 | MV_BIT9 | MV_BIT1 | MV_BIT0))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR," PARITY ERROR Detected\n");
+        _dumpPCIRegs(pAdapter);
+        _dumpEDMARegs(pAdapter,channelIndex);
+        _dumpChannelQueues(pAdapter,channelIndex);
+    }
+    if (eDmaErrorCause & MV_BIT3) /*device disconneted*/
+    {
+        handleDisconnect(pAdapter, channelIndex);
+        /* continue only if we have also a connect interrupt*/
+        if ((eDmaErrorCause & MV_BIT4) == 0)
+        {
+            return;
+        }
+    }
+    if (eDmaErrorCause & MV_BIT4) /*device conneted*/
+    {
+        handleConnect(pAdapter, channelIndex);
+        return;
+    }
+    /* unrecoverable error*/
+    if (handleUnrecoverableError(pAdapter,channelIndex ,eDmaErrorCause ) == MV_TRUE)
+    {
+        return;
+    }
+
+    /*PM hot plug*/
+    if (handleAsyncNotify(pAdapter,channelIndex ,eDmaErrorCause ) == MV_TRUE)
+    {
+        return;
+    }
+    /* device errors in none NCQ mode generate self disable interrupt*/
+    if (handleSelfDisable(pAdapter,channelIndex ,eDmaErrorCause ) == MV_TRUE)
+    {
+        return;
+    }
+    /* Neither device error without completion nor self disable must be in NCQ
+    *  mode and Port multiplier connected
+    */
+    if (handleDevErr(pAdapter,channelIndex ,eDmaErrorCause ) == MV_TRUE)
+    {
+        return;
+    }
+    /* recoverable error*/
+    if (handleRecoverableError(pAdapter,channelIndex ,eDmaErrorCause) == MV_TRUE)
+    {
+        return;
+    }
+
+    /*this point should not be reached*/
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+             "%d %d: Error in handling EDMA error\n",
+             pAdapter->adapterId, channelIndex);
+
+
+}
+static MV_VOID handleDisconnect(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    if (pSataChannel)
+    {
+        mvOsSemTake(&pSataChannel->semaphore);
+        pSataChannel->queueCommandsEnabled = MV_FALSE;
+        pSataChannel->EdmaActive = MV_FALSE;
+    }
+    /* If disk is disconnected, then disable the activity LED */
+    if (pAdapter->chipIs50XXB2 == MV_TRUE)
+    {
+        MV_U32 regVal1, regVal2;
+        /* First enable flash controller clocks*/
+        regVal1 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_PCI_REGS_OFFSET +
+                                    MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+
+        regVal1 |= (MV_BIT0);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_PCI_REGS_OFFSET + MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET,
+                           regVal1);
+        regVal1 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_PCI_REGS_OFFSET +
+                                    MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+        /* Disable activity LEDs */
+        regVal2 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+        regVal2 |= (MV_BIT8 << channelIndex);
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_FLASH_GPIO_PORT_CONTROL_OFFSET,
+                            regVal2);
+        regVal2 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+        /* Disable flash controller clocks */
+        regVal1 &= ~(MV_BIT0);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_PCI_REGS_OFFSET + MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET,
+                           regVal1);
+    }
+    /*SHI2*/
+    if ((pAdapter->chipIs50XXB0 == MV_TRUE)||
+        (pAdapter->chipIs50XXB2 == MV_TRUE))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS,
+                 "%d %d: Before Hard RESET Main Cause %x\n",
+                 pAdapter->adapterId, channelIndex,
+                 MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET));
+        /* Hard Reset the channel so we can do re-connect*/
+        _channelHardReset(pAdapter, channelIndex);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS,
+                 "%d %d: After Hard RESET Main Cause %x\n",
+                 pAdapter->adapterId, channelIndex,
+                 MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET));
+    }
+    else
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            _channelHardReset(pAdapter, channelIndex);
+            _establishSataComm(pAdapter, channelIndex);
+        }
+    }
+    /* after calling mvSataNotify we can not be sure that the channel*/
+    /* data structure is still available so first we release the     */
+    /* semaphore, after notifying the upper-layer with the disconnect*/
+    /* event, nothing else is done with that channel                 */
+    if (pSataChannel)
+    {
+        mvOsSemRelease(&pSataChannel->semaphore);
+    }
+    if (mvSataIsStorageDeviceConnected(pAdapter,channelIndex) == MV_FALSE)
+    {
+        pAdapter->mvSataEventNotify(pAdapter,
+                                    MV_EVENT_TYPE_SATA_CABLE,
+                                    MV_SATA_CABLE_EVENT_DISCONNECT,
+                                    channelIndex);
+    }
+
+}
+static MV_VOID handleConnect(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    /*SHI2*/
+    if ((pAdapter->chipIs50XXB0 == MV_TRUE) ||
+        (pAdapter->chipIs50XXB2 == MV_TRUE))
+    {
+        _fixPhyParams(pAdapter, channelIndex);/*TBD*/
+        /* The following link re-establishment is due to non    */
+        /* Marvell driven hard drives                           */
+        _establishSataComm(pAdapter, channelIndex);
+        _establishSataComm(pAdapter, channelIndex);
+    }
+
+    /* If disk is connected, then enable the activity LED */
+    if (pAdapter->chipIs50XXB2 == MV_TRUE)
+    {
+        MV_U32 regVal1, regVal2;
+        /* First enable flash controller clocks*/
+        regVal1 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_PCI_REGS_OFFSET +
+                                    MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+
+        regVal1 |= (MV_BIT0);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_PCI_REGS_OFFSET + MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET,
+                           regVal1);
+        regVal1 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_PCI_REGS_OFFSET +
+                                    MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+        /* Enable activity LEDs */
+        regVal2 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+        regVal2 &= ~(MV_BIT8 << channelIndex);
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_FLASH_GPIO_PORT_CONTROL_OFFSET,
+                            regVal2);
+        regVal2 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+        /* Disable flash controller clocks */
+        regVal1 &= ~(MV_BIT0);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_PCI_REGS_OFFSET + MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET,
+                           regVal1);
+    }
+    if (mvSataIsStorageDeviceConnected(pAdapter,channelIndex) == MV_TRUE)
+    {
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_CABLE,
+                                    MV_SATA_CABLE_EVENT_CONNECT,
+                                    channelIndex);
+    }
+}
+static MV_BOOLEAN handleUnrecoverableError(MV_SATA_ADAPTER *pAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_U32 eDmaErrorCause)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    if (((pAdapter->sataAdapterGeneration == MV_SATA_GEN_I) &&
+         (eDmaErrorCause & MV_EDMA_GEN_I_UNRECOVERABLE_EDMA_ERROR)) ||
+        ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+         (eDmaErrorCause & MV_EDMA_GEN_II_UNRECOVERABLE_EDMA_ERROR)))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Unrecoverable"
+                 " HW error detected.\n", pAdapter->adapterId, channelIndex);
+#ifdef MV_LOGGER
+        if (eDmaErrorCause & MV_BIT0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: ePrtDataErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT1)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: ePrtPRDErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT3)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: eDevDis"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT9)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: ePrtCRQBErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT10)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: ePrtCRPBErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT11)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: ePrtIntErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT12)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: eIORdyErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT15)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: LinkCtlRxErr[2]"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & (MV_BIT17 | MV_BIT18 | MV_BIT19 | MV_BIT20))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: LinkDataRxErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & (MV_BIT26 | MV_BIT27 | MV_BIT28 | MV_BIT29 | MV_BIT30))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: LinkDataTxErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & MV_BIT31)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: TransProtErr"
+                     "UnrecoverableHW error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+#endif
+        if (pSataChannel)
+        {
+            mvOsSemTake(&pSataChannel->semaphore);
+            pSataChannel->queueCommandsEnabled = MV_FALSE;
+            pSataChannel->EdmaActive = MV_FALSE;
+            deactivateEdma(pAdapter, channelIndex);
+            disableSaDevInterrupts(pAdapter, channelIndex);
+            flushDmaQueue (pSataChannel, MV_FLUSH_TYPE_CALLBACK,
+                           MV_COMPLETION_TYPE_ABORT, (MV_U16)eDmaErrorCause);
+            resetEdmaChannel(pSataChannel);
+            mvOsSemRelease(&pSataChannel->semaphore);
+        }
+        _dumpSataRegs(pAdapter, channelIndex);
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                    MV_SATA_UNRECOVERABLE_COMMUNICATION_ERROR,
+                                    channelIndex);
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+static MV_BOOLEAN handleRecoverableError(MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex,
+                                         MV_U32 eDmaErrorCause)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    if (((pAdapter->sataAdapterGeneration == MV_SATA_GEN_I) &&
+         (eDmaErrorCause & MV_EDMA_GEN_I_RECOVERABLE_EDMA_ERROR)) ||
+        ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+         (eDmaErrorCause & MV_EDMA_GEN_II_RECOVERABLE_EDMA_ERROR)))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Recoverable"
+                 " HW error detected.\n", pAdapter->adapterId, channelIndex);
+#ifdef MV_LOGGER
+        if (eDmaErrorCause & MV_BIT5)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: SerrInt"
+                     "Recoverable error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & (MV_BIT13 | MV_BIT14 | MV_BIT16))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: LinkCtlRxErr"
+                     "Recoverable error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+        if (eDmaErrorCause & (MV_BIT21 | MV_BIT22 | MV_BIT23 | MV_BIT24 | MV_BIT25))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: LinkCtlTxErr"
+                     "Recoverable error detected.\n", pAdapter->adapterId, channelIndex);
+        }
+#endif
+        _dumpSataRegs(pAdapter, channelIndex);
+        if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+            (eDmaErrorCause & MV_BIT5))
+        {
+            MV_U32  regVal;
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       edmaRegOffst[ channelIndex] +
+                                       MV_SATA_II_S_ERROR_REG_OFFSET);
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Clear "
+                     " Serror register(0x%02x).\n", pAdapter->adapterId,
+                     channelIndex, regVal);
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               edmaRegOffst[ channelIndex] +
+                               MV_SATA_II_S_ERROR_REG_OFFSET, regVal);
+        }
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                    MV_SATA_RECOVERABLE_COMMUNICATION_ERROR,
+                                    channelIndex);
+        if (pSataChannel)
+        {
+            mvOsSemTake(&pSataChannel->semaphore);
+            if (pSataChannel->recoveredErrorsCounter++ > 10)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         "%d %d: Reached %d Recoverable errors"
+                         "notify unrecoverable error\n",
+                         pAdapter->adapterId, channelIndex,
+                         pSataChannel->recoveredErrorsCounter);
+                pSataChannel->queueCommandsEnabled = MV_FALSE;
+                pSataChannel->EdmaActive = MV_FALSE;
+                deactivateEdma(pAdapter, channelIndex);
+                disableSaDevInterrupts(pAdapter, channelIndex);
+                flushDmaQueue (pSataChannel, MV_FLUSH_TYPE_CALLBACK,
+                               MV_COMPLETION_TYPE_ABORT, (MV_U16)eDmaErrorCause);
+                resetEdmaChannel(pSataChannel);
+                mvOsSemRelease(&pSataChannel->semaphore);
+                pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                            MV_SATA_UNRECOVERABLE_COMMUNICATION_ERROR,
+                                            channelIndex);
+            }
+            else
+            {
+                mvOsSemRelease(&pSataChannel->semaphore);
+                return MV_TRUE;
+            }
+        }
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+
+static MV_BOOLEAN handleAsyncNotify(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_U32 eDmaErrorCause)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+        (eDmaErrorCause & MV_BIT8))
+    {
+        MV_U32 regVal1;
+        if (pSataChannel != NULL)
+        {
+            mvOsSemTake(&pSataChannel->semaphore);
+        }
+        regVal1 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                    getEdmaRegOffset(channelIndex) +
+                                    MV_SATA_II_IF_STATUS_REG_OFFSET);
+        /*Clear status*/
+        if (regVal1 & (MV_BIT31 | MV_BIT30))
+        {
+            MV_U32 regVal2 = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                               getEdmaRegOffset(channelIndex) +
+                                               MV_SATA_II_IF_CONTROL_REG_OFFSET);
+            regVal2 |= MV_BIT24;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               getEdmaRegOffset(channelIndex) +
+                               MV_SATA_II_IF_CONTROL_REG_OFFSET, regVal2);
+        }
+        if (pSataChannel != NULL)
+        {
+            mvOsSemRelease(&pSataChannel->semaphore);
+        }
+        if (((regVal1 & MV_BIT30) == 0) &&
+            ((regVal1 & MV_BIT31) == MV_BIT31))
+        {
+
+
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS,
+                     "%d %d: PM asynchronous notification interrupt.\n",
+                     pAdapter->adapterId, channelIndex);
+
+            pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_CABLE,
+                                        MV_SATA_CABLE_EVENT_PM_HOT_PLUG,
+                                        channelIndex);
+        }
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+
+static MV_BOOLEAN handleSelfDisable(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_U32 eDmaErrorCause)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    if ((((pAdapter->sataAdapterGeneration == MV_SATA_GEN_I) && (eDmaErrorCause & MV_BIT8)) ||
+         ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) && (eDmaErrorCause & MV_BIT7)))
+        &&
+        (pSataChannel != NULL)) /* edma self disable */
+    {
+        mvOsSemTake(&pSataChannel->semaphore);
+        if (pSataChannel->EdmaActive == MV_TRUE)
+        {
+            pSataChannel->queueCommandsEnabled = MV_FALSE;
+            pSataChannel->EdmaActive = MV_FALSE;
+
+            if (eDmaErrorCause & MV_BIT2)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         "%d %d: Edma Self disabled due to device error"
+                         " without completion\n", pAdapter->adapterId,
+                         channelIndex);
+                switch (pSataChannel->queuedDMA)
+                {
+                case MV_EDMA_MODE_NOT_QUEUED:
+                case MV_EDMA_MODE_QUEUED:
+                    handleEdmaFailedCommand(pAdapter, channelIndex,
+                                            (MV_U16)eDmaErrorCause);
+                    break;
+                case MV_EDMA_MODE_NATIVE_QUEUING:
+                    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                             "%d %d: Edma Self disabled due to device "
+                             "error in NCQ mode!!!!\n",
+                             pAdapter->adapterId, channelIndex);
+
+                    break;
+                default:
+                    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                             "%d %d: Unknown EDMA mode (%d)\n",
+                             pAdapter->adapterId, channelIndex,
+                             pSataChannel->queuedDMA);
+                    break;
+
+                }
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+                         "%d %d: Edma Self disable received without reason!!!\n",
+                         pAdapter->adapterId, channelIndex);
+
+            }
+        }
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                    MV_SATA_DEVICE_ERROR, channelIndex);
+        if (_doDevErrorRecovery(pSataChannel) == MV_FALSE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+                     "%d %d: Error Recovery Fails!!!\n",
+                     pAdapter->adapterId, channelIndex);
+            mvOsSemRelease(&pSataChannel->semaphore);
+            return MV_TRUE;
+        }
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+static MV_BOOLEAN handleDevErr(MV_SATA_ADAPTER *pAdapter,
+                               MV_U8 channelIndex,
+                               MV_U32 eDmaErrorCause)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+        (eDmaErrorCause & MV_BIT2) && (pSataChannel != NULL))
+    {
+        mvOsSemTake(&pSataChannel->semaphore);
+        if (pSataChannel->EdmaActive == MV_TRUE)
+        {
+            if (pSataChannel->queuedDMA != MV_EDMA_MODE_NATIVE_QUEUING)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+                         "%d %d: EDMA device error must be handled"
+                         "previously!!!\n", pAdapter->adapterId,
+                         channelIndex);
+            }
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                     "%d %d: EDMA device error in NCQ mode\n",
+                     pAdapter->adapterId, channelIndex);
+            if (pSataChannel->NCQErrHandlingInfo.state == MV_NCQ_ERROR_HANDLING_STATE_IDLE)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         "%d %d: First NCQ error\n", pAdapter->adapterId,
+                         channelIndex);
+                pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_WAIT_FOR_COMPLETIONS;
+            }
+            updatePortsWithErrors(pSataChannel);
+            if (isGoodCompletionsExpected(pSataChannel) == MV_FALSE)
+            {
+                enterRequestSenseState(pSataChannel);
+            }
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+                     "%d %d: EDMA device error while EDMA not active!!!\n",
+                     pAdapter->adapterId, channelIndex);
+        }
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                    MV_SATA_DEVICE_ERROR, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+#ifdef MV_SATA_C2C_COMM
+/*******************************************************************************
+* handleC2CInterrupt - channel 2 channel interrupt handler
+*
+*
+* DESCRIPTION:
+*   Handles channel 2 channel interrupt (register device 2 host FIS) and
+*   convert ATA registers values to user specific 10 bytes message
+*
+* INPUT:
+*   pSataChannel   - pointer to the Sata channel data structure
+*
+* RETURN:
+*   None
+*
+* COMMENTS:
+*   None
+*
+*******************************************************************************/
+static void handleC2CInterrupt(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T   ioBaseAddr =
+    pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32      eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    MV_U8       port = pSataChannel->channelNumber & (MV_BIT0 | MV_BIT1);
+    MV_U8       sataUnit = (pSataChannel->channelNumber & MV_BIT2) >> 2;
+    MV_U8       ATAstatus;
+    MV_STORAGE_DEVICE_REGISTERS     deviceRegs;
+
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_ALTERNATE_REG_OFFSET);
+
+    ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    /* clear DevInterrupt*/
+    MV_REG_WRITE_DWORD(ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET, ~(MV_BIT8 << port));
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             "%d %d: C2C Interrupt: status 0x%02x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, ATAstatus);
+
+    dumpAtaDeviceRegisters(pSataChannel->mvSataAdapter,
+                           pSataChannel->channelNumber,
+                           MV_TRUE,
+                           &deviceRegs);
+    mvOsSemRelease(&pSataChannel->semaphore);
+    if (pSataChannel->C2CCallback)
+    {
+        MV_U8 msg[MV_C2C_MESSAGE_SIZE];
+        msg[0] = deviceRegs.errorRegister;
+        msg[1] = deviceRegs.lbaLowRegister & 0xFF;
+        msg[2] = deviceRegs.lbaMidRegister & 0xFF;
+        msg[3] = deviceRegs.lbaHighRegister & 0xFF;
+        msg[4] = deviceRegs.deviceRegister;
+        msg[5] = deviceRegs.lbaLowRegister >> 8;
+        msg[6] = deviceRegs.lbaMidRegister >> 8;
+        msg[7] = deviceRegs.lbaHighRegister >> 8;
+        msg[8] = deviceRegs.sectorCountRegister & 0xFF;
+        msg[9] = deviceRegs.sectorCountRegister >> 8;
+        pSataChannel->C2CCallback(pSataChannel->mvSataAdapter,
+                                  pSataChannel,
+                                  MV_C2C_REGISTER_DEVICE_TO_HOST_FIS_DONE,
+                                  MV_C2C_MESSAGE_SIZE,
+                                  msg);
+    }
+}
+#endif
+
+
+
+static void handleDeviceInterrupt(MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                  MV_U8 port)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_QUEUED_COMMAND_ENTRY *pCommandEntry;
+    MV_U8   channelIndex;
+
+    channelIndex = MV_CHANNEL_INDEX(sataUnit, port);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             "%d %d: SaDevInterrupt Received\n", pAdapter->adapterId,
+             channelIndex);
+
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: SaDevInterrupt Received for disconnected channel\n",
+                 pAdapter->adapterId, channelIndex);
+        /* disable SaDevInterrupts from this channel */
+        disableSaDevInterrupts(pAdapter,channelIndex);
+        return;
+    }
+#ifdef MV_SATA_C2C_COMM
+    /*handle channel 2 channel communication mode*/
+    if (pSataChannel->C2CmodeEnabled == MV_TRUE)
+    {
+        handleC2CInterrupt(pSataChannel);
+        return;
+    }
+#endif
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->NCQErrHandlingInfo.state == MV_NCQ_ERROR_HANDLING_STATE_WAIT_FOR_BUSY)
+    {
+        MV_U8       ATAstatus;
+
+        ATAstatus = MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress,
+                                     pSataChannel->eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        /* clear DevInterrupt*/
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET,
+                           ~(MV_BIT8 << port));
+
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: enter NCQ error handling request sense state\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, ATAstatus);
+        pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_REQUEST_SENSE;
+        pSataChannel->NCQErrHandlingInfo.CurrPort = 0;
+        setReadLogExtCmndPointers(pSataChannel);
+        handlePortNCQError(pSataChannel);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return;
+    }
+
+    /* clear interrupt */
+
+    pCommandEntry = pSataChannel->commandsQueueHead;
+    if (pCommandEntry == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: SaDevInterrupt: No command is running!!!\n",
+                 pAdapter->adapterId, channelIndex);
+        _dumpSataRegs(pAdapter, channelIndex);
+        /* disable SaDevInterrupts from this channel */
+        disableSaDevInterrupts(pAdapter,channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return;
+    }
+    if ((pCommandEntry->isFreeEntry == MV_TRUE) ||
+        (pCommandEntry->commandInfo.type != MV_QUEUED_COMMAND_TYPE_NONE_UDMA))
+    {
+        if (pCommandEntry->isFreeEntry == MV_TRUE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_NON_UDMA_COMMAND,
+                     "%d %d: SaDevInterrupt: current command is free ???\n",
+                     pAdapter->adapterId, channelIndex);
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR|MV_DEBUG_NON_UDMA_COMMAND,
+                     "%d %d: SaDevInterrupt: current command is Not PIO ???\n",
+                     pAdapter->adapterId, channelIndex);
+        }
+        /* disable SaDevInterrupts from this channel */
+        disableSaDevInterrupts(pAdapter,channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return;
+    }
+    handlePIOInterrupt(pSataChannel, pCommandEntry);
+    mvOsSemRelease(&pSataChannel->semaphore);
+}
+
+static void handlePIOInterrupt(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32      eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    MV_U8       port = pSataChannel->channelNumber & (MV_BIT0 | MV_BIT1);
+    MV_U8       sataUnit = (pSataChannel->channelNumber & MV_BIT2) >> 2;
+    MV_U8       ATAstatus;
+
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_ALTERNATE_REG_OFFSET);
+
+    ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    /* clear DevInterrupt*/
+    MV_REG_WRITE_DWORD(ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET, ~(MV_BIT8 << port));
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             "%d %d: PIO Interrupt: cmd 0x%02X, type %d. status 0x%02x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.command,
+             pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.protocolType,
+             ATAstatus);
+
+    if (ATAstatus & MV_ATA_BUSY_STATUS)
+    {
+        if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "%d %d: "
+                     "PIO Interrupt: drive is BUSY!!!! status 0x%02x\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber, ATAstatus);
+        }
+        return;
+    }
+    if (ATAstatus & MV_ATA_ERROR_STATUS)
+    {
+        completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+        return;
+    }
+    switch (pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.protocolType)
+    {
+    case MV_NON_UDMA_PROTOCOL_NON_DATA:
+        /* command is successfully completed*/
+        completePIOCommand(pSataChannel, pCommandEntry, MV_FALSE);
+        break;
+    case MV_NON_UDMA_PROTOCOL_PIO_DATA_IN:
+        if (ATAstatus & MV_ATA_READY_STATUS)
+        {
+            if (transferPIOData(pSataChannel,
+                                &pCommandEntry->commandInfo.commandParams.NoneUdmaCommand) == MV_TRUE)
+            {
+                if (pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.count == 0)
+                {
+                    completePIOCommand(pSataChannel, pCommandEntry, MV_FALSE);
+                }
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+
+                /* for Read long only*/
+                if (pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.count == 4)
+                {
+                    if (transferPIOData(pSataChannel,
+                                        &pCommandEntry->commandInfo.commandParams.NoneUdmaCommand) == MV_TRUE)
+                    {
+                        completePIOCommand(pSataChannel, pCommandEntry, MV_FALSE);
+                    }
+                    else
+                    {
+                        completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+                    }
+                }
+#endif /*MV_SATA_SUPPORT_READ_WRITE_LONG*/
+
+            }
+            else
+            {
+                completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+            }
+        }
+        else    /* when BUSY and DRQ cleared to zero then the device has*/
+        {
+            /* completed the command with error                     */
+            completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+            return;
+        }
+        break;
+    case MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT:
+        if ((ATAstatus & MV_ATA_READY_STATUS) &&
+            !(ATAstatus & MV_ATA_DEVICE_FAULT_STATUS))
+        {
+            if (pCommandEntry->commandInfo.commandParams.NoneUdmaCommand.count == 0)
+            {
+                completePIOCommand(pSataChannel, pCommandEntry, MV_FALSE);
+            }
+            else
+            {
+                if (transferPIOData(pSataChannel,
+                                    &pCommandEntry->commandInfo.commandParams.NoneUdmaCommand) == MV_FALSE)
+                {
+                    completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+                }
+            }
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: PIO Interrupt: PIO"
+                     " Data Out command failed status 0x%02x\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber, ATAstatus);
+            completePIOCommand(pSataChannel, pCommandEntry, MV_TRUE);
+        }
+        break;
+    default: /* never reached */
+        break;
+    }
+}
+static MV_BOOLEAN transferPIOData(MV_SATA_CHANNEL *pSataChannel,
+                                  MV_NONE_UDMA_COMMAND_PARAMS   *pNoneUdmaCommandParams)
+{
+    MV_U32  i;
+    MV_U32  dataBlockWords = pSataChannel->DRQDataBlockSize * ATA_SECTOR_SIZE_IN_WORDS;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             "%d %d: xfer data for PIO Data command.count %d\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pNoneUdmaCommandParams->count);
+
+    switch (pNoneUdmaCommandParams->protocolType)
+    {
+    case MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT:
+        for (i = 0; i < dataBlockWords; i++)
+        {
+            if (pNoneUdmaCommandParams->count == 0)
+            {
+                return MV_TRUE;
+            }
+            pNoneUdmaCommandParams->count--;
+            MV_REG_WRITE_WORD(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                              pSataChannel->eDmaRegsOffset +
+                              MV_ATA_DEVICE_PIO_DATA_REG_OFFSET,
+                              *pNoneUdmaCommandParams->bufPtr++);
+        }
+        break;
+    case MV_NON_UDMA_PROTOCOL_PIO_DATA_IN:
+        for (i = 0; i < dataBlockWords; i++)
+        {
+            if (pNoneUdmaCommandParams->count == 0)
+            {
+                return MV_TRUE;
+            }
+            pNoneUdmaCommandParams->count--;
+            *pNoneUdmaCommandParams->bufPtr++ =
+            MV_REG_READ_WORD(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                             pSataChannel->eDmaRegsOffset +
+                             MV_ATA_DEVICE_PIO_DATA_REG_OFFSET);
+        }
+        break;
+    case MV_NON_UDMA_PROTOCOL_NON_DATA:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "%d %d: in xfer data "
+                 "PIO command is None Data \n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        return MV_FALSE;
+    }
+    return MV_TRUE;
+}
+
+static void completePIOCommand(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                               MV_BOOLEAN failed)
+{
+    MV_COMPLETION_TYPE              compType = MV_COMPLETION_TYPE_NORMAL;
+    MV_STORAGE_DEVICE_REGISTERS     deviceRegs;
+    MV_U8                           commandTag;
+    MV_NONE_UDMA_COMMAND_PARAMS     *pParams =
+    &pCommandEntry->commandInfo.commandParams.NoneUdmaCommand;
+
+    dumpAtaDeviceRegisters(pSataChannel->mvSataAdapter,
+                           pSataChannel->channelNumber, pParams->isEXT,
+                           &deviceRegs);
+    if (failed == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: PIO Command completed "
+                 "with error\n", pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+
+        compType = MV_COMPLETION_TYPE_ERROR;
+        pSataChannel->queueCommandsEnabled = MV_FALSE;
+    }
+    else
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: PIO Command completed successfully\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        pSataChannel->recoveredErrorsCounter = 0;
+    }
+    /* pCommandEntry is invalid after calling the callback function
+        so we cache the tag to be used later*/
+
+    commandTag = pCommandEntry->commandTag;
+    if (commandTag == 0xFF)/*NCQ Error handling ReadLogExt command*/
+    {
+        /*sanity check*/
+        if (pCommandEntry != pSataChannel->NCQErrHandlingInfo.pReadLogExtEntry)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                     "%d %d: in completePIOCommand, command is ReadLogExt"
+                     ", pointers mismatch \n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+        }
+        commandsQueueRemove(pSataChannel,pCommandEntry);
+    }
+    else
+    {
+        removeCommand(pSataChannel,pCommandEntry);
+    }
+
+    pParams->callBack(pSataChannel->mvSataAdapter, pSataChannel->channelNumber,
+                      compType, pParams->commandId, 0, 0, &deviceRegs);
+
+    if (commandTag != 0xFF)/*if not NCQ Error handling ReadLogExt command*/
+    {
+        if (failed == MV_TRUE)
+        {
+            _doDevErrorRecovery(pSataChannel);
+        }
+        else
+        {
+            _insertQCommandsIntoEdma(pSataChannel);
+        }
+    }
+}
+/*******************************************************************************
+* _resetEdmaQPointers - resets EDMA's Queues Pointers
+*
+*
+* DESCRIPTION:
+*
+* INPUT:
+*   *pSataChannel   - pointer to the Sata channel data structure
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*   this function assumes that the channel semaphore is locked
+*
+*******************************************************************************/
+static MV_BOOLEAN _resetEdmaQPointers(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T       ioBaseAddr =
+    pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32 eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "%d %d: _resetEdmaQPointers\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber);
+
+    pSataChannel->EdmaQueuedCommands = 0;
+    pSataChannel->reqInPtr = 0;
+    pSataChannel->rspOutPtr = 0;
+
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_REQUEST_Q_BAH_REG_OFFSET,
+                       pSataChannel->requestQueuePciHiAddress);
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_REQUEST_Q_INP_REG_OFFSET,
+                       pSataChannel->requestQueuePciLowAddress &
+                       MV_EDMA_REQUEST_Q_BA_MASK);
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_REQUEST_Q_OUTP_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_RESPONSE_Q_BAH_REG_OFFSET,
+                       pSataChannel->responseQueuePciHiAddress);
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_RESPONSE_Q_INP_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_EDMA_RESPONSE_Q_OUTP_REG_OFFSET,
+                       pSataChannel->responseQueuePciLowAddress &
+                       MV_EDMA_RESPONSE_Q_BA_MASK);
+
+    return MV_TRUE;
+}
+/*******************************************************************************
+* resetEdmaChannel - resets the channel data stucture and EDMA registers
+*
+*
+* DESCRIPTION:
+*   this function resets the low level EDMA fields of Sata channel data
+*   structure and initialize the EDMA register accourdingly
+*
+* INPUT:
+*   *pSataChannel   - pointer to the Sata channel data structure
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*   this function assumes that the channel semaphore is locked
+*
+*******************************************************************************/
+static MV_BOOLEAN resetEdmaChannel(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T       ioBaseAddr =
+    pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32 eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    int i;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "%d %d: resetEdmaChannel\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber);
+
+    if (MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                          MV_EDMA_COMMAND_REG_OFFSET) &
+        MV_EDMA_COMMAND_HARD_RST_MASK)
+    {
+        MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                           MV_EDMA_COMMAND_REG_OFFSET,
+                           MV_EDMA_COMMAND_DISABLE_MASK);
+
+        MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                          MV_EDMA_COMMAND_REG_OFFSET);
+        mvMicroSecondsDelay(pSataChannel->mvSataAdapter,
+                            MV_HARD_RESET_WAIT_NEGATE);
+        _fixPhyParams(pSataChannel->mvSataAdapter, pSataChannel->channelNumber);
+    }
+    else
+    {
+        MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                           MV_EDMA_COMMAND_REG_OFFSET,
+                           MV_EDMA_COMMAND_DISABLE_MASK);
+    }
+
+    pSataChannel->outstandingCommands = 0;
+    for (i = 0; i <= MV_SATA_PM_MAX_PORTS; i++)
+    {
+        pSataChannel->portQueuedCommands[i] = 0;
+    }
+    pSataChannel->noneUdmaOutstandingCommands = 0;
+    pSataChannel->EdmaActive = MV_FALSE;
+
+    /* init free entries stack*/
+    pSataChannel->freeIDsNum = MV_SATA_SW_QUEUE_SIZE;
+    for (i = 0; i < MV_SATA_SW_QUEUE_SIZE; i++)
+    {
+        pSataChannel->freeIDsStack[i] = MV_SATA_SW_QUEUE_SIZE - 1 - i;
+        pSataChannel->commandsQueue[i].isFreeEntry = MV_TRUE;
+    }
+
+    pSataChannel->commandsQueueHead = NULL;
+    pSataChannel->commandsQueueTail = NULL;
+    pSataChannel->queueCommandsEnabled = MV_FALSE;
+#ifdef MV_SATA_C2C_COMM
+
+    /* C2C */
+    pSataChannel->C2CmodeEnabled = MV_FALSE;
+#endif
+    pSataChannel->NCQErrHandlingInfo.CurrPort = 0;
+    pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_IDLE;
+    pSataChannel->NCQErrHandlingInfo.PortsWithErrors = 0;
+    _resetEdmaQPointers(pSataChannel);
+    return MV_TRUE;
+}
+
+static void flushDmaQueue(MV_SATA_CHANNEL *pSataChannel,MV_FLUSH_TYPE flushType,
+                          MV_COMPLETION_TYPE completionType, MV_U16 eDmaCause)
+{
+    mvSataCommandCompletionCallBack_t callBackFunc;
+    int i;
+
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d: Flush DMA, type=%s, commands"
+             " %d (on EDMA %d)\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             (flushType==MV_FLUSH_TYPE_CALLBACK)?"CALLBACK":"NONE",
+             pSataChannel->outstandingCommands,pSataChannel->EdmaQueuedCommands);
+
+    if (flushType == MV_FLUSH_TYPE_CALLBACK)
+    {
+        for (i=0;i < MV_SATA_SW_QUEUE_SIZE; i++)
+        {
+            if (pSataChannel->commandsQueue[i].isFreeEntry == MV_FALSE)
+            {
+                MV_STORAGE_DEVICE_REGISTERS deviceRegisters;
+                MV_BOOLEAN  isEXT;
+                MV_VOID_PTR commandId;
+                if (pSataChannel->commandsQueue[i].commandInfo.type == MV_QUEUED_COMMAND_TYPE_NONE_UDMA)
+                {
+                    isEXT = pSataChannel->commandsQueue[i].commandInfo.commandParams.NoneUdmaCommand.isEXT;
+                    commandId = pSataChannel->commandsQueue[i].commandInfo.commandParams.NoneUdmaCommand.commandId;
+                    callBackFunc = pSataChannel->commandsQueue[i].commandInfo.commandParams.NoneUdmaCommand.callBack;
+                }
+                else
+                {
+                    isEXT = pSataChannel->commandsQueue[i].commandInfo.commandParams.udmaCommand.isEXT;
+                    commandId = pSataChannel->commandsQueue[i].commandInfo.commandParams.udmaCommand.commandId;
+                    callBackFunc = pSataChannel->commandsQueue[i].commandInfo.commandParams.udmaCommand.callBack;
+                }
+
+                dumpAtaDeviceRegisters(pSataChannel->mvSataAdapter,
+                                       pSataChannel->channelNumber, isEXT,
+                                       &deviceRegisters);
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         "%d %d: Calling callBackFunc - command index %d at %p,"
+                         " next %p, prev %p\n",
+                         pSataChannel->mvSataAdapter->adapterId,
+                         pSataChannel->channelNumber,
+                         i,
+                         &pSataChannel->commandsQueue[i],
+                         pSataChannel->commandsQueue[i].next,
+                         pSataChannel->commandsQueue[i].prev);
+                callBackFunc(pSataChannel->mvSataAdapter,
+                             pSataChannel->channelNumber, completionType,
+                             commandId, eDmaCause, 0, &deviceRegisters);
+            }
+        }
+    }
+}
+
+static void _fixPhyParams(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    /* Set unit 0 or 1 */
+    MV_U8       sataUnit = (channelIndex & MV_BIT2) >> 2;
+    /* Set port 0-3 */
+    MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+    MV_U32      regVal;
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+
+        if (pAdapter->chipIs50XXB0 == MV_TRUE)
+        {
+            /*SHI12*/
+            /* Disable auto-power management*/
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                       MV_SATA_I_HC_LT_MODES_PORT_REG_OFFSET(port));
+            regVal |= MV_BIT19; /* disbale auto-power management*/
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_LT_MODES_PORT_REG_OFFSET(port),
+                               regVal);
+            /*SHI9*/
+            /*Modify squelch threshold*/
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                       MV_SATA_I_HC_PHY_CONTROL_BRIDGE_PORT_OFFSET(port));
+
+            regVal &= ~0x3;
+            regVal |= 0x1;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_PHY_CONTROL_BRIDGE_PORT_OFFSET(port),
+                               regVal);
+        }
+        /* Revert values of pre-emphasis and signal amps to the saved ones */
+        {
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                       MV_SATA_I_HC_PHY_MODE_BRIDGE_PORT_REG_OFFSET(port));
+            regVal &= ~MV_SATA_I_PHY_MODE_AMP_MASK;
+            regVal |= (pAdapter->signalAmps[channelIndex] << MV_SATA_I_PHY_MODE_AMP_OFFSET) &
+                      MV_SATA_I_PHY_MODE_AMP_MASK;
+            regVal &= ~MV_SATA_I_PHY_MODE_PRE_MASK;
+            regVal |= (pAdapter->pre[channelIndex] << MV_SATA_I_PHY_MODE_PRE_OFFSET) &
+                      MV_SATA_I_PHY_MODE_PRE_MASK;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_PHY_MODE_BRIDGE_PORT_REG_OFFSET(port),
+                               regVal);
+        }
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        MV_U32 phyMode2Offset = getEdmaRegOffset(channelIndex) +
+                                MV_SATA_II_PHY_MODE_2_REG_OFFSET;
+        if ((pAdapter->chipIs60X1B2 == MV_TRUE) ||
+            (pAdapter->chipIs60X1C0 == MV_TRUE))
+        {
+            /*SHII23*/
+            MV_U32 regVal;
+            regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        getEdmaRegOffset (channelIndex) +
+                                        MV_SATA_II_PHY_MODE_2_REG_OFFSET);
+            regVal |= MV_BIT31;
+            regVal &= ~MV_BIT16;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                getEdmaRegOffset (channelIndex) +
+                                MV_SATA_II_PHY_MODE_2_REG_OFFSET,
+                                regVal);
+            mvMicroSecondsDelay (pAdapter, 200); /* Wait 200uSec */
+            regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        getEdmaRegOffset (channelIndex) +
+                                        MV_SATA_II_PHY_MODE_2_REG_OFFSET);
+            regVal &= ~MV_BIT31;
+            regVal &= ~MV_BIT16;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                getEdmaRegOffset (channelIndex) +
+                                MV_SATA_II_PHY_MODE_2_REG_OFFSET,
+                                regVal);
+            mvMicroSecondsDelay (pAdapter, 200); /* Wait 200uSec */
+        }
+
+
+        /* Fix values in phyMode 4 register.*/
+        /* SHII10 */
+        if ((pAdapter->chipIs60X1B2 == MV_TRUE) ||
+            (pAdapter->chipIs60X1C0 == MV_TRUE))
+        {
+            MV_U32 phyMode4Value;
+            MV_U32 tempRegOffset, tempRegValue = 0;
+            MV_U32 phyMode4Offset = getEdmaRegOffset (channelIndex) +
+                                    MV_SATA_II_PHY_MODE_4_REG_OFFSET;
+            tempRegOffset = getEdmaRegOffset (channelIndex) + 0x310;
+
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID,  MV_DEBUG|MV_DEBUG_SATA_LINK,
+                     "%d %d: PHY mode4 reg value before fix is %x\n",
+                     pAdapter->adapterId, channelIndex,
+                     MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        phyMode4Offset));
+            phyMode4Value = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                               phyMode4Offset);
+            /* SHII13 */
+            if (pAdapter->chipIs60X1B2 == MV_TRUE)
+            {
+                tempRegValue = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                                  tempRegOffset);
+            }
+
+            phyMode4Value |= MV_BIT0;
+            phyMode4Value &= ~MV_BIT1;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                phyMode4Offset, phyMode4Value);
+            /* SHII13 */
+            if (pAdapter->chipIs60X1B2 == MV_TRUE)
+            {
+                MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                    tempRegOffset, tempRegValue);
+            }
+
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID,  MV_DEBUG|MV_DEBUG_SATA_LINK,
+                     "%d %d: PHY mode4 reg value after fix is %x\n",
+                     pAdapter->adapterId, channelIndex,
+                     MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        phyMode4Offset));
+        }
+
+        /* Revert values of pre-emphasis and signal amps to the saved ones */
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   phyMode2Offset);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID,  MV_DEBUG, "%d %d: PHY mode2 "
+                 "reg = %x (Before AMP/PRE modification)\n",
+                 pAdapter->adapterId, channelIndex, regVal);
+
+        regVal &= ~MV_SATA_II_PHY_MODE_2_AMP_MASK;
+        regVal |= (pAdapter->signalAmps[channelIndex] << MV_SATA_II_PHY_MODE_2_AMP_OFFSET) &
+                  MV_SATA_II_PHY_MODE_2_AMP_MASK;
+        regVal &= ~MV_SATA_II_PHY_MODE_2_PRE_MASK;
+        regVal |= (pAdapter->pre[channelIndex] << MV_SATA_II_PHY_MODE_2_PRE_OFFSET) &
+                  MV_SATA_II_PHY_MODE_2_PRE_MASK;
+        regVal &= ~MV_BIT16; /* Should always write 0 to bit 16 in phymode 2 */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           phyMode2Offset, regVal);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID,  MV_DEBUG, "%d %d: PHY mode2 "
+                 "reg = %x (After AMP/PRE modification)\n",
+                 pAdapter->adapterId, channelIndex,
+                 MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   phyMode2Offset));
+    }
+
+}
+
+static void _channelHardReset(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_U32 EdmaCommandOffset = getEdmaRegOffset(channelIndex) +
+                               MV_EDMA_COMMAND_REG_OFFSET;
+
+    maskEdmaInterrupts(pAdapter, channelIndex);
+    /* 1. Set ATA reset bit*/
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, EdmaCommandOffset,
+                       MV_EDMA_COMMAND_HARD_RST_MASK);
+    MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, EdmaCommandOffset);
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        MV_U32 regVal;
+
+        regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                    getEdmaRegOffset (channelIndex) +
+                                    MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+        /* SHII8*/
+        regVal |= MV_BIT12;
+
+        if ((pAdapter->limitInterfaceSpeed[channelIndex] == MV_TRUE) &&
+            (pAdapter->ifSpeed[channelIndex] == MV_SATA_IF_SPEED_1_5_GBPS))
+        {
+            regVal &= ~MV_BIT7; /* Disable GEn II */
+        }
+        else
+        {
+            regVal |= MV_BIT7;  /* Enable GEn II */
+
+        }
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            getEdmaRegOffset (channelIndex) +
+                            MV_SATA_II_SATA_CONFIG_REG_OFFSET,
+                            regVal);
+        MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                           getEdmaRegOffset (channelIndex) +
+                           MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+
+
+    }
+    /* 2. Wait 25uSeconds*/
+    mvMicroSecondsDelay(pAdapter, MV_HARD_RESET_WAIT_ASSERT);
+
+
+    /* 3. Clear ATA reset bit*/
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, EdmaCommandOffset, 0);
+    MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, EdmaCommandOffset);
+
+    /* 4. Change phy params (watermark + squelch) */
+    _fixPhyParams(pAdapter, channelIndex);
+    /* For Gen 1 devices, time delay is needed after resetingt the SATA bridge*/
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        mvMicroSecondsDelay(pAdapter, MV_HARD_RESET_WAIT_NEGATE);
+    }
+    unmaskEdmaInterrupts(pAdapter, channelIndex);
+
+}
+static void _establishSataComm(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_U32 SControlOffset = getEdmaRegOffset(channelIndex) +
+                            MV_SATA_II_S_CONTROL_REG_OFFSET;
+    MV_U32 SStatusOffset_88SX60X1 = getEdmaRegOffset(channelIndex) +
+                                    MV_SATA_II_S_STATUS_REG_OFFSET;
+    MV_U32 SStatus;
+    MV_U8   retryCount, commRetryCount = 5;
+
+    maskEdmaInterrupts(pAdapter, channelIndex);
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        /*  Set DET field in SControl register to 1 */
+        MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+        MV_U8       sataUnit = (channelIndex & MV_BIT2) >> 2;
+        SControlOffset = MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                         MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port);
+    }
+
+    while (1)
+    {
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset, 0x301);
+        MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset);
+        MV_CPU_WRITE_BUFFER_FLUSH();
+        mvMicroSecondsDelay(pAdapter, MV_SATA_COMM_INIT_DELAY);
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset, 0x300);
+        MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset);
+        MV_CPU_WRITE_BUFFER_FLUSH();
+        mvMicroSecondsDelay(pAdapter, MV_SATA_COMM_INIT_WAIT_DELAY);
+        unmaskEdmaInterrupts(pAdapter, channelIndex);
+        /*Wait 200 msec for PHY to become ready*/
+        for (retryCount = 0; retryCount < 200; retryCount++)
+        {
+            if (_checkSStatusAfterHReset(pAdapter, channelIndex) == MV_FALSE)
+            {
+                mvMicroSecondsDelay(pAdapter, 1000);
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_SATA_LINK, "%d %d: SATA PHY ready "
+                         "after %d msec\n", pAdapter->adapterId, channelIndex,
+                         retryCount);
+
+                break;
+            }
+        }
+        if (retryCount == 200)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_SATA_LINK,
+                     "%d %d: SATA PHY not ready after 200 msec\n",
+                     pAdapter->adapterId, channelIndex);
+        }
+        /* For 88SX50XX try communication only once */
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            break;
+        }
+        SStatus = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                     SStatusOffset_88SX60X1);
+        /* SHII10 - retry SATA communication if failed 5 times */
+        if ((SStatus == 0x0) || (SStatus == 0x113) || (SStatus == 0x123))
+        {
+            break;
+        }
+        commRetryCount --;
+        if (commRetryCount == 0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_FATAL_ERROR,
+                     "%d %d: Failed OOB sequence 5 times !!!",
+                     pAdapter->adapterId, channelIndex);
+            break;
+        }
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 "%d %d: Retrying OOB sequnce",pAdapter->adapterId,
+                 channelIndex);
+    }
+}
+
+static void _establishSataCommAll(MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U8 channelIndex;
+    MV_U32 SControlOffset;
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+            channelIndex ++)
+        {
+            maskEdmaInterrupts(pAdapter, channelIndex);
+            SControlOffset = getEdmaRegOffset(channelIndex) +
+                             MV_SATA_II_S_CONTROL_REG_OFFSET;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset,
+                                0x301);
+
+        }
+        /* Wait for 1mSecond for COMRESET for all drives */
+        mvMicroSecondsDelay(pAdapter, MV_SATA_COMM_INIT_DELAY);
+        for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+            channelIndex ++)
+        {
+            SControlOffset = getEdmaRegOffset(channelIndex) +
+                             MV_SATA_II_S_CONTROL_REG_OFFSET;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset,
+                                0x300);
+        }
+        mvMicroSecondsDelay(pAdapter, MV_SATA_COMM_INIT_WAIT_DELAY);
+        for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+            channelIndex ++)
+        {
+            unmaskEdmaInterrupts(pAdapter, channelIndex);
+        }
+    }
+}
+
+
+
+
+
+void _setActivePMPort(MV_SATA_CHANNEL *pSataChannel, MV_U8 PMPort)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32          eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    MV_U32  regVal;
+
+    if (pSataChannel->PMSupported == MV_FALSE)
+    {
+        return;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_PM, "%d %d: Set TX PM"
+             " Port to %x\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, PMPort);
+
+    regVal = MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                               MV_SATA_II_IF_CONTROL_REG_OFFSET);
+
+    regVal &= ~MV_SATA_II_IF_CONTROL_PMTX_MASK;
+    regVal |= (PMPort << MV_SATA_II_IF_CONTROL_PMTX_OFFSET) &
+              MV_SATA_II_IF_CONTROL_PMTX_MASK;
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET, regVal);
+    MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                      MV_SATA_II_IF_CONTROL_REG_OFFSET);
+
+}
+static void revertSataHCRegs (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U8 channelIndex;
+    MV_U8 temp;
+    MV_U32 edmaRegsOffset;
+    MV_U32 sataHcRegsOffset;
+    MV_U32 regTemp;
+    MV_U8  sataUnit;
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        for (sataUnit = 0 ; sataUnit < pAdapter->numberOfUnits ; sataUnit ++)
+        {
+            for (temp = 0 ; temp < MV_SATA_PORT_PER_UNIT ; temp ++)
+            {
+                channelIndex = temp + sataUnit * MV_SATA_PORT_PER_UNIT;
+                edmaRegsOffset = getEdmaRegOffset(channelIndex);
+                /* Disable EDMA */
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_COMMAND_REG_OFFSET,
+                                   MV_EDMA_COMMAND_DISABLE_MASK);
+                MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                  edmaRegsOffset + MV_EDMA_COMMAND_REG_OFFSET);
+
+                /* Reset SATA bridge */
+                _channelHardReset(pAdapter, channelIndex);
+
+                /* Zero EDMA registersr */
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_COMMAND_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_CONFIG_REG_OFFSET, 0x11f);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_TIMER_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_REQUEST_Q_BAH_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_REQUEST_Q_INP_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_REQUEST_Q_OUTP_REG_OFFSET,0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_RESPONSE_Q_BAH_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_RESPONSE_Q_OUTP_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_RESPONSE_Q_INP_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_TEST_CONTROL_REG_OFFSET, 0);
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegsOffset + MV_EDMA_IORDY_TIMEOUT_REG_OFFSET, 0xbc);
+            }
+
+            /* Revert values of SATA HC regs (few registers are READ-ONLY ) */
+            sataHcRegsOffset = MV_SATAHC_REGS_BASE_OFFSET(sataUnit);
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                sataHcRegsOffset + MV_SATAHC_INT_COAL_THRE_REG_OFFSET, 0);
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                sataHcRegsOffset + MV_SATAHC_INT_TIME_THRE_REG_OFFSET, 0);
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                sataHcRegsOffset + MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET, 0);
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                sataHcRegsOffset + MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET, 0);
+            regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                         sataHcRegsOffset +
+                                         MV_SATA_I_HC_BRIDGES_PINS_CONFIG_REG_OFFSET);
+            /* Keep the SS during power on and the reference clock bits (reset sample )*/
+            regTemp &= 0x1c1c1c1c;
+            regTemp |= 0x03030303;
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                sataHcRegsOffset + MV_SATA_I_HC_BRIDGES_PINS_CONFIG_REG_OFFSET,
+                                regTemp);
+        }
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        MV_U32 timeout;
+        /* Use global reset feature */
+        /* Empty PCI master */
+
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET,
+                            MV_PCI_MAIN_COMMAND_STOP_MASTER_MASK);
+        MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                           MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET);
+        timeout = 1000;
+        while (timeout)
+        {
+            if (MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                   MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET) &
+                MV_PCI_MAIN_COMMAND_MASTER_EMPTY_MASK)
+            {
+                break;
+            }
+            mvMicroSecondsDelay (pAdapter, 1);
+            timeout --;
+        }
+        if (timeout == 0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: Global reset timeout when"
+                     " trying to flush PCI master - discarding the master flush"
+                     , pAdapter->adapterId);
+        }
+        /* Issue global reset - this will reset both SATAHC */
+        regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                     MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET);
+        regTemp |= MV_PCI_MAIN_COMMAND_GLOBAL_RESET_MASK;
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET, regTemp);
+        regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                     MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET);
+        if (!(regTemp & MV_PCI_MAIN_COMMAND_GLOBAL_RESET_MASK))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: Global reset error while "
+                     "writing '1' to the global reset bit",pAdapter->adapterId);
+        }
+        mvMicroSecondsDelay (pAdapter, 5);
+        regTemp &= ~(MV_PCI_MAIN_COMMAND_GLOBAL_RESET_MASK | MV_PCI_MAIN_COMMAND_STOP_MASTER_MASK);
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET, regTemp);
+        regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                     MV_PCI_MAIN_COMMAND_STATUS_REG_OFFSET);
+        if (regTemp & MV_PCI_MAIN_COMMAND_GLOBAL_RESET_MASK)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: Global reset error while "
+                     "writing '1' to the global reset bit",pAdapter->adapterId);
+        }
+        mvMicroSecondsDelay (pAdapter, 5);
+    }
+}
+
+static void revertFlashInterfaceRegs (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32 regTemp;
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_FLASH_PARAMS_REG_OFFSET, 0x0fcfffff);
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                     MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+        regTemp &= 0x3;
+        regTemp |= (MV_BIT5 | MV_BIT6);
+
+
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            MV_FLASH_GPIO_PORT_CONTROL_OFFSET, regTemp);
+    }
+}
+
+static void revertPCIInterfaceRegs (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32 regTemp;
+    if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_I))
+    {
+        if (!((pAdapter->pciConfigDeviceId == MV_SATA_DEVICE_ID_5080) &&
+              (pAdapter->pciConfigRevisionId == 0x0)))
+        {
+            regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                         MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+            regTemp |= MV_BIT0;
+
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET, regTemp);
+        }
+    }
+
+    regTemp = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                 MV_PCI_MODE_REG_OFFSET);
+    regTemp &= 0xff00ffff;
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_MODE_REG_OFFSET, regTemp);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_DISCARD_TIMER_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_MSI_TRIGGER_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_XBAR_IF_TIMEOUT_REG_OFFSET, 0x000100ff);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_MAIN_INTERRUPT_MASK_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_SERR_MASK_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_INTERRUPT_CAUSE_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_INTERRUPT_MASK_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_ERROR_LOW_ADDRESS_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_ERROR_HIGH_ADDRESS_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_ERROR_ATTRIBUTE_REG_OFFSET, 0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_PCI_ERROR_COMMAND_REG_OFFSET, 0);
+}
+
+static void commandsQueueAddTail(MV_SATA_CHANNEL *pSataChannel,
+                                 MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    pCommandEntry->next = NULL;
+    pCommandEntry->prev = pSataChannel->commandsQueueTail;
+    if (pSataChannel->commandsQueueTail != NULL)
+    {
+        pSataChannel->commandsQueueTail->next = pCommandEntry;
+    }
+    pSataChannel->commandsQueueTail = pCommandEntry;
+
+    if (pSataChannel->commandsQueueHead == NULL)
+    {
+        pSataChannel->commandsQueueHead = pCommandEntry;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: command queued. Head:%p Tail:%p "
+             "command :%p\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pSataChannel->commandsQueueHead,
+             pSataChannel->commandsQueueTail, pCommandEntry);
+}
+
+static void commandsQueueAddHead(MV_SATA_CHANNEL *pSataChannel,
+                                 MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    pCommandEntry->next = pSataChannel->commandsQueueHead;
+    pCommandEntry->prev = NULL;
+    if (pSataChannel->commandsQueueHead != NULL)
+    {
+        pSataChannel->commandsQueueHead->prev = pCommandEntry;
+    }
+    pSataChannel->commandsQueueHead = pCommandEntry;
+
+    if (pSataChannel->commandsQueueTail == NULL)
+    {
+        pSataChannel->commandsQueueTail = pCommandEntry;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: command queued. Head:%p Tail:%p "
+             "command :%p\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pSataChannel->commandsQueueHead,
+             pSataChannel->commandsQueueTail, pCommandEntry);
+}
+
+static void commandsQueueRemove(MV_SATA_CHANNEL *pSataChannel,
+                                MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    if (pCommandEntry->next == NULL)    /* last */
+    {
+        pSataChannel->commandsQueueTail = pCommandEntry->prev;
+        if (pSataChannel->commandsQueueTail != NULL)
+        {
+            pSataChannel->commandsQueueTail->next = NULL;
+        }
+    }
+    else
+    {
+        pCommandEntry->next->prev = pCommandEntry->prev;
+    }
+
+    if (pCommandEntry->prev == NULL) /* head*/
+    {
+        pSataChannel->commandsQueueHead = pCommandEntry->next;
+        if (pSataChannel->commandsQueueHead != NULL)
+        {
+            pSataChannel->commandsQueueHead->prev = NULL;
+        }
+    }
+    else
+    {
+        pCommandEntry->prev->next = pCommandEntry->next;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: command removed. Head:%p Tail:%p "
+             "command :%p\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pSataChannel->commandsQueueHead,
+             pSataChannel->commandsQueueTail, pCommandEntry);
+    pCommandEntry->next = NULL;
+    pCommandEntry->prev = NULL;
+}
+static void addCommand(MV_SATA_CHANNEL *pSataChannel,
+                       MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                       MV_QUEUE_COMMAND_INFO *pCommandInfo)
+{
+    if (pCommandInfo->type == MV_QUEUED_COMMAND_TYPE_UDMA)
+    {
+        memcpy(&pCommandEntry->commandInfo.commandParams.udmaCommand,
+               &pCommandInfo->commandParams.udmaCommand,
+               sizeof(MV_UDMA_COMMAND_PARAMS));
+
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: queue Udma command.\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+    }
+    else
+    {
+        memcpy(&pCommandEntry->commandInfo.commandParams.NoneUdmaCommand,
+               &pCommandInfo->commandParams.NoneUdmaCommand,
+               sizeof(MV_NONE_UDMA_COMMAND_PARAMS));
+        pSataChannel->noneUdmaOutstandingCommands++;
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: queue Non Udma command.[%d]\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber,
+                 pSataChannel->noneUdmaOutstandingCommands);
+    }
+    pCommandEntry->commandInfo.type = pCommandInfo->type;
+    pCommandEntry->commandInfo.PMPort = pCommandInfo->PMPort;
+    commandsQueueAddTail(pSataChannel, pCommandEntry);
+
+    pCommandEntry->isFreeEntry = MV_FALSE;
+    pSataChannel->outstandingCommands++;
+    pSataChannel->portQueuedCommands[pCommandInfo->PMPort]++;
+}
+
+static void removeCommand(MV_SATA_CHANNEL *pSataChannel,
+                          MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    if (pCommandEntry->commandInfo.type == MV_QUEUED_COMMAND_TYPE_UDMA)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: remove Udma command.\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+    }
+    else
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: remove Non Udma command.[%d]\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber,
+                 pSataChannel->noneUdmaOutstandingCommands);
+
+        pSataChannel->noneUdmaOutstandingCommands--;
+    }
+    commandsQueueRemove(pSataChannel,pCommandEntry);
+    pSataChannel->freeIDsStack[pSataChannel->freeIDsNum++] =
+    pCommandEntry->commandTag;
+    pCommandEntry->isFreeEntry = MV_TRUE;
+    pSataChannel->outstandingCommands--;
+    pSataChannel->portQueuedCommands[pCommandEntry->commandInfo.PMPort]--;
+}
+
+static MV_U32 SaDevInterrutpBit(MV_U8 channelIndex)
+{
+    MV_U32      maskBit = 0;
+
+    if (channelIndex >= MV_SATA_PORT_PER_UNIT)
+    {
+        maskBit = (1 << ((channelIndex << 1) + 2));
+    }
+    else
+    {
+        maskBit = (1 << ((channelIndex << 1) + 1));
+    }
+    return maskBit;
+}
+static void enableSaDevInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_U32      maskBit = 0;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: enable SaDevInterrupts.\n",
+             pAdapter->adapterId, channelIndex);
+    maskBit = SaDevInterrutpBit(channelIndex);
+    mvOsSemTake(&pAdapter->interruptsMaskSem);
+
+    pAdapter->mainMask |= maskBit;
+
+    /*clear disk interrupt */
+    MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress,
+                     getEdmaRegOffset(channelIndex) +
+                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    /* clear DevInterrupt*/
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_SATAHC_REGS_BASE_OFFSET((channelIndex & MV_BIT2) >> 2) +
+                       MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET,
+                       ~(MV_BIT8 << (channelIndex & (MV_BIT0 | MV_BIT1))));
+
+    /* unmask*/
+    if (pAdapter->interruptsAreMasked == MV_FALSE)
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                           pAdapter->mainMask);
+
+        MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                          MV_MAIN_INTERRUPT_MASK_REG_OFFSET);
+
+    }
+    mvOsSemRelease(&pAdapter->interruptsMaskSem);
+}
+
+void disableSaDevInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_U32      maskBit = 0;
+
+
+    maskBit = SaDevInterrutpBit(channelIndex);
+    mvOsSemTake(&pAdapter->interruptsMaskSem);
+    pAdapter->mainMask &= ~maskBit;
+    if (pAdapter->interruptsAreMasked == MV_FALSE)
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                           pAdapter->mainMask);
+
+        MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                          MV_MAIN_INTERRUPT_MASK_REG_OFFSET);
+
+    }
+    mvOsSemRelease(&pAdapter->interruptsMaskSem);
+}
+static void _checkATAStatus(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL  *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_U8 ATAstatus = MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress,
+                                       pSataChannel->eDmaRegsOffset +
+                                       MV_ATA_DEVICE_STATUS_REG_OFFSET);
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        if ((ATAstatus & (MV_ATA_BUSY_STATUS|MV_ATA_DATA_REQUEST_STATUS|
+                          MV_ATA_READY_STATUS|MV_ATA_DEVICE_FAULT_STATUS|
+                          MV_ATA_ERROR_STATUS)) == MV_ATA_READY_STATUS)
+        {
+            return;
+        }
+    }
+    else
+    {
+        if ((ATAstatus & (MV_ATA_BUSY_STATUS|MV_ATA_DATA_REQUEST_STATUS|
+                          MV_ATA_READY_STATUS)) == MV_ATA_READY_STATUS)
+        {
+            return;
+        }
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: _checkATAStatus "
+             "EDMA can't be enabled with ATA status (0x%02x), do SW reset\n",
+             pAdapter->adapterId, channelIndex, ATAstatus);
+    if (pSataChannel->PMSupported == MV_TRUE)
+    {
+        _setActivePMPort(pSataChannel, MV_SATA_PM_CONTROL_PORT);
+    }
+    _doSoftReset(pSataChannel);
+}
+static void activateEdma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL  *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32      eDmaRegsOffset;
+    MV_U8       sataUnit;
+    MV_U8       port;
+
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: activateEdma\n", pAdapter->adapterId,
+             channelIndex);
+    pSataChannel->EdmaActive = MV_TRUE;
+    sataUnit = (channelIndex & MV_BIT2) >> 2;
+    port = channelIndex & (MV_BIT0 | MV_BIT1);
+    /* clear Device interrupt */
+    MV_REG_WRITE_DWORD(ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET,
+                       ~((MV_BIT8 | MV_BIT0) << port));
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        MV_REG_WRITE_DWORD(ioBaseAddr,
+                           pSataChannel->eDmaRegsOffset +
+                           MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET, 0);
+    }
+    else
+    {
+        MV_REG_WRITE_DWORD(ioBaseAddr,
+                           pSataChannel->eDmaRegsOffset +
+                           MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET, MV_BIT8);
+    }
+
+    /* disable sata device interrupts */
+    disableSaDevInterrupts(pAdapter, channelIndex);
+
+    MV_CPU_WRITE_BUFFER_FLUSH();
+
+    _checkATAStatus(pAdapter, channelIndex);
+
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset + MV_EDMA_COMMAND_REG_OFFSET,
+                       MV_EDMA_COMMAND_ENABLE_MASK);
+}
+
+static void deactivateEdma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL  *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32      eDmaRegsOffset;
+    MV_U32      counter = 0;
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: deactivateEdma\n", pAdapter->adapterId,
+             channelIndex);
+    pSataChannel->EdmaActive = MV_FALSE;
+
+    MV_CPU_WRITE_BUFFER_FLUSH();
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset + MV_EDMA_COMMAND_REG_OFFSET,
+                       MV_EDMA_COMMAND_DISABLE_MASK);
+    while (counter < 1000)
+    {
+        if (MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                              MV_EDMA_COMMAND_REG_OFFSET) & MV_BIT0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: deactivateEdma: "
+                     "Edma still active. elapsed time %d us\n", pAdapter->adapterId,
+                     channelIndex, counter * 1000);
+            mvMicroSecondsDelay(pAdapter, 1000);
+        }
+        else
+        {
+            break;
+        }
+        counter++;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: deactivateEdma: "
+             "Edma status reg 0x%08x\n", pAdapter->adapterId,
+             channelIndex, MV_REG_READ_DWORD(ioBaseAddr,
+                                             eDmaRegsOffset +
+                                             MV_EDMA_STATUS_REG_OFFSET));
+    if (counter >= 1000)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                 " %d %d: deactivateEdma: Edma Failed (EDMA status = %x)\n",
+                 pAdapter->adapterId, channelIndex,
+                 MV_REG_READ_DWORD(ioBaseAddr,
+                                   eDmaRegsOffset + MV_EDMA_STATUS_REG_OFFSET));
+        pSataChannel->queueCommandsEnabled = MV_FALSE;
+        flushDmaQueue (pSataChannel, MV_FLUSH_TYPE_CALLBACK,
+                       MV_COMPLETION_TYPE_ABORT, 0);
+        resetEdmaChannel(pSataChannel);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_SATA_ERROR,
+                                    MV_SATA_UNRECOVERABLE_COMMUNICATION_ERROR,
+                                    channelIndex);
+        mvOsSemTake(&pSataChannel->semaphore);
+    }
+
+    /*_dumpSataRegs(pAdapter, channelIndex);*/
+    enableSaDevInterrupts(pAdapter, channelIndex);
+}
+
+static void EdmaReqQueueInsert(MV_SATA_CHANNEL *pSataChannel,
+                               MV_QUEUED_COMMAND_ENTRY *pCommandEntry,
+                               MV_UDMA_COMMAND_PARAMS  *pUdmaParams)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_UDMA_COMMAND, " %d %d: Insert Edma "
+             "Request. PMPort %x tag = 0x%x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pCommandEntry->commandInfo.PMPort,
+             pCommandEntry->commandTag);
+
+    /* insert the last commmand into the Edma queue */
+    writeEdmaRequestEntry (&pSataChannel->requestQueue[pSataChannel->reqInPtr],
+                           pSataChannel, pCommandEntry, pUdmaParams);
+
+    pSataChannel->reqInPtr++;
+    pSataChannel->reqInPtr &= MV_EDMA_QUEUE_MASK;
+    pSataChannel->EdmaQueuedCommands++;
+    pCommandEntry->isCommandInEdma = MV_TRUE;
+
+    MV_CPU_WRITE_BUFFER_FLUSH();
+    MV_REG_WRITE_DWORD(ioBaseAddr,
+                       pSataChannel->eDmaRegsOffset +
+                       MV_EDMA_REQUEST_Q_INP_REG_OFFSET,
+                       (pSataChannel->requestQueuePciLowAddress &
+                        MV_EDMA_REQUEST_Q_BA_MASK) |
+                       ((pSataChannel->reqInPtr << MV_EDMA_REQUEST_Q_INP_OFFSET)
+                        & MV_EDMA_REQUEST_Q_INP_MASK));
+
+}
+
+static MV_VOID _insertQCommandsIntoEdma(MV_SATA_CHANNEL *pSataChannel)
+{
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: _insert"
+             "QCommandsIntoEdma\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber);
+
+    if (pSataChannel->commandsQueueHead == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: Commands queue is empty\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        return;
+    }
+    if (pSataChannel->commandsQueueHead->commandInfo.type ==
+        MV_QUEUED_COMMAND_TYPE_NONE_UDMA)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: Next Command is PIO\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        if (pSataChannel->PMSupported == MV_TRUE)
+        {
+            _setActivePMPort(pSataChannel,
+                             pSataChannel->commandsQueueHead->commandInfo.PMPort);
+        }
+        if (sendNoneUdmaCommand(pSataChannel,
+                                pSataChannel->commandsQueueHead) == MV_FALSE)
+        {
+            completePIOCommand(pSataChannel, pSataChannel->commandsQueueHead,
+                               MV_TRUE);
+        }
+
+    }
+    else
+    {
+        MV_QUEUED_COMMAND_ENTRY *pEntry;
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+                 "%d %d: Next Command is UDMA\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        activateEdma(pSataChannel->mvSataAdapter,pSataChannel->channelNumber);
+        pEntry = pSataChannel->commandsQueueHead;
+        while ((pEntry != NULL) &&
+               (pEntry->commandInfo.type == MV_QUEUED_COMMAND_TYPE_UDMA))
+        {
+            EdmaReqQueueInsert(pSataChannel, pEntry,
+                               &pEntry->commandInfo.commandParams.udmaCommand);
+            pEntry = pEntry->next;
+        }
+
+    }
+
+}
+/* do device error recovery for PIO, DMA and QUEUED DMA commands (not NCQ)*/
+static MV_BOOLEAN _doDevErrorRecovery(MV_SATA_CHANNEL *pSataChannel)
+{
+    if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        if (_doSoftReset(pSataChannel) == MV_FALSE)
+        {
+            return MV_FALSE;
+        }
+    }
+    pSataChannel->queueCommandsEnabled = MV_TRUE;
+    /* Enable the storage device interrupts */
+    enableSaDevInterrupts(pSataChannel->mvSataAdapter,
+                          pSataChannel->channelNumber);
+    _resetEdmaQPointers(pSataChannel);
+    _insertQCommandsIntoEdma(pSataChannel);
+    return MV_TRUE;
+}
+/* this function used for NCQ error handling, it cheks if further commands
+    expected to be completed successfully (from drives without errors in PM)*/
+static MV_BOOLEAN isGoodCompletionsExpected(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_QUEUED_COMMAND_ENTRY *pEntry;
+
+    /*sanity checks*/
+    if ((pSataChannel == NULL) || (pSataChannel->EdmaActive == MV_FALSE) ||
+        (pSataChannel->queuedDMA != MV_EDMA_MODE_NATIVE_QUEUING))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID,MV_DEBUG_FATAL_ERROR,
+                 "isGoodCompletionsExpected called in wrong context\n");
+        return MV_FALSE;
+    }
+    pEntry = pSataChannel->commandsQueueHead;
+    while (pEntry != NULL)
+    {
+        if (pEntry->isCommandInEdma == MV_TRUE)
+        {
+            if ((((MV_U16)(1 << pEntry->commandInfo.PMPort)) &
+                 pSataChannel->NCQErrHandlingInfo.PortsWithErrors) == 0)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         " %d %d: isGoodCompletionsExpected: command (tag %d)"
+                         " expected with good completion from port %d. "
+                         "PortsWithErros= 0x%04x \n",
+                         pSataChannel->mvSataAdapter->adapterId,
+                         pSataChannel->channelNumber, pEntry->commandTag,
+                         pEntry->commandInfo.PMPort,
+                         pSataChannel->NCQErrHandlingInfo.PortsWithErrors);
+                return MV_TRUE;
+            }
+        }
+        else
+        {
+            /* stop once reached a command that has not been inserted into the
+                EDMA since the next commands also must be outside the EDMA
+            */
+            break;
+        }
+        pEntry = pEntry->next;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " %d %d: isGoodCompletionsExpected: No commands expected to be "
+             "completed. PortrNumDevError 0x%04x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             pSataChannel->NCQErrHandlingInfo.PortsWithErrors);
+    return MV_FALSE;
+}
+/* this function used for NCQ error handling, this function called wheb DevErr
+    interrupt receivedm it checks which PM ports repored device error and updates
+    PortsWithErrors varibles
+*/
+
+static MV_VOID updatePortsWithErrors(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_U32  testCtrlReg = MV_REG_READ_DWORD(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                                            pSataChannel->eDmaRegsOffset +
+                                            MV_SATA_II_IF_TEST_CTRL_REG_OFFSET);
+    testCtrlReg &= 0xFFFF0000;
+    testCtrlReg = testCtrlReg >> 16;
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " %d %d: updatePortsWithErrors: old val 0x%04x, new 0x%04x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             pSataChannel->NCQErrHandlingInfo.PortsWithErrors,
+             pSataChannel->NCQErrHandlingInfo.PortsWithErrors | testCtrlReg);
+
+    pSataChannel->NCQErrHandlingInfo.PortsWithErrors |= (MV_U16)testCtrlReg;
+}
+/* this function used for NCQ error handling, called when device error received
+   and no further good complitions expected. it stops the EDMA and starts the
+   process if sending ReadLogExt commands to the drives that reported device
+   errors
+*/
+static MV_VOID enterRequestSenseState(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_U8 ATAstatus;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " %d %d: enterRequestSenseState: PortsWithErrors 0x%04x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             pSataChannel->NCQErrHandlingInfo.PortsWithErrors);
+
+    deactivateEdma(pSataChannel->mvSataAdapter, pSataChannel->channelNumber);
+    /* clear Device errors in EDMA error cause register due to the aborted
+     commands*/
+    MV_REG_WRITE_DWORD(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                       pSataChannel->eDmaRegsOffset +
+                       MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET,~MV_BIT2);
+    /* the EDMA may be disabled after FPDMA commands issued and before */
+    /* receiving response from the drive (D2H Fis), in this case the ATA  */
+    /* busy bit will be set, so we wait for this bit to be cleared by the */
+    /* drive when is sends D2H registers Fis and SaDevInterrupt will be issued*/
+
+    /* clear SaDevInterrupt if already received*/
+    {
+        MV_U8       port = pSataChannel->channelNumber & (MV_BIT0 | MV_BIT1);
+        MV_U8       sataUnit = (pSataChannel->channelNumber & MV_BIT2) >> 2;
+
+        MV_REG_WRITE_DWORD(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET, ~(MV_BIT8 << port));
+    }
+
+    ATAstatus = MV_REG_READ_BYTE(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                                 pSataChannel->eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+
+    if (ATAstatus & MV_ATA_BUSY_STATUS)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: ATA Busy"
+                 "bit is set after disabling EDMA, wait for SaDevInterrupt\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_WAIT_FOR_BUSY;
+        return;
+    }
+    pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_REQUEST_SENSE;
+    pSataChannel->NCQErrHandlingInfo.CurrPort = 0;
+    setReadLogExtCmndPointers(pSataChannel);
+    handlePortNCQError(pSataChannel);
+}
+
+
+
+/* this function used for NCQ error handling, called from the ReadLogExt command
+    callback function, it makes sanity checks for the command output and
+    completes the erring command with the ATA registers values, finally it calls
+    handlePortNCQError to handle NCQ errors from the nexr drive if any*/
+static MV_BOOLEAN parseReadLogExtOutPut(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_U32  count;
+    MV_U8   tag;
+    MV_STORAGE_DEVICE_REGISTERS registerStruct;
+    MV_QUEUED_COMMAND_ENTRY       *pCommandEntry;
+
+    MV_U8_PTR ReadLogExtBuffer = (MV_U8_PTR)pSataChannel->NCQErrHandlingInfo.ReadLogExtBuffer;
+    /* chack CRC*/
+    {
+        MV_U8 crc = 0;
+        for (count = 0 ; count < ATA_SECTOR_SIZE ; count ++)
+        {
+            crc += ReadLogExtBuffer[count];
+        }
+        if (crc != 0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut "
+                     "ATA Command failed due to wrong CRC checksum (%02x)\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber,crc);
+            return MV_FALSE;
+        }
+    }
+    /* Swap to little endianess */
+    for (count = 0 ; count < ATA_SECTOR_SIZE_IN_WORDS; count++)
+    {
+        /* CPU to little*/
+        pSataChannel->NCQErrHandlingInfo.ReadLogExtBuffer[count] =
+        MV_LE16_TO_CPU(pSataChannel->NCQErrHandlingInfo.ReadLogExtBuffer[count]);
+    }
+
+    for (count = 0; count < 3; count++)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " ReadLogExt: 0x%02x  0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
+                 ReadLogExtBuffer[(count * 6) + 0],
+                 ReadLogExtBuffer[(count * 6) + 1],
+                 ReadLogExtBuffer[(count * 6) + 2],
+                 ReadLogExtBuffer[(count * 6) + 3],
+                 ReadLogExtBuffer[(count * 6) + 4],
+                 ReadLogExtBuffer[(count * 6) + 5]);
+    }
+    /* check NQ bit*/
+    if (ReadLogExtBuffer[0] & MV_BIT7)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut: "
+                 "Error - NQ is set\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        return MV_FALSE;
+    }
+    tag = 0x1F & ReadLogExtBuffer[0];
+
+    if (tag >= MV_SATA_SW_QUEUE_SIZE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut: "
+                 "Error - None Valid tag (0x%02x)\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, tag);
+        return MV_FALSE;
+    }
+    pCommandEntry = &pSataChannel->commandsQueue[tag];
+    if (pCommandEntry->isFreeEntry == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut: "
+                 "Error - No command with tag (0x%02x) has been issued\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, tag);
+        return MV_FALSE;
+    }
+    if (pCommandEntry->commandInfo.PMPort != pSataChannel->NCQErrHandlingInfo.CurrPort)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut: "
+                 "Error - command PM Port (0x%02x) and CurrPort (0x%02x) doesn't match\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, pCommandEntry->commandInfo.PMPort,
+                 pSataChannel->NCQErrHandlingInfo.CurrPort);
+        return MV_FALSE;
+    }
+    if (pCommandEntry->commandInfo.type != MV_QUEUED_COMMAND_TYPE_UDMA)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: parseReadLogExtOutPut: "
+                 "Error - command with tag (0x%02x) isn't UDMA command\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, tag);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: parseReadLogExtOutPut: "
+             " command tag (0x%02x)\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, tag);
+    registerStruct.statusRegister = ReadLogExtBuffer[2];
+    registerStruct.deviceRegister = ReadLogExtBuffer[7];
+    registerStruct.errorRegister = ReadLogExtBuffer[3];
+    registerStruct.lbaLowRegister = (ReadLogExtBuffer[8] << 8) | ReadLogExtBuffer[4];
+    registerStruct.lbaMidRegister = (ReadLogExtBuffer[9] << 8) | ReadLogExtBuffer[5];
+    registerStruct.lbaHighRegister = (ReadLogExtBuffer[10] << 8) | ReadLogExtBuffer[6];
+    registerStruct.sectorCountRegister = (ReadLogExtBuffer[13] << 8) | ReadLogExtBuffer[12];
+
+    _printATARegs(&registerStruct);
+
+    pSataChannel->EdmaQueuedCommands--;
+    pCommandEntry->commandInfo.commandParams.udmaCommand.callBack(pSataChannel->mvSataAdapter,
+                                                                  pSataChannel->channelNumber,
+                                                                  MV_COMPLETION_TYPE_ERROR,
+                                                                  pCommandEntry->commandInfo.commandParams.udmaCommand.commandId,
+                                                                  0x04,
+                                                                  0, &registerStruct);
+    removeCommand(pSataChannel,pCommandEntry);
+    return MV_TRUE;
+}
+/* this function used for NCQ error handling, it's the callback function of the
+    ReadLogExt command with issued by adding command entry to the channel's
+    commands queue */
+static MV_BOOLEAN
+ReadLogExtCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                       MV_U8 channelNum,
+                       MV_COMPLETION_TYPE comp_type,
+                       MV_VOID_PTR commandId,
+                       MV_U16 responseFlags,
+                       MV_U32 timeStamp,
+                       MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_SATA_CHANNEL *pSataChannel = pSataAdapter->sataChannel[channelNum];
+
+    switch (comp_type)
+    {
+    case MV_COMPLETION_TYPE_NORMAL:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " %d %d: ReadLogExtCompletionCB: Normal completion. Port 0x%02x\n",
+                 pSataAdapter->adapterId, channelNum,
+                 pSataChannel->NCQErrHandlingInfo.CurrPort);
+        if (parseReadLogExtOutPut(pSataChannel) == MV_TRUE)
+        {
+            pSataChannel->NCQErrHandlingInfo.CurrPort++;
+            handlePortNCQError(pSataChannel);
+        }
+        break;
+    default:
+        /* when ReadLogExt fails or parseReaDLogExtOutPut fails do nothing*/
+        /* the higher layers will not have the queued commands completed so it*/
+        /* should recover this situation by it's timeout error recovery*/
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " %d %d: ReadLogExtCompletionCB: Bad completion. Port 0x%02x\n",
+                 pSataAdapter->adapterId, channelNum,
+                 pSataChannel->NCQErrHandlingInfo.CurrPort);
+        _printATARegs(registerStruct);
+        _dumpSataRegs(pSataAdapter, channelNum);
+        break;
+    }
+    return MV_TRUE;
+}
+/* this function used for NCQ error handling, it "allocates" command entry of the
+    ReadLogExt command and data buffer used for that command from the EDMA
+    requests queue which is not used meanwhile since the EDMA disabled*/
+static MV_VOID setReadLogExtCmndPointers(MV_SATA_CHANNEL *pSataChannel)
+{
+    struct ReadLogExtBuffers
+    {
+        MV_QUEUED_COMMAND_ENTRY entry;
+        MV_U16                  pioBuffer[ATA_SECTOR_SIZE_IN_WORDS];
+    };
+    /* EDMA is not active, so we use the request queue buffer for Read Log Ext
+        command data */
+    struct ReadLogExtBuffers *pReadLogExtBuffers =
+    (struct ReadLogExtBuffers *)pSataChannel->requestQueue;
+    pSataChannel->NCQErrHandlingInfo.pReadLogExtEntry = &pReadLogExtBuffers->entry;
+    pSataChannel->NCQErrHandlingInfo.ReadLogExtBuffer = pReadLogExtBuffers->pioBuffer;
+}
+/* this function used for NCQ error handling, it sets the ReadLogExt command
+    entry, then issues the command to the CuttPort*/
+static MV_VOID insertReadLogExtCmnd(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_QUEUED_COMMAND_ENTRY *pEntry = pSataChannel->NCQErrHandlingInfo.pReadLogExtEntry;
+    MV_NONE_UDMA_COMMAND_PARAMS *pReadLogExtPIOParams  =
+    &pEntry->commandInfo.commandParams.NoneUdmaCommand;
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " %d %d: insertReadLogExtCmnd: Port 0x%02x\n",
+             pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber,
+             pSataChannel->NCQErrHandlingInfo.CurrPort);
+
+    pReadLogExtPIOParams->bufPtr = pSataChannel->NCQErrHandlingInfo.ReadLogExtBuffer;
+    pReadLogExtPIOParams->callBack = ReadLogExtCompletionCB;
+    pReadLogExtPIOParams->command = MV_ATA_COMMAND_READ_LOG_EXT;
+    pReadLogExtPIOParams->commandId = NULL;
+    pReadLogExtPIOParams->count = ATA_SECTOR_SIZE_IN_WORDS;
+    pReadLogExtPIOParams->device = 0;
+    pReadLogExtPIOParams->features = 0;
+    pReadLogExtPIOParams->isEXT = MV_TRUE;
+    pReadLogExtPIOParams->lbaHigh = 0;
+    pReadLogExtPIOParams->lbaLow = 0x10;
+    pReadLogExtPIOParams->lbaMid = 0;
+    pReadLogExtPIOParams->protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_IN;
+    pReadLogExtPIOParams->sectorCount = 1;
+    pEntry->commandInfo.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    pEntry->commandInfo.PMPort = pSataChannel->NCQErrHandlingInfo.CurrPort;
+    pEntry->isCommandInEdma = MV_FALSE;
+    pEntry->isFreeEntry = MV_FALSE;
+    pEntry->commandTag = 0xFF;
+    commandsQueueAddHead(pSataChannel, pEntry);
+    if (pSataChannel->PMSupported == MV_TRUE)
+    {
+        _setActivePMPort(pSataChannel, pEntry->commandInfo.PMPort);
+
+    }
+    if (sendNoneUdmaCommand(pSataChannel, pEntry) == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: Failed to "
+                 "Issue ReadLogExt PIO command\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        completePIOCommand(pSataChannel, pSataChannel->commandsQueueHead,
+                           MV_TRUE);
+    }
+}
+/* this function used for NCQ error handling, it checks the comming port
+    that experienced NCQ device error starting from CurrPort, if no port found,
+    it sets the NCQ error handling state to the Idle state and re-queues the
+    outstanding commands*/
+static MV_VOID handlePortNCQError(MV_SATA_CHANNEL *pSataChannel)
+{
+    while (pSataChannel->NCQErrHandlingInfo.CurrPort <= MV_SATA_PM_MAX_PORTS)
+    {
+        if (((MV_U16)( 1 << pSataChannel->NCQErrHandlingInfo.CurrPort)) & pSataChannel->NCQErrHandlingInfo.PortsWithErrors)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                     " %d %d: handlePortNCQError: NCQ Error found on Port "
+                     "0x%02x\n", pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber,
+                     pSataChannel->NCQErrHandlingInfo.CurrPort);
+            break;
+        }
+        pSataChannel->NCQErrHandlingInfo.CurrPort++;
+    }
+    if (pSataChannel->NCQErrHandlingInfo.CurrPort > MV_SATA_PM_MAX_PORTS)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " %d %d: handlePortNCQError: Finished All erring ports\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        pSataChannel->NCQErrHandlingInfo.state = MV_NCQ_ERROR_HANDLING_STATE_IDLE;
+        pSataChannel->NCQErrHandlingInfo.PortsWithErrors = 0;
+        _resetEdmaQPointers(pSataChannel);
+        _insertQCommandsIntoEdma(pSataChannel);
+        return;
+    }
+    insertReadLogExtCmnd(pSataChannel);
+}
+static MV_BOOLEAN sendNoneUdmaCommand(MV_SATA_CHANNEL *pSataChannel,
+                                      MV_QUEUED_COMMAND_ENTRY *pCommandEntry)
+{
+    MV_NONE_UDMA_COMMAND_PARAMS *pParams =
+    &pCommandEntry->commandInfo.commandParams.NoneUdmaCommand;
+    MV_BUS_ADDR_T   ioBaseAddr = pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32          eDmaRegsOffset;
+    MV_U8           ATAstatus;
+    unsigned int             i;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             " %d %d Issue NON UDMA command: protocol(%d) buff %p , words %x ,"
+             " features %x , sector count %x , lba %x.%x.%x device %x "
+             "command=%x\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, pParams->protocolType,
+             pParams->bufPtr, pParams->count,
+             pParams->features, pParams->sectorCount,
+             pParams->lbaLow, pParams->lbaMid,
+             pParams->lbaHigh, pParams->device,
+             pParams->command);
+
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    if ((ATAstatus & (MV_ATA_READY_STATUS | MV_ATA_BUSY_STATUS)) !=
+        MV_ATA_READY_STATUS)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: storage drive is not"
+                 " ready, ATA STATUS=0x%02x\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, ATAstatus);
+        return MV_FALSE;
+    }
+
+    if (pParams->isEXT == MV_TRUE)
+    {
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_FEATURES_REG_OFFSET,
+                          (pParams->features & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET,
+                          (pParams->sectorCount & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_LOW_REG_OFFSET,
+                          (pParams->lbaLow & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_MID_REG_OFFSET,
+                          (pParams->lbaMid & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET,
+                          (pParams->lbaHigh & 0xff00) >> 8);
+    }
+    else
+    {
+        if ((pParams->features & 0xff00) ||
+            (pParams->sectorCount & 0xff00) ||
+            (pParams->lbaLow & 0xff00) ||
+            (pParams->lbaMid & 0xff00) ||
+            (pParams->lbaHigh & 0xff00))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_NON_UDMA_COMMAND,
+                     " %d %d :in Issue NON UDMA command:"
+                     " bits[15:8] of register values should be reserved"
+                     " Features 0x%02x, SectorCount 0x%02x, LBA Low 0x%02x,"
+                     " LBA Mid 0x%02x, LBA High 0x%02x\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber, pParams->features,
+                     pParams->sectorCount, pParams->lbaLow,
+                     pParams->lbaMid, pParams->lbaHigh);
+            return MV_FALSE;
+        }
+    }
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_FEATURES_REG_OFFSET, pParams->features & 0xff);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET, pParams->sectorCount & 0xff);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_LOW_REG_OFFSET, pParams->lbaLow & 0xff);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_MID_REG_OFFSET, pParams->lbaMid & 0xff);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET,    pParams->lbaHigh    &    0xff);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_HEAD_REG_OFFSET, pParams->device);
+
+    MV_CPU_WRITE_BUFFER_FLUSH();
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_COMMAND_REG_OFFSET, pParams->command);
+
+    if (pParams->protocolType == MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT)
+    {
+        MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                         MV_ATA_DEVICE_ALTERNATE_REG_OFFSET);
+
+        /* Wait for the command to complete */
+        if (waitWhileStorageDevIsBusy(pSataChannel->mvSataAdapter,
+                                      ioBaseAddr, eDmaRegsOffset, 10, 100) ==
+            MV_FALSE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: in Issue PIO "
+                     "DATA-OUT command: disk not ready.\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber);
+            return MV_FALSE;
+        }
+
+        if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+
+            if (waitForDRQ(pSataChannel->mvSataAdapter, ioBaseAddr, eDmaRegsOffset, 500, 10000)
+                == MV_FALSE)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: DRQ bit in ATA STATUS"
+                         " register is not set\n", pSataChannel->mvSataAdapter->adapterId, pSataChannel->channelNumber);
+                return MV_FALSE;
+            }
+        }
+        /* Check the status register on DATA request commands */
+        ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & (MV_ATA_DATA_REQUEST_STATUS | MV_ATA_BUSY_STATUS | MV_ATA_ERROR_STATUS)) !=
+            MV_ATA_DATA_REQUEST_STATUS)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: in Issue PIO "
+                     "DATA-OUT command: Bad ATA STATUS:0x%02x.\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber, ATAstatus);
+            return MV_FALSE;
+        }
+
+        if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            /* Perform a dummy read */
+            MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                             MV_ATA_DEVICE_STATUS_REG_OFFSET);
+            mvMicroSecondsDelay (pSataChannel->mvSataAdapter, 1);
+        }
+        for (i = 0; i < ATA_SECTOR_SIZE_IN_WORDS; i++)
+        {
+            MV_REG_WRITE_WORD(ioBaseAddr, eDmaRegsOffset +
+                              MV_ATA_DEVICE_PIO_DATA_REG_OFFSET,
+                              *pParams->bufPtr++);
+            MV_CPU_WRITE_BUFFER_FLUSH();
+        }
+        pParams->count -= ATA_SECTOR_SIZE_IN_WORDS;
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+
+        /* for Write long only*/
+        if (pParams->count == 4)
+        {
+            if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+            {
+                /* Perform a dummy read */
+                MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+                mvMicroSecondsDelay (pSataChannel->mvSataAdapter, 1);
+            }
+            if (waitWhileStorageDevIsBusy(pSataChannel->mvSataAdapter,
+                                          ioBaseAddr, eDmaRegsOffset,
+                                          50000, 100) == MV_FALSE)
+            {
+                return MV_FALSE;
+            }
+            if (pSataChannel->mvSataAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+            {
+                if (waitForDRQ(pSataChannel->mvSataAdapter, ioBaseAddr, eDmaRegsOffset, 50000, 100)
+                    == MV_FALSE)
+                {
+                    return MV_FALSE;
+                }
+            }
+            for (i = 0; i < 4; i++)
+            {
+                MV_REG_WRITE_WORD(ioBaseAddr, eDmaRegsOffset +
+                                  MV_ATA_DEVICE_PIO_DATA_REG_OFFSET,
+                                  *pParams->bufPtr++);
+                MV_CPU_WRITE_BUFFER_FLUSH();
+
+
+                ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                             MV_ATA_DEVICE_STATUS_REG_OFFSET);
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Write Long ECC data"
+                         " xfered. ATA STATUS:0x%02x.\n",
+                         pSataChannel->mvSataAdapter->adapterId,
+                         pSataChannel->channelNumber, ATAstatus);
+            }
+            pParams->count -= 4;
+        }
+#endif /*MV_SATA_SUPPORT_READ_WRITE_LONG*/
+    }
+    return MV_TRUE;
+}
+
+/*   SATA Core API functions        */
+
+/*******************************************************************************
+* mvSataInitAdapter - initialize MV88SX50XX adapter
+*
+* DESCRIPTION:
+*   this function initializes glabal registers that concerns PCI access
+*   and Interrupts.
+*
+* INPUT:
+*   *pAdapter   - pointer to the adapter data structure.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*   The adapter will not be able yet to generate interrupts
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataInitAdapter (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U8    sataUnit;
+    MV_U8    channelIndex;
+    MV_U32  regVal;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataInitAdapter"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+
+    if (mvOsSemInit(&pAdapter->semaphore) == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+
+    if (mvOsSemInit(&pAdapter->interruptsMaskSem) == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+#ifdef MV_SATA_IO_GRANULARITY
+    if (mvOsSemInit(&pAdapter->iogSemaphore) == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+#endif
+
+    if (pAdapter->mvSataEventNotify == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d  : Bad pointer for "
+                 "mvSataEventNotify function\n", pAdapter->adapterId);
+        return MV_FALSE;
+    }
+    /* Clear main mask register to prevent adapter from generating interrupts */
+    pAdapter->mainMask = 0;
+    pAdapter->interruptsAreMasked = MV_TRUE;
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_MAIN_INTERRUPT_MASK_REG_OFFSET, pAdapter->mainMask);
+
+
+    /* Initialize the hardware information */
+    pAdapter->chipIs50XXB0 = MV_FALSE;
+    pAdapter->chipIs50XXB2 = MV_FALSE;
+    pAdapter->chipIs60X1B2 = MV_FALSE;
+    pAdapter->chipIs60X1C0 = MV_FALSE;
+    pAdapter->numberOfChannels = MV_SATA_CHANNELS_NUM;
+    pAdapter->numberOfUnits = MV_SATA_UNITS_NUM;
+
+    switch (pAdapter->pciConfigDeviceId)
+    {
+    case MV_SATA_DEVICE_ID_5080 :
+        pAdapter->sataAdapterGeneration = MV_SATA_GEN_I;
+        switch (pAdapter->pciConfigRevisionId)
+        {
+        case 0x1:
+            pAdapter->chipIs50XXB0 = MV_TRUE;
+            break;
+        case 0x3:
+            pAdapter->chipIs50XXB2 = MV_TRUE;
+            break;
+        default:
+            if (pAdapter->pciConfigRevisionId > 0x3)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         " %d : Warning: Future revision ID %02x for Device "
+                         "ID %02x.\n",
+                         pAdapter->adapterId, pAdapter->pciConfigRevisionId,
+                         pAdapter->pciConfigDeviceId);
+                pAdapter->chipIs50XXB2 = MV_TRUE;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                         " %d : Bad revision ID %02x for Device ID %02x\n",
+                         pAdapter->adapterId, pAdapter->pciConfigRevisionId,
+                         pAdapter->pciConfigDeviceId);
+                return MV_FALSE;
+            }
+        }
+        break;
+    case MV_SATA_DEVICE_ID_5041 :
+    case MV_SATA_DEVICE_ID_5040 :
+        pAdapter->numberOfChannels = MV_SATA_PORT_PER_UNIT;
+        pAdapter->numberOfUnits = 1;
+    case MV_SATA_DEVICE_ID_5081 :
+        pAdapter->sataAdapterGeneration = MV_SATA_GEN_I;
+        switch (pAdapter->pciConfigRevisionId)
+        {
+        case 0x0:
+            pAdapter->chipIs50XXB0 = MV_TRUE;
+            break;
+        case 0x3:
+            pAdapter->chipIs50XXB2 = MV_TRUE;
+            break;
+        default:
+            if (pAdapter->pciConfigRevisionId > 0x3)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : Warning: Future revis"
+                         "ion ID %02x.\n",
+                         pAdapter->adapterId, pAdapter->pciConfigRevisionId);
+                pAdapter->chipIs50XXB2 = MV_TRUE;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : Bad revisi"
+                         "on ID %02x\n",    pAdapter->adapterId,
+                         pAdapter->pciConfigRevisionId);
+                return MV_FALSE;
+            }
+        }
+        break;
+    case MV_SATA_DEVICE_ID_6041 :
+        pAdapter->numberOfChannels = MV_SATA_PORT_PER_UNIT;
+        pAdapter->numberOfUnits = 1;
+    case MV_SATA_DEVICE_ID_6081 :
+        pAdapter->sataAdapterGeneration = MV_SATA_GEN_II;
+        switch (pAdapter->pciConfigRevisionId)
+        {
+        case 0x7:/*B2*/
+            pAdapter->chipIs60X1B2 = MV_TRUE;
+            break;
+        case 0x9:/*C0*/
+            pAdapter->chipIs60X1C0 = MV_TRUE;
+            break;
+        default:
+            if (pAdapter->pciConfigRevisionId > 0x9)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : Warning:"
+                         " Future revision ID %02x.\n", pAdapter->adapterId,
+                         pAdapter->pciConfigRevisionId);
+                pAdapter->chipIs60X1C0 = MV_TRUE;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : Bad revisi"
+                         "on ID %02x\n", pAdapter->adapterId,
+                         pAdapter->pciConfigRevisionId);
+                return MV_FALSE;
+            }
+        }
+        break;
+
+    default:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : Bad device ID"
+                 " 0x%04x\n", pAdapter->adapterId,
+                 pAdapter->pciConfigDeviceId);
+        return MV_FALSE;
+
+
+
+
+
+
+
+    }
+
+    /*
+     * Save the PRE and AMP in the adapter. Also set staggared spin up to be
+     * disabled on default (60x1 only).
+     */
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d : Saving PRE and AMP values\n",
+             pAdapter->adapterId);
+    for (channelIndex = 0; channelIndex < pAdapter->numberOfChannels; channelIndex++)
+    {
+        MV_U32  PHYModeRegister;
+        pAdapter->staggaredSpinup[channelIndex] = MV_FALSE;
+        pAdapter->ifSpeed[channelIndex] = MV_SATA_IF_SPEED_NO_LIMIT;
+        pAdapter->limitInterfaceSpeed[channelIndex] = MV_FALSE;
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            PHYModeRegister = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                                MV_SATAHC_REGS_BASE_OFFSET((channelIndex & MV_BIT2) >> 2) +
+                                                MV_SATA_I_HC_PHY_MODE_BRIDGE_PORT_REG_OFFSET(channelIndex & (MV_BIT0 | MV_BIT1)));
+            pAdapter->signalAmps[channelIndex] = (MV_U8)((PHYModeRegister & MV_SATA_I_PHY_MODE_AMP_MASK) >> MV_SATA_I_PHY_MODE_AMP_OFFSET);
+            pAdapter->pre[channelIndex] = (MV_U8)((PHYModeRegister & MV_SATA_I_PHY_MODE_PRE_MASK) >> MV_SATA_I_PHY_MODE_PRE_OFFSET);
+        }
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+
+            MV_U32 resetConfigReg =
+            MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                               MV_RESET_CONFIG_REG_OFFSET);
+
+            /*
+             * Check if TWSI serial ROM initialization was triggered.
+             * If so, then PRE/AMP configuration probably are set after
+             * reset by serial ROM. If not then override the PRE/AMP
+             * values.
+             */
+            if (resetConfigReg & MV_RESET_CONFIG_TWSI_INIT_MASK)
+            {
+
+                MV_U32 phyMode2Offset = getEdmaRegOffset(channelIndex) +
+                                        MV_SATA_II_PHY_MODE_2_REG_OFFSET;
+                /* Make sure EDMA is off */
+                MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                    getEdmaRegOffset (channelIndex) +
+                                    MV_EDMA_COMMAND_REG_OFFSET,
+                                    MV_EDMA_COMMAND_DISABLE_MASK);
+                MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                   getEdmaRegOffset(channelIndex) +
+                                   MV_EDMA_COMMAND_REG_OFFSET);
+                regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                           phyMode2Offset);
+                pAdapter->signalAmps[channelIndex] =
+                (MV_U8)((regVal & MV_SATA_II_PHY_MODE_2_AMP_MASK) >>
+                        MV_SATA_II_PHY_MODE_2_AMP_OFFSET);
+                pAdapter->pre[channelIndex] =
+                (MV_U8)((regVal & MV_SATA_II_PHY_MODE_2_PRE_MASK) >>
+                        MV_SATA_II_PHY_MODE_2_PRE_OFFSET);
+            }
+            else
+            {
+                pAdapter->signalAmps[channelIndex] = 0x7;
+                pAdapter->pre[channelIndex] = 0x1;
+            }
+
+        }
+    }
+
+    /* Revert the registers to it's default value (software reset) */
+    revertSataHCRegs (pAdapter);
+    revertFlashInterfaceRegs (pAdapter);
+    revertPCIInterfaceRegs(pAdapter);
+
+    /* Enable the SATA LEDs if the silicon revision is B0 */
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d : Enabling SATA LEDS\n",
+                 pAdapter->adapterId);
+        /* Enable the SATA leds */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_FLASH_GPIO_PORT_CONTROL_OFFSET, 0x0);
+        if (pAdapter->chipIs50XXB2 == MV_TRUE)
+        {
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       MV_FLASH_GPIO_PORT_CONTROL_OFFSET);
+            for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+                channelIndex ++)
+            {
+                if (mvSataIsStorageDeviceConnected (pAdapter,channelIndex) == MV_FALSE)
+                {
+                    regVal |= (MV_BIT8 << channelIndex);
+                }
+            }
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                MV_FLASH_GPIO_PORT_CONTROL_OFFSET,
+                                regVal);
+        }
+        /* disable Flash controller clock*/
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_PCI_REGS_OFFSET +
+                                   MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET);
+
+        regVal &= ~(MV_BIT0);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_PCI_REGS_OFFSET + MV_PCI_EXPANSION_ROM_CONTROL_REG_OFFSET,
+                           regVal);
+    }
+
+    /* Enable the SATA LEDs for 88SX60X1 devices */
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d : Enabling SATA LEDS\n",
+                 pAdapter->adapterId);
+        /* Enable the SATA leds */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_FLASH_GPIO_PORT_CONTROL_OFFSET, 0x00000060);
+
+    }
+
+    /* Check if working in PCI-X mode, then disable all conventional PCI */
+    /* features */
+
+    regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_PCI_REGS_OFFSET + MV_PCI_MODE_REG_OFFSET);
+    if (((regVal & MV_PCI_MODE_MASK) >> MV_PCI_MODE_OFFSET) != 0) /* PCI-X */
+    {
+        if (pAdapter->pciCommand & MV_PCI_COMMAND_PCI_CONVENTIONAL_ONLY)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d : disable pci conventio"
+                     "nal features when working in PCI-X. pciCommand origin"
+                     "al value:0x%08x. new value: 0x%08x.\n",
+                     pAdapter->adapterId,
+                     pAdapter->pciCommand, pAdapter->pciCommand &
+                     (~MV_PCI_COMMAND_PCI_CONVENTIONAL_ONLY));
+            pAdapter->pciCommand &= ~MV_PCI_COMMAND_PCI_CONVENTIONAL_ONLY;
+        }
+        if ((pAdapter->chipIs50XXB0 == MV_TRUE) ||
+            (pAdapter->chipIs50XXB2 == MV_TRUE) ||
+            (pAdapter->chipIs60X1B2 == MV_TRUE))
+        {
+            /* PHI1*/
+            /* PHII7*/
+            if (pAdapter->pciCommand & MV_PCI_MWRITE_COMBINE_BIT)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d  : PCI-X Master"
+                         " Write combine enable rejected\n",
+                         pAdapter->adapterId);
+                pAdapter->pciCommand &= ~MV_PCI_MWRITE_COMBINE_BIT;
+            }
+        }
+    }
+    else
+    {
+        if ((pAdapter->chipIs50XXB0 == MV_TRUE) ||
+            (pAdapter->chipIs50XXB2 == MV_TRUE))
+        {
+            /* PHI2*/
+            if (pAdapter->pciCommand & MV_PCI_MWRITE_COMBINE_BIT)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d  : PCI Master"
+                         " Write combine enable rejected\n",
+                         pAdapter->adapterId);
+                pAdapter->pciCommand &= ~MV_PCI_MWRITE_COMBINE_BIT;
+            }
+            if (pAdapter->pciCommand & MV_PCI_MREAD_COMBINE_BIT)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d  : PCI Master"
+                         " Read combine enable rejected\n",
+                         pAdapter->adapterId);
+                pAdapter->pciCommand &= ~MV_PCI_MREAD_COMBINE_BIT;
+            }
+        }
+    }
+
+    /* SHII8*/
+    for (channelIndex = 0; channelIndex < pAdapter->numberOfChannels; channelIndex++)
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        getEdmaRegOffset (channelIndex) +
+                                        MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+            /* SHII8*/
+            regVal |= MV_BIT12;
+
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                getEdmaRegOffset (channelIndex) +
+                                MV_SATA_II_SATA_CONFIG_REG_OFFSET,
+                                regVal);
+            /* _channelHardReset(pAdapter, channelIndex);*/
+        }
+
+        _fixPhyParams(pAdapter, channelIndex);
+    }
+
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_PCI_REGS_OFFSET + MV_PCI_COMMAND_REG_OFFSET,
+                       pAdapter->pciCommand);
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_PCI_REGS_OFFSET + MV_PCI_SERR_MASK_REG_OFFSET,
+                       pAdapter->pciSerrMask);
+
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_PCI_REGS_OFFSET + MV_PCI_INTERRUPT_MASK_REG_OFFSET,
+                       pAdapter->pciInterruptMask);
+
+    for (sataUnit = 0; sataUnit < pAdapter->numberOfUnits; sataUnit++)
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INT_COAL_THRE_REG_OFFSET,
+                           pAdapter->intCoalThre[sataUnit]);
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INT_TIME_THRE_REG_OFFSET,
+                           pAdapter->intTimeThre[sataUnit]);
+
+
+
+
+
+
+
+    }
+    pAdapter->mainMask = MV_MAIN_INTERRUPT_MASK_ENABLE_ALL;
+    pAdapter->interruptsScheme = MV_SATA_INTERRUPT_HANDLING_IN_ISR;
+
+    for (channelIndex = 0; channelIndex < pAdapter->numberOfChannels; channelIndex++)
+    {
+        unmaskEdmaInterrupts(pAdapter, channelIndex);
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataShutDownAdapter - Shuts down adapter.
+*
+* DESCRIPTION: Shuts down a specific 88SX50xx adapter.
+*
+* INPUT:
+*   *pAdapter   - pointer to the adapter data structure.
+*
+* OUTPUT:
+*   None.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE on failure
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataShutdownAdapter(MV_SATA_ADAPTER *pAdapter)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataShutdownAdapter Failed, Bad adapter data structure "
+                 "pointer\n");
+        return MV_FALSE;
+    }
+    pAdapter->interruptsAreMasked = MV_TRUE;
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_MAIN_INTERRUPT_MASK_REG_OFFSET, 0);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataReadReg - return the value of register.
+*
+* DESCRIPTION:
+*   return the value of a register, which have the offset regOffset, in a
+*   MV88SX50XX adapter.
+*   Note that if reading from storage device's internal registers and EDMA
+*   is enabled, then the read transaction will never complete and possibly
+*   cause system hang.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*       regOffset   - offset of the register
+*
+* RETURN:
+*   the register value in 32 bit.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_U32     mvSataReadReg(MV_SATA_ADAPTER *pAdapter, MV_U32 regOffset)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataReadReg Failed,"
+                 " Bad adapter data structure pointer\n");
+        return 0;
+    }
+
+    return MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, regOffset);
+}
+
+/*******************************************************************************
+* mvSataWriteReg - return the value of register.
+*
+* DESCRIPTION:
+*   write the regValue to a register, which have the offset regOffset, in a
+*   MV88SX50XX adapter.
+*   Note that if writing to storage device's internal registers and EDMA
+*   is enabled, then the write transaction will never complete and possibly
+*   cause system hang.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*       regOffset   - offset of the register
+*   regValue    - the value to write to the register
+*
+* RETURN:
+*   None.
+* COMMENTS:
+*   for 8 or 16 bit registers the low bits of the regValue should hold the
+*   requested value to be written.
+*
+*******************************************************************************/
+MV_VOID mvSataWriteReg(MV_SATA_ADAPTER *pAdapter, MV_U32 regOffset,
+                       MV_U32 regValue)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataWriteReg Failed,"
+                 " Bad adapter data structure pointer\n");
+        return;
+    }
+
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, regOffset, regValue);
+}
+/*******************************************************************************
+* mvSataConfigureChannel - configure Sata channel
+*
+*
+* DESCRIPTION:
+*   this function configures SATA channel by resetting the low level fields
+*   of the channel data structure and configures EDMA regs accourdingly
+*
+* INPUT:
+*   pAdapter   - pointer to the MV88SX50XX adapter data structure
+*   channelIndex    - the index of the channel where the response received
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataConfigureChannel(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL     *pSataChannel;
+    MV_BOOLEAN          result;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataConfigureChannel"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataConfigureChann"
+                 "el Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    if (pAdapter->numberOfChannels <= channelIndex)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataConfigureChann"
+                 "el Failed - requsted to configure a non-valid channel\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    pSataChannel->eDmaRegsOffset = getEdmaRegOffset(channelIndex);
+    pSataChannel->mvSataAdapter = pAdapter;
+
+    if (mvOsSemInit(&pSataChannel->semaphore)==MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    /* Sets the request and response queues base addresses */
+    pSataChannel->queueCommandsEnabled = MV_FALSE;
+    pSataChannel->EdmaActive = MV_FALSE;
+    pSataChannel->deviceType = MV_SATA_DEVICE_TYPE_UNKNOWN;
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        pSataChannel->PMSupported = MV_TRUE;
+    }
+    else
+    {
+        pSataChannel->PMSupported = MV_FALSE;
+    }
+    pSataChannel->DRQDataBlockSize = 1;
+    result = resetEdmaChannel(pSataChannel);
+    disableSaDevInterrupts(pAdapter, channelIndex);
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return result;
+}
+
+/*******************************************************************************
+* mvSataRemoveChannel -
+*
+* DESCRIPTION:  Removes data structures and other parameters used for the
+*   specific SATA channel that is indicated by pAdapter and channelIndex.
+*
+* INPUT:
+*   pAdapter - A pointer to an MV_SATA_ADAPTER data structure that holds
+*                information to access the 88SX50xx device.
+*   channelIndex - An index to a specific 88SX50xx channel.
+* OUTPUT:
+*   None.
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataRemoveChannel(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL     *pSataChannel;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataRemoveChannel"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pAdapter->semaphore);
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataRemoveChannel"
+                 " Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pAdapter->semaphore);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataRemoveChannel "
+                 "failed, DMA is enabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        mvOsSemRelease(&pAdapter->semaphore);
+        return MV_FALSE;
+    }
+    mvOsSemRelease(&pSataChannel->semaphore);
+    mvOsSemRelease(&pAdapter->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataIsStorageDeviceConnected - Check if storage device is connected to a
+*                                  SATA channel.
+*
+* DESCRIPTION:
+*       This function reads the DET field from the R00 status bridge register
+*       of the corresponding channel.
+*
+* INPUT:
+*       pAdapter     - Pointer to the device data structure.
+*       channelIndex - Index of the required channel
+*
+* RETURN:
+*       MV_TRUE when storage device is connected, MV_FALSE otherwise( also when
+*       loopback mode is used).
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataIsStorageDeviceConnected(MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex)
+{
+    MV_U32  SStatusOffset = 0;
+    MV_U32  det;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataIsStorageDeviceConnected Failed, Bad adapter data"
+                 " structure pointer\n");
+        return MV_FALSE;
+    }
+
+    if (pAdapter->numberOfChannels <= channelIndex)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: "
+                 "mvSataIsStorageDeviceConnected Failed, Bad channelIndex "
+                 " input on a 0x%x adapterstructure pointer\n",
+                 pAdapter->adapterId,channelIndex,pAdapter->pciConfigDeviceId);
+        return MV_FALSE;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        MV_U8   sataUnit = (channelIndex & MV_BIT2) >> 2;
+        MV_U8   port = channelIndex & (MV_BIT0 | MV_BIT1);
+        SStatusOffset = MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                        MV_SATA_I_HC_R00_STATUS_BRIDGE_PORT_OFFSET(port);
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        SStatusOffset = getEdmaRegOffset(channelIndex) +
+                        MV_SATA_II_S_STATUS_REG_OFFSET;
+        if (pAdapter->staggaredSpinup[channelIndex] == MV_FALSE)
+        {
+            return MV_FALSE;
+        }
+    }
+
+    det = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                             SStatusOffset) & 0xf;
+
+    switch (det)
+    {
+    case MV_PHY_DET_STATE_NO_DEVICE:
+        break;
+    case MV_PHY_DET_STATE_DEVICE_NO_PHY_COM:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " %d %d: Detection value is 1\n", pAdapter->adapterId,
+                 channelIndex);
+
+        MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                          SStatusOffset);
+        mvMicroSecondsDelay(pAdapter, MV_PHY_COM_SETUP_WAIT);
+        det = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                SStatusOffset) & 0xf;
+        if (det != MV_PHY_DET_STATE_DEVICE_AND_PHY_COM)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Failed to"
+                     " establish SATA PHY communication\n",
+                     pAdapter->adapterId, channelIndex);
+            break;
+        }
+    case MV_PHY_DET_STATE_DEVICE_AND_PHY_COM:
+        return MV_TRUE;
+    case MV_PHY_DET_STATE_PHY_OFFLINE:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INIT, " %d %d: WARNING: SATA PHY is "
+                 "offline\n", pAdapter->adapterId, channelIndex);
+        break;
+    default:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: unknow value for\
+                      R00 Status Bridge reg bits[3:0] (0x%02x)\n",
+                 pAdapter->adapterId, channelIndex, det);
+    }
+    return MV_FALSE;
+}
+
+
+static MV_BOOLEAN _checkSStatusAfterHReset(MV_SATA_ADAPTER* pAdapter,
+                                           MV_U8 channelIndex)
+{
+    MV_U32 SStatusOffset;
+    MV_U32  SStatus;
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        /*  Get DET field in SControl register to 1 */
+        MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+        MV_U8       sataUnit = (channelIndex & MV_BIT2) >> 2;
+        SStatusOffset = MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                        MV_SATA_I_HC_R00_STATUS_BRIDGE_PORT_OFFSET(port);
+    }
+    else
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            SStatusOffset = getEdmaRegOffset(channelIndex) +
+                            MV_SATA_II_S_STATUS_REG_OFFSET;
+        }
+        else
+        {
+            return MV_TRUE;
+        }
+    }
+    SStatus = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                SStatusOffset);
+    SStatus &= (MV_BIT0 | MV_BIT1);
+    if ((SStatus == (MV_BIT0 | MV_BIT1)) || (SStatus == 0))
+    {
+        return MV_TRUE;
+    }
+    else
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: in Channel Hard "
+                 "Reset SATA communication not established.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+}
+
+
+/*******************************************************************************
+* mvSataChannelHardReset - issue channel SATA HARD reset.
+*
+* DESCRIPTION:
+*   perform HARDWARE RESET to the connected device by asserting the RESET
+*   signal, this is done by setting the hardware reset bit of the EDMA
+*   command register
+*
+* INPUT:
+*   pAdapter    - pointer to the device data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataChannelHardReset(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32  eDmaRegsOffset;
+    MV_U32      count = 0;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataChannelHardReset"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: "
+                 "mvSataChannelHardReset Failed, channel data structure not "
+                 "allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: Error:\
+                 mvSataIChannelHardReset called while EDMA is active\n",
+                 pAdapter->adapterId,channelIndex);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Issue HRST\n", pAdapter->adapterId,
+             channelIndex);
+
+
+    _channelHardReset(pAdapter, channelIndex);
+    if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_II) &&
+        (pAdapter->staggaredSpinup[channelIndex] == MV_FALSE))
+    {
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_TRUE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        while (1)
+        {
+            _establishSataComm(pAdapter, channelIndex);
+
+            /* try the DET fix 3 times */
+            if (_checkSStatusAfterHReset(pAdapter, channelIndex) == MV_FALSE)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: in Channel Hard "
+                         "Reset storage drive is not ready, try fix #%d\n",
+                         pAdapter->adapterId, channelIndex, count);
+
+                count++;
+                if (count == 3)
+                {
+                    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: in Channel H"
+                             "ard Reset storage drive is not ready after 3 tries\n",
+                             pAdapter->adapterId, channelIndex);
+                    mvOsSemRelease( &pSataChannel->semaphore);
+                    return MV_FALSE;
+                }
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK, " %d %d: Disk is Ready After"
+                         " Hard Reset\n", pAdapter->adapterId, channelIndex);
+                break;
+            }
+        }
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        _establishSataComm(pAdapter, channelIndex);
+    }
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return MV_TRUE;
+}
+/*******************************************************************************
+* mvSataConfigEdmaMode - set EDMA operating mode.
+*
+* DESCRIPTION:
+*   Set the EDMA operating mode - MV_EDMA_MODE_NOT_QUEUED,
+*   MV_EDMA_MODE_QUEUED or MV_EDMA_MODE_NATIVE_QUEUING.
+*   When set toe MV_EDMA_MODE_QUEUED or MV_EDMA_MODE_NATIVE_QUEUING then
+*   the maxQueueDepth should be valud.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*   eDmaMode    - the selected mode
+*   maxQueueDepth   - the maximum depth of the queue
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataConfigEdmaMode(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                                MV_EDMA_MODE eDmaMode, MV_U8 maxQueueDepth)
+{
+    MV_SATA_CHANNEL  *pSataChannel;
+    MV_BUS_ADDR_T  ioBaseAddr;
+    MV_U32 eDmaRegsOffset;
+    MV_U32     val;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataConfigEdmaMode"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataConfigEdmaMode"
+                 " Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    mvOsSemTake(&pSataChannel->semaphore);
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," %d %d: mvSataConfigEdmaMode failed,"
+                 " EDMA is enabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    val = MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                            MV_EDMA_CONFIG_REG_OFFSET);
+    if (eDmaMode == MV_EDMA_MODE_NATIVE_QUEUING)
+    {
+        if ((maxQueueDepth > MV_EDMA_QUEUE_LENGTH) ||  (maxQueueDepth == 0))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR," %d %d: mvSataConfigEdmaMode "
+                     "failed, Bad queue depth(%d)\n", pAdapter->adapterId,
+                     channelIndex, maxQueueDepth);
+            mvOsSemRelease(&pSataChannel->semaphore);
+            return MV_FALSE;
+        }
+        if (pAdapter->sataAdapterGeneration != MV_SATA_GEN_II)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: Trying to configure "
+                     "EDMA to NCQ on a non NCQ enabled EDMA\n",
+                     pAdapter->adapterId, channelIndex);
+            mvOsSemRelease(&pSataChannel->semaphore);
+            return MV_FALSE;
+        }
+        val &= ~MV_EDMA_CONFIG_Q_DEPTH_MASK; /* clear queue depth */
+        /* set the NCQ enable mode bit, and the queue depth bits*/
+        val |= MV_EDMA_CONFIG_NATIVE_QUEUING_MASK | (maxQueueDepth - 1);
+        val |= MV_EDMA_CONFIG_CONONDEVERR_MASK;
+
+        /* unmask DevErr */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           getEdmaRegOffset(channelIndex) +
+                           MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET,
+                           MV_EDMA_GEN_II_ERROR_MASK | MV_BIT2);
+    }
+    else
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               getEdmaRegOffset(channelIndex) +
+                               MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET,
+                               MV_EDMA_GEN_II_ERROR_MASK);
+        }
+    }
+
+    if (eDmaMode == MV_EDMA_MODE_QUEUED)
+    {
+        if ((maxQueueDepth > MV_EDMA_QUEUE_LENGTH) ||  (maxQueueDepth == 0))
+        {
+            mvOsSemRelease(&pSataChannel->semaphore);
+            return MV_FALSE;
+        }
+        val &= ~MV_EDMA_CONFIG_Q_DEPTH_MASK; /* clear queue depth */
+        val &= ~MV_EDMA_CONFIG_NATIVE_QUEUING_MASK; /* clear NCQ mode*/
+        val &= ~MV_EDMA_CONFIG_CONONDEVERR_MASK;
+        /* set the queue enable mode bit, and the queue depth bits*/
+        val |= MV_EDMA_CONFIG_EQUEUE_ENABLED_MASK | (maxQueueDepth - 1);
+    }
+
+    if (eDmaMode == MV_EDMA_MODE_NOT_QUEUED)
+    {
+        val &= ~MV_EDMA_CONFIG_Q_DEPTH_MASK; /* clear queue depth */
+        val &= ~MV_EDMA_CONFIG_NATIVE_QUEUING_MASK; /* clear NCQ mode*/
+        val &= ~MV_EDMA_CONFIG_EQUEUE_ENABLED_MASK;
+        val &= ~MV_EDMA_CONFIG_CONONDEVERR_MASK;
+    }
+    pSataChannel->queuedDMA = eDmaMode;
+
+
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        val |= MV_EDMA_CONFIG_BURST_SIZE_MASK;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        val |= (MV_EDMA_CONFIG_BURST_SIZE_EXT_MASK | MV_BIT13);
+    }
+
+    MV_REG_WRITE_DWORD(ioBaseAddr, eDmaRegsOffset + MV_EDMA_CONFIG_REG_OFFSET,
+                       val);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG," %d %d: Edma Configuration Reg Value: 0x%08x\n",
+             pAdapter->adapterId, channelIndex,
+             MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                               MV_EDMA_CONFIG_REG_OFFSET));
+
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataEnableChannelDma - enable EDMA engine
+*
+* DESCRIPTION:
+*   enable the EDMA engine for the given channel
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataEnableChannelDma(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL  *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataEnableChannelDma"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataEnableChannelD"
+                 "ma Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex );
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataEnableChannelDma "
+                 "failed, DMA is enabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+#ifdef MV_SATA_C2C_COMM
+    /* C2C */
+    if (pSataChannel->C2CmodeEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataEnableChannelDma "
+                 "failed, C2C mode is enabled\n", pAdapter->adapterId,
+                 channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+#endif
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: mvSataEnableChannelDma\n",
+             pAdapter->adapterId, channelIndex);
+    pSataChannel->queueCommandsEnabled = MV_TRUE;
+    activateEdma(pAdapter,channelIndex);
+
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataDisableChannelDma - disable EDMA engine
+*
+* DESCRIPTION:
+*   disable the EDMA engine for the given channel
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataDisableChannelDma(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex)
+{
+    MV_BUS_ADDR_T   ioBaseAddr;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataDisableChannelDma"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    if (pAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataDisableChannel"
+                 "Dma Failed, channel data structure is not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: mvSataDisableChannel\n",
+             pAdapter->adapterId, channelIndex);
+    mvOsSemTake(&pAdapter->sataChannel[channelIndex]->semaphore);
+    pAdapter->sataChannel[channelIndex]->queueCommandsEnabled = MV_FALSE;
+    deactivateEdma(pAdapter,channelIndex);
+    mvOsSemRelease(&pAdapter->sataChannel[channelIndex]->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataFlushDmaQueue - flush the outstanding UDMA commands
+*
+* DESCRIPTION:
+*   flush posted UDMA ATA commands on a certain MV88SX50XX SATA channel. if
+*   the flush type is MV_FLUSH_TYPE_CALLBACK then all call back functions of
+*   the UDMA commands are called with a flush indication.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*   flushType   - indicates wheather to call the callBack function or not.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataFlushDmaQueue(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                               MV_FLUSH_TYPE flushType)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataFlushDmaQueue"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataFlushDmaQueue "
+                 "Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataFlushDmaQueue "
+                 "Failed, EDMA not disabled\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    flushDmaQueue(pSataChannel, flushType, MV_COMPLETION_TYPE_ABORT, 0);
+    resetEdmaChannel(pSataChannel);
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataNumOfDmaCommands - get the number of the outstanding commmands for the
+*                           given channel
+*
+* DESCRIPTION:
+*   return the number of posted ATA commands on an EDMA engine for a
+*   specific SATA channel.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   num of queue commands.
+* COMMENTS:
+*   NONE
+*
+*******************************************************************************/
+MV_U8 mvSataNumOfDmaCommands(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_U8           result;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataNumOfDmaCommands"
+                 " Failed, Bad adapter data structure pointer\n");
+        return 0xFF;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataNumOfDmaComman"
+                 "ds Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return 0xFF;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    result = pSataChannel->outstandingCommands;
+    mvOsSemRelease(&pSataChannel->semaphore);
+
+    return result;
+}
+/*******************************************************************************
+* mvSataGetNumOfPortQueuedCommands - get the number of the outstanding commmands for
+*                               the given port
+*
+* DESCRIPTION:
+*   return the number of posted ATA commands on an EDMA engine for a
+*   specific SATA port.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*   PMPort      - port number
+*   pCommandsPerChannel - if not null, gets the total number of outstanding
+*                   command for the given channel
+*
+* RETURN:
+*   num of queue commands, 0xFF if error detected.
+* COMMENTS:
+*
+*
+*******************************************************************************/
+MV_U8 mvSataGetNumOfPortQueuedCommands(MV_SATA_ADAPTER *pAdapter,
+                                       MV_U8 channelIndex,
+                                       MV_U8 PMPort,
+                                       MV_U8 *pCommandsPerChannel)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_U8           result;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataGetNumOfPortQueuedCommands"
+                 " Failed, Bad adapter data structure pointer\n");
+        return 0xFF;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d %d: mvSataGetNumOfPortQueuedCommands"
+                 "ds Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex, PMPort);
+        return 0xFF;
+    }
+    if (PMPort > MV_SATA_PM_MAX_PORTS)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d %d: mvSataGetNumOfPortQueuedCommands"
+                 "ds Failed, non valid port\n",
+                 pAdapter->adapterId, channelIndex, PMPort);
+        return 0xFF;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    result = pSataChannel->portQueuedCommands[PMPort];
+    if (pCommandsPerChannel)
+    {
+        *pCommandsPerChannel = pSataChannel->outstandingCommands;
+    }
+    mvOsSemRelease(&pSataChannel->semaphore);
+
+    return result;
+}
+
+/*******************************************************************************
+* mvSataSetIntCoalParams - update the interrupt Coalescing registers
+*
+* DESCRIPTION:  Sets the interrupt coalescing for a specific SATA unit
+*               (each SATA unit contains quad SATA channels).
+*
+* INPUT:
+*   pAdapter - pointer to the adapter data structure.
+*   sataUnit - which SATA unit to be changed (0xff for all SATA ports)
+*   intCoalThre - the value to be written to the Coalescing threshold register
+*   intTimeThre - the value to be written to the Time threshold register
+*
+* OUTPUT:
+*   None.
+* RETURN:
+*   MV_TRUE
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataSetIntCoalParams (MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                   MV_U32 intCoalThre, MV_U32 intTimeThre)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataSetIntCoalParams"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+
+    if ((sataUnit != 0) && (sataUnit != 1) && (sataUnit != 0xff))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d  : %d Bad"
+                 " unit number\n", pAdapter->adapterId, sataUnit);
+        return MV_FALSE;
+    }
+
+    mvOsSemTake(&pAdapter->semaphore);
+    if (sataUnit == 0xff)
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATA_II_ALL_PORTS_INT_COAL_CMND_THR_REG_OFFSET,
+                               intCoalThre);
+
+            pAdapter->intCoalThre[0] = intCoalThre;
+            pAdapter->intCoalThre[1] = intCoalThre;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATA_II_ALL_PORTS_INT_COAL_TIME_THR_REG_OFFSET,
+                               intTimeThre);
+            pAdapter->intTimeThre[0] = intTimeThre;
+            pAdapter->intTimeThre[1] = intTimeThre;
+            pAdapter->mainMask |= MV_BIT21;
+            pAdapter->mainMask &= ~(MV_BIT17 | MV_BIT8);
+        }
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+        {
+            MV_U8 count;
+            for (count = 0 ; count < pAdapter->numberOfUnits ; count ++)
+            {
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_SATAHC_REGS_BASE_OFFSET(count) +
+                                   MV_SATAHC_INT_COAL_THRE_REG_OFFSET,
+                                   intCoalThre);
+
+                pAdapter->intCoalThre[count] = intCoalThre;
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_SATAHC_REGS_BASE_OFFSET(count) +
+                                   MV_SATAHC_INT_TIME_THRE_REG_OFFSET,
+                                   intTimeThre);
+                pAdapter->intTimeThre[count] = intTimeThre;
+            }
+        }
+    }
+    else
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INT_COAL_THRE_REG_OFFSET,
+                           intCoalThre);
+
+        pAdapter->intCoalThre[sataUnit] = intCoalThre;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATAHC_INT_TIME_THRE_REG_OFFSET,
+                           intTimeThre);
+        pAdapter->intTimeThre[sataUnit] = intTimeThre;
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            pAdapter->mainMask |= (MV_BIT17 | MV_BIT8);
+            pAdapter->mainMask &= ~MV_BIT21;
+        }
+    }
+    if (pAdapter->interruptsAreMasked == MV_FALSE)
+    {
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                           pAdapter->mainMask);
+
+        MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                          MV_MAIN_INTERRUPT_MASK_REG_OFFSET);
+
+
+
+
+
+
+
+    }
+    mvOsSemRelease(&pAdapter->semaphore);
+
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataSetChannelPhyParams - update the channel's Sata Phy params
+*
+* DESCRIPTION: This functoin changes the Sata Phy params such as the AMP and
+*       PRE by updating the PHY Mode register.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex- index of the Edma channel number.
+*   signalAmps  - three bits value to be written to the Phy Mode register at
+*                   bits[7:5]
+*   pre         - two bits value to be written to the Phy Mode register at
+*                   bits[12:11]
+*
+* OUTPUT:
+*   None.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FASLE otherwisw
+*
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataSetChannelPhyParams(MV_SATA_ADAPTER *pAdapter,
+                                     MV_U8 channelIndex,
+                                     MV_U8 signalAmps, MV_U8 pre)
+{
+    MV_U32          regAddr;
+    MV_U32          val;
+    MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+    MV_U8       unit = (channelIndex & MV_BIT2) >> 2;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "  : mvSataSetChannelPhyParam"
+                 "s Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        if ((signalAmps & 0xf8) || (pre & 0xfc))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: "
+                     "mvSataSetChannelPhyParams Failed. Bad params\n",
+                     pAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+        }
+
+        regAddr = MV_SATAHC_REGS_BASE_OFFSET(unit) +
+                  MV_SATA_I_HC_PHY_MODE_BRIDGE_PORT_REG_OFFSET(port);
+
+        val = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, regAddr);
+
+        val &= ~MV_SATA_I_PHY_MODE_AMP_MASK;
+        val |= (signalAmps << MV_SATA_I_PHY_MODE_AMP_OFFSET) &
+               MV_SATA_I_PHY_MODE_AMP_MASK;
+
+        val &= ~MV_SATA_I_PHY_MODE_PRE_MASK;
+        val |= (pre << MV_SATA_I_PHY_MODE_PRE_OFFSET) &
+               MV_SATA_I_PHY_MODE_PRE_MASK;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, regAddr, val);
+        pAdapter->pre[channelIndex] = pre;
+        pAdapter->signalAmps[channelIndex] = signalAmps;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        if ((signalAmps & 0xf8) || (pre & 0xf8))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: "
+                     "mvSataSetChannelPhyParams Failed. Bad params\n",
+                     pAdapter->adapterId, channelIndex);
+            return MV_FALSE;
+        }
+
+
+        pAdapter->pre[channelIndex] = pre;
+        pAdapter->signalAmps[channelIndex] = signalAmps;
+        regAddr = getEdmaRegOffset(channelIndex) +
+                  MV_SATA_II_PHY_MODE_2_REG_OFFSET;
+        val = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, regAddr);
+
+        val &= ~MV_SATA_II_PHY_MODE_2_AMP_MASK;
+        val |= (signalAmps << MV_SATA_II_PHY_MODE_2_AMP_OFFSET) &
+               MV_SATA_II_PHY_MODE_2_AMP_MASK;
+        val &= ~MV_SATA_II_PHY_MODE_2_PRE_MASK;
+        val |= (pre << MV_SATA_II_PHY_MODE_2_PRE_OFFSET) &
+               MV_SATA_II_PHY_MODE_2_PRE_MASK;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, regAddr, val);
+    }
+
+    return MV_TRUE;
+}
+/*******************************************************************************
+* mvSataChannelPhyShutdown -
+*
+* DESCRIPTION: Shutdown the sata Phy of the given channel.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise
+*
+* COMMENTS:
+*   After shutdown no connect / disconnect indication will be available.
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataChannelPhyShutdown(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex)
+{
+    MV_U32      regVal;
+    MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+    MV_U8       sataUnit = (channelIndex & MV_BIT2) >> 2;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "  : mvSataChannelPhyShutdown"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                    getEdmaRegOffset (channelIndex) +
+                                    MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+        /* SHII8*/
+        regVal |= MV_BIT12;
+
+        regVal |=  MV_BIT9;
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            getEdmaRegOffset (channelIndex) +
+                            MV_SATA_II_SATA_CONFIG_REG_OFFSET,
+                            regVal);
+        return MV_TRUE;
+    }
+    regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET);
+    regVal |=  MV_SATA_I_TEST_CONTROL_PHY_SHUTDOWN_MASK(port);
+
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET, regVal);
+    MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                      MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                      MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET);
+    return MV_TRUE;
+}
+/*******************************************************************************
+* mvSataChannelPhyPowerOn -
+*
+* DESCRIPTION: power on the sata Phy of the given channel.
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataChannelPhyPowerOn(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex)
+{
+    MV_U32      regVal;
+    MV_U8       port = channelIndex & (MV_BIT0 | MV_BIT1);
+    MV_U8       sataUnit = (channelIndex & MV_BIT2) >> 2;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "  : mvSataChannelPhyPowerOn"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                    getEdmaRegOffset (channelIndex) +
+                                    MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+        /* SHII8*/
+        regVal |= MV_BIT12;
+
+        regVal &= ~(MV_BIT9);
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                            getEdmaRegOffset (channelIndex) +
+                            MV_SATA_II_SATA_CONFIG_REG_OFFSET,
+                            regVal);
+        _fixPhyParams (pAdapter,channelIndex);
+        return MV_TRUE;
+    }
+    _fixPhyParams(pAdapter, channelIndex);
+    regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "  : %d %d %d mvSataChannelPhyPowerOn"
+             " reg[%x] = 0x%x -> 0x%x\n", pAdapter->adapterId, sataUnit, port,
+             MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+             MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET, regVal,
+             regVal & ~(MV_SATA_I_TEST_CONTROL_PHY_SHUTDOWN_MASK(port)));
+    regVal &=  ~(MV_SATA_I_TEST_CONTROL_PHY_SHUTDOWN_MASK(port));
+
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET, regVal);
+    MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                      MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                      MV_SATA_I_HC_BRIDGES_TEST_CONTROL_REG_OFFSET);{
+        MV_U32 temp = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                        MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                        MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port));
+        temp &= ~0xf;
+        temp |= MV_BIT0;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port), temp);
+    }
+    _fixPhyParams(pAdapter, channelIndex);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataChannelFarLoopbackDiagnostic - do far end loopback
+*
+* DESCRIPTION: operate the far-end LB mode on the bridge
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - index of the required channel
+*
+* OUTPUT:
+*   None.
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise
+* COMMENTS:
+*   None.
+*******************************************************************************/
+
+MV_BOOLEAN mvSataChannelFarLoopbackDiagnostic(MV_SATA_ADAPTER *pAdapter,
+                                              MV_U8 channelIndex)
+{
+    MV_U8   sataUnit = (channelIndex & MV_BIT2) >> 2;
+    MV_U8   port = channelIndex & (MV_BIT0 | MV_BIT1);
+    MV_U32  regVal, temp;
+    MV_U32  tryCount, pollCount;
+    MV_BOOLEAN  result = MV_TRUE;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "  : mvSataChannelFarLoopback"
+                 "Diagnostic Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        /* TODO - Add support for far end loopback */
+        return MV_TRUE;
+    }
+
+    for (tryCount = 0; tryCount < 5; tryCount++)
+    {
+
+        /* Set Far-end loopback */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATA_I_HC_R04_STATUS_BRIDGE_PORT_OFFSET(port),
+                           0x00100000);
+        /* BIST pattern */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATA_I_HC_R05_STATUS_BRIDGE_PORT_OFFSET(port),
+                           0xb5b5b5b5);
+        /* BIST pattern */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATA_I_HC_R06_STATUS_BRIDGE_PORT_OFFSET(port),
+                           0xb5b5b5b5);
+        /* enable BIST */
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                           MV_SATA_I_HC_R0F_STATUS_BRIDGE_PORT_OFFSET(port),
+                           0x00200000);
+
+        mvMicroSecondsDelay(pAdapter, MV_FAR_END_LOOPBACK_TEST_WAIT_TIME);
+
+        /* poll bit 20 of register 0F(bist finish) for 50 times*/
+        for (pollCount = 0; pollCount < 50; pollCount++)
+        {
+            regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                       MV_SATA_I_HC_R0F_STATUS_BRIDGE_PORT_OFFSET(port));
+
+            if (regVal & MV_BIT20)
+            {
+                break;
+            }
+        }
+
+        if (regVal & MV_BIT20)
+        {
+            break;
+        }/*if bit 20 still 0, then try the bist sequence again for 5 times*/
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Warning: FarEnd LoopBack "
+                     "- bit 20 still not set try again, tryCount %d\n",pAdapter->adapterId,
+                     channelIndex, tryCount);
+            temp = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                     MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                     MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port));
+            temp &= 0xff0;
+            temp |= MV_BIT0;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                               MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port), temp);
+
+            if (waitForBusyAfterHReset(pAdapter, channelIndex) == MV_FALSE)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: in Channel Hard Rese"
+                         "t storage drive is not ready\n",pAdapter->adapterId,
+                         channelIndex);
+
+                result =  MV_FALSE;
+            }
+            _fixPhyParams(pAdapter, channelIndex);
+
+
+
+
+
+
+
+        }
+    }
+    if (tryCount == 5)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: FarEnd LoopBack Failed"
+                 "- the test doesn't finish\n",pAdapter->adapterId,
+                 channelIndex);
+        result = MV_FALSE;
+    }
+    else
+    {
+        if (((regVal & MV_BIT20) == 0) && (regVal & MV_BIT19))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: FarEnd LoopBack"
+                     " finished with error, 0F regVal= %x\n",pAdapter->adapterId,
+                     channelIndex, regVal);
+            result = MV_FALSE;
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: FarEnd LoopBack finished "
+                     "successfuly, 0F regVal= %x\n",pAdapter->adapterId,
+                     channelIndex, regVal);
+        }
+    }
+    /* disable BIST and start phy communication */
+    temp = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                             MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                             MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port));
+    temp &= 0xff0;
+    temp |= MV_BIT0;
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                       MV_SATA_I_HC_R02_STATUS_BRIDGE_PORT_OFFSET(port), temp);
+
+    if (waitForBusyAfterHReset(pAdapter, channelIndex) == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: in Channel Hard Rese"
+                 "t storage drive is not ready\n",pAdapter->adapterId,
+                 channelIndex);
+
+        result =  MV_FALSE;
+    }
+    _fixPhyParams(pAdapter, channelIndex);
+
+    return result;
+}
+
+/*******************************************************************************
+* mvSataQueueCommand - Execute ATA command (PIO or UDMA)
+*
+* DESCRIPTION:
+*   adds ATA PIO or UDMA request to a MV88SX50XX specific sata channel
+*
+* INPUT:
+*   pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - the index of the specific EDMA channel
+*   pCommandInfo - Pointer to the PIO or UDMA command
+*
+* RETURN:
+*   MV_DMA_QUEUE_RESULT_OK - Command queuing is successfull
+*   MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED - when trying to add command
+                            while command queuing is disabled
+*   MV_QUEUE_COMMAND_RESULT_FULL - Command queue is full
+*   MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS - when the connected device doesn't
+*          support 48 bit addressing but the new command need's to use 48bit
+*           addressing.
+*   MV_QUEUE_RESULT_BAD_PARAMS - When bad parameters are received
+*
+* COMMENTS:
+*   None.
+*
+*******************************************************************************/
+MV_QUEUE_COMMAND_RESULT mvSataQueueCommand(MV_SATA_ADAPTER *pAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_QUEUE_COMMAND_INFO *pCommandInfo)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_QUEUED_COMMAND_ENTRY     *pCommandEntry;
+    MV_U32          eDmaRegsOffset;
+    MV_U32          nextEntry;
+
+#ifdef MV_SATA_IO_GRANULARITY
+    MV_U8          nextTransId;
+#endif
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "  : mvSataQueueCommand"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_QUEUE_COMMAND_RESULT_BAD_PARAMS;
+    }
+
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataQueueCommand"
+                 "nd Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_QUEUE_COMMAND_RESULT_BAD_PARAMS;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    if (pSataChannel->queueCommandsEnabled == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: queued commands mode"
+                 " is disabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED;
+    }
+    /* queue up to 31 commands*/
+    if (pSataChannel->outstandingCommands == MV_SATA_SW_QUEUE_SIZE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: queue is full\n",
+                 pAdapter->adapterId, channelIndex );
+
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_QUEUE_COMMAND_RESULT_FULL;
+    }
+#ifdef MV_SATA_IO_GRANULARITY
+    if ((MV_QUEUED_COMMAND_TYPE_UDMA == pCommandInfo->type) &&
+        (MV_TRUE ==
+         pCommandInfo->commandParams.udmaCommand.ioGranularityEnabled))
+    {
+
+        if (MV_FALSE == pAdapter->iogEnabled)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: IO granularity is "
+                     "disabled for the adapter\n",
+                     pAdapter->adapterId, channelIndex );
+            mvOsSemRelease(&pSataChannel->semaphore);
+            return MV_QUEUE_COMMAND_RESULT_BAD_PARAMS;
+        }
+        else
+        {
+            if (pAdapter->iogFreeIdsNum <= 0)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: IO granularity "
+                         "queue is full\n",
+                         pAdapter->adapterId);
+                mvOsSemRelease(&pSataChannel->semaphore);
+                return MV_QUEUE_COMMAND_RESULT_FULL;
+            }
+        }
+    }
+#endif
+    nextEntry = pSataChannel->freeIDsStack[--(pSataChannel->freeIDsNum)];
+    pCommandEntry = &(pSataChannel->commandsQueue[nextEntry]);
+    pCommandEntry->commandTag = (MV_U8)(nextEntry & 0x1f);
+    pCommandEntry->isCommandInEdma = MV_FALSE;
+    if (pCommandInfo->type == MV_QUEUED_COMMAND_TYPE_UDMA)
+    {
+        MV_UDMA_COMMAND_PARAMS  *pUdmaCommand = &pCommandInfo->commandParams.udmaCommand;
+        if (pSataChannel->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING)
+        {
+            pUdmaCommand->isEXT = MV_TRUE;
+        }
+#ifdef MV_SATA_IO_GRANULARITY
+        pUdmaCommand->iogCurrentTransId = MV_IOG_INVALID_COMMAND_ID;
+        if ((MV_TRUE == pAdapter->iogEnabled) &&
+            (MV_TRUE == pUdmaCommand->ioGranularityEnabled))
+        {
+            if (pUdmaCommand->iogCommandType == MV_IOG_COMMAND_TYPE_FIRST)
+            {
+                mvOsSemTake(&pAdapter->iogSemaphore);
+                nextTransId =
+                pAdapter->iogFreeIdsStack[--(pAdapter->iogFreeIdsNum)];
+                setIoGranularityCount(pAdapter,
+                                      nextTransId,
+                                      pUdmaCommand->ioGranularityCommandParam.transCount);
+                mvOsSemRelease(&pAdapter->iogSemaphore);
+            }
+            else
+            {
+                nextTransId =
+                pUdmaCommand->ioGranularityCommandParam.transId;
+            }
+            pUdmaCommand->iogCurrentTransId = nextTransId;
+        }
+#endif
+        if ((pSataChannel->noneUdmaOutstandingCommands == 0) &&
+            (pSataChannel->NCQErrHandlingInfo.state == MV_NCQ_ERROR_HANDLING_STATE_IDLE))
+        {
+            if (pSataChannel->EdmaActive == MV_FALSE)
+            {
+                disableSaDevInterrupts(pAdapter,channelIndex);
+                activateEdma(pAdapter,channelIndex);
+            }
+            addCommand(pSataChannel, pCommandEntry, pCommandInfo);
+            EdmaReqQueueInsert(pSataChannel, pCommandEntry,
+                               &pCommandInfo->commandParams.udmaCommand);
+        }
+        else
+        {
+            addCommand(pSataChannel, pCommandEntry, pCommandInfo);
+        }
+    }
+    else
+    {
+        addCommand(pSataChannel, pCommandEntry, pCommandInfo);
+        if (pSataChannel->outstandingCommands == 1)
+        {
+            if (pSataChannel->EdmaActive == MV_TRUE)
+            {
+                deactivateEdma(pAdapter,channelIndex);
+            }
+            if (pSataChannel->PMSupported == MV_TRUE)
+            {
+                _setActivePMPort(pSataChannel, pCommandInfo->PMPort);
+            }
+            if (sendNoneUdmaCommand(pSataChannel, pCommandEntry) == MV_FALSE)
+            {
+                removeCommand(pSataChannel,pCommandEntry);
+                _doSoftReset(pSataChannel);
+                mvOsSemRelease(&pSataChannel->semaphore);
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Failed to "
+                         "Issue PIO command\n", pAdapter->adapterId,
+                         channelIndex);
+                return MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED;
+            }
+        }
+    }
+
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_QUEUE_COMMAND_RESULT_OK;
+
+
+
+
+
+
+
+}
+/*******************************************************************************
+* mvSataSetInterruptsScheme - Modify interrupt scheme
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*       interruptScheme =  A parameter containing the rquired interrupt scheme
+*
+* RETURN:
+*       MV_TRUE on success, otherwise MV_FALSE.
+* COMMENTS: This function doesn't modify the HW main mask register
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataSetInterruptsScheme(MV_SATA_ADAPTER *pAdapter,
+                                     MV_SATA_INTERRUPT_SCHEME interruptScheme)
+{
+    mvOsSemTake(&pAdapter->semaphore);
+    switch (interruptScheme)
+    {
+    case MV_SATA_INTERRUPT_HANDLING_IN_ISR:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS, " %d  : Interrupts"
+                 " scheme set to Handling in ISR\n", pAdapter->adapterId);
+        break;
+    case MV_SATA_INTERRUPT_HANDLING_IN_TASK:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS, " %d  : Interrupts"
+                 " scheme set to Handling in TASK\n", pAdapter->adapterId);
+        break;
+    case MV_SATA_INTERRUPTS_DISABLED:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS, " %d  : Interrupts"
+                 " scheme set to interrupts Disabled\n", pAdapter->adapterId);
+        break;
+    default:
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d  : in mvSataSet"
+                 "InterruptsScheme: Invalid Interrup scheme (%d)\n",
+                 pAdapter->adapterId, interruptScheme);
+        mvOsSemRelease(&pAdapter->semaphore);
+        return MV_FALSE;
+    }
+    pAdapter->interruptsScheme = interruptScheme;
+    mvOsSemRelease(&pAdapter->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataCheckPendingInterrupt - Check and mask interrupts
+*
+* DESCRIPTION:
+*       Check if an interrupt is pending, If there is  a pending interrupt then
+*   this function masks the adapter's interrupts and returns MV_TRUE
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE if the interrupt issued by mv adapter, otherwise MV_FALSE.
+* COMMENTS:
+*       this function must be used only when interrupt scheme is set to
+*       MV_SATA_INTERRUPT_IN_TASK
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataCheckPendingInterrupt(MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32  mainMask;
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+
+    /*mvOsSemTake(&pAdapter->interruptsMaskSem);*/
+    mainMask = pAdapter->mainMask;
+    /*mvOsSemRelease(&pAdapter->interruptsMaskSem);*/
+    /* if the interrupt it ours*/
+    if (MV_REG_READ_DWORD(ioBaseAddr,MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET) &
+        mainMask)
+    {
+        /*clear mainMask, the ISR enables the interrupt once served*/
+        MV_REG_WRITE_DWORD(ioBaseAddr, MV_MAIN_INTERRUPT_MASK_REG_OFFSET, 0);
+        return MV_TRUE;
+    }
+    /*bogus interrupt*/
+    return MV_FALSE;
+}
+/*******************************************************************************
+* mvSataInterruptServiceRoutine - Interrupt service routine
+*
+* DESCRIPTION:
+*       this function is an interrupt service routine that is called upon
+*       reception of an interrupt from a MV88SX50XX adapter.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE if the interrupt issued by mv adapter, otherwise MV_FALSE.
+* COMMENTS:
+*       this function handles all the events that generate interrupts incuding
+*       calling the upper layer call back functions.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataInterruptServiceRoutine(MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32  mainCause;
+    MV_U32  mainMask;
+    MV_U32  unitCause = 0;
+    MV_U32  responseDone;
+    MV_U32  edmaError;
+    MV_U32  deviceInterrupt;
+    MV_U8  sataUnit;
+    MV_U8  port;
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    mvOsSemTake(&pAdapter->semaphore);
+    mainCause = MV_REG_READ_DWORD(ioBaseAddr,
+                                  MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET);
+
+    /* Check if the interrupt is ours */
+    mvOsSemTake(&pAdapter->interruptsMaskSem);
+    mainMask = pAdapter->mainMask;
+    mvOsSemRelease(&pAdapter->interruptsMaskSem);
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_INTERRUPTS,
+             " %d  : Interrupt. Cause = 0x%08x, mask 0x%08x\n",
+             pAdapter->adapterId, mainCause, mainMask);
+
+    /*
+     * Check if interrupt is our or interrupts are masked.
+     * in interrupts disaled scheme, the main mask register is cleared but the
+     * mainMask variable will hold the bits where interrupts expected, this why
+     * the sheme is not checked
+     */
+    if ((0 == (mainCause & mainMask)) ||
+        ((pAdapter->interruptsAreMasked == MV_TRUE) &&
+         (pAdapter->interruptsScheme != MV_SATA_INTERRUPTS_DISABLED)))
+    {
+        /* when interrupts handled in task, we expect to find interrupts here*/
+        if (pAdapter->interruptsScheme == MV_SATA_INTERRUPT_HANDLING_IN_TASK)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," %d  : ISR called "
+                     "but no interrutps are found in interrupts handle in task"
+                     "scheme!\n", pAdapter->adapterId);
+            /*anyway unmask interrupts*/
+            mvOsSemTake(&pAdapter->interruptsMaskSem);
+            if (pAdapter->interruptsAreMasked == MV_FALSE)
+            {
+                MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                                   MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                                   pAdapter->mainMask);
+            }
+            mvOsSemRelease(&pAdapter->interruptsMaskSem);
+        }
+        mvOsSemRelease(&pAdapter->semaphore);
+        return MV_FALSE;
+    }
+
+    if (mainCause & MV_MAIN_INTERRUPT_MASK_REG_PCIERR_BIT)
+    {
+        MV_U32  pciCause = MV_REG_READ_DWORD(ioBaseAddr,
+                                             MV_PCI_REGS_OFFSET +
+                                             MV_PCI_INTERRUPT_CAUSE_REG_OFFSET);
+
+        _dumpPCIRegs(pAdapter);
+        {
+            MV_U8   i;
+
+            for (i = 0; i < pAdapter->numberOfChannels;i++)
+            {
+                _dumpEDMARegs(pAdapter, i);
+                _dumpChannelQueues(pAdapter, i);
+            }
+        }
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR | MV_DEBUG_INTERRUPTS,
+                 " %d  : PCI error, pci interrupt cause register=%08x\n",
+                 pAdapter->adapterId, pciCause);
+        /* clear cause register */
+        MV_REG_WRITE_DWORD(ioBaseAddr, MV_PCI_REGS_OFFSET +
+                           MV_PCI_INTERRUPT_CAUSE_REG_OFFSET,
+                           ~pciCause);
+        pAdapter->mvSataEventNotify(pAdapter, MV_EVENT_TYPE_ADAPTER_ERROR,
+                                    pciCause, 0);
+    }
+#ifdef MV_SATA_IO_GRANULARITY
+    /*IO Granularity interrupt*/
+    if (mainCause & MV_IOG_TRANS_INT_MASK)
+    {
+        mvOsSemTake(&pAdapter->iogSemaphore);
+        iogInterrupt(pAdapter, ioBaseAddr, mainCause);
+        mvOsSemRelease(&pAdapter->iogSemaphore);
+    }
+#endif
+    for (sataUnit = 0; sataUnit < pAdapter->numberOfUnits; sataUnit++)
+    {
+        if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+        {
+            /* Clear the all ports interrupt coalescing cause register */
+            MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                                MV_SATA_II_ALL_PORTS_INT_CAUSE_REG_OFFSET,
+                                0);
+        }
+
+        if (mainCause & 0x1ff)
+        {
+            MV_U32  unitCauseAddr = MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                    MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET;
+            MV_U32  unitRspInPtr;
+
+            /* clear the cause bit of the Coalescing interrupt*/
+            MV_REG_WRITE_DWORD(ioBaseAddr, unitCauseAddr, ~MV_BIT4);
+            unitCause = MV_REG_READ_DWORD(ioBaseAddr, unitCauseAddr);
+            /* clear the cause register of the current unit */
+            MV_REG_WRITE_DWORD(ioBaseAddr, unitCauseAddr, ~unitCause | MV_BIT4);
+
+            unitRspInPtr = MV_REG_READ_DWORD(ioBaseAddr,
+                                             MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                             MV_SATAHC_RESPONSE_Q_IN_POINTER_OFFSET);
+
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d unit %d : unitCause = 0x%08x,"
+                     " unitRspInPtr 0x%08x\n", pAdapter->adapterId, sataUnit,
+                     unitCause, unitRspInPtr);
+
+            for (port = 0; port < MV_SATA_PORT_PER_UNIT; port++)
+            {
+                deviceInterrupt = unitCause & (MV_BIT8 << port);
+                responseDone = unitCause & (1 << port);
+                edmaError = (mainCause & MV_BIT0) ;
+                if (responseDone || edmaError)
+                {
+                    handleEdmaInterrupt(pAdapter, sataUnit, port,
+                                        unitRspInPtr & 0x1f, responseDone,
+                                        edmaError, unitCause);
+                }
+                if (deviceInterrupt &&
+                    (SaDevInterrutpBit((MV_U8)MV_CHANNEL_INDEX(sataUnit, port)) & mainMask))
+                {
+                    handleDeviceInterrupt(pAdapter, sataUnit, port);
+                }
+
+
+                mainCause >>= 2;
+                unitRspInPtr >>= 8;
+            }
+        }
+        else
+        {
+            mainCause >>=8;
+        }
+        mainCause >>= 1;            /* this is for the coalescing 0-3 bit*/
+    }
+    if (pAdapter->interruptsScheme == MV_SATA_INTERRUPT_HANDLING_IN_TASK)
+    {
+        if (pAdapter->interruptsAreMasked == MV_FALSE)
+        {
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                               pAdapter->mainMask);
+        }
+    }
+    mvOsSemRelease(&pAdapter->semaphore);
+    return MV_TRUE;
+}
+/*******************************************************************************
+* mvSataMaskAdapterInterrupt - mask any interrupts can be generated from a
+*       MV88SX50XX adapter
+*
+* DESCRIPTION:
+*       mask all the interrupts that could occur from the adapter.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       Before masking the interrupts, the value of the interrupt maks register
+*       will be stored in the adapter data structure.
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataMaskAdapterInterrupt(MV_SATA_ADAPTER *pAdapter)
+{
+    pAdapter->interruptsAreMasked = MV_TRUE;
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_MAIN_INTERRUPT_MASK_REG_OFFSET, 0);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataUnmaskAdapterInterrupt - unmask interrupts can be generated from a
+*       MV88SX50XX adapter
+*
+* DESCRIPTION:
+*       Restore a previous value in the MV88SX50XX interrupt maks register by
+*       writing the previously stored value in the interruptMaskRegister field
+*       in the adapter data structure to the MV88SX50XX adapter main interrupt
+*       mask register
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataUnmaskAdapterInterrupt(MV_SATA_ADAPTER *pAdapter)
+{
+    mvOsSemTake(&pAdapter->interruptsMaskSem);
+    pAdapter->interruptsAreMasked = MV_FALSE;
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                       pAdapter->mainMask);
+    mvOsSemRelease(&pAdapter->interruptsMaskSem);
+    return MV_TRUE;
+}
+
+
+/*******************************************************************************
+* mvSataEnableStaggeredSpinUpAll - Enables staggared spin-up of all SATA channels
+*
+* DESCRIPTION:
+*       Enables staggared spin-up of all SATA II chnannel. This function is not
+*       relevant for SATA I.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataEnableStaggeredSpinUpAll (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U8 channelIndex;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataEnableStaggeredSpinUp Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d  : Staggered spin-up called for all "
+             "SATA channels\n",pAdapter->adapterId);
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+
+        mvOsSemTake(&pAdapter->semaphore);
+        _establishSataCommAll(pAdapter);
+        for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+            channelIndex ++)
+        {
+            MV_U32 SStatusReg;
+            SStatusReg = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                            getEdmaRegOffset(channelIndex) +
+                                            MV_SATA_II_S_STATUS_REG_OFFSET);
+
+            /*
+             * SHII10
+             */
+
+            if ((SStatusReg != 0x0) && (SStatusReg != 0x113) && (SStatusReg != 0x123))
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: SStatusRegs = %x ; "
+                         "retrying communication...",
+                         pAdapter->adapterId, channelIndex, SStatusReg);
+                _establishSataComm(pAdapter,channelIndex);
+                SStatusReg = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                                getEdmaRegOffset(channelIndex) +
+                                                MV_SATA_II_S_STATUS_REG_OFFSET);
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: New SStatus is %x\n",
+                         pAdapter->adapterId, channelIndex, SStatusReg);
+
+            }
+            if ( ((SStatusReg & 0xf) == MV_PHY_DET_STATE_DEVICE_NO_PHY_COM) ||
+                 ((SStatusReg & 0xf) == MV_PHY_DET_STATE_PHY_OFFLINE))
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: "
+                         "Error - failed to establish SATA link after staggered "
+                         "spin up (S Status = %08x)\n", pAdapter->adapterId,
+                         channelIndex, SStatusReg);
+            }
+            pAdapter->staggaredSpinup[channelIndex] = MV_TRUE;
+        }
+        mvOsSemRelease(&pAdapter->semaphore);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK | MV_DEBUG, " %d  : "
+             "Finished staggered spin-up\n", pAdapter->adapterId);
+
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataEnableStaggeredSpinUp - Enables staggared spin-up.
+*
+* DESCRIPTION:
+*       Enables staggared spin-up of SATA II chnannel. This function is not
+*       relevant for SATA I.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - the index of the specific EDMA channel
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataEnableStaggeredSpinUp (MV_SATA_ADAPTER *pAdapter,
+                                        MV_U8 channelIndex)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataEnableStaggeredSpinUp Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_FALSE;
+    }
+    if (channelIndex >= pAdapter->numberOfChannels)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataEnableStaggeredSpinUp Failed, bad channel index\n");
+        return MV_FALSE;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: Staggered spin-up called\n",
+             pAdapter->adapterId, channelIndex);
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        MV_U32 SStatusReg;
+
+        mvOsSemTake(&pAdapter->semaphore);
+        _establishSataComm(pAdapter, channelIndex);
+        SStatusReg = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress,
+                                        getEdmaRegOffset(channelIndex) +
+                                        MV_SATA_II_S_STATUS_REG_OFFSET);
+        if ( ((SStatusReg & 0xf) == MV_PHY_DET_STATE_DEVICE_NO_PHY_COM) ||
+             ((SStatusReg & 0xf) == MV_PHY_DET_STATE_PHY_OFFLINE))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: "
+                     "Error - failed to establish SATA link after staggered "
+                     "spin up (S Status = %08x)\n", pAdapter->adapterId,
+                     channelIndex, SStatusReg);
+        }
+        pAdapter->staggaredSpinup[channelIndex] = MV_TRUE;
+        mvOsSemRelease(&pAdapter->semaphore);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK | MV_DEBUG, " %d %d: "
+             "Finished staggered spin-up\n", pAdapter->adapterId,
+             channelIndex);
+
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataDisableStaggeredSpinUpAll - Disables staggared spin-up on all channels
+*
+* DESCRIPTION:
+*       Disables staggared spin-up of all SATA II chnannel. This function is not
+*       relevant for SATA I.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataDisableStaggeredSpinUpAll (MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U8 channelIndex;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataDisableStaggeredSpinUp Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        /* OK to use mvSataDisableStaggeredSpinUp since it's fast enough */
+        for (channelIndex = 0 ; channelIndex < pAdapter->numberOfChannels ;
+            channelIndex ++)
+        {
+            mvSataDisableStaggeredSpinUp(pAdapter,channelIndex);
+
+
+
+
+
+
+
+        }
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataDisableStaggeredSpinUp - Disables staggared spin-up.
+*
+* DESCRIPTION:
+*       Disables staggared spin-up of SATA II chnannel. This function is not
+*       relevant for SATA I.
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - the index of the specific EDMA channel
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvSataDisableStaggeredSpinUp (MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex)
+{
+    MV_U32 SControlOffset, regVal;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataDisableStaggeredSpinUp Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_FALSE;
+    }
+    if (channelIndex >= pAdapter->numberOfChannels)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataDisableStaggeredSpinUp Failed, bad channel index\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        mvOsSemTake(&pAdapter->semaphore);
+        SControlOffset = getEdmaRegOffset( channelIndex) +
+                         MV_SATA_II_S_CONTROL_REG_OFFSET;
+        regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset);
+        regVal &= ~0xf;
+        regVal |= MV_PHY_DET_CONTROL_SHUTDOWN;
+        MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress, SControlOffset,
+                            regVal);
+        pAdapter->staggaredSpinup[channelIndex] = MV_FALSE;
+        mvOsSemRelease(&pAdapter->semaphore);
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvSataSetInterfaceSpeed - Sets the interface speed of a specific SATA channel
+*
+* DESCRIPTION:
+*       Sets the interface speed of a specific SATA channel (1.5/3 Gbps)
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - the index of the specific EDMA channel
+*
+* RETURN:
+*       MV_SATA_IF_SPEED_1_5 for 1.5 Gbps
+*       MV_SATA_IF_SPEED_3   for 3 Gbps
+*       MV_SATA_IF_SPEED_INVALID if no speed is negotiated
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataSetInterfaceSpeed (MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_SATA_IF_SPEED ifSpeed)
+{
+    MV_U32  SStatusOffset;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataSetInterfaceSpeed Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_FALSE;
+    }
+    if (channelIndex >= pAdapter->numberOfChannels)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataSetInterfaceSpeed Failed, bad channel index\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        MV_SATA_CHANNEL *pSataChannel;
+
+        pSataChannel = pAdapter->sataChannel[channelIndex];
+        if (pSataChannel != NULL)
+        {
+            mvOsSemTake(&pSataChannel->semaphore);
+            if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: Error:"
+                         "mvSataSetInterfaceSpeed called while EDMA is active\n",
+                         pAdapter->adapterId,channelIndex);
+                mvOsSemRelease( &pSataChannel->semaphore);
+                return MV_FALSE;
+            }
+            mvOsSemRelease(&pSataChannel->semaphore);
+        }
+
+        SStatusOffset = getEdmaRegOffset(channelIndex) +
+                        MV_SATA_II_S_STATUS_REG_OFFSET;
+
+        if (ifSpeed == MV_SATA_IF_SPEED_1_5_GBPS)
+        {
+            pAdapter->limitInterfaceSpeed[channelIndex] = MV_TRUE;
+            pAdapter->ifSpeed[channelIndex] = MV_SATA_IF_SPEED_1_5_GBPS;
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK, " %d %d: Set Sata speed to "
+                     "1.5Gbps\n", pAdapter->adapterId,channelIndex);
+        }
+        else if (ifSpeed == MV_SATA_IF_SPEED_3_GBPS)
+        {
+            pAdapter->limitInterfaceSpeed[channelIndex] = MV_TRUE;
+            pAdapter->ifSpeed[channelIndex] = MV_SATA_IF_SPEED_3_GBPS;
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK, " %d %d: Set Sata speed to "
+                     "3Gbps\n", pAdapter->adapterId,channelIndex);
+        }
+        else if (ifSpeed == MV_SATA_IF_SPEED_NO_LIMIT)
+        {
+            pAdapter->limitInterfaceSpeed[channelIndex] = MV_FALSE;
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_SATA_LINK, " %d %d: don't limit Sata"
+                     " speed \n", pAdapter->adapterId,channelIndex);
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                     "mvSataSetInterfaceSpeed Failed, bad IF speed\n");
+            return MV_FALSE;
+        }
+
+        mvOsSemTake(&pAdapter->semaphore);
+        _channelHardReset(pAdapter, channelIndex);
+        /* If interface is already active, then device detection is needed */
+        if (pAdapter->staggaredSpinup[channelIndex] == MV_TRUE)
+        {
+            _establishSataComm(pAdapter, channelIndex);
+        }
+        mvOsSemRelease(&pAdapter->semaphore);
+        return MV_TRUE;
+    }
+    if ((pAdapter->sataAdapterGeneration == MV_SATA_GEN_I) &&
+        ((ifSpeed == MV_SATA_IF_SPEED_NO_LIMIT) ||
+         (ifSpeed == MV_SATA_IF_SPEED_1_5_GBPS)))
+    {
+        return MV_TRUE;
+    }
+    return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvSataGetInterfaceSpeed - Gets the interface speed of a specific SATA channel
+*
+* DESCRIPTION:
+*       Gets the interface speed of a specific SATA channel (1.5/3 Gbps)
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*   channelIndex    - the index of the specific EDMA channel
+*
+* RETURN:
+*       MV_SATA_IF_SPEED_1_5 for 1.5 Gbps
+*       MV_SATA_IF_SPEED_3   for 3 Gbps
+*       MV_SATA_IF_SPEED_INVALID if no speed is negotiated
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_SATA_IF_SPEED mvSataGetInterfaceSpeed (MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex)
+{
+    MV_U32 SStatusOffset, regVal;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataGetInterfaceSpeed Failed, Bad adapter data structure"
+                 " pointer\n");
+        return MV_SATA_IF_SPEED_INVALID;
+    }
+    if (channelIndex >= pAdapter->numberOfChannels)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : "
+                 "mvSataGetInterfaceSpeed Failed, bad channel index\n");
+        return MV_SATA_IF_SPEED_INVALID;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        if (pAdapter->staggaredSpinup[channelIndex] == MV_TRUE)
+        {
+            SStatusOffset = getEdmaRegOffset(channelIndex) +
+                            MV_SATA_II_S_STATUS_REG_OFFSET;
+            regVal = MV_REG_READ_DWORD (pAdapter->adapterIoBaseAddress, SStatusOffset);
+            if (regVal & MV_BIT4)
+            {
+                return MV_SATA_IF_SPEED_1_5_GBPS;
+            }
+            if (regVal & MV_BIT5)
+            {
+                return MV_SATA_IF_SPEED_3_GBPS;
+            }
+        }
+        return MV_SATA_IF_SPEED_INVALID;
+    }
+    return MV_SATA_IF_SPEED_1_5_GBPS;/*TBD*/
+}
+
+/*================C2C functions==========================================*/
+#ifdef MV_SATA_C2C_COMM
+static void activateBMDmaMode(MV_SATA_ADAPTER *pAdapter,
+                              MV_U8 channelIndex,
+                              MV_U32 prdTableHi,
+                              MV_U32 prdTableLow,
+                              MV_UDMA_TYPE dmaType)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+
+
+    MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                        MV_BMDMA_COMMAND_OFFSET, 0);
+
+    MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                        MV_BMDMA_PRD_TABLE_LOW_ADDRESS_OFFSET, prdTableLow);
+    MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                        MV_BMDMA_PRD_TABLE_HIGH_ADDRESS_OFFSET, prdTableHi);
+
+    if (dmaType == MV_UDMA_TYPE_READ)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: Activate BM-DMA in write Mode"
+                 " (Read from disk)\n", pAdapter->adapterId, channelIndex);
+        MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                            MV_BMDMA_COMMAND_OFFSET, MV_BIT3 | MV_BIT0);
+    }
+    else
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: Activate BM-DMA in read Mode"
+                 " (Writes to disk)\n", pAdapter->adapterId, channelIndex);
+        MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                            MV_BMDMA_COMMAND_OFFSET, MV_BIT0);
+    }
+}
+
+
+/*******************************************************************************
+* sendVendorUniqueFIS - send vendor unique FIS
+*
+* DESCRIPTION:
+*       Performs vendor unique FIS transmission
+*
+* INPUT:
+*       pAdapter            - pointer to the adapter data structure.
+*       channelIndex        - the index of the specific SATA channel
+*       vendorUniqueBuffer  - data buffer to transmit
+*       numOfDWords         - number of double words in the buffer
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*  1. Verify the Transport Layer is in idle, field TransFsmSts in
+*     Serial-ATA Interface Status Register is cleared.
+*  2. Set Vendor Unique Mode. Write 1 to bit VendorUqMd in register
+*     Serial-ATA Interface Control Register.
+*  3. Insert data into Vendor Unique Register.
+*  4. Repeat steps 3 until all data except last Dword in the vendor unique
+*     FIS is transferred. Note that according to Serial-ATA protocol the
+*     FIS length is limited to 8 KB.
+*  5. Write 1 to bit VendorUqSend in register Serial-ATA Interface Control
+*     Register.
+*  6. Write last Dword in the FIS to Complete FIS transmission.
+*  7. Wait for transmission completion. Bit VendorUqDn or bit VendorUqErr
+*     in Serial-ATA Interface Status Register is set to 1.
+*  8. Verify successful transmission of the FIS. Bit VendorUqErr in
+*     Serial-ATA Interface Status Register is cleared.
+*  9. Clear Vendor Unique Mode. Write 0 to bit VendorUqMd in register
+*     Serial-ATA Interface Control Register.
+*******************************************************************************/
+static MV_BOOLEAN sendVendorUniqueFIS(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_U32 *vendorUniqueBuffer,
+                                      MV_U8 numOfDWords)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    MV_U32          regVal;
+    MV_U8           i;
+    MV_BOOLEAN      res = MV_FALSE;
+
+    regVal = MV_REG_READ_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                               MV_SATA_II_IF_STATUS_REG_OFFSET);
+
+    if (regVal & MV_SATA_II_IF_STATUS_FSM_STATUS_MASK)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: ERROR : sendVendorUniqueFIS"
+                 " Transport Layer is not in Idle status\n", pAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+
+    /* Set Vendor Unique Mode */
+    MV_REG_WRITE_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET, MV_BIT8);
+
+    for (i = 1; i < numOfDWords; i++)
+    {
+        MV_REG_WRITE_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                           MV_SATA_II_VENDOR_UQ_REG_OFFSET,
+                           vendorUniqueBuffer[i - 1]);
+    }
+
+    /* Write 1 to bit VendorUqSend */
+    MV_REG_WRITE_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET,  MV_BIT9|MV_BIT8);
+
+    MV_REG_WRITE_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_VENDOR_UQ_REG_OFFSET,
+                       vendorUniqueBuffer[i - 1]);
+
+
+    /* polling with timeout*/
+    for (i = 0;  i < 200; i++)
+    {
+        regVal = MV_REG_READ_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                                   MV_SATA_II_IF_STATUS_REG_OFFSET);
+
+        if (regVal & (MV_SATA_II_IF_STATUS_VUQ_DONE_MASK |
+                      MV_SATA_II_IF_STATUS_VUQ_ERR_MASK))
+        {
+            if (regVal & MV_SATA_II_IF_STATUS_VUQ_DONE_MASK)
+            {
+                res = MV_TRUE;
+                break;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: ERROR"
+                         "sendVendorUniqueFIS operation failed. "
+                         "regVal = 0x%08x\n",
+                         pAdapter->adapterId, channelIndex, regVal);
+                break;
+            }
+        }
+        mvMicroSecondsDelay(pAdapter, 1);
+    }
+    /* Clear Vendor Unique Mode */
+    MV_REG_WRITE_DWORD(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET, 0);
+
+    if (res != MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: ERROR in sendVendorUniqueFI"
+                 "S operation didn't finish. regVal = 0x%08x\n",
+                 pAdapter->adapterId, channelIndex, regVal);
+    }
+    return res;
+}
+
+
+
+/*******************************************************************************
+* mvSataC2CInit - setup channel-to-channel communication mode on
+*                   specific SATA channel
+*
+* DESCRIPTION:
+*       Initializes channel for channel-to-channel communication mode
+*
+* INPUT:
+*       pAdapter        - pointer to the adapter data structure.
+*       channelIndex    - the index of the specific SATA channel
+*       mvSataC2CMode   - Comunication mode for the channel:
+*                           target or initiator
+*
+*       mvSataC2CCallBack - callback function called on channel 2 channel
+*                           communication event
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataC2CInit (MV_SATA_ADAPTER *pAdapter,
+                          MV_U8 channelIndex,
+                          MV_SATA_C2C_MODE mvSataC2CMode,
+                          C2CCallBack_t mvSataC2CCallBack)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32          regVal;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataC2CInit"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataC2CInit Failed"
+                 ", channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex );
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataC2CInit "
+                 "failed, DMA is enabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataC2CInit "
+                 "failed, Feature not supported by this HW\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    regVal = MV_REG_READ_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                                MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+    /* Enable communication mode */
+    regVal |= MV_BIT11;
+    /* SHII8*/
+    regVal |= MV_BIT12;
+
+    if (mvSataC2CMode == MV_SATA_C2C_MODE_INITIATOR)
+    {
+        regVal |= MV_BIT10; /* Initiator */
+    }
+    else
+    {
+        regVal &= ~MV_BIT10; /* Target */
+    }
+
+    maskEdmaInterrupts(pAdapter, channelIndex);
+
+    MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                        MV_SATA_II_SATA_CONFIG_REG_OFFSET, regVal);
+    MV_REG_READ_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+
+    pSataChannel->C2CmodeEnabled = MV_TRUE;
+    pSataChannel->C2CMode = mvSataC2CMode;
+    pSataChannel->C2CCallback = mvSataC2CCallBack;
+
+    /*The hard reset is needed to reactivate channel Rx impedance
+    auto calibration on the target side.*/
+    if (mvSataC2CMode == MV_SATA_C2C_MODE_TARGET)
+    {
+        _channelHardReset(pAdapter, channelIndex);
+    }
+    mvSataMaskAdapterInterrupt(pAdapter);
+    pAdapter->mainMask |= SaDevInterrutpBit(channelIndex);
+    mvSataUnmaskAdapterInterrupt(pAdapter);
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: mvSataC2CInit %s mode\n",
+             pAdapter->adapterId, channelIndex,
+             (mvSataC2CMode == MV_SATA_C2C_MODE_INITIATOR) ? "Initiator" :
+             "Target");
+
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+
+/*******************************************************************************
+* mvSataC2CStop - Stop channel to channel communication mode
+*
+* DESCRIPTION:
+*       Stop channel to channel communication mode on
+*                   specific SATA channel
+*
+* INPUT:
+*       pAdapter        - pointer to the adapter data structure.
+*       channelIndex    - the index of the specific SATA channel
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataC2CStop (MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL  *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32          regVal;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    : mvSataC2CStop"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: mvSataC2CStop Failed"
+                 ", channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex );
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataC2CStop "
+                 "failed, DMA is enabled\n", pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    regVal = MV_REG_READ_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                                MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+    regVal &= ~MV_BIT11;    /* Disable communication mode */
+    /* SHII8*/
+    regVal |= MV_BIT12;
+
+    MV_REG_WRITE_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                        MV_SATA_II_SATA_CONFIG_REG_OFFSET, regVal);
+    MV_REG_READ_DWORD (ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                       MV_SATA_II_SATA_CONFIG_REG_OFFSET);
+    mvSataMaskAdapterInterrupt(pAdapter);
+    pAdapter->mainMask &= ~SaDevInterrutpBit(channelIndex);
+    mvSataUnmaskAdapterInterrupt(pAdapter);
+
+    _channelHardReset(pAdapter, channelIndex);
+    pSataChannel->C2CmodeEnabled = MV_FALSE;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: mvSataC2CStop\n",
+             pAdapter->adapterId, channelIndex);
+
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+
+
+/*******************************************************************************
+* mvSataC2CSendRegisterDeviceToHostFIS - sends Register device to host FIS
+*
+* DESCRIPTION:
+*                   Sends Register device to host FIS
+*                   used for channel-to-channel communication mode on
+*                   specific SATA channel
+* INPUT:
+*       pAdapter        - pointer to the adapter data structure.
+*       channelIndex    - the index of the specific SATA channel
+*       pmPort          - port multiplier port
+*       bInterrupt      - determine whether the interrupt is being generated on
+*                           the receiver side
+*       msg             - message containing 10 bytes of user data
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN  mvSataC2CSendRegisterDeviceToHostFIS(
+                                                MV_SATA_ADAPTER *pAdapter,
+                                                MV_U8 channelIndex,
+                                                MV_U8 pmPort,
+                                                MV_BOOLEAN bInterrupt,
+                                                MV_U8 msg[MV_C2C_MESSAGE_SIZE])
+
+{
+
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32          buffer[5];
+    MV_BOOLEAN      res;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d "
+                 "mvSataC2CSendRegisterDeviceToHostFIS failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d "
+                 "mvSataC2CSendRegisterDeviceToHostFIS failed - "
+                 "channel data structure not allocated.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+
+    if (pSataChannel->C2CmodeEnabled == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: mvSataC2CInitiator"
+                 "mvSataC2CSendRegisterDeviceToHostFIS failed - "
+                 "Bad C2C configuration.\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    buffer[0] = MV_SATA_REGISTER_HOST_2_DEVICE_FIS;
+    buffer[0] |= ((MV_U32)(pmPort & 0xF)) << 8;
+    if (MV_TRUE == bInterrupt)
+    {
+        buffer[0] |= 1 << 14;
+    }
+    buffer[0] |= ((MV_U32)msg[0]) << 24;
+    buffer[1] = msg[1] |
+                ((MV_U32)msg[2]) << 8 |
+                ((MV_U32)msg[3]) << 16 |
+                ((MV_U32)msg[4]) << 24;
+    buffer[2] = msg[5] |
+                ((MV_U32)msg[6]) << 8 |
+                ((MV_U32)msg[7]) << 16;
+    buffer[3] = msg[8] |
+                ((MV_U32)msg[9]) << 8;
+    buffer[4] = 0;
+    res = sendVendorUniqueFIS(pAdapter,
+                              channelIndex,
+                              (MV_U32*)buffer,
+                              5);
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return res;
+}
+
+
+
+/*******************************************************************************
+* mvSataC2CActivateBmDma - activate B-M DMA
+*
+* DESCRIPTION:
+*       Activates Bus Master DMA for the specific SATA channel
+*
+* INPUT:
+*       pAdapter        - pointer to the adapter data structure.
+*       channelIndex    - the index of the specific EDMA channel
+*       pmPort          - port multiplier port
+*       prdTableHi      - upper 32 bits of PRD table address
+*       prdTableHi      - lower 32 bits of PRD table address
+*       dmaType         - DMA type (read o write) from the initiator point
+                        of view
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN  mvSataC2CActivateBmDma(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex,
+                                   MV_U8 pmPort,
+                                   MV_U32 prdTableHi,
+                                   MV_U32 prdTableLow,
+                                   MV_UDMA_TYPE dmaType)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_BOOLEAN      res = MV_TRUE;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d "
+                 "mvSataC2CActivateBmDma failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d "
+                 "mvSataC2CActivateBmDma failed - "
+                 "channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex );
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->C2CmodeEnabled == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d "
+                 "mvSataC2CActivateBmDma failed - "
+                 "bad C2C configuration.\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease(&pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    if (pSataChannel->C2CMode == MV_SATA_C2C_MODE_TARGET)
+    {
+        activateBMDmaMode(pAdapter, channelIndex,
+                          prdTableHi, prdTableLow,
+                          (dmaType == MV_UDMA_TYPE_WRITE) ?
+                          MV_UDMA_TYPE_READ : MV_UDMA_TYPE_WRITE);
+        if (dmaType == MV_UDMA_TYPE_WRITE)
+        {
+            MV_U32 buffer[1] = {MV_SATA_DMA_ACTIVATE_FIS};
+
+            buffer[0] |= ((MV_U32)(pmPort & 0xF)) << 8;
+            res = sendVendorUniqueFIS(pAdapter,
+                                      channelIndex,
+                                      (MV_U32*)buffer,
+                                      1);
+        }
+        else
+        {
+            MV_U32 val = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                           pAdapter->sataChannel[channelIndex]->eDmaRegsOffset +
+                                           MV_SATA_II_IF_CONTROL_REG_OFFSET);
+            val |= MV_BIT16;
+            MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                               pAdapter->sataChannel[channelIndex]->eDmaRegsOffset +
+                               MV_SATA_II_IF_CONTROL_REG_OFFSET,
+                               val);
+        }
+
+
+
+
+
+
+
+    }
+    else
+    {
+        activateBMDmaMode(pAdapter, channelIndex, prdTableHi, prdTableLow,
+                          dmaType);
+    }
+    mvOsSemRelease(&pSataChannel->semaphore);
+    return res;
+}
+
+
+/*******************************************************************************
+* mvSataC2CResetBmDma - reset B-M DMA
+*
+* DESCRIPTION:
+*       Reset Bus Master DMA for the specific SATA channel
+*
+* INPUT:
+*       pAdapter        - pointer to the adapter data structure.
+*       channelIndex    - the index of the specific EDMA channel
+*
+* RETURN:
+*       MV_TRUE on success
+*       MV_FALSE on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataC2CResetBmDma(MV_SATA_ADAPTER *pAdapter,
+                               MV_U8 channelIndex)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_U32  val;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d "
+                 "mvSataC2CResetBmDma failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel)
+    {
+
+        mvOsSemTake(&pSataChannel->semaphore);
+    }
+
+    /*Reset bm dma*/
+    val = MV_REG_READ_DWORD (ioBaseAddr,
+                             getEdmaRegOffset(channelIndex) +
+                             MV_BMDMA_COMMAND_OFFSET);
+    /*The DMA direction must be preserved*/
+    val &= ~MV_BIT0;
+    MV_REG_WRITE_DWORD (ioBaseAddr,
+                        getEdmaRegOffset(channelIndex) +
+                        MV_BMDMA_COMMAND_OFFSET, val);
+
+    MV_REG_WRITE_DWORD(ioBaseAddr,
+                       getEdmaRegOffset(channelIndex) +
+                       MV_SATA_II_IF_CONTROL_REG_OFFSET,
+                       0);
+
+    if (pSataChannel)
+    {
+        mvOsSemRelease(&pSataChannel->semaphore);
+    }
+    return MV_TRUE;
+}
+#endif
+
+#ifdef MV_SATA_IO_GRANULARITY
+
+/*Public functions*/
+
+/*******************************************************************************
+* mvSataEnableIoGranularity - Enable/disable I/O granularity for the specific
+*                             SATA adapter
+*
+* DESCRIPTION:
+*               Enable/disable I/O granularity for the specific
+*               SATA adapter. if IO/granularity is enabled, the function masks
+*               all channel's and channel coalescing interrupts and enables
+*               I/O granularity coalescing interupts
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*       enable    -  MV_TRUE to enable I/O granularity
+*                    MV_FALSE to disable I/O granularity
+*
+* RETURN:
+*       MV_TRUE if succeed
+*       MV_FALSE otherwise
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvSataEnableIoGranularity(MV_SATA_ADAPTER *pAdapter,
+                                     MV_BOOLEAN enable)
+{
+    MV_U32 i;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d: "
+                 "mvSataEnableIoGranularity Failed, Bad adapter data structure"
+                 " pointer\n", pAdapter->adapterId);
+        return MV_FALSE;
+    }
+    if (pAdapter->sataAdapterGeneration != MV_SATA_GEN_II)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d: "
+                 "mvSataEnableIoGranularity Failed, Feature is not supported by HW\n",
+                 pAdapter->adapterId);
+        return MV_FALSE;
+    }
+    if (enable)
+    {
+        if (MV_TRUE == pAdapter->iogEnabled)
+        {
+            return MV_TRUE;
+        }
+        mvOsSemTake(&pAdapter->iogSemaphore);
+        for (i = 0; i < MV_IOG_QUEUE_SIZE; i++)
+        {
+            pAdapter->iogFreeIdsStack[i] = i;
+
+
+
+
+
+
+
+        }
+        pAdapter->iogFreeIdsNum = MV_IOG_QUEUE_SIZE;
+        pAdapter->iogEnabled = MV_TRUE;
+        mvOsSemRelease(&pAdapter->iogSemaphore);
+
+        mvOsSemTake(&pAdapter->interruptsMaskSem);
+        pAdapter->mainMask &= ~(MV_BIT1 | MV_BIT3 |  MV_BIT5 |  MV_BIT7 |
+                                MV_BIT10 | MV_BIT12 |  MV_BIT14 |  MV_BIT16 |
+                                MV_BIT17 | MV_BIT8);
+        pAdapter->mainMask |= MV_IOG_TRANS_INT_MASK;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                           pAdapter->mainMask);
+        mvOsSemRelease(&pAdapter->interruptsMaskSem);
+
+
+
+
+
+
+
+    }
+    else
+    {
+        if (MV_FALSE == pAdapter->iogEnabled)
+        {
+            return MV_TRUE;
+        }
+
+        mvOsSemTake(&pAdapter->interruptsMaskSem);
+        pAdapter->mainMask &= ~MV_IOG_TRANS_INT_MASK;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                           MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                           pAdapter->mainMask);
+        mvOsSemRelease(&pAdapter->interruptsMaskSem);
+
+        mvOsSemTake(&pAdapter->iogSemaphore);
+        pAdapter->iogFreeIdsNum = 0;
+        pAdapter->iogEnabled = MV_FALSE;
+        mvOsSemRelease(&pAdapter->iogSemaphore);
+    }
+    return MV_TRUE;
+}
+
+/*Static functions*/
+
+/*******************************************************************************
+* setIoGranularityCount - Set I/O granularity transaction control register.
+*
+* DESCRIPTION:
+*       This function Sets I/O granularity transaction control register for
+*       specific transaction ID
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*       transId     -  transaction ID
+*       counter     -  I/O granularity counter transaction for current
+*                       transaction Id
+*
+* RETURN:
+*       None
+*
+* COMMENTS:
+*       This function assumes that the channel semaphore is locked.
+*
+*******************************************************************************/
+
+static void setIoGranularityCount(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 transId,
+                                  MV_U8 counter)
+{
+    MV_U32 offset  = MV_IOG_TRANS_CTRL_REG_OFFSET + transId;
+    MV_U8 value  = (counter & 0x1F);
+    MV_REG_WRITE_BYTE(pAdapter->adapterIoBaseAddress, offset, value);
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_UDMA_COMMAND,
+             " %d : setIoGranularityCount "
+             "writing 0x%X to 0x%X, transId = 0x%X\n",
+             pAdapter->adapterId, value, offset, transId);
+}
+
+/*******************************************************************************
+* readIoGranularityCount - Read I/O granularity transaction control register.
+*
+* DESCRIPTION:
+*       This function reads I/O granularity transaction control register for
+*       specific transaction ID
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*       transId     -  transaction ID
+*
+*
+* RETURN:
+*        I/O granularity counter for transaction Id
+*
+* COMMENTS:
+*       This function assumes that the channel semaphore is locked.
+*
+*******************************************************************************/
+static MV_U8 readIoGranularityCount(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 transId)
+{
+    MV_U32 offset  = MV_IOG_TRANS_CTRL_REG_OFFSET + transId;
+    MV_U8 value  = MV_REG_READ_BYTE(pAdapter->adapterIoBaseAddress, offset);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS, " %d : readIoGranularityCount "
+             "reading 0x%X from 0x%X, transId = 0x%X\n",
+             pAdapter->adapterId, value, offset, transId);
+    return value;
+}
+
+
+/*******************************************************************************
+* checkIogBit - Check bit of I/O granularity cause register.
+*
+* DESCRIPTION:
+*       Checks bits in I/O granularity cause register for completion
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*       bitOffset    - bit offset in register for current transaction id
+*       value        - register value
+*
+* RETURN:
+*        None
+*
+* COMMENTS:
+*       Assume that is function is called while IO granularity semaphore is
+*       locked
+*******************************************************************************/
+
+static void checkIogBit(MV_SATA_ADAPTER *pAdapter,
+                        MV_U8 bitOffset,
+                        MV_U8 value)
+{
+    MV_U32 i;
+    MV_U8 id = 0x40;
+    for (i = 0; i < 8; i++)
+    {
+        if ((value >> i) & 0x1)
+        {
+            MV_U8 iogCount;
+            id = bitOffset + i;
+            iogCount = readIoGranularityCount(pAdapter, id);
+            if (iogCount > 0)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS,
+                         " %d: unexpected IO granularity "
+                         "transaction counter = %d > 0\n",
+                         pAdapter->adapterId, iogCount);
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_INTERRUPTS,
+                         " %d: IO granularity transaction Id 0x%X done.\n",
+                         pAdapter->adapterId, id);
+            }
+            pAdapter->iogFreeIdsStack[pAdapter->iogFreeIdsNum++] = id;
+        }
+    }
+}
+
+/*******************************************************************************
+* checkIogCompletion - Check bit of I/O granularity cause register.
+*
+* DESCRIPTION:
+*       Checks I/O granularity completion
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*       iogCause     - I/O granularity cause register value
+*       Offset      -  0 if transaction Id is 0-31, 32 if transaction Id 32-63
+*
+* RETURN:
+*        None
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static void checkIogCompletion(MV_SATA_ADAPTER *pAdapter,
+                               MV_U32 iogCause, MV_U8 offset)
+{
+    MV_U32 id;
+    MV_U8  byte;
+
+    if (iogCause & 0xFFFF0000)
+    {
+        byte = (MV_U8)(iogCause >> 24);
+        if (byte)
+        {
+            checkIogBit(pAdapter, (offset) + 24, byte);
+        }
+        byte  =  (MV_U8)((iogCause >> 16) & 0xFF);
+        if (byte)
+        {
+            checkIogBit(pAdapter, (offset) + 16, byte);
+        }
+    }
+    if (iogCause & 0x0000FFFF)
+    {
+        byte = (MV_U8)(iogCause >> 8);
+        if (byte)
+        {
+            checkIogBit(pAdapter, (offset) + 8, byte);
+        }
+        byte  =  (MV_U8)(iogCause & 0xFF);
+        if (byte)
+        {
+            checkIogBit(pAdapter, (offset), byte);
+        }
+    }
+}
+
+/*******************************************************************************
+* iogInterrupt - I/O granularity ISR.
+*
+* DESCRIPTION:
+*       Checks bit of I/O granularity cause register for
+*       specific transaction ID
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*       ioBaseAddr   - SATA Adapter base address
+*       mainCause   - interrupt cause register
+*
+* RETURN:
+*        None
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static void iogInterrupt(MV_SATA_ADAPTER *pAdapter,
+                         MV_BUS_ADDR_T ioBaseAddr,
+                         MV_U32 mainCause)
+{
+    MV_U32 iogCauseRegister;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG | MV_DEBUG_INTERRUPTS,
+             " %d: IO Granularity Interrupt."
+             "Cause = 0x%08x", pAdapter->adapterId, mainCause);
+    if (mainCause & MV_IOG_TRANS_LOW_BIT)
+    {
+
+        iogCauseRegister = MV_REG_READ_DWORD(ioBaseAddr,
+                                             MV_IOG_TRANS_LOW_REG_OFFSET);
+        MV_REG_WRITE_DWORD (ioBaseAddr,
+                            MV_IOG_TRANS_LOW_REG_OFFSET,
+                            ~iogCauseRegister);
+        if (MV_TRUE == pAdapter->iogEnabled)
+            checkIogCompletion(pAdapter, iogCauseRegister, 0);
+    }
+    if (mainCause & MV_IOG_TRANS_HIGH_BIT)
+    {
+        iogCauseRegister = MV_REG_READ_DWORD(ioBaseAddr,
+                                             MV_IOG_TRANS_HIGH_REG_OFFSET);
+        MV_REG_WRITE_DWORD (ioBaseAddr,
+                            MV_IOG_TRANS_HIGH_REG_OFFSET,
+                            ~iogCauseRegister);
+        if (MV_TRUE == pAdapter->iogEnabled)
+            checkIogCompletion(pAdapter, iogCauseRegister, 32);
+    }
+}
+
+
+/*******************************************************************************
+* iogReset - reset all settings in HW related to I/O granularity.
+*
+* DESCRIPTION:
+*       The function is executed when the error is occured and IO granularity
+*       is enabled for the adapter. The function performs the following
+*       operations
+*       1. IO granularity interrupts are masked
+*       2. Clear IO granularity cause registers
+*       3. Reset all IO granularity transcation counters
+*
+* INPUT:
+*       pAdapter     - Pointer to the MV88SX60XX adapter data structure.
+*
+* RETURN:
+*        None
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+static MV_BOOLEAN iogReset(MV_SATA_ADAPTER *pAdapter)
+{
+    MV_U32 i;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " %d: IO Granularity error handler is executed.\n.",
+             pAdapter->adapterId);
+    /*Mask IO Granularity interrupt*/
+    mvOsSemTake(&pAdapter->interruptsMaskSem);
+    MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress,
+                       MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+                       (pAdapter->mainMask & (~MV_IOG_TRANS_INT_MASK)));
+    mvOsSemRelease(&pAdapter->interruptsMaskSem);
+
+    mvOsSemTake(&pAdapter->iogSemaphore);
+    /*Clear IO Granularity cause registers*/
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_IOG_TRANS_LOW_REG_OFFSET,
+                        0);
+    MV_REG_WRITE_DWORD (pAdapter->adapterIoBaseAddress,
+                        MV_IOG_TRANS_HIGH_REG_OFFSET,
+                        0);
+
+    /*Set all transaction counters to zero*/
+    for (i = 0; i < MV_IOG_QUEUE_SIZE; i += 4)
+    {
+        MV_U32 offset  = MV_IOG_TRANS_CTRL_REG_OFFSET + i;
+        MV_REG_WRITE_DWORD(pAdapter->adapterIoBaseAddress, offset, 0);
+    }
+    mvOsSemRelease(&pAdapter->iogSemaphore);
+}
+
+
+
+#endif
+
+#ifdef MV_LOGGER
+void _dumpPCIRegs(MV_SATA_ADAPTER *pAdapter)
+{
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d "
+                 "_dumpPCIRegs failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId);
+        return ;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d :Dump PCI Regs\n",
+             pAdapter->adapterId);
+
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Main interrupt Cause",MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_MAIN_INTERRUPT_CAUSE_REG_OFFSET));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Main interrupt Mask",MV_MAIN_INTERRUPT_MASK_REG_OFFSET,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                               MV_MAIN_INTERRUPT_MASK_REG_OFFSET));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "SErr Mask",0xC28,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0xc28));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Error Addr Low",0x1d40,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d40));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Error Addr High",0x1d44,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d44));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Error Attr",0x1d48,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d48));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Error Command",0x1d50,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d50));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Intr Cause",0x1d58,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d58));
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%-25s  %04x %08x\n",
+             "Intr Mask",0x1d5c,
+             MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress, 0x1d5c));
+}
+static MV_U32 getRegField(MV_U32 regVal, MV_U32 fieldOff, MV_U32 bitsNum)
+{
+    MV_U32  mask = ((1 << bitsNum) - 1) << fieldOff;
+    return(regVal & mask) >> fieldOff;
+}
+void _dumpEDMARegs(MV_SATA_ADAPTER *pMvSataAdapter, MV_U8 channelIndex)
+{
+    MV_U32  regVal, regOff;
+
+    if (pMvSataAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d "
+                 "_dumpEDMARegs failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pMvSataAdapter->adapterId, channelIndex);
+        return;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d:Dump Edma HW Regs\n",
+             pMvSataAdapter->adapterId, channelIndex);
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_CONFIG_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " EMDA CFG   off 0x%08x val 0x%08x: depth 0x%x NCQ %x BURST SIZE %x "
+             "eQueue %x Stop On Err %x BURST EXT %x WRITE BURST SIZE %x\n",
+             regOff, regVal,
+             getRegField(regVal, 0, 5),
+             getRegField(regVal, 5, 1),
+             getRegField(regVal, 8, 1),
+             getRegField(regVal, 9, 1),
+             getRegField(regVal, 10, 1),
+             getRegField(regVal, 11, 1),
+             getRegField(regVal, 13, 1));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_INTERRUPT_ERROR_CAUSE_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Intr Cause off 0x%08x val 0x%08x\n", regOff, regVal);
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_INTERRUPT_ERROR_MASK_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Intr Mask  off 0x%08x val 0x%08x\n", regOff, regVal);
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_REQUEST_Q_BAH_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Req AddrHi off 0x%08x val 0x%08x\n", regOff, regVal);
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_REQUEST_Q_INP_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Req INP    off 0x%08x val 0x%08x: INP 0x%x BA 0x%x\n",
+             regOff, regVal,
+             getRegField(regVal, 5, 5),
+             getRegField(regVal, 10, 22));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_REQUEST_Q_OUTP_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Req OUTP   off 0x%08x val 0x%08x: OUT 0x%x\n",
+             regOff, regVal,
+             getRegField(regVal, 5, 5));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_RESPONSE_Q_BAH_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Res AddrHi off 0x%08x val 0x%08x\n",
+             regOff, regVal);
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_RESPONSE_Q_INP_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Res INP    off 0x%08x val 0x%08x: INP 0x%x\n",
+             regOff, regVal,
+             getRegField(regVal, 3, 5));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_RESPONSE_Q_OUTP_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Res OUTP   off 0x%08x val 0x%08x: OUTP 0x%x BA 0x%x\n",
+             regOff, regVal,
+             getRegField(regVal, 3, 5),
+             getRegField(regVal, 8, 24));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_COMMAND_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Command    off 0x%08x val 0x%08x: EN %x DIS %x HW RESET %x\n",
+             regOff, regVal,
+             getRegField(regVal, 0, 1),
+             getRegField(regVal, 1, 1),
+             getRegField(regVal, 2, 1));
+
+    regOff = edmaRegOffst[ channelIndex] + MV_EDMA_STATUS_REG_OFFSET;
+    regVal = mvSataReadReg(pMvSataAdapter, regOff);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR," Status     off 0x%08x val 0x%08x: TAG 0x%x\n",
+             regOff, regVal,
+             getRegField(regVal, 0, 5));
+
+
+
+
+
+
+
+}
+
+void _dumpChannelQueues(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_U32  i;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d "
+                 "_dumpChannelQueues failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId, channelIndex);
+        return ;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "%d %d:Dump Channel Queues\n",
+             pAdapter->adapterId, channelIndex);
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: _dumpChannelQueues"
+                 "el Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return ;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "Request Qeueu Info:\n");
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " virt addr %p:\n",
+             pSataChannel->requestQueue);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " phy low addr %08x:\n",
+             pSataChannel->requestQueuePciLowAddress);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " phy high addr %08x:\n",
+             pSataChannel->requestQueuePciHiAddress);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " SW IN pointer %x:\n",
+             pSataChannel->reqInPtr);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "Request Qeueu Entries:\n");
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "Index [3:0]       [7:4]       [11:8]       [15:12]\n");
+    for (i = 0; i < MV_EDMA_QUEUE_LENGTH; i++)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 "[%2d] 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",i,
+                 *((MV_U32 *)(pSataChannel->requestQueue + i)),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 1),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 2),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 3),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 4),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 5),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 6),
+                 *(((MV_U32 *)(pSataChannel->requestQueue + i)) + 7));
+    }
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "Responset Qeueu Info:\n");
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " virt addr %p:\n",
+             pSataChannel->responseQueue);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " phy low addr %08x:\n",
+             pSataChannel->responseQueuePciLowAddress);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " phy high addr %08x:\n",
+             pSataChannel->responseQueuePciHiAddress);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " SW OUT pointer %x:\n",
+             pSataChannel->rspOutPtr);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "Response Qeueu Entries:\n");
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "Index [1:0]   [3:2]   [7:4]\n");
+    for (i = 0; i < MV_EDMA_QUEUE_LENGTH; i++)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 "[%2d] 0x%04x  0x%04x  0x%08x\n",i,
+                 *((MV_U16 *)(pSataChannel->responseQueue + i)),
+                 *(((MV_U16 *)(pSataChannel->responseQueue + i)) + 1),
+                 *(((MV_U32 *)(pSataChannel->responseQueue + i)) + 1));
+    }
+
+
+
+
+
+
+
+}
+void _dumpSataRegs(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_U32  regVal;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d "
+                 "_dumpSataRegs failed - "
+                 "Bad adapter data structure pointer.\n",
+                 pAdapter->adapterId, channelIndex);
+        return;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegOffst[ channelIndex]  +
+                                   MV_SATA_II_S_STATUS_REG_OFFSET);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " SStatus  0x%08x:\n", regVal);
+
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegOffst[ channelIndex]  +
+                                   MV_SATA_II_S_CONTROL_REG_OFFSET);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " SControl 0x%08x:\n", regVal);
+
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegOffst[ channelIndex]  +
+                                   MV_SATA_II_S_ERROR_REG_OFFSET);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " SError    0x%08x:\n", regVal);
+
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegOffst[ channelIndex]  +
+                                   MV_SATA_II_IF_CONTROL_REG_OFFSET);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " IF Ctrl  0x%08x: TXPort 0x%x\n", regVal,
+                 getRegField(regVal, 0, 4));
+        regVal = MV_REG_READ_DWORD(pAdapter->adapterIoBaseAddress,
+                                   edmaRegOffst[ channelIndex]  +
+                                   MV_SATA_II_IF_STATUS_REG_OFFSET);
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 " IF status 0x%08x: RXFIS 0x%x RXPort 0x%x\n", regVal,
+                 getRegField(regVal, 0, 8),
+                 getRegField(regVal, 8, 4));
+    }
+}
+void _printATARegs(MV_STORAGE_DEVICE_REGISTERS   *pDeviceRegs)
+{
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             " ATA Drive Registers:\n");
+    if (pDeviceRegs == NULL)
+    {
+        return;
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","Error", pDeviceRegs->errorRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","SectorCount", pDeviceRegs->sectorCountRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","LBA Low", pDeviceRegs->lbaLowRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","LBA Mid", pDeviceRegs->lbaMidRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","LBA High", pDeviceRegs->lbaHighRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","Device", pDeviceRegs->deviceRegister);
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+             "%20s : %04x\n","Status", pDeviceRegs->statusRegister);
+}
+
+#endif /*MV_LOGGER*/
+
+
+
+
+
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvSata.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvSata.h
@@ -0,0 +1,573 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvSata.h - Header File for mvSata.c.
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       mvOs.h
+*       ATA/ATAPI-6 standard
+*
+*******************************************************************************/
+#ifndef __INCmvSatah
+#define __INCmvSatah
+#ifdef __cplusplus
+extern "C" /*{*/
+#endif /* __cplusplus */
+
+/* Includes */
+#include "mvOs.h"
+#include "mvRegs.h"
+
+/* Definitions */
+#define MV_CORE_DRIVER_LOG_ID                   0
+
+
+
+/* MV88SX50XX specific defines */
+#define MV_SATA_VENDOR_ID                       0x11AB
+#define MV_SATA_DEVICE_ID_5080                  0x5080
+#define MV_SATA_DEVICE_ID_5081                  0x5081
+#define MV_SATA_DEVICE_ID_5040                  0x5040
+#define MV_SATA_DEVICE_ID_5041                  0x5041
+#define MV_SATA_DEVICE_ID_6041                  0x6041
+#define MV_SATA_DEVICE_ID_6081                  0x6081
+#define MV_SATA_CHANNELS_NUM                    8
+#define MV_SATA_UNITS_NUM                       2
+
+#define MV_SATA_PM_MAX_PORTS                    15
+#define MV_SATA_PM_CONTROL_PORT                 15
+
+#define MV_EDMA_QUEUE_LENGTH                    32  /* Up to 32 outstanding  */
+/* commands per SATA channel*/
+#ifndef MV_SATA_OVERRIDE_SW_QUEUE_SIZE
+    #define MV_SATA_SW_QUEUE_SIZE                   (MV_EDMA_QUEUE_LENGTH -1)
+#else
+    #define MV_SATA_SW_QUEUE_SIZE                   MV_SATA_REQUESTED_SW_QUEUE_SIZE
+#endif
+
+
+#define MV_EDMA_QUEUE_MASK                      0x1F
+#define MV_EDMA_REQUEST_ENTRY_SIZE              32
+#define MV_EDMA_RESPONSE_ENTRY_SIZE             8
+#define MV_EDMA_REQUEST_QUEUE_SIZE              1024 /* 32*32 = 1KBytes */
+#define MV_EDMA_RESPONSE_QUEUE_SIZE             256  /* 32*8 = 256 Bytes */
+
+#define MV_EDMA_PRD_ENTRY_SIZE                  16      /* 16Bytes*/
+#define MV_EDMA_PRD_NO_SNOOP_FLAG               MV_BIT0
+#define MV_EDMA_PRD_EOT_FLAG                    MV_BIT15
+
+#define MV_ATA_IDENTIFY_DEV_DATA_LENGTH         256 /* number of words(2 byte)*/
+#define MV_ATA_MODEL_NUMBER_LEN                 40
+#define ATA_SECTOR_SIZE                         512
+#define ATA_SECTOR_SIZE_IN_WORDS                256
+
+#define MV_SATA_COMM_INIT_DELAY                 1000 /*1000 us*/
+#define MV_SATA_COMM_INIT_WAIT_DELAY            20000 /*20 ms*/
+
+/*Channel to Channel*/
+#ifdef MV_SATA_C2C_COMM
+    #define MV_SATA_REGISTER_HOST_2_DEVICE_FIS         0x00000034
+    #define MV_SATA_DMA_ACTIVATE_FIS                   0x00000039
+    #define MV_C2C_MESSAGE_SIZE                        10
+
+#endif
+
+#ifdef MV_SATA_IO_GRANULARITY
+    #define MV_IOG_QUEUE_SIZE           0x40
+    #define MV_IOG_INVALID_COMMAND_ID   MV_IOG_QUEUE_SIZE
+#endif
+
+/* Typedefs    */
+typedef enum mvUdmaType
+{
+    MV_UDMA_TYPE_READ, MV_UDMA_TYPE_WRITE
+} MV_UDMA_TYPE;
+
+typedef enum mvFlushType
+{
+    MV_FLUSH_TYPE_CALLBACK, MV_FLUSH_TYPE_NONE
+} MV_FLUSH_TYPE;
+
+typedef enum mvCompletionType
+{
+    MV_COMPLETION_TYPE_NORMAL, MV_COMPLETION_TYPE_ERROR,
+    MV_COMPLETION_TYPE_ABORT
+} MV_COMPLETION_TYPE;
+
+typedef enum mvEventType
+{
+    MV_EVENT_TYPE_ADAPTER_ERROR, MV_EVENT_TYPE_SATA_CABLE,
+    MV_EVENT_TYPE_SATA_ERROR
+} MV_EVENT_TYPE;
+
+typedef enum mvSataCableEvent
+{
+    MV_SATA_CABLE_EVENT_DISCONNECT = 0,
+    MV_SATA_CABLE_EVENT_CONNECT,
+    MV_SATA_CABLE_EVENT_PM_HOT_PLUG
+} MV_SATA_CABLE_EVENT;
+
+typedef enum mvSataErrorEvent
+{
+    MV_SATA_RECOVERABLE_COMMUNICATION_ERROR = 0,
+    MV_SATA_UNRECOVERABLE_COMMUNICATION_ERROR,
+    MV_SATA_DEVICE_ERROR
+} MV_SATA_ERROR_EVENT;
+
+#ifdef MV_SATA_C2C_COMM
+typedef enum mvC2CEventType
+{
+    MV_C2C_REGISTER_DEVICE_TO_HOST_FIS_DONE,
+    MV_C2C_REGISTER_DEVICE_TO_HOST_FIS_ERROR,
+    MV_C2C_BM_DMA_DONE,
+    MV_C2C_BM_DMA_ERROR,
+} MV_C2C_EVENT_TYPE;
+#endif
+
+typedef enum mvEdmaMode
+{
+    MV_EDMA_MODE_QUEUED,
+    MV_EDMA_MODE_NOT_QUEUED,
+    MV_EDMA_MODE_NATIVE_QUEUING
+} MV_EDMA_MODE;
+
+typedef enum mvQueueCommandResult
+{
+    MV_QUEUE_COMMAND_RESULT_OK = 0,
+    MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED,
+    MV_QUEUE_COMMAND_RESULT_FULL,
+    MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS,
+    MV_QUEUE_COMMAND_RESULT_BAD_PARAMS
+} MV_QUEUE_COMMAND_RESULT;
+
+typedef enum mvNonUdmaProtocol
+{
+    MV_NON_UDMA_PROTOCOL_NON_DATA,
+    MV_NON_UDMA_PROTOCOL_PIO_DATA_IN,
+    MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT
+} MV_NON_UDMA_PROTOCOL;
+
+typedef enum mvSataGeneration
+{
+    MV_SATA_GEN_I, MV_SATA_GEN_II
+} MV_SATA_GEN;
+
+typedef enum mvSataInterfaceSpeed
+{
+    MV_SATA_IF_SPEED_1_5_GBPS, MV_SATA_IF_SPEED_3_GBPS,
+    MV_SATA_IF_SPEED_NO_LIMIT, MV_SATA_IF_SPEED_INVALID
+} MV_SATA_IF_SPEED;
+
+#ifdef MV_SATA_C2C_COMM
+typedef enum mvSataC2CMode
+{
+    MV_SATA_C2C_MODE_INITIATOR, MV_SATA_C2C_MODE_TARGET
+} MV_SATA_C2C_MODE;
+#endif
+
+typedef enum mvSataDeviceType
+{
+    MV_SATA_DEVICE_TYPE_UNKNOWN = 0,
+    MV_SATA_DEVICE_TYPE_ATA_DISK,
+    MV_SATA_DEVICE_TYPE_ATAPI_DISK,
+    MV_SATA_DEVICE_TYPE_PM
+} MV_SATA_DEVICE_TYPE;
+
+struct mvDmaRequestQueueEntry;
+struct mvDmaResponseQueueEntry;
+struct mvDmaCommandEntry;
+
+struct mvSataAdapter;
+struct mvStorageDevRegisters;
+struct mvSataChannel;
+
+typedef MV_BOOLEAN (* mvSataCommandCompletionCallBack_t)(struct mvSataAdapter *,
+                                                         MV_U8,
+                                                         MV_COMPLETION_TYPE,
+                                                         MV_VOID_PTR, MV_U16,
+                                                         MV_U32,
+                                                         struct mvStorageDevRegisters *);
+#ifdef MV_SATA_C2C_COMM
+typedef  MV_BOOLEAN (*C2CCallBack_t)(struct mvSataAdapter *,
+                                     struct mvSataChannel *,
+                                     MV_C2C_EVENT_TYPE event,
+                                     MV_U32 msgSize,
+                                     MV_U8* msg);
+
+#endif
+
+typedef enum mvQueuedCommandType
+{
+    MV_QUEUED_COMMAND_TYPE_UDMA,
+    MV_QUEUED_COMMAND_TYPE_NONE_UDMA
+} MV_QUEUED_COMMAND_TYPE;
+
+#ifdef MV_SATA_IO_GRANULARITY
+typedef enum mvIogQueuedCommandType
+{
+    MV_IOG_COMMAND_TYPE_FIRST,
+    MV_IOG_COMMAND_TYPE_NEXT
+}   MV_IOG_COMMAND_TYPE;
+#endif
+
+typedef enum mvSataInterruptScheme
+{
+    MV_SATA_INTERRUPT_HANDLING_IN_ISR,
+    MV_SATA_INTERRUPT_HANDLING_IN_TASK,
+    MV_SATA_INTERRUPTS_DISABLED
+}MV_SATA_INTERRUPT_SCHEME;
+
+typedef struct mvUdmaCommandParams
+{
+    MV_UDMA_TYPE readWrite;
+    MV_BOOLEAN   isEXT;
+    MV_BOOLEAN   FUA;
+    MV_U32       lowLBAAddress;
+    MV_U16       highLBAAddress;
+    MV_U16       numOfSectors;
+    MV_U32       prdLowAddr;
+    MV_U32       prdHighAddr;
+    mvSataCommandCompletionCallBack_t callBack;
+    MV_VOID_PTR  commandId;
+#ifdef MV_SATA_IO_GRANULARITY
+    MV_BOOLEAN   ioGranularityEnabled;
+    MV_IOG_COMMAND_TYPE  iogCommandType;
+    union
+    {
+        MV_U8 transId;
+        MV_U8 transCount;
+    }   ioGranularityCommandParam;
+    MV_U8 iogCurrentTransId;
+#endif
+} MV_UDMA_COMMAND_PARAMS;
+
+typedef struct mvNoneUdmaCommandParams
+{
+    MV_NON_UDMA_PROTOCOL protocolType;
+    MV_BOOLEAN  isEXT;
+    MV_U16_PTR  bufPtr;
+    MV_U32      count;
+    MV_U16      features;
+    MV_U16      sectorCount;
+    MV_U16      lbaLow;
+    MV_U16      lbaMid;
+    MV_U16      lbaHigh;
+    MV_U8       device;
+    MV_U8       command;
+    mvSataCommandCompletionCallBack_t callBack;
+    MV_VOID_PTR  commandId;
+} MV_NONE_UDMA_COMMAND_PARAMS;
+
+typedef struct mvQueueCommandInfo
+{
+    MV_QUEUED_COMMAND_TYPE  type;
+    MV_U8   PMPort;
+    union
+    {
+        MV_UDMA_COMMAND_PARAMS      udmaCommand;
+        MV_NONE_UDMA_COMMAND_PARAMS NoneUdmaCommand;
+    } commandParams;
+} MV_QUEUE_COMMAND_INFO;
+
+/* The following structure is for the Core Driver internal usage */
+typedef struct mvQueuedCommandEntry
+{
+    MV_BOOLEAN   isFreeEntry;
+    MV_U8        commandTag;
+    MV_BOOLEAN   isCommandInEdma;
+    struct mvQueuedCommandEntry *next;
+    struct mvQueuedCommandEntry *prev;
+    MV_QUEUE_COMMAND_INFO   commandInfo;
+} MV_QUEUED_COMMAND_ENTRY;
+
+
+typedef enum mvNCQErrorHandlingState
+{
+    MV_NCQ_ERROR_HANDLING_STATE_IDLE,
+    MV_NCQ_ERROR_HANDLING_STATE_WAIT_FOR_COMPLETIONS,
+    MV_NCQ_ERROR_HANDLING_STATE_WAIT_FOR_BUSY,
+    MV_NCQ_ERROR_HANDLING_STATE_REQUEST_SENSE
+}MV_NCQ_ERROR_HANDLING_STATE;
+
+typedef struct
+{
+    MV_NCQ_ERROR_HANDLING_STATE state;
+    MV_U16                      PortsWithErrors;/*which ports reported errors*/
+    MV_U8                       CurrPort;
+    MV_QUEUED_COMMAND_ENTRY     *pReadLogExtEntry;
+    MV_U16_PTR                  ReadLogExtBuffer;
+}MV_NCQ_ERROR_HANDLING_INFO;
+/* The following structures are part of the Core Driver API */
+typedef struct mvSataChannel
+{
+    /* Fields set by Intermediate Application Layer */
+    MV_U8                       channelNumber;
+    struct mvDmaRequestQueueEntry  *requestQueue;
+    struct mvDmaResponseQueueEntry *responseQueue;
+    MV_U32                      requestQueuePciHiAddress;
+    MV_U32                      requestQueuePciLowAddress;
+    MV_U32                      responseQueuePciHiAddress;
+    MV_U32                      responseQueuePciLowAddress;
+    /* DRQ Data Block size in sectors, Core Driver sets a default value of 1 */
+    /* sector in mvSataConfigureChannel*/
+    MV_U8                       DRQDataBlockSize;
+    /* Fields set by CORE driver */
+    struct mvSataAdapter        *mvSataAdapter;
+    MV_OS_SEMAPHORE             semaphore;
+    MV_U32                      eDmaRegsOffset;
+    MV_BOOLEAN                  EdmaActive;
+    MV_EDMA_MODE                queuedDMA;
+    MV_U8                       outstandingCommands;
+    MV_U8                       portQueuedCommands[MV_SATA_PM_MAX_PORTS + 1];
+    struct mvQueuedCommandEntry commandsQueue[MV_SATA_SW_QUEUE_SIZE];
+    struct mvQueuedCommandEntry *commandsQueueHead;
+    struct mvQueuedCommandEntry *commandsQueueTail;
+    MV_BOOLEAN                  queueCommandsEnabled;
+    MV_U8                       noneUdmaOutstandingCommands;
+    MV_U8                       EdmaQueuedCommands;
+    MV_U32                      freeIDsStack[MV_SATA_SW_QUEUE_SIZE];
+    MV_U32                      freeIDsNum;
+    MV_U32                      reqInPtr;
+    MV_U32                      rspOutPtr;
+    /* Port Multiplier fiels*/
+    MV_BOOLEAN                  PMSupported;
+    MV_SATA_DEVICE_TYPE         deviceType;
+
+#ifdef MV_SATA_C2C_COMM
+
+    /* Channel 2 Channel*/
+    MV_BOOLEAN                  C2CmodeEnabled;
+    MV_SATA_C2C_MODE            C2CMode;
+    C2CCallBack_t               C2CCallback;
+#endif
+    MV_U8                       recoveredErrorsCounter;
+    /* NCQ error handling*/
+    MV_NCQ_ERROR_HANDLING_INFO  NCQErrHandlingInfo;
+} MV_SATA_CHANNEL;
+
+
+
+typedef struct mvSataAdapter
+{
+    /* Fields set by Intermediate Application Layer */
+    MV_U32            adapterId;
+    MV_VOID_PTR       IALData;
+    MV_U8             pciConfigRevisionId;
+    MV_U16            pciConfigDeviceId;
+    MV_BUS_ADDR_T     adapterIoBaseAddress;
+    MV_U32            intCoalThre[MV_SATA_UNITS_NUM];
+    MV_U32            intTimeThre[MV_SATA_UNITS_NUM];
+    MV_BOOLEAN        (*mvSataEventNotify)(struct mvSataAdapter *,
+                                           MV_EVENT_TYPE,
+                                           MV_U32, MV_U32);
+    MV_SATA_CHANNEL   *sataChannel[MV_SATA_CHANNELS_NUM];
+    MV_U32            pciCommand;
+    MV_U32            pciSerrMask;
+    MV_U32            pciInterruptMask;
+
+
+    /* Fields set by CORE driver */
+    MV_SATA_GEN       sataAdapterGeneration;
+    MV_BOOLEAN        staggaredSpinup[MV_SATA_CHANNELS_NUM]; /* For 60x1 only */
+    MV_BOOLEAN        limitInterfaceSpeed[MV_SATA_CHANNELS_NUM]; /* For 60x1 only */
+    MV_SATA_IF_SPEED  ifSpeed[MV_SATA_CHANNELS_NUM];  /* For 60x1 only */
+    MV_U8             numberOfChannels;/* 4 channels for 504x, 8 for 508x*/
+    MV_U8             numberOfUnits;/* 1 for 504x, 2 for 508x*/
+    MV_OS_SEMAPHORE   semaphore;
+    MV_U32            mainMask;
+    MV_BOOLEAN        interruptsAreMasked;
+    MV_SATA_INTERRUPT_SCHEME interruptsScheme;
+    MV_OS_SEMAPHORE   interruptsMaskSem;
+    MV_BOOLEAN        chipIs50XXB0;
+    MV_BOOLEAN        chipIs50XXB2;
+    MV_BOOLEAN        chipIs60X1B2;
+    MV_BOOLEAN        chipIs60X1C0;
+    MV_U8             signalAmps[MV_SATA_CHANNELS_NUM];
+    MV_U8             pre[MV_SATA_CHANNELS_NUM];
+#ifdef MV_SATA_IO_GRANULARITY
+    MV_BOOLEAN        iogEnabled;
+    MV_U8             iogFreeIdsStack[MV_IOG_QUEUE_SIZE];
+    MV_U8             iogFreeIdsNum;
+    MV_OS_SEMAPHORE   iogSemaphore;
+#endif
+} MV_SATA_ADAPTER;
+
+/* this structure used by the IAL defines the PRD entries used by the EDMA HW */
+typedef struct mvSataEdmaPRDEntry
+{
+    volatile MV_U32 lowBaseAddr;
+    volatile MV_U16 byteCount;
+    volatile MV_U16 flags;
+    volatile MV_U32 highBaseAddr;
+    volatile MV_U32 reserved;
+}MV_SATA_EDMA_PRD_ENTRY;
+
+/* API Functions */
+
+/* CORE driver Adapter Management */
+MV_BOOLEAN mvSataInitAdapter(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataShutdownAdapter(MV_SATA_ADAPTER *pAdapter);
+
+MV_U32  mvSataReadReg(MV_SATA_ADAPTER *pAdapter, MV_U32 regOffset);
+
+MV_VOID mvSataWriteReg(MV_SATA_ADAPTER *pAdapter, MV_U32 regOffset,
+                       MV_U32 regValue);
+
+/* CORE driver SATA Channel Management */
+MV_BOOLEAN mvSataConfigureChannel(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataRemoveChannel(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataIsStorageDeviceConnected(MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataChannelHardReset(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex);
+
+
+MV_BOOLEAN mvSataConfigEdmaMode(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                                MV_EDMA_MODE eDmaMode, MV_U8 maxQueueDepth);
+
+MV_BOOLEAN mvSataEnableChannelDma(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataDisableChannelDma(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataFlushDmaQueue(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                               MV_FLUSH_TYPE flushType);
+
+MV_U8 mvSataNumOfDmaCommands(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+MV_U8 mvSataGetNumOfPortQueuedCommands(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex,
+                                  MV_U8 PMPort,
+                                  MV_U8 *pCommandsPerChannel);
+
+MV_BOOLEAN mvSataSetIntCoalParams (MV_SATA_ADAPTER *pAdapter, MV_U8 sataUnit,
+                                   MV_U32 intCoalThre, MV_U32 intTimeThre);
+
+MV_BOOLEAN mvSataSetChannelPhyParams(MV_SATA_ADAPTER *pAdapter,
+                                     MV_U8 channelIndex,
+                                     MV_U8 signalAmps, MV_U8 pre);
+
+MV_BOOLEAN mvSataChannelPhyShutdown(MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataChannelPhyPowerOn(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataChannelFarLoopbackDiagnostic(MV_SATA_ADAPTER *pAdapter,
+                                              MV_U8 channelIndex);
+/* Queue ATA command */
+MV_QUEUE_COMMAND_RESULT mvSataQueueCommand(MV_SATA_ADAPTER *pAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_QUEUE_COMMAND_INFO *pCommandParams);
+
+
+/* Interrupt Service Routine */
+MV_BOOLEAN mvSataInterruptServiceRoutine(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataMaskAdapterInterrupt(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataUnmaskAdapterInterrupt(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataCheckPendingInterrupt(MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataSetInterruptsScheme(MV_SATA_ADAPTER *pAdapter,
+                                     MV_SATA_INTERRUPT_SCHEME interruptScheme);
+
+/*
+ * Staggered spin-ip support and SATA interface speed control
+ * (relevant for 60x1 adapters)
+ */
+MV_BOOLEAN mvSataEnableStaggeredSpinUpAll (MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataEnableStaggeredSpinUp (MV_SATA_ADAPTER *pAdapter,
+                                        MV_U8 channelIndex);
+
+MV_BOOLEAN mvSataDisableStaggeredSpinUpAll (MV_SATA_ADAPTER *pAdapter);
+
+MV_BOOLEAN mvSataDisableStaggeredSpinUp (MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex);
+
+
+MV_BOOLEAN mvSataSetInterfaceSpeed (MV_SATA_ADAPTER *pAdapter,
+                                    MV_U8 channelIndex,
+                                    MV_SATA_IF_SPEED ifSpeed);
+
+MV_SATA_IF_SPEED mvSataGetInterfaceSpeed (MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex);
+
+
+/* Command Completion and Event Notification (user implemented) */
+MV_BOOLEAN mvSataEventNotify(MV_SATA_ADAPTER *, MV_EVENT_TYPE ,
+                             MV_U32, MV_U32);
+#ifdef MV_SATA_C2C_COMM
+
+/* Channel 2 Channel communication */
+MV_BOOLEAN mvSataC2CInit (MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                          MV_SATA_C2C_MODE mvSataC2CMode,
+                          C2CCallBack_t mvSataC2CCallBack);
+
+MV_BOOLEAN mvSataC2CStop (MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+
+MV_BOOLEAN  mvSataC2CSendRegisterDeviceToHostFIS(
+                                                MV_SATA_ADAPTER *pAdapter,
+                                                MV_U8 channelIndex,
+                                                MV_U8 pmPort,
+                                                MV_BOOLEAN bInterrupt,
+                                                MV_U8 message[MV_C2C_MESSAGE_SIZE]);
+
+MV_BOOLEAN  mvSataC2CActivateBmDma(MV_SATA_ADAPTER *pAdapter,
+                                   MV_U8 channelIndex,
+                                   MV_U8 pmPort,
+                                   MV_U32 prdTableHi,
+                                   MV_U32 prdTableLow,
+                                   MV_UDMA_TYPE dmaType);
+
+MV_BOOLEAN mvSataC2CResetBmDma(MV_SATA_ADAPTER *pAdapter,
+                               MV_U8 channelIndex);
+
+#endif
+
+#ifdef MV_SATA_IO_GRANULARITY
+
+MV_BOOLEAN mvSataEnableIoGranularity(MV_SATA_ADAPTER *pAdapter,
+                                     MV_BOOLEAN enable);
+
+#endif
+
+#ifdef __cplusplus
+
+/*}*/
+#endif /* __cplusplus */
+
+#endif /* __INCmvSatah */
Index: linux-2.6.10/drivers/scsi/mvsata/mvScsiAtaLayer.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvScsiAtaLayer.c
@@ -0,0 +1,2818 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvScsiAtaLayer.c
+*
+* DESCRIPTION:
+*       C implementation for SCSI to ATA translation layer.
+*
+* DEPENDENCIES:
+*   mvIALCommon.h
+*   mvScsiAtaLayer.h
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvScsiAtaLayer.h"
+#include "mvIALCommon.h"
+
+#ifdef MV_LOGGER
+    #define SAL_SPRINTF     sprintf
+#endif
+
+/* ATA defines */
+/* Bits for HD_ERROR */
+#define NM_ERR          0x02    /* media present */
+#define ABRT_ERR        0x04    /* Command aborted */
+#define MCR_ERR         0x08    /* media change request */
+#define IDNF_ERR        0x10    /* ID field not found */
+#define MC_ERR          0x20    /* media changed */
+#define UNC_ERR         0x40    /* Uncorrect data */
+#define WP_ERR          0x40    /* write protect */
+#define ICRC_ERR        0x80    /* new meaning:  CRC error during transfer */
+
+#ifdef MV_LOGGER
+static MV_VOID reportScbCompletion(MV_SATA_ADAPTER*    pSataAdapter,
+                                   MV_SATA_SCSI_CMD_BLOCK *pScb);
+#endif
+
+/* Locals */
+static MV_VOID mvAta2HostString(IN   MV_U16 *source,
+                                OUT  MV_U16 *target,
+                                IN   MV_U32 wordsCount);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetInquiryData(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                            IN  MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaTestUnitReady(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                           IN  MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendDataCommand(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                             IN  MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetReadCapacityData(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                                 IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendVerifyCommand(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                               IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaReassignBlocks(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                            IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendSyncCacheCommand(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                                  IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetRequestSenseData(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                                 IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetModeSenseData(IN    MV_SATA_ADAPTER*    pSataAdapter,
+                                                              IN    MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_BOOLEAN  mvScsiAtaGetModeSenseDataPhase2(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                   IN  MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaModeSelect(IN    MV_SATA_ADAPTER*    pSataAdapter,
+                                                        IN    MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_U8 modeSelect(IN MV_SATA_ADAPTER    *pSataAdapter,
+                        IN  MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                        MV_SCSI_COMMAND_STATUS_TYPE *pCommandStatus);
+
+static MV_U8 mvParseModeCachingPage(MV_SATA_ADAPTER *pSataAdapter,
+                                    IN  MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                    MV_U8 *buffer,
+                                    MV_SCSI_COMMAND_STATUS_TYPE *pCommandStatus);
+static MV_U32 mvModeSenseCachingPage(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                     MV_U8 *buffer, MV_U8 pageControl);
+
+static MV_U32 mvModeSenseControlPage(MV_SATA_ADAPTER *pSataAdapter,
+                                     MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                     MV_U8 *buffer, MV_U8 pageControl);
+
+static MV_BOOLEAN SALCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                                         MV_U8 channelNum,
+                                         MV_COMPLETION_TYPE comp_type,
+                                         MV_VOID_PTR commandId,
+                                         MV_U16 responseFlags,
+                                         MV_U32 timeStamp,
+                                         MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+ MV_VOID handleNoneUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                                   MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+static MV_VOID handleUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                               MV_U32 responseFlags,
+                               MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+/*static*/ MV_VOID  checkQueueCommandResult(MV_SATA_SCSI_CMD_BLOCK *pScb,
+                                        MV_QUEUE_COMMAND_RESULT result);
+
+static MV_VOID  mvScsiAtaSendSplittedVerifyCommand(IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_VOID  mvScsiAtaSendReadLookAhead(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                           IN MV_SATA_SCSI_CMD_BLOCK  *pScb);
+
+static MV_VOID mvAta2HostString(IN MV_U16 *source,
+                                OUT MV_U16 *target,
+                                IN MV_U32 wordsCount
+                               )
+{
+    MV_U32 i;
+    for (i=0 ; i < wordsCount; i++)
+    {
+        target[i] = (source[i] >> 8) | ((source[i] & 0xff) << 8);
+        target[i] = MV_LE16_TO_CPU(target[i]);
+    }
+}
+
+MV_VOID setSenseData(IN MV_SATA_SCSI_CMD_BLOCK *pScb, IN MV_U8 SenseKey,
+                     IN MV_U8 AdditionalSenseCode, IN MV_U8 ASCQ)
+{
+    MV_SCSI_SENSE_DATA SenseData;
+
+    if (pScb->senseBufferLength == 0)
+    {
+        pScb->senseDataLength = 0;
+        return;
+    }
+    memset(&SenseData, 0, sizeof(MV_SCSI_SENSE_DATA));
+    SenseData.Valid = 0;
+    SenseData.ResponseCode = MV_SCSI_RESPONSE_CODE;
+    SenseData.SenseKey = SenseKey;
+    SenseData.AdditionalSenseCode = AdditionalSenseCode;
+    SenseData.AdditionalSenseCodeQualifier = ASCQ;
+    SenseData.AdditionalSenseLength = sizeof(MV_SCSI_SENSE_DATA) - 8;
+    pScb->senseDataLength = sizeof(MV_SCSI_SENSE_DATA);
+    if (pScb->senseBufferLength < pScb->senseDataLength)
+    {
+        pScb->senseDataLength = pScb->senseBufferLength;
+    }
+    memcpy(pScb->pSenseBuffer, &SenseData, pScb->senseDataLength);
+}
+
+static MV_BOOLEAN checkLBAOutOfRange(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                     IN MV_SATA_SCSI_CMD_BLOCK *pScb,
+                                     IN MV_U32 ATADiskSize, IN MV_U32 LBA,
+                                     IN MV_U32 sectors)
+{
+    if ((ATADiskSize <= LBA) ||  ((ATADiskSize - LBA) < sectors))
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Error LBA out of range. DiskSize %x sectors %x LBA %x\n"
+                 , ATADiskSize, sectors, LBA);
+
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                     SCSI_ADSENSE_ILLEGAL_BLOCK, 0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_TRUE;
+
+    }
+    return MV_FALSE;
+}
+/*******************************************************************************
+* mvScsiAtaGetInquiryData - Get the SCSI-3 standard inquiry(12h) data
+*
+* DESCRIPTION: This function fills the data buffer with Scsi standard inquiry
+*       data according to the ATA Identify data
+*
+* INPUT:
+*   pSataAdapter    - pointer to the SATA adapter data structure.
+*   pScb->bus    - the index of the specific SATA channel.
+*   pScb            - pointer to the Scsi command block.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE on failure.
+*
+* COMMENTS:
+*   No sanity check is done for the parameters.
+*
+*******************************************************************************/
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetInquiryData(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                            IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U8           buff[42];
+    MV_U32          inquiryLen;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    memset(buff, 0, 42);
+
+    if ((pScb->ScsiCdb[1] & (MV_BIT0 | MV_BIT1)) ||
+        (pScb->ScsiCdb[2]))
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%d %d: Inquiry completed with error: cmd[1] %x cmd[2] %x\n",
+                 pSataAdapter->adapterId, pScb->bus, pScb->ScsiCdb[1],
+                 pScb->ScsiCdb[2]);
+        if (pDriveData->UAConditionPending == MV_TRUE)
+        {
+
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Unit Attention condition is pending.\n");
+
+            if (pDriveData->UAEvents & MV_BIT0)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Bus Reset.\n");
+
+                pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_UA_RESET;
+                setSenseData(pScb, SCSI_SENSE_UNIT_ATTENTION, SCSI_ADSENSE_BUS_RESET
+                             , 2);
+                pDriveData->UAEvents &= ~MV_BIT0;
+            }
+            else if (pDriveData->UAEvents & MV_BIT1)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Mode Parameters Changed.\n");
+                pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_UA_PARAMS_CHANGED;
+                setSenseData(pScb, SCSI_SENSE_UNIT_ATTENTION,
+                             SCSI_ADSENSE_PARAMETERS_CHANGED, 1);
+                pDriveData->UAEvents &= ~MV_BIT1;
+            }
+
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->dataTransfered = 0;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            if (pDriveData->UAEvents == 0)
+            {
+                pDriveData->UAConditionPending = MV_FALSE;
+            }
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB,
+                     0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if (pScb->lun)
+    {
+        buff[0] = 0x7f;
+        inquiryLen = 5;
+    }
+    else
+    {
+        MV_U8   Vendor[9],Product[17], temp[24];
+        buff[0] = MV_SCSI_DIRECT_ACCESS_DEVICE;
+        buff[1] = 0;    /* Not Removable disk */
+        buff[2] = 3;    /*claim conformance to SCSI-3*/
+        buff[3] = 2;    /* set RESPONSE DATA FORMAT to 2*/
+        buff[4] = 42 - 4;
+#if 0
+        buff[6] = 0x80;     /* basic queuing*/
+        buff[7] = 0;
+#else
+        buff[6] = 0x0;     /* tagged queuing*/
+        buff[7] = 2;
+#endif
+        memcpy(temp, pDriveData->identifyInfo.model, 24);
+        mvAta2HostString((MV_U16 *)temp, (MV_U16 *)(temp), 12);
+        {
+            MV_U32 i;
+            for (i = 0; i < 9; i++)
+            {
+                if (temp[i] == ' ')
+                {
+                    break;
+                }
+            }
+            if (i == 9)
+            {
+                if (((temp[0] == 'I') && (temp[1] == 'C')) ||
+                    ((temp[0] == 'H') && (temp[1] == 'T')) ||
+                    ((temp[0] == 'H') && (temp[1] == 'D')) ||
+                    ((temp[0] == 'D') && (temp[1] == 'K')))
+                { /*Hitachi*/
+                    Vendor[0] = 'H';
+                    Vendor[1] = 'i';
+                    Vendor[2] = 't';
+                    Vendor[3] = 'a';
+                    Vendor[4] = 'c';
+                    Vendor[5] = 'h';
+                    Vendor[6] = 'i';
+                    Vendor[7] = ' ';
+                    Vendor[8] = '\0';
+                }
+                else if ((temp[0] == 'S') && (temp[1] == 'T'))
+                {
+                    /*Seagate*/
+                    Vendor[0] = 'S';
+                    Vendor[1] = 'e';
+                    Vendor[2] = 'a';
+                    Vendor[3] = 'g';
+                    Vendor[4] = 'a';
+                    Vendor[5] = 't';
+                    Vendor[6] = 'e';
+                    Vendor[7] = ' ';
+                    Vendor[8] = '\0';
+                }
+                else
+                {
+                    /*Unkown*/
+                    Vendor[0] = 'A';
+                    Vendor[1] = 'T';
+                    Vendor[2] = 'A';
+                    Vendor[3] = ' ';
+                    Vendor[4] = ' ';
+                    Vendor[5] = ' ';
+                    Vendor[6] = ' ';
+                    Vendor[7] = ' ';
+                    Vendor[8] = '\0';
+                }
+                memcpy(Product, temp, 16);
+                Product[16] = '\0';
+            }
+            else
+            {
+                MV_U32 j = i;
+                memcpy(Vendor, temp, j);
+                for (; j < 9; j++)
+                {
+                    Vendor[j] = ' ';
+                }
+                Vendor[8] = '\0';
+                for (; i < 24; i++)
+                {
+                    if (temp[i] != ' ')
+                    {
+                        break;
+                    }
+                }
+                memcpy(Product, &temp[i], 24 - i);
+                Product[16] = '\0';
+            }
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Vendor %s Product %s\n", Vendor, Product);
+            memcpy(&buff[8], Vendor, 8);
+            memcpy(&buff[16], Product, 16);
+            memcpy(&buff[32], pDriveData->identifyInfo.firmware, 4);
+            mvAta2HostString((MV_U16 *)(&buff[32]), (MV_U16 *)(&buff[32]), 2);
+        }
+        memcpy(&buff[36], "MVSATA", 6);
+
+        /*buff[32] = '3';*/
+
+        inquiryLen = 42;
+    }
+    if (pScb->dataBufferLength > inquiryLen)
+    {
+        memcpy(pScb->pDataBuffer, buff, inquiryLen);
+        pScb->dataTransfered = inquiryLen;
+    }
+    else
+    {
+        memcpy(pScb->pDataBuffer, buff, pScb->dataBufferLength);
+        pScb->dataTransfered = pScb->dataBufferLength;
+    }
+    pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+    pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_SCSI_COMMAND_STATUS_COMPLETED;
+}
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaTestUnitReady(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                           IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+    pScb->senseDataLength = 0;
+    pScb->dataTransfered = 0;
+
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_SCSI_COMMAND_STATUS_COMPLETED;
+}
+
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendDataCommand(IN  MV_SATA_ADAPTER*    pSataAdapter,
+                                                             IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U8           *cmd = pScb->ScsiCdb;
+    MV_QUEUE_COMMAND_RESULT    result;
+    MV_QUEUE_COMMAND_INFO commandInfo =
+    {
+        MV_QUEUED_COMMAND_TYPE_UDMA,
+        pScb->target,
+        {
+            {
+                MV_UDMA_TYPE_WRITE, MV_FALSE, MV_FALSE, 0, 0, 0, 0, 0,
+                SALCommandCompletionCB, (MV_VOID_PTR )pScb
+            }
+        }
+    };
+
+    MV_UDMA_COMMAND_PARAMS  *pUdmaParams = &commandInfo.commandParams.udmaCommand;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+	MV_SAL_ADAPTER_EXTENSION *pAdapterExt = pScb->pSalAdapterExtension;
+
+    if ((cmd[0] == SCSI_OPCODE_READ6) || (cmd[0] == SCSI_OPCODE_WRITE6))
+    {
+        pUdmaParams->lowLBAAddress =
+        ( (MV_U32)  cmd[3]) |
+        (((MV_U32)  cmd[2]) << 8) |
+        ((((MV_U32) cmd[1]) & 0x1f) << 16);
+        pUdmaParams->numOfSectors = (MV_U16) cmd[4];
+    }
+    else
+    {
+        pUdmaParams->lowLBAAddress =
+        (((MV_U32) cmd[5]) << 0) |
+        (((MV_U32) cmd[4]) << 8) |
+        (((MV_U32) cmd[3]) << 16) |
+        (((MV_U32) cmd[2]) << 24);
+
+        pUdmaParams->numOfSectors = ((MV_U16) cmd[8]) |
+                                    (((MV_U16) cmd[7]) << 8);
+        if (cmd[1] & MV_BIT3)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%d %d: READ10/WRITE10 command "
+                     "received with FUA\n",
+                     pSataAdapter->adapterId, pScb->bus);
+            pUdmaParams->FUA = MV_TRUE;
+        }
+    }
+    pUdmaParams->isEXT = pDriveData->identifyInfo.LBA48Supported;
+
+    /* If READ10 / WRITE10 with 0 sectors (no data transfer), then complete */
+    /* the command with OK.                                                 */
+    /* If READ6 / WRITE6 with 0 sectors, seemse the Windows have problem with */
+    /* this and doesn't allocate and buffers for this ; so complete this    */
+    /* command with ILLEGAL REQUEST sense and INVLAID CDB in addition sense */
+    /* code.                                                                */
+
+    if (pUdmaParams->numOfSectors == 0)
+    {
+        if ((cmd[0] == SCSI_OPCODE_READ10) || (cmd[0] == SCSI_OPCODE_WRITE10))
+        {
+
+            if (checkLBAOutOfRange(pSataAdapter, pScb,
+                                   pDriveData->identifyInfo.ATADiskSize,
+                                   pUdmaParams->lowLBAAddress, 0) == MV_TRUE)
+            {
+                return MV_SCSI_COMMAND_STATUS_COMPLETED;
+            }
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+            pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+            pScb->dataTransfered = 0;
+            pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+        else
+        {
+            /* READ6 / WRITE6 with sector count 0, which means 256 sectors */
+            pUdmaParams->numOfSectors = 256;
+        }
+    }
+    if (checkLBAOutOfRange(pSataAdapter, pScb,
+                           pDriveData->identifyInfo.ATADiskSize,
+                           pUdmaParams->lowLBAAddress,
+                           pUdmaParams->numOfSectors) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    /* If trying to send more than 256 sectors or DataTransferLength field is
+     * not equal to number of sectors request in CDB then return invalid
+     * request.
+     */
+    if ((pUdmaParams->numOfSectors > 256) ||
+        ((MV_U32)(pUdmaParams->numOfSectors * ATA_SECTOR_SIZE) !=
+         pScb->dataBufferLength))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCB;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if ((cmd[0] == SCSI_OPCODE_READ6) || (cmd[0] == SCSI_OPCODE_READ10))
+    {
+        pUdmaParams->readWrite = MV_UDMA_TYPE_READ;
+    }
+    pScb->dataTransfered = (MV_U32)(pUdmaParams->numOfSectors * ATA_SECTOR_SIZE);
+    pScb->udmaType = pUdmaParams->readWrite;
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_UDMA;
+    pScb->LowLbaAddress = pUdmaParams->lowLBAAddress;
+
+    if ((pUdmaParams->numOfSectors == 256) &&
+        ((pDriveData->identifyInfo.LBA48Supported == MV_FALSE)))
+    {
+        pUdmaParams->numOfSectors = 0;
+    }
+    pUdmaParams->prdLowAddr = pScb->PRDTableLowPhyAddress;
+    pUdmaParams->prdHighAddr = pScb->PRDTableHighPhyAddress;
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, &commandInfo);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    /*update statistics*/
+
+    pAdapterExt->totalAccumulatedOutstanding[pScb->bus] +=
+        mvSataNumOfDmaCommands(pSataAdapter,pScb->bus);
+    pDriveData->stats.totalIOs++;
+    pDriveData->stats.totalSectorsTransferred += pUdmaParams->numOfSectors;
+
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+
+/*******************************************************************************
+* mvScsiAtaGetReadCapacityData - Get the SCSI-3 Read Capacity (10h/16h) data
+*
+* DESCRIPTION: This function fills the data buffer with Scsi Read Capacity 10 or
+*       Read Capacity 16 data according to the disk size as it is reported in
+*       the ATA Identify data.
+*
+* INPUT:
+*   pSataAdapter    - pointer to the SATA adapter data structure.
+*   pScb->bus    - the index of the specific SATA channel.
+*
+* OUTPUT:
+* RETURN:
+*   MV_TRUE on success, MV_FALSE on failure.
+*
+* COMMENTS:
+*   No sanity check is done for the parameters.
+*
+*******************************************************************************/
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetReadCapacityData(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                                 IN    MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U32  lastAddressableLBA;
+    MV_U8   *buff;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    if ((pScb->ScsiCdb[8] & MV_BIT1) == 0)
+    {
+        if (pScb->ScsiCdb[2] || pScb->ScsiCdb[3] ||pScb->ScsiCdb[4] ||
+            pScb->ScsiCdb[5])
+        {
+
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Inquiry completed with error: PMI = 0, LBA != 0\n",
+                     pSataAdapter->adapterId, pScb->bus);
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_INVALID_CDB, 0);
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->dataTransfered = 0;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+    }
+
+    lastAddressableLBA = pDriveData->identifyInfo.ATADiskSize - 1;
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "MVSATA: last Addressable sector = 0x%x "
+             " (sec size=%d bytes)\n", lastAddressableLBA, ATA_SECTOR_SIZE);
+
+    /* The disk size as indicated by the ATA spec is the total addressable
+     * secotrs on the drive ; while the SCSI translation of the command
+     * should be the last addressable sector.
+     */
+    buff = pScb->pDataBuffer;
+    memset(buff, 0, pScb->dataBufferLength);
+    buff[0] = (MV_U8)(lastAddressableLBA >> 24);
+    buff[1] = (MV_U8)((lastAddressableLBA >> 16) & 0xff);
+    buff[2] = (MV_U8)((lastAddressableLBA >> 8) & 0xff);
+    buff[3] = (MV_U8)(lastAddressableLBA & 0xff);
+    buff[4] = 0;
+    buff[5] = 0;
+    buff[6] = (MV_U8)((ATA_SECTOR_SIZE >> 8) & 0xff);           /* 512 byte sectors */
+    buff[7] = (MV_U8)(ATA_SECTOR_SIZE & 0xff);
+    pScb->dataTransfered = 8;
+    pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+    pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_SCSI_COMMAND_STATUS_COMPLETED;
+}
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendVerifyCommand(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                               IN MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO   commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U8                   *cmd = pScb->ScsiCdb;
+    MV_U32                   LowLbaAddress;
+    MV_U16                  sectors;
+    MV_U16                  commands;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+	MV_SAL_ADAPTER_EXTENSION *pAdapterExt = pScb->pSalAdapterExtension;
+
+
+    pCommandParams = &commandParams;
+
+    if (cmd[0] == SCSI_OPCODE_VERIFY6)
+    {
+        LowLbaAddress =
+        ( (unsigned)  cmd[3]) |
+        (((unsigned)  cmd[2]) << 8) |
+        ((((unsigned) cmd[1]) & 0x1f) << 16);
+        sectors = (unsigned) cmd[4];
+    }
+    else
+    {
+        LowLbaAddress =
+        (((unsigned) cmd[5]) << 0) |
+        (((unsigned) cmd[4]) << 8) |
+        (((unsigned) cmd[3]) << 16) |
+        (((unsigned) cmd[2]) << 24);
+
+
+        sectors = ((unsigned) cmd[8]) |
+                  (((unsigned) cmd[7]) << 8);
+    }
+
+    if (sectors == 0)
+    {
+        if (cmd[0] == SCSI_OPCODE_VERIFY10)
+        {
+            if (checkLBAOutOfRange(pSataAdapter, pScb,
+                                   pDriveData->identifyInfo.ATADiskSize,
+                                   LowLbaAddress, 0) == MV_TRUE)
+            {
+                return MV_SCSI_COMMAND_STATUS_COMPLETED;
+            }
+            pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+            pScb->senseDataLength = 0;
+            pScb->dataTransfered = 0;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+        else
+        {
+            /* If VERIFY6 to 48bit device, then 256 sectors is OK ; otherwise
+            the CORE driver must get sector count of 0 in order to understand that
+            256 sectors must be transferred
+            */
+
+            if (pDriveData->identifyInfo.LBA48Supported == MV_TRUE)
+            {
+                sectors = 256;
+            }
+            else
+            {
+                sectors = 0;
+            }
+        }
+        if (checkLBAOutOfRange(pSataAdapter, pScb,
+                               pDriveData->identifyInfo.ATADiskSize,
+                               LowLbaAddress, 256) == MV_TRUE)
+        {
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+    }
+    else
+    {
+        if (checkLBAOutOfRange(pSataAdapter, pScb,
+                               pDriveData->identifyInfo.ATADiskSize,
+                               LowLbaAddress, (MV_U32)sectors) == MV_TRUE)
+        {
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+    }
+
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    pScb->LowLbaAddress = LowLbaAddress;
+
+    if (pDriveData->identifyInfo.LBA48Supported == MV_TRUE)
+    {
+        pScb->splitCount = 1;
+        pScb->isExtended = MV_TRUE;
+        commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+        commandParams.PMPort = pScb->target;
+        commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+        commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+        commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_READ_VERIFY_SECTORS_EXT;
+        commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+        commandParams.commandParams.NoneUdmaCommand.count = 0;
+        commandParams.commandParams.NoneUdmaCommand.features = 0;
+        commandParams.commandParams.NoneUdmaCommand.isEXT = MV_TRUE;
+        commandParams.commandParams.NoneUdmaCommand.lbaHigh = (MV_U16)((LowLbaAddress & 0xff0000) >> 16);
+        commandParams.commandParams.NoneUdmaCommand.lbaMid = (MV_U16)((LowLbaAddress & 0xff00) >> 8);
+        commandParams.commandParams.NoneUdmaCommand.lbaLow =
+        (MV_U16)(((LowLbaAddress & 0xff000000) >> 16)| (LowLbaAddress & 0xff));
+        commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+        commandParams.commandParams.NoneUdmaCommand.sectorCount = sectors;
+        commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending EXT Verify command: channel %d, code %x lba %x(%x.%x.%x), sectors %d[%d] Srb %p\n",
+                 pScb->bus, cmd[0], LowLbaAddress,
+                 commandParams.commandParams.NoneUdmaCommand.lbaHigh,
+                 commandParams.commandParams.NoneUdmaCommand.lbaMid,
+                 commandParams.commandParams.NoneUdmaCommand.lbaLow,
+                 commandParams.commandParams.NoneUdmaCommand.sectorCount,
+                 mvSataNumOfDmaCommands(pSataAdapter,pScb->bus), pScb);
+
+        result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+
+        if (result != MV_QUEUE_COMMAND_RESULT_OK)
+        {
+            checkQueueCommandResult(pScb, result);
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+        /* update stats*/
+        pAdapterExt->totalAccumulatedOutstanding[pScb->bus] +=
+            mvSataNumOfDmaCommands(pSataAdapter,pScb->bus);
+        pDriveData->stats.totalIOs++;
+        pDriveData->stats.totalSectorsTransferred += sectors;
+
+    }
+    else
+    {
+        /* The following only in case command is VERIFY 6 with 0 sector count */
+        if (sectors == 0)
+        {
+            commands = 1;
+        }
+        else
+        {
+            commands = (MV_U16)((((MV_U32)sectors + 0xff) & 0x1ff00) >> 8);
+        }
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "split Verify to %d commands: channel %d, lba %x, sectors %d\n",
+                 commands,pScb->bus, LowLbaAddress, sectors);
+
+        pScb->splitCount = commands;
+        pScb->sequenceNumber = 0;
+        pScb->isExtended = MV_FALSE;
+        mvScsiAtaSendSplittedVerifyCommand(pScb);
+    }
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSeek(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                  IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U32 lbaAddress;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    lbaAddress = (((MV_U32) pScb->ScsiCdb[5]) << 0) |
+                 (((MV_U32) pScb->ScsiCdb[4]) << 8) |
+                 (((MV_U32) pScb->ScsiCdb[3]) << 16) |
+                 (((MV_U32) pScb->ScsiCdb[2]) << 24);
+    if (checkLBAOutOfRange(pSataAdapter, pScb,
+                           pDriveData->identifyInfo.ATADiskSize,
+                           lbaAddress, 0) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+    pScb->dataTransfered = 0;
+    pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_SCSI_COMMAND_STATUS_COMPLETED;
+
+}
+
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaReassignBlocks(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                            IN MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    setSenseData(pScb, SCSI_SENSE_HARDWARE_ERROR, 0x32, 0);
+    pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+    pScb->dataTransfered = 0;
+    pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_ATA_FAILED;
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_TRUE;
+
+}
+
+
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+static MV_SCSI_COMMAND_STATUS_TYPE mvScsiAtaWriteLong(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                      IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U32                  LBA;
+    MV_U16                  eccBytes;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+	MV_SAL_ADAPTER_EXTENSION *pAdapterExt = pScb->pSalAdapterExtension;
+
+    pCommandParams = &commandParams;
+
+    memset(pCommandParams, 0, sizeof(MV_QUEUE_COMMAND_INFO));
+
+
+    LBA = (((MV_U32) pScb->ScsiCdb[5]) << 0) |
+          (((MV_U32) pScb->ScsiCdb[4]) << 8) |
+          (((MV_U32) pScb->ScsiCdb[3]) << 16) |
+          (((MV_U32) pScb->ScsiCdb[2]) << 24);
+
+    eccBytes = (MV_U16)pScb->ScsiCdb[8];
+
+    if ((pScb->ScsiCdb[7] != 2) || ((eccBytes != 4) && (eccBytes != 8)))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCB;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    if (checkLBAOutOfRange(pSataAdapter, pScb,
+                           pDriveData->identifyInfo.ATADiskSize,
+                           LBA, 1) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    /*if (checkLBAOutOfRange(pSataAdapter, pScb, MV_BIT28 - 2,
+                        LBA, 1) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }*/
+    if (LBA & (MV_BIT31|MV_BIT30|MV_BIT29|MV_BIT28))
+    {
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Error LBA (0x%x) out of range.\n", LBA);
+
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                     SCSI_ADSENSE_ILLEGAL_BLOCK, 0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_TRUE;
+    }
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = (MV_U16_PTR)pScb->pDataBuffer;
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 256+4;
+    commandParams.commandParams.NoneUdmaCommand.features = eccBytes;
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = (MV_U16)((LBA & 0xff0000) >> 16);
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = (MV_U16)((LBA & 0xff00) >> 8) ;
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = (MV_U16)LBA & 0xff;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_OUT;
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = 1;
+    commandParams.commandParams.NoneUdmaCommand.device = MV_BIT6 | (MV_U16)((LBA & 0xf000000) >> 24) ;
+    pScb->isExtended = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.command = 0x32;
+
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending WRITE LONG command : channel %d, code %x pScb %p\n",
+             pScb->bus, pScb->ScsiCdb[0], pScb);
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+        /* shoudl complete the Scsi request here*/
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    /* update stats*/
+    pAdapterExt->totalAccumulatedOutstanding[pScb->bus] += mvSataNumOfDmaCommands(pSataAdapter,pScb->bus);
+    pDriveData->stats.totalIOs++;
+
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+static MV_SCSI_COMMAND_STATUS_TYPE mvScsiAtaReadLong(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                     IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U32                  LBA;
+    MV_U16                  eccBytes;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+    MV_SAL_ADAPTER_EXTENSION *pAdapterExt = pScb->pSalAdapterExtension;
+
+    pCommandParams = &commandParams;
+
+    memset(pCommandParams, 0, sizeof(MV_QUEUE_COMMAND_INFO));
+
+
+    LBA = (((MV_U32) pScb->ScsiCdb[5]) << 0) |
+          (((MV_U32) pScb->ScsiCdb[4]) << 8) |
+          (((MV_U32) pScb->ScsiCdb[3]) << 16) |
+          (((MV_U32) pScb->ScsiCdb[2]) << 24);
+
+    eccBytes = (MV_U16)pScb->ScsiCdb[8];
+
+    if ((pScb->ScsiCdb[7] != 2) || ((eccBytes != 4) && (eccBytes != 8)))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCB;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    if (checkLBAOutOfRange(pSataAdapter, pScb,
+                           pDriveData->identifyInfo.ATADiskSize,
+                           LBA, 1) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    /*if (checkLBAOutOfRange(pSataAdapter, pScb, MV_BIT28 - 2,
+                        LBA, 1) == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }*/
+    if (LBA & (MV_BIT31|MV_BIT30|MV_BIT29|MV_BIT28))
+    {
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Error LBA (0x%x) out of range.\n", LBA);
+
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                     SCSI_ADSENSE_ILLEGAL_BLOCK, 0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_TRUE;
+    }
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = (MV_U16_PTR)pScb->pDataBuffer;
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 256+4;
+    commandParams.commandParams.NoneUdmaCommand.features = eccBytes;
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = (MV_U16)((LBA & 0xff0000) >> 16);
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = (MV_U16)((LBA & 0xff00) >> 8) ;
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = (MV_U16)LBA & 0xff;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_IN;
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = 1;
+    commandParams.commandParams.NoneUdmaCommand.device = MV_BIT6 | (MV_U16)((LBA & 0xf000000) >> 24) ;
+    pScb->isExtended = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.command = 0x22;
+
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending READ LONG command : channel %d, code %x pScb %p\n",
+             pScb->bus, pScb->ScsiCdb[0], pScb);
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+        /* shoudl complete the Scsi request here*/
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    /* update stats*/
+    pAdapterExt->totalAccumulatedOutstanding[pScb->bus] += mvSataNumOfDmaCommands(pSataAdapter,pScb->bus);
+    pDriveData->stats.totalIOs++;
+
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+#endif
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaSendSyncCacheCommand(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                                  IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U32                  LBA;
+    MV_U16                  sectors;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+    MV_SAL_ADAPTER_EXTENSION *pAdapterExt = pScb->pSalAdapterExtension;
+
+    pCommandParams = &commandParams;
+    /* Check if IMMED bit is set, if so then return ILLEGAL REQUEST */
+    if (pScb->ScsiCdb[1] & MV_BIT1)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Synchronise cache completed with error:"
+                 " IMMED is set\n", pSataAdapter->adapterId,
+                 pScb->bus);
+
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB,
+                     0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    memset(pCommandParams, 0, sizeof(MV_QUEUE_COMMAND_INFO));
+
+
+    LBA = (((MV_U32) pScb->ScsiCdb[5]) << 0) |
+          (((MV_U32) pScb->ScsiCdb[4]) << 8) |
+          (((MV_U32) pScb->ScsiCdb[3]) << 16) |
+          (((MV_U32) pScb->ScsiCdb[2]) << 24);
+
+    sectors = ((MV_U16) pScb->ScsiCdb[8]) |
+              (((MV_U16) pScb->ScsiCdb[7]) << 8);
+
+    if (checkLBAOutOfRange(pSataAdapter, pScb,
+                           pDriveData->identifyInfo.ATADiskSize,LBA, sectors)
+        == MV_TRUE)
+    {
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 0;
+    commandParams.commandParams.NoneUdmaCommand.features = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = 0;
+    commandParams.commandParams.NoneUdmaCommand.protocolType =
+    MV_NON_UDMA_PROTOCOL_NON_DATA;
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = 0;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+
+    if (pDriveData->identifyInfo.LBA48Supported == MV_TRUE)
+    {
+        pScb->isExtended = MV_TRUE;
+        commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_FLUSH_CACHE_EXT;
+        commandParams.commandParams.NoneUdmaCommand.isEXT = MV_TRUE;
+    }
+    else
+    {
+        pScb->isExtended = MV_FALSE;
+        commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_FLUSH_CACHE;
+        commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+
+    }
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending Flush Cache command : channel %d, code %x (extended -->"
+             " %s) pScb %p\n", pScb->bus, pScb->ScsiCdb[0],
+             (pScb->isExtended == MV_TRUE) ? "Yes":"No", pScb);
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+        /* shoudl complete the Scsi request here*/
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    /* update stats*/
+    pAdapterExt->totalAccumulatedOutstanding[pScb->bus] += mvSataNumOfDmaCommands(pSataAdapter,pScb->bus);
+    pDriveData->stats.totalIOs++;
+
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+
+/*******************************************************************************
+* mvScsiAtaGetRequestSenseData - Get the SCSI-3 Request Sense(03h) data
+*
+* DESCRIPTION: This function fills the sense buffer with a sense key of NO SENSE
+*       and an additional sense code of NO ADDITIONAL SENSE INFORMATION.
+*
+* INPUT:
+*   pSataAdapter    - pointer to the SATA adapter data structure.
+*   pScb->bus    - the index of the specific SATA channel.
+*   Cdb             - specifies the SCSI-3 command descriptor block.
+*
+* OUTPUT:
+*   pScsiStatus     - pointer to the Scsi status to be returned.
+*   pSenseBuffer    - pointer to the Scsi sense buffer.
+*   senseBufferLength   - the size in bytes of the sense buffer.
+*   pDataTransfered - the size in bytes of the data transfered into the data
+*                     buffer(alwasy zero for this command).
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE on failure.
+*
+* COMMENTS:
+*   No sanity check is done for the parameters.
+*
+*******************************************************************************/
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetRequestSenseData(IN MV_SATA_ADAPTER*    pSataAdapter,
+                                                                 IN MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_SCSI_SENSE_DATA SenseData;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    memset(pScb->pDataBuffer, 0, pScb->dataBufferLength);
+
+    memset(&SenseData, 0, sizeof(MV_SCSI_SENSE_DATA));
+    SenseData.Valid = 0;
+    SenseData.ResponseCode = MV_SCSI_RESPONSE_CODE;
+    SenseData.SenseKey = SCSI_SENSE_NO_SENSE;
+    SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+    SenseData.AdditionalSenseLength = sizeof(MV_SCSI_SENSE_DATA) - 8;
+
+    pScb->senseDataLength = 0;
+    if (pDriveData->UAConditionPending == MV_TRUE)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Unit Attention condition is pending.\n");
+        SenseData.SenseKey = SCSI_SENSE_UNIT_ATTENTION;
+        if (pDriveData->UAEvents & MV_BIT0)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Bus Reset.\n");
+
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_BUS_RESET;
+            SenseData.AdditionalSenseCodeQualifier = 2;
+            pDriveData->UAEvents &= ~MV_BIT0;
+        }
+        else if (pDriveData->UAEvents & MV_BIT1)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Mode Parameters Changed.\n");
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_PARAMETERS_CHANGED;
+            SenseData.AdditionalSenseCodeQualifier = 1;
+            pDriveData->UAEvents &= ~MV_BIT1;
+        }
+
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        if (pDriveData->UAEvents == 0)
+        {
+            pDriveData->UAConditionPending = MV_FALSE;
+        }
+    }
+    else
+    {
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    }
+    if (pScb->dataBufferLength >= sizeof(MV_SCSI_SENSE_DATA))
+    {
+        pScb->dataTransfered = sizeof(MV_SCSI_SENSE_DATA);
+        memcpy(pScb->pDataBuffer, &SenseData, pScb->dataTransfered);
+        /*pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;*/
+        /*pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;*/
+    }
+    else
+    {
+        pScb->dataTransfered = pScb->dataBufferLength;
+        memcpy(pScb->pDataBuffer, &SenseData, pScb->dataTransfered);
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;/*TBD*/
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+    }
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_SCSI_COMMAND_STATUS_COMPLETED;
+}
+
+/*******************************************************************************
+* mvScsiAtaGetModeSenseData - Get the SCSI-3 Mode Sense data
+*
+* DESCRIPTION: This function issues ATA Identify command, in the command
+*       completion, the Mode Sense data will be filled according to the returned
+*       Identify Data.
+*
+* INPUT:
+*   pSataAdapter    - pointer to the SATA adapter data structure.
+*   pScb->bus    - the index of the specific SATA channel.
+*   Cdb             - specifies the SCSI-3 command descriptor block.
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE on failure.
+*
+* COMMENTS:
+*   No sanity check is done for the parameters.
+*
+*******************************************************************************/
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaGetModeSenseData(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                              IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    pCommandParams = &commandParams;
+
+    memset(pCommandParams, 0, sizeof(MV_QUEUE_COMMAND_INFO));
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = pDriveData->identifyBuffer;
+    commandParams.commandParams.NoneUdmaCommand.count = 256;         /* 512 bytes */
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_IDENTIFY;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_PIO_DATA_IN;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending Identify command: channel %d, Srb %p\n",
+             pScb->bus, pScb);
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+        /* shoudl complete the Scsi request here*/
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    return MV_SCSI_COMMAND_STATUS_QUEUED;
+}
+static MV_BOOLEAN  mvScsiAtaGetModeSenseDataPhase2(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                   IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U8   AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+    MV_U8   *cmd = pScb->ScsiCdb;
+    MV_U8   pageCode= cmd[2] & 0x3f;
+    MV_U8   pageControl = (MV_U8)((cmd[2] & 0xc0) >> 6);
+    MV_U8   modeSenseResult[MV_MAX_MODE_SENSE_RESULT_LENGTH];
+    MV_U32  offset;
+    MV_U32  pageLength;
+    MV_BOOLEAN  commandFailed = MV_FALSE;
+
+    memset(pScb->pDataBuffer, 0, pScb->dataBufferLength);
+    memset(modeSenseResult, 0, MV_MAX_MODE_SENSE_RESULT_LENGTH);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Sense: cmd[2] 0x%xcode 0x%x control 0x%x "
+             "allocation length %d \n", pSataAdapter->adapterId, pScb->bus,
+             cmd[2], pageCode, pageControl, (MV_U32)cmd[4]);
+
+
+    if (pageControl == 0x3)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Sense: save control not supported\n.",
+                 pSataAdapter->adapterId, pScb->bus);
+        AdditionalSenseCode = 0x39; /*SAVING PARAMETERS NOT SUPPORTED */
+        commandFailed = MV_TRUE;
+    }
+    if (commandFailed != MV_TRUE)
+    {
+        memset(modeSenseResult, 0, MV_MAX_MODE_SENSE_RESULT_LENGTH);
+        /*1. Mode parameter header*/
+        /* Mode data length will be set later */
+        /* Medium Type 0: Default medium type */
+        /* Device-specific parameter 0:  write enabled, target */
+        /*      supports the DPO and FUA bits only in NCQ mode*/
+        if (pSataAdapter->sataChannel[pScb->bus]->queuedDMA == MV_EDMA_MODE_NATIVE_QUEUING)
+        {
+            modeSenseResult[2] = MV_BIT4;
+        }
+
+        /* Block descriptor length 0: no block descriptors*/
+
+        /*2. Block descriptor(s): Empty list*/
+        /*3. Page(s)*/
+        offset = 4;
+
+        switch (pageCode)
+        {
+        case 0x3f:
+        case 0x8: /*Caching page */
+            pageLength = mvModeSenseCachingPage(pScb,
+                                                modeSenseResult + offset,
+                                                pageControl);
+
+            offset += pageLength;
+
+            if (pageCode == 0x8)
+            {
+                break;
+            }
+        case 0xa:
+            pageLength = mvModeSenseControlPage(pSataAdapter,pScb,
+                                                modeSenseResult + offset,
+                                                pageControl);
+
+            offset += pageLength;
+            break;
+        default:
+            AdditionalSenseCode = SCSI_ADSENSE_INVALID_CDB;
+            commandFailed = MV_TRUE;
+        }
+
+        /* set the DATA LENGTH of the Mode parameter list not including the number*/
+        /* of bytes of the DATA LENGTH itself ( 1 byte for Mode Selet(6)) */
+        modeSenseResult[0] = (MV_U8)(offset - 1);
+
+        if (pScb->dataBufferLength < offset)
+        {
+            memcpy(pScb->pDataBuffer, modeSenseResult, pScb->dataBufferLength);
+            pScb->dataTransfered = pScb->dataBufferLength;
+        }
+        else
+        {
+            memcpy(pScb->pDataBuffer, modeSenseResult, offset);
+            pScb->dataTransfered = offset;
+        }
+    }
+
+    if (commandFailed == MV_TRUE)
+    {
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST, AdditionalSenseCode, 0);
+
+        pScb->dataTransfered = 0;
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+    }
+    else
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+    }
+    return MV_TRUE;
+}
+static MV_SCSI_COMMAND_STATUS_TYPE  mvScsiAtaModeSelect(IN MV_SATA_ADAPTER    *pSataAdapter,
+                                                        IN  MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U8 result;
+    MV_SCSI_COMMAND_STATUS_TYPE     commandStatus;
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " MODE SELECT RECEIVED: cmd:");
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %02x, %02x, %02x, %02x, %02x, %02x\n", pScb->ScsiCdb[0], pScb->ScsiCdb[1],
+                 pScb->ScsiCdb[2], pScb->ScsiCdb[3], pScb->ScsiCdb[4], pScb->ScsiCdb[5]);
+    }
+    result = modeSelect(pSataAdapter, pScb, &commandStatus);
+    if (result != 0x0)
+    {
+        if (result == 0x1)/*PARAMETER LIST LENGTH ERROR*/
+        {
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST, 0x1a, 0);
+
+        }
+        else if (result == 0x2)
+        {
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_INVALID_CDB, 0);
+
+        }
+        else if (result == 0x3)
+        {
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_INVALID_FIELD_IN_PARAMETER_LIST, 0);
+
+        }
+        else
+        {
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_NO_SENSE, 0);
+
+        }
+
+        pScb->dataTransfered = 0;
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    return commandStatus;
+}
+
+static MV_U8
+modeSelect(IN MV_SATA_ADAPTER    *pSataAdapter,
+           IN  MV_SATA_SCSI_CMD_BLOCK  *pScb,
+           MV_SCSI_COMMAND_STATUS_TYPE *pCommandStatus)
+{
+    MV_U8   *cmd = pScb->ScsiCdb;
+    MV_VOID_PTR pBuffer = pScb->pDataBuffer;
+    MV_U32  length = pScb->dataBufferLength;
+    MV_U8   PF = (cmd[1] & MV_BIT4) >> 4;
+    MV_U8   SP = (cmd[1] & MV_BIT0);
+    MV_U8   *list = (MV_U8 *)pBuffer;
+    MV_U32  offset;
+    MV_U32  cachePageOffset = 0;
+
+    {
+        MV_U32 i;
+        for (i =0 ; i < length; i++)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %02x", list[i]);
+        }
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "\n");
+    }
+    if (PF == 0)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%d %d: Mode Select Error: PF not supported\n.",
+                 pSataAdapter->adapterId, pScb->bus);
+        return 0x2; /* Invalid field in CDB */
+    }
+    if (SP == 1)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%d %d: Mode Select Error: SP not supported\n.",
+                 pSataAdapter->adapterId, pScb->bus);
+        return 0x2; /* PARAMETER LIST LENGTH ERROR */
+    }
+    if (length == 0)
+    {
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        *pCommandStatus = MV_SCSI_COMMAND_STATUS_COMPLETED;
+        return 0;
+    }
+    if (length < 4)
+    {
+        return 0x1; /* PARAMETER LIST LENGTH ERROR */
+    }
+    if (list[0] || (list[1] != MV_SCSI_DIRECT_ACCESS_DEVICE) || list[2])
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in parameter "
+                 "list\n", pSataAdapter->adapterId, pScb->bus);
+        return 0x3; /* Invalid field in parameter list */
+    }
+    if (list[3])
+    {
+        if (list[3] != 8)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: wrong size for mode parameter"
+                     " block descriptor, BLOCK DESCRIPTOR LENGTH %d\n.",
+                     pSataAdapter->adapterId, pScb->bus, list[3]);
+            return 0x3; /* Invalid field in parameter list */
+        }
+        if (length < 12)
+        {
+            return 0x1; /* PARAMETER LIST LENGTH ERROR */
+        }
+        if (list[4] || list[5] || list[6] || list[7] || list[8] || list[9] ||
+            (list[10] != 0x2) || list[11])
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in parameter "
+                     "block descriptor list\n", pSataAdapter->adapterId,
+                     pScb->bus);
+            return 0x3; /* Invalid field in parameter list */
+        }
+    }
+    offset = 4 + list[3];/* skip the mode parameter block descriptor */
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select: PF 0x%x SP 0x%x parameter length %x "
+             "length %d(0x%x)\n offset %d", pSataAdapter->adapterId, pScb->bus,
+             PF, SP, (MV_U32)cmd[4], length, length,
+             offset);
+    if (length == offset)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select : no mode pages available\n",
+                 pSataAdapter->adapterId, pScb->bus);
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        *pCommandStatus = MV_SCSI_COMMAND_STATUS_COMPLETED;
+        return 0;
+    }
+
+    while ((offset + 2) < length)
+    {
+        switch (list[offset] & 0x3f)
+        {
+        case 0x8:
+            if (list[offset + 1] != 0x12)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: bad length in caching mode "
+                         "page %d\n.",
+                         pSataAdapter->adapterId, pScb->bus, list[offset + 1]);
+                return 0x3; /* Invalid field in parameter list */
+            }
+            cachePageOffset = offset;
+            offset += list[offset + 1] + 2;
+            break;
+        case 0xa:
+            if ((list[offset] != 0xa) || (list[offset+1] != 0xa))
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in"
+                         " mode control page, list[%x] %x, list[%x] %x\n",
+                         pSataAdapter->adapterId, pScb->bus, offset,
+                         list[offset], offset + 1, list[offset+1]);
+                return 0x3;
+            }
+
+            if (list[offset + 3] != MV_BIT4)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in"
+                         " mode control page, list[%x] %x\n",
+                         pSataAdapter->adapterId, pScb->bus, offset + 3,
+                         list[offset + 3]);
+                return 0x3;
+            }
+
+            if (list[offset + 2] || list[offset + 4] || list[offset + 5] ||
+                list[offset + 6] || list[offset + 7]||list[offset + 8] ||
+                list[offset + 9]|| list[offset + 10] || list[offset + 11])
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in"
+                         " mode control page, line %d\n",
+                         pSataAdapter->adapterId, pScb->bus, __LINE__);
+                return 0x3;
+            }
+            offset += list[offset + 1] + 2;
+            break;
+        default:
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in parameter "
+                     "list, mode page %d not supported, offset %d\n",
+                     pSataAdapter->adapterId, pScb->bus, list[offset],
+                     offset);
+            return 0x3; /* Invalid field in parameter list */
+        }
+    }
+
+    if (length != offset)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: bad length %d\n.",
+                 pSataAdapter->adapterId, pScb->bus, length);
+        return 0x1; /* PARAMETER LIST LENGTH ERROR */
+    }
+
+    if (cachePageOffset)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Mode Select: caching Page found, offset %d\n", cachePageOffset);
+        return mvParseModeCachingPage(pSataAdapter, pScb,list + cachePageOffset, pCommandStatus);
+    }
+    else
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Mode Select: No caching Page found\n");
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        *pCommandStatus = MV_SCSI_COMMAND_STATUS_COMPLETED;
+        return 0;
+    }
+}
+
+static MV_U8
+mvParseModeCachingPage(MV_SATA_ADAPTER *pSataAdapter,
+                       IN  MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                       MV_U8 *buffer,
+                       MV_SCSI_COMMAND_STATUS_TYPE *pCommandStatus)
+{
+    MV_QUEUE_COMMAND_INFO commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U8                   index = 0;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+    pCommandParams = &commandParams;
+
+    if ((buffer[index++] & 0xc0) || (buffer[index++] != 0x12) ||
+        ((buffer[index++] | MV_BIT2)!= MV_BIT2) || (buffer[index++]) ||
+        (buffer[index++] != 0xff) || (buffer[index++] != 0xff) ||
+        buffer[index++] || buffer[index++] || buffer[index++] ||
+        (buffer[index++] != 0x10) || buffer[index++] ||
+        (buffer[index++] != 0x10) || ((buffer[index++] | MV_BIT5) != MV_BIT5) ||
+        (buffer[index++] != 0x1) || (buffer[index++] != 0xff) ||
+        (buffer[index++] != 0xff) || buffer[index++] || buffer[index++]
+        || buffer[index++] || buffer[index++])
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in caching mode"
+                 " page, index %d\n", pSataAdapter->adapterId, pScb->bus,
+                 index);
+        return 0x3; /* Invalid field in parameter list */
+    }
+
+    pScb->splitCount = 2;
+    pScb->sequenceNumber = 1;
+    if (buffer[12] & MV_BIT5) /* Disable Look Ahead*/
+    {
+        if (pDriveData->identifyInfo.readAheadSupported == MV_FALSE)
+        {
+            pScb->splitCount--;
+        }
+        pScb->LowLbaAddress = 0;
+    }
+    else
+    {
+        if (pDriveData->identifyInfo.readAheadSupported == MV_FALSE)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in caching mode"
+                     " page, enable read ahead (feature not supported)\n",
+                     pSataAdapter->adapterId, pScb->bus);
+            return 0x3; /* Invalid field in parameter list */
+        }
+        pScb->LowLbaAddress = 1;
+    }
+
+    if (buffer[2] & MV_BIT2) /* enable write cache*/
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Parse Caching Page: enable Write Cache\n");
+        if (pDriveData->identifyInfo.writeCacheSupported == MV_FALSE)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d: Mode Select Error: invalid field in caching mode"
+                     " page, enable write cache (feature not supported)\n",
+                     pSataAdapter->adapterId, pScb->bus);
+            return 0x3; /* Invalid field in parameter list */
+        }
+        commandParams.commandParams.NoneUdmaCommand.features = MV_ATA_SET_FEATURES_ENABLE_WCACHE;
+    }
+    else
+    {
+        if (pDriveData->identifyInfo.writeCacheSupported == MV_FALSE)
+        {
+            pScb->splitCount--;
+            if (pScb->splitCount == 1)
+            {
+                mvScsiAtaSendReadLookAhead(pSataAdapter, pScb);
+                *pCommandStatus = MV_SCSI_COMMAND_STATUS_QUEUED;
+                return 0;
+            }
+        }
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Parse Caching Page: disable Write Cache\n");
+        commandParams.commandParams.NoneUdmaCommand.features = MV_ATA_SET_FEATURES_DISABLE_WCACHE;
+    }
+
+    if (pScb->splitCount == 0)
+    {
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        *pCommandStatus = MV_SCSI_COMMAND_STATUS_COMPLETED;
+        return 0;
+    }
+
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_SET_FEATURES;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 0;
+
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = 0;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = 0;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending SET FEATURES command: features %d\n",
+             commandParams.commandParams.NoneUdmaCommand.features);
+
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        *pCommandStatus = MV_SCSI_COMMAND_STATUS_COMPLETED;
+
+        return 0;
+    }
+    *pCommandStatus = MV_SCSI_COMMAND_STATUS_QUEUED;
+    return 0;
+}
+
+static MV_U32
+mvModeSenseCachingPage(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                       MV_U8 *buffer,MV_U8 pageControl)
+{
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+
+
+    buffer[0] = 0x8; /* caching page*/
+    buffer[1] = 0x12; /* length = 2 + 0x12*/
+    buffer[2] = 0;
+    if (pageControl == 2) /*default values*/
+    {
+        if (pDriveData->identifyInfo.writeCacheSupported == MV_TRUE)
+        {
+            buffer[2] = MV_BIT2;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Cache Page: writeCacheEnabledByDefault\n");
+        }
+    }
+    else if (pageControl == 0)  /* current values*/
+    {
+        if ((pDriveData->identifyInfo.writeCacheSupported == MV_TRUE) &&
+            (pDriveData->identifyBuffer[85] & MV_BIT5))
+        {
+            buffer[2] = MV_BIT2;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Cache Page: writeCacheEnabled\n");
+        }
+    }
+    else if (pageControl == 1)  /* changeable values*/
+    {
+        if (pDriveData->identifyInfo.writeCacheSupported == MV_TRUE)
+        {
+            buffer[2] = MV_BIT2;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Cache Page: writeCacheSupported\n");
+        }
+    }
+
+    buffer[3] = 0;
+    if (pageControl != 1)
+    {
+        buffer[4] = 0xff;
+        buffer[5] = 0xff;
+        buffer[9] = 0x10;
+        buffer[11] = 0x10;
+    }
+    if (pageControl == 2) /*default values*/
+    {
+        if (pDriveData->identifyInfo.readAheadSupported == MV_FALSE)
+        {
+            buffer[12] = MV_BIT5;
+        }
+    }
+    else if (pageControl == 0)  /* current values*/
+    {
+        if ((pDriveData->identifyInfo.readAheadSupported == MV_TRUE) &&
+            (pDriveData->identifyBuffer[85] & MV_BIT6))
+        {
+            buffer[12] = 0;
+        }
+        else
+        {
+            buffer[12] = MV_BIT5;
+        }
+    }
+    else if (pageControl == 1)  /* changeable values*/
+    {
+        if (pDriveData->identifyInfo.readAheadSupported == MV_TRUE)
+        {
+            buffer[12] = MV_BIT5;
+        }
+    }
+    if (pageControl != 1)
+    {
+        buffer[13] = 0x01;
+        buffer[14] = 0xff;
+        buffer[15] = 0xff;
+    }
+
+    {
+        MV_U32 i;
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Cache Page: \n");
+        for (i = 0; i < 0x14; i++)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "[%d] %x\n",i, buffer[i]);
+        }
+    }
+    return 0x14;
+}
+
+static MV_U32
+mvModeSenseControlPage(MV_SATA_ADAPTER *pSataAdapter,
+                       MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                       MV_U8 *buffer, MV_U8 pageControl)
+{
+    buffer[0] = 0xA;    /* control page */
+    buffer[1] = 0xA;    /* length 2 + 0xa*/
+    if (pageControl != 1)
+    {
+        buffer[3] = MV_BIT4/*Unrestricted reordering allowed*/;
+    }
+
+    {
+        MV_U32 i;
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Control Page: \n");
+        for (i = 0; i < 0xc; i++)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "[%d] %x\n",i , buffer[i]);
+        }
+    }
+    return 0xc;
+}
+
+static MV_BOOLEAN
+SALCommandCompletionCB(MV_SATA_ADAPTER *pSataAdapter,
+                       MV_U8 channelNum,
+                       MV_COMPLETION_TYPE comp_type,
+                       MV_VOID_PTR commandId,
+                       MV_U16 responseFlags,
+                       MV_U32 timeStamp,
+                       MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_SATA_SCSI_CMD_BLOCK  *pScb;
+
+    if (commandId == NULL)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_FATAL_ERROR, " commandId is NULL, can't hanlde this !!!,adapterId=%d,"
+                 " channel=%d \n", pSataAdapter->adapterId, channelNum);
+        return MV_FALSE;
+    }
+
+    pScb = commandId;
+    switch (comp_type)
+    {
+    case MV_COMPLETION_TYPE_NORMAL:
+        /* finish */
+        /* If splited VERIFY command, then SRB completion will be on the last fragment */
+        if ((((pScb->ScsiCdb[0] == SCSI_OPCODE_VERIFY6) ||
+              (pScb->ScsiCdb[0] == SCSI_OPCODE_VERIFY10) ||
+              (pScb->ScsiCdb[0] == SCSI_OPCODE_MODE_SELECT6)))
+            &&  (pScb->splitCount > pScb->sequenceNumber))
+        {
+            /* add the command to the list for post interrupt service*/
+            pScb->pNext = pScb->pSalAdapterExtension->pHead;
+            pScb->pSalAdapterExtension->pHead = pScb;
+            return MV_TRUE;
+        }
+        if (pScb->ScsiCdb[0] == SCSI_OPCODE_MODE_SENSE6)
+        {
+            mvScsiAtaGetModeSenseDataPhase2(pSataAdapter, pScb);
+        }
+        else
+        {
+            pScb->ScsiStatus = MV_SCSI_STATUS_GOOD;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_SUCCESS;
+        }
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "command completed. pScb %p\n", pScb);
+
+        break;
+    case MV_COMPLETION_TYPE_ABORT:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "Error: command Aborted. Cdb: %02x %02x %02x %02x %02x "
+                 "%02x %02x %02x %02x %02x\n", pScb->ScsiCdb[0],
+                 pScb->ScsiCdb[1], pScb->ScsiCdb[2], pScb->ScsiCdb[3],
+                 pScb->ScsiCdb[4], pScb->ScsiCdb[5], pScb->ScsiCdb[6],
+                 pScb->ScsiCdb[7], pScb->ScsiCdb[8], pScb->ScsiCdb[9]);
+
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_ABORTED;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+        mvCommandCompletionErrorHandler(pScb->pIalAdapterExtension, channelNum);
+        break;
+    case MV_COMPLETION_TYPE_ERROR:
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_ATA_FAILED;
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "COMPLETION ERROR , adapter =%d, channel=%d, flags=%x\n",
+                 pSataAdapter->adapterId, channelNum, responseFlags);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Failed command Cdb: %02x %02x %02x %02x %02x "
+                 "%02x %02x %02x %02x %02x\n", pScb->ScsiCdb[0],
+                 pScb->ScsiCdb[1], pScb->ScsiCdb[2], pScb->ScsiCdb[3],
+                 pScb->ScsiCdb[4], pScb->ScsiCdb[5], pScb->ScsiCdb[6],
+                 pScb->ScsiCdb[7], pScb->ScsiCdb[8], pScb->ScsiCdb[9]);
+        /* here the  eDMA will be stopped, so we have to flush  */
+        /* the pending commands                                 */
+
+        if (pScb->commandType == MV_QUEUED_COMMAND_TYPE_UDMA)
+        {
+            handleUdmaError(pScb, responseFlags, registerStruct);
+#ifdef MV_LOGGER
+            memcpy(&pScb->ATAregStruct, registerStruct,
+                   sizeof(pScb->ATAregStruct));
+#endif
+        }
+        else
+        {
+            handleNoneUdmaError(pScb, registerStruct);
+#ifdef MV_LOGGER
+            memcpy(&pScb->ATAregStruct, registerStruct,
+                   sizeof(pScb->ATAregStruct));
+#endif
+        }
+        mvCommandCompletionErrorHandler(pScb->pIalAdapterExtension, channelNum);
+        break;
+    default:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_FATAL_ERROR, " Unknown completion type (%d)\n", comp_type);
+        return MV_FALSE;
+    }
+#ifdef MV_LOGGER
+    reportScbCompletion(pSataAdapter, pScb);
+#endif
+    pScb->completionCallBack(pSataAdapter, pScb);
+    return MV_TRUE;
+}
+MV_VOID
+handleNoneUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                    MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_U8 errorReg = registerStruct->errorRegister;
+    MV_SCSI_SENSE_DATA SenseData;
+
+    memset(&SenseData, 0, sizeof(MV_SCSI_SENSE_DATA));
+
+    pScb->dataBufferLength = 0;
+
+    /*if (pSrb->SenseInfoBufferLength < 13)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "IAL ERROR: invalid Sense Info buffer len (%d)\n",
+                 Srb->SenseInfoBufferLength);
+        Srb->SrbStatus = SRB_STATUS_ERROR;
+        return;
+    }*/
+    memset(pScb->pSenseBuffer, 0, pScb->senseBufferLength);
+    /*pScb->ScsiCommandCompletion = ;*/
+    pScb->ScsiStatus =  MV_SCSI_STATUS_CHECK_CONDITION;
+
+    SenseData.ResponseCode = MV_SCSI_RESPONSE_CODE;
+    SenseData.Valid = 0;
+
+    SenseData.AdditionalSenseLength = 5;
+    pScb->senseDataLength = 13;
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " ATA Drive Registers:\n");
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Error", registerStruct->errorRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","SectorCount", registerStruct->sectorCountRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Low", registerStruct->lbaLowRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Mid", registerStruct->lbaMidRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA High", registerStruct->lbaHighRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Device", registerStruct->deviceRegister);
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Status", registerStruct->statusRegister);
+
+    /* If the command is synchronize cache */
+    if (pScb->ScsiCdb[0] == SCSI_OPCODE_SYNCHRONIZE_CACHE10)
+    {
+        if (!(registerStruct->errorRegister & ABRT_ERR))
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " received error completion on flush cache command"
+                     " but ABORT bit in error register is not set\n");
+        }
+        SenseData.SenseKey = SCSI_SENSE_MEDIUM_ERROR;
+        SenseData.Valid = 1;
+        if (pScb->isExtended == MV_TRUE)
+        {
+            /* LBA 48 error handling */
+            SenseData.Information[0] =  (MV_U8)((registerStruct->lbaLowRegister >> 8) & 0xff);
+        }
+        else
+        {
+            /* LBA 28 error handling */
+            SenseData.Information[0] =  (MV_U8)((registerStruct->deviceRegister) & 0x0f);
+        }
+        SenseData.Information[1] = (MV_U8)(registerStruct->lbaHighRegister & 0xff);
+        SenseData.Information[2] = (MV_U8)(registerStruct->lbaMidRegister & 0xff);
+        SenseData.Information[3] = (MV_U8)(registerStruct->lbaLowRegister & 0xff);
+
+    }
+    else if ((pScb->ScsiCdb[0] == SCSI_OPCODE_VERIFY10) || (pScb->ScsiCdb[0] == SCSI_OPCODE_VERIFY6))
+    {
+        if (errorReg & (NM_ERR | MC_ERR | MCR_ERR))
+        {
+            SenseData.SenseKey = SCSI_SENSE_UNIT_ATTENTION;
+        }
+        else if (errorReg & UNC_ERR)
+        {
+            MV_U32  LowLbaAddress = pScb->LowLbaAddress;
+            SenseData.SenseKey = SCSI_SENSE_MEDIUM_ERROR;
+            SenseData.Valid = 1;
+            /* Since high 8 bit address are taken immediatly from LowLbaAddress and
+            not from the completion info ; the following code is relevant for both
+            48bit and 28bit LBA addressing*/
+            SenseData.Information[0] = (MV_U8)((LowLbaAddress & 0xff000000) >> 24);
+            SenseData.Information[1] = (MV_U8)(registerStruct->lbaHighRegister & 0xff);
+            SenseData.Information[2] = (MV_U8)(registerStruct->lbaMidRegister & 0xff);
+            SenseData.Information[3] = (MV_U8)(registerStruct->lbaLowRegister & 0xff);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Read Verify failed on UNC at sector %02x %02x %02x %02x\n",
+                     SenseData.Information[0], SenseData.Information[1],
+                     SenseData.Information[2], SenseData.Information[3]);
+        }
+        /*else if (errorReg & IDNF_ERR)
+        {
+            SenseData.SenseKey = SCSI_SENSE_VOL_OVERFLOW;
+        }*/
+        else if ((errorReg & ABRT_ERR) || (errorReg & IDNF_ERR))
+        {
+            SenseData.SenseKey = SCSI_SENSE_ABORTED_COMMAND;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+        }
+        else
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " in mapping ATA error to SCSI error\n");
+            SenseData.SenseKey = SCSI_SENSE_NO_SENSE;
+        }
+    }
+    else if (pScb->ScsiCdb[0] == SCSI_OPCODE_MODE_SELECT6)
+    {
+        /* MODE SELECT is only when enabling / disabling write cache */
+        if (errorReg & ABRT_ERR)
+        {
+            SenseData.SenseKey = SCSI_SENSE_ABORTED_COMMAND;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+        }
+        else
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " in mapping ATA error to SCSI error\n");
+            SenseData.SenseKey = SCSI_SENSE_NO_SENSE;
+        }
+    }
+    pScb->senseDataLength = 13;
+    memcpy(pScb->pSenseBuffer, &SenseData,
+           (pScb->senseBufferLength > pScb->senseDataLength) ?
+           pScb->senseDataLength : pScb->senseBufferLength);
+}
+
+
+
+static MV_VOID
+handleUdmaError(MV_SATA_SCSI_CMD_BLOCK  *pScb,
+                MV_U32 responseFlags,
+                MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "UDMA %s command failed\n", (pScb->udmaType == MV_UDMA_TYPE_READ) ?
+             "READ" : "WRITE");
+    if (responseFlags & (MV_BIT3))
+    {
+        /* prevent the error_handler from re-send any commands */
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_DISCONNECT;
+    }
+    else if (responseFlags & MV_BIT2)           /* ATA error*/
+    {
+        MV_SCSI_SENSE_DATA SenseData;
+
+        memset(&SenseData, 0, sizeof(MV_SCSI_SENSE_DATA));
+        pScb->ScsiStatus =  MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->senseDataLength = 13;
+        SenseData.Valid = 1;
+        SenseData.ResponseCode = MV_SCSI_RESPONSE_CODE;
+        SenseData.AdditionalSenseLength = 5;
+
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " ATA Drive Registers:\n");
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Error", registerStruct->errorRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","SectorCount", registerStruct->sectorCountRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Low", registerStruct->lbaLowRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA Mid", registerStruct->lbaMidRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","LBA High", registerStruct->lbaHighRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Device", registerStruct->deviceRegister);
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "%20s : %04x\n","Status", registerStruct->statusRegister);
+
+        if ((registerStruct->errorRegister & ICRC_ERR)||
+            (registerStruct->errorRegister == 0xC))/*error code injected by 88i8030*/
+        {
+            SenseData.SenseKey = SCSI_SENSE_ABORTED_COMMAND;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+        }
+        else if (registerStruct->errorRegister &
+                 (NM_ERR | MC_ERR | MCR_ERR))
+        {
+            SenseData.SenseKey = SCSI_SENSE_UNIT_ATTENTION;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
+        }
+        else if (registerStruct->errorRegister & UNC_ERR)
+        {
+            MV_U32  LowLbaAddress = pScb->LowLbaAddress;
+            SenseData.Valid = 1;
+            SenseData.Information[0] = (MV_U8)((LowLbaAddress & 0xff000000) >> 24);
+            SenseData.Information[1] = (MV_U8)(registerStruct->lbaHighRegister & 0xff);
+            SenseData.Information[2] = (MV_U8)(registerStruct->lbaMidRegister & 0xff);
+            SenseData.Information[3] = (MV_U8)(registerStruct->lbaLowRegister & 0xff);
+            if (pScb->udmaType == MV_UDMA_TYPE_READ)
+            {
+                SenseData.SenseKey = SCSI_SENSE_MEDIUM_ERROR;
+                SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " UDMA Read failed on UNC at sector %02x %02x %02x %02x\n",
+                         SenseData.Information[0], SenseData.Information[1],
+                         SenseData.Information[2], SenseData.Information[3]);
+
+            }
+            else
+            {
+                SenseData.SenseKey = SCSI_SENSE_DATA_PROTECT;
+                SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+            }
+        }
+        else if (((registerStruct->errorRegister & IDNF_ERR) &&
+                  (!(registerStruct->errorRegister & ABRT_ERR))) ||
+                 (!(registerStruct->errorRegister & IDNF_ERR) &&
+                  (registerStruct->errorRegister & ABRT_ERR)))
+        {
+            /* In case IDNF is set and ABRT reset OR IDNF reset and ABRT is set */
+            SenseData.SenseKey = SCSI_SENSE_ILLEGAL_REQUEST;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_ILLEGAL_BLOCK;
+        }
+        else if (registerStruct->errorRegister & ABRT_ERR)
+        {
+            SenseData.SenseKey = SCSI_SENSE_ABORTED_COMMAND;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+        }
+        else
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " in mapping ATA error to SCSI error\n");
+            SenseData.SenseKey = SCSI_SENSE_ABORTED_COMMAND;
+            SenseData.AdditionalSenseCode = SCSI_ADSENSE_NO_SENSE;
+        }
+        pScb->senseDataLength = 13;
+        memcpy(pScb->pSenseBuffer, &SenseData,
+               (pScb->senseBufferLength > pScb->senseDataLength) ?
+               pScb->senseDataLength : pScb->senseBufferLength);
+    }
+    else if (responseFlags & (MV_BIT0 | MV_BIT1))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_PARITY_ERROR;
+        pScb->ScsiStatus =  MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->senseDataLength = 0;
+        pScb->dataTransfered = 0;
+    }
+    else if (responseFlags & (MV_BIT6|MV_BIT5))
+    {
+        if (responseFlags & MV_BIT6)
+        {
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_UNDERRUN;
+        }
+        else
+        {
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_OVERRUN;
+        }
+        pScb->dataTransfered = 0;
+
+    }
+}
+
+/*******************************************************************************
+* checkQueueCommandResult -
+*
+* DESCRIPTION:  set the scsi request completion status and the Scsi Status
+*       according to the result returned form the mvSataQueueCommand function
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+* COMMENTS:
+*
+*
+*******************************************************************************/
+
+/*static*/ MV_VOID  checkQueueCommandResult(MV_SATA_SCSI_CMD_BLOCK *pScb,
+                                        MV_QUEUE_COMMAND_RESULT  result)
+{
+    switch (result)
+    {
+    case MV_QUEUE_COMMAND_RESULT_BAD_LBA_ADDRESS:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Edma Queue command failed. Bad LBA \n");
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCB;
+        break;
+    case MV_QUEUE_COMMAND_RESULT_QUEUED_MODE_DISABLED:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Edma Queue command failed. EDMA disabled\n");
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_NOT_READY;
+
+        break;
+    case MV_QUEUE_COMMAND_RESULT_FULL:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Edma Queue command failed. Queue is Full\n");
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_QUEUE_FULL;
+        pScb->ScsiStatus = MV_SCSI_STATUS_QUEUE_FULL;
+        break;
+    case MV_QUEUE_COMMAND_RESULT_BAD_PARAMS:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Edma Queue command failed. (Bad Params)\n");
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCB;
+        break;
+    default:
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Bad result value (%d) from queue"
+                 " command\n", result);
+    }
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " mvSataQueueUDmaCommand Failed\n");
+    pScb->dataTransfered = 0;
+    pScb->senseDataLength = 0;
+}
+#ifdef MV_LOGGER
+static MV_VOID reportScbCompletion(MV_SATA_ADAPTER*    pSataAdapter,
+                                   MV_SATA_SCSI_CMD_BLOCK *pScb)
+{
+    if (pScb->ScsiCommandCompletion != MV_SCSI_COMPLETION_SUCCESS)
+    {
+        MV_U8   buffer[100];
+        MV_U32  index = 0;
+        MV_BOOLEAN      printInfo = MV_TRUE;
+
+        switch (pScb->ScsiCommandCompletion)
+        {
+        case MV_SCSI_COMPLETION_BAD_SCSI_COMMAND:
+            SAL_SPRINTF(buffer, "%s", "MV_SCSI_COMPLETION_BAD_SCSI_COMMAND");
+            break;
+        case MV_SCSI_COMPLETION_ATA_FAILED:
+            SAL_SPRINTF(buffer, "%s", "MV_SCSI_COMPLETION_ATA_FAILED");
+            break;
+        case MV_SCSI_COMPLETION_PARITY_ERROR:
+            SAL_SPRINTF(buffer, "%s", "MV_SCSI_COMPLETION_PARITY");
+            break;
+        default:
+            printInfo = MV_FALSE;
+        }
+
+        if (printInfo == MV_TRUE)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " %d %d %d :Scsi command completed. pScb %p, ScsiStatus %d "
+                     "completionStatus %s\n", pSataAdapter->adapterId,
+                     pScb->bus, pScb->target, pScb, pScb->ScsiStatus, buffer);
+        }
+        else
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Scsi command completed. pScb %p, ScsiStatus %d "
+                     "completionStatus %d\n", pScb, pScb->ScsiStatus,
+                     pScb->ScsiCommandCompletion);
+        }
+
+        index = SAL_SPRINTF(buffer, "%s", "CDB:");
+        {
+            MV_U32  i;
+            for (i =0 ; i < pScb->ScsiCdbLength; i++)
+            {
+                index += SAL_SPRINTF(&buffer[index], "%x ",
+                                     pScb->ScsiCdb[i]);
+            }
+            buffer[index] = '\n';
+            buffer[index+1] = 0;
+            mvLogMsg(MV_SAL_LOG_ID,(printInfo == MV_TRUE) ?
+                     MV_DEBUG_ERROR : MV_DEBUG, buffer);
+            if (pScb->ScsiStatus == MV_SCSI_STATUS_CHECK_CONDITION)
+            {
+                if ((pScb->pSenseBuffer != NULL) && (pScb->senseBufferLength > 0))
+                {
+                    MV_U32  len = pScb->senseDataLength > pScb->senseBufferLength ?
+                                  pScb->senseBufferLength:pScb->senseDataLength;
+                    index = SAL_SPRINTF(buffer, "%s", "Sense Data:");
+                    for (i = 0; i < len; i++)
+                    {
+                        index += SAL_SPRINTF(buffer + index, "%x ",
+                                             pScb->pSenseBuffer[i]);
+                    }
+                    buffer[index] = '\n';
+                    buffer[index+1] = 0;
+                    mvLogMsg(MV_SAL_LOG_ID, (printInfo == MV_TRUE) ?
+                             MV_DEBUG_ERROR : MV_DEBUG, buffer);
+                }
+            }
+        }
+        if (pScb->ScsiCommandCompletion == MV_SCSI_COMPLETION_ATA_FAILED)
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " ATA Drive Registers:\n");
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","Error", pScb->ATAregStruct.errorRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","SectorCount", pScb->ATAregStruct.sectorCountRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","LBA Low", pScb->ATAregStruct.lbaLowRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","LBA Mid", pScb->ATAregStruct.lbaMidRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","LBA High", pScb->ATAregStruct.lbaHighRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","Device", pScb->ATAregStruct.deviceRegister);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "%20s : %04x\n","Status", pScb->ATAregStruct.statusRegister);
+        }
+    }
+    else
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Scsi command completed. pScb %p, ScsiStatus %d "
+                 "completionStatus %d\n", pScb, pScb->ScsiStatus,
+                 pScb->ScsiCommandCompletion);
+    }
+
+}
+#endif
+static MV_VOID  mvScsiAtaSendSplittedVerifyCommand(IN MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO   commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+    MV_U8                  sectors = 0;/*256 sectors*/
+    pCommandParams = &commandParams;
+
+    pScb->sequenceNumber++;
+    if (pScb->sequenceNumber == 1)/*for the first command*/
+    {
+        if (pScb->ScsiCdb[0] == SCSI_OPCODE_VERIFY6)
+        {
+            sectors = pScb->ScsiCdb[4];
+        }
+        else
+        {
+            sectors = pScb->ScsiCdb[8];
+        }
+    }
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_READ_VERIFY_SECTORS;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 0;
+
+    commandParams.commandParams.NoneUdmaCommand.features = 0;
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = (MV_U16)((pScb->LowLbaAddress & 0xff0000) >> 16);
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = (MV_U16)((pScb->LowLbaAddress & 0xff00) >> 8);
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = (MV_U16)(pScb->LowLbaAddress & 0xff);
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = sectors;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6 |
+                                                                 ((pScb->LowLbaAddress & 0xf000000) >> 24));
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: Sending Splitted Verify command:seq# %d code %x lba"
+             " %x(%x.%x.%x), sectors %d[%d] Srb %p\n",
+             pScb->pSalAdapterExtension->pSataAdapter->adapterId, pScb->bus,
+             pScb->target,
+             pScb->sequenceNumber,pScb->ScsiCdb[0],
+             pScb->LowLbaAddress,
+             commandParams.commandParams.NoneUdmaCommand.lbaHigh,
+             commandParams.commandParams.NoneUdmaCommand.lbaMid,
+             commandParams.commandParams.NoneUdmaCommand.lbaLow,
+             commandParams.commandParams.NoneUdmaCommand.sectorCount,
+             mvSataNumOfDmaCommands(pScb->pSalAdapterExtension->pSataAdapter,
+                                    pScb->bus), pScb);
+
+    if (sectors)
+    {
+        pScb->LowLbaAddress += sectors;
+    }
+    else
+    {
+        pScb->LowLbaAddress += 0x100;
+    }
+
+    result = mvSataQueueCommand(pScb->pSalAdapterExtension->pSataAdapter,
+                                pScb->bus, pCommandParams);
+
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+#ifdef MV_LOGGER
+        reportScbCompletion(pScb->pSalAdapterExtension->pSataAdapter, pScb);
+#endif
+
+        return;
+    }
+
+    /* update stats*/
+    pScb->pSalAdapterExtension->totalAccumulatedOutstanding[pScb->bus] +=
+    mvSataNumOfDmaCommands(pScb->pSalAdapterExtension->pSataAdapter,pScb->bus);
+    pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target].stats.totalIOs++;
+    pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target].stats.totalSectorsTransferred += sectors;
+
+}
+static MV_VOID  mvScsiAtaSendReadLookAhead(IN MV_SATA_ADAPTER *pSataAdapter,
+                                           IN MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_QUEUE_COMMAND_INFO   commandParams, *pCommandParams;
+    MV_QUEUE_COMMAND_RESULT result;
+
+    pCommandParams = &commandParams;
+
+    if (pScb->LowLbaAddress == 0) /* Disable Look Ahead*/
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Parse Caching Page: Disable Read Look Ahead\n");
+        commandParams.commandParams.NoneUdmaCommand.features = MV_ATA_SET_FEATURES_DISABLE_RLA;
+    }
+    else
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Parse Caching Page: Enable Look Ahead\n");
+        commandParams.commandParams.NoneUdmaCommand.features = MV_ATA_SET_FEATURES_ENABLE_RLA;
+    }
+
+    pScb->commandType = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+
+    commandParams.type = MV_QUEUED_COMMAND_TYPE_NONE_UDMA;
+    commandParams.PMPort = pScb->target;
+    commandParams.commandParams.NoneUdmaCommand.bufPtr = NULL;
+    commandParams.commandParams.NoneUdmaCommand.callBack = SALCommandCompletionCB;
+    commandParams.commandParams.NoneUdmaCommand.command = MV_ATA_COMMAND_SET_FEATURES;
+    commandParams.commandParams.NoneUdmaCommand.commandId = (MV_VOID_PTR) pScb;
+    commandParams.commandParams.NoneUdmaCommand.count = 0;
+
+    commandParams.commandParams.NoneUdmaCommand.isEXT = MV_FALSE;
+    commandParams.commandParams.NoneUdmaCommand.lbaHigh = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaMid = 0;
+    commandParams.commandParams.NoneUdmaCommand.lbaLow = 0;
+    commandParams.commandParams.NoneUdmaCommand.protocolType = MV_NON_UDMA_PROTOCOL_NON_DATA;
+    commandParams.commandParams.NoneUdmaCommand.sectorCount = 0;
+    commandParams.commandParams.NoneUdmaCommand.device = (MV_U8)(MV_BIT6);
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Sending SET FEATURES command: features %d\n",
+             commandParams.commandParams.NoneUdmaCommand.features);
+
+    pScb->sequenceNumber++;
+    result = mvSataQueueCommand(pSataAdapter, pScb->bus, pCommandParams);
+
+    if (result != MV_QUEUE_COMMAND_RESULT_OK)
+    {
+        checkQueueCommandResult(pScb, result);
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return;
+    }
+}
+
+MV_VOID     mvSataScsiInitAdapterExt(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                                     MV_SATA_ADAPTER* pSataAdapter)
+{
+    MV_U8   channelIndex;
+    MV_U8   PMPort;
+    pAdapterExt->pSataAdapter = pSataAdapter;
+    pAdapterExt->pHead = NULL;
+    pAdapterExt->UAMask = 0xFF;
+    for (channelIndex = 0; channelIndex < MV_SATA_CHANNELS_NUM; channelIndex++)
+    {
+        for (PMPort = 0; PMPort < MV_SATA_PM_MAX_PORTS; PMPort++)
+        {
+            pAdapterExt->ataDriveData[channelIndex][PMPort].driveReady = MV_FALSE;
+            /* one identify data buffer used for all the drives connected to */
+            /* the same channel*/
+            pAdapterExt->ataDriveData[channelIndex][PMPort].identifyBuffer =
+            pAdapterExt->identifyBuffer[channelIndex];
+        }
+    }
+}
+
+MV_SCSI_COMMAND_STATUS_TYPE mvSataExecuteScsiCommand(MV_SATA_SCSI_CMD_BLOCK  *pScb)
+{
+    MV_U8               *cmd = pScb->ScsiCdb;
+    MV_BOOLEAN          invalidCDB = MV_FALSE;
+    MV_SATA_ADAPTER *pSataAdapter = pScb->pSalAdapterExtension->pSataAdapter;
+    MV_SATA_SCSI_DRIVE_DATA *pDriveData;
+
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Scsi Command Received, adapter %d bus %d target %d lun %"
+             "d pScb %p\n    Data Buffer length %d, Sense buffer length %x\n",
+             pSataAdapter->adapterId, pScb->bus, pScb->target,
+             pScb->lun, pScb, pScb->dataBufferLength, pScb->senseBufferLength);
+
+#ifdef MV_LOGGER
+
+        {
+            MV_U8 buffer[30];
+            MV_U32  i, index;
+
+            index = SAL_SPRINTF(buffer, "%s", "CDB:");
+            for (i =0 ; i < pScb->ScsiCdbLength; i++)
+            {
+                index += SAL_SPRINTF(&buffer[index], "%x ",
+                                     pScb->ScsiCdb[i]);
+            }
+            buffer[index] = '\n';
+            buffer[index+1] = 0;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, buffer);
+        }
+#endif
+    pScb->dataTransfered = 0;
+    pScb->senseDataLength = 0;
+    pScb->ScsiStatus = 0;
+    if (pScb->bus >= pSataAdapter->numberOfChannels)
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_INVALID_BUS;
+        pScb->dataTransfered = 0;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    if ((pScb->target >= MV_SATA_PM_MAX_PORTS) ||
+        (pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target].driveReady == MV_FALSE) ||
+        ((pScb->lun) && (pScb->ScsiCdb[0] != SCSI_OPCODE_INQUIRY)))
+    {
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_NO_DEVICE;
+        pScb->dataTransfered = 0;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+    pDriveData = &pScb->pSalAdapterExtension->ataDriveData[pScb->bus][pScb->target];
+    switch (cmd[0])
+    {
+    case SCSI_OPCODE_READ10:
+    case SCSI_OPCODE_WRITE10:
+    case SCSI_OPCODE_READ_CAPACITY10:
+    case SCSI_OPCODE_VERIFY10:
+    case SCSI_OPCODE_SYNCHRONIZE_CACHE10:
+
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+    case SCSI_OPCODE_WRITE_LONG10:
+    case SCSI_OPCODE_READ_LONG10:
+#endif
+        if (cmd[1] & MV_BIT0) /* if related address*/
+        {
+            invalidCDB = MV_TRUE;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: Scsi command received with "
+                     "RELADR bit enabled - returning ILLEGAL REQUEST\n"
+                     ,pSataAdapter->adapterId, pScb->bus, pScb->target);
+
+        }
+    }
+    if (cmd[pScb->ScsiCdbLength - 1] != 0) /*if CONTROL is set*/
+    {
+        MV_BOOLEAN commandSupported = MV_TRUE;
+
+        switch (cmd[0])
+        {
+        case SCSI_OPCODE_READ6:
+        case SCSI_OPCODE_READ10:
+        case SCSI_OPCODE_WRITE6:
+        case SCSI_OPCODE_WRITE10:
+        case SCSI_OPCODE_INQUIRY:
+        case SCSI_OPCODE_TEST_UNIT_READY:
+        case SCSI_OPCODE_MODE_SELECT6:
+        case SCSI_OPCODE_MODE_SENSE6:
+        case SCSI_OPCODE_READ_CAPACITY10:     /* read capctiy CDB*/
+        case SCSI_OPCODE_REQUEST_SENSE6:
+        case SCSI_OPCODE_VERIFY6:
+        case SCSI_OPCODE_VERIFY10:
+        case SCSI_OPCODE_SYNCHRONIZE_CACHE10:
+        case SCSI_OPCODE_SEEK10:
+        case SCSI_OPCODE_REASSIGN_BLOCKS:
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+        case SCSI_OPCODE_WRITE_LONG10:
+        case SCSI_OPCODE_READ_LONG10:
+#endif
+
+            break;
+        default:
+            commandSupported = MV_FALSE;
+        }
+        if (commandSupported == MV_TRUE)
+        {
+            invalidCDB = MV_TRUE;
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "[%d,%d] Scsi command received with "
+                     "none zero CONTROL bits - returning ILLEGAL REQUEST\n"
+                     ,pSataAdapter->adapterId, pScb->bus);
+        }
+    }
+
+    if (pDriveData->UAConditionPending == MV_TRUE)
+    {
+        if (((cmd[0] != SCSI_OPCODE_INQUIRY) &&
+             (cmd[0] != SCSI_OPCODE_REQUEST_SENSE6)) || (invalidCDB == MV_TRUE))
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " Unit Attention condition is pending.\n");
+
+            if (pDriveData->UAEvents & MV_BIT0)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Bus Reset.\n");
+                pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_UA_RESET;
+                setSenseData(pScb, SCSI_SENSE_UNIT_ATTENTION, SCSI_ADSENSE_BUS_RESET
+                             , 2);
+                pDriveData->UAEvents &= ~MV_BIT0;
+            }
+            else if (pDriveData->UAEvents & MV_BIT1)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Report Mode Parameters Changed.\n");
+                pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_UA_PARAMS_CHANGED;
+                setSenseData(pScb, SCSI_SENSE_UNIT_ATTENTION,
+                             SCSI_ADSENSE_PARAMETERS_CHANGED, 1);
+                pDriveData->UAEvents &= ~MV_BIT1;
+            }
+
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->dataTransfered = 0;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            if (pDriveData->UAEvents == 0)
+            {
+                pDriveData->UAConditionPending = MV_FALSE;
+            }
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+        }
+    }
+    if (invalidCDB == MV_TRUE)
+    {
+        setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_INVALID_CDB,
+                     0);
+        pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+        pScb->dataTransfered = 0;
+        pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+        reportScbCompletion(pSataAdapter, pScb);
+#endif
+        pScb->completionCallBack(pSataAdapter, pScb);
+        return MV_SCSI_COMMAND_STATUS_COMPLETED;
+    }
+
+    switch (cmd[0])
+    {
+    case SCSI_OPCODE_READ6:
+    case SCSI_OPCODE_READ10:
+    case SCSI_OPCODE_WRITE6:
+    case SCSI_OPCODE_WRITE10:
+        return mvScsiAtaSendDataCommand(pSataAdapter, pScb);
+    case SCSI_OPCODE_INQUIRY:
+        return mvScsiAtaGetInquiryData(pSataAdapter, pScb);
+    case SCSI_OPCODE_TEST_UNIT_READY:
+        return mvScsiAtaTestUnitReady(pSataAdapter, pScb);
+    case SCSI_OPCODE_MODE_SELECT6:
+        return mvScsiAtaModeSelect(pSataAdapter, pScb);
+    case SCSI_OPCODE_MODE_SENSE6:
+        return mvScsiAtaGetModeSenseData(pSataAdapter,pScb);
+        /* Used to detect write protected status.*/
+    case SCSI_OPCODE_READ_CAPACITY10:     /* read capctiy CDB*/
+        return mvScsiAtaGetReadCapacityData(pSataAdapter, pScb);
+    case SCSI_OPCODE_REQUEST_SENSE6:
+        return mvScsiAtaGetRequestSenseData(pSataAdapter, pScb);
+    case SCSI_OPCODE_VERIFY6:
+    case SCSI_OPCODE_VERIFY10:
+        return mvScsiAtaSendVerifyCommand(pSataAdapter, pScb);
+    case SCSI_OPCODE_SYNCHRONIZE_CACHE10:
+        return mvScsiAtaSendSyncCacheCommand(pSataAdapter, pScb);
+    case SCSI_OPCODE_SEEK10:
+        return mvScsiAtaSeek(pSataAdapter, pScb);
+    case SCSI_OPCODE_REASSIGN_BLOCKS:
+        return mvScsiAtaReassignBlocks(pSataAdapter, pScb);
+#ifdef MV_SATA_SUPPORT_READ_WRITE_LONG
+    case SCSI_OPCODE_WRITE_LONG10:
+        return mvScsiAtaWriteLong(pSataAdapter, pScb);
+    case SCSI_OPCODE_READ_LONG10:
+        return mvScsiAtaReadLong(pSataAdapter, pScb);
+#endif
+
+    default:
+        {
+            setSenseData(pScb, SCSI_SENSE_ILLEGAL_REQUEST,
+                         SCSI_ADSENSE_ILLEGAL_COMMAND, 0);
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, "mvExecuteScsiCommand: ERROR: Unsupported command %02X\n", pScb->ScsiCdb[0]);
+            pScb->ScsiStatus = MV_SCSI_STATUS_CHECK_CONDITION;
+            pScb->dataTransfered = 0;
+            pScb->ScsiCommandCompletion = MV_SCSI_COMPLETION_BAD_SCSI_COMMAND;
+#ifdef MV_LOGGER
+            reportScbCompletion(pSataAdapter, pScb);
+#endif
+            pScb->completionCallBack(pSataAdapter, pScb);
+            return MV_SCSI_COMMAND_STATUS_COMPLETED;
+
+        }
+    }
+
+    return MV_SCSI_COMMAND_STATUS_FAILED;
+}
+
+MV_VOID mvSataScsiPostIntService(MV_SAL_ADAPTER_EXTENSION *pAdapterExt)
+{
+    MV_SATA_SCSI_CMD_BLOCK  *pScb = pAdapterExt->pHead;
+    while (pScb)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, "Post Interrupt Service: pScb %p command %x\n", pScb,
+                 pScb->ScsiCdb[0]);
+        switch (pScb->ScsiCdb[0])
+        {
+        case    SCSI_OPCODE_VERIFY10:
+        case    SCSI_OPCODE_VERIFY6:
+            mvScsiAtaSendSplittedVerifyCommand(pScb);
+            break;
+        case    SCSI_OPCODE_MODE_SELECT6:
+            mvScsiAtaSendReadLookAhead(pAdapterExt->pSataAdapter,
+                                       pScb);
+            break;
+        default:
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG_ERROR, " Post Interrupt Service called for bad scsi"
+                     " command(%x)\n", pScb->ScsiCdb[0]);
+        }
+        pScb = pScb->pNext;
+    }
+    pAdapterExt->pHead = NULL;
+    return;
+}
+
+MV_VOID     mvSataScsiSetDriveReady(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                                    MV_U8   channelIndex, MV_U8 PMPort,
+                                    MV_BOOLEAN  isReady)
+{
+    if (isReady == MV_TRUE)
+    {
+        mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: ATA Drive is Ready.\n",
+                 pAdapterExt->pSataAdapter->adapterId, channelIndex, PMPort);
+        pAdapterExt->ataDriveData[channelIndex][PMPort].driveReady = MV_TRUE;
+        pAdapterExt->totalAccumulatedOutstanding[channelIndex] = 0;
+        pAdapterExt->ataDriveData[channelIndex][PMPort].stats.totalIOs = 0;
+        pAdapterExt->ataDriveData[channelIndex][PMPort].stats.totalSectorsTransferred = 0;
+    }
+    else
+    {
+        if (PMPort == 0xFF)
+        {
+            MV_U8   i;
+
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d  : SATA Channel is Removed.\n",
+                     pAdapterExt->pSataAdapter->adapterId, channelIndex);
+            for (i = 0; i < MV_SATA_PM_MAX_PORTS; i++)
+            {
+                mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: SATA Drive is Removed.\n",
+                         pAdapterExt->pSataAdapter->adapterId, channelIndex,
+                         i);
+                pAdapterExt->ataDriveData[channelIndex][i].driveReady = MV_FALSE;
+            }
+
+        }
+        else
+        {
+            mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: SATA Drive is Removed.\n",
+                     pAdapterExt->pSataAdapter->adapterId, channelIndex,
+                     PMPort);
+            pAdapterExt->ataDriveData[channelIndex][PMPort].driveReady = MV_FALSE;
+
+        }
+    }
+}
+
+
+/* notify the translation layer with Reset and Power on reset*/
+MV_VOID mvSataScsiNotifyUA(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                           MV_U8    channelIndex, MV_U8 PMPort)
+{
+    pAdapterExt->ataDriveData[channelIndex][PMPort].UAConditionPending = MV_TRUE;
+    /* bit 0 - reset*/
+    /* bit 1 - parameters changed*/
+    pAdapterExt->ataDriveData[channelIndex][PMPort].UAEvents = MV_BIT1 | MV_BIT0;
+    pAdapterExt->ataDriveData[channelIndex][PMPort].UAEvents &=
+                                            pAdapterExt->UAMask;
+    mvLogMsg(MV_SAL_LOG_ID, MV_DEBUG, " %d %d %d: Notify SAL with Unit Attention condition.\n",
+             pAdapterExt->pSataAdapter->adapterId, channelIndex, PMPort);
+}
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvScsiAtaLayer.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvScsiAtaLayer.h
@@ -0,0 +1,334 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvScsiAtaLayer.c
+*
+* DESCRIPTION:
+*       C implementation for SCSI to ATA translation layer.
+*
+* DEPENDENCIES:
+*   mvIALCommonUtils.h
+*   mvSata.h
+*   mvStorageDev.h
+*   mvOs.h
+*
+*******************************************************************************/
+#ifndef __INCmvScsiAtaLayer
+#define __INCmvScsiAtaLayer
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvStorageDev.h"
+#include "mvIALCommonUtils.h"
+
+/* Defines */
+#define MV_SAL_LOG_ID       1
+
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+
+#ifndef INOUT
+#define INOUT
+#endif
+
+/* Scsi opcodes*/
+/* 6 - bytes commands*/
+#define SCSI_OPCODE_TEST_UNIT_READY         0x00
+#define SCSI_OPCODE_REQUEST_SENSE6          0x03
+#define SCSI_OPCODE_REASSIGN_BLOCKS         0x07
+#define SCSI_OPCODE_READ6                   0x08
+#define SCSI_OPCODE_WRITE6                  0x0A
+#define SCSI_OPCODE_INQUIRY                 0x12
+#define SCSI_OPCODE_VERIFY6                 0x13
+#define SCSI_OPCODE_MODE_SELECT6            0x15
+#define SCSI_OPCODE_MODE_SENSE6             0x1A
+
+/* 10 - bytes commands*/
+#define SCSI_OPCODE_READ_CAPACITY10         0x25
+#define SCSI_OPCODE_READ10                  0x28
+#define SCSI_OPCODE_WRITE10                 0x2A
+#define SCSI_OPCODE_VERIFY10                0x2F
+#define SCSI_OPCODE_SYNCHRONIZE_CACHE10     0x35
+#define SCSI_OPCODE_SEEK10                  0x2B
+#define SCSI_OPCODE_WRITE_LONG10            0x3F
+#define SCSI_OPCODE_READ_LONG10				0x3E
+
+/* 12 - bytes commands */
+/* 16 - bytes commands */
+
+
+
+    /* SCSI bus status codes */
+#define MV_SCSI_STATUS_GOOD                  0x00
+#define MV_SCSI_STATUS_CHECK_CONDITION       0x02
+#define MV_SCSI_STATUS_CONDITION_MET         0x04
+#define MV_SCSI_STATUS_BUSY                  0x08
+#define MV_SCSI_STATUS_INTERMEDIATE          0x10
+#define MV_SCSI_STATUS_INTERMEDIATE_COND_MET 0x14
+#define MV_SCSI_STATUS_RESERVATION_CONFLICT  0x18
+#define MV_SCSI_STATUS_COMMAND_TERMINATED    0x22
+#define MV_SCSI_STATUS_QUEUE_FULL            0x28
+
+
+/* Typedefs */
+
+
+/* Scsi Sense Data Format */
+/* Max length - 18 bytes, the additional sense length will not exceed 10 bytes*/
+    typedef struct _mvScsiSenseData
+    {
+        MV_U8 ResponseCode:7;
+        MV_U8 Valid:1;
+        MV_U8 Reserved1;
+        MV_U8 SenseKey:4;
+        MV_U8 Reserved2:1;
+        MV_U8 ILI:1; /* Incorrect Length Indicator*/
+        MV_U8 EOM:1; /* End Of Media */
+        MV_U8 FileMark:1;
+        MV_U8 Information[4];
+        MV_U8 AdditionalSenseLength;
+        MV_U8 CommandSpecificInformation[4];
+        MV_U8 AdditionalSenseCode;
+        MV_U8 AdditionalSenseCodeQualifier;
+        MV_U8 FieldReplaceableUnitCode;
+        MV_U8 SenseKeySpecific[3];
+    } MV_SCSI_SENSE_DATA;
+
+/* Sense codes */
+
+#define SCSI_SENSE_NO_SENSE         0x00
+#define SCSI_SENSE_RECOVERED_ERROR  0x01
+#define SCSI_SENSE_NOT_READY        0x02
+#define SCSI_SENSE_MEDIUM_ERROR     0x03
+#define SCSI_SENSE_HARDWARE_ERROR   0x04
+#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
+#define SCSI_SENSE_UNIT_ATTENTION   0x06
+#define SCSI_SENSE_DATA_PROTECT     0x07
+#define SCSI_SENSE_BLANK_CHECK      0x08
+#define SCSI_SENSE_UNIQUE           0x09
+#define SCSI_SENSE_COPY_ABORTED     0x0A
+#define SCSI_SENSE_ABORTED_COMMAND  0x0B
+#define SCSI_SENSE_EQUAL            0x0C
+#define SCSI_SENSE_VOL_OVERFLOW     0x0D
+#define SCSI_SENSE_MISCOMPARE       0x0E
+#define SCSI_SENSE_RESERVED         0x0F
+
+/* Additional Sense codes */
+
+#define SCSI_ADSENSE_NO_SENSE       0x00
+#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
+#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
+#define SCSI_ADSENSE_INVALID_CDB    0x24
+#define SCSI_ADSENSE_INVALID_LUN    0x25
+#define SCSI_ADSENSE_INVALID_FIELD_IN_PARAMETER_LIST    0x26
+#define SCSI_ADSENSE_BUS_RESET      0x29
+#define SCSI_ADSENSE_PARAMETERS_CHANGED     0x2A
+#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
+
+
+#define MV_SCSI_RESPONSE_CODE   0x70
+#define MV_SCSI_DIRECT_ACCESS_DEVICE    0x00
+#define MV_MAX_MODE_SENSE_RESULT_LENGTH 50
+
+
+/* Typedefs */
+    typedef enum _mvScsiCompletionType
+    {
+        MV_SCSI_COMPLETION_INVALID_STATUS,
+        MV_SCSI_COMPLETION_SUCCESS,
+        MV_SCSI_COMPLETION_BAD_SCB,
+        MV_SCSI_COMPLETION_BAD_SCSI_COMMAND,
+        MV_SCSI_COMPLETION_ATA_FAILED,
+        MV_SCSI_COMPLETION_QUEUE_FULL,
+        MV_SCSI_COMPLETION_NOT_READY,
+        MV_SCSI_COMPLETION_ABORTED,
+        MV_SCSI_COMPLETION_OVERRUN,
+        MV_SCSI_COMPLETION_UNDERRUN,
+        MV_SCSI_COMPLETION_PARITY_ERROR,
+        MV_SCSI_COMPLETION_DISCONNECT,
+        MV_SCSI_COMPLETION_NO_DEVICE,
+        MV_SCSI_COMPLETION_INVALID_BUS,
+        MV_SCSI_COMPLETION_BUS_RESET,
+        MV_SCSI_COMPLETION_BUSY,
+        MV_SCSI_COMPLETION_UA_RESET,
+        MV_SCSI_COMPLETION_UA_PARAMS_CHANGED
+    }MV_SCSI_COMPLETION_TYPE;
+
+    typedef enum _mvScsiCommandStatus
+    {
+        MV_SCSI_COMMAND_STATUS_COMPLETED,
+        MV_SCSI_COMMAND_STATUS_QUEUED,
+        MV_SCSI_COMMAND_STATUS_FAILED,
+        MV_SCSI_COMMAND_STATUS_QUEUED_BY_IAL
+    }MV_SCSI_COMMAND_STATUS_TYPE;
+
+    struct _mvSataScsiCmdBlock;
+
+    typedef MV_BOOLEAN (* mvScsiCommandCompletionCallBack)(struct mvSataAdapter *,
+                                                           struct _mvSataScsiCmdBlock*);
+
+    struct mvSalAdapterExtension;
+    struct mvIalCommonAdapterExtension;
+
+    typedef struct _mvSataScsiCmdBlock
+    {
+        /*  the Scsi command data block buffer*/
+        IN MV_U8*       ScsiCdb;
+
+        /* the length in bytes of the CDB (6,10,12,16)*/
+        IN MV_U32       ScsiCdbLength;
+
+        /* the scsi bus*/
+        IN MV_U8        bus;
+
+        /* the target device id*/
+        IN MV_U8        target;
+
+        /* scsi lun number of the device*/
+        IN MV_U8        lun;
+
+        /* True when the data located in the buffer pointed by pDataBuffer  */
+        /* (virtual address), false when the command is READ/WRITE, in this */
+        /* case the data located in a PRD table*/
+        /*IN MV_BOOLEAN useSingleBuffer;*/
+
+        /* pointer to the command data buffer*/
+        IN MV_U8        *pDataBuffer;
+
+        /* length in bytes of the command data buffer*/
+        IN MV_U32       dataBufferLength;
+
+        /* number of entries in the PRD table*/
+        /*IN MV_U32     PRDTableEntries; */
+
+        /* low 32 bits of the PRD table physical address*/
+        IN MV_U32       PRDTableLowPhyAddress;
+
+        /* high 32 bits of the PRD table physical address*/
+        IN MV_U32       PRDTableHighPhyAddress;
+
+        /* the Scsi status will be written to this field*/
+        OUT MV_U8       ScsiStatus;
+
+        /* pointer to the Scsi sense buffer*/
+        IN MV_U8*       pSenseBuffer;
+
+        /* length in bytes of the Scsi sense buffer*/
+        IN MV_U32       senseBufferLength;
+
+        /* length in bytes of the generated sense data*/
+        OUT MV_U32      senseDataLength;
+
+        /* length in bytes of the data transferred to the data buffer/s*/
+        OUT MV_U32      dataTransfered;
+
+        /* the translation layer status of the completed Scsi command */
+        OUT MV_SCSI_COMPLETION_TYPE ScsiCommandCompletion;
+        /* call back function called by the translation layer when the Scsi */
+        /* completed    */
+        IN mvScsiCommandCompletionCallBack completionCallBack;
+
+        IN struct mvSalAdapterExtension * pSalAdapterExtension;
+        IN struct mvIALCommonAdapterExtension* pIalAdapterExtension;
+        /* field for IAL usage only*/
+        MV_VOID_PTR     IALData;
+        /* fields for internal usage for the translation layer*/
+
+
+        MV_UDMA_TYPE            udmaType;
+        MV_QUEUED_COMMAND_TYPE  commandType;
+        /* used for sense buffer */
+        MV_U32                  LowLbaAddress;
+        /* Used for non-UDMA and for sense buffer */
+        MV_BOOLEAN              isExtended;
+        MV_U16                  splitCount;
+        MV_U16                  sequenceNumber;
+        /* used to create list for comands that need post interrupt service */
+        struct _mvSataScsiCmdBlock  *pNext;
+#ifdef MV_LOGGER
+        MV_STORAGE_DEVICE_REGISTERS ATAregStruct;
+#endif
+    }MV_SATA_SCSI_CMD_BLOCK;
+
+    typedef struct
+    {
+        MV_U32              totalIOs;
+        MV_U32              totalSectorsTransferred;
+    }MV_SATA_SCSI_CHANNEL_STATS;
+
+    typedef struct
+    {
+        MV_BOOLEAN          driveReady;
+        ATA_IDENTIFY_INFO   identifyInfo;
+        MV_U16_PTR          identifyBuffer;
+        MV_SATA_SCSI_CHANNEL_STATS stats;
+        MV_BOOLEAN          UAConditionPending;
+        MV_U8               UAEvents;
+    }MV_SATA_SCSI_DRIVE_DATA;
+
+    typedef struct mvSalAdapterExtension
+    {
+        MV_SATA_ADAPTER *pSataAdapter;
+        MV_SATA_SCSI_CMD_BLOCK  *pHead;
+        MV_U8                   UAMask;/*which UA condictions to report*/
+        MV_U32  totalAccumulatedOutstanding[MV_SATA_CHANNELS_NUM];
+        MV_SATA_SCSI_DRIVE_DATA     ataDriveData[MV_SATA_CHANNELS_NUM][MV_SATA_PM_MAX_PORTS];
+        MV_U16  identifyBuffer[MV_SATA_CHANNELS_NUM][MV_ATA_IDENTIFY_DEV_DATA_LENGTH];
+
+    }MV_SAL_ADAPTER_EXTENSION;
+
+
+    MV_VOID     mvSataScsiInitAdapterExt(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                                         MV_SATA_ADAPTER* pSataAdapter);
+
+    MV_VOID     mvSataScsiPostIntService(MV_SAL_ADAPTER_EXTENSION *pAdapterExt);
+
+
+    MV_SCSI_COMMAND_STATUS_TYPE mvSataExecuteScsiCommand(MV_SATA_SCSI_CMD_BLOCK *pMvSataScsiCmdBlock);
+
+    MV_VOID     mvSataScsiSetDriveReady(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                                        MV_U8   channelIndex, MV_U8 PMPort,
+                                        MV_BOOLEAN  isReady);
+
+    MV_VOID mvSataScsiNotifyUA(MV_SAL_ADAPTER_EXTENSION *pAdapterExt,
+                               MV_U8    channelIndex, MV_U8 PMPort);
+
+/* Locals */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __IsNCmvScsiAtaLayer */
Index: linux-2.6.10/drivers/scsi/mvsata/mvStorageDev.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvStorageDev.c
@@ -0,0 +1,1828 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvStorageDev.c - C File for implementation of the core driver.
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*   mvOs.h
+*   mvSata.h.
+*   mvStorageDev.h
+*   mvRegs.h
+*
+*******************************************************************************/
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvStorageDev.h"
+#include "mvRegs.h"
+
+/* Defines */
+
+/* functions for internal driver use */
+MV_BOOLEAN waitWhileStorageDevIsBusy(MV_SATA_ADAPTER* pAdapter,
+                                     MV_BUS_ADDR_T ioBaseAddr,
+                                     MV_U32 eDmaRegsOffset, MV_U32 loops,
+                                     MV_U32 delay);
+MV_BOOLEAN waitForDRQToClear(MV_SATA_ADAPTER* pAdapter,
+                             MV_BUS_ADDR_T ioBaseAddr,
+                             MV_U32 eDmaRegsOffset, MV_U32 loops,
+                             MV_U32 delay);
+
+void enableStorageDevInterrupt (MV_SATA_CHANNEL *pSataChannel);
+void disableStorageDevInterrupt(MV_SATA_CHANNEL *pSataChannel);
+static MV_BOOLEAN isStorageDevReadyForPIO(MV_SATA_CHANNEL *pSataChannel);
+void dumpAtaDeviceRegisters(MV_SATA_ADAPTER *pAdapter,
+                            MV_U8 channelIndex, MV_BOOLEAN isEXT,
+                            MV_STORAGE_DEVICE_REGISTERS *pRegisters);
+MV_BOOLEAN _doSoftReset(MV_SATA_CHANNEL *pSataChannel);
+extern void _setActivePMPort(MV_SATA_CHANNEL *pSataChannel, MV_U8 PMPort);
+extern void disableSaDevInterrupts(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex);
+
+MV_BOOLEAN  _PMAccessReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                         MV_U8 PMPort, MV_U8 PMReg, MV_U32 *pValue,
+                         MV_STORAGE_DEVICE_REGISTERS *registerStruct,
+                         MV_BOOLEAN isRead);
+
+MV_BOOLEAN executeNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
+                                 MV_U8 channelIndex,
+                                 MV_U8  PMPort,
+                                 MV_NON_UDMA_PROTOCOL protocolType,
+                                 MV_BOOLEAN  isEXT,
+                                 MV_U16_PTR bufPtr, MV_U32 count,
+                                 MV_U16 features,
+                                 MV_U16 sectorCount,
+                                 MV_U16 lbaLow, MV_U16 lbaMid,
+                                 MV_U16 lbaHigh, MV_U8 device,
+                                 MV_U8 command);
+
+/*******************************************************************************
+* waitWhileStorageDevIsBusy - Wait for the storage device to be released from
+*                             busy state.
+*
+* DESCRIPTION:
+*   The busy bit is set to one to indicate that the storage device is busy. The
+*   busy bit shall be set to one by the device only when one of the following
+*   events occurs:
+*
+*   1) after either the negation of RESET- or the setting of the SRST bit to one
+*      in the Device Control register.
+*   2) after writing the Command register if the DRQ bit is not set to one.
+*   3) between blocks of a data transfer during PIO data-in commands before the
+*      DRQ bit is cleared to zero.
+*   4) after the transfer of a data block during PIO data-out commands before
+*      the DRQ bit is cleared to zero.
+*   5) during the data transfer of DMA commands either the BSY bit, the DRQ bit,
+*      or both shall be set to one.
+*   6) after the command packet is received during the execution of a PACKET
+*      command.
+*
+* INPUT:
+*     ioBaseAddr     - The PCI I/O window base address of the adapter.
+*     eDmaRegsOffset - The EDMA register's offset of the relevant SATA channel.
+*     loops          - max number of times to pool the status register.
+*     delay          - number of u seconds to wait each loop.
+*
+* RETURN:
+*     MV_TRUE if the device is released from busy state, MV_FALSE otherwise.
+* COMMENTS:
+*     None.
+*
+*******************************************************************************/
+MV_BOOLEAN waitWhileStorageDevIsBusy(MV_SATA_ADAPTER* pAdapter,
+                                     MV_BUS_ADDR_T ioBaseAddr,
+                                     MV_U32 eDmaRegsOffset, MV_U32 loops,
+                                     MV_U32 delay)
+{
+    MV_U8   ATAstatus = 0;
+    MV_U32  i;
+
+    for (i = 0;i < loops; i++)
+    {
+        ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+        {
+
+            if ((ATAstatus & MV_ATA_ERROR_STATUS) == 0)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "waitWhileStorageDevIsBusy: %d loops *"
+                         "%d usecs\n", i, delay);
+                return MV_TRUE;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Device ERROR"
+                         " Status: 0x%02x\n", ATAstatus);
+                return MV_FALSE;
+            }
+        }
+        mvMicroSecondsDelay(pAdapter, delay);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Time out - Device ERROR"
+             " Status: 0x%02x. loops %d, delay %d\n", ATAstatus, loops, delay);
+
+    return MV_FALSE;
+}
+
+
+MV_BOOLEAN waitWhileStorageDevIsBusy_88SX60X1(MV_SATA_ADAPTER* pAdapter,
+                                              MV_BUS_ADDR_T ioBaseAddr,
+                                              MV_U32 eDmaRegsOffset,
+                                              MV_U8 channelIndex,
+                                              MV_U32 loops, MV_U32 delay)
+{
+    MV_U8   ATAstatus = 0;
+    MV_U32  i,intReg;
+    MV_U8   sataUnit = channelIndex >> 2, portNum = (channelIndex & 0x3);
+
+
+    for (i = 0;i < loops; i++)
+    {
+        intReg = MV_REG_READ_DWORD (ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                    MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET);
+
+        if (intReg & (1 << (8 + portNum)))
+        {
+            ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                         MV_ATA_DEVICE_STATUS_REG_OFFSET);
+            MV_REG_WRITE_DWORD (ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET,
+                                ~(1 << (8 + portNum)));
+            if ((ATAstatus & MV_ATA_ERROR_STATUS) == 0)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID,MV_DEBUG, "waitWhileStorageDevIsBusy: %d loops *"
+                         "%d usecs\n", i, delay);
+                return MV_TRUE;
+            }
+            else
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID,MV_DEBUG_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Device ERROR"
+                         " Status: 0x%02x\n", ATAstatus);
+                return MV_FALSE;
+            }
+        }
+        mvMicroSecondsDelay(pAdapter, delay);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Time out - Device ERROR"
+             " Status: 0x%02x. loops %d, delay %d\n", ATAstatus, loops, delay);
+    return MV_FALSE;
+}
+
+MV_BOOLEAN waitForDRQ(MV_SATA_ADAPTER* pAdapter,
+                      MV_BUS_ADDR_T ioBaseAddr,
+                      MV_U32 eDmaRegsOffset, MV_U32 loops,
+                      MV_U32 delay)
+{
+    MV_U8   ATAstatus = 0;
+    MV_U32  i;
+
+    for (i = 0;i < loops; i++)
+    {
+        ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+        {
+            if (ATAstatus & MV_ATA_DATA_REQUEST_STATUS)
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "waitWhileStorageDevIsBusy: %d loops *"
+                         "%d usecs\n", i, delay);
+                return MV_TRUE;
+            }
+        }
+        mvMicroSecondsDelay(pAdapter, delay);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Time out - Device ERROR"
+             " Status: 0x%02x. loops %d, delay %d\n", ATAstatus, loops, delay);
+
+    return MV_FALSE;
+}
+/*******************************************************************************
+* enableStorageDevInterrupt - Enable the storage device to be able to issue
+*                       interrupt.
+*
+* DESCRIPTION:
+*   Enable the connected storage device to the given channel to assert INTRQ by
+*   clearing nIEN bit in the Device Control register.
+*
+* INPUT:
+*   pSataChannel - Pointer to the Sata channel data structure.
+*
+* RETURN:
+*   None.
+*
+* COMMENTS:
+*   this function also clears the SRST bit in the Device Control register.
+*
+*******************************************************************************/
+void enableStorageDevInterrupt(MV_SATA_CHANNEL *pSataChannel)
+{
+
+    MV_REG_WRITE_BYTE(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                      pSataChannel->eDmaRegsOffset +
+                      MV_ATA_DEVICE_CONTROL_REG_OFFSET,0);
+    MV_REG_READ_BYTE(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                     pSataChannel->eDmaRegsOffset +
+                     MV_ATA_DEVICE_CONTROL_REG_OFFSET);
+}
+
+/*******************************************************************************
+* disableStorageDevInterrupt - Disable the storage device to be able to issue
+*                              interrupt.
+*
+* DESCRIPTION:
+*   This function disable the connected storage device to the given channel to
+*   assert INTRQ by setting nIEN bit in the Device Control register.
+*
+* INPUT:
+*   pSataChannel - Pointer to the Sata channel data structure.
+*
+* RETURN:
+*   None.
+*
+* COMMENTS:
+*   this function also clears the SRST bit
+*
+*******************************************************************************/
+void disableStorageDevInterrupt(MV_SATA_CHANNEL *pSataChannel)
+{
+
+
+    MV_REG_WRITE_BYTE(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                      pSataChannel->eDmaRegsOffset +
+                      MV_ATA_DEVICE_CONTROL_REG_OFFSET, MV_BIT1);
+    MV_REG_READ_BYTE(pSataChannel->mvSataAdapter->adapterIoBaseAddress,
+                     pSataChannel->eDmaRegsOffset +
+                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+}
+
+/*******************************************************************************
+* isStorageDevReadyForPIO - Check that the storage device connected to the given
+*                           channel and the channel itself are ready to perform
+*                           PIO commands.
+*
+* DESCRIPTION:
+*   Check if the device connected to the given channel and the channel itself
+*   are ready for PIO commands.
+*
+* INPUT:
+*       pSataChannel - Pointer to the SATA channel data structure.
+*
+* RETURN:
+*       MV_TRUE if the channel and the connected device ready to do PIO,
+*       MV_FALSE otherwise.
+*
+* COMMENTS:
+*     If the adapter's eEnEDMA bit in the EDMA Command Register is set, PIO
+*     commands cannot be issued. The eEnEDMA bit cannot be reset by the CPU.
+*     Only the EDMA resets it, when bit eDsEDMA is set or when an error
+*     condition occurs.
+*
+*******************************************************************************/
+static MV_BOOLEAN isStorageDevReadyForPIO(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T ioBaseAddr =pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32  eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    MV_U8   ATAcontrolRegValue;
+
+    /* If the adapter's eEnEDMA bit in the EDMA Command Register is set  */
+    /* PIO commands cannot be issued.                                       */
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: PIO command failed:"
+                 "EDMA is active\n", pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        return MV_FALSE;
+    }
+    /* Check if BUSY bit is '0' */
+
+    /* Reading the Control register actually gives us the Alternate Status  */
+    /* register content (ATA protocol). If the busy bit is set in the       */
+    /* Alternate Status register, we wait for 50 mili-sec and try again, if */
+    /* the busy bit is still set, we return false indicating that the       */
+    /* device is not ready for PIO commands.                                */
+    ATAcontrolRegValue = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                          MV_ATA_DEVICE_CONTROL_REG_OFFSET);
+    if ((ATAcontrolRegValue & MV_ATA_BUSY_STATUS)!= 0)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  control regiser is "
+                 "0x%02x\n",pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber,ATAcontrolRegValue);
+        return MV_FALSE;
+    }
+    if ((ATAcontrolRegValue & MV_ATA_READY_STATUS) !=
+        MV_ATA_READY_STATUS)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  storage drive is not"
+                 " ready, ATA STATUS=0x%02x\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber, ATAcontrolRegValue);
+        return MV_FALSE;
+    }
+    /* The device is ready for PIO commands */
+    return MV_TRUE;
+}
+
+MV_BOOLEAN mvStorageDevATAIdleImmediate(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T ioBaseAddr;
+    MV_U32  eDmaRegsOffset;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATAIdentif"
+                 "yDevice failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {     /* If the pointer do not exists, retrun false */
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data "
+                 "structure is not allocated\n", pAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+
+    ioBaseAddr =pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevATAIdle"
+                 "Immediate command failed: EDMA is active\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "Issue IDLE IMMEDIATE COMMAND\n");
+    disableStorageDevInterrupt(pSataChannel);
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset + MV_ATA_DEVICE_COMMAND_REG_OFFSET,
+                      MV_ATA_COMMAND_IDLE_IMMEDIATE);
+
+    if (waitWhileStorageDevIsBusy(pAdapter,
+                                  ioBaseAddr, eDmaRegsOffset, 10000, 100) == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  Idle Immediate failed\n",
+                 pSataChannel->mvSataAdapter->adapterId, pSataChannel->channelNumber);
+
+        enableStorageDevInterrupt(pSataChannel);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    enableStorageDevInterrupt(pSataChannel);
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvStorageDevATAIdentifyDevice - Perform an ATA IDENTIFY device command.
+*
+* DESCRIPTION:
+*       This function issues an IDENTIFY command to the connected device, and
+*       stores all the information in the identifyDevice buffer of the channel.
+*
+* INPUT:
+*       pAdapter     - Pointer to the device data structure.
+*       channelIndex - The index of the channel where the storage device
+*                      connected to.
+*       PMPort       - index of the required destination port multipliers
+*                      device Port (0 if no PM available).
+*       identifyDeviceResult - a buffer that is allocated by IAL that will hold
+*                              the IDENTIFY DEIVICE command result.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE on failure.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevATAIdentifyDevice(MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex,
+                                         MV_U8 PMPort,
+                                         MV_U16_PTR  identifyDeviceResult
+                                        )
+{
+    MV_BOOLEAN result;
+    /* Get the pointer to the relevant channel. */
+    MV_SATA_CHANNEL *pSataChannel;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATAIdentif"
+                 "yDevice failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {     /* If the pointer do not exists, retrun false */
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data "
+                 "structure is not allocated\n", pAdapter->adapterId,
+                 channelIndex);
+        return MV_FALSE;
+    }
+    if (identifyDeviceResult == NULL)
+    {     /* If the pointer do not exists, retrun false */
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  identify data buffer"
+                 " is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    result = mvStorageDevATAExecuteNonUDMACommand(pAdapter, channelIndex,
+                                                  PMPort,
+                                                  MV_NON_UDMA_PROTOCOL_PIO_DATA_IN,
+                                                  MV_FALSE,
+                                                  /* pBuffer */
+                                                  identifyDeviceResult,
+                                                  256,     /* count       */
+                                                  0,       /* features    */
+                                                  0,       /* sectorCount */
+                                                  0,       /* lbaLow      */
+                                                  0,       /* lbaMid      */
+                                                  0,       /* lbaHigh     */
+                                                  0,       /* device      */
+                                                  /* The command */
+                                                  MV_ATA_COMMAND_IDENTIFY);
+    if (result == MV_FALSE)
+    {
+        return MV_FALSE;
+    }
+    if (identifyDeviceResult[IDEN_ATA_VERSION] & (MV_BIT7 | MV_BIT6 | MV_BIT5))
+    {
+        /* if ATA 5/6/7 then check CRC of Identify command result */
+        MV_U8 crc = 0;
+        MV_U16 count;
+        MV_U8_PTR pointer = (MV_U8_PTR)identifyDeviceResult;
+        /* If no 0xa5 signature valid, then don't check CRC */
+        if (pointer[510] != 0xa5)
+        {
+            return MV_TRUE;
+        }
+        for (count = 0 ; count < ATA_SECTOR_SIZE ; count ++)
+        {
+            crc += pointer[count];
+        }
+        if (crc != 0)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  IDENTIFY DEVICE "
+                     "ATA Command failed due to wrong CRC checksum (%02x)\n",
+                     pAdapter->adapterId, channelIndex,crc);
+            return MV_FALSE;
+        }
+
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvStorageDevATASoftResetDevice - Issue SATA SOFTWARE reset to device.
+*
+* DESCRIPTION:
+*       Perform SOFTWARE RESET to the connected storage device by setting the
+*       SRST bit of the ATA device COMMAND
+*
+* INPUT:
+*       pAdapter     - Pointer to the device data structure.
+*       channelIndex - Index of the required channel.
+*       PMPort       - index of the required destination port multipliers
+*                      device port (0 if no PM available).
+*       registerStruct - Pointer to ATA registers data structure
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+*
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevATASoftResetDevice(MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex,
+                                          MV_U8 PMPort,
+                                          MV_STORAGE_DEVICE_REGISTERS *registerStruct
+                                         )
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_U32          eDmaRegsOffset;
+    MV_BOOLEAN      result;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATASoftRes"
+                 "etDevice Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevATASoft"
+                 "ResetDevice command failed: EDMA is active\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    _setActivePMPort(pSataChannel, PMPort);
+    result = _doSoftReset(pSataChannel);
+    if (registerStruct)
+    {
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, MV_FALSE,
+                               registerStruct);
+    }
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return result;
+}
+
+
+
+void _startSoftResetDevice(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T   ioBaseAddr =
+    pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_NON_UDMA_COMMAND | MV_DEBUG, "Issue SRST COMMAND\n");
+
+/* Write to the Device Control register, bits 1,2:                      */
+/* - bit 1 (nIEN): is the enable bit for the device assertion of INTRQ  */
+/*   to the host. When the nIEN bit is set to one, or the device is not */
+/*   selected, the device shall release the INTRQ signal.               */
+/* - bit 2 (SRST): is the host software reset bit.                      */
+    MV_REG_WRITE_BYTE(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                      MV_ATA_DEVICE_CONTROL_REG_OFFSET, MV_BIT2|MV_BIT1);
+    MV_REG_READ_BYTE(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                     MV_ATA_DEVICE_CONTROL_REG_OFFSET);
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 10);
+    /* enableStorageDevInterrupt will clear the SRST bit*/
+    enableStorageDevInterrupt(pSataChannel);
+}
+
+MV_BOOLEAN _isDeviceBsyBitOff(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T   ioBaseAddr =
+    pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U8           ATAstatus;
+    MV_U32          eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+    {
+        return MV_TRUE;
+    }
+    else
+    {
+#ifdef MV_LOGGER
+        if (pSataChannel->mvSataAdapter->sataAdapterGeneration
+            == MV_SATA_GEN_II)
+        {
+            MV_U32 ifStatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                               MV_SATA_II_IF_STATUS_REG_OFFSET);
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG,
+                     "[%d %d] SATA interface status register = 0x%X\n",
+                     pSataChannel->mvSataAdapter->adapterId,
+                     pSataChannel->channelNumber,
+                     ifStatus);
+        }
+#endif
+        return MV_FALSE;
+    }
+}
+
+
+/*******************************************************************************
+* mvStorageDevATAStartSoftResetDevice -
+*                   begins device software reset
+*
+* DESCRIPTION:
+*
+*   Submits SRST for channel connected device and exit. The IAL must call the
+*   mvStorageIsDeviceBsyBitOff later on to check whether the device is
+*   ready
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*       channelIndex - channel number
+*       PMPort      - port multiplier port
+*
+* OUTPUT:
+*       None
+* RETURN:
+*       MV_TRUE on success,
+*       MV_FALSE otherwise.
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevATAStartSoftResetDevice(MV_SATA_ADAPTER *pAdapter,
+                                               MV_U8 channelIndex,
+                                               MV_U8 PMPort
+                                              )
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATASoftRes"
+                 "etDevice Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevATASoft"
+                 "ResetDevice command failed: EDMA is active\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    _setActivePMPort(pSataChannel, PMPort);
+    _startSoftResetDevice(pSataChannel);
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvStorageIsDeviceBsyBitOff -
+*                    check if device is BUSY bit cleared after SRST
+*
+* DESCRIPTION:
+*
+*   Checks the if BSY bit in ATA status is on/off
+*
+* INPUT:
+*       pAdapter    - pointer to the adapter data structure.
+*       channelIndex - channel number
+*       registerStruct - If non-zero then this function dumps ATA registers
+*                        to this data structure before exit.
+*
+* OUTPUT:
+*       None
+* RETURN:
+*       MV_TRUE if BSY bit is off
+*       MV_FALSE if BSY bit is on (or on failure)
+* COMMENTS:
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageIsDeviceBsyBitOff(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_STORAGE_DEVICE_REGISTERS *registerStruct
+                                     )
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BUS_ADDR_T   ioBaseAddr;
+    MV_BOOLEAN      result;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATASoftRes"
+                 "etDevice Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pSataChannel->semaphore);
+    result = _isDeviceBsyBitOff(pSataChannel);
+    if (registerStruct)
+    {
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, MV_FALSE,
+                               registerStruct);
+    }
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return result;
+}
+
+
+/*******************************************************************************
+* mvStorageDevATASetFeatures - Perform ATA SET FEATURES command.
+*
+* DESCRIPTION:
+*       Perform ATA SET FEATURES command to the ATA device connected to the
+*       given channel. This command is used by the host to establish parameters
+*       that affect the execution of certain device features (Table 44 in the
+*       ATA protocol document defines these features).
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       PMPort              - index of the required destination port multipliers
+*                             device Port (0 if no PM available).
+*       subCommand          - Sub command for the SET FEATURES ATA command
+*       subCommandSpecific1 - First parameter to the sub command.
+*       subCommandSpecific2 - Second parameter to the sub command.
+*       subCommandSpecific3 - Third parameter to the sub command.
+*       subCommandSpecific4 - Fourth parameter to the sub command.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevATASetFeatures(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_U8   PMPort,
+                                      MV_U8 subCommand,
+                                      MV_U8 subCommandSpecific1,
+                                      MV_U8 subCommandSpecific2,
+                                      MV_U8 subCommandSpecific3,
+                                      MV_U8 subCommandSpecific4)
+{
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND,
+             "ATA Set Features: %x , %x , %x , %x , %x\n", subCommand,
+             subCommandSpecific1, subCommandSpecific2, subCommandSpecific3,
+             subCommandSpecific4);
+    return mvStorageDevATAExecuteNonUDMACommand(pAdapter, channelIndex,
+                                                PMPort,
+                                                MV_NON_UDMA_PROTOCOL_NON_DATA,
+                                                MV_FALSE,
+                                                NULL,    /* pBuffer*/
+                                                0,       /* count  */
+                                                subCommand,     /*features*/
+                                                /* sectorCount */
+                                                subCommandSpecific1,
+                                                subCommandSpecific2,    /* lbaLow */
+                                                subCommandSpecific3,    /* lbaMid */
+                                                /* lbaHigh */
+                                                subCommandSpecific4,
+                                                0,      /* device */
+                                                /* command */
+                                                MV_ATA_COMMAND_SET_FEATURES);
+}
+
+
+/*******************************************************************************
+* mvStorageDevATAExecuteNonUdmaCommand - perform ATA non udma command.
+*
+* DESCRIPTION:
+*       perform ATA non UDMA command to the ATA device connected to the given
+*       channel
+*
+* INPUT:
+*   pAdapter    - pointer to the device data structure.
+*   channelIndex    - index of the required channel
+*   PMPort          - index of the required destination port multipliers
+*                     device Port (0 if no PM available).
+*   protocolType    - protocol type of the command
+*   isEXT   - true when the given command is the EXTENDED
+*   bufPtr  - pointer to the buffer to write/read to/from
+*   count   - number of words to transfer
+*   features    - the value to be written to the FEATURES register
+*   sectorCount - the value to be written to the SECTOR COUNT register
+*   lbaLow  - the value to be written to the LBA LOW register
+*   lbaMid  - the value to be written to the LBA MID register
+*   lbaHigh - the value to be written to the LBA HIGH register
+*   device  - the value to be written to the DEVICE register
+*   command - the value to be written to the COMMAND register
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       when the command is EXTENDED, then the high 8 bits of the 16 bits values
+*   will be written first, so they should hold the previous value as defined in
+*   the ATA 6 standard
+*
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevATAExecuteNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
+                                                MV_U8 channelIndex,
+                                                MV_U8 PMPort,
+                                                MV_NON_UDMA_PROTOCOL protocolType,
+                                                MV_BOOLEAN  isEXT,
+                                                MV_U16_PTR bufPtr, MV_U32 count,
+                                                MV_U16 features,
+                                                MV_U16 sectorCount,
+                                                MV_U16 lbaLow, MV_U16 lbaMid,
+                                                MV_U16 lbaHigh, MV_U8 device,
+                                                MV_U8 command)
+{
+    MV_BOOLEAN result;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevATAExecute"
+                 "NonUDMACommand Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  mvStorageDevATAExecu"
+                 "teNonUDMACommand Failed, channel data structure not allocated"
+                 "\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pAdapter->sataChannel[channelIndex]->semaphore);
+    result = executeNonUDMACommand(pAdapter, channelIndex, PMPort, protocolType,
+                                   isEXT, bufPtr, count, features, sectorCount,
+                                   lbaLow, lbaMid, lbaHigh, device, command);
+    mvOsSemRelease(&pAdapter->sataChannel[channelIndex]->semaphore);
+    return result;
+}
+
+MV_BOOLEAN executeNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
+                                 MV_U8 channelIndex,
+                                 MV_U8  PMPort,
+                                 MV_NON_UDMA_PROTOCOL protocolType,
+                                 MV_BOOLEAN  isEXT,
+                                 MV_U16_PTR bufPtr, MV_U32 count,
+                                 MV_U16 features,
+                                 MV_U16 sectorCount,
+                                 MV_U16 lbaLow, MV_U16 lbaMid,
+                                 MV_U16 lbaHigh, MV_U8 device,
+                                 MV_U8 command)
+{
+    MV_SATA_CHANNEL *pSataChannel = pAdapter->sataChannel[channelIndex];
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    MV_U32          eDmaRegsOffset;
+    MV_U32          i;
+    MV_U8           ATAstatus;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_NON_UDMA_COMMAND, " %d %d Issue NON "
+             "UDMA command: protocol(%d) %p , %x , %x , %x , %x.%x.%x %x "
+             "command=%x\n", pAdapter->adapterId, channelIndex, protocolType,
+             bufPtr, count, features, sectorCount, lbaLow, lbaMid,
+             lbaHigh, device, command);
+
+    eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+    if ((PMPort) && ((pSataChannel->PMSupported == MV_FALSE) ||
+                     (pSataChannel->deviceType != MV_SATA_DEVICE_TYPE_PM)))
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  executeNonUDMACommand"
+                 " failed PM not supported for this channel\n",
+                 pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    if (command != MV_ATA_COMMAND_PM_READ_REG &&
+        command != MV_ATA_COMMAND_PM_WRITE_REG)
+    {
+        if (isStorageDevReadyForPIO(pSataChannel) == MV_FALSE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                     " %d %d : Error in Issue NON UDMA command:"
+                     " isStorageDevReadyForPIO failed\n",
+                     pAdapter->adapterId, channelIndex);
+
+            return MV_FALSE;
+        }
+    }
+    _setActivePMPort(pSataChannel, PMPort);
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  PIO command failed:"
+                 "EDMA is active\n", pSataChannel->mvSataAdapter->adapterId,
+                 pSataChannel->channelNumber);
+        return MV_FALSE;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        disableStorageDevInterrupt(pSataChannel);
+    }
+
+    if (isEXT == MV_TRUE)
+    {
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_FEATURES_REG_OFFSET,
+                          (features & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET,
+                          (sectorCount & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_LOW_REG_OFFSET,
+                          (lbaLow & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_MID_REG_OFFSET,
+                          (lbaMid & 0xff00) >> 8);
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET,
+                          (lbaHigh & 0xff00) >> 8);
+    }
+    else
+    {
+        if ((features & 0xff00) || (sectorCount & 0xff00) || (lbaLow & 0xff00) ||
+            (lbaMid & 0xff00) || (lbaHigh & 0xff00))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                     " %d %d : Error in Issue NON UDMA command:"
+                     " bits[15:8] of register values should be reserved"
+                     " Features 0x%02x, SectorCount 0x%02x, LBA Low 0x%02x,"
+                     " LBA Mid 0x%02x, LBA High 0x%02x\n",
+                     pAdapter->adapterId, channelIndex, features,
+                     sectorCount, lbaLow, lbaMid, lbaHigh);
+            enableStorageDevInterrupt(pSataChannel);
+            return MV_FALSE;
+        }
+    }
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_FEATURES_REG_OFFSET, features & 0xff);
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET, sectorCount & 0xff);
+
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_LOW_REG_OFFSET, lbaLow & 0xff);
+
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_MID_REG_OFFSET, lbaMid & 0xff);
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET, lbaHigh & 0xff);
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_HEAD_REG_OFFSET, device);
+    MV_CPU_WRITE_BUFFER_FLUSH();
+
+    /* 88SX60X1 FEr SATA #16 */
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+        enableStorageDevInterrupt(pSataChannel);
+    }
+
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_COMMAND_REG_OFFSET, command);
+
+    if (protocolType == MV_NON_UDMA_PROTOCOL_NON_DATA)
+    {
+        /* Wait for the command to complete */
+        if (waitWhileStorageDevIsBusy(pAdapter, ioBaseAddr, eDmaRegsOffset, 3100, 10000) ==
+            MV_FALSE)
+        {
+            enableStorageDevInterrupt(pSataChannel);
+            return MV_FALSE;
+        }
+        enableStorageDevInterrupt(pSataChannel);
+        pSataChannel->recoveredErrorsCounter = 0;
+        return MV_TRUE;
+    }
+    /* Wait for the command to complete */
+    if (waitWhileStorageDevIsBusy(pAdapter, ioBaseAddr, eDmaRegsOffset, 3100, 10000) ==
+        MV_FALSE)
+    {
+        enableStorageDevInterrupt(pSataChannel);
+        return MV_FALSE;
+    }
+    /* Check the status register on DATA request commands */
+    ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+    {
+        if (!(ATAstatus & MV_ATA_DATA_REQUEST_STATUS))
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: DRQ bit in ATA STATUS"
+                     " register is not set\n", pAdapter->adapterId, channelIndex);
+            enableStorageDevInterrupt(pSataChannel);
+            return MV_FALSE;
+        }
+    }
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+
+        if (waitForDRQ(pAdapter, ioBaseAddr, eDmaRegsOffset, 500, 10000)
+            == MV_FALSE)
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d: DRQ bit in ATA STATUS"
+                     " register is not set\n", pAdapter->adapterId, channelIndex);
+            enableStorageDevInterrupt(pSataChannel);
+            return MV_FALSE;
+        }
+    }
+    for (i = 0; i < count; i++)
+    {
+        /* Every DRQ data block we have to check the BUSY bit to verify that
+           the Disk is ready for next block transfer  */
+        if ((i & (((MV_U32)pSataChannel->DRQDataBlockSize * ATA_SECTOR_SIZE_IN_WORDS) - 1)) == 0)
+        {
+            if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+            {
+                /* Perform a dummy read */
+                MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                 MV_ATA_DEVICE_STATUS_REG_OFFSET);
+                /* 88SX60X1 FEr SATA #16 */
+                if (i != 0)
+                {
+                    if (waitWhileStorageDevIsBusy_88SX60X1(pAdapter,
+                                                           ioBaseAddr, eDmaRegsOffset, channelIndex,
+                                                           50000, 100) == MV_FALSE)
+                    {
+                        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                                 "Sata device interrupt timeout...i = %d\n",i);
+                        enableStorageDevInterrupt(pSataChannel);
+                        return MV_FALSE;
+                    }
+                }
+                else
+                {
+                    MV_U8 sataUnit = channelIndex >> 2,portNum = channelIndex & 3;
+
+                    if (waitWhileStorageDevIsBusy(pAdapter,ioBaseAddr,
+                                                  eDmaRegsOffset, 50000, 100) == MV_FALSE)
+                    {
+                        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                                 "Busy bit timeout...i = %d\n",i);
+                        enableStorageDevInterrupt(pSataChannel);
+                        return MV_FALSE;
+                    }
+                    MV_REG_WRITE_DWORD (ioBaseAddr, MV_SATAHC_REGS_BASE_OFFSET(sataUnit) +
+                                        MV_SATAHC_INTERRUPT_CAUSE_REG_OFFSET,
+                                        ~(1 << (8 + portNum)));
+                }
+                if (waitForDRQ(pAdapter, ioBaseAddr, eDmaRegsOffset, 50000, 100)
+                    == MV_FALSE)
+                {
+                    enableStorageDevInterrupt(pSataChannel);
+                    return MV_FALSE;
+                }
+            }
+            else if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_I)
+            {
+                if (waitWhileStorageDevIsBusy(pAdapter,
+                                              ioBaseAddr, eDmaRegsOffset,
+                                              50000, 100) == MV_FALSE)
+                {
+                    enableStorageDevInterrupt(pSataChannel);
+                    return MV_FALSE;
+                }
+            }
+        }
+        if (protocolType == MV_NON_UDMA_PROTOCOL_PIO_DATA_IN)
+        {
+            bufPtr[i] = MV_REG_READ_WORD(ioBaseAddr, eDmaRegsOffset +
+                                         MV_ATA_DEVICE_PIO_DATA_REG_OFFSET);
+        }
+        else
+        {
+            MV_REG_WRITE_WORD(ioBaseAddr, eDmaRegsOffset +
+                              MV_ATA_DEVICE_PIO_DATA_REG_OFFSET, bufPtr[i]);
+            MV_CPU_WRITE_BUFFER_FLUSH();
+        }
+    }
+
+
+    /* Wait for the storage device to be available */
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: on non-UDMA sequence - checking if"
+             " device is has finished the command\n",
+             pAdapter->adapterId, channelIndex);
+
+    if (waitWhileStorageDevIsBusy(pAdapter,
+                                  ioBaseAddr, eDmaRegsOffset, 50000, 100) ==
+        MV_FALSE)
+    {
+        enableStorageDevInterrupt(pSataChannel);
+        return MV_FALSE;
+    }
+
+    if (pAdapter->sataAdapterGeneration == MV_SATA_GEN_II)
+    {
+
+        if (waitForDRQToClear(pAdapter, ioBaseAddr, eDmaRegsOffset, 50000, 100)
+            == MV_FALSE)
+        {
+            enableStorageDevInterrupt(pSataChannel);
+            return MV_FALSE;
+        }
+    }
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, " %d %d: Finish NonUdma Command. Status=0x%02x"
+             "\n", pAdapter->adapterId, channelIndex,
+             MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                              MV_ATA_DEVICE_STATUS_REG_OFFSET));
+    enableStorageDevInterrupt(pSataChannel);
+    pSataChannel->recoveredErrorsCounter = 0;
+    return MV_TRUE;
+}
+MV_BOOLEAN  _PMAccessReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                         MV_U8 PMPort, MV_U8 PMReg, MV_U32 *pValue,
+                         MV_STORAGE_DEVICE_REGISTERS *registerStruct,
+                         MV_BOOLEAN isRead)
+{
+    MV_BOOLEAN result;
+
+    if (isRead == MV_TRUE)
+    {
+        result = executeNonUDMACommand(pAdapter, channelIndex,
+                                       MV_SATA_PM_CONTROL_PORT,
+                                       MV_NON_UDMA_PROTOCOL_NON_DATA,
+                                       MV_FALSE/*isEXT*/,
+                                       NULL/*bufPtr*/,
+                                       0/*count*/,
+                                       PMReg /*features*/, 0/*sectorCount*/,
+                                       0 /*lbaLow*/, 0 /*lbaMid*/, 0 /*lbaHigh*/,
+                                       PMPort/*device*/,
+                                       MV_ATA_COMMAND_PM_READ_REG/*command*/);
+        if (result == MV_TRUE)
+        {
+            MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+            MV_U32 eDmaRegsOffset = pAdapter->sataChannel[channelIndex]->eDmaRegsOffset;
+
+            *pValue = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                       MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET);
+            *pValue |= MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                        MV_ATA_DEVICE_LBA_LOW_REG_OFFSET) << 8;
+            *pValue |= MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                        MV_ATA_DEVICE_LBA_MID_REG_OFFSET) << 16;
+            *pValue |= MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                        MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET) << 24;
+        }
+    }
+    else
+    {
+        result = executeNonUDMACommand(pAdapter, channelIndex,
+                                       MV_SATA_PM_CONTROL_PORT,
+                                       MV_NON_UDMA_PROTOCOL_NON_DATA,
+                                       MV_FALSE/*isEXT*/,
+                                       NULL/*bufPtr*/,
+                                       0/*count*/,
+                                       PMReg /*features*/,
+                                       (MV_U16)((*pValue) & 0xff)/*sectorCount*/,
+                                       (MV_U16)(((*pValue) & 0xff00) >> 8) /*lbaLow*/,
+                                       (MV_U16)(((*pValue) & 0xff0000) >> 16)   /*lbaMid*/,
+                                       (MV_U16)(((*pValue) & 0xff000000) >> 24) /*lbaHigh*/,
+                                       PMPort/*device*/,
+                                       MV_ATA_COMMAND_PM_WRITE_REG/*command*/);
+    }
+    if (registerStruct)
+    {
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, MV_FALSE,
+                               registerStruct);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG|MV_DEBUG_PM, " %d %d: %s PM Reg %s: PM Port %x"
+             ", PM Reg %d, value %x\n", pAdapter->adapterId, channelIndex,
+             (isRead == MV_TRUE) ? "Read" : "Write",
+             (result == MV_TRUE) ? "Succeeded" : "Failed",
+             PMPort, PMReg, *pValue);
+
+    return result;
+}
+
+MV_BOOLEAN waitForDRQToClear(MV_SATA_ADAPTER* pAdapter,
+                             MV_BUS_ADDR_T ioBaseAddr,
+                             MV_U32 eDmaRegsOffset, MV_U32 loops,
+                             MV_U32 delay)
+{
+    MV_U8   ATAstatus = 0;
+    MV_U32  i;
+
+    for (i = 0;i < loops; i++)
+    {
+        ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+        {
+            if (!(ATAstatus & MV_ATA_DATA_REQUEST_STATUS))
+            {
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG, "waitWhileStorageDevIsBusy: %d loops *"
+                         "%d usecs\n", i, delay);
+                return MV_TRUE;
+            }
+        }
+        mvMicroSecondsDelay(pAdapter, delay);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "waitWhileStorageDevIsBusy<FAILED>: Time out - Device ERROR"
+             " Status: 0x%02x. loops %d, delay %d\n", ATAstatus, loops, delay);
+
+    return MV_FALSE;
+}
+
+void dumpAtaDeviceRegisters(MV_SATA_ADAPTER *pAdapter,
+                            MV_U8 channelIndex, MV_BOOLEAN isEXT,
+                            MV_STORAGE_DEVICE_REGISTERS *pRegisters)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pAdapter->adapterIoBaseAddress;
+    MV_U32 eDmaRegsOffset = pAdapter->sataChannel[channelIndex]->eDmaRegsOffset;
+
+    if (MV_REG_READ_DWORD(ioBaseAddr, eDmaRegsOffset +
+                          MV_EDMA_COMMAND_REG_OFFSET) & MV_BIT0)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR,
+                 " %d %d: dumpAtaDeviceRegisters: Edma is active!!!\n",
+                 pAdapter->adapterId, channelIndex);
+        return;
+    }
+    MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                      MV_ATA_DEVICE_CONTROL_REG_OFFSET, 0);
+
+    pRegisters->errorRegister =
+    MV_REG_READ_BYTE(ioBaseAddr,
+                     eDmaRegsOffset + MV_ATA_DEVICE_ERROR_REG_OFFSET);
+
+    pRegisters->sectorCountRegister =
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET) & 0x00ff;
+    pRegisters->lbaLowRegister =
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_LBA_LOW_REG_OFFSET) & 0x00ff;
+
+    pRegisters->lbaMidRegister =
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_LBA_MID_REG_OFFSET) & 0x00ff;
+
+    pRegisters->lbaHighRegister =
+    MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                     MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET) & 0x00ff;
+
+    if (isEXT == MV_TRUE)
+    {
+        /*set the HOB bit of DEVICE CONTROL REGISTER */
+
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_CONTROL_REG_OFFSET, MV_BIT7);
+
+        pRegisters->sectorCountRegister |= (MV_REG_READ_BYTE(ioBaseAddr,
+                                                             eDmaRegsOffset +
+                                                             MV_ATA_DEVICE_SECTOR_COUNT_REG_OFFSET) << 8) & 0xff00;
+
+        pRegisters->lbaLowRegister |= (MV_REG_READ_BYTE(ioBaseAddr,
+                                                        eDmaRegsOffset + MV_ATA_DEVICE_LBA_LOW_REG_OFFSET) << 8)
+                                      & 0xff00;
+
+        pRegisters->lbaMidRegister |= (MV_REG_READ_BYTE(ioBaseAddr,
+                                                        eDmaRegsOffset + MV_ATA_DEVICE_LBA_MID_REG_OFFSET) << 8)
+                                      & 0xff00;
+
+        pRegisters->lbaHighRegister |= (MV_REG_READ_BYTE(ioBaseAddr,
+                                                         eDmaRegsOffset + MV_ATA_DEVICE_LBA_HIGH_REG_OFFSET) << 8)
+                                       & 0xff00;
+        MV_REG_WRITE_BYTE(ioBaseAddr, eDmaRegsOffset +
+                          MV_ATA_DEVICE_CONTROL_REG_OFFSET, 0);
+
+    }
+
+    pRegisters->deviceRegister = MV_REG_READ_BYTE(ioBaseAddr,
+                                                  eDmaRegsOffset + MV_ATA_DEVICE_HEAD_REG_OFFSET);
+
+    pRegisters->statusRegister = MV_REG_READ_BYTE(ioBaseAddr,
+                                                  eDmaRegsOffset + MV_ATA_DEVICE_STATUS_REG_OFFSET);
+
+
+}
+
+
+MV_BOOLEAN _doSoftReset(MV_SATA_CHANNEL *pSataChannel)
+{
+    MV_BUS_ADDR_T   ioBaseAddr = pSataChannel->mvSataAdapter->adapterIoBaseAddress;
+    MV_U32          i;
+    MV_U8           ATAstatus;
+    MV_U32          eDmaRegsOffset = pSataChannel->eDmaRegsOffset;
+
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_NON_UDMA_COMMAND | MV_DEBUG, "Issue SRST COMMAND\n");
+
+/* Write to the Device Control register, bits 1,2:                      */
+/* - bit 1 (nIEN): is the enable bit for the device assertion of INTRQ  */
+/*   to the host. When the nIEN bit is set to one, or the device is not */
+/*   selected, the device shall release the INTRQ signal.               */
+/* - bit 2 (SRST): is the host software reset bit.                      */
+    MV_REG_WRITE_BYTE(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                      MV_ATA_DEVICE_CONTROL_REG_OFFSET, MV_BIT2|MV_BIT1);
+    MV_REG_READ_BYTE(ioBaseAddr, pSataChannel->eDmaRegsOffset +
+                     MV_ATA_DEVICE_CONTROL_REG_OFFSET);
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 10);
+
+/* enableStorageDevInterrupt will clear the SRST bit*/
+    enableStorageDevInterrupt(pSataChannel);
+
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 500);
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 500);
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 500);
+    mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 500);
+
+    for (i = 0;i < 31000; i++)
+    {
+        ATAstatus = MV_REG_READ_BYTE(ioBaseAddr, eDmaRegsOffset +
+                                     MV_ATA_DEVICE_STATUS_REG_OFFSET);
+        if ((ATAstatus & MV_ATA_BUSY_STATUS) == 0)
+        {
+            return MV_TRUE;
+        }
+        mvMicroSecondsDelay(pSataChannel->mvSataAdapter, 1000);
+    }
+    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d: Software reset failed "
+             "Status=0x%02x\n", pSataChannel->mvSataAdapter->adapterId,
+             pSataChannel->channelNumber, ATAstatus);
+
+    return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvPMDevReadReg - Reads port multiplier's internal register
+*
+*
+* DESCRIPTION:
+*       Performs PIO non-data command for reading port multiplier's internal
+*       register.
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       PMPort              - This should be port 0xf
+*       PMReg               - The required register to be read
+*       pValue              - A pointer to 32bit data container that holds
+*                             the result.
+*       registerStruct      - A pointer to ATA register data structure. This
+*                             holds the ATA registers dump after command
+*                             is executed.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN  mvPMDevReadReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                           MV_U8 PMPort, MV_U8 PMReg, MV_U32 *pValue,
+                           MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BOOLEAN      result;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevPMReadReg"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->PMSupported == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevPMReadReg"
+                 " failed PM not supported for this channel\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevPMReadReg"
+                 " command failed: EDMA is active\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    result = _PMAccessReg(pAdapter, channelIndex, PMPort, PMReg, pValue,
+                          registerStruct, MV_TRUE);
+
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return result;
+}
+
+
+
+/*******************************************************************************
+* mvPMDevWriteReg - Writes to port multiplier's internal register
+*
+*
+* DESCRIPTION:
+*       Performs PIO non-data command for writing to port multiplier's internal
+*       register.
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       PMPort              - This should be port 0xf
+*       PMReg               - The required register to be read
+*       value               - Holds 32bit of the value to be written
+*       registerStruct      - A pointer to ATA register data structure. This
+*                             holds the ATA registers dump after command
+*                             is executed.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN  mvPMDevWriteReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                            MV_U8 PMPort, MV_U8 PMReg, MV_U32 value,
+                            MV_STORAGE_DEVICE_REGISTERS *registerStruct)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+    MV_BOOLEAN      result;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvStorageDevPMWriteReg"
+                 " Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    mvOsSemTake(&pSataChannel->semaphore);
+    if (pSataChannel->PMSupported == MV_FALSE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevPMWriteReg"
+                 " failed PM not supported for this channel\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+    if (pSataChannel->queueCommandsEnabled == MV_TRUE)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, " %d %d:  mvStorageDevPMWriteReg"
+                 " command failed: EDMA is active\n",
+                 pAdapter->adapterId, channelIndex);
+        mvOsSemRelease( &pSataChannel->semaphore);
+        return MV_FALSE;
+    }
+
+    result = _PMAccessReg(pAdapter, channelIndex, PMPort, PMReg, &value,
+                          registerStruct, MV_FALSE);
+
+    mvOsSemRelease( &pSataChannel->semaphore);
+    return result;
+}
+
+static MV_BOOLEAN _checkPMPortSStatus(MV_SATA_ADAPTER* pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_U8 PMPort,
+                                      MV_BOOLEAN *error)
+{
+    MV_BOOLEAN result;
+    MV_U32 SStatus;
+
+    result = mvPMDevReadReg(pAdapter, channelIndex, PMPort,
+                            MV_SATA_PSCR_SSTATUS_REG_NUM, &SStatus, NULL);
+
+    if (result == MV_FALSE)
+    {
+        *error = MV_TRUE;
+        return result;
+    }
+    *error = MV_FALSE;
+    SStatus &= (MV_BIT0 | MV_BIT1);
+    if ((SStatus == (MV_BIT0 | MV_BIT1)) || (SStatus == 0))
+    {
+        return MV_TRUE;
+    }
+    else
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR, "[%d %d]"
+                 "PM staggered spin-up - "
+                 "SATA communication not established.\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+}
+
+
+/*******************************************************************************
+* mvPMDevEnableStaggeredSpinUp -
+*
+*
+* DESCRIPTION:
+*       Enables commnucation on a port multiplier's device SATA channel
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       PMPort              - Required device SATA channel on port multiplier
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN  mvPMDevEnableStaggeredSpinUp(MV_SATA_ADAPTER *pAdapter,
+                                         MV_U8 channelIndex, MV_U8 PMPort)
+{
+    MV_BOOLEAN  result;
+    result = mvPMDevWriteReg(pAdapter, channelIndex, PMPort,
+                             MV_SATA_PSCR_SCONTROL_REG_NUM, 0x301, NULL);
+    if (result == MV_FALSE)
+    {
+        return result;
+    }
+    mvMicroSecondsDelay(pAdapter, MV_SATA_COMM_INIT_DELAY);
+    result = mvPMDevWriteReg(pAdapter, channelIndex, PMPort,
+                             MV_SATA_PSCR_SCONTROL_REG_NUM, 0x300, NULL);
+    return result;
+}
+
+
+/*******************************************************************************
+* mvPMDevEnableStaggeredSpinUpAll -
+*
+*
+* DESCRIPTION:
+*       Enables commnucation on all port multiplier's device SATA channels
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       PMNumOfPorts        - Number of device SATA channel the port multiplier
+*                             has.
+*       bitmask             - A pointer to 16bit data container that holds
+*                             a bitmask of '1' when the relevant port multiplier's
+*                             device port staggered spinup operation is success.
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+
+MV_BOOLEAN mvPMDevEnableStaggeredSpinUpAll(MV_SATA_ADAPTER *pSataAdapter,
+                                           MV_U8 channelIndex,
+                                           MV_U8 PMNumOfPorts,
+                                           MV_U16 *bitmask)
+{
+    MV_U8 PMPort;
+    MV_U8 retryCount;
+    MV_U8 tmpBitmask = 1;
+    if (bitmask == NULL)
+    {
+        return MV_FALSE;
+    }
+    /*Do not issue staggered spinup for port 0 - already done because of
+    legacy port mode*/
+    *bitmask = 1;
+    for (PMPort = 1; PMPort < PMNumOfPorts; PMPort++)
+    {
+
+        if (mvPMDevEnableStaggeredSpinUp(pSataAdapter,
+                                         channelIndex,
+                                         PMPort) == MV_TRUE)
+        {
+            tmpBitmask |= (1 << PMPort);
+        }
+        else
+        {
+            mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                     "Error [%d %d %d]: "
+                     "PM enable staggered spin-up failed.\n",
+                     pSataAdapter->adapterId, channelIndex, PMPort);
+            return MV_FALSE;
+        }
+    }
+    mvMicroSecondsDelay(pSataAdapter, MV_SATA_COMM_INIT_WAIT_DELAY);
+    for (retryCount = 0; retryCount < 200; retryCount++)
+    {
+        for (PMPort = 0; PMPort < PMNumOfPorts; PMPort++)
+        {
+            MV_BOOLEAN error;
+            if ((*bitmask) & (1 << PMPort))
+            {
+                continue;
+            }
+            if (_checkPMPortSStatus(pSataAdapter,
+                                    channelIndex, PMPort, &error) == MV_FALSE)
+            {
+                if (error == MV_TRUE)
+                {
+                    mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                             "[%d %d %d]: "
+                             "Fatal error - cannot read PM port SStatus.\n",
+                             pSataAdapter->adapterId, channelIndex, PMPort);
+                    break;
+                }
+                mvMicroSecondsDelay(pSataAdapter, 1000);
+            }
+            else
+            {
+                if (bitmask != NULL)
+                {
+                    *bitmask |= (1 << PMPort);
+                }
+                mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG,
+                         "[%d %d %d] PM SATA PHY ready after %d msec\n",
+                         pSataAdapter->adapterId, channelIndex,
+                         PMPort, retryCount);
+            }
+        }
+        if (tmpBitmask == *bitmask)
+        {
+            break;
+        }
+    }
+    if (tmpBitmask != *bitmask)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_ERROR,
+                 "[%d %d]: "
+                 "Some of PM ports PHY are not initialized.\n",
+                 pSataAdapter->adapterId, channelIndex, PMPort);
+
+    }
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvStorageDevExecutePIO -
+*
+*
+* DESCRIPTION:
+*       Sends custom PIO command (polling driven)
+*
+* INPUT:
+*   pAdapter    - pointer to the device data structure.
+*   channelIndex    - index of the required channel
+*   PMPort          - index of the required destination port multipliers
+*                     device Port (0 if no PM available).
+*   protocolType    - protocol type of the command
+*   isEXT   - true when the given command is the EXTENDED
+*   bufPtr  - pointer to the buffer to write/read to/from
+*   pInATARegs  - Holds ATA registers for the command
+*   pOutATARegs - Holds ATA registers after the command completed
+*
+* RETURN:
+*   MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       when the command is EXTENDED, then the high 8 bits of the 16 bits values
+*   will be written first, so they should hold the previous value as defined in
+*   the ATA 6 standard
+*******************************************************************************/
+MV_BOOLEAN mvStorageDevExecutePIO(MV_SATA_ADAPTER *pAdapter,
+                                  MV_U8 channelIndex,
+                                  MV_U8 PMPort,
+                                  MV_NON_UDMA_PROTOCOL protocolType,
+                                  MV_BOOLEAN  isEXT, MV_U16_PTR bufPtr,
+                                  MV_U32 count,
+                                  MV_STORAGE_DEVICE_REGISTERS *pInATARegs,
+                                  MV_STORAGE_DEVICE_REGISTERS *pOutATARegs)
+{
+    MV_BOOLEAN result;
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  mvPMDevExecutePIO"
+                 "Command Failed, Bad adapter data structure pointer\n");
+        return MV_FALSE;
+    }
+    if (pAdapter->sataChannel[channelIndex] == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  mvPMDevExecutePIO"
+                 "Command Failed, channel data structure not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+    mvOsSemTake(&pAdapter->sataChannel[channelIndex]->semaphore);
+    result = executeNonUDMACommand(pAdapter, channelIndex, PMPort,
+                                   protocolType, isEXT,
+                                   bufPtr, count, pInATARegs->featuresRegister,
+                                   pInATARegs->sectorCountRegister,
+                                   pInATARegs->lbaLowRegister,
+                                   pInATARegs->lbaMidRegister,
+                                   pInATARegs->lbaHighRegister,
+                                   pInATARegs->deviceRegister,
+                                   pInATARegs->commandRegister);
+    if (pOutATARegs)
+    {
+        dumpAtaDeviceRegisters(pAdapter, channelIndex, isEXT, pOutATARegs);
+    }
+    mvOsSemRelease(&pAdapter->sataChannel[channelIndex]->semaphore);
+    return result;
+}
+
+/*******************************************************************************
+* mvStorageDevSetDeviceType -
+*
+*
+* DESCRIPTION:
+*       Sets the device type connected directly to the specific adapter's
+*       SATA channel.
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*       deviceType          - Type of device
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_BOOLEAN  mvStorageDevSetDeviceType(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                                      MV_SATA_DEVICE_TYPE deviceType)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  "
+                 " mvStorageDevSetDeviceType Failed, Bad adapter data structure "
+                 "pointer\n");
+        return MV_SATA_DEVICE_TYPE_UNKNOWN;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  channel data structu"
+                 "re is not allocated\n", pAdapter->adapterId, channelIndex);
+        return MV_FALSE;
+    }
+
+    pSataChannel->deviceType = deviceType;
+
+    return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvStorageDevGetDeviceType -
+*
+*
+* DESCRIPTION:
+*       Gets the device type connected directly to the specific adapter's
+*       SATA channel.
+*
+* INPUT:
+*       pAdapter            - Pointer to the device data structure.
+*       channelIndex        - Index of the required channel
+*
+* RETURN:
+*       MV_TRUE on success, MV_FALSE otherwise.
+* COMMENTS:
+*       NONE
+*
+*******************************************************************************/
+MV_SATA_DEVICE_TYPE mvStorageDevGetDeviceType(MV_SATA_ADAPTER *pAdapter,
+                                              MV_U8 channelIndex)
+{
+    MV_SATA_CHANNEL *pSataChannel;
+
+    if (pAdapter == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, "    :  "
+                 " mvStorageDevGetDeviceType Failed, Bad adapter data structure "
+                 "pointer\n");
+        return MV_SATA_DEVICE_TYPE_UNKNOWN;
+    }
+    pSataChannel = pAdapter->sataChannel[channelIndex];
+    if (pSataChannel == NULL)
+    {
+        mvLogMsg(MV_CORE_DRIVER_LOG_ID, MV_DEBUG_FATAL_ERROR, " %d %d:  "
+                 "channel data structure is not allocated\n",
+                 pAdapter->adapterId, channelIndex);
+        return MV_SATA_DEVICE_TYPE_UNKNOWN;
+    }
+
+    return pSataChannel->deviceType;
+}
+
Index: linux-2.6.10/drivers/scsi/mvsata/mvStorageDev.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/scsi/mvsata/mvStorageDev.h
@@ -0,0 +1,305 @@
+/*******************************************************************************
+*
+*   Marvell Serial ATA Linux Driver
+*   Copyright 2004
+*   Marvell International Ltd.
+*
+* This software program (the "Program") is distributed by Marvell International
+* ltd. under the terms of the GNU General Public License Version 2, June 1991
+* (the "License").  You may use, redistribute and/or modify this Program in
+* accordance with the terms and conditions of the License, a copy of which is
+* available along with the Program in the license.txt file or by writing to the
+* Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+* MA 02111-1307 or on the worldwide web at http:www.gnu.org/licenses/gpl.txt.
+*
+* THE PROGRAM IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE
+* EXPRESSLY DISCLAIMED.  The License provides additional details about this
+* warranty disclaimer.
+*
+* For more information about the Program or the License as it applies to the
+* Program, please contact Marvell International Ltd. via its affiliate, Marvell
+* Semiconductor, Inc., 700 First Avenue, Sunnyvale, CA 94010
+*
+********************************************************************************
+* mvStorageDev.h - Header File for mvStorageDev.c.
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       mvSata.h.
+*       mvOs.h.
+*       ATA/ATAPI-6 standard
+*
+*******************************************************************************/
+#ifndef __INCmvStorageDevh
+#define __INCmvStorageDevh
+#ifdef __cplusplus
+
+extern "C" {
+#endif /* __cplusplus */
+
+/* Includes */
+#include "mvOs.h"
+#include "mvSata.h"
+#include "mvRegs.h"
+
+/* Definitions */
+
+/* ATA register on the ATA drive*/
+
+#define MV_EDMA_ATA_FEATURES_ADDR               0x11
+#define MV_EDMA_ATA_SECTOR_COUNT_ADDR           0x12
+#define MV_EDMA_ATA_LBA_LOW_ADDR                0x13
+#define MV_EDMA_ATA_LBA_MID_ADDR                0x14
+#define MV_EDMA_ATA_LBA_HIGH_ADDR               0x15
+#define MV_EDMA_ATA_DEVICE_ADDR                 0x16
+#define MV_EDMA_ATA_COMMAND_ADDR                0x17
+
+#define MV_ATA_ERROR_STATUS                     MV_BIT0
+#define MV_ATA_DATA_REQUEST_STATUS              MV_BIT3
+#define MV_ATA_SERVICE_STATUS                   MV_BIT4
+#define MV_ATA_DEVICE_FAULT_STATUS              MV_BIT5
+#define MV_ATA_READY_STATUS                     MV_BIT6
+#define MV_ATA_BUSY_STATUS                      MV_BIT7
+
+
+#define MV_ATA_COMMAND_READ_SECTORS             0x20
+#define MV_ATA_COMMAND_READ_SECTORS_EXT         0x24
+#define MV_ATA_COMMAND_READ_LOG_EXT				0x2F
+#define MV_ATA_COMMAND_READ_VERIFY_SECTORS      0x40
+#define MV_ATA_COMMAND_READ_VERIFY_SECTORS_EXT  0x42
+#define MV_ATA_COMMAND_READ_BUFFER              0xE4
+#define MV_ATA_COMMAND_WRITE_BUFFER             0xE8
+#define MV_ATA_COMMAND_WRITE_SECTORS            0x30
+#define MV_ATA_COMMAND_WRITE_SECTORS_EXT        0x34
+#define MV_ATA_COMMAND_DIAGNOSTIC               0x90
+#define MV_ATA_COMMAND_SMART                    0xb0
+#define MV_ATA_COMMAND_READ_MULTIPLE            0xc4
+#define MV_ATA_COMMAND_WRITE_MULTIPLE           0xc5
+#define MV_ATA_COMMAND_STANDBY_IMMEDIATE        0xe0
+#define MV_ATA_COMMAND_IDLE_IMMEDIATE           0xe1
+#define MV_ATA_COMMAND_STANDBY                  0xe2
+#define MV_ATA_COMMAND_IDLE                     0xe3
+#define MV_ATA_COMMAND_SLEEP                    0xe6
+#define MV_ATA_COMMAND_IDENTIFY                 0xec
+#define MV_ATA_COMMAND_DEVICE_CONFIG            0xb1
+#define MV_ATA_COMMAND_SET_FEATURES             0xef
+#define MV_ATA_COMMAND_WRITE_DMA                0xca
+#define MV_ATA_COMMAND_WRITE_DMA_EXT            0x35
+#define MV_ATA_COMMAND_WRITE_DMA_QUEUED         0xcc
+#define MV_ATA_COMMAND_WRITE_DMA_QUEUED_EXT     0x36
+#define MV_ATA_COMMAND_WRITE_FPDMA_QUEUED_EXT   0x61
+#define MV_ATA_COMMAND_READ_DMA                 0xc8
+#define MV_ATA_COMMAND_READ_DMA_EXT             0x25
+#define MV_ATA_COMMAND_READ_DMA_QUEUED          0xc7
+#define MV_ATA_COMMAND_READ_DMA_QUEUED_EXT      0x26
+#define MV_ATA_COMMAND_READ_FPDMA_QUEUED_EXT    0x60
+#define MV_ATA_COMMAND_FLUSH_CACHE              0xe7
+#define MV_ATA_COMMAND_FLUSH_CACHE_EXT          0xea
+
+#define MV_ATA_COMMAND_PM_READ_REG              0xe4
+#define MV_ATA_COMMAND_PM_WRITE_REG             0xe8
+
+#define MV_SATA_GSCR_ID_REG_NUM                 0
+#define MV_SATA_GSCR_REVISION_REG_NUM           1
+#define MV_SATA_GSCR_INFO_REG_NUM               2
+#define MV_SATA_GSCR_ERROR_REG_NUM              32
+#define MV_SATA_GSCR_ERROR_ENABLE_REG_NUM       33
+#define MV_SATA_GSCR_FEATURES_REG_NUM           64
+#define MV_SATA_GSCR_FEATURES_ENABLE_REG_NUM    96
+
+
+#define MV_SATA_PSCR_SSTATUS_REG_NUM            0
+#define MV_SATA_PSCR_SERROR_REG_NUM             1
+#define MV_SATA_PSCR_SCONTROL_REG_NUM           2
+#define MV_SATA_PSCR_SACTIVE_REG_NUM            3
+
+
+
+#define MV_ATA_SET_FEATURES_DISABLE_8_BIT_PIO   0x01
+#define MV_ATA_SET_FEATURES_ENABLE_WCACHE       0x02  /* Enable write cache */
+#define MV_ATA_SET_FEATURES_TRANSFER            0x03  /* Set transfer mode  */
+#define MV_ATA_TRANSFER_UDMA_0                  0x40
+#define MV_ATA_TRANSFER_UDMA_1                  0x41
+#define MV_ATA_TRANSFER_UDMA_2                  0x42
+#define MV_ATA_TRANSFER_UDMA_3                  0x43
+#define MV_ATA_TRANSFER_UDMA_4                  0x44
+#define MV_ATA_TRANSFER_UDMA_5                  0x45
+#define MV_ATA_TRANSFER_UDMA_6                  0x46
+#define MV_ATA_TRANSFER_UDMA_7                  0x47
+#define MV_ATA_TRANSFER_PIO_SLOW                0x00
+#define MV_ATA_TRANSFER_PIO_0                   0x08
+#define MV_ATA_TRANSFER_PIO_1                   0x09
+#define MV_ATA_TRANSFER_PIO_2                   0x0A
+#define MV_ATA_TRANSFER_PIO_3                   0x0B
+#define MV_ATA_TRANSFER_PIO_4                   0x0C
+
+/* Enable advanced power management */
+#define MV_ATA_SET_FEATURES_ENABLE_APM          0x05
+
+/* Disable media status notification*/
+#define MV_ATA_SET_FEATURES_DISABLE_MSN         0x31
+
+/* Disable read look-ahead          */
+#define MV_ATA_SET_FEATURES_DISABLE_RLA         0x55
+
+/* Enable release interrupt         */
+#define MV_ATA_SET_FEATURES_ENABLE_RI           0x5D
+
+/* Enable SERVICE interrupt         */
+#define MV_ATA_SET_FEATURES_ENABLE_SI           0x5E
+
+/* Disable revert power-on defaults */
+#define MV_ATA_SET_FEATURES_DISABLE_RPOD        0x66
+
+/* Disable write cache              */
+#define MV_ATA_SET_FEATURES_DISABLE_WCACHE      0x82
+
+/* Disable advanced power management*/
+#define MV_ATA_SET_FEATURES_DISABLE_APM         0x85
+
+/* Enable media status notification */
+#define MV_ATA_SET_FEATURES_ENABLE_MSN          0x95
+
+/* Enable read look-ahead           */
+#define MV_ATA_SET_FEATURES_ENABLE_RLA          0xAA
+
+/* Enable revert power-on defaults  */
+#define MV_ATA_SET_FEATURES_ENABLE_RPOD         0xCC
+
+/* Disable release interrupt        */
+#define MV_ATA_SET_FEATURES_DISABLE_RI          0xDD
+
+/* Disable SERVICE interrupt        */
+#define MV_ATA_SET_FEATURES_DISABLE_SI          0xDE
+
+/* Defines for parsing the IDENTIFY command results*/
+#define IDEN_SERIAL_NUM_OFFSET                  10
+#define IDEN_SERIAL_NUM_SIZE                    (20-10)
+#define IDEN_FIRMWARE_OFFSET                    23
+#define IDEN_FIRMWARE_SIZE                      (27-23)
+#define IDEN_MODEL_OFFSET                       27
+#define IDEN_MODEL_SIZE                         (47-27)
+#define IDEN_CAPACITY_1_OFFSET                  49
+#define IDEN_VALID                              53
+#define IDEN_NUM_OF_ADDRESSABLE_SECTORS         60
+#define IDEN_PIO_MODE_SPPORTED                  64
+#define IDEN_QUEUE_DEPTH                        75
+#define IDEN_SATA_CAPABILITIES                  76
+#define IDEN_SATA_FEATURES_SUPPORTED            78
+#define IDEN_SATA_FEATURES_ENABLED              79
+#define IDEN_ATA_VERSION                        80
+#define IDEN_SUPPORTED_COMMANDS1                82
+#define IDEN_SUPPORTED_COMMANDS2                83
+#define IDEN_ENABLED_COMMANDS1                  85
+#define IDEN_ENABLED_COMMANDS2                  86
+#define IDEN_UDMA_MODE                          88
+
+/* Typedefs    */
+
+/* Structures  */
+
+    typedef struct mvStorageDevRegisters
+    {
+/* Fields set by CORE driver */
+        MV_U8    errorRegister;
+        MV_U16   featuresRegister;/*input only*/
+        MV_U8    commandRegister;/*input only*/
+        MV_U16   sectorCountRegister;
+        MV_U16   lbaLowRegister;
+        MV_U16   lbaMidRegister;
+        MV_U16   lbaHighRegister;
+        MV_U8    deviceRegister;
+        MV_U8    statusRegister;
+    } MV_STORAGE_DEVICE_REGISTERS;
+
+/* Function */
+
+    MV_BOOLEAN mvStorageDevATAExecuteNonUDMACommand(MV_SATA_ADAPTER *pAdapter,
+                                                    MV_U8 channelIndex,
+                                                    MV_U8   PMPort,
+                                                    MV_NON_UDMA_PROTOCOL protocolType,
+                                                    MV_BOOLEAN  isEXT,
+                                                    MV_U16_PTR bufPtr, MV_U32 count,
+                                                    MV_U16 features,
+                                                    MV_U16 sectorCount,
+                                                    MV_U16 lbaLow, MV_U16 lbaMid,
+                                                    MV_U16 lbaHigh, MV_U8 device,
+                                                    MV_U8 command);
+
+    MV_BOOLEAN mvStorageDevATAIdentifyDevice(MV_SATA_ADAPTER *pAdapter,
+                                             MV_U8 channelIndex,
+                                             MV_U8 PMPort,
+                                             MV_U16_PTR  identifyDeviceResult
+                                            );
+
+    MV_BOOLEAN mvStorageDevATASetFeatures(MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex,
+                                          MV_U8   PMPort,
+                                          MV_U8 subCommand,
+                                          MV_U8 subCommandSpecific1,
+                                          MV_U8 subCommandSpecific2,
+                                          MV_U8 subCommandSpecific3,
+                                          MV_U8 subCommandSpecific4);
+
+    MV_BOOLEAN mvStorageDevATAIdleImmediate(MV_SATA_ADAPTER *pAdapter,
+                                            MV_U8 channelIndex);
+
+    MV_BOOLEAN mvStorageDevATASoftResetDevice(MV_SATA_ADAPTER *pAdapter,
+                                              MV_U8 channelIndex,
+                                              MV_U8 PMPort,
+                                              MV_STORAGE_DEVICE_REGISTERS *registerStruct
+                                             );
+
+/*PM*/
+
+    MV_BOOLEAN mvPMDevReadReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                              MV_U8 PMPort, MV_U8 PMReg, MV_U32 *pValue,
+                              MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+    MV_BOOLEAN  mvPMDevWriteReg(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                                MV_U8 PMPort, MV_U8 PMReg, MV_U32 value,
+                                MV_STORAGE_DEVICE_REGISTERS *registerStruct);
+
+    MV_BOOLEAN  mvPMDevEnableStaggeredSpinUp(MV_SATA_ADAPTER *pAdapter,
+                                             MV_U8 channelIndex, MV_U8 PMPort);
+
+    MV_BOOLEAN  mvPMDevEnableStaggeredSpinUpAll(MV_SATA_ADAPTER *pAdapter,
+                                                MV_U8 channelIndex,
+                                                MV_U8 PMNumOfPorts,
+                                                MV_U16 *bitmask);
+
+    MV_BOOLEAN mvStorageDevExecutePIO(MV_SATA_ADAPTER *pAdapter,
+                                      MV_U8 channelIndex,
+                                      MV_U8 PMPort,
+                                      MV_NON_UDMA_PROTOCOL protocolType,
+                                      MV_BOOLEAN  isEXT, MV_U16_PTR bufPtr,
+                                      MV_U32 count,
+                                      MV_STORAGE_DEVICE_REGISTERS *pInATARegs,
+                                      MV_STORAGE_DEVICE_REGISTERS *pOutATARegs);
+
+
+    MV_BOOLEAN mvStorageDevATAStartSoftResetDevice(MV_SATA_ADAPTER *pAdapter,
+                                                   MV_U8 channelIndex,
+                                                   MV_U8 PMPort);
+
+    MV_BOOLEAN mvStorageIsDeviceBsyBitOff(MV_SATA_ADAPTER *pAdapter,
+                                          MV_U8 channelIndex,
+                                          MV_STORAGE_DEVICE_REGISTERS *registerStruct
+                                         );
+
+    MV_BOOLEAN  mvStorageDevSetDeviceType(MV_SATA_ADAPTER *pAdapter, MV_U8 channelIndex,
+                                          MV_SATA_DEVICE_TYPE deviceType);
+
+    MV_SATA_DEVICE_TYPE mvStorageDevGetDeviceType(MV_SATA_ADAPTER *pAdapter,
+                                                  MV_U8 channelIndex);
+
+
+#ifdef __cplusplus
+
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvStorageDevh */
Index: linux-2.6.10/mvl_patches/pro-1115.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1115.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1115);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

