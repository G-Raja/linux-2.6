#! /usr/bin/env bash
# Patch: -common_pxa_monahans_camera
# Date: Fri Dec  7 11:52:54 2007
# Source: Marvell
# MR: 23636
# Type: Integration
# Disposition: merged from Marvell
# Signed-off-by: Aleksey Makarov <amakarov@ru.mvista.com>
# Description:
# 	This patch adds support for the camera found on 
# 	PXA3xx Processor Developer Kiti (Zylonite)
# 

PATCHNUM=1448
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Marvell
MR: 23636
Type: Integration
Disposition: merged from Marvell
Signed-off-by: Aleksey Makarov <amakarov@ru.mvista.com>
Description:
	This patch adds support for the camera found on 
	PXA3xx Processor Developer Kiti (Zylonite)

Index: linux-2.6.10/drivers/media/video/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/media/video/Makefile
+++ linux-2.6.10/drivers/media/video/Makefile
@@ -63,5 +63,6 @@ obj-$(CONFIG_VIDEO_M32R_AR_M64278) += ar
 obj-$(CONFIG_VIDEO_OMAP_CAMERA) += omap/
 
 obj-$(CONFIG_VIDEO_MAINSTONE_CAMERA) += mstone.o
+obj-$(CONFIG_PXA_CAMERA_ZL)          += monahans/
 
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
Index: linux-2.6.10/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/media/video/Kconfig
+++ linux-2.6.10/drivers/media/video/Kconfig
@@ -388,4 +388,12 @@ config VIDEO_MAINSTONE_CAMERA
 	select I2C
         depends on VIDEO_DEV && MACH_MAINSTONE
 
+config PXA_CAMERA_ZL
+	tristate "Camera Interface for PXA3xx Processor Developer Kit (Zylonite)"
+	depends on VIDEO_DEV && I2C && MACH_ZYLONITE
+	select PXA3XX_ARAVA
+        ---help---
+	  Say Y here to build driver for the camera on
+	  PXA3xx Processor Developer Kit(Zylonite)
+
 endmenu
Index: linux-2.6.10/drivers/media/video/monahans/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the video capture/playback device drivers.
+#
+
+obj-$(CONFIG_PXA_CAMERA_ZL)  += pxa_camera_zl.o camera.o ci.o \
+				ov2620.o ov2620_hw.o ov2630.o ov2630_hw.o \
+				ov7660.o ov7660_hw.o
Index: linux-2.6.10/drivers/media/video/monahans/camera.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/camera.c
@@ -0,0 +1,1647 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all primitive functions for camera driver
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+#include <linux/config.h>
+#include <asm/errno.h>
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "camera.h"
+#include "ci.h"
+
+/*
+ * Declarations
+ */
+
+#define SINGLE_DESCRIPTOR_TRANSFER_MAX  4096
+#define SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX  ((1<<21) - 32)
+
+/* there is a QCI bug that QCI can not branch to next descriptor upon the
+ * current frame is done. instead, it will branch to next descriptor once
+ * current descriptor is done.
+ * workaround: assert branch only when last descriptor of current frame
+ * is loaded */
+#define  CI_DMAC_BRANCH_BUG
+
+/*
+ * Define macroses to shorten access to descriptors:
+ * p -- pointer to camera_frame_buffer_info_t
+ * chan -- 0 for ch0_dma_desc_XXX_addr, ...
+ * vir_or_phy -- vir for chX_dma_desc_vir_addr, phy for chX_dma_desc_phy_addr
+ * first_or_last -- FIRST for FIRST_DMA_DESC_FOR_REAL_XXX_INX, ...
+ * real_or_phantom -- REAL XXX_DMA_DESC_FOR_REAL_BUFFER_INX, ...
+ */
+
+#define DESCR(p, chan, vir_or_phy, first_or_last, real_or_phantom) \
+       ((p)->ch ## chan ## _dma_desc_ ## vir_or_phy ## _addr \
+       [first_or_last ## _DMA_DESC_FOR_ ## real_or_phantom ## _BUFFER_INX])
+
+
+/* map of camera image format (camera.h) ==> capture interface format (ci.h) */
+static const int FORMAT_MAPPINGS[] = {
+	/* RAW */
+	CI_RAW8,
+	CI_RAW9,
+	CI_RAW10,
+
+	/* RGB */
+	CI_RGB444,
+	CI_RGB555,
+	CI_RGB565,
+	CI_RGB666_PACKED,          /* RGB Packed */
+	CI_RGB666,
+	CI_RGB888_PACKED,
+	CI_RGB888,
+	CI_RGBT555_0,              /* RGB+Transparent bit 0 */
+	CI_RGBT888_0,
+	CI_RGBT555_1,              /* RGB+Transparent bit 1 */
+	CI_RGBT888_1,
+
+	CI_INVALID_FORMAT,
+	CI_YCBCR422,               /* YCBCR */
+	CI_YCBCR422_PLANAR,        /* YCBCR Planar */
+	CI_INVALID_FORMAT,
+#if defined(CONFIG_PXA310)
+	CI_INVALID_FORMAT,
+	CI_YCBCR420,
+	CI_YCBCR420_PLANAR
+#else
+	CI_INVALID_FORMAT
+#endif
+};
+
+static void cam_configure_dmac(p_camera_context_t camera_context);
+static int cam_start_capture(p_camera_context_t camera_context,
+		unsigned int frames);
+static void cam_set_stop_state(p_camera_context_t camera_context);
+
+/*
+ * Private functions
+ */
+static void cam_configure_dmac(p_camera_context_t camera_context)
+{
+	unsigned int des_physical;
+	camera_frame_buffer_queue_t *queue;
+
+	queue = (camera_context->capture_mode == CAMERA_MODE_VIDEO)?
+		&(camera_context->video_capture_buffer_queue):
+			&(camera_context->still_capture_buffer_queue);
+
+	if (queue->head == NULL)
+		return;
+
+	des_physical = DESCR(queue->head, 0, phy, FIRST, REAL);
+	ci_dma_load_descriptor(des_physical, CI_DMA_CHANNEL_0);
+
+	if (camera_context->fifo1_transfer_size) {
+		des_physical = DESCR(queue->head, 1, phy, FIRST, REAL);
+		ci_dma_load_descriptor(des_physical, CI_DMA_CHANNEL_1);
+	}
+
+	if (camera_context->fifo2_transfer_size) {
+		des_physical = DESCR(queue->head, 2, phy, FIRST, REAL);
+		ci_dma_load_descriptor(des_physical, CI_DMA_CHANNEL_2);
+	}
+
+	camera_context->dma_running = 1;
+}
+
+static int cam_start_capture(p_camera_context_t camera_context, unsigned int frames)
+{
+	int   status;
+
+	/* Disable CI */
+	cam_set_stop_state(camera_context);
+
+	/* clear ci fifo */
+	ci_reset_fifo();
+	ci_clear_interrupt_status(0xFFFFFFFF);
+
+	if (!camera_context->ci_disable_complete) {
+		ci_disable(1, 1);
+		ci_disable_complete();
+	}
+
+	cam_configure_dmac(camera_context);
+
+	ci_enable();
+
+	/* start capture */
+	status = camera_context->camera_functions->
+			start_capture(camera_context, frames);
+	return status;
+}
+
+/*
+ * Init/Deinit APIs
+ */
+
+extern void zylonite_enable_cif_pins(void);
+
+int mcam_init(p_camera_context_t camera_context)
+{
+	int   status = 0;
+
+#ifdef DEBUG_PARAM_CHECK
+
+	/* parameter check */
+	if (camera_context->sensor_type > CAMERA_TYPE_MAX)
+		return -EINVAL;
+
+	/* check the function dispatch table according to the sensor type */
+	if (!camera_context->camera_functions)
+		return -EINVAL;
+
+	if (!camera_context->camera_functions->init ||
+			!camera_context->camera_functions->deinit ||
+			!camera_context->camera_functions->set_capture_format ||
+			!camera_context->camera_functions->start_capture ||
+			!camera_context->camera_functions->stop_capture)
+		return -EINVAL;
+#endif
+
+	/* initialize some camera used parameters */
+	camera_context->capture_input_width = 0;
+	camera_context->capture_input_height = 0;
+	camera_context->capture_output_width = 0;
+	camera_context->capture_output_height = 0;
+	camera_context->capture_input_format = CAMERA_IMAGE_FORMAT_MAX + 1;
+	camera_context->capture_output_format = CAMERA_IMAGE_FORMAT_MAX + 1;
+	camera_context->fifo0_transfer_size = 0;
+	camera_context->fifo1_transfer_size = 0;
+	camera_context->fifo2_transfer_size = 0;
+	camera_context->fifo3_transfer_size = 0;
+	camera_context->video_fifo0_transfer_size = 0;
+	camera_context->video_fifo1_transfer_size = 0;
+	camera_context->video_fifo2_transfer_size = 0;
+	camera_context->still_fifo0_transfer_size = 0;
+	camera_context->still_fifo1_transfer_size = 0;
+	camera_context->still_fifo2_transfer_size = 0;
+	camera_context->frame_buffer_number = 0;
+	camera_context->video_capture_buffer_queue.head = NULL;
+	camera_context->video_capture_buffer_queue.tail = NULL;
+	camera_context->still_capture_buffer_queue.head = NULL;
+	camera_context->still_capture_buffer_queue.tail = NULL;
+	camera_context->psu_enable = 0;
+	camera_context->cgu_enable = 0;
+	camera_context->ssu_scale = CI_SSU_SCALE_DISABLE;
+	camera_context->cmu_usage = CI_CMU_DISABLE;
+	camera_context->dma_running = 0;
+
+	/* MFP pins init */
+	zylonite_enable_cif_pins();
+
+	/* UTMI_SWITCH must be set to low and
+	 * the UTMI_TEST_EN should be set to output (low)
+	 */
+	mhn_gpio_set_direction(MFP_UTMI_SWITCH,  GPIO_DIR_OUT);
+	mhn_gpio_set_direction(MFP_UTMI_TEST_EN, GPIO_DIR_OUT);
+	mhn_gpio_set_level(MFP_UTMI_SWITCH,  GPIO_LEVEL_LOW);
+	mhn_gpio_set_level(MFP_UTMI_TEST_EN, GPIO_LEVEL_HIGH);
+
+	/* set two gpio pin direction as output
+	 * to control the power of two sensors.
+	 */
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_OUT);
+	mhn_gpio_set_direction(MFP_CIF_LO_PWDN_GPI0, GPIO_DIR_OUT);
+	/* set two gpio pin output as HI to power off two sensors. */
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_level(MFP_CIF_LO_PWDN_GPI0, GPIO_LEVEL_HIGH);
+
+	/* capture interface init */
+	ci_init();
+
+	/* sensor init */
+	status = camera_context->camera_functions->init(camera_context);
+	if (status) {
+		goto camera_init_err;
+	}
+
+	/* set frame rate */
+	mcam_set_capture_frame_rate(camera_context);
+
+	return 0;
+
+camera_init_err:
+	mcam_deinit(camera_context);
+	return -EIO;
+}
+
+int mcam_deinit(p_camera_context_t camera_context)
+{
+	int status;
+
+	/* deinit sensor */
+	status = camera_context->camera_functions->deinit(camera_context);
+
+	/* capture interface deinit */
+	ci_deinit();
+
+	return status;
+}
+
+/*
+ * Capture APIs
+ */
+
+/* Set the image format */
+int mcam_set_capture_format(p_camera_context_t camera_context)
+{
+	int status;
+	unsigned int capture_input_width, capture_input_height;
+	int ci_input_format, ci_output_format;
+	unsigned int scale;
+
+	/* caculate some parameters according to the driver parameters */
+
+	/* get basic capture format and resolution info */
+	if (camera_context->capture_mode == CAMERA_MODE_VIDEO) {
+		camera_context->capture_input_format =
+			camera_context->video_capture_input_format;
+		camera_context->capture_output_format =
+			camera_context->video_capture_output_format;
+		camera_context->capture_output_width =
+			camera_context->video_capture_width;
+		camera_context->capture_output_height =
+			camera_context->video_capture_height;
+		camera_context->fifo0_transfer_size =
+			camera_context->video_fifo0_transfer_size;
+		camera_context->fifo1_transfer_size =
+			camera_context->video_fifo1_transfer_size;
+		camera_context->fifo2_transfer_size =
+			camera_context->video_fifo2_transfer_size;
+	} else {
+		camera_context->capture_input_format =
+			camera_context->still_capture_input_format;
+		camera_context->capture_output_format =
+			camera_context->still_capture_output_format;
+		camera_context->capture_output_width =
+			camera_context->still_capture_width;
+		camera_context->capture_output_height =
+			camera_context->still_capture_height;
+		camera_context->fifo0_transfer_size =
+			camera_context->still_fifo0_transfer_size;
+		camera_context->fifo1_transfer_size =
+			camera_context->still_fifo1_transfer_size;
+		camera_context->fifo2_transfer_size =
+			camera_context->still_fifo2_transfer_size;
+	}
+
+#ifdef DEBUG_PARAM_CHECK
+	if (camera_context->capture_input_format >  CAMERA_IMAGE_FORMAT_MAX ||
+			camera_context->capture_output_format >
+			CAMERA_IMAGE_FORMAT_MAX)
+		return -EINVAL;
+#endif
+
+	/* determine whether to enable PSU */
+	camera_context->psu_enable =
+		(camera_context->capture_input_format <=
+		CAMERA_IMAGE_FORMAT_RAW10) ? 1 : 0;
+
+	/* determine whether to enable CGU */
+	camera_context->cgu_enable =
+		((camera_context->capture_input_format <=
+		CAMERA_IMAGE_FORMAT_RAW10) &&
+		(camera_context->capture_input_format !=
+		camera_context->capture_output_format)) ?
+		1 : 0;
+
+	/* determine how to use SSU */
+	camera_context->ssu_scale =
+		(camera_context->capture_mode == CAMERA_MODE_VIDEO)?
+		(CI_SSU_SCALE)camera_context->video_capture_scale:
+		(CI_SSU_SCALE)camera_context->still_capture_scale;
+
+	/* determine how to use CMU */
+	if ((camera_context->capture_input_format <=
+			CAMERA_IMAGE_FORMAT_RAW10) &&
+			(camera_context->capture_output_format >=
+			CAMERA_IMAGE_FORMAT_RGB444) &&
+			(camera_context->capture_output_format <=
+			CAMERA_IMAGE_FORMAT_RGBT888_1)) {
+		camera_context->cmu_usage = CI_CMU_OUTPUT_RGB;
+	} else if ((camera_context->capture_input_format <=
+			CAMERA_IMAGE_FORMAT_RAW10) &&
+			(camera_context->capture_output_format >=
+			CAMERA_IMAGE_FORMAT_YCBCR400) &&
+			(camera_context->capture_output_format <=
+#if defined(CONFIG_PXA310)
+			CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR)) {
+#else
+			CAMERA_IMAGE_FORMAT_YCBCR444_PLANAR)) {
+#endif
+		camera_context->cmu_usage = CI_CMU_OUTPUT_YUV;
+	} else {
+		camera_context->cmu_usage = CI_CMU_DISABLE;
+	}
+#if defined(CONFIG_PXA310)
+	if (camera_context->capture_output_format == CAMERA_IMAGE_FORMAT_YCBCR420_PACKED
+		|| camera_context->capture_output_format == CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR)
+	{
+		camera_context->ycbcr_ds = CI_YUV_420_DOWN_SAMPLE;
+	} else {
+		camera_context->ycbcr_ds = CI_NO_DOWN_SAMPLE;
+	}
+#endif
+
+#ifdef DEBUG_PARAM_CHECK
+	if ((camera_context->cmu_usage != CI_CMU_DISABLE) &&
+			(camera_context->ssu_scale == CI_SSU_SCALE_DISABLE)) {
+		return -EINVAL;
+	}
+#endif
+
+	/* caculate the input resolution */
+	capture_input_width = camera_context->capture_output_width;
+	capture_input_height = camera_context->capture_output_height;
+
+	if (camera_context->ssu_scale != CI_SSU_SCALE_DISABLE) {
+		scale = (camera_context->ssu_scale == CAMERA_CAPTURE_SCALE_HALF) ?
+				2:4;
+		capture_input_width = (camera_context->capture_input_format <=
+			CAMERA_IMAGE_FORMAT_RAW10) ?
+			(capture_input_width*scale + 2) :
+			(capture_input_width*scale + 2);
+
+		capture_input_height = (camera_context->capture_input_format <=
+			CAMERA_IMAGE_FORMAT_RAW10) ?
+			(capture_input_height*scale + 2) :
+			(capture_input_height*scale + 1);
+	}
+
+	if (camera_context->cmu_usage != CI_CMU_DISABLE) {
+		if (CAMERA_CAPTURE_SCALE_HALF == camera_context->ssu_scale) {
+			capture_input_height = capture_input_height + 2 + 1;
+		} else if (CI_SSU_SCALE_QUARTER == camera_context->ssu_scale) {
+			capture_input_height = capture_input_height + 4 + 3;
+		} else if (CI_SSU_SCALE_DISABLE == camera_context->ssu_scale) {
+			capture_input_height = capture_input_height + 1;
+		}
+	}
+
+	camera_context->capture_input_width = capture_input_width;
+	camera_context->capture_input_height = capture_input_height;
+
+	/* set sensor setting */
+	status = camera_context->camera_functions->
+			set_capture_format(camera_context);
+	if (status) {
+		return status;
+	}
+
+	/* set CI setting */
+
+	/* set scale to SSU */
+	ci_ssu_set_scale(camera_context->ssu_scale);
+
+	/* enable/disable CMU */
+	ci_cmu_enable(camera_context->cmu_usage);
+
+	/* set CI image format */
+	ci_input_format =
+		FORMAT_MAPPINGS[camera_context->capture_input_format];
+	ci_output_format =
+		FORMAT_MAPPINGS[camera_context->capture_output_format];
+
+#ifdef DEBUG_PARAM_CHECK
+	if (ci_input_format == CI_INVALID_FORMAT ||
+			ci_output_format == CI_INVALID_FORMAT)
+		return -EINVAL;
+#endif
+
+	ci_set_image_format(ci_input_format, ci_output_format);
+#if defined(CONFIG_PXA310)
+	ci_set_ycbcr_420_down_sample (camera_context->ycbcr_ds);
+#endif
+
+	return 0;
+}
+
+/* take a picture and copy it into the frame buffers */
+int mcam_capture_still_image(p_camera_context_t camera_context)
+{
+	int status;
+	status = cam_start_capture(camera_context, 1);
+	return status;
+}
+
+/* capture motion video and copy them to the frame buffers */
+int mcam_start_video_capture(p_camera_context_t camera_context)
+{
+	int status;
+	status = cam_start_capture(camera_context, 0);
+	return status;
+}
+
+static void cam_set_stop_state(p_camera_context_t camera_context)
+{
+	/* Clear the counts and the current status. */
+	camera_context->ci_disable_complete = 0;
+	ci_clear_interrupt_status(0xFFFFFFFF);
+
+
+	/* Depending upon the timing of using the command to change to single
+	 * frame mode, the OV9640 may issue a VSYNC and 1 HSYNC signal and then
+	 * stop.  This would leave the CI in a non-IDLE state.  The camera
+	 * interface is now disabled before leaving the stop state.
+	 */
+	ci_disable(1, 1);
+}
+
+/* disable motion video image capture */
+void mcam_stop_video_capture(p_camera_context_t camera_context)
+{
+	int status;
+
+	/* stop capture */
+	status = camera_context->camera_functions->stop_capture(camera_context);
+
+	/* Set up to receive interrupts and track the sof, eof,
+	 * and eol after the shutdown.
+	 */
+	cam_set_stop_state(camera_context);
+
+	/* clear ci fifo */
+	ci_reset_fifo();
+
+	/* empty the capture queue.
+	 * WARNING: the driver must re-submit all of buffers into
+	 * queue before it starts video/still capture next time!
+	 */
+	camera_context->dma_running = 0;
+}
+
+/*
+ * Flow Control APIs
+ */
+
+/* Get the buffer size and the DMA descriptors memory size for this buffer */
+int mcam_get_buffer_size(
+		p_camera_context_t   camera_context,
+		int   buffer_type,
+		int  *buffer_size,
+		int  *buffer_dma_desc_mem_size)
+{
+	unsigned int    capture_output_format;
+	unsigned int    capture_output_width;
+	unsigned int    capture_output_height;
+	unsigned int    frame_size;
+	unsigned int    fifo0_transfer_size;
+	unsigned int    fifo1_transfer_size;
+	unsigned int    fifo2_transfer_size;
+	unsigned int    fifo0_num_descriptors = 0;
+	unsigned int    fifo1_num_descriptors = 0;
+	unsigned int    fifo2_num_descriptors = 0;
+	unsigned int    fifo0_phantom_num_descriptors = 0;
+	unsigned int    fifo1_phantom_num_descriptors = 0;
+	unsigned int    fifo2_phantom_num_descriptors = 0;
+	unsigned int    num_descriptors_for_buffer;
+
+
+	/* caculate the fifo0~2 transfer size */
+	capture_output_format = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		camera_context->video_capture_output_format:
+		camera_context->still_capture_output_format;
+
+	capture_output_width  = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		camera_context->video_capture_width:
+		camera_context->still_capture_width;
+
+	capture_output_height = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		camera_context->video_capture_height:
+		camera_context->still_capture_height;
+
+	switch (capture_output_format) {
+		case CAMERA_IMAGE_FORMAT_RAW10:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RAW9:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RAW8:
+			frame_size =
+				capture_output_width * capture_output_height;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RGB565:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RGB888_PACKED:
+			frame_size =
+				capture_output_width * capture_output_height * 3;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PACKED:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size / 2;
+			fifo1_transfer_size = frame_size / 4;
+			fifo2_transfer_size = frame_size / 4;
+			break;
+#if defined(CONFIG_PXA310)
+		case CAMERA_IMAGE_FORMAT_YCBCR420_PACKED:
+			frame_size =
+				capture_output_width * capture_output_height * 3 / 2;
+			fifo0_transfer_size = frame_size;
+			fifo1_transfer_size = 0;
+			fifo2_transfer_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR:
+			frame_size =
+				capture_output_width * capture_output_height * 2;
+			fifo0_transfer_size = frame_size / 2;
+			fifo1_transfer_size = frame_size / 8;
+			fifo2_transfer_size = frame_size / 8;
+			break;
+#endif
+		default:
+			return -EINVAL;
+			break;
+	}
+
+	if (buffer_type == VIDEO_CAPTURE_BUFFER) {
+		camera_context->video_fifo0_transfer_size = fifo0_transfer_size;
+		camera_context->video_fifo1_transfer_size = fifo1_transfer_size;
+		camera_context->video_fifo2_transfer_size = fifo2_transfer_size;
+	} else {
+		camera_context->still_fifo0_transfer_size = fifo0_transfer_size;
+		camera_context->still_fifo1_transfer_size = fifo1_transfer_size;
+		camera_context->still_fifo2_transfer_size = fifo2_transfer_size;
+	}
+
+	/* caculate the buffer size and descriptor memory size */
+	fifo0_num_descriptors = (fifo0_transfer_size +
+		SINGLE_DESCRIPTOR_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_TRANSFER_MAX;
+
+	fifo1_num_descriptors = (fifo1_transfer_size +
+		SINGLE_DESCRIPTOR_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_TRANSFER_MAX;
+
+	fifo2_num_descriptors = (fifo2_transfer_size +
+		SINGLE_DESCRIPTOR_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_TRANSFER_MAX;
+
+	fifo0_phantom_num_descriptors = (fifo0_transfer_size +
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+
+	fifo1_phantom_num_descriptors = (fifo1_transfer_size +
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+
+	fifo2_phantom_num_descriptors = (fifo2_transfer_size +
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX - 1) /
+		SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+
+	if (camera_context->align_type == YUV_NO_PADDING)
+		goto no_padding;
+
+	num_descriptors_for_buffer = fifo0_num_descriptors +
+			fifo1_num_descriptors + fifo2_num_descriptors;
+
+	*buffer_size = num_descriptors_for_buffer *
+			SINGLE_DESCRIPTOR_TRANSFER_MAX;
+
+	/* descriptors memory for real frame buffer and phantom buffer */
+	*buffer_dma_desc_mem_size = sizeof(struct ci_dma_descriptor)*(
+			fifo0_num_descriptors + fifo0_phantom_num_descriptors +
+			fifo1_num_descriptors + fifo1_phantom_num_descriptors +
+			fifo2_num_descriptors + fifo2_phantom_num_descriptors);
+
+	return 0;
+
+no_padding:
+	num_descriptors_for_buffer = (fifo0_transfer_size +
+			fifo1_transfer_size + fifo2_transfer_size +
+			SINGLE_DESCRIPTOR_TRANSFER_MAX - 1) / SINGLE_DESCRIPTOR_TRANSFER_MAX + 2;
+
+	*buffer_size = fifo0_transfer_size + fifo1_transfer_size +
+		fifo2_transfer_size;
+
+	/* descriptors memory for real frame buffer and phantom buffer */
+	*buffer_dma_desc_mem_size = sizeof(struct ci_dma_descriptor)*(
+			num_descriptors_for_buffer + fifo0_phantom_num_descriptors
+			+ fifo1_phantom_num_descriptors + fifo2_phantom_num_descriptors);
+
+	return 0;
+}
+
+/* Add the buffer into the buffer pool
+ * and generate the DMA chains for the buffer
+ */
+int mcam_prepare_buffer(
+		p_camera_context_t camera_context,
+		void *buf_virt_addr,
+		int *buf_phy_addr_array,
+		int buf_phy_addr_array_size,
+		int buffer_size,
+		int buffer_type,
+		void *dma_desc_virt_addr,
+		int *dma_desc_phy_addr_array,
+		int *buffer_id,
+		void **pY,
+		void **pCb,
+		void **pCr)
+{
+	camera_frame_buffer_info_t *buffer_info;
+	int buffer_index, des_transfer_size, remain_size;
+	volatile struct ci_dma_descriptor *cur_des_virtual;
+	unsigned int buffer_page_seq, dma_descriptor_seq;
+	unsigned int fifo0_transfer_size;
+	unsigned int fifo1_transfer_size;
+	unsigned int fifo2_transfer_size;
+	unsigned int fifo0_num_descriptors = 0;
+	unsigned int fifo1_num_descriptors = 0;
+	unsigned int fifo2_num_descriptors = 0;
+	unsigned int fifo0_phantom_num_descriptors = 0;
+	unsigned int fifo1_phantom_num_descriptors = 0;
+	unsigned int fifo2_phantom_num_descriptors = 0;
+
+	unsigned int fifo0_last_buf_transfer_size = 0;
+	unsigned int fifo1_last_buf_transfer_size = 0;
+	unsigned int offset;
+
+	/* compute descriptor number for fifo0~fifo2 */
+	fifo0_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo0_transfer_size:
+		camera_context->still_fifo0_transfer_size;
+
+	fifo1_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo1_transfer_size:
+		camera_context->still_fifo1_transfer_size;
+
+	fifo2_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo2_transfer_size:
+		camera_context->still_fifo2_transfer_size;
+
+	/* calculate how many descriptors are needed per frame */
+	fifo0_num_descriptors = 0;
+	fifo1_num_descriptors = 0;
+	fifo2_num_descriptors = 0;
+	fifo0_phantom_num_descriptors = 0;
+	fifo1_phantom_num_descriptors = 0;
+	fifo2_phantom_num_descriptors = 0;
+
+	/* add the buffer into the buffer pool */
+	buffer_index = (*buffer_id == -1) ?
+				camera_context->frame_buffer_number:*buffer_id;
+	buffer_info = &(camera_context->master_frame_buffer_list[buffer_index]);
+	buffer_info->frame_id = buffer_index;
+	buffer_info->buffer_size = buffer_size;
+	buffer_info->dma_descriptors_virtual =
+		(struct ci_dma_descriptor *)dma_desc_virt_addr;
+	if (*buffer_id == -1)
+		camera_context->frame_buffer_number++;
+
+	/* generate the DMA chains */
+	dma_descriptor_seq = 0;
+	buffer_page_seq = 0;
+	cur_des_virtual = (struct ci_dma_descriptor*)dma_desc_virt_addr;
+
+	/* 1. generate fifo0 DMA chain */
+	if (fifo0_transfer_size) {
+		/* 1.1 Build the primary DMA chain */
+		remain_size = fifo0_transfer_size;
+		while(remain_size) {
+			/* set descriptor */
+			fifo0_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+
+			 /* FIFO0 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR0);
+			cur_des_virtual->dtadr =
+				(unsigned)buf_phy_addr_array[buffer_page_seq++];
+			cur_des_virtual->dcmd =
+				des_transfer_size | CI_DMAC_DCMD_INC_TRG_ADDR;
+
+			if (remain_size == fifo0_transfer_size) {
+				DESCR(buffer_info, 0, vir, FIRST, REAL) = cur_des_virtual;
+				DESCR(buffer_info, 0, phy, FIRST, REAL) =
+					(u32)dma_desc_phy_addr_array[dma_descriptor_seq - 1];
+				/* record address of the first real descriptor */
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_TRANSFER_MAX) {
+				buffer_info->ch0_dma_desc_num = fifo0_num_descriptors;
+
+				DESCR(buffer_info, 0, vir, LAST, REAL) =
+					cur_des_virtual;
+				DESCR(buffer_info, 0, phy, LAST, REAL) =
+					(u32)dma_desc_phy_addr_array[dma_descriptor_seq - 1];
+#ifdef CI_DMAC_BRANCH_BUG
+				cur_des_virtual->dcmd |= CI_DMAC_DCMD_SOF_IRQ_EN;
+#endif
+				fifo0_last_buf_transfer_size = des_transfer_size;
+
+				/* record address of the last real descriptor */
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+
+		/* 1.2 Build the phantom DMA chain */
+		remain_size = fifo0_transfer_size;
+		while(remain_size) {
+			/* set descriptor */
+			fifo0_phantom_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+			/* FIFO0 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR0);
+			cur_des_virtual->dtadr =
+				camera_context->phantom_buffer_physical;
+			cur_des_virtual->dcmd = des_transfer_size;
+
+			if (remain_size == fifo0_transfer_size) {
+				/* The address of the first phantom descriptor*/
+				DESCR(buffer_info, 0, vir, FIRST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 0, phy, FIRST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX){
+				buffer_info->ch0_phantom_dma_desc_num =
+					fifo0_phantom_num_descriptors;
+
+				DESCR(buffer_info, 0, vir, LAST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 0, phy, LAST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+				/* The address of the last phantom descriptor */
+				cur_des_virtual->ddadr =
+					DESCR(buffer_info, 0, phy, FIRST, PHANTOM);
+				/* loop the phantom buffer to itself */
+
+#ifdef CI_DMAC_BRANCH_BUG
+				cur_des_virtual->dcmd |= CI_DMAC_DCMD_SOF_IRQ_EN;
+#endif
+
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+	}
+
+	/* 2. generate fifo1 DMA chain */
+	if (fifo1_transfer_size) {
+		/* 2.1 Build the primary DMA chain */
+		remain_size = fifo1_transfer_size;
+		while(remain_size) {
+			/* set descriptor */
+			fifo1_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			offset = 0;
+			if((camera_context->align_type == YUV_NO_PADDING)
+					&& (fifo0_last_buf_transfer_size != SINGLE_DESCRIPTOR_TRANSFER_MAX)
+					&& (remain_size == fifo1_transfer_size)){
+				buffer_page_seq -= 1;
+				des_transfer_size = min(des_transfer_size,
+						(int)(SINGLE_DESCRIPTOR_TRANSFER_MAX - fifo0_last_buf_transfer_size));
+				offset = fifo0_last_buf_transfer_size;
+			}
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+
+			/* FIFO1 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR1);
+			cur_des_virtual->dtadr =
+				(unsigned)buf_phy_addr_array[buffer_page_seq++] + offset;
+			cur_des_virtual->dcmd =
+				des_transfer_size | CI_DMAC_DCMD_INC_TRG_ADDR;
+
+			if (remain_size == fifo1_transfer_size) {
+				/* The address of the first real descriptor */
+				DESCR(buffer_info, 1, vir, FIRST, REAL) =
+					cur_des_virtual;
+				DESCR(buffer_info, 1, phy, FIRST, REAL) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_TRANSFER_MAX) {
+				/* The address of the last real descriptor */
+				buffer_info->ch1_dma_desc_num = fifo1_num_descriptors;
+				DESCR(buffer_info, 1, vir, LAST, REAL) =
+					cur_des_virtual;
+				DESCR(buffer_info, 1, phy, LAST, REAL) =
+					(u32)dma_desc_phy_addr_array[dma_descriptor_seq - 1];
+				fifo1_last_buf_transfer_size = des_transfer_size;
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+
+		/* 2.2 Build the phantom DMA chain */
+		remain_size = fifo1_transfer_size;
+		while (remain_size) {
+			/* set descriptor */
+			fifo1_phantom_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+
+			/* FIFO1 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR1);
+			cur_des_virtual->dtadr =
+				camera_context->phantom_buffer_physical;
+			cur_des_virtual->dcmd = des_transfer_size;
+
+			if (remain_size == fifo1_transfer_size) {
+				/* The record address of the
+				 * first phantom descriptor
+				 */
+				DESCR(buffer_info, 1, vir, FIRST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 1, phy, FIRST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX) {
+				/* The address of the last phantom descriptor */
+				buffer_info->ch1_phantom_dma_desc_num =
+					fifo1_phantom_num_descriptors;
+				DESCR(buffer_info, 1, vir, LAST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 1, phy, LAST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+
+				/* loop the phantom buffer to itself */
+				cur_des_virtual->ddadr =
+					DESCR(buffer_info, 1, phy, FIRST, PHANTOM);
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+	}
+
+	/* 3. generate fifo2 DMA chain */
+	if (fifo2_transfer_size) {
+		/* 3.1 Build the primary DMA chain */
+		remain_size = fifo2_transfer_size;
+		while(remain_size) {
+			/* set descriptor */
+			fifo2_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			offset = 0;
+			if((camera_context->align_type == YUV_NO_PADDING)
+					&& (fifo1_last_buf_transfer_size != SINGLE_DESCRIPTOR_TRANSFER_MAX)
+					&& (remain_size == fifo2_transfer_size)){
+				buffer_page_seq -= 1;
+				des_transfer_size = min(des_transfer_size,
+						(int)(SINGLE_DESCRIPTOR_TRANSFER_MAX - fifo1_last_buf_transfer_size));
+				offset = fifo1_last_buf_transfer_size;
+			}
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+
+			/* FIFO2 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR2);
+			cur_des_virtual->dtadr =
+				(unsigned)buf_phy_addr_array[buffer_page_seq++] + offset;
+			cur_des_virtual->dcmd =
+				des_transfer_size | CI_DMAC_DCMD_INC_TRG_ADDR;
+
+			if (remain_size == fifo2_transfer_size) {
+				/* The address of the first real descriptor */
+				DESCR(buffer_info, 2, vir, FIRST, REAL) =
+					cur_des_virtual;
+				DESCR(buffer_info, 2, phy, FIRST, REAL) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_TRANSFER_MAX) {
+				/* The address of the last real descriptor */
+				buffer_info->ch2_dma_desc_num =
+					fifo2_num_descriptors;
+				DESCR(buffer_info, 2, vir, LAST, REAL) =
+					cur_des_virtual;
+				DESCR(buffer_info, 2, phy, LAST, REAL) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+
+		/* 3.2 Build the phantom DMA chain */
+		remain_size = fifo2_transfer_size;
+		while(remain_size) {
+			/* set descriptor */
+			fifo2_phantom_num_descriptors++;
+			if (remain_size > SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX)
+				des_transfer_size =
+					SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX;
+			else
+				des_transfer_size = remain_size;
+
+			cur_des_virtual->ddadr =
+				dma_desc_phy_addr_array[++dma_descriptor_seq];
+
+			/* FIFO2 physical address */
+			cur_des_virtual->dsadr = __PREG_3(CIBR2);
+			cur_des_virtual->dtadr =
+				camera_context->phantom_buffer_physical;
+			cur_des_virtual->dcmd = des_transfer_size;
+
+			if (remain_size == fifo2_transfer_size){
+				/* The address of the first phantom descriptor */
+				DESCR(buffer_info, 2, vir, FIRST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 2, phy, FIRST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+			}
+
+			if (remain_size <= SINGLE_DESCRIPTOR_PHANTOM_TRANSFER_MAX) {
+				/* The address of the last phantom descriptor */
+				buffer_info->ch2_phantom_dma_desc_num =
+					fifo2_phantom_num_descriptors;
+				DESCR(buffer_info, 2, vir, LAST, PHANTOM) =
+					cur_des_virtual;
+				DESCR(buffer_info, 2, phy, LAST, PHANTOM) =
+					(u32)dma_desc_phy_addr_array
+					[dma_descriptor_seq - 1];
+				/* loop the phantom buffer to itself */
+				cur_des_virtual->ddadr =
+					DESCR(buffer_info, 2, phy, FIRST, PHANTOM);
+			}
+
+			/* advance pointers */
+			remain_size -= des_transfer_size;
+			cur_des_virtual++;
+		}
+	}
+
+	if ((unsigned int)buf_phy_addr_array_size < buffer_page_seq)
+		return -EINVAL;
+
+	if(camera_context->align_type == YUV_NO_PADDING) {
+		buffer_info->pY = (void*)buf_virt_addr;
+		buffer_info->pCb = (fifo1_transfer_size) ?
+			(void*)((unsigned int)buffer_info->pY + fifo0_transfer_size ) : 0;
+		buffer_info->pCr = (fifo2_transfer_size) ?
+			(void*)((unsigned int)buffer_info->pCb + fifo1_transfer_size) : 0;
+	} else {
+		buffer_info->pY = (void*)buf_virt_addr;
+		buffer_info->pCb = (fifo1_transfer_size) ?
+			(void*)((unsigned int)buffer_info->pY +
+					fifo0_num_descriptors * SINGLE_DESCRIPTOR_TRANSFER_MAX) : 0;
+		buffer_info->pCr = (fifo2_transfer_size) ?
+			(void*)((unsigned int)buffer_info->pCb +
+					fifo1_num_descriptors * SINGLE_DESCRIPTOR_TRANSFER_MAX) : 0;
+	}
+
+	/* return results */
+	*buffer_id  = buffer_info->frame_id;
+	*pY         = buffer_info->pY;
+	*pCb        = buffer_info->pCb;
+	*pCr        = buffer_info->pCr;
+
+	return 0;
+}
+
+/* branch to queue head */
+static int cam_branch_to_head(p_camera_context_t camera_context)
+{
+       camera_frame_buffer_queue_t *queue;
+       unsigned int fifo0_transfer_size;
+       unsigned int fifo1_transfer_size;
+       unsigned int fifo2_transfer_size;
+       volatile unsigned int cidadr0 = CIDADR0;
+
+       /* get the specified capture queue and other info */
+       queue = (camera_context->capture_mode == CAMERA_MODE_VIDEO)?
+               &(camera_context->video_capture_buffer_queue):
+                       &(camera_context->still_capture_buffer_queue);
+
+#ifdef CI_DMAC_BRANCH_BUG
+       if (DESCR(queue->tail, 0, phy, FIRST, PHANTOM) != cidadr0)
+               return -1;
+#endif
+
+       fifo0_transfer_size =  camera_context->fifo0_transfer_size;
+       fifo1_transfer_size =  camera_context->fifo1_transfer_size;
+       fifo2_transfer_size =  camera_context->fifo2_transfer_size;
+
+       if (fifo0_transfer_size)
+               ci_dma_set_branch(DESCR(queue->head, 0, phy, FIRST, REAL), 1, 1, CI_DMA_CHANNEL_0);
+
+       if (fifo1_transfer_size)
+               ci_dma_set_branch(DESCR(queue->head, 1, phy, FIRST, REAL), 1, 1, CI_DMA_CHANNEL_1);
+
+       if (fifo2_transfer_size)
+               ci_dma_set_branch(DESCR(queue->head, 2, phy, FIRST, REAL), 1, 1, CI_DMA_CHANNEL_2);
+
+       return 0;
+}
+
+
+
+/* Submit a buffer into the capture queue */
+int mcam_submit_buffer(p_camera_context_t  camera_context,
+		int  buffer_id, int buffer_type)
+{
+	camera_frame_buffer_info_t  *buffer_info;
+	camera_frame_buffer_queue_t *queue;
+	unsigned int fifo0_transfer_size;
+	unsigned int fifo1_transfer_size;
+	unsigned int fifo2_transfer_size;
+	unsigned int need_branch = 0;
+
+	/* get the specified capture queue and buffer and other info */
+	queue = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		&(camera_context->video_capture_buffer_queue):
+			&(camera_context->still_capture_buffer_queue);
+
+	buffer_info = &(camera_context->master_frame_buffer_list[buffer_id]);
+
+	fifo0_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo0_transfer_size:
+		camera_context->still_fifo0_transfer_size;
+
+	fifo1_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo1_transfer_size:
+		camera_context->still_fifo1_transfer_size;
+
+	fifo2_transfer_size = (buffer_type == VIDEO_CAPTURE_BUFFER)?
+		camera_context->video_fifo2_transfer_size:
+		camera_context->still_fifo2_transfer_size;
+
+
+	/* attach the submitted buffer's DMA chain to the queue */
+	if ((queue->tail != NULL) && (queue->tail != buffer_info)) {
+		if (fifo0_transfer_size) {
+			DESCR(queue->tail, 0, vir, LAST, REAL)->ddadr =
+				DESCR(buffer_info, 0, phy, FIRST, REAL);
+			DESCR(queue->tail, 0, vir, LAST, PHANTOM)->ddadr =
+				DESCR(buffer_info, 0, phy, FIRST, REAL);
+		}
+
+		if (fifo1_transfer_size) {
+			DESCR(queue->tail, 1, vir, LAST, REAL)->ddadr =
+				DESCR(buffer_info, 1, phy, FIRST, REAL);
+			DESCR(queue->tail, 1, vir, LAST, PHANTOM)->ddadr =
+				DESCR(buffer_info, 1, phy, FIRST, REAL);
+		}
+
+		if (fifo2_transfer_size) {
+			DESCR(queue->tail, 2, vir, LAST, REAL)->ddadr =
+				DESCR(buffer_info, 2, phy, FIRST, REAL);
+			DESCR(queue->tail, 2, vir, LAST, PHANTOM)->ddadr =
+				DESCR(buffer_info, 2, phy, FIRST, REAL);
+		}
+
+	} else if ((camera_context->dma_running && queue->tail == buffer_info) &&
+			((buffer_type == VIDEO_CAPTURE_BUFFER &&
+			camera_context->capture_mode == CAMERA_MODE_VIDEO) ||
+			(buffer_type == STILL_CAPTURE_BUFFER &&
+			camera_context->capture_mode == CAMERA_MODE_STILL))) {
+		need_branch = 1;
+	}
+
+	/* update the head of the queue, if necessary */
+	if (queue->head == NULL) {
+		queue->head = buffer_info;
+	}
+
+	/* update the tail of the queue */
+	if (queue->tail == NULL) {
+		queue->tail = buffer_info;
+	} else {
+		queue->tail->next_buffer = buffer_info;
+		queue->tail = buffer_info;
+	}
+	queue->tail->next_buffer = NULL;
+
+	/* ensure the tail's phantom buffer loop to itself */
+
+	if (fifo0_transfer_size) {
+		DESCR(queue->tail, 0, vir, LAST, REAL)->ddadr =
+			DESCR(buffer_info, 0, phy, FIRST, PHANTOM);
+		DESCR(queue->tail, 0, vir, LAST, PHANTOM)->ddadr =
+			DESCR(buffer_info, 0, phy, FIRST, PHANTOM);
+	}
+
+	if (fifo1_transfer_size) {
+		DESCR(queue->tail, 1, vir, LAST, REAL)->ddadr =
+			DESCR(buffer_info, 1, phy, FIRST, PHANTOM);
+		DESCR(queue->tail, 1, vir, LAST, PHANTOM)->ddadr =
+			DESCR(buffer_info, 1, phy, FIRST, PHANTOM);
+	}
+
+	if (fifo2_transfer_size) {
+		DESCR(queue->tail, 2, vir, LAST, REAL)->ddadr =
+			DESCR(buffer_info, 2, phy, FIRST, PHANTOM);
+		DESCR(queue->tail, 2, vir, LAST, PHANTOM)->ddadr =
+			DESCR(buffer_info, 2, phy, FIRST, PHANTOM);
+	}
+
+
+	/* tag the buffer as clean */
+	*((unsigned int*)buffer_info->pY + fifo0_transfer_size/4 - 2) =
+		CAMERA_CLEAN_BUFFER_IDENTIFIER;
+	*((unsigned int*)buffer_info->pY + fifo0_transfer_size/4 - 1) =
+		CAMERA_CLEAN_BUFFER_IDENTIFIER;
+
+	/* reload the dma descriptor if needed */
+	if (need_branch)
+		cam_branch_to_head(camera_context);
+
+	return 0;
+}
+
+#define DESCR(p, chan, vir_or_phy, first_or_last, real_or_phantom) \
+       ((p)->ch ## chan ## _dma_desc_ ## vir_or_phy ## _addr \
+       [first_or_last ## _DMA_DESC_FOR_ ## real_or_phantom ## _BUFFER_INX])
+
+/* detect if the queue is in dead lock */
+int queue_dead_locked(p_camera_context_t camera_context)
+{
+       camera_frame_buffer_queue_t *queue;
+       unsigned int cidadr0 = CIDADR0;
+       unsigned int fifo0_transfer_size;
+
+       /* get the specified capture queue and other info */
+       queue = (camera_context->capture_mode == CAMERA_MODE_VIDEO)?
+               &(camera_context->video_capture_buffer_queue):
+                       &(camera_context->still_capture_buffer_queue);
+
+       fifo0_transfer_size =  camera_context->fifo0_transfer_size;
+
+       if (queue->head == NULL)
+               return 0;
+
+       {
+	       unsigned int * a = (unsigned int*)queue->head->pY + fifo0_transfer_size/4;
+	       if ( (*(a - 2) != CAMERA_CLEAN_BUFFER_IDENTIFIER) && (*(a - 1) != CAMERA_CLEAN_BUFFER_IDENTIFIER))
+		       return 0;
+	       else
+		       return ((CITADR0 == camera_context->phantom_buffer_physical) &&
+			        DESCR(queue->tail, 0, phy, FIRST, PHANTOM) <= cidadr0) &&
+			        (cidadr0 <= DESCR(queue->tail, 0, phy, LAST, PHANTOM));
+       }
+}
+
+
+/* Get the buffer filled with valid frame data */
+int mcam_get_filled_buffer(p_camera_context_t  camera_context,
+		int *buffer_id)
+{
+	camera_frame_buffer_queue_t *queue;
+	unsigned int fifo0_transfer_size;
+
+	/* get the specified capture queue and other info */
+	queue = (camera_context->capture_mode == CAMERA_MODE_VIDEO)?
+		&(camera_context->video_capture_buffer_queue):
+		&(camera_context->still_capture_buffer_queue);
+
+	fifo0_transfer_size =  camera_context->fifo0_transfer_size;
+
+	/* check if there are any buffers filled with valid image data */
+	if (queue->head != NULL) {
+
+		unsigned int * a = (unsigned int*)queue->head->pY + fifo0_transfer_size/4;
+
+		if ((*(a - 2) != CAMERA_CLEAN_BUFFER_IDENTIFIER) &&
+				(*(a - 1) != CAMERA_CLEAN_BUFFER_IDENTIFIER)) {
+
+			*buffer_id  = queue->head->frame_id;
+			queue->head = queue->head->next_buffer;
+
+			return 0;
+		}
+
+
+		if (queue_dead_locked(camera_context))
+			cam_branch_to_head(camera_context);
+
+		return -EIO;
+	}
+
+	return -EIO;
+}
+
+/*
+ * Frame rate APIs
+ */
+void mcam_set_capture_frame_rate(p_camera_context_t camera_context)
+{
+	ci_set_frame_rate((CI_FRAME_CAPTURE_RATE)camera_context->frame_rate);
+}
+
+/* return current setting */
+void mcam_get_capture_frame_rate(p_camera_context_t camera_context)
+{
+	camera_context->frame_rate = ci_get_frame_rate();
+}
+
+/*
+ * Interrupt APIs
+ */
+/* set interrupt mask */
+void mcam_set_interrupt_mask(p_camera_context_t camera_context,
+		unsigned int mask)
+{
+	/* set CI interrupt */
+	ci_set_interrupt_mask(mask);
+}
+
+/* get interrupt mask */
+unsigned int mcam_get_interrupt_mask(p_camera_context_t camera_context)
+{
+	/* get CI mask */
+	return ci_get_interrupt_mask();
+}
+
+/* get interrupt status */
+unsigned int mcam_get_interrupt_status(p_camera_context_t camera_context)
+{
+	return ci_get_interrupt_status();
+}
+
+/* clear interrupt status */
+void mcam_clear_interrupt_status(p_camera_context_t camera_context,
+		unsigned int status)
+{
+	ci_clear_interrupt_status(status);
+}
+
+/*
+ * Sensor Control APIs
+ */
+int mcam_read_8bit(p_camera_context_t camera_context, u8 reg_addr, u8 *reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->read_8bit) {
+		status = camera_context->camera_functions->
+				read_8bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor 8 bit register write */
+int mcam_write_8bit(p_camera_context_t camera_context, u8 reg_addr, u8 reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->write_8bit) {
+		status = camera_context->camera_functions->
+				write_8bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor 16-bit register read */
+int mcam_read_16bit(p_camera_context_t camera_context, u16 reg_addr, u16 *reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->read_16bit) {
+		status = camera_context->camera_functions->
+				read_16bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor 16 bit register write */
+int mcam_write_16bit(p_camera_context_t camera_context, u16 reg_addr,
+		u16 reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->write_16bit) {
+		status = camera_context->camera_functions->
+				write_16bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor 32 bit register read */
+int mcam_read_32bit(p_camera_context_t camera_context, u32 reg_addr,
+		u32 *reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->read_32bit) {
+		status = camera_context->camera_functions->
+				read_32bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor 32 bit register write */
+int mcam_write_32bit(p_camera_context_t camera_context, u32 reg_addr,
+		u32 reg_val)
+{
+	int status;
+
+	if (camera_context->camera_functions->write_32bit) {
+		status = camera_context->camera_functions->
+				write_32bit(camera_context, reg_addr, reg_val);
+		return status;
+	}
+	return -EIO;
+}
+
+/* CMOS sensor Power Mode read */
+void mcam_get_power_mode(p_camera_context_t camera_context, u8 *power_mode)
+{
+	*power_mode = camera_context->sensor_status.power_mode;
+}
+
+/* CMOS sensor Power Mode write */
+int mcam_set_power_mode (p_camera_context_t camera_context, u8 power_mode)
+{
+	int status;
+
+	status = 0;
+
+	if (camera_context->sensor_status.power_mode != power_mode)
+		status = camera_context->camera_functions->
+				set_power_mode(camera_context, power_mode);
+
+	return status;
+}
+
+/* CMOS sensor Capability read */
+unsigned int mcam_get_caps (p_camera_context_t camera_context)
+{
+	return camera_context->sensor_status.caps;
+}
+
+/* CMOS sensor contrast value read */
+void mcam_get_contrast_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value)
+{
+	*mode = camera_context->sensor_status.contrast_mode;
+	if (*mode == SENSOR_MANUAL_CONTRAST)
+		*value = camera_context->sensor_status.contrast_value;
+	else
+		*value = 0;
+}
+
+/* CMOS sensor contrast value write */
+int mcam_set_contrast_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value)
+{
+	camera_context->sensor_status.contrast_mode = mode;
+	camera_context->sensor_status.contrast_value = value;
+	return camera_context->camera_functions->
+		set_contrast(camera_context, mode, value);
+}
+
+/* CMOS sensor white balance value read */
+void mcam_get_white_balance_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value)
+{
+	*mode = camera_context->sensor_status.whitebalance_mode;
+	if (*mode == SENSOR_MANUAL_WHITEBALANCE)
+		*value = camera_context->sensor_status.whitebalance_value;
+	else
+		*value = 0;
+}
+
+/* CMOS sensor white balance value write */
+int mcam_set_white_balance_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value)
+{
+	camera_context->sensor_status.whitebalance_mode = mode;
+	camera_context->sensor_status.whitebalance_value = value;
+	return camera_context->camera_functions->
+		set_whitebalance(camera_context, mode, value);
+}
+
+/* CMOS sensor exposure value read */
+void mcam_get_exposure_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value)
+{
+	*mode = camera_context->sensor_status.exposure_mode;
+	if (*mode == SENSOR_MANUAL_EXPOSURE)
+		*value = camera_context->sensor_status.exposure_value;
+	else
+		*value = 0;
+}
+
+/* CMOS sensor exposure value write */
+int mcam_set_exposure_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value)
+{
+	camera_context->sensor_status.exposure_mode = mode;
+	camera_context->sensor_status.exposure_value = value;
+	return camera_context->camera_functions->
+		set_exposure(camera_context, mode, value);
+}
+
+/* CMOS sensor zoom value read */
+void mcam_get_zoom_value (p_camera_context_t camera_context, unsigned int *value)
+{
+	*value = camera_context->sensor_status.zoom_value;
+}
+
+/* CMOS sensor zoom value write */
+int mcam_set_zoom_value (p_camera_context_t camera_context, unsigned int value)
+{
+	camera_context->sensor_status.zoom_value = value;
+	return camera_context->camera_functions->set_zoom(camera_context, value);
+}
+
+/* get Histogram Info */
+int mcam_get_histogram_info(
+		p_camera_context_t     camera_context,
+		unsigned int                color_type,
+		unsigned int               *histogram_size,
+		unsigned int               *histogram_sum)
+{
+	unsigned int mux_select;
+
+	mux_select = (camera_context->capture_input_format ==
+		CAMERA_IMAGE_FORMAT_RAW10)?CI_HSU_MUX_1_TO_9:
+		(camera_context->capture_input_format ==
+		CAMERA_IMAGE_FORMAT_RAW9) ?CI_HSU_MUX_0_TO_8:
+		CI_HSU_MUX_0_TO_7;
+	camera_context->fifo3_transfer_size =
+		(mux_select == CI_HSU_MUX_0_TO_7)?512:1024;
+
+	*histogram_size = camera_context->fifo3_transfer_size;
+	return ci_hsu_get_histgram(
+			(CI_HSU_COLOR_TYPE) color_type,
+			(CI_HSU_MUX_SEL_TYPE) mux_select,
+			camera_context->histogram_lut_buffer_virtual,
+			camera_context->histogram_lut_buffer_physical,
+			(unsigned int*) camera_context->
+				histogram_lut_dma_descriptors_virtual,
+			camera_context->histogram_lut_dma_descriptors_physical,
+			camera_context->fifo3_transfer_size,
+			histogram_sum);
+}
+
+/*
+ * sleep/wakeup APIs
+ */
+int mcam_suspend(p_camera_context_t    camera_context)
+{
+	/* stop capture at first, if necessary */
+	if (camera_context->dma_running) {
+		if (camera_context->capture_mode == CAMERA_MODE_VIDEO) {
+			mcam_stop_video_capture(camera_context);
+		} else if (camera_context->capture_mode == CAMERA_MODE_STILL) {
+			mcam_stop_video_capture(camera_context);;
+		} else {
+			return 0;
+		}
+		camera_context->dma_running = 1;
+	}
+
+	/* sleep sensor */
+	camera_context->camera_functions->sleep(camera_context);
+
+	ci_deinit();
+
+	/* set two gpio pin output as HI to power off two sensors */
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_level(MFP_CIF_LO_PWDN_GPI0, GPIO_LEVEL_HIGH);
+
+	return 0;
+}
+
+int mcam_resume(p_camera_context_t    camera_context)
+{
+	int status;
+
+	/* set two gpio pin direction as output to
+	 * control the power of two sensors.
+	 */
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_OUT);
+	mhn_gpio_set_direction(MFP_CIF_LO_PWDN_GPI0, GPIO_DIR_OUT);
+	/* set two gpio pin output as HI to power off two sensors */
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_level(MFP_CIF_LO_PWDN_GPI0, GPIO_LEVEL_HIGH);
+
+	ci_init();
+
+	mcam_set_capture_frame_rate(camera_context);
+
+	/* wake up sensor */
+	status = camera_context->camera_functions->wakeup(camera_context);
+	if (status != 0) {
+		goto camera_init_err;
+	}
+
+	/* recovered to the pre-sleep status */
+	mcam_set_capture_format(camera_context);
+	if (camera_context->dma_running) {
+		if (camera_context->capture_mode == CAMERA_MODE_VIDEO) {
+			mcam_start_video_capture(camera_context);
+		} else if (camera_context->capture_mode == CAMERA_MODE_STILL) {
+			mcam_capture_still_image(camera_context);
+		}
+	}
+
+	return 0;
+camera_init_err:
+	mcam_deinit(camera_context);
+
+	return -EIO;
+}
+
Index: linux-2.6.10/drivers/media/video/monahans/camera.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/camera.h
@@ -0,0 +1,824 @@
+/*
+    Copyright (C) 2005, Intel Corporation.
+    Copyright (C) 2006, Marvell International Ltd.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *   contains all camera specific macros, typedefs, and prototypes.
+ *   Declares no storage.
+ *
+ * Notes:
+ *   Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAMERA_HEADER__
+#define __MONAHANS_CAMERA_HEADER__
+
+
+#include "ci.h"
+
+/*
+ * Macros
+ */
+/* Sensor type */
+#define CAMERA_TYPE_ADCM_2650		1
+#define CAMERA_TYPE_ADCM_2670		2
+#define CAMERA_TYPE_ADCM_2700		3
+#define CAMERA_TYPE_OMNIVISION_9640	4
+#define CAMERA_TYPE_OMNIVISION_2620	5
+#define CAMERA_TYPE_OMNIVISION_7660	6
+#define CAMERA_TYPE_OMNIVISION_2630	7
+#define CAMERA_TYPE_MAX			CAMERA_TYPE_OMNIVISION_2630
+
+/* Image format definition */
+#define CAMERA_IMAGE_FORMAT_RAW8		0
+#define CAMERA_IMAGE_FORMAT_RAW9		1
+#define CAMERA_IMAGE_FORMAT_RAW10		2
+#define CAMERA_IMAGE_FORMAT_RGB444		3
+#define CAMERA_IMAGE_FORMAT_RGB555		4
+#define CAMERA_IMAGE_FORMAT_RGB565		5
+#define CAMERA_IMAGE_FORMAT_RGB666_PACKED	6
+#define CAMERA_IMAGE_FORMAT_RGB666_PLANAR	7
+#define CAMERA_IMAGE_FORMAT_RGB888_PACKED	8
+#define CAMERA_IMAGE_FORMAT_RGB888_PLANAR	9
+#define CAMERA_IMAGE_FORMAT_RGBT555_0		10  /* RGB+Transparent bit 0 */
+#define CAMERA_IMAGE_FORMAT_RGBT888_0		11
+#define CAMERA_IMAGE_FORMAT_RGBT555_1		12  /* RGB+Transparent bit 1 */
+#define CAMERA_IMAGE_FORMAT_RGBT888_1		13
+
+#define CAMERA_IMAGE_FORMAT_YCBCR400		14
+#define CAMERA_IMAGE_FORMAT_YCBCR422_PACKED	15
+#define CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR	16
+#define CAMERA_IMAGE_FORMAT_YCBCR444_PACKED	17
+#define CAMERA_IMAGE_FORMAT_YCBCR444_PLANAR	18
+#if defined(CONFIG_PXA310)
+#define CAMERA_IMAGE_FORMAT_YCBCR420_PACKED	19
+#define CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR	20
+#define CAMERA_IMAGE_FORMAT_MAX		\
+		CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR
+#else
+#define CAMERA_IMAGE_FORMAT_MAX		\
+		CAMERA_IMAGE_FORMAT_YCBCR444_PLANAR
+#endif
+
+/* Interrupt mask */
+#define CAMERA_INTMASK_FIFO_OVERRUN	CI_INT_IFO
+#define CAMERA_INTMASK_END_OF_FRAME	CI_INT_EOF
+#define CAMERA_INTMASK_START_OF_FRAME	CI_INT_SOF
+#define CAMERA_INTMASK_CI_DISABLE_DONE	CI_INT_CDD
+#define CAMERA_INTMASK_CI_QUICK_DISABLE	CI_INT_CQD
+#define CAMERA_INTMASK_PARITY_ERROR	CI_INT_PAR_ERR
+#define CAMERA_INTMASK_END_OF_LINE	CI_INT_EOL
+#define CAMERA_INTMASK_FIFO_EMPTY	CI_INT_FEMPTY
+#define CAMERA_INTMASK_TIME_OUT		CI_INT_FTO
+#define CAMERA_INTMASK_FIFO3_UNDERRUN	CI_INT_FU
+#define CAMERA_INTMASK_BRANCH_STATUS	CI_INT_BS
+#define CAMERA_INTMASK_ENF_OF_FRAME_TRANSFER	CI_INT_EOFX
+#define CAMERA_INTMASK_DMA_CHANNEL0_STOP	CI_INT_SC0
+#define CAMERA_INTMASK_DMA_CHANNEL1_STOP	CI_INT_SC1
+#define CAMERA_INTMASK_DMA_CHANNEL2_STOP	CI_INT_SC2
+#define CAMERA_INTMASK_DMA_CHANNEL3_STOP	CI_INT_SC3
+
+
+/* Capture mode */
+#define CAMERA_MODE_VIDEO		0x0001
+#define CAMERA_MODE_STILL		0x0002
+
+/* buffer type */
+#define VIDEO_CAPTURE_BUFFER		0
+#define STILL_CAPTURE_BUFFER		1
+
+/* clean buffer identifier */
+#define CAMERA_CLEAN_BUFFER_IDENTIFIER	0x12345678
+
+#define CAMERA_CAPTURE_SCALE_DISABLE     CI_SSU_SCALE_DISABLE
+#define CAMERA_CAPTURE_SCALE_HALF        CI_SSU_SCALE_HALF
+#define CAMERA_CAPTURE_SCALE_QUATER      CI_SSU_SCALE_QUARTER
+
+/* sensor capabilities */
+#define SENSOR_CAP_MANUAL_CONTRAST       0x0001
+#define SENSOR_CAP_MANUAL_WHITEBALANCE   0x0002
+#define SENSOR_CAP_MANUAL_EXPOSURE       0x0004
+#define SENSOR_CAP_MANUAL_ZOOM           0x0008
+
+/* sensor power mode */
+#define CAMERA_POWER_OFF                 0
+#define CAMERA_POWER_LOW                 1
+#define CAMERA_POWER_MID                 2
+#define CAMERA_POWER_FULL                3
+
+/* sensor contrast mode and value */
+#define SENSOR_MANUAL_CONTRAST           0
+#define SENSOR_AUTO_CONTRAST             1
+
+#define SENSOR_CONTRAST_LOWEST           0
+#define SENSOR_CONTRAST_LOW              1
+#define SENSOR_CONTRAST_MIDDLE           2
+#define SENSOR_CONTRAST_HIGH             3
+#define SENSOR_CONTRAST_HIGHEST          4
+
+/* sensor white balance mode and value */
+#define SENSOR_MANUAL_WHITEBALANCE       0
+#define SENSOR_AUTO_WHITEBALANCE         1
+
+#define SENSOR_WHITEBALANCE_AUTO         0
+#define SENSOR_WHITEBALANCE_INCANDESCENT 1
+#define SENSOR_WHITEBALANCE_SUNNY        2
+#define SENSOR_WHITEBALANCE_FLUORESCENT  3
+
+/* sensor exposure mode and value */
+#define SENSOR_MANUAL_EXPOSURE           0
+#define SENSOR_AUTO_EXPOSURE             1
+
+#define SENSOR_EXPOSURE_LOWEST           0
+#define SENSOR_EXPOSURE_LOW              1
+#define SENSOR_EXPOSURE_MIDDLE           2
+#define SENSOR_EXPOSURE_HIGH             3
+#define SENSOR_EXPOSURE_HIGHEST          4
+
+/* Buffer Pool Information */
+/* Max Buffer number of Camera Buffer Pool has 64
+ * First 32bytes: phantom buffer
+ * Last 16 bytes: init dma descriptor for all channels
+ * 32 bytes are enough: clear DCMD[IncTrgAddr] of
+ * phantom buffer's DMA descriptor so as to save
+ * memory, since phantom buffer is useless.
+ */
+#define MAX_CAMERA_FRAME_BUFFERS	32
+
+#define PHANTOM_BUFFER_SIZE		112
+
+/* Frame Buffer Information */
+/* each channel of frame buffer has 3
+ * special DMA descriptors, two for real
+ * buffer, another for phantom buffer.
+ */
+#define SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME      4
+
+/* the first DMA descriptor of real buffer */
+#define FIRST_DMA_DESC_FOR_REAL_BUFFER_INX              0
+
+/* the last DMA descriptor of real buffer */
+#define LAST_DMA_DESC_FOR_REAL_BUFFER_INX               1
+
+/* the first DMA descriptor of phantom buffer */
+#define FIRST_DMA_DESC_FOR_PHANTOM_BUFFER_INX           2
+
+/* the last DMA descriptor of phantom buffer */
+#define LAST_DMA_DESC_FOR_PHANTOM_BUFFER_INX            3
+
+/*
+ * Structures
+ */
+typedef struct camera_context_s camera_context_t, *p_camera_context_t;
+
+typedef enum {
+       YUV_HAVE_PADDING   = 0,
+       YUV_NO_PADDING     = 1
+} PADDING_TYPE;
+
+typedef struct {
+	int (*init)(p_camera_context_t camera_context);
+	int (*deinit)(p_camera_context_t camera_context);
+	int (*set_capture_format)(p_camera_context_t camera_context);
+	int (*start_capture)(p_camera_context_t camera_context ,
+			unsigned int frames);
+	int (*stop_capture)(p_camera_context_t camera_context);
+	int (*sleep)(p_camera_context_t camera_context);
+	int (*wakeup)(p_camera_context_t camera_context);
+
+	/*  functions for sensor control */
+	int (*read_8bit)(p_camera_context_t camera_context,
+			u8 reg_addr, u8 *reg_val);
+	int (*write_8bit)(p_camera_context_t camera_context,
+			u8 reg_addr, u8 reg_val);
+	int (*read_16bit)(p_camera_context_t camera_context,
+			u16 reg_addr, u16 *reg_val);
+	int (*write_16bit)(p_camera_context_t camera_context,
+			u16 reg_addr, u16 reg_val);
+	int (*read_32bit)(p_camera_context_t camera_context,
+			u32 reg_addr, u32 *reg_val);
+	int (*write_32bit)(p_camera_context_t camera_context,
+			u32 reg_addr, u32 reg_val);
+	int (*set_power_mode)(p_camera_context_t camera_context, u8 power_mode);
+	int (*set_contrast) (p_camera_context_t camera_context,
+			u8 mode, u32 value);
+	int (*set_whitebalance) (p_camera_context_t camera_context,
+			u8 mode, u32 value);
+	int (*set_exposure) (p_camera_context_t camera_context,
+			u8 mode, u32 value);
+	int (*set_zoom) (p_camera_context_t camera_context, u32 value);
+} camera_function_t, *p_camera_function_t;
+
+
+typedef struct {
+	unsigned char power_mode;
+
+	unsigned int caps;
+	/*  1 << 0:    Manual ContrastMode supported by sensor;
+	 *  1 << 1:    Manual whitebalance supported by sensor;
+	 *  1 << 2:    Manual exposure supported by sensor;
+	 *  1 << 3:    Manual Zoom supported by sensor;
+	 */
+
+	unsigned char contrast_mode;
+	unsigned char whitebalance_mode;
+	unsigned char exposure_mode;
+
+	unsigned int contrast_value;
+	unsigned int whitebalance_value;
+	unsigned int exposure_value;
+	unsigned int zoom_value;
+} sensor_status_t, *p_sensor_status_t;
+
+typedef struct camera_frame_buffer_info_s camera_frame_buffer_info_t ,\
+		*p_camera_frame_buffer_info_t;
+typedef struct camera_frame_buffer_queue_s camera_frame_buffer_queue_t, \
+		*p_camera_frame_buffer_queue_t;
+
+struct camera_frame_buffer_info_s {
+	/* Information for frame buffer itself */
+
+	/* Frame ID, indicates this buffer's
+	 * position in the buffer pool.
+	 */
+	int			frame_id;
+
+	/* the buffer size, can be obtained via
+	 * mcam_get_buffer_size() before
+	 * allocating the memory for the buffer.
+	 */
+	int			buffer_size;
+
+	/* the virtual address of the memory for DMA descriptors
+	 * for this buffer, should be 16-bytes aligned.
+	 */
+	volatile struct ci_dma_descriptor *dma_descriptors_virtual;
+
+	/* the virtual address of the Y component */
+	void			*pY;
+
+	/* the virtual address of the Cb component */
+	void			*pCb;
+
+	/* the virtual address of the Cr component */
+	void			*pCr;
+
+	/* Information of the DMA descriptor Chains for this frame buffer */
+	/* pointer to an array of physical address of
+	 * channel 0's DMA chain for this buffer;
+	 */
+	u32		ch0_dma_desc_phy_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* pointer to an array of virtual address of
+	 * channel 0's DMA chain for this buffer;
+	 */
+	volatile struct ci_dma_descriptor *ch0_dma_desc_vir_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* DMA descriptors number for channel 0 */
+	int			ch0_dma_desc_num;
+
+	/* DMA descriptors number of phantom buffer for channel 0 */
+	int			ch0_phantom_dma_desc_num;
+
+	/* pointer to an array of physical address of
+	 * channel 1's DMA chain for this buffer;
+	 */
+	u32		ch1_dma_desc_phy_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* pointer to an array of virtual address of
+	 * channel 1's DMA chain for this buffer;
+	 */
+	volatile struct ci_dma_descriptor *ch1_dma_desc_vir_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* DMA descriptors number for channel 1 */
+	int			ch1_dma_desc_num ;
+
+	/* DMA descriptors number of phantom buffer for channel 1 */
+	int			ch1_phantom_dma_desc_num;
+
+	/* pointer to an array of physical address of
+	 * channel 2's DMA chain for this buffer;
+	 */
+	u32		ch2_dma_desc_phy_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* pointer to an array of virtual address of
+	 * channel 2's DMA chain for this buffer;
+	 */
+	volatile struct ci_dma_descriptor *ch2_dma_desc_vir_addr	\
+			[SPECIAL_DMA_DESC_NUM_PER_CHANNEL_PER_FRAME];
+
+	/* DMA descriptors number for channel 2 */
+	int			ch2_dma_desc_num;
+
+	/* DMA descriptors number of phantom buffer for channel 2 */
+	int			ch2_phantom_dma_desc_num;
+
+	/* next buffer in the queue, only used in
+	 * video capture buffer queue or still
+	 * capture buffer queue.
+	 */
+	camera_frame_buffer_info_t	*next_buffer;
+};
+
+struct camera_frame_buffer_queue_s {
+	/* first frame buffer owned by the queue. When
+	 * this buffer will be reported the
+	 * application when it is filled with frame
+	 * data, then this pointer will point to the
+	 * next buffer in the queue. If the queue runs
+	 * out of its buffers, this pointer will be
+	 * NULL until one new free buffer added into
+	 * the queue when this pointer will point to
+	 * this new buffer.
+	 */
+	camera_frame_buffer_info_t   *head;
+
+	/* last frame buffer in the queue, always
+	 * followed by the phantom buffer. When there
+	 * is no frame available in the queue, the DMA
+	 * controller will transfer the frame data to
+	 * its phantom buffer until the Camera driver
+	 * submits new frames into the queue. The
+	 * frame complete interrupt for phantom buffer
+	 * should be ignored.
+         */
+	camera_frame_buffer_info_t   *tail;
+};
+
+/* context */
+struct camera_context_s {
+	/* DRIVER FILLED PARAMTER */
+
+	/* sensor information */
+	/* defines the imagine sensor type connected to the camera
+	 * interface. For example,
+	 * TYPE_OMNIVISION_2620 selected the Agilent
+	 * 2620 sensor available on the Zylonite platform
+	 */
+	unsigned int                       sensor_type;
+
+	/* capture image information */
+	/* video capture or still capture */
+	unsigned int                       capture_mode;
+
+	/* video_capture_width and video_capture_height define the
+	 * desired width and height of the motion video capture
+	 * stream.  Knowledge of the particular sensor is required
+	 * in order to specify a valid width and height.  Some
+	 * sensors support arbitrary width and height up to the
+	 * maximum sensor dimensions.  Other sensors support only
+	 * subset of possible sizes.
+	 */
+	unsigned int                       video_capture_width;
+	unsigned int                       video_capture_height;
+
+	/* defines the scaling rate of sensor output vs QCI output.
+	 * possible choices: 1:1(default) or 2:1 or 4:1.However, if there
+	 * is need to convert RAW data to YUV/RGB, then this field must be
+	 * set as 2:1 or 4:1
+	 */
+	unsigned int                       video_capture_scale;
+
+	/* video_capture_input_format describes the data format for
+	 * motion video that the sensor provides to the camera
+	 * interface.  For example,
+	 * CAMERA_IMAGE_FORMAT_RAW10 is
+	 * used to describe a 10-bits RAW data format, such as that
+	 * used by the OV2620.
+	 */
+	unsigned int                       video_capture_input_format;
+
+	/* video_capture_output_format describes the data format
+	 * for motion video that the camera interface will use to
+	 * source data to the DMA controller.  The output format
+	 * need not be the same as the input format.  The Monahans
+	 * camera interface provides some limited conversion
+	 * mechanisms.  For example, input data of
+	 * CAMERA_IMAGE_FORMAT_RAW10 may be converted to
+	 * CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR by specifying
+	 * that planar format.
+	 */
+	unsigned int                       video_capture_output_format;
+
+	/* still_capture_width and still_capture_height define the
+	 * desired width and height of the still image capture.
+	 * Knowledge of the particular sensor is required
+	 * in order to specify a valid width and height.  Some
+	 * sensors support arbitrary width and height up to the
+	 * maximum sensor dimensions.  Other sensors support only
+	 * subset of possible sizes.
+         */
+	unsigned int                       still_capture_width;
+	unsigned int                       still_capture_height;
+
+	/* defines the scaling rate of sensor output vs QCI output.
+	 * possible choices: 1:1(default) or 2:1 or 4:1.However, if there
+	 * is need to convert RAW data to YUV/RGB, then this field must be
+	 * set as 2:1 or 4:1
+	 */
+	unsigned int                       still_capture_scale;
+
+	/* still_capture_input_format describes the data format for
+	 * still image that the sensor provides to the camera
+	 * interface.  For example,
+	 * CAMERA_IMAGE_FORMAT_RAW10 is
+	 * used to describe a 10-bits RAW data format, such as that
+	 * used by the OV2620.
+	 */
+	unsigned int                       still_capture_input_format;
+
+	/* still_capture_output_format describes the data format
+	 * for still image that the camera interface will use to
+	 * source data to the DMA controller.  The output format
+	 * need not be the same as the input format.  The Monahans
+	 * camera interface provides some limited conversion
+	 * mechanisms.  For example, input data of
+	 * CAMERA_IMAGE_FORMAT_RAW10 may be converted to
+	 * CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR by specifying
+	 * that planar format.
+	 */
+	unsigned int                       still_capture_output_format;
+
+	/* frame rate control */
+	/* frame_rate specifies the desired frame rate control.
+	 * Use a 0 to specify the maximum frame rate.  For n > 0,
+	 * it specifies that the interface should capture 1 out of
+	 * every n+1 frames generated.  A future implementation may
+	 * change the interpretation of the frame rate in order to
+	 * specify the frames per second.
+	 */
+	unsigned int                       frame_rate;
+
+	/* memory for phantom buffer */
+	/* buffer with PHANTOM_BUFFER_SIZE bytes,
+	 * allocated by camera driver, used as phantom buffer by all
+	 * buffers, should be 16-bytes aligned.
+	 */
+	u32                    *phantom_buffer_virtual;
+	u32                     phantom_buffer_physical;
+
+	/* memory for getting Histogram or loading CGU LUT */
+	/* buffer with 1024 bytes, allocated by camera
+	 * driver, used for getting Histogram(512 or 1024bytes) or
+	 * loading CGU LUT(64*3bytes), should be 16-bytes aligned.
+	 */
+	u32                    *histogram_lut_buffer_virtual;
+	u32                     histogram_lut_buffer_physical;
+
+	/* memory for DMA descriptors to get Histogram or load CGU LUT */
+	/* memory for DMA descriptors allocated by Camera driver,
+	 * 16-bytes aligned, should be 16-byte sized. This
+	 * descriptor is required to get histogram data or load
+	 * Compander look-up-table (CGU LUT).
+	 */
+	struct ci_dma_descriptor *histogram_lut_dma_descriptors_virtual;
+	u32                     histogram_lut_dma_descriptors_physical;
+
+	/* os mapped register address */
+	/* specifies the virtual address of the OST registers */
+	/* unsigned int                       ost_reg_base; */
+
+	/* specifies the virtual address of the GPIO registers */
+	/* unsigned int                       gpio_reg_base; */
+
+	/* specifies the virtual address of the CAMERA INTERFACE registers */
+	unsigned int                       ci_reg_base;
+
+	/* specifies the virtual address of the Clock registers registers */
+	/* unsigned int                       clk_reg_base; */
+
+	/* function dispatch table */
+	/* specify pointers to the given camera sensor functions */
+	p_camera_function_t           camera_functions;
+
+
+
+	/* INTERNALLY USED: DON'T TOUCH! */
+
+	/* Sensor status */
+	sensor_status_t               sensor_status;
+
+	/* sensor related parameter or status will be put here */
+
+	/* capture parameters:
+	 *    those parameters are being used by Camera currently
+	 *    for video capture or still capture, generated from
+	 *    driver-filled parameters according to the parameter
+	 *    capture_mode.
+	 */
+
+	/* current image resolution of the sensor output or QCI
+	 * input, may be the same as QCI output, may be not,
+	 * depending on the capture scale.
+	 */
+	unsigned int                       capture_input_width;
+	unsigned int                       capture_input_height;
+
+	/* current image resolution of the QCI output */
+	unsigned int                       capture_output_width;
+	unsigned int                       capture_output_height;
+
+	/* current image format of the sensor output or QCI input */
+	unsigned int                       capture_input_format;
+
+	/* current image format of the QCI output */
+	unsigned int                       capture_output_format;
+
+	/* this three parameters indicate the current transfer size
+	 * of channel 0, channel 1 and channel 2, respectively.
+	 * they would be calculated from the format and
+	 * resolution of the current QCI output.
+	 */
+	unsigned int                       fifo0_transfer_size;
+	unsigned int                       fifo1_transfer_size;
+	unsigned int                       fifo2_transfer_size;
+
+	/* transfer size of channel 3. This parameter is for
+	 * reading Histogram only, may be 512 or 1024, depending on
+	 * the CIHST.SCALE. For loading CGU LUT, the transfer size
+	 * will be hard coded as 64*3 bytes, since the CGU LUT
+	 *consists of three 64-element Look-Up-Tables.
+	 */
+	unsigned int                       fifo3_transfer_size;
+
+	/* this three parameters indicate the transfer size
+	 * of channel 0, channel 1 and channel 2 for video capture, respectively.
+	 * they would be calculated from the format and
+	 * resolution of the vide capture QCI output.
+	 */
+	unsigned int                       video_fifo0_transfer_size;
+	unsigned int                       video_fifo1_transfer_size;
+	unsigned int                       video_fifo2_transfer_size;
+
+	/* this three parameters indicate the transfer size
+	 * of channel 0, channel 1 and channel 2 for still capture, respectively.
+	 * they would be calculated from the format and
+	 * resolution of the still capture QCI output.
+	 */
+	unsigned int                       still_fifo0_transfer_size;
+	unsigned int                       still_fifo1_transfer_size;
+	unsigned int                       still_fifo2_transfer_size;
+
+	/* frame buffer pool */
+	/* frame buffer pool is maintained within the camera driver.
+	 * When the application or camera driver is initialized, the
+	 * frame buffer will be allocated, too. Those frame buffers
+	 * will be added to this frame buffer pool. Afterward the
+	 * application/camera driver will get buffers from this pool
+	 * and submits them to the still capture buffer queue or the
+	 * video capture buffer queue.
+	 */
+	camera_frame_buffer_info_t
+		master_frame_buffer_list[MAX_CAMERA_FRAME_BUFFERS];
+
+	/* indicates how many buffers the buffer pool currently has */
+	int                                 frame_buffer_number;
+
+	/* still capture buffer queue */
+	/* frame buffer queue used by still capture, its frame
+	 * buffers come from frame buffer pool. Generally, this
+	 * queue only has one buffer.
+	 */
+	camera_frame_buffer_queue_t   still_capture_buffer_queue;
+
+	/* video capture buffer queue */
+	/* frame buffer queue used by video capture, its frame
+	 * buffers come from frame buffer pool, too.
+	 */
+	camera_frame_buffer_queue_t   video_capture_buffer_queue;
+
+	/* QCI status */
+	/* indicates whether QCI disabling is completed */
+	unsigned int                       ci_disable_complete;
+
+	/* indicates whether PSU is enabled */
+	int                        psu_enable;
+
+	/* indicates whether the CGU is enabled */
+	int                        cgu_enable;
+
+	/* indicates the SSU scale ratio */
+	CI_SSU_SCALE                  ssu_scale;
+
+	/* indicates how to use CMU. This varible will tell the sensor
+	 * that it should choose which CMU matrix to load
+	 */
+	CI_CMU_USAGE                  cmu_usage;
+
+	int                        dma_running;
+
+	/*
+	 * align_tpye indicate whether YUV have padding
+	 * 0: have padding
+	 * 1: no padding;
+         */
+	int                       align_type;
+
+#if defined(CONFIG_PXA310)
+	CI_CICR4_YCBCR_DOWN_SAMPLE		ycbcr_ds;
+#endif
+};
+
+/*
+ * Prototypes
+ */
+
+/*
+ * Init/Deinit APIs
+ */
+
+/* Setup the sensor type, configure image capture format (RGB, yuv 444,
+ * yuv 422, yuv 420, packed | planar, MJPEG) regardless of current operating
+ * mode (i.e. sets mode for both still capture and video capture)
+ */
+int mcam_init(p_camera_context_t camera_context);
+
+/* Power off sensor */
+int mcam_deinit(p_camera_context_t camera_context);
+
+/*
+ * Capture APIs
+ */
+
+/* Set the image format */
+int mcam_set_capture_format(p_camera_context_t camera_context);
+
+/* take a picture and copy it into the frame buffer */
+int mcam_capture_still_image(p_camera_context_t camera_context);
+
+/* capture motion video and copy it the frame buffer */
+int mcam_start_video_capture(p_camera_context_t camera_context);
+
+/* disable motion video image capture */
+void mcam_stop_video_capture(p_camera_context_t camera_context);
+
+/*
+ * Flow Control APIs
+ */
+/* Get the buffer size and the DMA descriptors memory size for this buffer*/
+int mcam_get_buffer_size(
+		p_camera_context_t   camera_context,
+		int   buffer_type,
+		int  *buffer_size,
+		int  *buffer_dma_desc_mem_size);
+
+/* Add the buffer into the buffer pool */
+int mcam_prepare_buffer(
+		p_camera_context_t   camera_context,
+		void   *buffer_virtual_address,
+		int   *buffer_physical_address_array,
+		int    buffer_physical_address_array_size,
+		int    buffer_size,
+		int    buffer_type,
+		void   *dma_desc_mem_virtual_address,
+		int   *dma_desc_mem_physical_address_array,
+		int   *buffer_id,
+		void   **pY,
+		void   **pCb,
+		void   **pCr);
+
+/* Submit a buffer into the capture queue */
+int mcam_submit_buffer(
+		p_camera_context_t  camera_context,
+		int  buffer_id,
+		int  buffer_type);
+
+/* Get the buffer filled with valid frame data */
+int mcam_get_filled_buffer(
+		p_camera_context_t  camera_context,
+		int *buffer_id);
+
+/*
+ * Frame rate APIs
+ */
+
+/* Set desired frame rate */
+void mcam_set_capture_frame_rate(p_camera_context_t camera_context);
+
+/* return current setting */
+void mcam_get_capture_frame_rate(p_camera_context_t camera_context);
+
+/*
+ * Interrupt APIs
+ */
+
+/* set interrupt mask */
+void mcam_set_interrupt_mask(p_camera_context_t camera_context,
+		unsigned int mask);
+
+/* get interrupt mask */
+unsigned int mcam_get_interrupt_mask(p_camera_context_t camera_context);
+
+/* get interrupt status */
+unsigned int mcam_get_interrupt_status(p_camera_context_t camera_context);
+
+/* clear interrupt status */
+void mcam_clear_interrupt_status(p_camera_context_t camera_context,
+		unsigned int status);
+
+/*
+ * Sensor Control APIs
+ */
+
+/* CMOS sensor 8 bit register read */
+int mcam_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr, u8 *reg_val);
+
+/* CMOS sensor 8 bit register write */
+int mcam_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr, u8 reg_val);
+
+/* CMOS sensor 16-bit register read */
+int mcam_read_16bit(p_camera_context_t camera_context,
+		u16 reg_addr, u16 *reg_val);
+
+/* CMOS sensor 16 bit register write */
+int mcam_write_16bit(p_camera_context_t camera_context,
+		u16 reg_addr, u16 reg_val);
+
+/* CMOS sensor 32 bit register read */
+int mcam_read_32bit(p_camera_context_t camera_context,
+		u32 reg_addr, u32 *reg_val);
+
+/* CMOS sensor 32 bit register write */
+int mcam_write_32bit(p_camera_context_t camera_context,
+		u32 reg_addr, u32 reg_val);
+
+/* CMOS sensor Power Mode read */
+void mcam_get_power_mode (p_camera_context_t camera_context,
+		u8 *power_mode);
+
+/* CMOS sensor Power Mode write */
+int mcam_set_power_mode (p_camera_context_t camera_context, u8 power_mode);
+
+/* CMOS sensor Capability read */
+unsigned int mcam_get_caps (p_camera_context_t camera_context);
+
+/* CMOS sensor contrast value read */
+void mcam_get_contrast_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value);
+
+/* CMOS sensor contrast value write */
+int mcam_set_contrast_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value);
+
+/* CMOS sensor white balance value read */
+void mcam_get_white_balance_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value);
+
+/* CMOS sensor white balance value write */
+int mcam_set_white_balance_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value);
+
+/* CMOS sensor exposure value read */
+void mcam_get_exposure_value (p_camera_context_t camera_context,
+		unsigned char *mode, unsigned int *value);
+
+/* CMOS sensor exposure value write */
+int mcam_set_exposure_value (p_camera_context_t camera_context,
+		unsigned char mode, unsigned int value);
+
+/* CMOS sensor zoom value read */
+void mcam_get_zoom_value (p_camera_context_t camera_context,
+		unsigned int *value);
+
+/* CMOS sensor zoom value write */
+int mcam_set_zoom_value (p_camera_context_t camera_context, unsigned int value);
+
+/* get Histogram Info */
+int mcam_get_histogram_info(
+		p_camera_context_t     camera_context,
+		unsigned int                color_type,
+		unsigned int               *histogram_size,
+		unsigned int               *histogram_sum);
+
+/* sleep camera */
+int mcam_suspend(p_camera_context_t    camera_context);
+
+/* wakeup camera */
+int mcam_resume(p_camera_context_t    camera_context);
+
+#endif
+
+
Index: linux-2.6.10/drivers/media/video/monahans/ci.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ci.c
@@ -0,0 +1,966 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *     contains all primitive functions for Monahans Quick Capture Interface
+ *
+ * Notes:
+ *     Only valid for processor code named Monahans.
+ */
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/stddef.h>
+#include <asm/errno.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/hardware.h>
+#include "ci.h"
+
+/*
+ * Configuration APIs
+ */
+void ci_set_frame_rate(CI_FRAME_CAPTURE_RATE frate)
+{
+	unsigned int value;
+
+	/* write cicr4 */
+	value = CICR4;
+	value &= ~(CI_CICR4_FR_RATE_SMASK << CI_CICR4_FR_RATE_SHIFT);
+	value |= (unsigned)frate << CI_CICR4_FR_RATE_SHIFT;
+	CICR4 = value;
+}
+
+CI_FRAME_CAPTURE_RATE ci_get_frame_rate()
+{
+	unsigned int value;
+	value = CICR4;
+	return (CI_FRAME_CAPTURE_RATE)((value >> CI_CICR4_FR_RATE_SHIFT) &
+		CI_CICR4_FR_RATE_SMASK);
+}
+
+void ci_set_image_format(int input_format, int output_format)
+{
+	unsigned int value, tbit, rgbt_conv, rgb_conv, rgb_f;
+	unsigned int ycbcr_f, rgb_bpp, raw_bpp, cspace;
+
+	/* write cicr1: preserve ppl value and data width value */
+	value = CICR1;
+	value &= ((CI_CICR1_PPL_SMASK << CI_CICR1_PPL_SHIFT) |
+		((CI_CICR1_DW_SMASK) << CI_CICR1_DW_SHIFT));
+
+	tbit = rgbt_conv = rgb_conv = rgb_f = ycbcr_f = rgb_bpp	\
+		= raw_bpp = cspace = 0;
+
+	switch (input_format) {
+		case CI_RAW8:
+			cspace = 0;
+			raw_bpp = 0;
+			break;
+		case CI_RAW9:
+			cspace = 0;
+			raw_bpp = 1;
+			break;
+		case CI_RAW10:
+			cspace = 0;
+			raw_bpp = 2;
+			break;
+		case CI_YCBCR422:
+		case CI_YCBCR422_PLANAR:
+			cspace = 2;
+#if defined(CONFIG_PXA310)
+			if (output_format == CI_YCBCR422_PLANAR || output_format == CI_YCBCR420_PLANAR) {
+				ycbcr_f = 1;
+			}
+#else
+			if (output_format == CI_YCBCR422_PLANAR) {
+				ycbcr_f = 1;
+			}
+#endif
+			break;
+		case CI_RGB444:
+			cspace = 1;
+			rgb_bpp = 0;
+			break;
+		case CI_RGB555:
+			cspace = 1;
+			rgb_bpp = 1;
+			if (output_format == CI_RGBT555_0) {
+				rgbt_conv = 2;
+				tbit = 0;
+			}
+			else if (output_format == CI_RGBT555_1) {
+				rgbt_conv = 2;
+				tbit = 1;
+			}
+			break;
+		case CI_RGB565:
+			cspace = 3;
+			rgb_bpp = 2;
+			rgb_f = 1;
+			break;
+		case CI_RGB666:
+			cspace = 1;
+			rgb_bpp = 3;
+			if (output_format == CI_RGB666_PACKED) {
+				rgb_f = 1;
+			}
+			break;
+		case CI_RGB888:
+		case CI_RGB888_PACKED:
+			cspace = 1;
+			rgb_bpp = 4;
+			break;
+		default:
+			break;
+	}
+
+	switch (input_format) {
+		case CI_RAW8:
+		case CI_RAW9:
+		case CI_RAW10:
+#if defined(CONFIG_PXA310)
+			if (output_format == CI_YCBCR422_PLANAR || output_format == CI_YCBCR420_PLANAR) {
+				ycbcr_f = 1;
+			}
+#else
+			if (output_format == CI_YCBCR422_PLANAR) {
+				ycbcr_f = 1;
+			}
+#endif
+		case CI_RGB888:
+		case CI_RGB888_PACKED:
+			switch (output_format) {
+				case CI_RGB888_PACKED:
+					rgb_f = 1;
+					break;
+				case CI_RGBT888_0:
+					rgbt_conv = 1;
+					tbit = 0;
+					break;
+				case CI_RGBT888_1:
+					rgbt_conv = 1;
+					tbit = 1;
+					break;
+				case CI_RGB666:
+					rgb_conv = 1;
+					break;
+				case CI_RGB565:
+					rgb_conv = 2;
+					break;
+				case CI_RGB555:
+					rgb_conv = 3;
+					break;
+				case CI_RGB444:
+					rgb_conv = 4;
+					break;
+				default:
+					break;
+			}
+		default:
+			break;
+	}
+
+	value |= (tbit==1) ? CI_CICR1_TBIT : 0;
+	value |= rgbt_conv << CI_CICR1_RGBT_CONV_SHIFT;
+	value |= rgb_conv << CI_CICR1_RGB_CONV_SHIFT;
+	value |= (rgb_f==1) ? CI_CICR1_RBG_F : 0;
+	value |= (ycbcr_f==1) ? CI_CICR1_YCBCR_F : 0;
+	value |= rgb_bpp << CI_CICR1_RGB_BPP_SHIFT;
+	value |= raw_bpp << CI_CICR1_RAW_BPP_SHIFT;
+	value |= cspace << CI_CICR1_COLOR_SP_SHIFT;
+	CICR1 = value;
+}
+
+void ci_set_mode(CI_MODE mode, CI_DATA_WIDTH data_width)
+{
+	unsigned int value;
+
+	/* write mode field in cicr0 */
+	value = CICR0;
+	value &= ~(CI_CICR0_SIM_SMASK << CI_CICR0_SIM_SHIFT);
+	value |= (unsigned int)mode << CI_CICR0_SIM_SHIFT;
+	CICR0 = value;
+
+	/* write data width cicr1 */
+	value = CICR1;
+	value &= ~(CI_CICR1_DW_SMASK << CI_CICR1_DW_SHIFT);
+	value |= ((unsigned)data_width) << CI_CICR1_DW_SHIFT;
+	CICR1 = value;
+}
+
+void ci_configure_mp(unsigned int PPL, unsigned int LPF, CI_MP_TIMING* timing)
+{
+	unsigned int value;
+
+	/* write ppl field in cicr1 */
+	value = CICR1;
+	value &= ~(CI_CICR1_PPL_SMASK << CI_CICR1_PPL_SHIFT);
+	value |= (PPL & CI_CICR1_PPL_SMASK) << CI_CICR1_PPL_SHIFT;
+	CICR1 = value;
+
+	/* write BLW, ELW in cicr2 */
+	value = CICR2;
+	value &= ~((unsigned int)CI_CICR2_BLW_SMASK << CI_CICR2_BLW_SHIFT |
+		(unsigned int)CI_CICR2_ELW_SMASK << CI_CICR2_ELW_SHIFT);
+	value |= (timing->BLW & CI_CICR2_BLW_SMASK) << CI_CICR2_BLW_SHIFT;
+	CICR2 = value;
+
+	/* write BFW, LPF in cicr3 */
+	value = CICR3;
+	value &= ~((unsigned int)CI_CICR3_BFW_SMASK << CI_CICR3_BFW_SHIFT |
+		(unsigned int)CI_CICR3_LPF_SMASK << CI_CICR3_LPF_SHIFT);
+	value |= (timing->BFW & CI_CICR3_BFW_SMASK) << CI_CICR3_BFW_SHIFT;
+	value |= (LPF & CI_CICR3_LPF_SMASK) << CI_CICR3_LPF_SHIFT;
+	CICR3 = value;
+}
+
+void ci_configure_sp(unsigned int PPL, unsigned int LPF, CI_SP_TIMING* timing)
+{
+	unsigned int value;
+
+	/* write ppl field in cicr1 */
+	value = CICR1;
+	value &= ~(CI_CICR1_PPL_SMASK << CI_CICR1_PPL_SHIFT);
+	value |= (PPL & CI_CICR1_PPL_SMASK) << CI_CICR1_PPL_SHIFT;
+	CICR1 = value;
+
+	/* write cicr2 */
+	value |= (timing->BLW & CI_CICR2_BLW_SMASK) << CI_CICR2_BLW_SHIFT;
+	value |= (timing->ELW & CI_CICR2_ELW_SMASK) << CI_CICR2_ELW_SHIFT;
+	value |= (timing->HSW & CI_CICR2_HSW_SMASK) << CI_CICR2_HSW_SHIFT;
+	value |= (timing->BFPW & CI_CICR2_BFPW_SMASK) << CI_CICR2_BFPW_SHIFT;
+	value |= (timing->FSW & CI_CICR2_FSW_SMASK) << CI_CICR2_FSW_SHIFT;
+	CICR2 = value;
+
+	/* write cicr3 */
+	value |= (timing->BFW & CI_CICR3_BFW_SMASK) << CI_CICR3_BFW_SHIFT;
+	value |= (timing->EFW & CI_CICR3_EFW_SMASK) << CI_CICR3_EFW_SHIFT;
+	value |= (timing->VSW & CI_CICR3_VSW_SMASK) << CI_CICR3_VSW_SHIFT;
+	value |= (LPF & CI_CICR3_LPF_SMASK) << CI_CICR3_LPF_SHIFT;
+	CICR3 = value;
+}
+
+void ci_configure_ms(unsigned int PPL, unsigned int LPF, CI_MS_TIMING* timing)
+{
+	/* the operation is same as Master-Parallel */
+	ci_configure_mp(PPL, LPF, (CI_MP_TIMING*)timing);
+}
+
+void ci_configure_ep(int parity_check)
+{
+	unsigned int value;
+
+	/* write parity_enable field in cicr0 */
+	value = CICR0;
+	if (parity_check) {
+		value |= CICR0_PAR_EN;
+	}
+	else {
+		value &= ~CICR0_PAR_EN;
+	}
+	CICR0 = value;
+}
+
+void ci_configure_es(int parity_check)
+{
+	/* the operationi is same as Embedded-Parallel */
+	ci_configure_ep(parity_check);
+}
+
+void ci_set_clock(int pclk_enable, int mclk_enable, unsigned int mclk_mhz)
+{
+	unsigned int ciclk,  value, div, accr_hss, accr_d0cs, hss;
+	int p;
+	unsigned int x;
+
+	/* determine the LCLK frequency programmed into the ACCR */
+	accr_hss = (ACSR >> 14) & 0x3;
+	accr_d0cs = (ACSR >> 26) & 0x1;
+
+	hss = (accr_d0cs == 1)?60*100:
+		(accr_hss == 0x0)?104*100:
+		(accr_hss == 0x1)?156*100:
+		208*100;/*unit: 10KHZ*/
+
+#ifdef CONFIG_PXA310
+	ciclk = hss;
+#else
+	ciclk = hss/2;
+#endif
+
+	x = ((ciclk / mclk_mhz) - 2);
+	p =  x/2;
+
+	if (x%2)
+		div = p + 1;
+	else
+		div = p;
+
+	/* write cicr4 */
+	value = CICR4;
+	value &= ~(CI_CICR4_PCLK_EN | CI_CICR4_MCLK_EN |
+		CI_CICR4_DIV_SMASK<<CI_CICR4_DIV_SHIFT);
+	value |= (pclk_enable) ? CI_CICR4_PCLK_EN : 0;
+	value |= (mclk_enable) ? CI_CICR4_MCLK_EN : 0;
+	value |= div << CI_CICR4_DIV_SHIFT;
+	CICR4 = value;
+}
+
+void ci_set_polarity(int pclk_sample_falling,
+		int hsync_active_low, int vsync_active_low)
+{
+	unsigned int value;
+
+	/* write cicr4 */
+	value = CICR4;
+	value &= ~(CI_CICR4_PCP | CI_CICR4_HSP | CI_CICR4_VSP);
+	value |= (pclk_sample_falling)? CI_CICR4_PCP : 0;
+	value |= (hsync_active_low) ? CI_CICR4_HSP : 0;
+	value |= (vsync_active_low) ? CI_CICR4_VSP : 0;
+	CICR4 = value;
+}
+
+void ci_set_fifo(unsigned int timeout, CI_FIFO_THRESHOLD threshold,
+		int fifo1_enable, int fifo2_enable)
+{
+	unsigned int value;
+
+	/* write citor */
+	CITOR = timeout;
+
+	/* write cifr0: always enable fifo 0! also reset input fifo */
+	value = CIFR0;
+	value &= ~(CIFR_FEN0 | CIFR_FEN1 | CIFR_FEN2 | CIFR_RESET_F |
+			CI_CIFR_THL_0_SMASK<<CI_CIFR_THL_0_SHIFT);
+	value |= (unsigned int)threshold << CI_CIFR_THL_0_SHIFT;
+	value |= (fifo1_enable) ? CIFR_FEN1 : 0;
+	value |= (fifo2_enable) ? CIFR_FEN2 : 0;
+	value |= CIFR_RESET_F | CIFR_FEN0;
+	CIFR0 = value;
+}
+
+void ci_reset_fifo()
+{
+	unsigned int value;
+	value = CIFR0;
+	value |= CIFR_RESET_F;
+	CIFR0 = value;
+}
+
+void ci_set_interrupt_mask(unsigned int mask)
+{
+	unsigned int value;
+
+	/* write mask in cicr0 */
+	value = CICR0;
+	value &= ~CI_CICR0_INTERRUPT_MASK;
+	value |= (CICR0_VAL(mask) & CI_CICR0_INTERRUPT_MASK);
+	CICR0 = value;
+
+	/* write mask in cidcsr0 */
+	value = CIDCSR0;
+	value |= CIDCSR0_VAL(mask);
+	CIDCSR0 = value;
+
+	/* write mask in cidcsr1 */
+	value = CIDCSR1;
+	value |= CIDCSR1_VAL(mask);
+	CIDCSR1 = value;
+
+	/* write mask in cidcsr2 */
+	value = CIDCSR2;
+	value |= CIDCSR2_VAL(mask);
+	CIDCSR2 = value;
+
+	/* write mask in cidcsr3 */
+	value = CIDCSR3;
+	value |= CIDCSR3_VAL(mask);
+	CIDCSR3 = value;
+}
+
+unsigned int ci_get_interrupt_mask()
+{
+	unsigned int cicr0_val, cidcsr0_val;
+	unsigned int  cidcsr1_val, cidcsr2_val, cidcsr3_val;
+
+	/* get mask in cicr0 */
+	cicr0_val = CICR0;
+
+	/* get mask in cidcsr0 */
+	cidcsr0_val = CIDCSR0;
+
+	/* get mask in cidcsr1 */
+	cidcsr1_val = CIDCSR1;
+
+	/* get mask in cidcsr2 */
+	cidcsr2_val = CIDCSR2;
+
+	/* get mask in cidcsr3 */
+	cidcsr3_val = CIDCSR3;
+
+	return CI_INT_MASK(cicr0_val, cidcsr0_val,
+		cidcsr1_val, cidcsr2_val, cidcsr3_val);
+}
+
+void ci_clear_interrupt_status(unsigned int status)
+{
+	unsigned int cidcsr0_val, cidcsr1_val, cidcsr2_val, cidcsr3_val;
+
+	/* write 1 to clear cisr interrupt status */
+	CISR = CISR_VAL(status);
+
+	/* write 1 to clear cifsr interrupt status */
+	CIFSR = CIFSR_VAL(status);
+
+	/* write 1 to clear cidcsr0 interrupt status */
+	if (CIDCSR0_STATUS_VAL(status)) {	/* if DMA channel stopped */
+		CIDCSR0 = 0;		/* reset DMA channel */
+	}
+
+	/* write 1 to clear cidcsr1 interrupt status */
+	if (CIDCSR1_STATUS_VAL(status)) {	/* if DMA channel stopped */
+		CIDCSR1 = 0;		/* reset DMA channel */
+	}
+
+	/* write 1 to clear cidcsr2 interrupt status */
+	if (CIDCSR2_STATUS_VAL(status)) {	/* if DMA channe2 stopped */
+		CIDCSR2 = 0;		/* reset DMA channel */
+	}
+
+	/* write 1 to clear cidcsr3 interrupt status */
+	if (CIDCSR3_STATUS_VAL(status)) {	/* if DMA channe3 stopped */
+		CIDCSR3 = 0;		/* reset DMA channel */
+	}
+
+	/* write 1 to clear Bus error status */
+	if (status & (1UL << 28)) {
+		cidcsr0_val = CIDCSR0;
+		cidcsr0_val |= 0x1;
+		CIDCSR0 = cidcsr0_val;
+
+		cidcsr1_val = CIDCSR1;
+		cidcsr1_val |= 0x1;
+		CIDCSR1 = cidcsr1_val;
+
+		cidcsr2_val = CIDCSR2;
+		cidcsr3_val |= 0x1;
+		CIDCSR2 = cidcsr2_val;
+
+		cidcsr3_val = CIDCSR3;
+		cidcsr3_val |= 0x1;
+		CIDCSR3 = cidcsr3_val;
+	}
+}
+
+unsigned int ci_get_interrupt_status()
+{
+	unsigned int cisr_val, cifsr_val, cidcsr0_val;
+	unsigned int cidcsr1_val, cidcsr2_val, cidcsr3_val;
+
+	/* get interrupt status in cisr */
+	cisr_val = CISR;
+
+	/* get interrupt status in cifsr */
+	cifsr_val = CIFSR;
+
+	/* get interrupt status in cidcsr0 */
+	cidcsr0_val = CIDCSR0;
+
+	/* get interrupt status in cidcsr1 */
+	cidcsr1_val = CIDCSR1;
+
+	/* get interrupt status in cidcsr2 */
+	cidcsr2_val = CIDCSR2;
+
+	/* get interrupt status in cidcsr3 */
+	cidcsr3_val = CIDCSR3;
+
+	return CI_INT_STATUS(cisr_val, cifsr_val, cidcsr0_val,
+		cidcsr1_val, cidcsr2_val, cidcsr3_val);
+}
+
+#if defined(CONFIG_PXA310)
+int ci_set_ycbcr_420_down_sample (CI_CICR4_YCBCR_DOWN_SAMPLE ycbcr_ds)
+{
+	unsigned int value;
+
+	/* write cicr4 */
+	value = CICR4;
+	if (ycbcr_ds == CI_NO_DOWN_SAMPLE) {
+		value &= ~(CI_CICR4_YCBCR_DS);
+	} else {
+		value |= CI_CICR4_YCBCR_DS;
+	}
+	CICR4 = value;
+
+	return 0;
+}
+#endif
+
+/*
+ * Control APIs
+ */
+void ci_init()
+{
+	/* clear all CI registers */
+
+	/* disable all interrupts */
+	CICR0 = CI_CICR0_INTERRUPT_MASK;
+	CICR1 = 0;
+	CICR2 = 0;
+	CICR3 = 0;
+	CICR4 = 0;
+	CISR  = ~0;
+	CIFR0 = 0;
+	CITOR = 0;
+	CIRCD = 0xF0000000;
+}
+
+void ci_deinit()
+{
+}
+
+void ci_enable()
+{
+	unsigned int value;
+
+	/* write mask in cicr0 */
+	value = CICR0;
+	value |= CICR0_ENB;
+
+	CICR0 = value;
+}
+
+void ci_disable_complete()
+{
+	unsigned int value;
+
+	/* Clear the disable control bit */
+	value = CICR0;
+	value &= ~CICR0_DIS;
+	CICR0 = value;
+}
+
+int ci_disable(int quick, int wait_for_disable_complete)
+{
+	unsigned int value, mask;
+	int retry;
+
+
+	value = CICR0;
+	if (!(value&CICR0_ENB)) {
+		return 0;
+	}
+
+	value = CISR;
+	CISR = value;
+
+	/* write control bit in cicr0 */
+	value = CICR0;
+	if (quick) {
+		value &= ~CICR0_ENB;
+		mask = CI_CISR_CQD;
+	} else {
+		value |= CICR0_DIS;
+		mask = CI_CISR_CDD;
+	}
+	CICR0 = value;
+
+	if (wait_for_disable_complete) {
+		/* wait shutdown complete */
+		retry = 50;
+		while (retry-- > 0) {
+			value = CISR;
+			if (value & mask) {
+				CISR = mask;
+				return 0;
+			}
+			mdelay(10);
+		}
+	} else {
+		return 0;
+	}
+
+	return -1;
+}
+
+void ci_slave_capture_enable()
+{
+	unsigned int value;
+
+	/* write mask in cicr0 */
+	value = CICR0;
+	value |= CICR0_SL_CAP_EN;
+	CICR0 = value;
+}
+
+void ci_slave_capture_disable(void)
+{
+	unsigned int value;
+
+	/* write mask in cicr0 */
+	value = CICR0;
+	value &= ~CICR0_SL_CAP_EN;
+	CICR0 = value;
+}
+
+/*
+ * CI RAW data processing chain APIs
+ */
+int ci_hsu_get_histgram (CI_HSU_COLOR_TYPE  color_type,
+		CI_HSU_MUX_SEL_TYPE mux_select,
+		unsigned int *histogram_lut_buffer_virtual,
+		unsigned int  histogram_lut_buffer_physical,
+		unsigned int *histogram_lut_dma_descriptors_virtual,
+		unsigned int  histogram_lut_dma_descriptors_physical,
+		unsigned int  histogram_size,
+		unsigned int *histogram_sum)
+{
+	int tries;
+	volatile struct ci_dma_descriptor *dma_desc;
+	unsigned int reg_val;
+
+	if (histogram_lut_buffer_virtual == NULL) {
+		return -EINVAL;
+	}
+
+	/* enable FIFO3 */
+	reg_val = CIFR1;
+	reg_val |= CI_CIFR_FEN3;
+	CIFR1 = reg_val;
+
+	/* clear the CI sum register */
+	reg_val = 0x00000000;
+	CISUM = reg_val;
+
+	/* clear the CI Histgram RAM and EOF3 */
+	reg_val = CIHST;
+	reg_val |= CI_CIHST_CLR_RAM;
+	CIHST = reg_val;
+
+	CIFSR = CI_CIFSR_EOF3;
+
+	/* wait for rma clear interrupt */
+	for (tries = 5; tries >= 0; tries--) {
+		if (CISR & CI_CISR_HST_INT) {
+			CISR = CI_CISR_HST_INT;
+			break;
+		}
+		mdelay(10);
+
+		if (tries == 0) {
+			return -EBUSY;
+		}
+	}
+
+	/* configure the DMA for fifo3 */
+	dma_desc = (struct ci_dma_descriptor*)histogram_lut_dma_descriptors_virtual;
+	dma_desc->ddadr = histogram_lut_dma_descriptors_physical;
+	dma_desc->dsadr = __PREG_3(CIBR3);
+	dma_desc->dtadr = histogram_lut_buffer_physical;
+	dma_desc->dcmd  = CI_DMAC_DCMD_INC_TRG_ADDR | histogram_size;
+
+
+	ci_dma_load_descriptor(histogram_lut_dma_descriptors_physical,
+		CI_DMA_CHANNEL_3);
+
+	/* enable histgram */
+	reg_val = CIHST;
+	reg_val &= ~(CI_CIHST_COLOR_SEL_SMASK << CI_CIHST_COLOR_SEL_SHIFT);
+	reg_val |= (color_type << CI_CIHST_COLOR_SEL_SHIFT);
+	reg_val &= ~(CI_CIHST_SCALE_SMASK << CI_CIHST_SCALE_SHIFT);
+	reg_val |= (mux_select << CI_CIHST_SCALE_SHIFT);
+	CIHST = reg_val;
+
+	/* wait for fifo3 end of frame
+	 * WARNING: to judge if the getting histgram process is completed,
+	 *	    don't clear CI_INTSTATUS_EOF3 in  the interrupt handler!!!!!
+	 */
+	for (tries = 100; tries >= 0; tries--) {
+		reg_val = CIFSR;
+		if (reg_val & CI_CIFSR_EOF3) {
+			CIFSR = CI_CIFSR_EOF3;
+			break;
+		}
+		mdelay(10);
+		if (tries == 0)
+			return -EBUSY;
+	}
+
+	/* stop Histgram */
+	reg_val = CIHST;
+	reg_val &= ~(CI_CIHST_COLOR_SEL_SMASK << CI_CIHST_COLOR_SEL_SHIFT);
+	reg_val |= (0 << CI_CIHST_COLOR_SEL_SHIFT);
+	CIHST = reg_val;
+
+	/* disable FIFO3 */
+	reg_val = CIFR1;
+	reg_val &= ~CI_CIFR_FEN3;
+	CIFR1 = reg_val;
+
+	*histogram_sum = CISUM;
+
+	return 0;
+}
+
+int ci_psu_tag_bad_pixel(int column, int row)
+{
+	unsigned int reg_val;
+
+	reg_val = CIPBUF;
+
+	reg_val &= ~((CI_CIPBUF_DEADCOL_SMASK << CI_CIPBUF_DEADCOL_SHIFT) |
+			(CI_CIPBUF_DEADROW_SMASK << CI_CIPBUF_DEADROW_SHIFT));
+
+	reg_val |= ((column << CI_CIPBUF_DEADCOL_SHIFT) |
+			(row << CI_CIPBUF_DEADROW_SHIFT));
+
+	CIPBUF = reg_val;
+
+	return 0;
+}
+
+int ci_psu_enable(int enable)
+{
+	unsigned int reg_val;
+
+	reg_val = CIPSS;
+
+	if (enable) {
+		reg_val |= CIPSS_PSU_EN;
+	} else {
+		reg_val &= ~CIPSS_PSU_EN;
+	}
+
+	CIPSS = reg_val;
+
+	return 0;
+}
+
+int ci_cgu_set_black_level(unsigned char black_level)
+{
+	unsigned int reg_val;
+
+	reg_val = CICCR;
+
+	reg_val &= ~(CI_CICCR_BLC_SMASK << CI_CICCR_BLC_SHIFT);
+	reg_val &= ~(CI_CICCR_CLUT_SMASK << CI_CICCR_CLUT_SHIFT);
+	reg_val |= (black_level << CI_CICCR_BLC_SHIFT);
+
+	CICCR = reg_val;
+
+	return 0;
+}
+
+int ci_cgu_set_addr_mux_select(CI_CGU_MUX_SEL_TYPE mux_select)
+{
+	unsigned int reg_val;
+
+	reg_val = CICCR;
+
+	reg_val &= ~(CI_CICCR_SCALE_SMASK << CI_CICCR_SCALE_SHIFT);
+	reg_val |= (mux_select << CI_CICCR_SCALE_SHIFT);
+
+	CICCR = reg_val;
+
+	return 0;
+}
+
+int ci_cgu_load_lut_ram(
+		unsigned int  *histogram_lut_buffer_virtual,
+		unsigned int   histogram_lut_buffer_physical,
+		unsigned int  *histogram_lut_dma_descriptors_virtual,
+		unsigned int   histogram_lut_dma_descriptors_physical,
+		unsigned char *lut_ram)
+{
+	int tries;
+	volatile struct ci_dma_descriptor *dma_desc;
+	unsigned int reg_val;
+	int i;
+	unsigned char *src, *dst;
+
+	/* enable FIFO3 */
+	reg_val = CIFR1;
+	reg_val |= CI_CIFR_FEN3;
+	CIFR1 = reg_val;
+
+	/* clear CIFSR.EOF3 at first */
+	CIFSR = CI_CIFSR_EOF3;
+
+	/* memcopy the LUT data to the memory which can be used by DMA */
+	src = lut_ram;
+	dst = (unsigned char*)histogram_lut_buffer_virtual;
+	for (i = 0; i < 192; i++) {
+		*dst = *src;
+		dst++;
+		src++;
+	}
+
+	for (i=0; i<3; i++) {
+		/* configure the DMA for fifo3 */
+		dma_desc = (struct ci_dma_descriptor*)	\
+			histogram_lut_dma_descriptors_virtual;
+		dma_desc->ddadr = histogram_lut_dma_descriptors_physical;
+		dma_desc->dsadr = histogram_lut_buffer_physical + i*64;
+		dma_desc->dtadr = __PREG_3(CIBR3);
+		dma_desc->dcmd  = 64;
+		ci_dma_load_descriptor(histogram_lut_dma_descriptors_physical,
+			CI_DMA_CHANNEL_3);
+
+		/* start loading the LUT ram */
+		reg_val = CICCR;
+		reg_val &= ~(CI_CICCR_CLUT_SMASK << CI_CICCR_CLUT_SHIFT);
+		reg_val |= (CI_CICCR_CLUT_RED << CI_CICCR_CLUT_SHIFT);
+		reg_val |= CI_CICCR_LUT_LD;
+		CICCR = reg_val;
+
+		/* wait for LUT ram loading process completed */
+		for (tries = 100; tries >= 0; tries--) {
+			if ((CICCR & CI_CICCR_LUT_LD) == 0) {
+				break;
+			}
+			mdelay(10);
+
+			if (tries == 0) {
+				return -EBUSY;
+			}
+		}
+	}
+
+	/* disable FIFO3 */
+	reg_val = CIFR1;
+	reg_val &= ~CI_CIFR_FEN3;
+	CIFR1 = reg_val;
+
+	return 0;
+}
+
+int ci_cgu_enable(int enable)
+{
+	unsigned int reg_val;
+
+	reg_val = CICCR;
+
+	if (enable) {
+		reg_val |= CI_CICCR_EN;
+	} else {
+		reg_val &= ~CI_CICCR_EN;
+	}
+
+	CICCR = reg_val;
+
+	return 0;
+}
+
+int ci_ssu_set_scale(CI_SSU_SCALE scale)
+{
+	unsigned int reg_val;
+
+	reg_val = CISSC;
+
+	reg_val &= ~(CI_CISSC_SCALE_SMASK << CI_CISSC_SCALE_SHIFT);
+	reg_val |= (scale << CI_CISSC_SCALE_SHIFT);
+
+	CISSC = reg_val;
+
+	return 0;
+}
+
+int ci_cmu_set_color_correction_coe(CI_CMU_COE_MATRIX *coe_matrix)
+{
+	unsigned int reg_val;
+
+	/* set k00, k01, k02 to CICMC0 */
+	reg_val = CICMC0;
+	reg_val &= ~((CI_CICMC0_COF02_SMASK << CI_CICMC0_COF02_SHIFT) |
+			(CI_CICMC0_COF01_SMASK << CI_CICMC0_COF01_SHIFT) |
+			(CI_CICMC0_COF00_SMASK << CI_CICMC0_COF00_SHIFT));
+	reg_val |=  ((coe_matrix->k00 << CI_CICMC0_COF00_SHIFT) |
+			(coe_matrix->k01 << CI_CICMC0_COF01_SHIFT) |
+			(coe_matrix->k02 << CI_CICMC0_COF02_SHIFT));
+	CICMC0 = reg_val;
+
+	/* set k10, k11, k12 to CICMC1 */
+	reg_val = CICMC1;
+	reg_val &= ~((CI_CICMC1_COF12_SMASK << CI_CICMC1_COF12_SHIFT) |
+			(CI_CICMC1_COF11_SMASK << CI_CICMC1_COF11_SHIFT) |
+			(CI_CICMC1_COF10_SMASK << CI_CICMC1_COF10_SHIFT));
+	reg_val |=  ((coe_matrix->k10 << CI_CICMC1_COF10_SHIFT) |
+			(coe_matrix->k11 << CI_CICMC1_COF11_SHIFT) |
+			(coe_matrix->k12 << CI_CICMC1_COF12_SHIFT));
+	CICMC1 = reg_val;
+
+	/* set k20, k21, k22 to CICMC2 */
+	reg_val = CICMC2;
+	reg_val &= ~((CI_CICMC2_COF22_SMASK << CI_CICMC2_COF22_SHIFT) |
+			(CI_CICMC2_COF21_SMASK << CI_CICMC2_COF21_SHIFT) |
+			(CI_CICMC2_COF20_SMASK << CI_CICMC2_COF20_SHIFT));
+	reg_val |=  ((coe_matrix->k20 << CI_CICMC2_COF20_SHIFT) |
+			(coe_matrix->k21 << CI_CICMC2_COF21_SHIFT) |
+			(coe_matrix->k22 << CI_CICMC2_COF22_SHIFT));
+	CICMC2 = reg_val;
+
+	return 0;
+}
+
+int ci_cmu_enable(CI_CMU_USAGE cmu_usage)
+{
+	unsigned int reg_val;
+
+	reg_val = CICMR;
+
+	reg_val &= ~(CI_CICMR_DMODE_SMASK << CI_CICMR_DMODE_SHIFT);
+	reg_val |= (cmu_usage << CI_CICMR_DMODE_SHIFT);
+
+	CICMR = reg_val;
+
+	return 0;
+}
+
+/*
+ * CI dedicated DMAC APIs
+ */
+int ci_dma_load_descriptor(unsigned int dma_desc_phy, CI_DMA_CHANNEL channel)
+{
+	*(&CIDADR0 + channel*4) = dma_desc_phy;
+
+	return 0;
+}
+
+int ci_dma_set_branch (
+		unsigned int branch_to_dma_desc_phy,
+		int branch_int_enable,
+		int branch_after_cur_frame,
+		CI_DMA_CHANNEL channel)
+{
+	unsigned int reg_val;
+
+	/* note: to enable Branch Interrupt, CI_INT_BS should be enabled
+	 * as well as branch_int_enable is set as 1
+	 */
+	reg_val = (branch_to_dma_desc_phy & CI_CIDBR_SRCADDR_SMASK);
+	reg_val |= (branch_int_enable == 1)?CI_CIDBR_BINT:0;
+	reg_val |= (branch_after_cur_frame == 1)?CI_CIDBR_BRA:0;
+
+	*(&CIDBR0 + channel) = reg_val;
+
+	return 0;
+}
+
Index: linux-2.6.10/drivers/media/video/monahans/ci.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ci.h
@@ -0,0 +1,739 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *   Contains all Monahans QCI specific macros, typedefs, and prototypes.
+ *   Declares no storage.
+ * Notes:
+ *   Only valid for processor code named Monahans.
+ */
+
+
+#ifndef __MONAHANS_CI_HEADER__
+#define __MONAHANS_CI_HEADER__
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <linux/pxa_camera_zl.h>
+
+/*
+ * Register definitions
+ */
+
+#define	CI_CICR0_SIM_SHIFT		24
+#define	CI_CICR0_SIM_SMASK		0x7
+#define	CI_CICR0_INTERRUPT_MASK		(CICR0_FOM | CICR0_EOFM | \
+		CICR0_SOFM | CICR0_CDM | \
+		CICR0_QDM | CICR0_PERRM | \
+		CICR0_EOLM | CICR0_FEM | \
+		CICR0_TOM | CICR0_FUM | \
+		CICR0_BSM | CICR0_EOFXM)
+
+#define CI_CICR1_DW_SHIFT		0
+#define CI_CICR1_DW_SMASK		0x7
+#define CI_CICR1_COLOR_SP_SHIFT		3
+#define CI_CICR1_COLOR_SP_SMASK		0x3
+#define CI_CICR1_RAW_BPP_SHIFT		5
+#define CI_CICR1_RAW_BPP_SMASK		0x3
+#define CI_CICR1_RGB_BPP_SHIFT		7
+#define CI_CICR1_RGB_BPP_SMASK		0x7
+#define CI_CICR1_YCBCR_F		(1UL << 10)
+#define CI_CICR1_RBG_F			(1UL << 11)
+#define CI_CICR1_RGB_CONV_SHIFT		12
+#define CI_CICR1_RGB_CONV_SMASK		0x7
+#define CI_CICR1_PPL_SHIFT		15
+#define CI_CICR1_PPL_SMASK		0xFFF
+#define CI_CICR1_RESERVED		0x1C000000
+#define CI_CICR1_RGBT_CONV_SHIFT	9
+#define CI_CICR1_RGBT_CONV_SMASK	0x3
+#define CI_CICR1_TBIT			(1UL << 31)
+
+
+#define CI_CICR2_FSW_SHIFT	0
+#define CI_CICR2_FSW_SMASK	0x3
+#define CI_CICR2_BFPW_SHIFT	3
+#define CI_CICR2_BFPW_SMASK	0x3F
+#define CI_CICR2_RESERVED	0x00000200
+#define CI_CICR2_HSW_SHIFT	10
+#define CI_CICR2_HSW_SMASK	0x3F
+#define CI_CICR2_ELW_SHIFT	16
+#define CI_CICR2_ELW_SMASK	0xFF
+#define CI_CICR2_BLW_SHIFT	24
+#define CI_CICR2_BLW_SMASK	0xFF
+
+#define CI_CICR3_LPF_SHIFT	0
+#define CI_CICR3_LPF_SMASK	0x7FF
+#define CI_CICR3_VSW_SHIFT	11
+#define CI_CICR3_VSW_SMASK	0x1F
+#define CI_CICR3_EFW_SHIFT	16
+#define CI_CICR3_EFW_SMASK	0xFF
+#define CI_CICR3_BFW_SHIFT	24
+#define CI_CICR3_BFW_SMASK	0xFF
+
+#define CI_CICR4_DIV_SHIFT	0
+#define CI_CICR4_DIV_SMASK	0xFF
+#define CI_CICR4_FR_RATE_SHIFT	8
+#define CI_CICR4_FR_RATE_SMASK	0x7
+#define CI_CICR4_RESERVED1	0x0007F800
+#define CI_CICR4_MCLK_EN	(1UL << 19)
+#define CI_CICR4_VSP		(1UL << 20)
+#define CI_CICR4_HSP		(1UL << 21)
+#define CI_CICR4_PCP		(1UL << 22)
+#define CI_CICR4_PCLK_EN	(1UL << 23)
+#if defined(CONFIG_PXA310)
+#define CI_CICR4_YCBCR_DS	(1UL << 27)
+#define CI_CICR4_RESERVED2	0xF7000000
+#else
+#define CI_CICR4_RESERVED2	0xFF000000
+#endif
+#define CI_CICR4_RESERVED	(CI_CICR4_RESERVED1|CI_CICR4_RESERVED2)
+
+#define CI_CISR_EOF          (1 << 3)
+#define CI_CISR_SOF          (1 << 4)
+#define CI_CISR_CDD          (1 << 5)
+#define CI_CISR_CQD          (1 << 6)
+#define CI_CISR_PAR_ERR      (1 << 7)
+#define CI_CISR_EOL          (1 << 8)
+#define CI_CISR_HST_INT      (1 << 9)
+#define CI_CISR_CGU_INT      (1 << 10)
+#define CI_CISR_FTO          (1 << 15)
+#define CI_CISR_EOFX         (1 << 30)
+#define CI_CISR_SINT         (1 << 31)
+#define	CI_CISR_MASK	(CI_CISR_EOF | CI_CISR_SOF | CI_CISR_CDD | \
+		CI_CISR_CQD | CI_CISR_PAR_ERR | CI_CISR_EOL | \
+		CI_CISR_CGU_INT|CI_CISR_FTO | \
+		CI_CISR_EOFX | CI_CISR_SINT)
+
+
+#define	CI_CIFSR_EOF3	(1 << 10)
+
+
+#define	CIPSS_PSU_EN	(1 << 31)
+
+#define	CI_CIPBUF_DEADROW_SHIFT	0
+#define	CI_CIPBUF_DEADROW_SMASK	0xFFF
+#define	CI_CIPBUF_DEADCOL_SHIFT	16
+#define	CI_CIPBUF_DEADCOL_SMASK	0xFFF
+
+#define CI_CIHST_COLOR_SEL_SHIFT	0
+#define CI_CIHST_COLOR_SEL_SMASK	0xF
+#define CI_CIHST_COLOR_RED		0x1
+#define CI_CIHST_COLOR_BLUE		0x2
+#define CI_CIHST_COLOR_GREEN1		0x4
+#define CI_CIHST_COLOR_GREEN2		0x8
+#define CI_CIHST_SCALE_SHIFT		4
+#define CI_CIHST_SCALE_SMASK		0x3
+#define CI_CIHST_SCALE_0_TO_7		0x0
+#define CI_CIHST_SCALE_0_TO_8		0x1
+#define CI_CIHST_SCALE_1_TO_9		0x2
+#define CI_CIHST_CLR_RAM		(1 << 6)
+
+#define CI_CICCR_EN		(1 << 0)
+#define CI_CICCR_SCALE_SHIFT	1
+#define CI_CICCR_SCALE_SMASK	0x3
+#define CI_CICCR_SCALE_0_TO_7	0x0
+#define CI_CICCR_SCALE_1_TO_8	0x1
+#define CI_CICCR_SCALE_2_TO_9	0x2
+#define CI_CICCR_CLUT_SHIFT	3
+#define CI_CICCR_CLUT_SMASK	0xFF
+#define CI_CICCR_CLUT_RED	0x00
+#define CI_CICCR_CLUT_BLUE	0x20
+#define CI_CICCR_CLUT_GREEN	0x40
+#define CI_CICCR_BLC_SHIFT	11
+#define CI_CICCR_BLC_SMASK	0xFF
+#define CI_CICCR_LUT_LD		(1 << 19)
+
+#define CI_CISSC_SCALE_SHIFT	0
+#define CI_CISSC_SCALE_SMASK	0x3
+#define CI_CISSC_SCALE_DISABLE	0x0
+#define CI_CISSC_SCALE_2_TO_1	0x1
+#define CI_CISSC_SCALE_4_TO_1	0x2
+
+#define CI_CICMR_DMODE_SHIFT	0
+#define CI_CICMR_DMODE_SMASK	0x3
+#define CI_CICMR_DMODE_DISABLE	0x0
+#define CI_CICMR_DMODE_RGB	0x1
+#define CI_CICMR_DMODE_YUV	0x2
+
+#define CI_CICMC0_COF02_SHIFT	0
+#define CI_CICMC0_COF02_SMASK	0x3FF
+
+#define CI_CICMC0_COF01_SHIFT	10
+#define CI_CICMC0_COF01_SMASK	0x3FF
+
+#define CI_CICMC0_COF00_SHIFT	20
+#define CI_CICMC0_COF00_SMASK	0x3FF
+
+#define CI_CICMC1_COF12_SHIFT	0
+#define CI_CICMC1_COF12_SMASK	0x3FF
+
+#define CI_CICMC1_COF11_SHIFT	10
+#define CI_CICMC1_COF11_SMASK	0x3FF
+
+#define CI_CICMC1_COF10_SHIFT	20
+#define CI_CICMC1_COF10_SMASK	0x3FF
+
+#define CI_CICMC2_COF22_SHIFT	0
+#define CI_CICMC2_COF22_SMASK	0x3FF
+
+#define CI_CICMC2_COF21_SHIFT	10
+#define CI_CICMC2_COF21_SMASK	0x3FF
+
+#define CI_CICMC2_COF20_SHIFT	20
+#define CI_CICMC2_COF20_SMASK	0x3FF
+
+
+#define CI_CIFR_THL_0_SHIFT	4
+#define CI_CIFR_THL_0_SMASK	0x3
+
+#define CI_CIFR_RESERVED1	0x000000C0
+
+#define CI_CIFR_FLVL0_SHIFT	8
+#define CI_CIFR_FLVL0_SMASK	0xFF
+
+#define CI_CIFR_FLVL1_SHIFT	16
+#define CI_CIFR_FLVL1_SMASK	0x7F
+
+#define CI_CIFR_FLVL2_SHIFT	23
+#define CI_CIFR_FLVL2_SMASK	0x7F
+
+#define CI_CIFR_RESERVED2	0xC0000000
+#define CI_CIFR_RESERVED	CI_CIFR_RESERVED1 | CI_CIFR_RESERVED2
+
+#define	CI_CIFR_FEN3		(1 << 0)
+#define	CI_CIFR_FLVL3_SHIFT	1
+#define	CI_CIFR_FLVL3_SMASK	0xFF
+
+#define	CI_CIDBR_BRA		(1 << 0)
+#define	CI_CIDBR_BINT		(1 << 1)
+#define	CI_CIDBR_SRCADDR_SMASK	0xFFFFFFF0
+
+/*
+ * Parameter Type definitions
+ */
+enum pxa_image_format {
+	CI_RAW8	= 0,		/* RAW */
+	CI_RAW9,
+	CI_RAW10,
+	CI_YCBCR422,		/* YCBCR */
+	CI_YCBCR422_PLANAR,	/* YCBCR Planaried */
+	CI_RGB444,		/* RGB */
+	CI_RGB555,
+	CI_RGB565,
+	CI_RGB666,
+	CI_RGB888,
+	CI_RGBT555_0,		/* RGB+Transparent bit 0 */
+	CI_RGBT888_0,
+	CI_RGBT555_1,		/* RGB+Transparent bit 1 */
+	CI_RGBT888_1,
+	CI_RGB666_PACKED,	/* RGB Packed */
+	CI_RGB888_PACKED,
+#if defined(CONFIG_PXA310)
+	CI_YCBCR420,
+	CI_YCBCR420_PLANAR,
+#endif
+	CI_INVALID_FORMAT =	0xFF
+};
+
+/* Interrupt mask */
+#define CI_INT_IFO	(1 << 0)   /* FIFO Overrun Mask */
+#define CI_INT_EOF	(1 << 1)   /* QCI End-of-Frame Mask */
+#define CI_INT_SOF	(1 << 2)   /* QCI Start-of-Frame Mask */
+#define CI_INT_CDD	(1 << 3)   /* QCI Disable Done Mask */
+#define CI_INT_CQD	(1 << 4)   /* QCI Quick Disable Mask */
+#define CI_INT_PAR_ERR	(1 << 5)   /* Parity Error Mask */
+#define CI_INT_EOL	(1 << 6)   /* End-of-Line Mask */
+#define CI_INT_FEMPTY	(1 << 7)   /* FIFO Empty Mask */
+#define CI_INT_FTO	(1 << 9)   /* Time-Out Mask */
+#define CI_INT_FU	(1 << 10)  /* Input FIFO Underrun Mask Channel 3 */
+#define CI_INT_BS	(1 << 11)  /* Branch Status Mask */
+#define CI_INT_EOFX	(1 << 12)  /* End-of-Frame Transfer to Memory Mask */
+#define CI_INT_SC0	(1 << 13)  /* Stop Channel Interrupt Mask Channel 0*/
+#define CI_INT_SC1	(1 << 14)  /* Stop Channel Interrupt Mask Channel 1*/
+#define CI_INT_SC2	(1 << 15)  /* Stop Channel Interrupt Mask Channel 2*/
+#define CI_INT_SC3	(1 << 16)  /* Stop Channel Interrupt Mask Channel 3*/
+
+#define CICR0_VAL(ci_int_mask) \
+	((ci_int_mask) & CI_CICR0_INTERRUPT_MASK)
+
+/* convert CI_INT_SC0 to CIDCSR0[StopIrqEn] */
+#define CIDCSR0_VAL(ci_int_mask) \
+	(((!((ci_int_mask) & (1UL << 13))) >> 13) << 29)
+
+/* convert CI_INT_SC1 to CIDCSR1[StopIrqEn] */
+#define CIDCSR1_VAL(ci_int_mask) \
+	(((!((ci_int_mask) & (1UL << 14))) >> 14) << 29)
+
+/* convert CI_INT_SC2 to CIDCSR2[StopIrqEn] */
+#define CIDCSR2_VAL(ci_int_mask) \
+	(((!((ci_int_mask) & (1UL << 15))) >> 15) << 29)
+
+/* convert CI_INT_SC3 to CIDCSR3[StopIrqEn] */
+#define CIDCSR3_VAL(ci_int_mask) \
+	(((!((ci_int_mask) & (1UL << 16))) >> 16) << 29)
+
+#define CI_INT_MASK(cicr0_val, cidcsr0_val, cidcsr1_val,\
+		cidcsr2_val, cidcsr3_val) \
+	(((cicr0_val) & CI_CICR0_INTERRUPT_MASK) | \
+	 ((!((cidcsr0_val) & (1UL << 29))) << 13) | \
+	 ((!((cidcsr1_val) & (1UL << 29))) << 14) | \
+	 ((!((cidcsr2_val) & (1UL << 29))) << 15) | \
+	 ((!((cidcsr3_val) & (1UL << 29))) << 16)   \
+)
+
+/*
+   notes:
+
+   mapping between ci_int_mask and related registers bits:
+   ci_int_mask:
+
+  0  CICR0[FOM]
+  1  CICR0[EOFM]
+  2  CICR0[SOFM]
+  3  CICR0[CDM]
+  4  CICR0[QDM]
+  5  CICR0[PERRM]
+  6  CICR0[EOLM]
+  7  CICR0[FEM]
+  8  N/A
+  9  CICR0[TOM]
+  10  CICR0[FUM]
+  11  CICR0[BSM]
+  12  CICR0[EOFM]
+  13  CIDCSR0[StopIrqEn]
+  14  CIDCSR1[StopIrqEn]
+  15  CIDCSR2[StopIrqEn]
+  16  CIDCSR3[StopIrqEn]
+  17  N/A
+  18  N/A
+  19  N/A
+  20  N/A
+  21  N/A
+  22  N/A
+  23  N/A
+  24  N/A
+  25  N/A
+  26  N/A
+  27  N/A
+  28  N/A
+  29  N/A
+  30  N/A
+  31  N/A
+
+#define CI_INT_MASK(cicr0_val, cidcsr0_val, cidcsr1_val,	\
+			cidcsr2_val, cidcsr3_val) \
+	(((cicr0_val) & CI_CICR0_INTERRUPT_MASK) | \
+	((!((cidcsr0_val) & (1UL << 29))) << 13) | \
+	((!((cidcsr1_val) & (1UL << 29))) << 14) | \
+	((!((cidcsr2_val) & (1UL << 29))) << 15) | \
+	((!((cidcsr3_val) & (1UL << 29))) << 16)   \
+)
+ */
+
+/* Interrupt status */
+
+/* End-of-Frame for Channel 3, depending on Channel 0
+ * DMA channel descriptor Chain configuration
+ */
+#define CI_INTSTATUS_EOF3              (1 << 0)
+/* FIFO Underrun for Channel 3, masked by CI_INT_FU */
+#define CI_INTSTATUS_FU_3              (1 << 1)
+/* End-of-Frame, masked by CI_INT_EOF */
+#define CI_INTSTATUS_EOF               (1 << 3)
+/* Start-of-Frame, masked by CI_INT_SOF */
+#define CI_INTSTATUS_SOF               (1 << 4)
+/* Quick Capture Interface Disable Done, masked by CI_INT_CDD */
+#define CI_INTSTATUS_CDD               (1 << 5)
+/* Quick Capture Interface Quick Disable Status, masked by CI_INT_CQD */
+#define CI_INTSTATUS_CQD               (1 << 6)
+/* Parity Error, masked by CI_INT_PAR_ERR */
+#define CI_INTSTATUS_PAR_ERR           (1 << 7)
+/* End of Line, masked by CI_INT_EOL */
+#define CI_INTSTATUS_EOL               (1 << 8)
+/* Histogram Interrupt, unmaskable */
+#define CI_INTSTATUS_HST_INT           (1 << 9)
+/* Compander Interrupt, unmaskable */
+#define CI_INTSTATUS_CGC_INT           (1 << 10)
+/* FIFO Overrun for Channel 0, masked by CI_INT_IFO */
+#define CI_INTSTATUS_IFO_0             (1 << 11)
+/* FIFO Overrun for Channel 1, masked by CI_INT_IFO */
+#define CI_INTSTATUS_IFO_1             (1 << 12)
+/* FIFO Overrun for Channel 2, masked by CI_INT_IFO */
+#define CI_INTSTATUS_IFO_2             (1 << 13)
+/* FIFO Overrun for Channel 3, masked by CI_INT_IFO */
+#define CI_INTSTATUS_IFO_3             (1 << 14)
+/* FIFO Time-out, masked by CI_INT_FTO */
+#define CI_INTSTATUS_FTO               (1 << 15)
+/* Branch Status for Channel 0, masked by CI_INT_BS */
+#define CI_INTSTATUS_BS0               (1 << 16)
+/* Branch Status for Channel 1, masked by CI_INT_BS */
+#define CI_INTSTATUS_BS1               (1 << 17)
+/* Branch Status for Channel 2, masked by CI_INT_BS */
+#define CI_INTSTATUS_BS2               (1 << 18)
+/* Branch Status for Channel 3, masked by CI_INT_BS */
+#define CI_INTSTATUS_BS3               (1 << 19)
+/* Start-of-Frame for Channel 0, depending on Channel 0
+ * DMA channel descriptor Chain configuration
+ */
+#define CI_INTSTATUS_SOF0              (1 << 20)
+/* Start-of-Frame for Channel 1, depending on Channel 1
+ * DMA channel descriptor Chain configuration
+ */
+#define CI_INTSTATUS_SOF1              (1 << 21)
+/* Start-of-Frame for Channel 2, depending on Channel 2
+ * DMA channel descriptor Chain configuration
+ */
+#define CI_INTSTATUS_SOF2              (1 << 22)
+/* Start-of-Frame for Channel 3, depending on Channel 3
+ * DMA channel descriptor Chain configuration
+ */
+#define CI_INTSTATUS_SOF3              (1 << 23)
+/* Stop interrupt Channel 0, masked by CI_INT_SC0 */
+#define CI_INTSTATUS_SC0               (1 << 24)
+/* Stop interrupt Channel 1, masked by CI_INT_SC1 */
+#define CI_INTSTATUS_SC1               (1 << 25)
+/* Stop interrupt Channel 2, masked by CI_INT_SC2 */
+#define CI_INTSTATUS_SC2               (1 << 26)
+/* Stop interrupt Channel 3, masked by CI_INT_SC3 */
+#define CI_INTSTATUS_SC3               (1 << 27)
+/* Bus error in One or more DMA channels */
+#define CI_INTSTATUS_BUSERR            (1 << 28)
+/* Subsequent Interrupt Status, unmaskable */
+#define CI_INTSTATUS_SINT              (1 << 31)
+/* End-of-Frame Transferred to Memory (Channel 0-2,
+ * not Channel 3) masked by CI_INT_EOFX
+ */
+#define CI_INTSTATUS_EOFX              (1 << 30)
+
+#define CISR_VAL(ci_int_status) \
+	((ci_int_status) & CI_CISR_MASK)
+
+#define CIFSR_VAL(ci_int_status) (\
+	  ((((ci_int_status) & (0xf << 11)) >> 11) <<  0) | \
+	  ((((ci_int_status) & (0x1 <<  1)) >>  1) << 28) | \
+	  ((((ci_int_status) & (0xf << 16)) >> 16) << 21) | \
+	  ((((ci_int_status) & (0x1 <<  0)) >>  0) << 10) | \
+	  ((((ci_int_status) & (0xf << 20)) >> 20) << 14)   \
+	)
+
+#define CIDCSR0_STATUS_VAL(ci_int_status) \
+	((((ci_int_status) & (0x1 << 24)) >> 24) << 3)
+
+#define CIDCSR1_STATUS_VAL(ci_int_status) \
+	((((ci_int_status) & (0x1 << 25)) >> 25) << 3)
+
+#define CIDCSR2_STATUS_VAL(ci_int_status) \
+	((((ci_int_status) & (0x1 << 26)) >> 26) << 3)
+
+#define CIDCSR3_STATUS_VAL(ci_int_status) \
+	((((ci_int_status) & (0x1 << 27)) >> 27) << 3)
+
+#define CI_INT_STATUS(cisr_val, cifsr_val, cidcsr0_val,		\
+		 cidcsr1_val, cidcsr2_val, cidcsr3_val)		\
+	(((cisr_val) & CI_CISR_MASK) |				\
+	 ((((cifsr_val)   & (0xf <<  0)) >>  0) << 11) |	\
+	 ((((cifsr_val)   & (0x1 << 10)) >> 10) <<  0) |	\
+	 ((((cifsr_val)   & (0xf << 14)) >> 14) << 20) |	\
+	 ((((cifsr_val)   & (0xf << 21)) >> 21) << 16) |	\
+	 ((((cifsr_val)   & (0x1 << 28)) >> 28) <<  1) |	\
+	 ((((cidcsr0_val) & (0x1 <<  3)) >>  3) << 24) |	\
+	 ((((cidcsr1_val) & (0x1 <<  3)) >>  3) << 25) |	\
+	 ((((cidcsr2_val) & (0x1 <<  3)) >>  3) << 26) |	\
+	 ((((cidcsr3_val) & (0x1 <<  3)) >>  3) << 27) |	\
+	 ((((cidcsr0_val) & (0x1 <<  0)) >>  0) << 28) |	\
+	 ((((cidcsr1_val) & (0x1 <<  0)) >>  0) << 28) |	\
+	 ((((cidcsr2_val) & (0x1 <<  0)) >>  0) << 28) |	\
+	 ((((cidcsr3_val) & (0x1 <<  0)) >>  0) << 28)		\
+	)
+
+/*
+   note:
+
+   mapping between ci_int_status and related registers bits:
+   ci_int_status:
+  0   CIFSR[EOF3]
+  1   CIFSR[FU_3]
+  2   N/A
+  3   CISR[EOF]
+  4   CISR[SOF]
+  5   CISR[CDD]
+  6   CISR[CQD]
+  7   CISR[PAR_ERR]
+  8   CISR[EOL]
+  9   CISR[HST_INT]
+  10  CISR[CGC_INT]
+  11  CIFSR[IFO_0]
+  12  CIFSR[IFO_1]
+  13  CIFSR[IFO_2]
+  14  CIFSR[IFO_3]
+  15  CISR[FTO]
+  16  CIFSR[BS0]
+  17  CIFSR[BS1]
+  18  CIFSR[BS2]
+  19  CIFSR[BS3]
+  20  CIFSR[SOF0]
+  21  CIFSR[SOF1]
+  22  CIFSR[SOF2]
+  23  CIFSR[SOF3]
+  24  CIDCSR0[StopIrq]
+  25  CIDCSR1[StopIrq]
+  26  CIDCSR2[StopIrq]]
+  27  CIDCSR3[StopIrq]
+  28  CIDCSR0[BusErrIntr] | CIDCSR1[BusErrIntr] | CIDCSR2[BusErrIntr]| CIDCSR3[BusErrIntr]
+  29  N/A
+  30  CISR[EOFX]
+  31  CISR[SINT]
+*/
+
+typedef enum CI_MODE{
+	CI_MODE_MP,             /* Master-Parallel */
+	CI_MODE_SP,             /* Slave-Parallel */
+	CI_MODE_MS,             /* Master-Serial */
+	CI_MODE_EP,             /* Embedded-Parallel */
+	CI_MODE_ES              /* Embedded-Serial */
+} CI_MODE;
+
+
+typedef enum  {
+	CI_FR_ALL = 0,          /* Capture all incoming frames */
+	CI_FR_1_2,              /* Capture 1 out of every 2 frames */
+	CI_FR_1_3,              /* Capture 1 out of every 3 frames */
+	CI_FR_1_4,
+	CI_FR_1_5,
+	CI_FR_1_6,
+	CI_FR_1_7,
+	CI_FR_1_8
+} CI_FRAME_CAPTURE_RATE;
+
+
+typedef enum  {
+	CI_FIFO_THL_32 = 0,
+	CI_FIFO_THL_64,
+	CI_FIFO_THL_96
+} CI_FIFO_THRESHOLD;
+
+typedef struct {
+	unsigned int BFW;
+	unsigned int BLW;
+} CI_MP_TIMING, CI_MS_TIMING;
+
+typedef struct {
+	unsigned int BLW;
+	unsigned int ELW;
+	unsigned int HSW;
+	unsigned int BFPW;
+	unsigned int FSW;
+	unsigned int BFW;
+	unsigned int EFW;
+	unsigned int VSW;
+} CI_SP_TIMING;
+
+typedef enum {
+	CI_DATA_WIDTH4 = 0x0,
+	CI_DATA_WIDTH5 = 0x1,
+	CI_DATA_WIDTH8 = 0x2,
+	CI_DATA_WIDTH9 = 0x3,
+	CI_DATA_WIDTH10= 0x4
+} CI_DATA_WIDTH;
+
+#if defined(CONFIG_PXA310)
+typedef enum {
+	CI_NO_DOWN_SAMPLE,
+	CI_YUV_420_DOWN_SAMPLE,
+} CI_CICR4_YCBCR_DOWN_SAMPLE;
+#endif
+
+/*
+ * Configuration APIs
+ */
+void ci_set_frame_rate(CI_FRAME_CAPTURE_RATE frate);
+CI_FRAME_CAPTURE_RATE ci_get_frame_rate(void);
+void ci_set_image_format(int input_format, int output_format);
+void ci_set_mode(CI_MODE mode, CI_DATA_WIDTH data_width);
+void ci_configure_mp(unsigned int PPL, unsigned int LPF, CI_MP_TIMING* timing);
+void ci_configure_sp(unsigned int PPL, unsigned int LPF, CI_SP_TIMING* timing);
+void ci_configure_ms(unsigned int PPL, unsigned int LPF, CI_MS_TIMING* timing);
+void ci_configure_ep(int parity_check);
+void ci_configure_es(int parity_check);
+void ci_set_clock(int pclk_enable, int mclk_enable, unsigned int mclk_mhz);
+void ci_set_polarity(int pclk_sample_falling, int hsync_active_low,
+	int vsync_active_low);
+void ci_set_fifo(unsigned int timeout, CI_FIFO_THRESHOLD threshold,
+	int fifo1_enable, int fifo2_enable);
+void ci_reset_fifo(void);
+void ci_set_interrupt_mask(unsigned int mask);
+unsigned int ci_get_interrupt_mask(void);
+void ci_clear_interrupt_status(unsigned int status);
+unsigned int ci_get_interrupt_status(void);
+void ci_disable_complete(void);
+
+#if defined(CONFIG_PXA310)
+int ci_set_ycbcr_420_down_sample (CI_CICR4_YCBCR_DOWN_SAMPLE ycbcr_ds);
+#endif
+
+/*
+ * Control APIs
+ */
+void ci_init(void);
+void ci_deinit(void);
+void ci_enable(void);
+int  ci_disable(int quick, int wait_for_disable_complete);
+void ci_slave_capture_enable(void);
+void ci_slave_capture_disable(void);
+
+/*
+ * CI RAW data processing chain APIs
+ */
+
+/* Histogram Unit(HSU) related functions */
+typedef enum {
+	CI_HISTO_RED     = CI_CIHST_COLOR_RED,
+	CI_HISTO_BLUE    = CI_CIHST_COLOR_BLUE,
+	CI_HISTO_GREEN1  = CI_CIHST_COLOR_GREEN1,
+	CI_HISTO_GREEN2  = CI_CIHST_COLOR_GREEN2
+} CI_HSU_COLOR_TYPE;
+
+typedef enum {
+	CI_HSU_MUX_0_TO_7  = CI_CIHST_SCALE_0_TO_7,    /* for 8bit raw data */
+	CI_HSU_MUX_0_TO_8  = CI_CIHST_SCALE_0_TO_8,    /* for 9bit raw data */
+	CI_HSU_MUX_1_TO_9  = CI_CIHST_SCALE_1_TO_9     /* for 10bit raw data */
+} CI_HSU_MUX_SEL_TYPE;
+
+int ci_hsu_get_histgram(
+		CI_HSU_COLOR_TYPE  color_type,
+		CI_HSU_MUX_SEL_TYPE mux_select,
+		unsigned int *lut_buffer_virtual,
+		unsigned int  lut_buffer_physical ,
+		unsigned int *lut_dma_desc_virtual,
+		unsigned int  lut_dma_desc_physical,
+		unsigned int  size,
+		unsigned int *sum);
+
+/* Pixel Substitute(PSU) related functions */
+int ci_psu_tag_bad_pixel(int column, int row);
+
+int ci_psu_enable(int enable);
+
+/* Compand and Gamma Correction (CGU) related functions */
+typedef enum {
+	CI_CGU_MUX_0_TO_7  = CI_CICCR_SCALE_0_TO_7,    /* for 8bit raw data */
+	CI_CGU_MUX_1_TO_8  = CI_CICCR_SCALE_1_TO_8,    /* for 9bit raw data */
+	CI_CGU_MUX_2_TO_9  = CI_CICCR_SCALE_2_TO_9     /* for 10bit raw data */
+} CI_CGU_MUX_SEL_TYPE;
+
+int ci_cgu_set_addr_mux_select(CI_CGU_MUX_SEL_TYPE mux_select);
+
+typedef enum {
+	CI_CGU_LUT_RED      = CI_CICCR_CLUT_RED,
+	CI_CGU_LUT_BLUE     = CI_CICCR_CLUT_BLUE,
+	CI_CGU_LUT_GREEN    = CI_CICCR_CLUT_GREEN
+} CI_CGU_LUT_TYPE;
+
+int ci_cgu_load_lut_ram(
+		unsigned int  *histogram_lut_buffer_virtual,
+		unsigned int   histogram_lut_buffer_physical,
+		unsigned int  *histogram_lut_dma_descriptors_virtual,
+		unsigned int   histogram_lut_dma_descriptors_physical,
+		unsigned char *lut_ram);
+
+int ci_cgu_set_black_level(unsigned char black_level);
+
+int ci_cgu_enable(int enable);
+
+
+#define CI_SSU_SCALE_DEFAULT CI_SSU_SCALE_DISABLE
+
+int ci_ssu_set_scale(CI_SSU_SCALE scale);
+
+/* Color Synthesis Unit(CSU) related functions */
+
+/* Color Management Unit(CMU) related functions */
+typedef enum {
+	CI_CMU_DISABLE    = CI_CICMR_DMODE_DISABLE,
+	CI_CMU_OUTPUT_RGB = CI_CICMR_DMODE_RGB,
+	CI_CMU_OUTPUT_YUV = CI_CICMR_DMODE_YUV
+} CI_CMU_USAGE;
+
+typedef struct {
+	signed short k00, k01, k02;
+	signed short k10, k11, k12;
+	signed short k20, k21, k22;
+} CI_CMU_COE_MATRIX;
+
+/* just for debug use, will be removed later */
+#define YUV_FLOAT_TO_INT(x) ((signed short)((float)x*(1UL << 7)) & 0x3ff)
+/* example:
+   static CI_CMU_COE_MATRIX cRGB24_to_YUV422_matrix = {
+   YUV_FLOAT_TO_INT(0.257) , YUV_FLOAT_TO_INT(0.504) , YUV_FLOAT_TO_INT(0.098),
+   YUV_FLOAT_TO_INT(-0.148),  YUV_FLOAT_TO_INT(0.291), YUV_FLOAT_TO_INT(0.439),
+   YUV_FLOAT_TO_INT(0.439) , YUV_FLOAT_TO_INT(0.368) , YUV_FLOAT_TO_INT(0.071)
+   };
+ */
+
+/* just for debug use, will be removed later */
+#define RGB_FLOAT_TO_INT(x) ((signed short)((float)x*(1UL << 7)) & 0x3ff)
+/* example:
+   static CI_CMU_COE_MATRIX cRGB24_to_sRGB24_matrix = {
+   RGB_FLOAT_TO_INT(1.780214),  RGB_FLOAT_TO_INT(-0.96883),
+   RGB_FLOAT_TO_INT(0.188617),  RGB_FLOAT_TO_INT(-0.7987),
+   RGB_FLOAT_TO_INT(1.790752), RGB_FLOAT_TO_INT(0.007949),
+   RGB_FLOAT_TO_INT(-0.67645),  RGB_FLOAT_TO_INT(-1.60901),
+   RGB_FLOAT_TO_INT(3.285467),
+   };
+ */
+
+int ci_cmu_set_color_correction_coe(CI_CMU_COE_MATRIX *coe_matrix);
+
+int ci_cmu_enable(CI_CMU_USAGE cmu_usage);
+
+/*
+ *	CI dedicated DMAC APIs
+ */
+typedef enum {
+	CI_DMA_CHANNEL_0 = 0,
+	CI_DMA_CHANNEL_1,
+	CI_DMA_CHANNEL_2,
+	CI_DMA_CHANNEL_3
+} CI_DMA_CHANNEL;
+
+struct ci_dma_descriptor {
+	u32     ddadr;  /* descriptor address reg */
+	u32     dsadr;  /* source address register */
+	u32     dtadr;  /* target address register */
+	u32     dcmd ;  /* command address register */
+};
+
+#define CI_DMAC_DCMD_LEN                  (1 <<  0)
+#define CI_DMAC_DCMD_EOF_IRQ_EN           (1 << 21)
+#define CI_DMAC_DCMD_SOF_IRQ_EN           (1 << 22)
+#define CI_DMAC_DCMD_INC_TRG_ADDR         (1 << 30)
+
+
+int ci_dma_load_descriptor(unsigned int dma_desc_phy, CI_DMA_CHANNEL channel);
+
+int ci_dma_set_branch(
+		unsigned int branch_to_dma_desc_phy,
+		int branch_int_enable,
+		int branch_after_cur_frame,
+		CI_DMA_CHANNEL channel);
+
+#endif
+
+
Index: linux-2.6.10/drivers/media/video/monahans/ov2620.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2620.c
@@ -0,0 +1,367 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *    contains all primitive functions for OV2620
+ *
+ * Notes:Only valid for processor code named Monahans.
+ */
+
+#include "camera.h"
+#include "ci.h"
+#include "ov2620.h"
+#include "ov2620_hw.h"
+#include <linux/delay.h>
+
+#include <asm/errno.h>
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+
+/* LUT Table, TBD */
+static unsigned char lut_table[] = {
+	/* RED LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* BLUE LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* GREEN LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+};
+
+/* CMU conversion matrixes, they're sensor specific */
+static CI_CMU_COE_MATRIX ov2620_cRGB_sRGB_COE = {
+	RGB_FLOAT_TO_INT(1.780214),  RGB_FLOAT_TO_INT(-0.96883),
+	RGB_FLOAT_TO_INT(0.188617),
+
+	RGB_FLOAT_TO_INT(-0.7987),   RGB_FLOAT_TO_INT(1.790752),
+	RGB_FLOAT_TO_INT(0.007949),
+
+	RGB_FLOAT_TO_INT(-0.67645),  RGB_FLOAT_TO_INT(-1.60901),
+	RGB_FLOAT_TO_INT(3.285467),
+} ;/* This is not provided by OmniVision yet */
+
+static CI_CMU_COE_MATRIX ov2620_cRGB_YUV_COE = {
+	YUV_FLOAT_TO_INT(0.257),  YUV_FLOAT_TO_INT(0.504),
+	YUV_FLOAT_TO_INT(0.098),
+
+	YUV_FLOAT_TO_INT(-0.148), YUV_FLOAT_TO_INT(0.291),
+	YUV_FLOAT_TO_INT(0.439),
+
+	YUV_FLOAT_TO_INT(0.439),  YUV_FLOAT_TO_INT(0.368),
+	YUV_FLOAT_TO_INT(0.071),
+};/* This is not provided by OmniVision yet */
+
+/* Bad pixel table, it's sensor specific, TBD */
+#define END_MARKER -1
+static int ov2620_badpixel_table[] = {
+	END_MARKER, END_MARKER
+};
+
+/*
+ * OV2620 Functions
+ */
+int ov2620_init(p_camera_context_t camera_context)
+{
+	u8 cm_rev, cm_pid;
+	int timeout;
+	int status;
+
+	/* provide informat about the capabilities of the sensor */
+	camera_context->sensor_status.caps |= SENSOR_CAP_MANUAL_CONTRAST |
+		SENSOR_CAP_MANUAL_WHITEBALANCE |
+		SENSOR_CAP_MANUAL_EXPOSURE;
+
+	/* Configure CI according to OV2620's hardware
+	 * master parallel with 8 data pins
+	 */
+	ci_set_mode(CI_MODE_MP, CI_DATA_WIDTH10);
+
+	/* enable pixel clock(sensor will provide pclock)
+	 * and master clock = 26MHZ
+	 */
+	ci_set_clock(1, 1, 2600);
+
+	/* data sample on rising and h,vsync active high */
+	ci_set_polarity(0, 0, 0);
+
+	/* fifo control */
+	ci_set_fifo(0, CI_FIFO_THL_32, 1, 1);
+
+	/* set black level */
+	ci_cgu_set_black_level(0);
+
+	/* CGU Mux Select */
+	ci_cgu_set_addr_mux_select(CI_CGU_MUX_2_TO_9);
+
+	/* OV2620 Power on sequence
+	 * Take out of Power down mode (GPIO_57), PWRDWN=1, NORMAL=0
+	 * Assert Reset
+	 * Delay
+	 * Remove reset
+	 * Delay
+	 */
+	ov2620hw_power_down(CAMERA_POWER_FULL);
+	ov2620hw_reset();
+
+	/* read out version */
+	timeout = 50;
+	do {
+		cm_pid = cm_rev = 0;
+		status = ov2620hw_version_revision(&cm_pid, &cm_rev);
+
+		/* Check to make sure we are working with an OV2620 */
+		if (cm_pid != PID_OV26XX || cm_rev != PID_2620) {
+			ov2620hw_power_down(CAMERA_POWER_OFF);
+			ov2620hw_power_down(CAMERA_POWER_FULL);
+			ov2620hw_reset();
+			mdelay(1);
+		}
+		if (--timeout == 0)
+			return -EIO;
+	}
+	while (cm_pid != PID_OV26XX);
+
+	/* turn sensor output off */
+	ov2620hw_view_finder_off();
+
+
+	return 0;
+}
+
+int ov2620_deinit(p_camera_context_t camera_context)
+{
+	/* power off the external module */
+	ov2620hw_power_down(CAMERA_POWER_OFF);
+
+	return 0;
+}
+
+int ov2620_sleep(p_camera_context_t camera_context)
+{
+	return ov2620_deinit(camera_context);
+}
+
+int ov2620_wake(p_camera_context_t camera_context)
+{
+	return ov2620_init(camera_context);
+}
+
+int ov2620_set_capture_format(p_camera_context_t camera_context)
+{
+	CI_MP_TIMING timing;
+	u32 winStartX, winStartY;
+	u32 winEndX, winEndY;
+	int           *padPixelX, *padPixelY;
+	int           badPixelNum;
+
+	/* Set CMU Coe matrix, if necessary */
+	if ((camera_context->capture_input_format != CAMERA_IMAGE_FORMAT_RAW10) &&
+		(camera_context->capture_input_format !=
+			CAMERA_IMAGE_FORMAT_RAW8) &&
+		(camera_context->capture_input_format !=
+			CAMERA_IMAGE_FORMAT_RAW9))
+		return -EINVAL;
+
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_YUV) {
+		ci_cmu_set_color_correction_coe(&ov2620_cRGB_YUV_COE);
+	}
+
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_RGB) {
+		ci_cmu_set_color_correction_coe(&ov2620_cRGB_sRGB_COE);
+	}
+
+	ci_cmu_enable(camera_context->cmu_usage);
+
+	/* Set OV2620 format */
+	ov2620hw_set_format(
+			camera_context->capture_input_width,
+			camera_context->capture_input_height,
+			&winStartX,
+			&winStartY,
+			&winEndX,
+			&winEndY);
+
+	/* configure PSU, if necessary */
+	if (camera_context->psu_enable) {
+		ci_psu_enable(0);
+	}
+
+	padPixelX = ov2620_badpixel_table;
+	padPixelY = ov2620_badpixel_table + 1;
+	badPixelNum = 0;
+	while ((*padPixelX != END_MARKER) && (*padPixelY != END_MARKER)) {
+
+		if (((u32)(*padPixelX) >= winStartX) &&
+			((u32)(*padPixelX) <= winEndX) &&
+			((u32)(*padPixelY) >= winStartY) &&
+			((u32)(*padPixelY) <= winEndY)) {
+
+			/* the very first pixel of each color
+			 * can't be tagged as bad!!!
+			 */
+			if ((*padPixelX - winStartX > 1) ||
+				(*padPixelY - winStartY > 1)) {
+				ci_psu_tag_bad_pixel(
+					*padPixelX - winStartX,
+					*padPixelY - winStartY);
+
+				badPixelNum++;
+				/* PSU only can substitute 128 bad pixels!! */
+				if (badPixelNum == 128)
+					break;
+			}
+		}
+
+		padPixelX += 2;
+		padPixelY += 2;
+	}
+
+	/* fill the last PSU RAM location with all 0's,
+	 * signifying the end of the dead pixel addresses stored in the RAM
+	 */
+	if (badPixelNum < 128)
+		ci_psu_tag_bad_pixel(0, 0);
+
+	if (badPixelNum != 0) {
+		if (!camera_context->psu_enable) {
+			ci_psu_enable(1);
+			camera_context->psu_enable = 1;
+		}
+	}
+
+	/* set capture width/height and timing */
+	timing.BFW = 0x00;
+	timing.BLW = 0x01;   /*GRBG to RGGB*/
+	ci_configure_mp(camera_context->capture_input_width-1,
+		camera_context->capture_input_height-1, &timing);
+
+	return 0;
+}
+
+int ov2620_start_capture(p_camera_context_t camera_context,
+		unsigned int frames)
+{
+	if (camera_context->cgu_enable) {
+		ci_cgu_load_lut_ram(camera_context->histogram_lut_buffer_virtual,
+				camera_context->histogram_lut_buffer_physical,
+				(unsigned int*)camera_context->
+					histogram_lut_dma_descriptors_virtual,
+				camera_context->
+					histogram_lut_dma_descriptors_physical,
+				lut_table);
+	}
+
+	ci_cgu_enable(camera_context->cgu_enable);
+
+	/* turn auto function on only doing continues capture */
+	if (frames == 0) {
+		ov2620hw_auto_function_on();
+	} else {
+		ov2620hw_auto_function_off();
+	}
+
+	/* turn viewfinder on */
+	ov2620hw_view_finder_on();
+	return 0;
+}
+
+int ov2620_stop_capture(p_camera_context_t camera_context)
+{
+	/* turn auto function off */
+	ov2620hw_auto_function_off();
+
+	/* turn viewfinder off */
+	ov2620hw_view_finder_off();
+
+	return 0;
+}
+
+int ov2620_set_power_mode(p_camera_context_t camera_context, u8 mode)
+{
+	ov2620hw_power_down(mode);
+	return 0;
+}
+
+int ov2620_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val)
+{
+	ov2620hw_read_sensor_reg(reg_addr, reg_val);
+	return 0;
+}
+
+int ov2620_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val)
+{
+	u8 buffer;
+	int status;
+
+	buffer = reg_val;
+	status = (ov2620hw_write_sensor_reg(reg_addr, &buffer) == 0) ?
+		0 : -EIO;
+
+	return status;
+}
+
+int ov2620_set_contrast(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_CONTRAST)
+		return ov2620hw_set_contrast(value);
+	else
+		return 0;
+}
+
+int ov2620_set_exposure(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_EXPOSURE)
+		return ov2620hw_set_exposure(value);
+	else
+		return 0;
+}
+
+int ov2620_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_WHITEBALANCE)
+		return ov2620hw_set_white_balance(value);
+	else
+		return 0;
+}
Index: linux-2.6.10/drivers/media/video/monahans/ov2620.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2620.h
@@ -0,0 +1,68 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all OV2620 function prototypes.
+ *	Declares no storage.
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV2620_HEADER__
+#define __MONAHANS_CAM_OV2620_HEADER__
+
+#include "camera.h"
+
+/*
+ * Prototypes
+ */
+
+int ov2620_init(p_camera_context_t);
+
+int ov2620_deinit(p_camera_context_t);
+
+int ov2620_sleep(p_camera_context_t camera_context);
+
+int ov2620_wake(p_camera_context_t camera_context);
+
+int ov2620_set_capture_format(p_camera_context_t);
+
+int ov2620_start_capture(p_camera_context_t, unsigned int frames);
+
+int ov2620_stop_capture(p_camera_context_t);
+
+int ov2620_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val);
+
+int ov2620_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val);
+
+int ov2620_set_power_mode(p_camera_context_t camera_context, u8 mode);
+
+int ov2620_set_contrast(p_camera_context_t camera_context, u8 mode, u32 value);
+
+int ov2620_set_exposure(p_camera_context_t camera_context, u8 mode, u32 value);
+
+int ov2620_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value);
+
+#endif
+
Index: linux-2.6.10/drivers/media/video/monahans/ov2620_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2620_hw.c
@@ -0,0 +1,967 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all hardware related functions for OV2620
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#include "camera.h"
+#include "ov2620_hw.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+#include <asm/hardware.h>
+#include <asm/arch/zylonite.h>
+#include <asm/string.h>
+
+/*
+ * Register Settings
+ */
+const static u8 ov2620InitSetting[]=
+{
+	OV2620_COMH,     0x80,        /* Initiates system reset */
+	OV2620_COMF,     0x05,
+	OV2620_CLKRC,    0x81,
+	OV2620_COMH,     0x24,
+	OV2620_FVO,      0x0c,
+	OV2620_CHLF,     0x37,
+	OV2620_VCHG,     0x4c,
+	OV2620_R39,      0xf3,
+	OV2620_AEW,      0x80,
+	OV2620_AEB,      0x70,
+	OV2620_COMI,     0x8f,
+	OV2620_REGEND,   0x00
+};
+
+/*
+ * Register Settings, Get from OmniVision
+ */
+static u8 UXGA[] =
+{
+	OV2620_COMH,    0x80,
+	OV2620_COMF,    0x05,
+	OV2620_COMH,    0x04,
+	OV2620_FVO,     0x0c,
+	OV2620_CHLF,    0x07,
+	OV2620_VCHG,    0x4c,
+	OV2620_R39,     0xf3,
+	OV2620_CLKRC,   0x81,
+	OV2620_COML,    0x00,
+	OV2620_FRARL,   0x00,
+	OV2620_REGEND,  0x00
+};
+
+static u8 SVGA[] =
+{
+	OV2620_COMH,    0x80,
+	OV2620_COMF,    0x05,
+	OV2620_COMH,    0x44,
+	OV2620_FVO,     0x0c,
+	OV2620_CHLF,    0x07,
+	OV2620_VCHG,    0x4c,
+	OV2620_R39,     0xf3,
+	OV2620_CLKRC,   0x81,
+	OV2620_COML,    0x10,
+	OV2620_FRARL,   0x00,
+	OV2620_HREFST,  0x3c,
+	OV2620_HREFEND, 0xa0,
+	OV2620_REGEND,  0x00
+};
+
+static u8 CIF[] =
+{
+	OV2620_COMH,    0x80,
+	OV2620_COMF,    0x05,
+	OV2620_COMH,    0x24,
+	OV2620_FVO,     0x0c,
+	OV2620_CHLF,    0x07,
+	OV2620_VCHG,    0x4c,
+	OV2620_R39,     0xf3,
+	OV2620_CLKRC,   0x81,
+	OV2620_COML,    0x40,
+	OV2620_FRARL,   0x10,
+	OV2620_REGEND,  0x00
+};
+
+const static u8 gSensorSlaveAddr = 0x30;
+static int read_sensor_reg(const u8 subAddress, u8 *bufP);
+static int write_sensor_reg(const u8 subAddress, u8 *bufP);
+
+/*
+ * Private/helper api
+ */
+#ifdef DEBUG_PARAM_CHECK
+static int get_reg_value(u8 *regP, u8 regAddr, u8 *regValueP)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV2620_REGEND) {
+		curReg = regP[index << 1];
+		if (curReg == regAddr) {
+			*regValueP = regP[(index << 1) + 1];
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+
+static int set_reg_value(u8 *regP, u8 regAddr, u8 regValue)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV2620_REGEND)	{
+		curReg = regP[index << 1];
+		if (curReg == regAddr)	{
+			regP[(index << 1) + 1] = regValue;
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+#endif
+
+/*
+ * Sensor read/write
+ */
+
+static int rmw_sensor_reg(const u8 subAddress, u8 *bufP, u8 andMask, u8 orMask)
+{
+	int status;
+	status = read_sensor_reg(subAddress, bufP);
+	if (!status) {
+		*bufP &= andMask;
+		*bufP |= orMask;
+		status = write_sensor_reg(subAddress, bufP);
+	}
+	return status;
+}
+
+int ov2620hw_read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return read_sensor_reg(subAddress, bufP);
+}
+
+int ov2620hw_write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return write_sensor_reg(subAddress, bufP);
+}
+
+int ov2620hw_set_regs(const u8 *regP)
+{
+	u32 curReg = 0;
+	int    status = 0;
+
+	/* The list is a register number followed by the value */
+	while (regP[curReg << 1] < OV2620_REGEND) {
+		u8 regVal = regP[(curReg << 1) + 1];
+
+		status = (write_sensor_reg(regP[curReg << 1], &regVal) == 0)?
+			0 : -EIO;
+
+		if (curReg == 0)
+			ov2620hw_wait(5);
+
+		curReg++;
+	}
+
+	return status;
+}
+
+int ov2620hw_read_all_regs(u8 *bufP, u32 numRegs)
+{
+	int curReg;
+
+	for (curReg = 0; curReg < numRegs; curReg++, bufP++)
+		read_sensor_reg((u8)curReg, bufP);
+
+	return 0;
+}
+
+/*
+ * Power & Reset
+ */
+void ov2620hw_power_down(u8 powerMode)
+{
+	/* OV2620 PWRDWN, 0 = NORMAL, 1=POWER DOWN */
+	if (powerMode == CAMERA_POWER_OFF)
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	else
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_LOW);
+
+	mdelay(100);
+}
+
+void ov2620hw_reset()
+{
+	ov2620hw_set_regs(ov2620InitSetting);
+}
+
+void ov2620hw_wait(int ms)
+{
+	mdelay(ms);
+}
+
+/*
+ * Settings
+ */
+int ov2620hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision)
+{
+	read_sensor_reg(OV2620_PIDH, pCmRevision);
+	read_sensor_reg(OV2620_PIDL, pSensorRevision);
+	return 0;
+}
+
+void ov2620hw_set_hsync()
+{
+	u8	val;
+
+	/* Makes HREF become HSYNC */
+	read_sensor_reg(OV2620_COMK, &val);
+	val |= 0x40;
+	write_sensor_reg(OV2620_COMK, &val);
+}
+
+void ov2620hw_auto_function_on()
+{
+	u8 val;
+	read_sensor_reg(OV2620_COMI, &val);
+	val |= 0x07;    /* don't disturb AWB */
+	write_sensor_reg(OV2620_COMI, &val);
+}
+
+void ov2620hw_auto_function_off()
+{
+	u8 val;
+	read_sensor_reg(OV2620_COMI, &val);
+	val &= ~0x07;    /* don't disturb AWB */
+	write_sensor_reg(OV2620_COMI, &val);
+}
+
+/*
+ * Viewfinder, still
+ */
+int ov2620hw_view_finder_on()
+{
+	u8 com3;
+
+	read_sensor_reg(OV2620_COMD, &com3);
+	com3 &= ~0x01;
+	write_sensor_reg(OV2620_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov2620hw_view_finder_off()
+{
+	u8 com3;
+
+	read_sensor_reg(OV2620_COMD, &com3);
+	com3 |= 0x01;
+	write_sensor_reg(OV2620_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov2620hw_halt_video_output()
+{
+	u8 com3;
+
+	/* Set the camera to only output 1 frame */
+	read_sensor_reg(OV2620_COMD, &com3);
+	com3 |= 1;
+	write_sensor_reg(OV2620_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+int ov2620hw_resume_full_output_mode()
+{
+	u8 mode;
+
+	/* Output still frames continuously
+	 * Turn off single capture mode COM3.
+	 */
+	rmw_sensor_reg(OV2620_COMD, (&mode), ((u8) ~1), 0);
+	return OV_ERR_NONE;
+}
+
+int ov2620hw_get_single_image()
+{
+	u8 mode;
+
+	rmw_sensor_reg(OV2620_COMD, &mode, (u8) ~1, 1);
+	return OV_ERR_NONE;
+}
+
+/*
+ * Format
+ */
+int ov2620hw_set_format(u32 captureWidth,
+		u32 captureHeight,
+		u32 *winStartX,
+		u32 *winStartY,
+		u32 *winEndX,
+		u32 *winEndY)
+{
+	OV2620_MODE mode;
+	unsigned short hStart, hEnd;
+	unsigned short vStart, vEnd;
+	unsigned char regVal;
+	unsigned short hMiddle, hProtection, vProtection;
+	int bConfigROI = 1;
+
+	hProtection = 1;
+	vProtection =1;
+
+	/* let the sensor work on proper mode */
+	if ((captureWidth <= 403) && (captureHeight <= 301)) {
+		mode = OV2620_CIF;
+	} else if ((captureWidth <= 807) && (captureHeight <= 603)) {
+		mode = OV2620_SVGA;
+	} else if ((captureWidth <= 1615) && (captureHeight <= 1207)) {
+		mode = OV2620_UXGA;
+	} else {
+		return -EINVAL;
+	}
+
+	if (mode == OV2620_CIF) {
+		ov2620hw_set_regs(CIF);
+	} else if (mode == OV2620_SVGA) {
+		ov2620hw_set_regs(SVGA);
+	} else {
+		ov2620hw_set_regs(UXGA);
+	}
+
+	/* set cropping window */
+	if (mode == OV2620_CIF) {
+		captureWidth *= 2;
+	}
+
+	if (mode == OV2620_CIF) {
+		hMiddle = 888;
+		hStart = (unsigned short)(hMiddle - captureWidth/2);
+		if (1 == hStart%2) {
+			hStart++;
+		}
+		hEnd = (unsigned short)(hStart+captureWidth+hProtection);
+		vStart = 1;
+		vEnd = (unsigned short)(vStart + captureHeight/2)+vProtection;
+
+		if ((hStart<=488)||(hEnd>=1288)||(vEnd>=151)) {
+			bConfigROI = 0;
+		}
+
+	} else if (mode == OV2620_SVGA) {
+		hMiddle = 880;
+		hStart = (unsigned short)(hMiddle - captureWidth/2);
+		if (1 == hStart%2) {
+			hStart++;
+		}
+		hEnd = (unsigned short)(hStart+captureWidth+hProtection);
+		vStart = 1;
+		vEnd = (unsigned short)(vStart + captureHeight/2)+vProtection;
+
+		if ((hStart<=480)||(hEnd>=1280)||(vEnd>=303)) {
+			bConfigROI = 0;
+		}
+
+	} else {
+		hMiddle = 1140;
+		hStart = (unsigned short)(hMiddle - captureWidth/2);
+		if (1 == hStart%2) {
+			hStart++;
+		}
+		hEnd = (unsigned short)(hStart+captureWidth+hProtection);
+		vStart = 1;
+		vEnd = (unsigned short)(vStart + captureHeight/2)+vProtection;
+
+		if ((hStart<=340)||(hEnd>=1940)||(vEnd>=603)) {
+			bConfigROI = 0;
+		}
+	}
+
+	if (bConfigROI) {
+		/* set Horizontal Window Start */
+		regVal = hStart>>3;
+		write_sensor_reg(OV2620_HREFST, &regVal);
+		read_sensor_reg(OV2620_COMM, &regVal);
+		regVal &= ~0x07;
+		regVal |= hStart & 0x07;
+		write_sensor_reg(OV2620_COMM, &regVal);
+
+		/* set Horizontal Window End */
+		regVal = hEnd>>3;
+		write_sensor_reg(OV2620_HREFEND, &regVal);
+		read_sensor_reg(OV2620_COMM, &regVal);
+		regVal &= ~(0x07 << 3);
+		regVal |= (hEnd & 0x07) << 3;
+		write_sensor_reg(OV2620_COMM, &regVal);
+
+		/* set Vertical Window Start */
+		regVal = vStart>>2;
+		write_sensor_reg(OV2620_VSTRT, &regVal);
+		read_sensor_reg(OV2620_COMA, &regVal);
+		regVal &= ~0x03;
+		regVal |= vStart & 0x03;
+		write_sensor_reg(OV2620_COMA, &regVal);
+
+		/* set Vertical Window End */
+		regVal = vEnd>>2;
+		write_sensor_reg(OV2620_VEND, &regVal);
+		read_sensor_reg(OV2620_COMA, &regVal);
+		regVal &= ~(0x03 << 2);
+		regVal |= (vEnd & 0x03) << 2;
+		write_sensor_reg(OV2620_COMA, &regVal);
+
+	}
+
+	/* return window region */
+
+	*winStartX = hStart;
+	*winStartY = vStart;
+	*winEndX   = hEnd;
+	*winEndY   = vEnd;
+
+	return 0;
+}
+
+/*
+ * Contrast
+ */
+/* FIX ME: TBD */
+const static u8 ContrastLowestSettings[] = {
+	0x6C, 0x80,
+	0x6D, 0xa0,
+	0x6E, 0x78,
+	0x6F, 0x50,
+	0x70, 0x48,
+	0x71, 0x40,
+	0x72, 0x48,
+	0x73, 0x40,
+	0x74, 0x40,
+	0x75, 0x40,
+	0x76, 0x40,
+	0x77, 0x40,
+	0x78, 0x3e,
+	0x79, 0x3c,
+	0x7A, 0x3c,
+	0x7B, 0x28,
+	0x7C, 0x8,
+	0x7D, 0x12,
+	0x7E, 0x21,
+	0x7F, 0x35,
+	0x80, 0x3e,
+	0x81, 0x46,
+	0x82, 0x4f,
+	0x83, 0x57,
+	0x84, 0x5f,
+	0x85, 0x67,
+	0x86, 0x77,
+	0x87, 0x87,
+	0x88, 0xa6,
+	0x89, 0xc4,
+	0x8A, 0xe2,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastLowSettings[] = {
+	0x6C, 0x70,
+	0x6D, 0x80,
+	0x6E, 0x40,
+	0x6F, 0x54,
+	0x70, 0x58,
+	0x71, 0x60,
+	0x72, 0x60,
+	0x73, 0x60,
+	0x74, 0x50,
+	0x75, 0x58,
+	0x76, 0x44,
+	0x77, 0x3c,
+	0x78, 0x30,
+	0x79, 0x28,
+	0x7A, 0x22,
+	0x7B, 0x44,
+	0x7C, 0x7,
+	0x7D, 0xf,
+	0x7E, 0x17,
+	0x7F, 0x2c,
+	0x80, 0x37,
+	0x81, 0x43,
+	0x82, 0x4f,
+	0x83, 0x5b,
+	0x84, 0x65,
+	0x85, 0x70,
+	0x86, 0x81,
+	0x87, 0x90,
+	0x88, 0xa8,
+	0x89, 0xbc,
+	0x8A, 0xcd,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastMiddleSettings[] = {
+	0x6C, 0x40,
+	0x6D, 0x30,
+	0x6E, 0x4B,
+	0x6F, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3A,
+	0x79, 0x2E,
+	0x7A, 0x28,
+	0x7B, 0x22,
+	0x7C, 0x4,
+	0x7D, 0x7,
+	0x7E, 0x10,
+	0x7F, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6C,
+	0x85, 0x78,
+	0x86, 0x8C,
+	0x87, 0x9E,
+	0x88, 0xBB,
+	0x89, 0xD2,
+	0x8A, 0xE6,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastHighSettings[] = {
+	0x6c, 0x10,
+	0x6d, 0x10,
+	0x6e, 0x18,
+	0x6f, 0x5c,
+	0x70, 0x90,
+	0x71, 0x90,
+	0x72, 0x90,
+	0x73, 0x90,
+	0x74, 0x80,
+	0x75, 0x80,
+	0x76, 0x60,
+	0x77, 0x5c,
+	0x78, 0x44,
+	0x79, 0x24,
+	0x7a, 0x1a,
+	0x7b, 0x10,
+	0x7c, 0x1,
+	0x7d, 0x2,
+	0x7e, 0x5,
+	0x7f, 0x1c,
+	0x80, 0x2e,
+	0x81, 0x40,
+	0x82, 0x52,
+	0x83, 0x64,
+	0x84, 0x74,
+	0x85, 0x84,
+	0x86, 0x9c,
+	0x87, 0xb3,
+	0x88, 0xd5,
+	0x89, 0xe7,
+	0x8a, 0xf4,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastHighestSettings[] = {
+	0x6c, 0x20,
+	0x6d, 0x40,
+	0x6e, 0x10,
+	0x6f, 0x38,
+	0x70, 0x80,
+	0x71, 0xe0,
+	0x72, 0xd0,
+	0x73, 0xe8,
+	0x74, 0xa0,
+	0x75, 0x80,
+	0x76, 0x80,
+	0x77, 0x54,
+	0x78, 0x30,
+	0x79, 0x22,
+	0x7a, 0x8,
+	0x7b, 0x1,
+	0x7c, 0x2,
+	0x7d, 0x6,
+	0x7e, 0x8,
+	0x7f, 0x16,
+	0x80, 0x26,
+	0x81, 0x42,
+	0x82, 0x5c,
+	0x83, 0x79,
+	0x84, 0x8d,
+	0x85, 0x9d,
+	0x86, 0xbd,
+	0x87, 0xd2,
+	0x88, 0xea,
+	0x89, 0xfb,
+	0x8a, 0xff,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+int ov2620hw_set_contrast(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_CONTRAST_LOWEST:
+			regP = ContrastLowestSettings;
+			break;
+		case SENSOR_CONTRAST_LOW:
+			regP = ContrastLowSettings;
+			break;
+		case SENSOR_CONTRAST_MIDDLE:
+			regP = ContrastMiddleSettings;
+			break;
+		case SENSOR_CONTRAST_HIGH:
+			regP = ContrastHighSettings;
+			break;
+		case SENSOR_CONTRAST_HIGHEST:
+			regP = ContrastHighestSettings;
+			break;
+		default:
+			regP = ContrastMiddleSettings;
+			break;
+	}
+
+	/* set hw */
+	if (regP)
+		ov2620hw_set_regs(regP);
+	return 0;
+}
+
+/*
+ * Exposure
+ */
+/* FIX ME: TBD */
+const static u8 ExposureSettings[] = {
+	0x40, 0x30, 0x81, /* EV-2 */
+	0x58, 0x48, 0x91, /* EV-1 */
+	0x88, 0x7c, 0x93, /* EV0  */
+	0xa0, 0x90, 0xb4, /* EV+1 */
+	0xc0, 0xb0, 0xd6, /* EV+2 */
+};
+
+int ov2620hw_set_exposure(u32 value)
+{
+	u8 aew, aeb, vv;
+	int index = -1;
+
+	switch (value) {
+		case SENSOR_EXPOSURE_LOWEST:
+			index = 0;
+			break;
+		case SENSOR_EXPOSURE_LOW:
+			index = 3;
+			break;
+		case SENSOR_EXPOSURE_MIDDLE:
+			index = 6;
+			break;
+		case SENSOR_EXPOSURE_HIGH:
+			index = 9;
+			break;
+		case SENSOR_EXPOSURE_HIGHEST:
+			index = 12;
+			break;
+		default:
+			break;
+	}
+
+	aew = aeb = vv = 0;
+
+	if (index != -1) {
+		aew = ExposureSettings[index];
+		aeb = ExposureSettings[index + 1];
+		vv  = ExposureSettings[index + 2];
+	}
+
+	/* set hw */
+	if (aew || aeb || vv) {
+		ov2620hw_write_sensor_reg(OV2620_AEW, &aew);
+		ov2620hw_write_sensor_reg(OV2620_AEB, &aeb);
+		ov2620hw_write_sensor_reg(OV2620_VV, &vv);
+	}
+
+	return 0;
+}
+
+/*
+ * Auto White Balance
+ */
+/* FIX ME: TBD */
+const static u8 AWBAuto[] = {
+	0x13, 0xad,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x60, 0x14,
+	0x5f, 0x05,
+	0x13, 0xaf,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBFluorescent[] = {
+	0x13, 0xad,
+	0x01, 0x6c,
+	0x02, 0x2e,
+	0x5f, 0x05,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBOutdoor[] = {
+	0x13, 0xad,
+	0x01, 0x44,
+	0x02, 0x44,
+	0x5f, 0x05,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBIncandescent[] = {
+	0x13, 0xad,
+	0x01, 0x6c,
+	0x02, 0x20,
+	0x5f, 0x05,
+	OV2620_REGEND,     0x00        /* End of list delimiter */
+};
+
+
+int ov2620hw_set_white_balance(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_WHITEBALANCE_AUTO:                /* Auto */
+			regP = AWBAuto;
+			break;
+		case SENSOR_WHITEBALANCE_INCANDESCENT:        /* Incandescent */
+			regP = AWBIncandescent;
+			break;
+		case SENSOR_WHITEBALANCE_SUNNY:               /* Sunny */
+			regP = AWBOutdoor;
+			break;
+		case SENSOR_WHITEBALANCE_FLUORESCENT:         /* Fluorescent */
+			regP = AWBFluorescent;
+			break;
+		default:
+			break;
+	}
+
+	/* set hw */
+	if (regP) {
+		ov2620hw_set_regs(regP);
+	}
+	return 0;
+}
+
+/*
+ * OV2620 I2C Client Driver
+ */
+#include <linux/i2c.h>
+static int i2c_ov2620_attach_adapter(struct i2c_adapter *adapter);
+static int i2c_ov2620_detect_client(struct i2c_adapter *, int, int);
+static int i2c_ov2620_detach_client(struct i2c_client *client);
+#define I2C_DRIVERID_OV2620   I2C_DRIVERID_EXP1
+#define	OV2620_ADDRESS	0x30
+
+static struct i2c_driver ov2620_driver  =
+{
+	.owner		= THIS_MODULE,
+	.name		= "ov2620",
+	.id		= I2C_DRIVERID_OV2620,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= &i2c_ov2620_attach_adapter,
+	.detach_client	= &i2c_ov2620_detach_client,
+};
+
+/* Unique ID allocation */
+static struct i2c_client *g_client;
+static unsigned short normal_i2c[] = {OV2620_ADDRESS, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+I2C_CLIENT_INSMOD;
+
+static int read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	int ret;
+
+	if (g_client == NULL)	/*	No global client pointer?	*/
+		return -1;
+
+	ret = i2c_smbus_read_byte_data(g_client, subAddress);
+	if (ret >= 0) {
+		*bufP = ret;
+	}
+	return ret;
+}
+
+static int write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	if (g_client == NULL)	/*	No global client pointer?	*/
+		return -1;
+
+	return i2c_smbus_write_byte_data(g_client, subAddress, *bufP);
+}
+
+static int i2c_ov2620_read(struct i2c_client *client, u8 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static int i2c_ov2620_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, &i2c_ov2620_detect_client);
+}
+
+static int i2c_ov2620_detect_client(struct i2c_adapter *adapter,
+		int address, int kind)
+{
+	struct i2c_client *new_client;
+	int err = 0;
+
+	/* Let's see whether this adapter can support what we need.
+	 * Please substitute the things you need here!
+	 */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		goto ERROR0;
+	}
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	 * client structure, even though we cannot fill it completely yet.
+	 * But it allows us to access several i2c functions safely
+	 */
+
+	/* Note that we reserve some space for ov2620_data too. If you don't
+	 * need it, remove it. We do it here to help to lessen memory
+	 * fragmentation.
+	 */
+
+	new_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+
+	if (!new_client)  {
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	memset(new_client, 0, sizeof(struct i2c_client));
+
+	/* FIXME */
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &ov2620_driver;
+	new_client->flags = 0;
+
+	/* detect OV2620 */
+	pxa_set_cken(CKEN_CAMERA, 1);
+	mhn_mfp_set_afds(MFP_CIF_MCLK, MFP_AF0, MFP_DS04X);
+	ci_set_clock(1, 1, 2600);
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_OUT);
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_LOW);
+	mdelay(1);
+
+	if ((i2c_ov2620_read(new_client, OV2620_PIDH) != PID_OV26XX) ||
+		(i2c_ov2620_read(new_client, OV2620_PIDL) != PID_2620)) {
+		ci_set_clock(0, 0, 2600);
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+		mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_IN);
+		pxa_set_cken(CKEN_CAMERA, 0);
+		goto ERROR1;
+	} else {
+		extern int ov2620_detected;
+		ov2620_detected = 1;
+		pr_info("OV2620 detected.\n");
+	}
+	ci_set_clock(0, 0, 2600);
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_IN);
+	pxa_set_cken(CKEN_CAMERA, 0);
+
+	g_client = new_client;
+
+	strcpy(new_client->name, "OV2620");
+
+	/* Tell the i2c layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+	return 0;
+
+ERROR1:
+	kfree(new_client);
+ERROR0:
+	return err;
+}
+
+static int i2c_ov2620_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	/* Try to detach the client from i2c space */
+	if ((err = i2c_detach_client(client))) {
+		return err;
+	}
+
+	/* Frees client data too, if allocated at the same time */
+	kfree(client);
+	g_client = NULL;
+	return 0;
+}
+
+static int __init i2c_ov2620_init(void)
+{
+	int ret;
+
+	if ((ret = i2c_add_driver(&ov2620_driver))) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit i2c_ov2620_exit(void)
+{
+	i2c_del_driver(&ov2620_driver);
+}
+
+MODULE_DESCRIPTION("I2C OV2620 driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_ov2620_init);
+module_exit(i2c_ov2620_exit);
Index: linux-2.6.10/drivers/media/video/monahans/ov2620_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2620_hw.h
@@ -0,0 +1,169 @@
+/*
+    Copyright (C) 2005, Intel Corporation.
+    Copyright (C) 2006, Marvell International Ltd.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+ * Abstract:
+ *    contains all OV2620 specific macros, typedefs, and prototypes.
+ * Declares no storage.
+ *	Notes: Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV2620_HW_HEADER__
+#define __MONAHANS_CAM_OV2620_HW_HEADER__
+
+/*
+ * Constants & Structures
+ */
+/*
+ * Revision constants
+ */
+#define PID_OV26XX              0x26
+#define PID_2620                0x20
+
+/*
+ * Return codes
+ */
+#define OV_ERR_NONE             0x00
+#define OV_ERR_TIMEOUT          -1
+#define OV_ERR_PARAMETER        -2
+#define OV_COMM_ERR             -3
+
+/*
+ * OV2620 Mode
+ */
+typedef enum {
+    OV2620_UXGA = 0,
+    OV2620_CIF,
+    OV2620_SVGA,
+    OV2620_INVALID
+}OV2620_MODE;
+
+/*
+ * Camera Mode
+ */
+#define VIEWFINDER_MODE         0x10
+#define STILLFRAME_MODE         0x20
+
+/*
+ * Others
+ */
+#define OV2620_TIMEOUT          1000    /* ms to timeout. */
+
+#define OV2620_GAIN             0x00    /* AGC Gain Control */
+#define OV2620_BLUE_GAIN        0x01    /* Blue Gain Control */
+#define OV2620_RED_GAIN         0x02    /* Red Gain Control */
+#define OV2620_COMA             0x03    /* Common Control A */
+#define OV2620_COMB             0x04    /* Common Control B */
+#define OV2620_BAVG             0x05    /* B Channel Average */
+#define OV2620_GbAVE            0x06    /* G Channel Average - Picked G pixels in the same line with B pixels */
+#define OV2620_RAVG             0x08    /* R Channel Average */
+#define OV2620_COMC             0x09    /* Common control C */
+#define OV2620_PIDH             0x0A    /* Product ID Number MSBs */
+#define OV2620_PIDL             0x0B    /* Product ID Number LSBs */
+#define OV2620_COMD             0x0C    /* Common control D */
+#define OV2620_COME             0x0D    /* Common control E */
+#define OV2620_COMF             0x0E    /* Common control F */
+#define OV2620_COMG             0x0F    /* Common control G */
+#define OV2620_AEC              0x10    /* Automatic Exposure [10:3] */
+#define OV2620_CLKRC            0x11    /* Clock Rate Control */
+#define OV2620_COMH             0x12    /* Common Control H */
+#define OV2620_COMI             0x13    /* Common control I */
+#define OV2620_COMJ             0x14    /* Common Control J */
+#define OV2620_COMK             0x15    /* Common Control K */
+#define OV2620_HREFST           0x17    /* Horizontal Window Start */
+#define OV2620_HREFEND          0x18    /* Horizontal window End */
+#define OV2620_VSTRT            0x19    /* Vertical Window Line Start */
+#define OV2620_VEND             0x1A    /* Vertical Window Line End */
+#define OV2620_PSHFT            0x1B    /* Pixel Shift */
+#define OV2620_MIDH             0x1C    /* Manufacturer ID Byte - High */
+#define OV2620_MIDL             0x1D    /* Manufacturer ID Byte - Low */
+#define OV2620_BOFF             0x20    /* B Channel Offset Adjustment */
+#define OV2620_GbOFF            0x21    /* Gb Channel Offset Adjustment */
+#define OV2620_GrOFF            0x22    /* Gr Channel Offset Adjustment */
+#define OV2620_ROFF             0x23    /* R Channel Offset Adjustment */
+#define OV2620_AEW              0x24    /* Luminance Signal High Range for AEC/AGC Operation */
+#define OV2620_AEB              0x25    /* Luminance Signal Low Range for AEC/AGC Operation */
+#define OV2620_VV               0x26    /* Fast Mode Large Step Range Threshold */
+#define OV2620_BBIAS            0x27    /* B Channel Offset Manual Adjustment Value */
+#define OV2620_GbBIAS           0x28    /* Gb Channel Offset Manual Adjustment Value */
+#define OV2620_GrBIAS           0x29    /* Gr Channel Offset Manual Adjustment Value */
+#define OV2620_COML             0x2A    /* Common Control L */
+#define OV2620_FRARL            0x2B    /* Line Interval Adjustment Value LSB 8 bits */
+#define OV2620_RBIAS            0x2C    /* R Channel Offset Manual Adjustment Value */
+#define OV2620_ADVSL            0x2D    /* VSYNC Pulse Width LSB 8 bits */
+#define OV2620_ADVSH            0x2E    /* VSYNC Pulse Width MSB 8 bits */
+#define OV2620_YAVG             0x2F    /* Luminance Average */
+#define OV2620_HSDY             0x30    /* HSYNC Position and Width Start Point LSB 8 bits */
+#define OV2620_HENY             0x31    /* HSYNC Position and Width End Lower 8 bits */
+#define OV2620_COMM             0x32    /* Common Control M */
+#define OV2620_CHLF             0x33    /* Current Control */
+#define OV2620_VCHG             0x36    /* Sensor Precharge Voltage Control */
+#define OV2620_ADC              0x37    /* ADC Reference Control */
+#define OV2620_ACOM             0x38    /* Analog Common Control */
+#define OV2620_R39              0x39    /* R39 */
+#define OV2620_HV               0x3A    /* Sensor Internal Reference Control */
+#define OV2620_FVO              0x3C    /* Sensor Internal Reference Control */
+#define OV2620_BOFFS            0x3E    /* Analog B Channel BLC Offset control */
+#define OV2620_GbOFFS           0x3F    /* Analog Gb Channel BLC Offset control */
+#define OV2620_GrOFFS           0x40    /* Analog Gr Channel BLC Offset control */
+#define OV2620_ROFFS            0x41    /* Analog R Channel BLC Offset control */
+#define OV2620_COMO             0x42    /* Common Control O */
+
+/*
+ * End of OV2620 register
+ */
+#define OV2620_REGEND        (OV2620_COMO + 1)
+
+
+/*
+ * Function Prototype
+ */
+int ov2620hw_set_regs(const u8 *regP);
+int ov2620hw_read_all_regs(u8 *bufP, u32 numRegs);
+
+void ov2620hw_power_down(u8 powerMode);
+void ov2620hw_reset(void);
+void ov2620hw_wait(int ms);
+
+int  ov2620hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision);
+void ov2620hw_set_hsync(void);
+void ov2620hw_auto_function_on(void);
+void ov2620hw_auto_function_off(void);
+
+int ov2620hw_view_finder_on(void);
+int ov2620hw_view_finder_off(void);
+int ov2620hw_halt_video_output(void);
+int ov2620hw_resume_full_output_mode(void);
+int ov2620hw_get_single_image(void);
+
+int ov2620hw_set_format(u32 captureWidth,
+                              u32 captureHeight,
+                              u32 *winStartX,
+                              u32 *winStartY,
+                              u32 *winEndX,
+                              u32 *winEndY);
+
+int ov2620hw_read_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov2620hw_write_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov2620hw_set_contrast(u32 value);
+int ov2620hw_set_exposure(u32 value);
+int ov2620hw_set_white_balance(u32 value);
+
+#endif
+
Index: linux-2.6.10/drivers/media/video/monahans/ov2630.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2630.c
@@ -0,0 +1,388 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all primitive functions for OV2630
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#include <linux/module.h>
+#include "camera.h"
+#include "ci.h"
+#include "ov2630.h"
+#include "ov2630_hw.h"
+#include <linux/delay.h>
+#include <asm/errno.h>
+
+/* LUT Table, TBD */
+static unsigned char lut_table[] = {
+	/* RED LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* BLUE LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* GREEN LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+};
+
+/* CMU conversion matrixes, they're sensor specific */
+static CI_CMU_COE_MATRIX ov2630_cRGB_sRGB_COE = {
+	RGB_FLOAT_TO_INT(0),  RGB_FLOAT_TO_INT(0), RGB_FLOAT_TO_INT(1),
+	RGB_FLOAT_TO_INT(0) ,  RGB_FLOAT_TO_INT(1), RGB_FLOAT_TO_INT(0),
+	RGB_FLOAT_TO_INT(1),  RGB_FLOAT_TO_INT(0), RGB_FLOAT_TO_INT(0)
+};
+
+static CI_CMU_COE_MATRIX ov2630_cRGB_YUV_COE = {
+	YUV_FLOAT_TO_INT(0.098),  YUV_FLOAT_TO_INT(0.504),
+	YUV_FLOAT_TO_INT(0.257),
+
+	YUV_FLOAT_TO_INT(0.439),  YUV_FLOAT_TO_INT(-0.291),
+	YUV_FLOAT_TO_INT(-0.148),
+
+	YUV_FLOAT_TO_INT(-0.071), YUV_FLOAT_TO_INT(-0.368),
+	YUV_FLOAT_TO_INT(0.439),
+};
+
+/* Bad pixel table, it's sensor specific, TBD */
+#define END_MARKER -1
+static int ov2630_badpixel_table[] = {
+	/*  column, row */
+	END_MARKER, END_MARKER
+};
+
+/*
+ * OV2630 Functions
+ */
+int ov2630_init(p_camera_context_t camera_context)
+{
+	u8 cm_rev, cm_pid;
+	u32 timeout;
+	int status;
+
+	/* provide informat about the capabilities of the sensor */
+	camera_context->sensor_status.caps |= SENSOR_CAP_MANUAL_CONTRAST |
+		SENSOR_CAP_MANUAL_WHITEBALANCE |
+		SENSOR_CAP_MANUAL_EXPOSURE;
+
+	/* Configure CI according to OV2630's hardware
+	 * master parallel with 8 data pins
+	 */
+	ci_set_mode(CI_MODE_MP, CI_DATA_WIDTH10);
+
+	/* enable pixel clock(sensor will provide pclock)
+	 * and master clock = 26MHZ
+	 */
+	/* software work around*/
+#if defined(CONFIG_PXA310)
+	ci_set_clock(1, 1, 1300);
+#else
+	ci_set_clock(1, 1, 2600);
+#endif
+
+	/* data sample on rising and h,vsync active high */
+	ci_set_polarity(0, 0, 0);
+
+	/* fifo control */
+	ci_set_fifo(0, CI_FIFO_THL_32, 1, 1);
+
+	/* set black level */
+	ci_cgu_set_black_level(0);
+
+	/* CGU Mux Select */
+	ci_cgu_set_addr_mux_select(CI_CGU_MUX_2_TO_9);
+
+	/* OV2630 Power on sequence
+	 * Take out of Power down mode (GPIO_57), PWRDWN=1, NORMAL=0
+	 * Assert Reset
+	 * Delay
+	 * Remove reset
+	 * Delay
+	 */
+	ov2630hw_power_down(CAMERA_POWER_FULL);
+	ov2630hw_reset();
+
+	/* read out version */
+	timeout = 50;
+	do {
+		cm_pid = cm_rev = 0;
+		status = ov2630hw_version_revision(&cm_pid, &cm_rev);
+
+		/* Check to make sure we are working with an OV2630 */
+		if (cm_pid != PIDH_OV2630 || cm_rev != PIDL_OV2630) {
+			ov2630hw_power_down(CAMERA_POWER_OFF);
+			ov2630hw_power_down(CAMERA_POWER_FULL);
+			ov2630hw_reset();
+			mdelay(1);
+		}
+		if (--timeout == 0) {
+			return -EIO;
+		}
+	} while (cm_pid != PIDH_OV2630);
+
+	/* turn sensor output off */
+	ov2630hw_viewfinder_off();
+
+	return 0;
+}
+
+int ov2630_deinit(p_camera_context_t camera_context)
+{
+	/* power off the external module */
+	ov2630hw_power_down(CAMERA_POWER_OFF);
+
+	return 0;
+}
+
+int ov2630_sleep(p_camera_context_t camera_context)
+{
+	return ov2630_deinit(camera_context);
+}
+
+int ov2630_wake(p_camera_context_t camera_context)
+{
+	return ov2630_init(camera_context);
+}
+
+int ov2630_set_capture_format(p_camera_context_t camera_context)
+{
+	CI_MP_TIMING timing;
+	u32 winStartX, winStartY;
+	u32 winEndX, winEndY;
+	int           *padPixelX, *padPixelY;
+	int           badPixelNum;
+
+/* software work around*/
+#if defined(CONFIG_PXA310)
+	if (camera_context->capture_input_width > 400 || camera_context->capture_input_height > 300) {
+		ci_set_clock(1, 1, 1300);
+	} else {
+		ci_set_clock(1, 1, 2600);
+	}
+#endif
+
+	/* Set CMU Coe matrix, if necessary */
+	if ((camera_context->capture_input_format !=
+			CAMERA_IMAGE_FORMAT_RAW10)&&
+		(camera_context->capture_input_format !=
+			CAMERA_IMAGE_FORMAT_RAW8) &&
+		(camera_context->capture_input_format !=
+			CAMERA_IMAGE_FORMAT_RAW9))
+		return -EINVAL;
+
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_YUV) {
+		ci_cmu_set_color_correction_coe(&ov2630_cRGB_YUV_COE);
+	}
+
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_RGB) {
+		ci_cmu_set_color_correction_coe(&ov2630_cRGB_sRGB_COE);
+	}
+
+	ci_cmu_enable(camera_context->cmu_usage);
+
+	/* Set OV2630 format */
+	ov2630hw_set_format(
+			camera_context->capture_input_width,
+			camera_context->capture_input_height,
+			&winStartX,
+			&winStartY,
+			&winEndX,
+			&winEndY);
+
+	/* configure PSU, if necessary */
+	if (camera_context->psu_enable) {
+		ci_psu_enable(0);
+
+		padPixelX = ov2630_badpixel_table;
+		padPixelY = ov2630_badpixel_table + 1;
+		badPixelNum = 0;
+
+		while ((*padPixelX != END_MARKER) && (*padPixelY != END_MARKER)) {
+
+			if (((u32)(*padPixelX) >= winStartX) &&
+				((u32)(*padPixelX) <= winEndX) &&
+				((u32)(*padPixelY) >= winStartY) &&
+				((u32)(*padPixelY) <= winEndY)) {
+
+				/* the very first pixel of each color
+				 * can't be tagged as bad!!!
+				 */
+				if ((*padPixelX - winStartX > 1) ||
+					(*padPixelY - winStartY > 1)) {
+					ci_psu_tag_bad_pixel(
+						*padPixelX - winStartX,
+						*padPixelY - winStartY);
+
+					badPixelNum++;
+					/* PSU only can substitute
+					 * 128 bad pixels!!
+					 */
+					if (badPixelNum == 128)
+						break;
+				}
+			}
+
+			padPixelX += 2;
+			padPixelY += 2;
+		}
+
+		/* fill the last PSU RAM location with all 0's,
+		 * signifying the end of the dead pixel addresses
+		 * stored in the RAM
+		 */
+		if (badPixelNum < 128) {
+			ci_psu_tag_bad_pixel(0, 0);
+		}
+
+		if (badPixelNum != 0) {
+			ci_psu_enable(1);
+		} else {
+			camera_context->psu_enable = 0;
+		}
+	}
+
+
+	/* set capture width/height and timing */
+	/* this is ok for raw data */
+	timing.BFW = 0x01;
+	timing.BLW = 0x01;   /* GRBG to RGGB */
+
+
+	ci_configure_mp(camera_context->capture_input_width-1,
+		camera_context->capture_input_height-1, &timing);
+
+#if defined(CONFIG_PXA310)
+	ci_set_ycbcr_420_down_sample (camera_context->ycbcr_ds);
+#endif
+
+	return 0;
+}
+
+int ov2630_start_capture(p_camera_context_t camera_context, unsigned int frames)
+{
+	if (camera_context->cgu_enable) {
+		ci_cgu_load_lut_ram((unsigned int*)camera_context->
+					histogram_lut_buffer_virtual,
+				camera_context->histogram_lut_buffer_physical,
+				(unsigned int*)camera_context->
+					histogram_lut_dma_descriptors_virtual,
+				camera_context->
+					histogram_lut_dma_descriptors_physical,
+				lut_table);
+	}
+
+	ci_cgu_enable(camera_context->cgu_enable);
+
+	/* turn auto function on only doing continues capture */
+	if (frames == 0) {
+		ov2630hw_auto_function_on();
+	} else {
+		ov2630hw_auto_function_off();
+	}
+
+	/* turn viewfinder on */
+	ov2630hw_viewfinder_on();
+	return 0;
+}
+
+int ov2630_stop_capture(p_camera_context_t camera_context)
+{
+	/* turn auto function off */
+	ov2630hw_auto_function_off();
+
+	/* turn viewfinder off */
+	ov2630hw_viewfinder_off();
+
+	return 0;
+}
+
+int ov2630_set_power_mode(p_camera_context_t camera_context, u8 mode)
+{
+	ov2630hw_power_down(mode);
+	return 0;
+}
+
+int ov2630_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val)
+{
+	ov2630hw_read_sensor_reg(reg_addr, reg_val);
+	return 0;
+}
+
+int ov2630_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val)
+{
+	u8 buffer;
+	int status;
+
+	buffer = reg_val;
+	status = (ov2630hw_write_sensor_reg(reg_addr, &buffer) == 0) ?
+		0 : -EIO;
+
+	return status;
+}
+
+int ov2630_set_contrast(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_CONTRAST)
+		return ov2630hw_set_contrast(value);
+	else
+		return 0;
+}
+
+int ov2630_set_exposure(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_EXPOSURE)
+		return ov2630hw_set_exposure(value);
+	else
+		return 0;
+}
+
+int ov2630_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_WHITEBALANCE)
+		return ov2630hw_set_white_balance(value);
+	else
+		return 0;
+}
Index: linux-2.6.10/drivers/media/video/monahans/ov2630.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2630.h
@@ -0,0 +1,67 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all OV2630 function prototypes.
+ *	Declares no storage.
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV2630_HEADER__
+#define __MONAHANS_CAM_OV2630_HEADER__
+
+#include "camera.h"
+
+/*
+ * Prototypes
+ */
+
+int ov2630_init(p_camera_context_t);
+
+int ov2630_deinit(p_camera_context_t);
+
+int ov2630_sleep(p_camera_context_t camera_context);
+
+int ov2630_wake(p_camera_context_t camera_context);
+
+int ov2630_set_capture_format(p_camera_context_t);
+
+int ov2630_start_capture(p_camera_context_t, unsigned int frames);
+
+int ov2630_stop_capture(p_camera_context_t);
+
+int ov2630_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val);
+
+int ov2630_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val);
+
+int ov2630_set_power_mode(p_camera_context_t camera_context, u8 mode);
+
+int ov2630_set_contrast(p_camera_context_t camera_context, u8 mode, u32 value);
+
+int ov2630_set_exposure(p_camera_context_t camera_context, u8 mode, u32 value);
+
+int ov2630_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value);
+#endif
+
Index: linux-2.6.10/drivers/media/video/monahans/ov2630_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2630_hw.c
@@ -0,0 +1,805 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all hardware related functions for OV2630
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include "camera.h"
+#include "ov2630_hw.h"
+#include <linux/delay.h>
+
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+#include <asm/hardware.h>
+#include <asm/string.h>
+
+/*
+ * Register Settings
+ */
+const static u8 ov2630InitSetting[]=
+{
+	0x12,	0x80,
+	0x0e,	0x0,
+	0x0f,	0x42,
+	0x13,	0xe7,
+	0x14,	0x4e,
+	0x24,	0x6c,
+	0x25,	0x60,
+	0x35,	0x90,
+	0x36,	0x88,
+	0x37,	0x44,
+	0x3a,	0x90,
+	0x3b,	0x14,
+	0x3f,	0x0f,
+	0x40,	0x0,
+	0x41,	0x0,
+	0x42,	0x0,
+	0x43,	0x0,
+	0x44,	0x80,
+	0x4b,	0x00,
+	0x4c,	0x28,
+	0x50,	0xf4,
+	0x58,	0x7,
+	0x59,	0x20,
+	0x5f,	0x40,
+	0x75,	0x0f,
+	0x78,	0x40,
+	0x7a,	0x10,
+	0x84,	0x4,
+	0x86,	0x20,
+	0x88,	0x0c,
+	0x89,	0x08,
+	0x8a,	0x2,
+	OV2630_REGEND,   0x00
+};
+
+/*
+ *  Register Settings, Get from OmniVision
+ */
+static u8 UXGA[] =
+{
+#if defined(CONFIG_PXA310)
+	0x11,   0x01,
+#else
+	0x11,	0x02,   /* workaroud for issue 193451 */
+#endif
+	0x34,	0xf0,
+	0x03,	0x48,
+	0x17,	0x2d,
+	0x18,	0x02,
+	0x19,	0x01,
+	0x1a,	0x97,
+#if defined(CONFIG_PXA310)
+	0x1e,   0x40,
+	0x32,   0x0b,
+#else
+	0x1e,	0xc0,
+	0x32,	0x1b,
+#endif
+	0x4d,	0xc0,
+	0x5a,	0x00,
+	0x87,	0x10,
+
+	/* for non-zoom */
+	0x0c,	0x21,
+	0x16,	0x00,
+	0x12,	0x00,
+	0x48,	0x80,
+	0x4a,	0x00,
+	0x4e,	0x18,
+	0x4f,	0x08,
+	OV2630_REGEND,   0x00
+};
+
+static u8 SVGA[] =
+{
+	0x11,	0x00,
+	0x34,   0x70,
+	0x3,	0x0e,
+	0x17,	0x3f,
+	0x18,	0x02,
+	0x19,	0x0,
+	0x1a,	0x4b,
+	0x1e,	0x00,
+	0x32,	0x1f,
+	0x4d,	0xc0,
+	0x5a,	0x00,
+	0x87,	0x00,
+
+	/* for non-zoom */
+	0x0c,	0xa0,
+	0x16,	0x00,
+	0x12,	0x41,
+	0x48,	0x00,
+	0x4a,	0x00,
+	0x4e,	0x08,
+	0x4f,	0x00,
+	OV2630_REGEND,   0x00
+};
+
+static u8 CIF[] =
+{
+	0x11,	0x01,
+	0x34,	0x70,
+	0x03,	0x0a,
+	0x17,	0x3f,
+	0x18,	0x01,
+	0x19,	0x00,
+	0x1a,	0x25,
+	0x1e,	0x00,
+	0x32,	0xbf,
+	0x4d,	0xc0,
+	0x5a,	0x80,
+	0x87,	0x00,
+
+	/* for non-zoom */
+	0x0c,	0xa0,
+	0x16,	0x00,
+	0x12,	0x21,
+	0x48,	0x00,
+	0x4a,	0x00,
+	0x4e,	0x08,
+	0x4f,	0x00,
+	OV2630_REGEND,   0x00
+};
+
+const static u8 gSensorSlaveAddr = 0x30;
+static int read_sensor_reg(const u8 subAddress, u8 *bufP);
+static int write_sensor_reg(const u8 subAddress, u8 *bufP);
+
+/*
+ * Private/helper api
+ */
+#ifdef DEBUG_PARAM_CHECK
+static int get_reg_value(u8 *regP, u8 regAddr, u8 *regValueP)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV2630_REGEND) {
+		curReg = regP[index << 1];
+		if (curReg == regAddr) {
+			*regValueP = regP[(index << 1) + 1];
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+
+static int set_reg_value(u8 *regP, u8 regAddr, u8 regValue)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV2630_REGEND) {
+		curReg = regP[index << 1];
+		if (curReg == regAddr) {
+			regP[(index << 1) + 1] = regValue;
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+#endif
+
+/*
+ *  Sensor read/write
+ */
+
+static int rmw_sensor_reg(const u8 subAddress, u8 *bufP,
+		u8 andMask, u8 orMask)
+{
+	int status;
+	status = read_sensor_reg(subAddress, bufP);
+	if (!status) {
+		*bufP &= andMask;
+		*bufP |= orMask;
+		status = write_sensor_reg(subAddress, bufP);
+	}
+	return status;
+}
+
+int ov2630hw_read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return read_sensor_reg(subAddress, bufP);
+}
+
+int ov2630hw_write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return write_sensor_reg(subAddress, bufP);
+}
+
+int ov2630hw_set_regs(const u8 *regP)
+{
+	u32 curReg = 0;
+	int    status = 0;
+
+	/* The list is a register number followed by the value */
+	while (regP[curReg << 1] < OV2630_REGEND) {
+		u8 regVal = regP[(curReg << 1) + 1];
+
+		status = (write_sensor_reg(regP[curReg << 1], &regVal) == 0) ?
+			0 : -EIO;
+
+		if (curReg == 0)
+			ov2630hw_wait(5);
+
+		curReg++;
+	}
+
+	return status;
+}
+
+int ov2630hw_read_all_regs(u8 *bufP, u32 numRegs)
+{
+	u32 curReg;
+
+	for (curReg = 0; curReg < numRegs; curReg++, bufP++)
+		read_sensor_reg((u8)curReg, bufP);
+
+
+	return 0;
+}
+
+/*
+ * Power & Reset
+ */
+void ov2630hw_power_down(u8 powerMode)
+{
+	/* OV2630 PWRDWN, 0 = NORMAL, 1=POWER DOWN */
+	if (powerMode == CAMERA_POWER_OFF)
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	else
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_LOW);
+
+	mdelay(100);
+}
+
+void ov2630hw_reset()
+{
+	ov2630hw_set_regs(ov2630InitSetting);
+}
+
+void ov2630hw_wait(int ms)
+{
+	mdelay(ms);
+}
+
+/*
+ * Settings
+ */
+int ov2630hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision)
+{
+	read_sensor_reg(OV2630_PIDH, pCmRevision);
+	read_sensor_reg(OV2630_PIDL, pSensorRevision);
+	return 0;
+}
+
+void ov2630hw_set_hsync()
+{
+	u8 val;
+
+	/* Makes HREF become HSYNC */
+	read_sensor_reg(OV2630_COMK, &val);
+	val |= 0x40;
+	write_sensor_reg(OV2630_COMK, &val);
+}
+
+void ov2630hw_auto_function_on()
+{
+	u8 val;
+	read_sensor_reg(OV2630_COMI, &val);
+	val |= 0x07;    /* don't disturb AWB */
+	write_sensor_reg(OV2630_COMI, &val);
+}
+
+void ov2630hw_auto_function_off()
+{
+	u8 val;
+	read_sensor_reg(OV2630_COMI, &val);
+	val &= ~0x07;    /* don't disturb AWB */
+	write_sensor_reg(OV2630_COMI, &val);
+}
+
+/*
+ * Viewfinder, still
+ */
+int ov2630hw_viewfinder_on()
+{
+	u8 com3;
+
+	read_sensor_reg(OV2630_COMD, &com3);
+	com3 &= ~0x01;
+	write_sensor_reg(OV2630_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov2630hw_viewfinder_off()
+{
+	u8 com3;
+
+
+	read_sensor_reg(OV2630_COMD, &com3);
+	com3 |= 0x01;
+	write_sensor_reg(OV2630_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov2630hw_halt_video_output()
+{
+	u8 com3;
+
+	/* Set the camera to only output 1 frame */
+	read_sensor_reg(OV2630_COMD, &com3);
+	com3 |= 1;
+	write_sensor_reg(OV2630_COMD, &com3);
+
+	return OV_ERR_NONE;
+}
+
+int ov2630hw_resumeto_full_output_mode()
+{
+	u8 mode;
+
+	/* Output still frames continuously
+	 * Turn off single capture mode COM3.
+	 */
+	rmw_sensor_reg(OV2630_COMD, (&mode), ((u8) ~1), 0);
+	return OV_ERR_NONE;
+}
+
+int ov2630hw_get_single_image()
+{
+	u8 mode;
+
+	rmw_sensor_reg(OV2630_COMD, &mode, (u8) ~1, 1);
+	return OV_ERR_NONE;
+}
+
+/*
+ * Format
+ */
+int ov2630hw_set_format(u32 captureWidth,
+		u32 captureHeight,
+		u32 *winStartX,
+		u32 *winStartY,
+		u32 *winEndX,
+		u32 *winEndY)
+{
+	OV2630_MODE mode;
+	unsigned short hStart;
+	unsigned short vStart;
+	unsigned char regVal;
+
+	/* let the sensor work on proper mode */
+	if ((captureWidth <= 400) && (captureHeight <= 292)) {
+		mode = OV2630_CIF;
+	} else if ((captureWidth <= 800) && (captureHeight <= 600)) {
+		mode = OV2630_SVGA;
+	} else if ((captureWidth <= 1600) && (captureHeight <= 1200)) {
+		mode = OV2630_UXGA;
+	} else {
+		return -EINVAL;
+	}
+
+	if (mode == OV2630_CIF) {
+		ov2630hw_set_regs(CIF);
+	} else if (mode == OV2630_SVGA) {
+		ov2630hw_set_regs(SVGA);
+	} else{
+		ov2630hw_set_regs(UXGA);
+	}
+
+	/* set cropping window */
+	if (mode == OV2630_CIF) {
+		captureWidth *= 2;
+	}
+
+
+	if (mode == OV2630_CIF) {
+		hStart = (unsigned short)(511 + (800 -captureWidth)/2);
+		vStart = (unsigned short)(2 + (292 - captureHeight)/4);
+	} else if (mode == OV2630_SVGA) {
+		hStart = (unsigned short)(511 + (800 -captureWidth)/2);
+		vStart = (unsigned short)(2 + (600 - captureHeight)/4);
+	} else {
+		hStart = (unsigned short)(363 + (1600 -captureWidth)/2);
+		vStart = (unsigned short)(4 + (1200 - captureHeight)/4);
+	}
+
+	/* set Horizontal Window Start */
+	regVal = hStart>>3;
+	write_sensor_reg(OV2630_HREFST, &regVal);
+	read_sensor_reg(OV2630_COMM, &regVal);
+	regVal &= ~0x07;
+	regVal |= hStart & 0x07;
+	write_sensor_reg(OV2630_COMM, &regVal);
+
+
+	/* set Vertical Window Start */
+	regVal = vStart>>2;
+	write_sensor_reg(OV2630_VSTRT, &regVal);
+	read_sensor_reg(OV2630_COMA, &regVal);
+	regVal &= ~0x03;
+	regVal |= vStart & 0x03;
+	write_sensor_reg(OV2630_COMA, &regVal);
+
+	/* return window region */
+	*winStartX = hStart;
+	*winStartY = vStart;
+	*winEndX   = hStart + captureWidth;
+	*winEndY   = vStart + captureHeight;
+
+	return 0;
+}
+
+/*
+ * Contrast
+ */
+/* FIX ME: TBD */
+const static u8 ContrastLowestSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastLowSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastMiddleSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastHighSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 ContrastHighestSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+int ov2630hw_set_contrast(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_CONTRAST_LOWEST:
+			regP = ContrastLowestSettings;
+			break;
+		case SENSOR_CONTRAST_LOW:
+			regP = ContrastLowSettings;
+			break;
+		case SENSOR_CONTRAST_MIDDLE:
+			regP = ContrastMiddleSettings;
+			break;
+		case SENSOR_CONTRAST_HIGH:
+			regP = ContrastHighSettings;
+			break;
+		case SENSOR_CONTRAST_HIGHEST:
+			regP = ContrastHighestSettings;
+			break;
+		default:
+			regP = ContrastMiddleSettings;
+			break;
+	}
+
+	/* set hw */
+	if (regP)
+		ov2630hw_set_regs(regP);
+	return 0;
+}
+
+/*
+ * Exposure
+ */
+/* FIX ME: TBD */
+const static u8 ExposureSettings[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+int ov2630hw_set_exposure(u32 value)
+{
+	u8 aew, aeb, vv;
+	int index = -1;
+
+	switch (value) {
+		case SENSOR_EXPOSURE_LOWEST:
+			index = 0;
+			break;
+		case SENSOR_EXPOSURE_LOW:
+			index = 3;
+			break;
+		case SENSOR_EXPOSURE_MIDDLE:
+			index = 6;
+			break;
+		case SENSOR_EXPOSURE_HIGH:
+			index = 9;
+			break;
+		case SENSOR_EXPOSURE_HIGHEST:
+			index = 12;
+			break;
+		default:
+			break;
+	}
+
+	aew = aeb = vv = 0;
+
+	if (index != -1) {
+		aew = ExposureSettings[index];
+		aeb = ExposureSettings[index + 1];
+		vv  = ExposureSettings[index + 2];
+	}
+
+	/* set hw */
+	if (aew || aeb || vv) {
+		ov2630hw_write_sensor_reg(OV2630_AEW, &aew);
+		ov2630hw_write_sensor_reg(OV2630_AEB, &aeb);
+		ov2630hw_write_sensor_reg(OV2630_VV, &vv);
+	}
+
+	return 0;
+}
+
+/*
+ * Auto White Balance
+ */
+/* FIX ME: TBD */
+const static u8 AWBAuto[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBFluorescent[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBOutdoor[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+const static u8 AWBIncandescent[] = {
+	/* need to follow up */
+	OV2630_REGEND,     0x00        /* End of list delimiter */
+};
+
+int ov2630hw_set_white_balance(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_WHITEBALANCE_AUTO:		/* Auto */
+			regP = AWBAuto;
+			break;
+		case SENSOR_WHITEBALANCE_INCANDESCENT:	/* Incandescent */
+			regP = AWBIncandescent;
+			break;
+		case SENSOR_WHITEBALANCE_SUNNY:		/* Sunny */
+			regP = AWBOutdoor;
+			break;
+		case SENSOR_WHITEBALANCE_FLUORESCENT:	/* Fluorescent */
+			regP = AWBFluorescent;
+			break;
+		default:
+			break;
+	}
+
+	/* set hw */
+	if (regP) {
+		ov2630hw_set_regs(regP);
+	}
+	return 0;
+}
+
+/*
+ * OV2630 I2C Client Driver
+ */
+#include <linux/i2c.h>
+static int i2c_ov2630_attach_adapter(struct i2c_adapter *adapter);
+static int i2c_ov2630_detect_client(struct i2c_adapter *, int,  int);
+static int i2c_ov2630_detach_client(struct i2c_client *client);
+#define I2C_DRIVERID_OV2630   I2C_DRIVERID_EXP1
+#define	OV2630_ADDRESS	0x30
+
+static struct i2c_driver ov2630_driver  =
+{
+	.owner		= THIS_MODULE,
+	.name		= "ov2630",
+	.id		= I2C_DRIVERID_OV2630,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= &i2c_ov2630_attach_adapter,
+	.detach_client	= &i2c_ov2630_detach_client,
+};
+
+/* Unique ID allocation */
+static struct i2c_client *g_client;
+static unsigned short normal_i2c[] = {OV2630_ADDRESS, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+I2C_CLIENT_INSMOD;
+
+static int read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	int ret;
+
+	if (g_client == NULL)	/* No global client pointer? */
+		return -1;
+
+	ret = i2c_smbus_read_byte_data(g_client, subAddress);
+	if (ret >= 0) {
+		*bufP = ret;
+	}
+	return ret;
+}
+
+static int write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	if (g_client == NULL)	/* No global client pointer? */
+		return -1;
+
+	return i2c_smbus_write_byte_data(g_client, subAddress, *bufP);
+}
+
+static int i2c_ov2630_read(struct i2c_client *client, u8 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static int i2c_ov2630_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, i2c_ov2630_detect_client);
+}
+
+static int i2c_ov2630_detect_client(struct i2c_adapter *adapter,
+		int address, int kind)
+{
+	struct i2c_client *new_client;
+	int err = 0;
+
+	/* Let's see whether this adapter can support what we need.
+	   Please substitute the things you need here!  */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		goto ERROR0;
+	}
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	 * client structure, even though we cannot fill it completely yet.
+	 * But it allows us to access several i2c functions safely
+	 */
+
+	/* Note that we reserve some space for ov2630_data too. If you don't
+	 * need it, remove it. We do it here to help to lessen memory
+	 * fragmentation.
+	 */
+	new_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+
+	if (!new_client)  {
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	memset(new_client, 0, sizeof(struct i2c_client));
+
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &ov2630_driver;
+	new_client->flags = 0;
+
+	/* detect OV2630 */
+	pxa_set_cken(CKEN_CAMERA, 1);
+	mhn_mfp_set_afds(MFP_CIF_MCLK, MFP_AF0, MFP_DS04X);
+	ci_set_clock(1, 1, 2600);
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_OUT);
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_LOW);
+	mdelay(1);
+	if ((i2c_ov2630_read(new_client, OV2630_PIDH) != PIDH_OV2630) ||
+		(i2c_ov2630_read(new_client, OV2630_PIDL) != PIDL_OV2630)) {
+		ci_set_clock(0, 0, 2600);
+		mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+		mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_IN);
+		pxa_set_cken(CKEN_CAMERA, 0);
+		goto ERROR1;
+	}
+	else {
+		extern int ov2630_detected;
+		ov2630_detected = 1;
+		pr_info("OV2630 detected.\n");
+	}
+
+	ci_set_clock(0, 0, 2600);
+	mhn_gpio_set_level(MFP_CIF_HI_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_direction(MFP_CIF_HI_PWDN_GPI0, GPIO_DIR_IN);
+	pxa_set_cken(CKEN_CAMERA, 0);
+
+	g_client = new_client;
+
+	strcpy(new_client->name, "OV2630");
+
+	/* Tell the i2c layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+	return 0;
+
+ERROR1:
+	kfree(new_client);
+ERROR0:
+	return err;
+}
+
+static int i2c_ov2630_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	/* Try to detach the client from i2c space */
+	if ((err = i2c_detach_client(client))) {
+		return err;
+	}
+
+	/* Frees client data too, if allocated at the same time */
+	kfree(client);
+	g_client = NULL;
+	return 0;
+}
+
+static int __init i2c_ov2630_init(void)
+{
+	int ret;
+
+	if ((ret = i2c_add_driver(&ov2630_driver))) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit i2c_ov2630_exit(void)
+{
+	i2c_del_driver(&ov2630_driver);
+}
+
+MODULE_DESCRIPTION("I2C OV2630 driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_ov2630_init);
+module_exit(i2c_ov2630_exit);
+
Index: linux-2.6.10/drivers/media/video/monahans/ov2630_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov2630_hw.h
@@ -0,0 +1,176 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all OV2630 specific macros, typedefs, and prototypes.
+ *	Declares no storage.
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV2630_HW_HEADER__
+#define __MONAHANS_CAM_OV2630_HW_HEADER__
+
+/*
+ * Constants & Structures
+ */
+/* Revision constants */
+#define PIDH_OV2630              0x26
+#define PIDL_OV2630              0x33
+
+/* Return codes */
+#define OV_ERR_NONE             0x00
+#define OV_ERR_TIMEOUT          -1
+#define OV_ERR_PARAMETER        -2
+#define OV_COMM_ERR             -3
+
+/* OV2630 Mode */
+typedef enum {
+	OV2630_UXGA = 0,
+	OV2630_CIF,
+	OV2630_SVGA,
+	OV2630_INVALID
+}OV2630_MODE;
+
+/* Camera Mode */
+#define VIEWFINDER_MODE         0x10
+#define STILLFRAME_MODE         0x20
+
+/* Others */
+#define OV2630_TIMEOUT          1000    /* ms to timeout */
+
+#define OV2630_GAIN             0x00    /* AGC Gain Control */
+#define OV2630_BLUE_GAIN        0x01    /* Blue Gain Control */
+#define OV2630_RED_GAIN         0x02    /* Red Gain Control */
+#define OV2630_COMA             0x03    /* Common Control A */
+#define OV2630_COMB             0x04    /* Common Control B */
+#define OV2630_BAVG             0x05    /* B Channel Average */
+/* G Channel Average - Picked G pixels in the same line with B pixels */
+#define OV2630_GbAVE            0x06
+/* G Channel Average - Picked G pixels in the same line with R pixels */
+#define OV2630_GrAVE            0x07
+#define OV2630_RAVG             0x08	/* R Channel Average */
+#define OV2630_COMC             0x09	/* Common control C */
+#define OV2630_PIDH             0x0A    /* Product ID Number MSBs */
+#define OV2630_PIDL             0x0B    /* Product ID Number LSBs */
+#define OV2630_COMD             0x0C    /* Common control D */
+#define OV2630_COME             0x0D    /* Common control E */
+#define OV2630_COMF             0x0E    /* Common control F */
+#define OV2630_COMG             0x0F    /* Common control G */
+#define OV2630_AEC              0x10    /* Automatic Exposure [10:3] */
+#define OV2630_CLKRC            0x11    /* Clock Rate Control */
+#define OV2630_COMH             0x12    /* Common Control H */
+#define OV2630_COMI             0x13    /* Common control I */
+#define OV2630_COMJ             0x14    /* Common Control J */
+#define OV2630_COMK             0x15    /* Common Control K */
+#define OV2630_HREFST           0x17    /* Horizontal Window Start */
+#define OV2630_HREFEND          0x18    /* Horizontal window End */
+#define OV2630_VSTRT            0x19    /* Vertical Window Line Start */
+#define OV2630_VEND             0x1A    /* Vertical Window Line End */
+#define OV2630_PSHFT            0x1B    /* Pixel Shift */
+#define OV2630_MIDH             0x1C    /* Manufacturer ID Byte - High */
+#define OV2630_MIDL             0x1D    /* Manufacturer ID Byte - Low */
+#define OV2630_BOFF             0x20    /* B Channel Offset Adjustment */
+#define OV2630_GbOFF            0x21    /* Gb Channel Offset Adjustment */
+#define OV2630_GrOFF            0x22    /* Gr Channel Offset Adjustment */
+#define OV2630_ROFF             0x23    /* R Channel Offset Adjustment */
+
+/* Luminance Signal High Range for AEC/AGC Operation */
+#define OV2630_AEW              0x24
+/* Luminance Signal Low Range for AEC/AGC Operation */
+#define OV2630_AEB              0x25
+/* Fast Mode Large Step Range Threshold */
+#define OV2630_VV               0x26
+/* B Channel Offset Manual Adjustment Value */
+#define OV2630_BBIAS            0x27
+/* Gb Channel Offset Manual Adjustment Value */
+#define OV2630_GbBIAS           0x28
+/* Gr Channel Offset Manual Adjustment Value */
+#define OV2630_GrBIAS           0x29
+#define OV2630_COML             0x2A    /* Common Control L */
+/* Line Interval Adjustment Value LSB 8 bits */
+#define OV2630_FRARL            0x2B
+/* R Channel Offset Manual Adjustment Value */
+#define OV2630_RBIAS            0x2C
+/* VSYNC Pulse Width LSB 8 bits */
+#define OV2630_ADVSL            0x2D
+/* VSYNC Pulse Width MSB 8 bits */
+#define OV2630_ADVSH            0x2E
+#define OV2630_YAVG             0x2F    /* Luminance Average */
+/* HSYNC Position and Width Start Point LSB 8 bits */
+#define OV2630_HSDY             0x30
+/* HSYNC Position and Width End Lower 8 bits */
+#define OV2630_HENY             0x31
+#define OV2630_COMM             0x32    /* Common Control M */
+#define OV2630_REG33            0x33    /* Current Control */
+#define OV2630_VCHG             0x36    /* Sensor Precharge Voltage Control */
+#define OV2630_ADC              0x37    /* ADC Reference Control */
+#define OV2630_ACOM             0x38    /* Analog Common Control */
+#define OV2630_REG39            0x39    /* R39 */
+#define OV2630_REG3A            0x3A    /* Sensor Internal Reference Control */
+#define OV2630_REG3C            0x3C    /* Sensor Internal Reference Control */
+/* Gb/Gr Channel Manual Offset Compensation */
+#define OV2630_DKOFFBR          0x3E
+#define OV2630_REG3F            0x3F    /* Sensor Offset Control */
+#define OV2630_BBLC             0x40    /* B Channel Black Level Value */
+#define OV2630_RBLC             0x41    /* R Channel Black Level Value */
+#define OV2630_GbBLC            0x42    /* Gb Channel Black Level Value */
+
+/* End of OV2630 register */
+#define OV2630_REGEND        (0x8D + 1)
+
+/*
+ * Function Prototype
+ */
+int ov2630hw_set_regs(const u8 *regP);
+int ov2630hw_read_all_regs(u8 *bufP, u32 numRegs);
+
+void ov2630hw_power_down(u8 powerMode);
+void ov2630hw_reset(void);
+void ov2630hw_wait(int ms);
+
+int  ov2630hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision);
+void ov2630hw_set_hsync(void);
+void ov2630hw_auto_function_on(void);
+void ov2630hw_auto_function_off(void);
+
+int ov2630hw_viewfinder_on(void);
+int ov2630hw_viewfinder_off(void);
+int ov2630hw_halt_video_output(void);
+int ov2630hw_resumeto_full_output_mode(void);
+int ov2630hw_get_single_image(void);
+
+int ov2630hw_set_format(u32 captureWidth,
+		u32 captureHeight,
+		u32 *winStartX,
+		u32 *winStartY,
+		u32 *winEndX,
+		u32 *winEndY);
+
+int ov2630hw_read_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov2630hw_write_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov2630hw_set_contrast(u32 value);
+int ov2630hw_set_exposure(u32 value);
+int ov2630hw_set_white_balance(u32 value);
+
+
+#endif
+
Index: linux-2.6.10/drivers/media/video/monahans/ov7660.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov7660.c
@@ -0,0 +1,350 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all primitive functions for OV7660
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#include <linux/module.h>
+#include "camera.h"
+#include "ci.h"
+#include "ov7660.h"
+#include "ov7660_hw.h"
+#include <linux/delay.h>
+
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+
+#ifdef HW_IP_OV7660
+
+static unsigned char lut_table[] = {
+	/* RED LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* BLUE LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+
+	/* GREEN LUT */
+	0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c,
+	0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c,
+	0x40, 0x44, 0x48, 0x4c, 0x50, 0x54, 0x58, 0x5c,
+	0x60, 0x64, 0x68, 0x6c, 0x70, 0x74, 0x78, 0x7c,
+	0x80, 0x84, 0x88, 0x8c, 0x90, 0x94, 0x98, 0x9c,
+	0xa0, 0xa4, 0xa8, 0xac, 0xb0, 0xb4, 0xb8, 0xbc,
+	0xc0, 0xc4, 0xc8, 0xcc, 0xd0, 0xd4, 0xd8, 0xdc,
+	0xe0, 0xe4, 0xe8, 0xec, 0xf0, 0xf4, 0xf8, 0xfc,
+};
+
+static CI_CMU_COE_MATRIX ov7660_cRGB_sRGB_COE = {
+	RGB_FLOAT_TO_INT(0),  RGB_FLOAT_TO_INT(0), RGB_FLOAT_TO_INT(1),
+	RGB_FLOAT_TO_INT(0),  RGB_FLOAT_TO_INT(1), RGB_FLOAT_TO_INT(0),
+	RGB_FLOAT_TO_INT(1),  RGB_FLOAT_TO_INT(0), RGB_FLOAT_TO_INT(0)
+};
+
+static CI_CMU_COE_MATRIX ov7660_cRGB_YUV_COE = {
+	YUV_FLOAT_TO_INT(0.098), YUV_FLOAT_TO_INT(0.504),
+	YUV_FLOAT_TO_INT(0.257),
+
+	YUV_FLOAT_TO_INT(0.439), YUV_FLOAT_TO_INT(-0.291),
+	YUV_FLOAT_TO_INT(-0.148),
+
+	YUV_FLOAT_TO_INT(-0.071), YUV_FLOAT_TO_INT(-0.368),
+	YUV_FLOAT_TO_INT(0.439),
+}; /* This is not provided by OmniVision yet */
+#endif
+
+/*
+ * OV7660 Functions
+ */
+int ov7660_init(p_camera_context_t camera_context)
+{
+	u8 cm_rev, cm_pid;
+	u32 timeout;
+	int status;
+
+	/* provide informat about the capabilities of the sensor */
+	camera_context->sensor_status.caps |= SENSOR_CAP_MANUAL_CONTRAST |
+		SENSOR_CAP_MANUAL_WHITEBALANCE |
+		SENSOR_CAP_MANUAL_EXPOSURE;
+
+	/* Configure CI according to OV7660's hardware
+	 * master parallel with 8 data pins
+	 */
+	ci_set_mode(CI_MODE_MP, CI_DATA_WIDTH8);
+
+	/* enable pixel clock(sensor will provide pclock)
+	 * and master clock = 26MHZ
+	 */
+	/* software work around*/
+#if defined(CONFIG_PXA310)
+	ci_set_clock(1, 1, 1300);
+#else
+	ci_set_clock(1, 1, 2600);
+#endif
+
+	/* data sample on rising and h,vsync active high */
+	ci_set_polarity(0, 0, 0);
+
+	/* fifo control */
+	ci_set_fifo(0, CI_FIFO_THL_32, 1, 1);
+
+	/* set black level */
+	ci_cgu_set_black_level(0);
+
+	/* CGU Mux Select */
+	ci_cgu_set_addr_mux_select(CI_CGU_MUX_0_TO_7);
+
+
+	/* OV7660 Power on sequence
+	 * Take out of Power down mode (GPIO_103), PWRDWN=1, NORMAL=0
+	 * Assert Reset
+	 * Delay
+	 * Remove reset
+	 * Delay
+	 */
+	ov7660hw_power_down(CAMERA_POWER_FULL);
+	ov7660hw_reset();
+
+	/* read out version */
+	timeout = 50;
+	do {
+		cm_pid = cm_rev = 0;
+		status = ov7660hw_version_revision(&cm_pid, &cm_rev);
+
+		/* Check to make sure we are working with an OV7660 */
+		if (cm_pid != PID_OV76XX || cm_rev != PID_7660) {
+			ov7660hw_power_down(CAMERA_POWER_OFF);
+			ov7660hw_power_down(CAMERA_POWER_FULL);
+			ov7660hw_reset();
+			mdelay(1);
+		}
+		if (--timeout == 0) {
+			return -EIO;
+		}
+	} while (cm_pid != PID_OV76XX);
+
+	/* turn sensor output off */
+	ov7660hw_viewfinder_off();
+
+	return 0;
+}
+
+int ov7660_deinit(p_camera_context_t camera_context)
+{
+	/* power off the external module */
+	ov7660hw_power_down(CAMERA_POWER_OFF);
+
+	return 0;
+}
+
+int ov7660_sleep(p_camera_context_t camera_context)
+{
+	return ov7660_deinit(camera_context);
+}
+
+int ov7660_wake(p_camera_context_t camera_context)
+{
+	return ov7660_init(camera_context);
+}
+
+int ov7660_set_capture_format(p_camera_context_t camera_context)
+{
+	CI_MP_TIMING timing;
+	int status;
+	u32 ovSizeFormat, ovFormat;
+
+	/* Set the current mode */
+	switch (camera_context->capture_input_format) {
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR:
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PACKED:
+			ovFormat = OV_FORMAT_YUV_422;
+			break;
+		case CAMERA_IMAGE_FORMAT_RGB565:
+			ovFormat = OV_FORMAT_RGB_565;
+			break;
+		case CAMERA_IMAGE_FORMAT_RAW8:
+			ovFormat = OV_FORMAT_RAW8;
+			break;
+		default:
+			ovFormat = OV_FORMAT_YUV_422;
+			break;
+	}
+	if (camera_context->capture_input_width == 88 &&
+			camera_context->capture_input_height == 72)
+		ovSizeFormat = OV_SIZE_QQCIF;
+	else if (camera_context->capture_input_width == 176 &&
+			camera_context->capture_input_height == 144)
+		ovSizeFormat = OV_SIZE_QCIF;
+	else if (camera_context->capture_input_width == 352 &&
+			camera_context->capture_input_height == 288)
+		ovSizeFormat = OV_SIZE_CIF;
+	else if (camera_context->capture_input_width == 160 &&
+			camera_context->capture_input_height == 120)
+		ovSizeFormat = OV_SIZE_QQVGA;
+	else if (camera_context->capture_input_width == 320 &&
+			camera_context->capture_input_height == 240)
+		ovSizeFormat = OV_SIZE_QVGA;
+	else if (camera_context->capture_input_width == 640 &&
+			camera_context->capture_input_height == 480)
+		ovSizeFormat = OV_SIZE_VGA;
+	else
+		ovSizeFormat = OV_SIZE_VGA;
+
+#ifdef HW_IP_OV7660
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_YUV) {
+		ci_cmu_set_color_correction_coe(&ov7660_cRGB_YUV_COE);
+	}
+
+	if (camera_context->cmu_usage == CI_CMU_OUTPUT_RGB) {
+		ci_cmu_set_color_correction_coe(&ov7660_cRGB_sRGB_COE);
+	}
+
+	ci_cmu_enable(camera_context->cmu_usage);
+#endif
+
+	status = ov7660hw_set_format(ovSizeFormat,
+			ovFormat, camera_context->capture_mode);
+
+	/* set capture width/height and timing */
+	if (ovFormat == OV_FORMAT_RAW8) {
+		timing.BFW = 0x01;
+		timing.BLW = 0x01; /*GRBG to RGGB*/
+	} else {
+		timing.BFW = 0x00;
+		timing.BLW = 0x00;
+	}
+	ci_configure_mp(camera_context->capture_input_width-1,
+			camera_context->capture_input_height-1, &timing);
+
+#if defined(CONFIG_PXA310)
+	ci_set_ycbcr_420_down_sample (camera_context->ycbcr_ds);
+#endif
+
+	return 0;
+}
+
+int ov7660_start_capture(p_camera_context_t camera_context,
+		unsigned int frames)
+{
+#ifdef HW_IP_OV7660
+	if (camera_context->cgu_enable) {
+		ci_cgu_load_lut_ram(
+				(unsigned int*)camera_context->
+					histogram_lut_buffer_virtual,
+				camera_context->histogram_lut_buffer_physical,
+				(unsigned int*)camera_context->
+					histogram_lut_dma_descriptors_virtual,
+				camera_context->
+					histogram_lut_dma_descriptors_physical,
+				lut_table);
+	}
+	ci_cgu_enable(camera_context->cgu_enable);
+#endif
+
+	/* turn auto function on only doing continues capture */
+	if (frames == 0) {
+		ov7660hw_auto_function_on();
+	} else {
+		ov7660hw_auto_function_off();
+	}
+
+	/* turn viewfinder on */
+	ov7660hw_viewfinder_on();
+	return 0;
+}
+
+int ov7660_stop_capture(p_camera_context_t camera_context)
+{
+	/* turn auto function off */
+	ov7660hw_auto_function_off();
+
+	/* turn viewfinder off */
+	ov7660hw_viewfinder_off();
+
+	return 0;
+}
+
+int ov7660_set_power_mode(p_camera_context_t camera_context, u8 mode)
+{
+	ov7660hw_power_down(mode);
+	return 0;
+}
+
+int ov7660_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val)
+{
+	ov7660hw_read_sensor_reg(reg_addr, reg_val);
+	return 0;
+}
+
+int ov7660_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val)
+{
+	u8 buffer;
+	int status;
+
+	buffer = reg_val;
+	status = (ov7660hw_write_sensor_reg(reg_addr, &buffer) == 0) ?
+		0 : -EIO;
+
+	return status;
+}
+
+int ov7660_set_contrast(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_CONTRAST)
+		return ov7660hw_set_contrast(value);
+	else
+		return 0;
+}
+
+int ov7660_set_exposure(p_camera_context_t camera_context, u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_EXPOSURE)
+		return ov7660hw_set_exposure(value);
+	else
+		return 0;
+}
+
+int ov7660_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value)
+{
+	if (mode == SENSOR_MANUAL_WHITEBALANCE)
+		return ov7660hw_set_white_balance(value);
+	else
+		return 0;
+}
Index: linux-2.6.10/drivers/media/video/monahans/ov7660.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov7660.h
@@ -0,0 +1,68 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all OV7660 function prototypes.
+ *	Declares no storage.
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV7660_HEADER__
+#define __MONAHANS_CAM_OV7660_HEADER__
+
+#include "camera.h"
+
+/*
+ * Prototypes
+ */
+int ov7660_init(p_camera_context_t);
+
+int ov7660_deinit(p_camera_context_t);
+
+int ov7660_sleep(p_camera_context_t camera_context);
+
+int ov7660_wake(p_camera_context_t camera_context);
+
+int ov7660_set_capture_format(p_camera_context_t);
+
+int ov7660_start_capture(p_camera_context_t, unsigned int frames);
+
+int ov7660_stop_capture(p_camera_context_t);
+
+int ov7660_read_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 *reg_val);
+
+int ov7660_write_8bit(p_camera_context_t camera_context,
+		u8 reg_addr,  u8 reg_val);
+
+int ov7660_set_power_mode(p_camera_context_t camera_context, u8 mode);
+
+int ov7660_set_contrast(p_camera_context_t camera_context,
+		u8 mode, u32 value);
+
+int ov7660_set_exposure(p_camera_context_t camera_context,
+		u8 mode, u32 value);
+
+int ov7660_set_white_balance(p_camera_context_t camera_context,
+		u8 mode, u32 value);
+#endif
+
Index: linux-2.6.10/drivers/media/video/monahans/ov7660_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov7660_hw.c
@@ -0,0 +1,3880 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	Contains all hardware related functions for OV7660
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include "camera.h"
+#include "ov7660_hw.h"
+#include <linux/delay.h>
+
+#include <asm/arch/mfp.h>
+#include <asm/arch/mhn_gpio.h>
+#include <asm/hardware.h>
+#include <asm/string.h>
+
+/*
+ * Attention: This is platform related!
+ */
+
+/*
+ * Register Settings
+ */
+const static u8 gRAW_CIF_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x25,
+	0x04, 0x00,
+	0x0c, 0x04,
+	0x18, 0x7c,
+	0x17, 0x24,
+	0x32, 0xbf,
+	0x1a, 0x4a,
+	0x19, 0x02,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x28,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0d,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x2e,
+	0x25, 0x58,
+	0x24, 0x68,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRAW_QCIF_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0d,
+	0x04, 0x04,
+	0x0c, 0x0c,
+	0x18, 0x7c,
+	0x17, 0x24,
+	0x32, 0xbf,
+	0x1a, 0x4a,
+	0x19, 0x02,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x28,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0d,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x2e,
+	0x25, 0x58,
+	0x24, 0x68,
+	0x2a, 0x30,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRAW_QQCIF_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0d,
+	0x04, 0x24,
+	0x0c, 0x0c,
+	0x18, 0x7c,
+	0x17, 0x24,
+	0x32, 0xbf,
+	0x1a, 0x4a,
+	0x19, 0x02,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x28,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0f,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x2e,
+	0x25, 0x58,
+	0x24, 0x68,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRAW_QQVGA_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x83,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x15,
+	0x04, 0x24,
+	0x0c, 0x0c,
+	0x18, 0x4a,
+	0x17, 0x22,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x68,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0a,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x4e,
+	0x25, 0x58,
+	0x24, 0x68,
+	0x92, 0xd8,
+	0x93, 0x01,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRAW_QVGA_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x83,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x15,
+	0x04, 0x00,
+	0x0c, 0x04,
+	0x18, 0x4a,
+	0x17, 0x22,
+	0x32, 0x89,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x05,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x68,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0a,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x2e,
+	0x25, 0x58,
+	0x24, 0x68,
+	0x92, 0x48,
+	0x93, 0x00,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRAW_VGA_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x9e, 0x3f,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x00, 0x00,
+	0x10, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x05,
+	0x04, 0x00,
+	0x0c, 0x00,
+	0x18, 0x61,
+	0x17, 0x11,
+	0x32, 0x89,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3c, 0x68,
+	0x3d, 0x19,
+	0x40, 0xc1,
+	0x69, 0x80,
+	0x6b, 0x0a,
+	0xa1, 0x08,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x14, 0x2e,
+	0x25, 0x58,
+	0x24, 0x68,
+	0x2a, 0x10,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_CIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x00,
+	0x9d, 0x31,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x24,
+	0x04, 0x00,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x12,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_CIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x82,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x21,
+	0x9e, 0x1b,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x24,
+	0x04, 0x00,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x12,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QCIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x48,
+	0x93, 0x06,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0c,
+	0x04, 0x04,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QCIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x68,
+	0x93, 0x06,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0c,
+	0x04, 0x04,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QQCIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x68,
+	0x93, 0x01,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0c,
+	0x04, 0x24,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QQCIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x68,
+	0x93, 0x06,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x0c,
+	0x04, 0x24,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QQVGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0xd8,
+	0x93, 0x01,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x14,
+	0x04, 0x24,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0x3f,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QQVGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x82,
+	0x92, 0xd8,
+	0x93, 0x03,
+	0x9d, 0x41,
+	0x9e, 0x36,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x14,
+	0x04, 0x24,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0x3f,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QVGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x83,
+	0x92, 0x48,
+	0x93, 0x00,
+	0x9d, 0x31,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x14,
+	0x04, 0x00,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_QVGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x85,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x21,
+	0x9e, 0x1b,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x14,
+	0x04, 0x00,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_VGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x4c,
+	0x9e, 0x3f,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x04,
+	0x04, 0x00,
+	0x18, 0x00,
+	0x17, 0x12,
+	0x32, 0xa4,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xd1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0xae,
+	0x50, 0x26,
+	0x51, 0x08,
+	0x52, 0x1a,
+	0x53, 0xa9,
+	0x54, 0x0f,
+	0x55, 0x05,
+	0x56, 0x46,
+	0x57, 0xcb,
+	0x58, 0x77,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x5c,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gRGB565_VGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x85,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x19,
+	0x9e, 0x15,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x04,
+	0x04, 0x00,
+	0x18, 0x00,
+	0x17, 0x12,
+	0x32, 0xa4,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x00,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x3c,
+	0x40, 0xd1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x6c,
+	0x50, 0x02,
+	0x51, 0x12,
+	0x52, 0x09,
+	0x53, 0x6a,
+	0x54, 0x0d,
+	0x55, 0x12,
+	0x56, 0x0d,
+	0x57, 0x7b,
+	0x58, 0x40,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0xf0,
+	0x6d, 0xf0,
+	0x6e, 0xf0,
+	0x6f, 0x70,
+	0x70, 0x58,
+	0x71, 0x58,
+	0x72, 0x48,
+	0x73, 0x48,
+	0x74, 0x38,
+	0x75, 0x40,
+	0x76, 0x34,
+	0x77, 0x34,
+	0x78, 0x2e,
+	0x79, 0x28,
+	0x7a, 0x24,
+	0x7b, 0x22,
+	0x7c, 0x0f,
+	0x7d, 0x1e,
+	0x7e, 0x3c,
+	0x7f, 0x58,
+	0x80, 0x63,
+	0x81, 0x6e,
+	0x82, 0x77,
+	0x83, 0x80,
+	0x84, 0x87,
+	0x85, 0x8f,
+	0x86, 0x9c,
+	0x87, 0xa9,
+	0x88, 0xc0,
+	0x89, 0xd4,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_CIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x00,
+	0x93, 0x01,
+	0x9d, 0x31,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x20,
+	0x04, 0x00,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_CIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x21,
+	0x9e, 0x1b,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x20,
+	0x04, 0x00,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QCIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x08,
+	0x04, 0x04,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QCIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x68,
+	0x93, 0x06,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x08,
+	0x04, 0x04,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QQCIF_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x08,
+	0x04, 0x24,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QQCIF_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x80,
+	0x92, 0x68,
+	0x93, 0x06,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x08,
+	0x04, 0x24,
+	0x18, 0x80,
+	0x17, 0x28,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x4a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x02,
+	0x34, 0x00,
+	0x35, 0x84,
+	0x36, 0x03,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0f,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QQVGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x62,
+	0x9e, 0x52,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x10,
+	0x04, 0x24,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QQVGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0xd8,
+	0x93, 0x03,
+	0x9d, 0x41,
+	0x9e, 0x36,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x10,
+	0x04, 0x24,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QVGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x00,
+	0x9d, 0x31,
+	0x9e, 0x29,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x10,
+	0x04, 0x00,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_QVGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x21,
+	0x9e, 0x1b,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x10,
+	0x04, 0x00,
+	0x18, 0x4b,
+	0x17, 0x23,
+	0x32, 0xbf,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_VGA_15fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x4c,
+	0x9e, 0x3f,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x00,
+	0x04, 0x00,
+	0x18, 0x01,
+	0x17, 0x13,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x90,
+	0x3f, 0x29,
+	0x40, 0xc1,
+	0x41, 0x20,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xa0,
+	0x4f, 0x66,
+	0x50, 0x6b,
+	0x51, 0x05,
+	0x52, 0x19,
+	0x53, 0x40,
+	0x54, 0x59,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0x40,
+	0x6d, 0x30,
+	0x6e, 0x4b,
+	0x6f, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3a,
+	0x79, 0x2e,
+	0x7a, 0x28,
+	0x7b, 0x22,
+	0x7c, 0x04,
+	0x7d, 0x07,
+	0x7e, 0x10,
+	0x7f, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6c,
+	0x85, 0x78,
+	0x86, 0x8c,
+	0x87, 0x9e,
+	0x88, 0xbb,
+	0x89, 0xd2,
+	0x8a, 0xe6,
+	0x14, 0x2e,
+	0x24, 0x68,
+	0x25, 0x5c,
+	0x92, 0x48,
+	0x93, 0x01,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 gYUV_VGA_5fps_INITIALIZE[] =
+{
+	0x12, 0x80,
+	0x11, 0x81,
+	0x92, 0x48,
+	0x93, 0x01,
+	0x9d, 0x19,
+	0x9e, 0x15,
+	0x3b, 0x02,
+	0x13, 0xf2,
+	0x10, 0x00,
+	0x00, 0x00,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x13, 0xf7,
+	0x12, 0x00,
+	0x04, 0x00,
+	0x18, 0x01,
+	0x17, 0x13,
+	0x32, 0x92,
+	0x19, 0x02,
+	0x1a, 0x7a,
+	0x03, 0x00,
+	0x0e, 0x84,
+	0x0f, 0x62,
+	0x15, 0x02,
+	0x16, 0x02,
+	0x1b, 0x01,
+	0x1e, 0x01,
+	0x29, 0x3c,
+	0x33, 0x00,
+	0x34, 0x07,
+	0x35, 0x84,
+	0x36, 0x00,
+	0x38, 0x13,
+	0x39, 0x43,
+	0x3a, 0x0c,
+	0x3c, 0x6c,
+	0x3d, 0x99,
+	0x3f, 0x3c,
+	0x40, 0xc1,
+	0x41, 0x00,
+	0x6b, 0x0a,
+	0xa1, 0xc8,
+	0x69, 0x80,
+	0x43, 0xf0,
+	0x44, 0x10,
+	0x45, 0x78,
+	0x46, 0xa8,
+	0x47, 0x60,
+	0x48, 0x80,
+	0x59, 0xba,
+	0x5a, 0x9a,
+	0x5b, 0x22,
+	0x5c, 0xb9,
+	0x5d, 0x9b,
+	0x5e, 0x10,
+	0x5f, 0xe0,
+	0x60, 0x85,
+	0x61, 0x60,
+	0x9f, 0x9d,
+	0xa0, 0xe0,
+	0x4f, 0x40,
+	0x50, 0x43,
+	0x51, 0x03,
+	0x52, 0x10,
+	0x53, 0x28,
+	0x54, 0x38,
+	0x55, 0x40,
+	0x56, 0x40,
+	0x57, 0x40,
+	0x58, 0x0d,
+	0x8b, 0xcc,
+	0x8c, 0xcc,
+	0x8d, 0xcf,
+	0x6c, 0xf0,
+	0x6d, 0xf0,
+	0x6e, 0xf0,
+	0x6f, 0x70,
+	0x70, 0x58,
+	0x71, 0x58,
+	0x72, 0x48,
+	0x73, 0x48,
+	0x74, 0x38,
+	0x75, 0x40,
+	0x76, 0x34,
+	0x77, 0x34,
+	0x78, 0x2e,
+	0x79, 0x28,
+	0x7a, 0x24,
+	0x7b, 0x22,
+	0x7c, 0x0f,
+	0x7d, 0x1e,
+	0x7e, 0x3c,
+	0x7f, 0x58,
+	0x80, 0x63,
+	0x81, 0x6e,
+	0x82, 0x77,
+	0x83, 0x80,
+	0x84, 0x87,
+	0x85, 0x8f,
+	0x86, 0x9c,
+	0x87, 0xa9,
+	0x88, 0xc0,
+	0x89, 0xd4,
+	0x8a, 0xe6,
+	0x14, 0x4e,
+	0x24, 0x68,
+	0x25, 0x58,
+	OV7660_REGEND, 0x00	    /* End of list delimiter */
+};
+
+const static u8 Premier_Lens[] =
+{
+	OV7660_AWBTH3   , 0x5C,
+	OV7660_AWBTH4   , 0x6e,
+	OV7660_AWBTH5   , 0x46,
+	OV7660_AWBTH6   , 0x4D,
+	OV7660_AWBC1    , 0x23,
+	OV7660_AWBC2    , 0x41,
+	OV7660_AWBC3    , 0x43,
+	OV7660_AWBC4    , 0x74,
+	OV7660_AWBC5    , 0x6e,
+
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 LiteOn_Lens[] =
+{
+	OV7660_AWBTH3   , 0x58,
+	OV7660_AWBTH4   , 0x6c,
+	OV7660_AWBTH5   , 0x46,
+	OV7660_AWBTH6   , 0x48,
+	OV7660_AWBC1    , 0x23,
+	OV7660_AWBC2    , 0x41,
+	OV7660_AWBC3    , 0x54,
+	OV7660_AWBC4    , 0x74,
+	OV7660_AWBC5    , 0x5c,
+
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 gSensorSlaveAddr = 0x21;
+static int read_sensor_reg(const u8 subAddress, u8 *bufP);
+static int write_sensor_reg(const u8 subAddress, u8 *bufP);
+
+struct OV7660_SETTING
+{
+	int   format;
+	int   resolution;
+	const u8 *setting;
+};
+
+static struct OV7660_SETTING ov7660_setting_table[] =
+{
+	{OV_FORMAT_RAW8   , OV_SIZE_QQVGA, gRAW_QQVGA_INITIALIZE},
+	{OV_FORMAT_RAW8   , OV_SIZE_QVGA , gRAW_QVGA_INITIALIZE},
+	{OV_FORMAT_RAW8   , OV_SIZE_VGA  , gRAW_VGA_INITIALIZE},
+	{OV_FORMAT_RAW8   , OV_SIZE_QQCIF, gRAW_QQCIF_INITIALIZE},
+	{OV_FORMAT_RAW8   , OV_SIZE_QCIF , gRAW_QCIF_INITIALIZE},
+	{OV_FORMAT_RAW8   , OV_SIZE_CIF  , gRAW_CIF_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_QQVGA, gYUV_QQVGA_15fps_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_QVGA , gYUV_QVGA_15fps_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_VGA  , gYUV_VGA_15fps_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_QQCIF, gYUV_QQCIF_15fps_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_QCIF , gYUV_QCIF_15fps_INITIALIZE},
+	{OV_FORMAT_YUV_422, OV_SIZE_CIF  , gYUV_CIF_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_QQVGA, gRGB565_QQVGA_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_QVGA , gRGB565_QVGA_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_VGA  , gRGB565_VGA_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_QQCIF, gRGB565_QQCIF_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_QCIF , gRGB565_QCIF_15fps_INITIALIZE},
+	{OV_FORMAT_RGB_565, OV_SIZE_CIF  , gRGB565_CIF_15fps_INITIALIZE},
+	{0, 0, 0}
+} ;
+
+/*
+ *  Private/helper api
+ */
+#ifdef DEBUG_PARAM_CHECK
+static int get_reg_value(u8 *regP, u8 regAddr, u8 *regValueP)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV7660_REGEND) {
+		curReg = regP[index << 1];
+		if (curReg == regAddr) {
+			*regValueP = regP[(index << 1) + 1];
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+
+static int set_reg_value(u8 *regP, u8 regAddr, u8 regValue)
+{
+	unsigned int index = 0;
+	u8 curReg = 0;
+
+	while (curReg < OV7660_REGEND) {
+		curReg = regP[index << 1];
+		if (curReg == regAddr) {
+			regP[(index << 1) + 1] = regValue;
+			return 0;
+		}
+		index ++;
+	}
+
+	return -EIO;
+
+}
+#endif
+
+/*
+ * Sensor read/write
+ */
+static int rmw_sensor_reg(const u8 subAddress,
+		u8 *bufP, u8 andMask, u8 orMask)
+{
+	int status;
+	status = read_sensor_reg(subAddress, bufP);
+	if (!status) {
+		*bufP &= andMask;
+		*bufP |= orMask;
+		status = write_sensor_reg(subAddress, bufP);
+	}
+	return status;
+}
+
+int ov7660hw_read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return read_sensor_reg(subAddress, bufP);
+}
+
+int ov7660hw_write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	return write_sensor_reg(subAddress, bufP);
+}
+
+int ov7660hw_set_regs(const u8 *regP)
+{
+	u32	curReg = 0;
+	int	status = 0;
+
+	/* The list is a register number followed by the value */
+	while (regP[curReg << 1] < OV7660_REGEND) {
+		u8 regVal = regP[(curReg << 1) + 1];
+
+		status = (write_sensor_reg(regP[curReg << 1], &regVal) == 0) ?
+			0 : -EIO;
+
+		if (curReg == 0)
+			ov7660hw_wait(5);
+
+		curReg++;
+	}
+
+	return status;
+}
+
+int ov7660hw_read_all_regs(u8 *bufP, u32 numRegs)
+{
+	u32	curReg;
+
+	for (curReg = 0; curReg < numRegs; curReg++, bufP++)
+		read_sensor_reg((u8)curReg, bufP);
+
+
+	return 0;
+}
+
+static void sensor_power_on(void)
+{
+	mhn_gpio_set_direction(MFP_CIF_LO_PWDN_GPI0, GPIO_DIR_OUT);
+	mhn_gpio_set_level(MFP_CIF_LO_PWDN_GPI0, GPIO_LEVEL_LOW);
+}
+
+static void sensor_power_off(void)
+{
+	mhn_gpio_set_level(MFP_CIF_LO_PWDN_GPI0, GPIO_LEVEL_HIGH);
+	mhn_gpio_set_direction(MFP_CIF_LO_PWDN_GPI0, GPIO_DIR_IN);
+}
+
+/*
+ * Power & Reset
+ */
+void ov7660hw_power_down(u8 powerMode)
+{
+	/* OV7660 PWRDWN, 0 = NORMAL, 1=POWER DOWN */
+	if (powerMode == CAMERA_POWER_OFF)
+		sensor_power_off();
+	else
+		sensor_power_on();
+
+	mdelay(100);
+}
+
+void ov7660hw_reset()
+{
+}
+
+void ov7660hw_wait(int ms)
+{
+	mdelay(ms);
+}
+
+/*
+ * Settings
+ */
+int ov7660hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision)
+{
+	read_sensor_reg(OV7660_PID, pCmRevision);
+	read_sensor_reg(OV7660_VER, pSensorRevision);
+	return 0;
+}
+
+void ov7660hw_set_hsync()
+{
+	u8	val;
+
+	/* Makes HREF become HSYNC */
+	read_sensor_reg(OV7660_COM10, &val);
+	val |= 0x40;
+	write_sensor_reg(OV7660_COM10, &val);
+}
+
+void ov7660hw_auto_function_on()
+{
+	u8 val;
+	read_sensor_reg(OV7660_COM8, &val);
+	val |= 0x07;	/* don't disturb AWB */
+	write_sensor_reg(OV7660_COM8, &val);
+}
+
+void ov7660hw_auto_function_off()
+{
+	u8 val;
+	read_sensor_reg(OV7660_COM8, &val);
+	val &= ~0x07;	/* don't disturb AWB */
+	write_sensor_reg(OV7660_COM8, &val);
+}
+
+/*
+ * Viewfinder, still
+ */
+int ov7660hw_viewfinder_on()
+{
+	u8	com3;
+
+	read_sensor_reg(OV7660_COM3, &com3);
+	com3 &= ~0x01;
+	write_sensor_reg(OV7660_COM3, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov7660hw_viewfinder_off()
+{
+	u8	com3;
+
+	read_sensor_reg(OV7660_COM3, &com3);
+	com3 |= 0x01;
+	write_sensor_reg(OV7660_COM3, &com3);
+
+	return OV_ERR_NONE;
+}
+
+
+int ov7660hw_halt_video_output()
+{
+	u8	com3;
+
+	/* Set the camera to only output 1 frame */
+	read_sensor_reg(OV7660_COM3, &com3);
+	com3 |= 1;
+	write_sensor_reg(OV7660_COM3, &com3);
+
+	return OV_ERR_NONE;
+}
+
+int ov7660hw_resumeto_full_output_mode()
+{
+	u8	mode;
+
+	/* Output still frames continuously
+	 * Turn off single capture mode COM3.
+	 */
+	rmw_sensor_reg(OV7660_COM3, (&mode), ((u8) ~1), 0);
+	return OV_ERR_NONE;
+}
+
+int ov7660hw_get_single_image()
+{
+	u8	mode;
+
+	rmw_sensor_reg(OV7660_COM3, &mode, (u8) ~1, 1);
+	return OV_ERR_NONE;
+}
+
+#define MIN(x, y) ((x < y) ? x : y)
+#define MAX(x, y) ((x > y) ? x : y)
+
+/*
+ * Format
+ */
+int ov7660hw_set_format(u32 captureSizeFormat, u32 colorFormat, u32 mode)
+{
+
+	int	status;
+	u8	*regsP;
+	const u8	*defaultDataP;
+	struct OV7660_SETTING  *ov7660_setting;
+
+	defaultDataP  = NULL;
+	for (ov7660_setting = ov7660_setting_table;
+		ov7660_setting->format != 0;ov7660_setting++) {
+		if ((colorFormat == ov7660_setting->format) &&
+			(captureSizeFormat == ov7660_setting->resolution)) {
+			defaultDataP = ov7660_setting->setting;
+			break;
+		}
+	}
+
+	if (defaultDataP == NULL)
+		return -EPERM;
+
+	/* Get the pointer to the basic setting.
+	 * The pointer must be freed after exiting.
+	 */
+	regsP = (u8 *) defaultDataP;
+
+	/* Blast the entire parameter tree into the part */
+	status = ov7660hw_set_regs(regsP);
+
+	return 0;
+}
+
+/*
+ * Contrast
+ */
+const static u8 ContrastLowestSettings[] = {
+	0x6C, 0x80,
+	0x6D, 0xa0,
+	0x6E, 0x78,
+	0x6F, 0x50,
+	0x70, 0x48,
+	0x71, 0x40,
+	0x72, 0x48,
+	0x73, 0x40,
+	0x74, 0x40,
+	0x75, 0x40,
+	0x76, 0x40,
+	0x77, 0x40,
+	0x78, 0x3e,
+	0x79, 0x3c,
+	0x7A, 0x3c,
+	0x7B, 0x28,
+	0x7C, 0x8,
+	0x7D, 0x12,
+	0x7E, 0x21,
+	0x7F, 0x35,
+	0x80, 0x3e,
+	0x81, 0x46,
+	0x82, 0x4f,
+	0x83, 0x57,
+	0x84, 0x5f,
+	0x85, 0x67,
+	0x86, 0x77,
+	0x87, 0x87,
+	0x88, 0xa6,
+	0x89, 0xc4,
+	0x8A, 0xe2,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 ContrastLowSettings[] = {
+	0x6C, 0x70,
+	0x6D, 0x80,
+	0x6E, 0x40,
+	0x6F, 0x54,
+	0x70, 0x58,
+	0x71, 0x60,
+	0x72, 0x60,
+	0x73, 0x60,
+	0x74, 0x50,
+	0x75, 0x58,
+	0x76, 0x44,
+	0x77, 0x3c,
+	0x78, 0x30,
+	0x79, 0x28,
+	0x7A, 0x22,
+	0x7B, 0x44,
+	0x7C, 0x7,
+	0x7D, 0xf,
+	0x7E, 0x17,
+	0x7F, 0x2c,
+	0x80, 0x37,
+	0x81, 0x43,
+	0x82, 0x4f,
+	0x83, 0x5b,
+	0x84, 0x65,
+	0x85, 0x70,
+	0x86, 0x81,
+	0x87, 0x90,
+	0x88, 0xa8,
+	0x89, 0xbc,
+	0x8A, 0xcd,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 ContrastMiddleSettings[] = {
+	0x6C, 0x40,
+	0x6D, 0x30,
+	0x6E, 0x4B,
+	0x6F, 0x60,
+	0x70, 0x70,
+	0x71, 0x70,
+	0x72, 0x70,
+	0x73, 0x70,
+	0x74, 0x60,
+	0x75, 0x60,
+	0x76, 0x50,
+	0x77, 0x48,
+	0x78, 0x3A,
+	0x79, 0x2E,
+	0x7A, 0x28,
+	0x7B, 0x22,
+	0x7C, 0x4,
+	0x7D, 0x7,
+	0x7E, 0x10,
+	0x7F, 0x28,
+	0x80, 0x36,
+	0x81, 0x44,
+	0x82, 0x52,
+	0x83, 0x60,
+	0x84, 0x6C,
+	0x85, 0x78,
+	0x86, 0x8C,
+	0x87, 0x9E,
+	0x88, 0xBB,
+	0x89, 0xD2,
+	0x8A, 0xE6,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 ContrastHighSettings[] = {
+	0x6c, 0x10,
+	0x6d, 0x10,
+	0x6e, 0x18,
+	0x6f, 0x5c,
+	0x70, 0x90,
+	0x71, 0x90,
+	0x72, 0x90,
+	0x73, 0x90,
+	0x74, 0x80,
+	0x75, 0x80,
+	0x76, 0x60,
+	0x77, 0x5c,
+	0x78, 0x44,
+	0x79, 0x24,
+	0x7a, 0x1a,
+	0x7b, 0x10,
+	0x7c, 0x1,
+	0x7d, 0x2,
+	0x7e, 0x5,
+	0x7f, 0x1c,
+	0x80, 0x2e,
+	0x81, 0x40,
+	0x82, 0x52,
+	0x83, 0x64,
+	0x84, 0x74,
+	0x85, 0x84,
+	0x86, 0x9c,
+	0x87, 0xb3,
+	0x88, 0xd5,
+	0x89, 0xe7,
+	0x8a, 0xf4,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 ContrastHighestSettings[] = {
+	0x6c, 0x20,
+	0x6d, 0x40,
+	0x6e, 0x10,
+	0x6f, 0x38,
+	0x70, 0x80,
+	0x71, 0xe0,
+	0x72, 0xd0,
+	0x73, 0xe8,
+	0x74, 0xa0,
+	0x75, 0x80,
+	0x76, 0x80,
+	0x77, 0x54,
+	0x78, 0x30,
+	0x79, 0x22,
+	0x7a, 0x8,
+	0x7b, 0x1,
+	0x7c, 0x2,
+	0x7d, 0x6,
+	0x7e, 0x8,
+	0x7f, 0x16,
+	0x80, 0x26,
+	0x81, 0x42,
+	0x82, 0x5c,
+	0x83, 0x79,
+	0x84, 0x8d,
+	0x85, 0x9d,
+	0x86, 0xbd,
+	0x87, 0xd2,
+	0x88, 0xea,
+	0x89, 0xfb,
+	0x8a, 0xff,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+int ov7660hw_set_contrast(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_CONTRAST_LOWEST:
+			regP = ContrastLowestSettings;
+			break;
+		case SENSOR_CONTRAST_LOW:
+			regP = ContrastLowSettings;
+			break;
+		case SENSOR_CONTRAST_MIDDLE:
+			regP = ContrastMiddleSettings;
+			break;
+		case SENSOR_CONTRAST_HIGH:
+			regP = ContrastHighSettings;
+			break;
+		case SENSOR_CONTRAST_HIGHEST:
+			regP = ContrastHighestSettings;
+			break;
+		default:
+			regP = ContrastMiddleSettings;
+			break;
+	}
+
+	/* set hw */
+	if (regP)
+		ov7660hw_set_regs(regP);
+	return 0;
+}
+
+/*
+ * Exposure
+ */
+const static u8 ExposureSettings[] = {
+	0x40, 0x30, 0x81, /* EV-2 */
+	0x58, 0x48, 0x91, /* EV-1 */
+	0x88, 0x7c, 0x93, /* EV0 */
+	0xa0, 0x90, 0xb4, /* EV+1 */
+	0xc0, 0xb0, 0xd6, /* EV+2 */
+};
+
+int ov7660hw_set_exposure(u32 value)
+{
+	u8 aew, aeb, vpt;
+	int index = -1;
+
+	switch (value) {
+		case SENSOR_EXPOSURE_LOWEST:
+			index = 0;
+			break;
+		case SENSOR_EXPOSURE_LOW:
+			index = 3;
+			break;
+		case SENSOR_EXPOSURE_MIDDLE:
+			index = 6;
+			break;
+		case SENSOR_EXPOSURE_HIGH:
+			index = 9;
+			break;
+		case SENSOR_EXPOSURE_HIGHEST:
+			index = 12;
+			break;
+		default:
+			break;
+	}
+
+	aew = aeb = vpt = 0;
+
+	if (index != -1) {
+		aew = ExposureSettings[index];
+		aeb = ExposureSettings[index + 1];
+		vpt  = ExposureSettings[index + 2];
+	}
+
+	/* set hw */
+	if (aew || aeb || vpt) {
+		ov7660hw_write_sensor_reg(0x24, &aew);
+		ov7660hw_write_sensor_reg(0x25, &aeb);
+		ov7660hw_write_sensor_reg(0x26, &vpt);
+	}
+
+	return 0;
+}
+
+/*
+ * Auto White Balance
+ */
+const static u8 AWBAuto[] = {
+	0x13, 0xad,
+	0x01, 0x80,
+	0x02, 0x80,
+	0x60, 0x14,
+	0x5f, 0x05,
+	0x13, 0xaf,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 AWBFluorescent[] = {
+	0x13, 0xad,
+	0x01, 0x6c,
+	0x02, 0x2e,
+	0x5f, 0x05,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 AWBOutdoor[] = {
+	0x13, 0xad,
+	0x01, 0x44,
+	0x02, 0x44,
+	0x5f, 0x05,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+const static u8 AWBIncandescent[] = {
+	0x13, 0xad,
+	0x01, 0x6c,
+	0x02, 0x20,
+	0x5f, 0x05,
+	OV7660_REGEND, 	0x00		/* End of list delimiter */
+};
+
+
+int ov7660hw_set_white_balance(u32 value)
+{
+	const u8 *regP;
+
+	regP = NULL;
+	switch (value) {
+		case SENSOR_WHITEBALANCE_AUTO:		/* Auto */
+			regP = AWBAuto;
+			break;
+		case SENSOR_WHITEBALANCE_INCANDESCENT:	/* Incandescent */
+			regP = AWBIncandescent;
+			break;
+		case SENSOR_WHITEBALANCE_SUNNY:		/* Sunny */
+			regP = AWBOutdoor;
+			break;
+		case SENSOR_WHITEBALANCE_FLUORESCENT:	/* Fluorescent */
+			regP = AWBFluorescent;
+			break;
+		default:
+			break;
+	}
+
+	/* set hw */
+	if (regP) {
+		ov7660hw_set_regs(regP);
+	}
+	return 0;
+}
+
+/*
+ * OV7660 I2C Client Driver
+ */
+#include <linux/i2c.h>
+static int i2c_ov7660_attach_adapter(struct i2c_adapter *adapter);
+static int i2c_ov7660_detect_client(struct i2c_adapter *, int, int);
+static int i2c_ov7660_detach_client(struct i2c_client *client);
+#define I2C_DRIVERID_OV7660   I2C_DRIVERID_EXP1
+#define	OV7660_ADDRESS	0x21
+
+static struct i2c_driver ov7660_driver  =
+{
+	.owner		= THIS_MODULE,
+	.name		= "ov7660",
+	.id		= I2C_DRIVERID_OV7660,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= &i2c_ov7660_attach_adapter,
+	.detach_client	= &i2c_ov7660_detach_client,
+};
+
+/* Unique ID allocation */
+static struct i2c_client *g_client;
+static unsigned short force[] = { ANY_I2C_BUS, OV7660_ADDRESS, I2C_CLIENT_END };
+static unsigned short empty[] = { I2C_CLIENT_END };
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c =           empty,
+	.normal_i2c_range =     empty,
+	.probe =                empty,
+	.probe_range =          empty,
+	.ignore =               empty,
+	.ignore_range =         empty,
+	.force =                force,
+};
+
+
+static int read_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	int err;
+
+	if (g_client == NULL)	/*	No global client pointer?	*/
+		return -1;
+
+	err = i2c_master_send(g_client, &subAddress, 1);
+	if (err != 1)
+		return err;
+
+	err = i2c_master_recv(g_client, bufP, 1);
+
+	return err;
+}
+
+static int write_sensor_reg(const u8 subAddress, u8 *bufP)
+{
+	if (g_client == NULL)	/*	No global client pointer?	*/
+		return -1;
+
+	return i2c_smbus_write_byte_data(g_client, subAddress, *bufP);
+}
+
+static int i2c_ov7660_read(struct i2c_client *client, u8 reg)
+{
+	int err;
+	unsigned char v;
+
+	err = i2c_master_send(client, &reg, 1);
+	if (err != 1)
+		return err;
+
+	err = i2c_master_recv(client, &v, 1);
+	if (err != 1)
+		return err;
+
+	return v;
+}
+
+static int i2c_ov7660_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, i2c_ov7660_detect_client);
+}
+
+static int i2c_ov7660_detect_client(struct i2c_adapter *adapter,
+		int address, int kind)
+{
+	struct i2c_client *new_client;
+	int err = 0;
+
+	/* Let's see whether this adapter can support what we need.
+	 * Please substitute the things you need here!
+	 */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		goto ERROR0;
+	}
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	 * client structure, even though we cannot fill it completely yet.
+	 * But it allows us to access several i2c functions safely
+	 */
+
+	/* Note that we reserve some space for ov7660_data too. If you don't
+	 * need it, remove it. We do it here to help to lessen memory
+	 * fragmentation.
+	 */
+
+	new_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+
+	if (!new_client)  {
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	memset(new_client, 0, sizeof(struct i2c_client));
+
+	/* FIXME */
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &ov7660_driver;
+	new_client->flags = 0;
+
+	/* detect OV7660 */
+	pxa_set_cken(CKEN_CAMERA, 1);
+	mhn_mfp_set_afds(MFP_CIF_MCLK, MFP_AF0, MFP_DS04X);
+	ci_set_clock(1, 1, 2600);
+	sensor_power_on();
+	mdelay(1);
+
+	if ((i2c_ov7660_read(new_client, OV7660_PID) != PID_OV76XX) ||
+			(i2c_ov7660_read(new_client, OV7660_VER) != PID_7660)) {
+		ci_set_clock(0, 0, 2600);
+		sensor_power_off();
+		pxa_set_cken(CKEN_CAMERA, 0);
+		goto ERROR1;
+	} else {
+		extern int ov7660_detected;
+		ov7660_detected = 1;
+		pr_info("OV7660 detected.\n");
+	}
+	ci_set_clock(0, 0, 2600);
+	sensor_power_off();
+	pxa_set_cken(CKEN_CAMERA, 0);
+
+	g_client = new_client;
+
+	strcpy(new_client->name, "OV7660");
+
+	/* Tell the i2c layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+	return 0;
+
+ERROR1:
+	kfree(new_client);
+ERROR0:
+	return err;
+}
+
+static int i2c_ov7660_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	/* Try to detach the client from i2c space */
+	if ((err = i2c_detach_client(client))) {
+		return err;
+	}
+
+	/* Frees client data too, if allocated at the same time */
+	kfree(client);
+	g_client = NULL;
+	return 0;
+}
+
+static int __init i2c_ov7660_init(void)
+{
+	int ret;
+
+	if ((ret = i2c_add_driver(&ov7660_driver))) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit i2c_ov7660_exit(void)
+{
+	i2c_del_driver(&ov7660_driver);
+}
+
+MODULE_DESCRIPTION("OV7660 I2C Client driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_ov7660_init);
+module_exit(i2c_ov7660_exit);
Index: linux-2.6.10/drivers/media/video/monahans/ov7660_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/ov7660_hw.h
@@ -0,0 +1,230 @@
+/*
+   Copyright (C) 2005, Intel Corporation.
+   Copyright (C) 2006, Marvell International Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Abstract:
+ *	contains all OV7660 specific macros, typedefs, and prototypes.
+ *	Declares no storage.
+ *
+ * Notes:
+ *	Only valid for processor code named Monahans.
+ */
+
+#ifndef __MONAHANS_CAM_OV7660_HW_HEADER__
+#define __MONAHANS_CAM_OV7660_HW_HEADER__
+
+/*
+ * Constants & Structures
+ */
+/* Revision constants */
+#define PID_OV76XX			0x76
+#define PID_7660			0x60
+
+/* Return codes */
+#define OV_ERR_NONE			0x00
+#define OV_ERR_TIMEOUT			-1
+#define OV_ERR_PARAMETER		-2
+#define OV_COMM_ERR			-3
+
+/* Output Size & Format */
+#define OV_SIZE_QQVGA			0x01
+#define OV_SIZE_QVGA			(OV_SIZE_QQVGA << 1)
+#define OV_SIZE_VGA			(OV_SIZE_QQVGA << 2)
+#define OV_SIZE_QQCIF			0x10
+#define OV_SIZE_QCIF			(OV_SIZE_QQCIF << 1)
+#define OV_SIZE_CIF			(OV_SIZE_QQCIF << 2)
+#define OV_FORMAT_YUV_422		1
+#define OV_FORMAT_RGB_565		2
+#define OV_FORMAT_RAW8			3
+
+/* Camera Mode */
+#define VIEWFINDER_MODE     0x10
+#define STILLFRAME_MODE     0x20
+
+/* Others */
+#define OV7660_TIMEOUT    1000    /* ms to timeout */
+
+/* OV7660 Register Definitions */
+#define OV7660_GAIN		0x0000
+#define OV7660_BLUE		0x0001
+#define OV7660_RED		0x0002
+#define OV7660_VREF		0x0003
+#define OV7660_COM1		0x0004
+#define OV7660_BAVE		0x0005	/* U/B Average Level */
+#define OV7660_GEAVE		0x0006	/* Y/Ge Average Level */
+#define OV7660_GOAVE		0x0007	/* Y/Go Average Level */
+#define OV7660_RAVE		0x0008	/* V/R Average level */
+#define OV7660_COM2		0x0009	/* Common control 2 */
+#define OV7660_PID		0x000A	/* Product ID */
+#define OV7660_VER		0x000B	/* Version */
+#define OV7660_COM3		0x000C
+#define OV7660_COM4		0x000D
+#define OV7660_COM5		0x000E
+#define OV7660_COM6		0x000F
+#define OV7660_AECH		0x0010
+#define OV7660_CLKRC		0x0011
+#define OV7660_COM7		0x0012
+#define OV7660_COM8		0x0013
+#define OV7660_COM9		0x0014
+#define OV7660_COM10		0x0015
+#define OV7660_WS		0x0016
+#define OV7660_HSTART		0x0017
+#define OV7660_HSTOP		0x0018
+#define OV7660_VSTRT		0x0019
+#define OV7660_VSTOP		0x001A
+#define OV7660_PSHFT		0x001B
+#define OV7660_MIDH		0x001C
+#define OV7660_MIDL		0x001D
+#define OV7660_DLY		0x001E
+#define OV7660_LAEC		0x001F
+#define OV7660_BOS		0x0020
+#define OV7660_GBOS		0x0021
+#define OV7660_GROS		0x0022
+#define OV7660_ROS		0x0023
+#define OV7660_AEW		0x0024
+#define OV7660_AEB		0x0025
+#define OV7660_VPT		0x0026
+#define OV7660_BBIAS		0x0027
+#define OV7660_GbBIAS		0x0028
+#define OV7660_GrBIAS		0x0029
+#define OV7660_EXHCH		0x002A
+#define OV7660_EXHCL		0x002B
+#define OV7660_RBIAS		0x002C
+#define OV7660_ADVFL		0x002D
+#define OV7660_ADVFH		0x002E
+#define OV7660_YAVE		0x002F
+#define OV7660_HSYST		0x0030
+#define OV7660_HSYEN		0x0031
+#define OV7660_HREF		0x0032
+#define OV7660_CHLF		0x0033
+#define OV7660_ARBLM		0x0034
+#define OV7660_VRHL		0x0035
+#define OV7660_VIDO		0x0036
+#define OV7660_ADC		0x0037
+#define OV7660_ACOM		0x0038
+#define OV7660_OFON		0x0039
+#define OV7660_TSLB		0x003A
+#define OV7660_COM11		0x003B
+#define OV7660_COM12		0x003C
+#define OV7660_COM13		0x003D
+#define OV7660_COM14		0x003E
+#define OV7660_EDGE		0x003F
+#define OV7660_COM15		0x0040
+#define OV7660_COM16		0x0041
+#define OV7660_COM17		0x0042
+#define OV7660_AWBTH1		0x0043
+#define OV7660_AWBTH2		0x0044
+#define OV7660_AWBTH3		0x0045
+#define OV7660_AWBTH4		0x0046
+#define OV7660_AWBTH5		0x0047
+#define OV7660_AWBTH6		0x0048
+#define OV7660_RSVD49		0x0049
+#define OV7660_MTX1		0x004F
+#define OV7660_MTX2		0x0050
+#define OV7660_MTX3		0x0051
+#define OV7660_MTX4		0x0052
+#define OV7660_MTX5		0x0053
+#define OV7660_MTX6		0x0054
+#define OV7660_MTX7		0x0055
+#define OV7660_MTX8		0x0056
+#define OV7660_MTX9		0x0057
+#define OV7660_MTXS		0x0058
+#define OV7660_AWBC1		0x0059
+#define OV7660_AWBC2		0x005A
+#define OV7660_AWBC3		0x005B
+#define OV7660_AWBC4		0x005C
+#define OV7660_AWBC5		0x005D
+#define OV7660_AWBC6		0x005E
+#define OV7660_AWBC7		0x005F
+#define OV7660_AWBC8		0x0060
+#define OV7660_AWBC9		0x0061
+#define OV7660_LCC1		0x0062
+#define OV7660_LCC2		0x0063
+#define OV7660_LCC3		0x0064
+#define OV7660_LCC4		0x0065
+#define OV7660_LCC5		0x0066
+#define OV7660_MANU		0x0067
+#define OV7660_MANV		0x0068
+#define OV7660_HV		0x0069
+#define OV7660_MBD		0x006A
+#define OV7660_DBLV		0x006B
+#define OV7660_GSP0		0x006C
+#define OV7660_GSP1		0x006D
+#define OV7660_GSP2		0x006E
+#define OV7660_GSP3		0x006F
+#define OV7660_GSP4		0x0070
+#define OV7660_GSP5		0x0071
+#define OV7660_GSP6		0x0072
+#define OV7660_GSP7		0x0073
+#define OV7660_GSP8		0x0074
+#define OV7660_GSP9		0x0075
+#define OV7660_GSP10		0x0076
+#define OV7660_GSP11		0x0077
+#define OV7660_GSP12		0x0078
+#define OV7660_GSP13		0x0079
+#define OV7660_GSP14		0x007A
+#define OV7660_GSP15		0x007B
+#define OV7660_GST0		0x007C
+#define OV7660_GST1		0x007D
+#define OV7660_GST2		0x007E
+#define OV7660_GST3		0x007F
+#define OV7660_GST4		0x0080
+#define OV7660_GST5		0x0081
+#define OV7660_GST6		0x0082
+#define OV7660_GST7		0x0083
+#define OV7660_GST8		0x0084
+#define OV7660_GST9		0x0085
+#define OV7660_GST10		0x0086
+#define OV7660_GST11		0x0087
+#define OV7660_GST12		0x0088
+#define OV7660_GST13		0x0089
+#define OV7660_GST14		0x008A
+
+/* End of OV7660 register */
+#define OV7660_REGEND		(0xA3 + 1)
+
+/*
+ * Function Prototype
+ */
+int ov7660hw_set_regs(const u8 *regP);
+int ov7660hw_read_all_regs(u8 *bufP, u32 numRegs);
+
+void ov7660hw_power_down(u8 powerMode);
+void ov7660hw_reset(void);
+void ov7660hw_wait(int ms);
+
+int ov7660hw_version_revision(u8 * pCmRevision, u8 *pSensorRevision);
+void ov7660hw_set_hsync(void);
+void ov7660hw_auto_function_on(void);
+void ov7660hw_auto_function_off(void);
+
+int ov7660hw_viewfinder_on(void);
+int ov7660hw_viewfinder_off(void);
+int ov7660hw_halt_video_output(void);
+int ov7660hw_resumeto_full_output_mode(void);
+int ov7660hw_get_single_image(void);
+
+int ov7660hw_set_format(u32 captureSizeFormat, u32 colorFormat, u32 mode);
+int ov7660hw_read_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov7660hw_write_sensor_reg(const u8 subAddress, u8 *bufP);
+int ov7660hw_set_contrast(u32 value);
+int ov7660hw_set_exposure(u32 value);
+int ov7660hw_set_white_balance(u32 value);
+
+#endif
Index: linux-2.6.10/drivers/media/video/monahans/pxa_camera_zl.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/media/video/monahans/pxa_camera_zl.c
@@ -0,0 +1,2888 @@
+/*
+ * pxa_camera_zl - main file for camera driver
+ *
+ * Copyright (C) 2005, Intel Corporation.
+ * Copyright (C) 2006, Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * (C) Copyright 2006 Marvell International Ltd.
+ * All Rights Reserved
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/interrupt.h>
+#include <linux/videodev.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/cpufreq.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <asm/mach-types.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+#include <asm/hardware.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <asm/bug.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/cpu-freq-voltage-mhn.h>
+#include <asm/arch/mhn_pmic.h>
+
+#include <linux/mm.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/pxa_camera_zl.h>
+
+#include "ov2620.h"
+#include "ov2630.h"
+#include "ov7660.h"
+#include "camera.h"
+#include "ci.h"
+
+int ov7660_detected = 0;
+int ov2620_detected = 0;
+int ov2630_detected = 0;
+
+/* #define HW_IP_OV7660 */
+
+#define        PXA_CAMERA_VERSION    KERNEL_VERSION(0, 0, 1)
+
+/*
+ * main camera driver macros and data
+ */
+
+/* This mask just enable EOFX interrupt */
+#define    INT_MASK    CAMERA_INTMASK_FIFO_OVERRUN |	\
+	CAMERA_INTMASK_END_OF_FRAME |			\
+	CAMERA_INTMASK_START_OF_FRAME |			\
+	CAMERA_INTMASK_CI_DISABLE_DONE |		\
+	CAMERA_INTMASK_CI_QUICK_DISABLE |		\
+	CAMERA_INTMASK_PARITY_ERROR |			\
+	CAMERA_INTMASK_END_OF_LINE |			\
+	CAMERA_INTMASK_FIFO_EMPTY  |			\
+	CAMERA_INTMASK_TIME_OUT  |			\
+	CAMERA_INTMASK_FIFO3_UNDERRUN |			\
+	CAMERA_INTMASK_BRANCH_STATUS |			\
+	/*CAMERA_INTMASK_ENF_OF_FRAME_TRANSFER |*/	\
+	CAMERA_INTMASK_DMA_CHANNEL0_STOP |		\
+	CAMERA_INTMASK_DMA_CHANNEL1_STOP |		\
+	CAMERA_INTMASK_DMA_CHANNEL2_STOP |		\
+	CAMERA_INTMASK_DMA_CHANNEL3_STOP
+
+#define DMA_DESCRIPTOR_SIZE (sizeof(struct ci_dma_descriptor))
+
+#define SENSOR_NUMBER  4
+
+#define SET_OV2620_SENSOR(cam_ctx)  do {			\
+	cam_ctx->sensor_type = CAMERA_TYPE_OMNIVISION_2620;	\
+	cam_ctx->camera_functions->init = ov2620_init;		\
+	cam_ctx->camera_functions->deinit = ov2620_deinit;	\
+	cam_ctx->camera_functions->set_capture_format =		\
+			ov2620_set_capture_format;		\
+	cam_ctx->camera_functions->start_capture =		\
+			ov2620_start_capture;			\
+	cam_ctx->camera_functions->stop_capture =		\
+			ov2620_stop_capture;			\
+	cam_ctx->camera_functions->sleep = ov2620_sleep;	\
+	cam_ctx->camera_functions->wakeup = ov2620_wake;	\
+	cam_ctx->camera_functions->read_8bit =			\
+			ov2620_read_8bit;			\
+	cam_ctx->camera_functions->write_8bit =			\
+			ov2620_write_8bit;			\
+	cam_ctx->camera_functions->read_16bit = NULL;		\
+	cam_ctx->camera_functions->write_16bit = NULL;		\
+	cam_ctx->camera_functions->read_32bit = NULL;		\
+	cam_ctx->camera_functions->write_32bit = NULL;		\
+	cam_ctx->camera_functions->set_power_mode =		\
+			ov2620_set_power_mode;			\
+	cam_ctx->camera_functions->set_contrast =		\
+			ov2620_set_contrast;			\
+	cam_ctx->camera_functions->set_whitebalance =		\
+			ov2620_set_white_balance;		\
+	cam_ctx->camera_functions->set_exposure =		\
+			ov2620_set_exposure;			\
+	cam_ctx->camera_functions->set_zoom = NULL;		\
+} while (0)
+
+#define SET_OV2630_SENSOR(cam_ctx)  do {			\
+	cam_ctx->sensor_type = CAMERA_TYPE_OMNIVISION_2630;	\
+	cam_ctx->camera_functions->init = ov2630_init;		\
+	cam_ctx->camera_functions->deinit = ov2630_deinit;	\
+	cam_ctx->camera_functions->set_capture_format =		\
+			ov2630_set_capture_format;		\
+	cam_ctx->camera_functions->start_capture =		\
+			ov2630_start_capture;			\
+	cam_ctx->camera_functions->stop_capture =		\
+			ov2630_stop_capture;			\
+	cam_ctx->camera_functions->sleep = ov2630_sleep;	\
+	cam_ctx->camera_functions->wakeup = ov2630_wake;	\
+	cam_ctx->camera_functions->read_8bit =			\
+			ov2630_read_8bit;			\
+	cam_ctx->camera_functions->write_8bit =			\
+			ov2630_write_8bit;			\
+	cam_ctx->camera_functions->read_16bit = NULL;		\
+	cam_ctx->camera_functions->write_16bit = NULL;		\
+	cam_ctx->camera_functions->read_32bit = NULL;		\
+	cam_ctx->camera_functions->write_32bit = NULL;		\
+	cam_ctx->camera_functions->set_power_mode =		\
+			ov2630_set_power_mode;			\
+	cam_ctx->camera_functions->set_contrast =		\
+			ov2630_set_contrast;			\
+	cam_ctx->camera_functions->set_whitebalance =		\
+			ov2630_set_white_balance;		\
+	cam_ctx->camera_functions->set_exposure =		\
+			ov2630_set_exposure;			\
+	cam_ctx->camera_functions->set_zoom = NULL;		\
+} while (0)
+
+#define SET_OV7660_SENSOR(cam_ctx)  do {			\
+	cam_ctx->sensor_type = CAMERA_TYPE_OMNIVISION_7660;	\
+	cam_ctx->camera_functions->init = ov7660_init;		\
+	cam_ctx->camera_functions->deinit = ov7660_deinit;	\
+	cam_ctx->camera_functions->set_capture_format =		\
+			ov7660_set_capture_format;		\
+	cam_ctx->camera_functions->start_capture =		\
+			ov7660_start_capture;			\
+	cam_ctx->camera_functions->stop_capture =		\
+			ov7660_stop_capture;			\
+	cam_ctx->camera_functions->sleep = ov7660_sleep;	\
+	cam_ctx->camera_functions->wakeup = ov7660_wake;	\
+	cam_ctx->camera_functions->read_8bit =			\
+			ov7660_read_8bit;			\
+	cam_ctx->camera_functions->write_8bit =			\
+			ov7660_write_8bit;			\
+	cam_ctx->camera_functions->read_16bit = NULL;		\
+	cam_ctx->camera_functions->write_16bit = NULL;		\
+	cam_ctx->camera_functions->read_32bit = NULL;		\
+	cam_ctx->camera_functions->write_32bit = NULL;		\
+	cam_ctx->camera_functions->set_power_mode =		\
+			ov7660_set_power_mode;			\
+	cam_ctx->camera_functions->set_contrast =		\
+			ov7660_set_contrast;			\
+	cam_ctx->camera_functions->set_whitebalance =		\
+			ov7660_set_white_balance;		\
+	cam_ctx->camera_functions->set_exposure =		\
+			ov7660_set_exposure;			\
+	cam_ctx->camera_functions->set_zoom = NULL;		\
+} while (0)
+
+#define SET_DEFAULT_SENSOR(cam_ctx)	SET_OV7660_SENSOR(cam_ctx)
+
+/* default value */
+#define WIDTH_DEFT		176
+#define HEIGHT_DEFT		144
+#define FRAMERATE_DEFT		0
+
+/* sensor capability*/
+#define OV_2620_MAX_WIDTH	1600
+#define OV_2620_MAX_HEIGHT	1200
+#define OV_2620_MIN_WIDTH	2
+#define OV_2620_MIN_HEIGHT	2
+
+#define OV_2630_MAX_WIDTH	1600
+#define OV_2630_MAX_HEIGHT	1200
+#define OV_2630_MIN_WIDTH	2
+#define OV_2630_MIN_HEIGHT	2
+
+#define OV_7660_MAX_WIDTH	640
+#define OV_7660_MAX_HEIGHT	480
+#define OV_7660_MIN_WIDTH	88
+#define OV_7660_MIN_HEIGHT	72
+
+extern int pxa_i2c_write(u8 slaveaddr, const u8 * bytesbuf, u32 bytescount);
+
+static int pxa_camera_minor = 0;
+static p_camera_context_t g_camera_context;
+
+struct pxa_camera_driver_status_t {
+	int		still_buf_ready;
+	int		video_buf_ready;
+	int		still_buf_submited;
+	int		video_buf_submited;
+	int		still_capture_started;
+	int		video_capture_started;
+	struct		list_head still_buf_head;
+	struct		list_head video_buf_head;
+	struct		list_head still_report_head;
+	struct		list_head video_report_head;
+	unsigned int	still_timeperframe_numerator;
+	unsigned int	video_timeperframe_numerator;
+	unsigned int	still_timeperframe_denominator;
+	unsigned int	video_timeperframe_denominator;
+
+	int		capture_mode;
+	int		*p_buf_ready;
+	int		*p_buf_submited;
+	int		*p_capture_started;
+	struct		list_head *p_buf_head;
+	struct		list_head *p_report_head;
+	unsigned int	*p_timeperframe_numerator;
+	unsigned int	*p_timeperframe_denominator;
+	wait_queue_head_t camera_wait_q;
+	int		task_waiting;
+	int		driver_opened;
+
+	int		re_init_needed;
+	int		re_bufprepare_needed;
+	int		re_bufsubmit_needed;
+	int		re_formatset_needed;
+
+	int		i2c_inited;
+	int		suspended;
+};
+static struct pxa_camera_driver_status_t g_camdrv_status;
+
+static int pxa_camera_open(struct inode *inode, struct file *file);
+static int pxa_camera_close(struct inode *inode, struct file *file);
+static int pxa_camera_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long param);
+static ssize_t pxa_camera_read(struct file *file, char __user * buf,
+		size_t count, loff_t * ppos);
+static int pxa_camera_mmap(struct file *file, struct vm_area_struct *vma);
+static unsigned int pxa_camera_poll(struct file *file, poll_table * wait);
+static void pxa_camera_release(struct video_device *dev);
+
+/* Internal function */
+static int pxa_camera_ioctl_streamon(struct pxa_camera_driver_status_t
+		*p_camdrv_status);
+static void pxa_camera_ioctl_streamoff(struct pxa_camera_driver_status_t
+		*p_camdrv_status);
+static int pxa_camera_reset(struct pxa_camera_driver_status_t *p_camdrv_status);
+static int pxa_camera_get_framerate(struct pxa_camera_driver_status_t
+		*p_camdrv_status);
+
+static struct file_operations pxa_camera_fops = {
+	.owner		= THIS_MODULE,
+	.open		= pxa_camera_open,
+	.release	= pxa_camera_close,
+	.ioctl		= pxa_camera_ioctl,
+	.read		= pxa_camera_read,
+	.mmap		= pxa_camera_mmap,
+	.poll		= pxa_camera_poll,
+	.llseek		= no_llseek,
+};
+
+static struct video_device vd = {
+	.name		= "PXA Camera",
+	.type		= VID_TYPE_CAPTURE,
+	.hardware	= 50,		/* FIXME */
+	.fops		= &pxa_camera_fops,
+	.release	= pxa_camera_release,
+	.minor		= -1,
+};
+
+struct pxa_camera_format {
+	char *name;		/* format description */
+	int palette;		/* video4linux 1      */
+	int fourcc;		/* video4linux 2      */
+	int depth;		/* bit/pixel          */
+};
+
+static const struct pxa_camera_format pxa_camera_formats[] = {
+	{
+		.name		= "RGB565",
+		.palette	= VIDEO_PALETTE_RGB565,
+		.fourcc		= V4L2_PIX_FMT_RGB565X,
+		.depth		= 16,
+	}, {
+#if defined(CONFIG_PXA310)
+		.name 		= "YCbCr4:2:0",
+		.palette 	= VIDEO_PALETTE_YUV420,
+		.fourcc 	= V4L2_PIX_FMT_YUV420,
+		.depth 	= 16,
+	}, {
+#endif
+		.name 		= "YCbCr4:2:2(Planar)",
+		.palette 	= VIDEO_PALETTE_YUV422P,
+		.fourcc 	= V4L2_PIX_FMT_YUV422P,
+		.depth 		= 16,
+	}, {
+		.name 		= "RawRGGB 8 bit",
+		.palette 	= VIDEO_PALETTE_RGGB8,
+		.fourcc 	= V4L2_PIX_FMT_SRGGB8,
+		.depth 		= 8,
+	}, {
+		.name 		= "RawRGGB 10 bit",
+		.palette 	= VIDEO_PALETTE_RGGB10,
+		.fourcc 	= V4L2_PIX_FMT_SRGGB10,
+		.depth 		= 16,
+	}
+};
+
+const unsigned int PXA_CAMERA_FORMATS = ARRAY_SIZE(pxa_camera_formats);
+
+/* look up table: sensor input format <--> qci output format*/
+struct pxa_camera_format_t {
+	unsigned int input_format;
+	unsigned int output_format;
+};
+
+static struct pxa_camera_format_t ov7660_input_format_lut[] = {
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_RGB565,
+		.output_format	= CAMERA_IMAGE_FORMAT_RGB565,
+	},
+#ifdef HW_IP_OV7660
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW8,
+		.output_format	= CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW8,
+		.output_format	= CAMERA_IMAGE_FORMAT_RGB888_PACKED,
+	},
+#else
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR,
+		.output_format	= CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR,
+	},
+#endif
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW8,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW8,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW10,
+	}, {
+#if defined(CONFIG_PXA310)
+		.input_format	= CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR,
+		.output_format	= CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR,
+	}, {
+#endif
+		.input_format	= CAMERA_IMAGE_FORMAT_MAX + 1,
+		.output_format	= CAMERA_IMAGE_FORMAT_MAX + 1
+	},
+};
+
+static struct pxa_camera_format_t ov2620_input_format_lut[] = {
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW10,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW8,
+	},
+#if 0				/*will support in MH B0 */
+	{CAMERA_IMAGE_FORMAT_RAW10, CAMERA_IMAGE_FORMAT_RGB565},
+	{CAMERA_IMAGE_FORMAT_RAW10, CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR},
+#endif
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_MAX + 1,
+		.output_format	= CAMERA_IMAGE_FORMAT_MAX + 1
+	},
+};
+
+static struct pxa_camera_format_t ov2630_input_format_lut[] = {
+	{
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW10,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RAW8,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_RGB888_PACKED,
+	}, {
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR,
+	}, {
+#if defined(CONFIG_PXA310)
+		.input_format	= CAMERA_IMAGE_FORMAT_RAW10,
+		.output_format	= CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR,
+	}, {
+#endif
+		.input_format	= CAMERA_IMAGE_FORMAT_MAX + 1,
+		.output_format	= CAMERA_IMAGE_FORMAT_MAX + 1,
+	},
+};
+
+/*
+ * buffer list
+ */
+
+struct buf_node {
+	unsigned int io_type;           /* camera IO methods */
+	struct list_head buf_head;	/* For buffer list */
+	struct list_head report_head;	/* For report buffer list */
+	void *vaddr;		/* vmap() return virtual address */
+	struct page **pages;	/* physical pages */
+	int page_num;		/* physical pages count */
+	int buf_id;		/* buffer id to let driver access */
+	int buf_index;		/* buffer index */
+	int size;		/* buffer size */
+	void *dma_desc_vaddr;	/* dma description virtual address */
+	dma_addr_t dma_desc_paddr;	/* dma description physical address */
+	int dma_desc_size;	/* dma description size */
+	void *Y_vaddr;		/* Y virtual address */
+	void *Cb_vaddr;		/* Cb virtual address */
+	void *Cr_vaddr;		/* Cr virtual address */
+	int fifo0_size;		/* fifo0 data transfer size */
+	int fifo1_size;		/* fifo1 data transfer size */
+	int fifo2_size;		/* fifo2 data transfer size */
+};
+
+static struct semaphore buf_list_sem;
+static spinlock_t report_list_lock;	/* Spin lock for report_list */
+static spinlock_t cam_queue_lock;	/* Spin lock for queue */
+
+/* page cache */
+
+#define        MAX_PAGE_CACHE         256
+struct page_cache_head {
+	struct list_head page_list;
+	int page_count;
+	spinlock_t lock;
+};
+
+static struct page_cache_head pc_head;
+
+static unsigned int camera_format_from_v4l2(__u32 fourcc)
+{
+	return (fourcc == V4L2_PIX_FMT_YUV422P) ?
+			CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR :
+#if defined(CONFIG_PXA310)
+		(fourcc == V4L2_PIX_FMT_YUV420) ?
+			CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR:
+#endif
+		(fourcc == V4L2_PIX_FMT_SRGGB8) ?
+			CAMERA_IMAGE_FORMAT_RAW8 :
+		(fourcc == V4L2_PIX_FMT_SRGGB10) ?
+			CAMERA_IMAGE_FORMAT_RAW10 :
+		(fourcc == V4L2_PIX_FMT_RGB565X) ?
+			CAMERA_IMAGE_FORMAT_RGB565 :
+		(fourcc == V4L2_PIX_FMT_RGB24) ?
+			CAMERA_IMAGE_FORMAT_RGB888_PACKED :
+			CAMERA_IMAGE_FORMAT_MAX + 1;
+}
+
+static __u32 camera_fromat_to_v4l2(unsigned int format)
+{
+	return (format == CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR) ?
+			V4L2_PIX_FMT_YUV422P :
+#if defined(CONFIG_PXA310)
+		(format == CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR) ?
+			V4L2_PIX_FMT_YUV420 :
+#endif
+		(format == CAMERA_IMAGE_FORMAT_RAW8) ?
+			V4L2_PIX_FMT_SRGGB8 :
+		(format == CAMERA_IMAGE_FORMAT_RAW10) ?
+			V4L2_PIX_FMT_SRGGB10 :
+		(format == CAMERA_IMAGE_FORMAT_RGB565) ?
+			V4L2_PIX_FMT_RGB565X : 0xffffffff;
+}
+
+static unsigned int camera_default_input(unsigned int output_format)
+{
+	struct pxa_camera_format_t *format_lut;
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	if (CAMERA_TYPE_OMNIVISION_2620 == cam_ctx->sensor_type) {
+		format_lut = ov2620_input_format_lut;
+	} else if (CAMERA_TYPE_OMNIVISION_2630 == cam_ctx->sensor_type) {
+		format_lut = ov2630_input_format_lut;
+	} else {
+		format_lut = ov7660_input_format_lut;
+	}
+
+	for (; format_lut->output_format != CAMERA_IMAGE_FORMAT_MAX + 1;
+			format_lut++) {
+		if (format_lut->output_format == output_format) {
+			return format_lut->input_format;
+		}
+	}
+
+	return CAMERA_IMAGE_FORMAT_MAX + 1;
+}
+
+static struct buf_node *camera_get_buffer_from_id(int buf_id)
+{
+	struct list_head *pos;
+	struct buf_node *buf_node;
+
+	list_for_each(pos, g_camdrv_status.p_buf_head) {
+		buf_node = list_entry(pos, struct buf_node, buf_head);
+		if (buf_node->buf_id == buf_id)
+			goto found;
+	}
+	return NULL;
+
+found:
+	return buf_node;
+}
+
+static struct buf_node *camera_get_buffer_from_index(int buf_index)
+{
+	struct list_head *pos;
+	struct buf_node *buf_node;
+
+	list_for_each(pos, g_camdrv_status.p_buf_head) {
+		buf_node = list_entry(pos, struct buf_node, buf_head);
+		if (buf_node->buf_index == buf_index)
+			goto found;
+	}
+	return NULL;
+
+found:
+	return buf_node;
+}
+
+static int camera_get_buffer_num(void)
+{
+	struct list_head *pos;
+	int buf_num = 0;
+
+	list_for_each(pos, g_camdrv_status.p_buf_head) {
+		buf_num++;
+	}
+	return buf_num;
+}
+
+static ssize_t camera_get_buffer_size(void)
+{
+	struct buf_node *buf_node;
+	ssize_t page_num;
+
+	if (!list_empty(g_camdrv_status.p_buf_head)) {
+		buf_node =
+			list_entry(g_camdrv_status.p_buf_head->next,
+					struct buf_node, buf_head);
+		page_num = buf_node->page_num;
+	} else {
+		page_num = 0;
+	}
+
+	return page_num * PAGE_SIZE;
+}
+
+static struct page *camera_alloc_page(void)
+{
+	unsigned long flags;
+	struct page *page = NULL;
+
+	if (!list_empty(&pc_head.page_list)) {
+		spin_lock_irqsave(&pc_head.lock, flags);
+		page = list_entry(pc_head.page_list.next, struct page, lru);
+		list_del(&page->lru);
+		pc_head.page_count--;
+		spin_unlock_irqrestore(&pc_head.lock, flags);
+	} else {
+		page = alloc_page(GFP_KERNEL);
+	}
+
+	return page;
+}
+
+/* camera_free_page()
+ *
+ * Free page.
+ * Param:
+ *    page:    the page will be freed
+ *    limit:
+ *        0: The page will be added to camera page cache list.
+ *           This will be very useful when app change capture mode
+ *           and capture resolution dynamically. We needn't free all
+ *           of the old pages and alloc new pages for new catpure
+ *           mode/resolution. Just need alloc/free the delta pages.
+ *        1: If the number of camera page cache list is lager than
+ *           MAX_PAGE_CACHE, the page will be free using __free_page.
+ *           Else the page will be added to page cache list.
+ *
+ */
+static void camera_free_page(struct page *page, int limit)
+{
+	unsigned long flags;
+
+	if (0 == limit) {
+		spin_lock_irqsave(&pc_head.lock, flags);
+		list_add_tail(&page->lru, &pc_head.page_list);
+		pc_head.page_count++;
+		spin_unlock_irqrestore(&pc_head.lock, flags);
+	} else {
+		if (pc_head.page_count < MAX_PAGE_CACHE) {
+			spin_lock_irqsave(&pc_head.lock, flags);
+			list_add_tail(&page->lru, &pc_head.page_list);
+			pc_head.page_count++;
+			spin_unlock_irqrestore(&pc_head.lock, flags);
+		} else {
+			set_page_count(page, 1);
+			ClearPageReserved(page);
+			__free_page(page);
+		}
+	}
+}
+
+static void camera_free_buffer_node(struct buf_node *buf_node, int limit)
+{
+	int i;
+	struct page *page = NULL;
+
+	/*
+	 * vunmap will do TLB flush for us.
+	 * We map uncachable memory, so needn't cache invalid operation here.
+	 */
+	vunmap(buf_node->vaddr);
+	if (buf_node->io_type == V4L2_MEMORY_USERPTR)
+		goto done;
+
+
+	for (i = 0; i < buf_node->page_num; i++) {
+		page = buf_node->pages[i];
+		camera_free_page(page, limit);
+	}
+
+done:
+	kfree(buf_node->pages);
+	kfree(buf_node);
+}
+
+static void camera_free_buffer_list(int capture_mode, int limit)
+{
+	struct buf_node *buf_node;
+	unsigned long flags;
+	struct list_head *p_buf_head;
+	struct list_head *p_report_head;
+
+	if (CAMERA_MODE_STILL == capture_mode) {
+		p_buf_head = &(g_camdrv_status.still_buf_head);
+		p_report_head = &(g_camdrv_status.still_report_head);
+	} else {
+		p_buf_head = &(g_camdrv_status.video_buf_head);
+		p_report_head = &(g_camdrv_status.video_report_head);
+	}
+
+	down_interruptible(&buf_list_sem);
+	while (!list_empty(p_buf_head)) {
+		buf_node =
+			list_entry(p_buf_head->next, struct buf_node, buf_head);
+		list_del_init(p_buf_head->next);
+		dma_free_coherent(NULL, buf_node->dma_desc_size,
+				buf_node->dma_desc_vaddr,
+				buf_node->dma_desc_paddr);
+		camera_free_buffer_node(buf_node, limit);
+	}
+	up(&buf_list_sem);
+
+	/* empty the report list */
+	spin_lock_irqsave(&report_list_lock, flags);
+	while (!list_empty(p_report_head)) {
+		list_del_init(p_report_head->next);
+	}
+	spin_unlock_irqrestore(&report_list_lock, flags);
+
+}
+
+static unsigned long uva_to_pa(unsigned long addr, struct page **page)
+{
+	unsigned long ret = 0UL;
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte;
+
+	pgd = pgd_offset(current->mm, addr);
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, addr);
+		if (!pmd_none(*pmd)) {
+			pte = pte_offset_map(pmd, addr);
+			if (!pte_none(*pte) && pte_present(*pte)) {
+				(*page) = pte_page(*pte);
+				ret = page_to_phys(*page);
+				ret |= (addr & (PAGE_SIZE-1));
+			}
+		}
+	}
+	return ret;
+}
+
+
+static int camera_alloc_buffer_node(struct buf_node **buf_node, unsigned long userptr, int size)
+{
+	int page_num;
+	int i, j;
+	unsigned int ret = 0;
+	struct page *page;
+	unsigned int vaddr = PAGE_ALIGN(userptr);
+	struct buf_node *buf;
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf) {
+		pr_debug("Not enough memory\n");
+		return -ENOMEM;
+	}
+
+	page_num = PAGE_ALIGN(size) / PAGE_SIZE;
+	buf->pages =
+		(struct page **)kzalloc(page_num * sizeof(long), GFP_KERNEL);
+	if (!buf->pages) {
+		pr_debug("Not enough memory\n");
+		ret = -ENOMEM;
+		goto alloc_node_error;
+	}
+
+	for (i = 0; i < page_num; i++) {
+		if (vaddr){
+			uva_to_pa(vaddr, &page);
+			vaddr += PAGE_SIZE;
+		} else {
+			page = camera_alloc_page();
+
+			if (!page) {
+				pr_debug("Not enough memory\n");
+				ret = -ENOMEM;
+				goto alloc_pages_error;
+			}
+			set_page_count(page, 1);
+			SetPageReserved(page);
+		}
+
+		buf->pages[i] = page;
+	}
+
+	buf->page_num = page_num;
+	buf->size = page_num * PAGE_SIZE;
+	buf->buf_id = -1;
+	buf->vaddr =
+		vmap(buf->pages, buf->page_num, VM_MAP,
+				pgprot_noncached(pgprot_kernel));
+
+	memset(buf->vaddr, 0, buf->size);
+
+	/* check if the memory map is OK. */
+	if (!buf->vaddr) {
+		pr_debug("vmap() failure\n");
+		ret = -EFAULT;
+		goto vmap_error;
+	}
+
+	*buf_node = buf;
+
+	return ret;
+
+vmap_error:
+alloc_pages_error:
+	for (j = 0; j < i; j++) {
+		page = buf->pages[j];
+		camera_free_page(page, 1);
+	}
+	kfree(buf->pages);
+alloc_node_error:
+	kfree(buf);
+	return ret;
+}
+
+static void camera_get_fifo_size(p_camera_context_t cam_ctx,
+		struct buf_node *buf_node, int buffer_type)
+{
+	/*
+	 * caculate the fifo0-2 transfer size
+	 */
+	unsigned int capture_output_format;
+	unsigned int capture_output_width;
+	unsigned int capture_output_height;
+	unsigned int frame_size;
+
+	capture_output_format = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		cam_ctx->video_capture_output_format :
+		cam_ctx->still_capture_output_format;
+
+	capture_output_width = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		cam_ctx->video_capture_width : cam_ctx->still_capture_width;
+
+	capture_output_height = (buffer_type == VIDEO_CAPTURE_BUFFER) ?
+		cam_ctx->video_capture_height : cam_ctx->still_capture_height;
+
+	switch (capture_output_format) {
+		case CAMERA_IMAGE_FORMAT_RAW10:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RAW9:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RAW8:
+			frame_size = capture_output_width *
+				capture_output_height;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RGB888_PACKED:
+			frame_size = capture_output_width *
+				capture_output_height * 3;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_RGB565:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PACKED:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size / 2;
+			buf_node->fifo1_size = frame_size / 4;
+			buf_node->fifo2_size = frame_size / 4;
+			break;
+#if defined(CONFIG_PXA310)
+		case CAMERA_IMAGE_FORMAT_YCBCR420_PACKED:
+			frame_size = capture_output_width *
+				capture_output_height * 3 / 2;
+			buf_node->fifo0_size = frame_size;
+			buf_node->fifo1_size = 0;
+			buf_node->fifo2_size = 0;
+			break;
+		case CAMERA_IMAGE_FORMAT_YCBCR420_PLANAR:
+			frame_size = capture_output_width *
+				capture_output_height * 2;
+			buf_node->fifo0_size = frame_size / 2;
+			buf_node->fifo1_size = frame_size / 8;
+			buf_node->fifo2_size = frame_size / 8;
+			break;
+#endif
+		default:
+			break;
+	}
+	return;
+}
+
+static int camera_prepare_buffer(p_camera_context_t cam_ctx, unsigned long userptr,
+               unsigned int buf_len, unsigned int *buf_index)
+{
+	int ret = 0;
+	int buf_type, buf_size, dma_desc_size;
+	int j;
+	void *dma_desc_virt;
+	int *buf_phy_addr_array;
+	int *dma_desc_phy_addr_array;
+
+	dma_addr_t dma_desc_phy = 0;
+	struct buf_node *buf_node = NULL;
+	unsigned int dma_desc_phy_addr_array_size;
+	unsigned long flags;
+
+	buf_type = (cam_ctx->capture_mode == CAMERA_MODE_STILL) ?
+		STILL_CAPTURE_BUFFER : VIDEO_CAPTURE_BUFFER;
+
+	if (mcam_get_buffer_size(cam_ctx, buf_type, &buf_size, &dma_desc_size)) {
+		pr_debug("Get buffer size failure!\n");
+		return -EFAULT;
+	}
+
+	if (userptr && buf_len < buf_size)
+		return -EFAULT;
+
+	buf_phy_addr_array =
+		kzalloc(PAGE_ALIGN(buf_size) / PAGE_SIZE * sizeof(long),
+				GFP_KERNEL);
+
+	if (!buf_phy_addr_array) {
+		pr_debug("No memory for record pages's physical address\n");
+		return -ENOMEM;
+	}
+
+	dma_desc_phy_addr_array_size =
+		(dma_desc_size + DMA_DESCRIPTOR_SIZE - 1) / DMA_DESCRIPTOR_SIZE;
+
+	dma_desc_phy_addr_array =
+		kzalloc(dma_desc_phy_addr_array_size * sizeof(long), GFP_KERNEL);
+
+	if (!dma_desc_phy_addr_array) {
+		pr_debug("No memory for record dma descriptors's physical address\n");
+		kfree(buf_phy_addr_array);
+		return -ENOMEM;
+	}
+
+	dma_desc_virt = dma_alloc_coherent(NULL, dma_desc_size,
+			&dma_desc_phy, GFP_KERNEL);
+
+	if (!dma_desc_virt) {
+		pr_debug("Just alloc %d number buffer node\n", camera_get_buffer_num() - 1);
+		goto exit;
+	}
+
+	ret = camera_alloc_buffer_node(&buf_node, userptr, buf_size);
+	if (ret) {
+		pr_debug("Alloc %dth buffer node failure\n", camera_get_buffer_num());
+		dma_free_coherent(NULL, dma_desc_size, dma_desc_virt,
+				dma_desc_phy);
+		goto exit;
+	}
+
+	buf_node->io_type = userptr?V4L2_MEMORY_USERPTR : V4L2_MEMORY_MMAP;
+	buf_node->buf_index = camera_get_buffer_num();
+	buf_node->dma_desc_vaddr = dma_desc_virt;
+	buf_node->dma_desc_paddr = dma_desc_phy;
+	buf_node->dma_desc_size = dma_desc_size;
+
+	pr_debug("dma_desc_virt = 0x%p, dma_desc_phy = 0x%08x\n", dma_desc_virt, dma_desc_phy);
+
+	for (j = 0; j < buf_node->page_num; j++) {
+		buf_phy_addr_array[j] = __pa(page_address(buf_node->pages[j]));
+	}
+
+	dma_desc_phy_addr_array[0] = buf_node->dma_desc_paddr;
+	for (j = 1; j < dma_desc_phy_addr_array_size; j++) {
+		dma_desc_phy_addr_array[j] =
+			dma_desc_phy_addr_array[j - 1] +
+			DMA_DESCRIPTOR_SIZE;
+	}
+
+	spin_lock_irqsave(&cam_queue_lock, flags);
+	ret = mcam_prepare_buffer(cam_ctx,
+			buf_node->vaddr,
+			(void *)buf_phy_addr_array,
+			buf_node->page_num,
+			buf_size,
+			buf_type,
+			buf_node->dma_desc_vaddr,
+			dma_desc_phy_addr_array,
+			&buf_node->buf_id,
+			&buf_node->Y_vaddr,
+			&buf_node->Cb_vaddr,
+			&buf_node->Cr_vaddr);
+	spin_unlock_irqrestore(&cam_queue_lock, flags);
+
+	if (ret) {
+		pr_debug("Prepare %dth buffer node failure\n", buf_node->buf_index + 1);
+		camera_free_buffer_node(buf_node, 1);
+		dma_free_coherent(NULL, dma_desc_size, dma_desc_virt, dma_desc_phy);
+		goto exit;
+	}
+
+	camera_get_fifo_size(cam_ctx, buf_node, buf_type);
+
+	list_add_tail(&buf_node->buf_head, g_camdrv_status.p_buf_head);
+
+exit:
+	kfree(buf_phy_addr_array);
+	kfree(dma_desc_phy_addr_array);
+
+	*(g_camdrv_status.p_buf_ready) = 1;
+
+	pr_debug("test point in camera_prepare_buffers\n");
+
+	if (buf_index)
+		*buf_index = buf_node->buf_index;
+
+	return ret;
+}
+
+static int camera_prepare_buffers(p_camera_context_t cam_ctx, int buf_num)
+{
+	int i;
+
+	for (i = 0; i < buf_num; i++)
+		camera_prepare_buffer(cam_ctx, 0, 0, NULL);
+
+	return camera_get_buffer_num();
+}
+
+static int camera_submit_buffer(p_camera_context_t cam_ctx,
+		unsigned int buf_indx)
+{
+	struct buf_node *buf_node;
+	unsigned int buf_type;
+	int ret;
+	unsigned long flags;
+
+	buf_node = camera_get_buffer_from_index(buf_indx);
+
+	if (!buf_node)
+		goto exit;
+
+	buf_type = (cam_ctx->capture_mode == CAMERA_MODE_STILL) ?
+		STILL_CAPTURE_BUFFER : VIDEO_CAPTURE_BUFFER;
+
+	spin_lock_irqsave(&cam_queue_lock, flags);
+	ret = mcam_submit_buffer(cam_ctx, buf_node->buf_id, buf_type);
+	spin_unlock_irqrestore(&cam_queue_lock, flags);
+	if (ret) {
+		pr_debug("Submit %dth buffer node failure\n", buf_indx);
+		goto exit;
+	}
+
+	*(g_camdrv_status.p_buf_submited) = 1;
+
+	return 0;
+
+exit:
+	return -EFAULT;
+}
+
+static int camera_submit_buffers(p_camera_context_t cam_ctx)
+{
+	struct list_head *pos;
+	struct buf_node *buf_node;
+	unsigned int buf_type;
+	int i = 0;
+	unsigned long flags;
+
+	if (!*(g_camdrv_status.p_buf_ready)) {
+		pr_debug("buffer not ready!\n");
+		goto exit;
+	}
+	buf_type = (cam_ctx->capture_mode == CAMERA_MODE_STILL) ?
+		STILL_CAPTURE_BUFFER : VIDEO_CAPTURE_BUFFER;
+
+	list_for_each(pos, g_camdrv_status.p_buf_head) {
+		buf_node = list_entry(pos, struct buf_node, buf_head);
+
+		spin_lock_irqsave(&cam_queue_lock, flags);
+		mcam_submit_buffer(cam_ctx, buf_node->buf_id, buf_type);
+		spin_unlock_irqrestore(&cam_queue_lock, flags);
+
+		i++;
+	}
+
+	if (i == 0) {
+		goto exit;
+	}
+
+	*(g_camdrv_status.p_buf_submited) = 1;
+
+	return 0;
+
+exit:
+	return -EFAULT;
+}
+
+static int camera_start_capture(p_camera_context_t cam_ctx)
+{
+
+	if (!*(g_camdrv_status.p_buf_submited)) {
+		pr_debug("pxa_camera: buffer not submited!\n");
+		goto exit;
+	}
+
+	mcam_set_interrupt_mask(cam_ctx, INT_MASK);
+
+	if (mcam_set_capture_format(cam_ctx)) {
+		goto exit;
+	}
+
+	cam_ctx->frame_rate = pxa_camera_get_framerate(&g_camdrv_status);
+	mcam_set_capture_frame_rate(cam_ctx);
+
+	if (CAMERA_MODE_VIDEO == cam_ctx->capture_mode) {
+		if (mcam_start_video_capture(cam_ctx)) {
+			goto exit;
+		}
+	} else {
+		if (mcam_capture_still_image(cam_ctx)) {
+			goto exit;
+		}
+	}
+
+	enable_irq(IRQ_CAMERA);
+
+	return 0;
+
+exit:
+
+	return -EFAULT;
+}
+
+static void camera_stop_capture(p_camera_context_t cam_ctx)
+{
+	/*
+	 * stop video capture
+	 * stop still capture
+	 * Note: a workaround of camera drv for stopping still capture
+	 * which has no such stop still capture primitives
+	 */
+	mcam_stop_video_capture(cam_ctx);
+	disable_irq(IRQ_CAMERA);
+
+	return;
+
+}
+
+static void camera_desubmit_buffers(p_camera_context_t cam_ctx)
+{
+	/*
+	 * stop capture: a workaround of camera drv
+	 * which has no such desubmit buffer primitives
+	 */
+
+	if (CAMERA_MODE_STILL == cam_ctx->capture_mode) {
+		cam_ctx->still_capture_buffer_queue.head = NULL;
+		cam_ctx->still_capture_buffer_queue.tail = NULL;
+	} else {
+		cam_ctx->video_capture_buffer_queue.head = NULL;
+		cam_ctx->video_capture_buffer_queue.tail = NULL;
+	}
+
+	*(g_camdrv_status.p_buf_submited) = 0;
+
+}
+
+static void camera_deprepare_buffers(p_camera_context_t cam_ctx)
+{
+	camera_free_buffer_list(cam_ctx->capture_mode, 1);
+	*(g_camdrv_status.p_buf_ready) = 0;
+}
+
+/*
+ * Init/Deinit APIs
+ */
+static int camera_init(p_camera_context_t camera_context)
+{
+
+	/* FIXME: init the Vcc for Camera analog. Should be done by system */
+	if (CAMERA_TYPE_OMNIVISION_2620 == camera_context->sensor_type) {
+		mhn_pmic_set_voltage(VCC_CAMERA_ANA, 3200);
+	} else if (CAMERA_TYPE_OMNIVISION_2630 == camera_context->sensor_type) {
+		mhn_pmic_set_voltage(VCC_CAMERA_ANA, 2800);
+	} else {
+		mhn_pmic_set_voltage(VCC_CAMERA_ANA, 2800);
+	}
+
+	/* enable QCI clock  */
+	pxa_set_cken(CKEN_CAMERA, 1);
+
+	if (!mcam_init(camera_context)) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static int camera_deinit(p_camera_context_t camera_context)
+{
+	int status;
+
+	if (!mcam_deinit(camera_context)) {
+		status = 0;
+	} else {
+		status = -EFAULT;
+	}
+
+	/* disable QCI clock  */
+	pxa_set_cken(CKEN_CAMERA, 0);
+
+	return status;
+}
+
+static void pxa_camera_set_mode(struct pxa_camera_driver_status_t
+		*p_camdrv_status, int capture_mode)
+{
+	p_camdrv_status->capture_mode = capture_mode;
+	if (CAMERA_MODE_VIDEO == capture_mode) {
+		p_camdrv_status->p_buf_ready =
+			&(p_camdrv_status->video_buf_ready);
+		p_camdrv_status->p_buf_submited =
+			&(p_camdrv_status->video_buf_submited);
+		p_camdrv_status->p_capture_started =
+			&(p_camdrv_status->video_capture_started);
+		p_camdrv_status->p_buf_head =
+			&(p_camdrv_status->video_buf_head);
+		p_camdrv_status->p_report_head =
+			&(p_camdrv_status->video_report_head);
+		p_camdrv_status->p_timeperframe_numerator =
+			&(p_camdrv_status->video_timeperframe_numerator);
+		p_camdrv_status->p_timeperframe_denominator =
+			&(p_camdrv_status->video_timeperframe_denominator);
+
+	} else {
+		p_camdrv_status->p_buf_ready =
+			&(p_camdrv_status->still_buf_ready);
+		p_camdrv_status->p_buf_submited =
+			&(p_camdrv_status->still_buf_submited);
+		p_camdrv_status->p_capture_started =
+			&(p_camdrv_status->still_capture_started);
+		p_camdrv_status->p_buf_head =
+			&(p_camdrv_status->still_buf_head);
+		p_camdrv_status->p_report_head =
+			&(p_camdrv_status->still_report_head);
+		p_camdrv_status->p_timeperframe_numerator =
+			&(p_camdrv_status->still_timeperframe_numerator);
+		p_camdrv_status->p_timeperframe_denominator =
+			&(p_camdrv_status->still_timeperframe_denominator);
+
+	}
+
+}
+
+static int camera_do_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, void *arg)
+{
+	int retval = 0;
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	if (!cam_ctx) {
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+
+		case VIDIOC_QUERYCAP:
+			{
+				struct v4l2_capability *cap = arg;
+				retval = 0;
+				memset(cap, 0, sizeof(*cap));
+
+				strcpy(cap->driver, "pxa camera");
+				strcpy(cap->card, "");
+				cap->version = PXA_CAMERA_VERSION;
+				cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+					V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;
+
+				retval = 0;
+				break;
+			}
+
+		case VIDIOC_ENUMINPUT:
+			{
+				struct v4l2_input *i = arg;
+				unsigned int n;
+
+				n = i->index;
+				if (n >= SENSOR_NUMBER) {
+					retval = -EINVAL;
+					break;
+				}
+
+				memset(i, 0, sizeof(*i));
+				i->index = n;
+				i->type = V4L2_INPUT_TYPE_CAMERA;
+
+				switch (n) {
+					case OV2620_SENSOR:
+						strcpy(i->name, "Omnivision2620");
+						break;
+
+					case OV2630_SENSOR:
+						strcpy(i->name, "Omnivision2630");
+						break;
+
+					case OV7660_SENSOR:
+						strcpy(i->name, "Omnivision7660");
+						break;
+
+					default:
+						break;
+				}
+
+				break;
+			}
+
+		case VIDIOC_ENUM_FMT:
+			{
+				struct v4l2_fmtdesc *f = arg;
+				enum v4l2_buf_type type;
+				int index;
+
+				if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (f->index >= PXA_CAMERA_FORMATS) {
+					retval = -EINVAL;
+					break;
+				}
+
+				type = f->type;
+				index = f->index;
+
+				memset(f, 0, sizeof(*f));
+				f->index = index;
+				f->type = type;
+				f->pixelformat = pxa_camera_formats[index].fourcc;
+				strlcpy(f->description,
+					pxa_camera_formats[index].name,
+					sizeof(f->description));
+
+				break;
+			}
+
+		case VIDIOC_G_FMT:
+			{
+				struct v4l2_format *f = arg;
+
+				if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (CAMERA_MODE_VIDEO == cam_ctx->capture_mode) {
+					f->fmt.pix.pixelformat =
+						camera_fromat_to_v4l2(cam_ctx->
+						video_capture_output_format);
+					f->fmt.pix.width =
+						cam_ctx->video_capture_width;
+					f->fmt.pix.height =
+						cam_ctx->video_capture_height;
+				} else {
+					f->fmt.pix.pixelformat =
+						camera_fromat_to_v4l2(cam_ctx->
+						still_capture_output_format);
+					f->fmt.pix.width =
+						cam_ctx->still_capture_width;
+					f->fmt.pix.height =
+						cam_ctx->still_capture_height;
+				}
+
+				break;
+			}
+
+		case VIDIOC_S_FMT:
+			{
+				struct v4l2_format *f = arg;
+				unsigned int pixelformat;
+				int capture_width;
+				int capture_height;
+
+				if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (CAMERA_TYPE_OMNIVISION_2620 ==
+					cam_ctx->sensor_type) {
+					if (V4L2_PIX_FMT_SRGGB10 !=
+							f->fmt.pix.pixelformat) {
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 1600) ||
+						(f->fmt.pix.height > 1200)) {
+						retval = -EINVAL;
+						break;
+					}
+				} else if (CAMERA_TYPE_OMNIVISION_2630 ==
+						cam_ctx->sensor_type) {
+					if ((V4L2_PIX_FMT_RGB24 !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_SRGGB10 !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_YUV422P !=
+							f->fmt.pix.pixelformat)
+#if defined(CONFIG_PXA310)
+						&& (V4L2_PIX_FMT_SRGGB8 !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_YUV420 !=
+							f->fmt.pix.pixelformat)) {
+#else
+						&& (V4L2_PIX_FMT_SRGGB8 !=
+							f->fmt.pix.pixelformat)) {
+#endif
+
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 1600)
+						|| (f->fmt.pix.height > 1200)) {
+						retval = -EINVAL;
+						break;
+					}
+				} else {	/* OV7660 */
+					if ((V4L2_PIX_FMT_YUV422P !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_RGB565X !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_SRGGB8 !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_SRGGB10 !=
+							f->fmt.pix.pixelformat)
+#if defined(CONFIG_PXA310)
+						&& (V4L2_PIX_FMT_RGB24 !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_YUV420 !=
+							f->fmt.pix.pixelformat)) {
+#else
+						&& (V4L2_PIX_FMT_RGB24 !=
+							f->fmt.pix.pixelformat)) {
+#endif
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 640)
+						|| (f->fmt.pix.height > 480)) {
+						retval = -EINVAL;
+						break;
+					}
+				}
+
+				pixelformat = camera_format_from_v4l2(
+						f->fmt.pix.pixelformat);
+				capture_width = f->fmt.pix.width;
+				capture_height = f->fmt.pix.height;
+
+				if (CAMERA_MODE_VIDEO == cam_ctx->capture_mode) {
+
+					if ((cam_ctx->video_capture_width !=
+							capture_width) ||
+						(cam_ctx->video_capture_height !=
+							capture_height) ||
+						(pixelformat !=
+							cam_ctx->
+							video_capture_output_format)) {
+						pxa_camera_reset(&g_camdrv_status);
+					}
+					cam_ctx->video_capture_output_format =
+						camera_format_from_v4l2(f->
+							fmt.pix.pixelformat);
+					cam_ctx->video_capture_input_format =
+						camera_default_input(cam_ctx->
+							video_capture_output_format);
+					cam_ctx->video_capture_width =
+						f->fmt.pix.width;
+					cam_ctx->video_capture_height =
+						f->fmt.pix.height;
+
+				} else {
+
+					if ((cam_ctx->still_capture_width !=
+							capture_width) ||
+						(cam_ctx->still_capture_height !=
+							capture_height)	||
+						(pixelformat != cam_ctx->
+							still_capture_output_format)) {
+						pxa_camera_reset(&g_camdrv_status);
+					}
+					cam_ctx->still_capture_output_format =
+						camera_format_from_v4l2(f->
+							fmt.pix.pixelformat);
+					cam_ctx->still_capture_input_format =
+						camera_default_input(cam_ctx->
+							still_capture_output_format);
+					cam_ctx->still_capture_width =
+						f->fmt.pix.width;
+					cam_ctx->still_capture_height =
+						f->fmt.pix.height;
+
+				}
+
+				break;
+			}
+
+		case VIDIOC_TRY_FMT:
+			{
+				struct v4l2_format *f = arg;
+
+				if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (CAMERA_TYPE_OMNIVISION_2620 ==
+						cam_ctx->sensor_type) {
+					if (V4L2_PIX_FMT_SRGGB10 !=
+							f->fmt.pix.pixelformat) {
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 1600) ||
+						(f->fmt.pix.height > 1200)) {
+						retval = -EINVAL;
+						break;
+					}
+				} else if (CAMERA_TYPE_OMNIVISION_2630 ==
+						cam_ctx->sensor_type) {
+					if (V4L2_PIX_FMT_SRGGB10 !=
+							f->fmt.pix.pixelformat) {
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 1600) ||
+						(f->fmt.pix.height > 1200)) {
+						retval = -EINVAL;
+						break;
+					}
+				} else {
+					if ((V4L2_PIX_FMT_YUV422P !=
+							f->fmt.pix.pixelformat)
+						&& (V4L2_PIX_FMT_RGB565X !=
+							f->fmt.pix.pixelformat)) {
+						retval = -EINVAL;
+						break;
+					}
+					if ((f->fmt.pix.width > 640) ||
+						(f->fmt.pix.height > 480)) {
+						retval = -EINVAL;
+						break;
+					}
+				}
+				break;
+			}
+
+		case VIDIOC_S_INPUT:
+			{
+				int *i = arg;
+				int sensor_type;
+
+				if (*(g_camdrv_status.p_capture_started)) {
+					pxa_camera_ioctl_streamoff(
+						&g_camdrv_status);
+				}
+
+				switch (*i) {
+					case OV2620_SENSOR:
+						if (ov2620_detected == 0) {
+							retval = -EINVAL;
+							return retval;
+						}
+						sensor_type =
+							CAMERA_TYPE_OMNIVISION_2620;
+						break;
+					case OV2630_SENSOR:
+						if (ov2630_detected == 0) {
+							retval = -EINVAL;
+							return retval;
+						}
+						sensor_type =
+							CAMERA_TYPE_OMNIVISION_2630;
+						break;
+					case OV7660_SENSOR:
+						if (ov7660_detected == 0) {
+							retval = -EINVAL;
+							return retval;
+						}
+						sensor_type =
+							CAMERA_TYPE_OMNIVISION_7660;
+						break;
+					default:
+						retval = -EINVAL;
+						return retval;
+				}
+
+				if (sensor_type != cam_ctx->sensor_type) {
+					mcam_deinit(cam_ctx);
+					if (sensor_type ==
+						CAMERA_TYPE_OMNIVISION_2620) {
+						SET_OV2620_SENSOR(cam_ctx);
+					} else if (sensor_type ==
+						CAMERA_TYPE_OMNIVISION_2630) {
+						SET_OV2630_SENSOR(cam_ctx);
+					} else {
+						SET_OV7660_SENSOR(cam_ctx);
+					}
+					mcam_init(cam_ctx);
+				}
+
+				break;
+			}
+
+		case VIDIOC_G_INPUT:
+			{
+				int *i = arg;
+
+				if (CAMERA_TYPE_OMNIVISION_2620 ==
+					cam_ctx->sensor_type) {
+					*i = OV2620_SENSOR;
+				} else if (CAMERA_TYPE_OMNIVISION_2630 ==
+					cam_ctx->sensor_type) {
+					*i = OV2630_SENSOR;
+				} else if (CAMERA_TYPE_OMNIVISION_7660 ==
+					cam_ctx->sensor_type) {
+					*i = OV7660_SENSOR;
+				} else {
+					retval = -EINVAL;
+				}
+				break;
+			}
+
+		case VIDIOC_G_PARM:
+			{
+				struct v4l2_streamparm *parm = arg;
+
+				if (parm->type !=
+					V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (CAMERA_MODE_STILL ==
+					cam_ctx->capture_mode) {
+					parm->parm.capture.capturemode =
+						V4L2_MODE_HIGHQUALITY;
+				} else {
+					parm->parm.capture.capturemode = 0;
+				}
+				parm->parm.capture.timeperframe.numerator =
+					*(g_camdrv_status.p_timeperframe_numerator);
+				parm->parm.capture.timeperframe.denominator =
+					*(g_camdrv_status.p_timeperframe_denominator);
+
+				break;
+			}
+
+		case VIDIOC_S_PARM:
+			{
+
+				struct v4l2_streamparm *parm = arg;
+				int capture_mode;
+
+				if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (V4L2_MODE_HIGHQUALITY ==
+						parm->parm.capture.capturemode) {
+					capture_mode = CAMERA_MODE_STILL;
+				} else {
+					capture_mode = CAMERA_MODE_VIDEO;
+				}
+
+				/* Spatial Scaling Unit(SSU) related functions */
+				if (CI_SSU_SCALE_HALF ==
+						parm->parm.capture.extendedmode) {
+					if (CAMERA_MODE_STILL == capture_mode) {
+						cam_ctx->still_capture_scale =
+							CAMERA_CAPTURE_SCALE_HALF;
+					} else {
+						cam_ctx->video_capture_scale =
+							CAMERA_CAPTURE_SCALE_HALF;
+					}
+				} else if (CI_SSU_SCALE_QUARTER ==
+						parm->parm.capture.extendedmode) {
+					if (CAMERA_MODE_STILL == capture_mode) {
+						cam_ctx->still_capture_scale =
+							CAMERA_CAPTURE_SCALE_QUATER;
+					} else {
+						cam_ctx->video_capture_scale =
+							CAMERA_CAPTURE_SCALE_QUATER;
+					}
+				} else {
+					if (CAMERA_MODE_STILL == capture_mode) {
+						cam_ctx->still_capture_scale =
+							CAMERA_CAPTURE_SCALE_DISABLE;
+					} else {
+						cam_ctx->video_capture_scale =
+							CAMERA_CAPTURE_SCALE_DISABLE;
+					}
+				}
+
+				if ((capture_mode != cam_ctx->capture_mode) ||
+					(*(g_camdrv_status.p_timeperframe_numerator) !=
+					parm->parm.capture.timeperframe.numerator) ||
+					(*(g_camdrv_status.p_timeperframe_denominator) !=
+					parm->parm.capture.timeperframe.denominator)) {
+
+					if (*(g_camdrv_status.p_capture_started)) {
+						pxa_camera_ioctl_streamoff
+							(&g_camdrv_status);
+					}
+
+					if (capture_mode != cam_ctx->capture_mode) {
+						cam_ctx->capture_mode = capture_mode;
+						pxa_camera_set_mode(&g_camdrv_status,
+								cam_ctx->
+								capture_mode);
+					}
+
+					*(g_camdrv_status.p_timeperframe_numerator) =
+						parm->parm.capture.timeperframe.numerator;
+					*(g_camdrv_status.p_timeperframe_denominator) =
+						parm->parm.capture.timeperframe.denominator;
+
+				}
+
+				break;
+
+			}
+
+		case VIDIOC_S_CTRL:
+			{
+				struct v4l2_control *ctrl = arg;
+
+				switch (ctrl->id) {
+					case V4L2_CID_CONTRAST:
+						retval = mcam_set_contrast_value(
+							cam_ctx,
+							SENSOR_MANUAL_CONTRAST,
+							ctrl->value);
+						break;
+					case V4L2_CID_DO_WHITE_BALANCE:
+						retval =
+							mcam_set_white_balance_value(
+							cam_ctx,
+							SENSOR_MANUAL_WHITEBALANCE,
+							ctrl->value);
+						break;
+					case V4L2_CID_EXPOSURE:
+						retval =
+							mcam_set_exposure_value(cam_ctx,
+							SENSOR_MANUAL_EXPOSURE,
+							ctrl->value);
+						break;
+					default:
+						retval = -EINVAL;
+						break;
+				}
+				break;
+			}
+
+		case VIDIOC_G_CTRL:
+			{
+				/* do nothing */
+				break;
+			}
+
+		case VIDIOC_QUERYBUF:
+			{
+				struct v4l2_buffer *buf = arg;
+				int buf_size;
+
+				if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (buf->memory != V4L2_MEMORY_MMAP) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (buf->index >= camera_get_buffer_num()) {
+					retval = -EINVAL;
+					break;
+				}
+
+				buf_size = camera_get_buffer_size();
+				buf->length = buf_size;
+				buf->m.offset = buf->index * buf_size;
+
+				break;
+			}
+
+		case VIDIOC_QBUF:
+			{
+				struct v4l2_buffer *buf = arg;
+
+				unsigned long flags;
+
+				if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (buf->memory != V4L2_MEMORY_MMAP && (buf->memory != V4L2_MEMORY_USERPTR)) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if ((buf->memory == V4L2_MEMORY_USERPTR) && (buf->length > 0)) {
+					if (camera_prepare_buffer(cam_ctx, buf->m.userptr, buf->length, &buf->index)) {
+						retval = -EINVAL;
+						break;
+					}
+				}
+
+				if (buf->index >= camera_get_buffer_num()) {
+					retval = -EINVAL;
+					break;
+				}
+
+				spin_lock_irqsave(&report_list_lock, flags);
+				retval = camera_submit_buffer(cam_ctx, buf->index);
+				spin_unlock_irqrestore(&report_list_lock, flags);
+
+				break;
+			}
+
+		case VIDIOC_DQBUF:
+			{
+				struct v4l2_buffer *buf = arg;
+				struct buf_node *buf_node;
+				unsigned long flags;
+
+				if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (buf->memory != V4L2_MEMORY_MMAP && (buf->memory != V4L2_MEMORY_USERPTR)) {
+					retval = -EINVAL;
+					break;
+				}
+
+				spin_lock_irqsave(&report_list_lock, flags);
+
+				if (!list_empty(g_camdrv_status.p_report_head)) {
+					buf_node =
+						list_entry(
+						g_camdrv_status.p_report_head->
+						next,
+						struct buf_node,
+						report_head);
+					BUG_ON(!buf_node);
+
+					list_del(&buf_node->report_head);
+
+					buf->index = buf_node->buf_index;
+
+				} else
+					retval = -EIO;
+				spin_unlock_irqrestore(&report_list_lock, flags);
+
+				break;
+			}
+
+		case VIDIOC_REQBUFS:
+			{
+				struct v4l2_requestbuffers *req = arg;
+				int count;
+
+				if (req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				if (req->type != V4L2_MEMORY_MMAP && (req->memory != V4L2_MEMORY_USERPTR)) {
+					retval = -EINVAL;
+					break;
+				}
+
+				camera_deprepare_buffers(cam_ctx);
+
+				if ((req->reserved[0] & 0x1) == YUV_NO_PADDING)
+					cam_ctx->align_type = YUV_NO_PADDING;
+				else
+					cam_ctx->align_type = YUV_HAVE_PADDING;
+
+				if (req->memory == V4L2_MEMORY_USERPTR)
+					break;
+
+				count = camera_prepare_buffers(cam_ctx, req->count);
+				if (count < 0)
+					retval = -EFAULT;
+				else
+					req->count = count;
+
+				break;
+			}
+
+		case VIDIOC_STREAMON:
+			{
+				int *type = arg;
+
+				if (*type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				retval = pxa_camera_ioctl_streamon(
+						&g_camdrv_status);
+
+				break;
+			}
+
+		case VIDIOC_STREAMOFF:
+			{
+				int *type = arg;
+
+				if (*type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+					retval = -EINVAL;
+					break;
+				}
+
+				pxa_camera_ioctl_streamoff(&g_camdrv_status);
+
+				break;
+			}
+
+			/* Application extended IOCTL.  */
+			/* Register access interface    */
+
+		case WCAM_VIDIOCGCIREG:
+			{
+				struct reg_set_s *reg = arg;
+				reg->val2 =  __raw_readl(
+					((unsigned int)cam_ctx->ci_reg_base
+					  + (reg->val1)));
+				break;
+
+			}
+
+		case WCAM_VIDIOCSCIREG:
+			{
+				struct reg_set_s *reg = arg;
+				unsigned int regVal;
+
+				__raw_writel(reg->val2, (unsigned int)cam_ctx->
+					ci_reg_base + reg->val1);
+				regVal =
+					__raw_readl((unsigned int)cam_ctx->
+						ci_reg_base + reg->val1);
+				if (regVal != reg->val2) {
+					retval = -EFAULT;
+					break;
+				}
+				break;
+			}
+
+		case WCAM_VIDIOCGCAMREG:
+			{
+				struct reg_set_s *reg = arg;
+				unsigned char regVal;
+
+				mcam_read_8bit(cam_ctx, (unsigned char)reg->val1, &regVal);
+				reg->val2 = regVal;
+
+				break;
+
+			}
+
+		case WCAM_VIDIOCSCAMREG:
+			{
+				struct reg_set_s *reg = arg;
+				mcam_write_8bit(cam_ctx, (unsigned char)reg->val1,
+					(unsigned char)reg->val2);
+				break;
+			}
+
+		case WCAM_VIDIOCGHST:
+			{
+				struct hst_context_s *hst_ctx = arg;
+				unsigned int color_type = CI_HISTO_GREEN1;
+				unsigned short *ptemp;
+				int i, count;
+				unsigned int hst_sum = 0;
+
+				if (HST_COLOR_RED == hst_ctx->color) {
+					color_type = CI_HISTO_RED;
+				} else if (HST_COLOR_BLUE == hst_ctx->color) {
+					color_type = CI_HISTO_BLUE;
+				} else if (HST_COLOR_GREEN1 == hst_ctx->color) {
+					color_type = CI_HISTO_GREEN1;
+				} else if (HST_COLOR_GREEN2 == hst_ctx->color) {
+					color_type = CI_HISTO_GREEN2;
+				}
+
+				disable_irq(IRQ_CAMERA);
+				mcam_get_histogram_info(cam_ctx, color_type,
+					&(hst_ctx->size), &(hst_ctx->sum));
+				enable_irq(IRQ_CAMERA);
+				ptemp =	(unsigned short *)cam_ctx->
+						histogram_lut_buffer_virtual;
+
+				/* software work around for sum */
+				count = hst_ctx->size / 2;
+				for (i = 0; i < count; i++) {
+					hst_sum += i * (ptemp[i]);
+				}
+				hst_ctx->sum = hst_sum;
+				retval = copy_to_user((char __user *)hst_ctx->hst,
+						(void *)(cam_ctx->
+						 histogram_lut_buffer_virtual),
+						hst_ctx->size);
+
+				break;
+			}
+
+		default:
+			{
+				retval = -ENOIOCTLCMD;
+				break;
+			}
+	}
+
+	return retval;
+}
+
+static irqreturn_t pxa_camera_irq(int irq, void *dev_id, struct pt_regs * regs)
+{
+	unsigned int int_state;
+	p_camera_context_t cam_ctx = g_camera_context;
+	int buf_id;
+	struct buf_node *buf_node;
+	unsigned long flags1, flags2;
+
+	int_state = mcam_get_interrupt_status(cam_ctx);
+
+	spin_lock_irqsave(&report_list_lock, flags1);
+	spin_lock_irqsave(&cam_queue_lock, flags2);
+
+	if (!mcam_get_filled_buffer(cam_ctx, &buf_id)) {
+		buf_node = camera_get_buffer_from_id(buf_id);
+		if (&buf_node->report_head != g_camdrv_status.p_report_head->next) {
+			list_add_tail(&buf_node->report_head, g_camdrv_status.p_report_head);
+		}
+		if (g_camdrv_status.task_waiting) {
+			wake_up_interruptible(&(g_camdrv_status. camera_wait_q));
+			g_camdrv_status.task_waiting = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&cam_queue_lock, flags2);
+	spin_unlock_irqrestore(&report_list_lock, flags1);
+
+	mcam_clear_interrupt_status(cam_ctx, int_state);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Application interface
+ */
+
+static int pxa_camera_get_framerate(struct pxa_camera_driver_status_t
+		*p_camdrv_status)
+{
+
+	p_camera_context_t cam_ctx = g_camera_context;
+	unsigned int sensor_timeperframe_numerator = 0;
+	unsigned int sensor_timeperframe_denominator = 0;
+	unsigned int framerate;
+
+	if ((0 == *(p_camdrv_status->p_timeperframe_denominator))
+			|| (0 == *(p_camdrv_status->p_timeperframe_numerator))) {
+		framerate = 0;
+		return framerate;
+
+	}
+
+	if (CAMERA_TYPE_OMNIVISION_2620 == cam_ctx->sensor_type) {
+		switch (cam_ctx->capture_input_format) {
+			case CAMERA_IMAGE_FORMAT_RAW10:
+				if ((cam_ctx->capture_input_width <= 404)
+						&& (cam_ctx->capture_input_height <= 302)) {
+					/* CIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if ((cam_ctx->capture_input_width <= 808)
+						&& (cam_ctx->capture_input_height <= 604)) {
+					/* SVGA */
+					sensor_timeperframe_numerator = 2;
+					sensor_timeperframe_denominator = 15;
+				} else if ((cam_ctx->capture_input_width <= 1616)
+						&& (cam_ctx->capture_input_height <= 1208)) {
+					/* UXGA */
+					sensor_timeperframe_numerator = 2;
+					sensor_timeperframe_denominator = 5;
+				}
+				break;
+			default:
+				break;
+		}
+
+	} else if (CAMERA_TYPE_OMNIVISION_2630 == cam_ctx->sensor_type) {
+		switch (cam_ctx->capture_input_format) {
+			case CAMERA_IMAGE_FORMAT_RAW10:
+				if ((cam_ctx->capture_input_width <= 400)
+						&& (cam_ctx->capture_input_height <= 292)) {
+					/* CIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if ((cam_ctx->capture_input_width <= 800)
+						&& (cam_ctx->capture_input_height <= 600)) {
+					/* SVGA */
+					sensor_timeperframe_numerator = 2;
+					sensor_timeperframe_denominator = 15;
+				} else if ((cam_ctx->capture_input_width <= 1600)
+						&& (cam_ctx->capture_input_height <= 1200)) {
+					/* UXGA */
+					sensor_timeperframe_numerator = 2;
+					sensor_timeperframe_denominator = 5;
+				}
+				break;
+			default:
+				break;
+		}
+
+	} else {
+
+		switch (cam_ctx->capture_input_format) {
+			case CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR:
+			case CAMERA_IMAGE_FORMAT_YCBCR422_PACKED:
+				if (cam_ctx->capture_input_width <= 88
+						&& cam_ctx->capture_input_height <= 72) {
+					/* QQCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 176
+						&& cam_ctx->capture_input_height <= 144) {
+					/* QCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 352
+						&& cam_ctx->capture_input_height <= 288) {
+					/* CIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 160
+						&& cam_ctx->capture_input_height <= 120) {
+					/* QQVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 320
+						&& cam_ctx->capture_input_height <= 240) {
+					/* QVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 640
+						&& cam_ctx->capture_input_height <= 480) {
+					/* VGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				}
+				break;
+			case CAMERA_IMAGE_FORMAT_RGB565:
+				if (cam_ctx->capture_input_width <= 88
+						&& cam_ctx->capture_input_height <= 72) {
+					/* QQCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 176
+						&& cam_ctx->capture_input_height <= 144) {
+					/* QCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 352
+						&& cam_ctx->capture_input_height <= 288) {
+					/* CIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 160
+						&& cam_ctx->capture_input_height <= 120) {
+					/* QQVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 320
+						&& cam_ctx->capture_input_height <= 240) {
+					/* QVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 640
+						&& cam_ctx->capture_input_height <= 480) {
+					/* VGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				}
+				break;
+			case CAMERA_IMAGE_FORMAT_RAW8:
+				if (cam_ctx->capture_input_width <= 88
+						&& cam_ctx->capture_input_height <= 72) {
+					/* QQCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 176
+						&& cam_ctx->capture_input_height <= 144) {
+					/* QCIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 352
+						&& cam_ctx->capture_input_height <= 288) {
+					/* CIF */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 160
+						&& cam_ctx->capture_input_height <= 120) {
+					/* QQVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 320
+						&& cam_ctx->capture_input_height <= 240) {
+					/* QVGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				} else if (cam_ctx->capture_input_width <= 640
+						&& cam_ctx->capture_input_height <= 480) {
+					/* VGA */
+					sensor_timeperframe_numerator = 1;
+					sensor_timeperframe_denominator = 15;
+				}
+				break;
+			default:
+				break;
+		}
+
+	}
+
+	framerate =
+		((*(p_camdrv_status->p_timeperframe_numerator)) *
+		 sensor_timeperframe_denominator) /
+		((*(p_camdrv_status->p_timeperframe_denominator)) *
+		 sensor_timeperframe_numerator);
+
+	if (framerate == 0) {
+		framerate = 0;
+	} else if (framerate > 8) {
+		framerate = 7;
+	} else {
+		framerate--;
+	}
+
+	return framerate;
+
+}
+
+static int pxa_camera_reset(struct pxa_camera_driver_status_t *p_camdrv_status)
+{
+
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	if (*(p_camdrv_status->p_capture_started)) {
+		pxa_camera_ioctl_streamoff(p_camdrv_status);
+	}
+
+	if (*(p_camdrv_status->p_buf_submited)) {
+		camera_desubmit_buffers(cam_ctx);
+	}
+
+	if (*(p_camdrv_status->p_buf_ready)) {
+		camera_deprepare_buffers(cam_ctx);
+	}
+
+	return 0;
+}
+
+static int pxa_camera_ioctl_streamon(struct pxa_camera_driver_status_t
+		*p_camdrv_status)
+{
+
+	struct buf_node *buf_node;
+	p_camera_context_t cam_ctx = g_camera_context;
+	unsigned long flags;
+
+	if (!*(g_camdrv_status.p_buf_ready)) {
+		if (CAMERA_MODE_STILL == cam_ctx->capture_mode) {
+			if (camera_prepare_buffers(cam_ctx, 2) < 0) {
+				return -EIO;
+			}
+		} else {
+			if (camera_prepare_buffers(cam_ctx, 3) < 0) {
+				return -EIO;
+			}
+		}
+	}
+
+	if (!*(g_camdrv_status.p_buf_submited)) {
+		if (camera_submit_buffers(cam_ctx)) {
+			return -EIO;
+		}
+	}
+
+	spin_lock_irqsave(&report_list_lock, flags);
+	/* Empty report head and put its buf into head queue */
+	while (!list_empty(p_camdrv_status->p_report_head)) {
+		buf_node =
+			list_entry(g_camdrv_status.p_report_head->next,
+					struct buf_node, report_head);
+		list_del_init(&buf_node->report_head);
+		if (camera_submit_buffer(cam_ctx, buf_node->buf_index)) {
+			spin_unlock_irqrestore(&report_list_lock, flags);
+			return -EIO;
+		}
+	}
+	spin_unlock_irqrestore(&report_list_lock, flags);
+
+	if (!*(g_camdrv_status.p_capture_started)) {
+		if (camera_start_capture(cam_ctx)) {
+			return -EIO;
+		}
+	}
+
+	*(g_camdrv_status.p_capture_started) = 1;
+	return 0;
+}
+
+static void pxa_camera_ioctl_streamoff(struct pxa_camera_driver_status_t
+		*p_camdrv_status)
+{
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	camera_stop_capture(cam_ctx);
+	*(g_camdrv_status.p_capture_started) = 0;
+}
+
+static int pxa_camera_open(struct inode *inode, struct file *file)
+{
+	int status = -1;
+	dma_addr_t handle = 0;
+
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	if (g_camdrv_status.suspended) {
+		return status;
+	}
+	g_camdrv_status.driver_opened = 1;
+
+	g_camdrv_status.still_buf_ready = 0;
+	g_camdrv_status.video_buf_ready = 0;
+	g_camdrv_status.still_buf_submited = 0;
+	g_camdrv_status.video_buf_submited = 0;
+	g_camdrv_status.still_capture_started = 0;
+	g_camdrv_status.video_capture_started = 0;
+
+	g_camdrv_status.still_timeperframe_numerator = 0;
+	g_camdrv_status.video_timeperframe_numerator = 0;
+	g_camdrv_status.still_timeperframe_denominator = 0;
+	g_camdrv_status.video_timeperframe_denominator = 0;
+
+	INIT_LIST_HEAD(&(g_camdrv_status.still_buf_head));
+	INIT_LIST_HEAD(&(g_camdrv_status.video_buf_head));
+	INIT_LIST_HEAD(&(g_camdrv_status.still_report_head));
+	INIT_LIST_HEAD(&(g_camdrv_status.video_report_head));
+
+	init_waitqueue_head(&(g_camdrv_status.camera_wait_q));
+	g_camdrv_status.task_waiting = 0;
+
+	/* set default value */
+	cam_ctx->capture_mode = CAMERA_MODE_VIDEO;
+	pxa_camera_set_mode(&g_camdrv_status, cam_ctx->capture_mode);
+
+	INIT_LIST_HEAD(&pc_head.page_list);
+	pc_head.page_count = 0;
+	spin_lock_init(&pc_head.lock);
+	init_MUTEX(&buf_list_sem);
+	spin_lock_init(&report_list_lock);
+	spin_lock_init(&cam_queue_lock);
+
+	cam_ctx->video_capture_width = WIDTH_DEFT;
+	cam_ctx->video_capture_height = HEIGHT_DEFT;
+	cam_ctx->video_capture_scale = CAMERA_CAPTURE_SCALE_DISABLE;
+	cam_ctx->video_capture_input_format =
+		CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR;
+	cam_ctx->video_capture_output_format =
+		CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR;
+
+	cam_ctx->still_capture_width = WIDTH_DEFT;
+	cam_ctx->still_capture_height = HEIGHT_DEFT;
+	cam_ctx->still_capture_scale = CAMERA_CAPTURE_SCALE_DISABLE;
+	cam_ctx->still_capture_input_format =
+		CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR;
+	cam_ctx->still_capture_output_format =
+		CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR;
+
+	cam_ctx->frame_rate = FRAMERATE_DEFT;
+	cam_ctx->ci_reg_base = (unsigned int)(&(CICR0));
+
+	SET_DEFAULT_SENSOR(cam_ctx);
+
+	/*
+	 * we alloc histogram/LUT buffer and its dma descriptor here
+	 */
+	cam_ctx->histogram_lut_buffer_virtual = dma_alloc_coherent(NULL,
+			1024, &handle, GFP_KERNEL);
+
+	if (!cam_ctx->histogram_lut_buffer_virtual) {
+		pr_debug("Can't get memory for histogram buffer\n");
+		goto alloc_histogram_buffer_error;
+	} else
+		cam_ctx->histogram_lut_buffer_physical = handle;
+
+	cam_ctx->histogram_lut_dma_descriptors_virtual =
+		dma_alloc_coherent(NULL, 16, &handle, GFP_KERNEL);
+
+	if (!cam_ctx->histogram_lut_dma_descriptors_virtual) {
+		pr_debug("Can't get memory for phantom buffer\n");
+		goto alloc_histogram_dma_desc_error;
+	} else
+		cam_ctx->histogram_lut_dma_descriptors_physical = handle;
+
+	/*
+	 * We alloc phantom buffer here. The buffer node (list) will be
+	 * alloc when application start capturing.
+	 */
+	cam_ctx->phantom_buffer_virtual = dma_alloc_coherent(NULL,
+			PHANTOM_BUFFER_SIZE,
+			&handle,
+			GFP_KERNEL);
+	if (!cam_ctx->phantom_buffer_virtual) {
+		pr_debug("Can't get memory for phantom buffer\n");
+		goto alloc_phantom_buffer_error;
+	} else {
+		cam_ctx->phantom_buffer_physical = handle;
+	}
+
+	status = camera_init(cam_ctx);
+	if (status) {
+		goto camera_init_error;
+	}
+
+	/* set interrupt mask */
+	mcam_set_interrupt_mask(cam_ctx, INT_MASK);
+
+	/* empty the report list */
+	while (!list_empty(g_camdrv_status.p_report_head)) {
+		list_del_init(g_camdrv_status.p_report_head->next);
+	}
+
+	/* empty the head list */
+	while (!list_empty(g_camdrv_status.p_buf_head)) {
+		list_del_init(g_camdrv_status.p_buf_head->next);
+	}
+
+	return status;
+
+camera_init_error:
+	dma_free_coherent(NULL, PHANTOM_BUFFER_SIZE,
+			(void *)cam_ctx->phantom_buffer_virtual,
+			cam_ctx->phantom_buffer_physical);
+
+alloc_phantom_buffer_error:
+
+	dma_free_coherent(NULL, 16,
+			(void *)cam_ctx->
+			histogram_lut_dma_descriptors_virtual,
+			cam_ctx->histogram_lut_dma_descriptors_physical);
+
+alloc_histogram_dma_desc_error:
+
+	dma_free_coherent(NULL, 1024,
+			(void *)cam_ctx->histogram_lut_buffer_virtual,
+			cam_ctx->histogram_lut_buffer_physical);
+
+alloc_histogram_buffer_error:
+	return status;
+}
+
+static int pxa_camera_close(struct inode *inode, struct file *file)
+{
+	p_camera_context_t cam_ctx = g_camera_context;
+	struct page *page;
+	unsigned long flags;
+
+	g_camdrv_status.driver_opened = 0;
+
+	if (*(g_camdrv_status.p_capture_started)) {
+		pxa_camera_ioctl_streamoff(&g_camdrv_status);
+	}
+
+	camera_deinit(cam_ctx);
+
+	if (cam_ctx->phantom_buffer_virtual) {
+		dma_free_coherent(NULL, PHANTOM_BUFFER_SIZE,
+				(void *)cam_ctx->phantom_buffer_virtual,
+				cam_ctx->phantom_buffer_physical);
+	}
+	if (cam_ctx->histogram_lut_dma_descriptors_virtual) {
+		dma_free_coherent(NULL, 16,
+				(void *)cam_ctx->
+				histogram_lut_dma_descriptors_virtual,
+				cam_ctx->
+				histogram_lut_dma_descriptors_physical);
+	}
+
+	if (cam_ctx->histogram_lut_buffer_virtual) {
+		dma_free_coherent(NULL, 1024,
+				(void *)cam_ctx->histogram_lut_buffer_virtual,
+				cam_ctx->histogram_lut_buffer_physical);
+	}
+
+	/* empty the report list */
+	while (!list_empty(&(g_camdrv_status.still_report_head))) {
+		list_del_init(g_camdrv_status.still_report_head.next);
+	}
+	while (!list_empty(&(g_camdrv_status.video_report_head))) {
+		list_del_init(g_camdrv_status.video_report_head.next);
+	}
+
+	camera_free_buffer_list(CAMERA_MODE_STILL, 1);
+	camera_free_buffer_list(CAMERA_MODE_VIDEO, 1);
+
+	/* Free all the camera page cache */
+	while (!list_empty(&pc_head.page_list)) {
+		spin_lock_irqsave(&pc_head.lock, flags);
+		page = list_entry(pc_head.page_list.next, struct page, lru);
+		list_del(&page->lru);
+		spin_unlock_irqrestore(&pc_head.lock, flags);
+
+		set_page_count(page, 1);
+		ClearPageReserved(page);
+		__free_page(page);
+	}
+	pc_head.page_count = 0;
+
+	return 0;
+}
+
+static ssize_t pxa_camera_read(struct file *file, char __user * buf,
+		size_t count, loff_t * ppos)
+{
+	p_camera_context_t cam_ctx = g_camera_context;
+	ssize_t ret = 0;
+	struct buf_node *buf_node;
+	char __user *tmp_buf = buf;
+	unsigned long flags;
+
+	if (!*(g_camdrv_status.p_capture_started)) {
+		if (pxa_camera_ioctl_streamon(&g_camdrv_status)) {
+			return -EIO;
+		}
+	}
+
+	spin_lock_irqsave(&report_list_lock, flags);
+	if (list_empty(g_camdrv_status.p_report_head)) {
+		int ret;
+		g_camdrv_status.task_waiting = 1;
+		spin_unlock_irqrestore(&report_list_lock, flags);
+		ret = wait_event_interruptible(g_camdrv_status.camera_wait_q,
+				!list_empty(g_camdrv_status.
+					p_report_head));
+		if (ret)
+			return ret;
+	} else {
+		spin_unlock_irqrestore(&report_list_lock, flags);
+	}
+
+	spin_lock_irqsave(&report_list_lock, flags);
+	buf_node =
+		list_entry(g_camdrv_status.p_report_head->next, struct buf_node,
+				report_head);
+	if (!buf_node) {
+		ret = -EINVAL;
+		spin_unlock_irqrestore(&report_list_lock, flags);
+		goto out;
+	}
+
+	list_del(&buf_node->report_head);
+	spin_unlock_irqrestore(&report_list_lock, flags);
+
+	if (copy_to_user(tmp_buf, buf_node->Y_vaddr, buf_node->fifo0_size)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	tmp_buf += buf_node->fifo0_size;
+
+	if (buf_node->fifo1_size) {
+		if (copy_to_user
+				(tmp_buf, buf_node->Cb_vaddr, buf_node->fifo1_size)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		tmp_buf += buf_node->fifo1_size;
+	}
+
+	if (buf_node->fifo2_size) {
+		if (copy_to_user
+				(tmp_buf, buf_node->Cr_vaddr, buf_node->fifo2_size)) {
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+
+	ret =
+		buf_node->fifo0_size + buf_node->fifo1_size + buf_node->fifo2_size;
+
+out:
+	camera_submit_buffer(cam_ctx, buf_node->buf_index);
+
+	return ret;
+}
+
+static int pxa_camera_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long iterators = (unsigned long)vma->vm_start;
+	unsigned long size = 0;
+	int i, ret = 0;
+	struct buf_node *buf_node;
+	unsigned int offset;
+	unsigned int buf_index;
+
+	offset = vma->vm_pgoff << PAGE_SHIFT;
+	buf_index = offset / camera_get_buffer_size();
+
+	down_interruptible(&buf_list_sem);
+	buf_node = camera_get_buffer_from_index(buf_index);
+	for (i = 0; i < buf_node->page_num; i++) {
+		if (remap_pfn_range(vma,
+				iterators,
+				(__pa(page_address(buf_node->pages[i]))) >>
+				PAGE_SHIFT, PAGE_SIZE,
+				pgprot_noncached(PAGE_SHARED)
+#ifdef	CACHEABLE_BUFFER
+				| L_PTE_CACHEABLE | L_PTE_BUFFERABLE
+#endif
+				)) {
+			ret = -EFAULT;
+			goto remap_page_error;
+		}
+		size += PAGE_SIZE;
+		iterators += PAGE_SIZE;
+	}
+	up(&buf_list_sem);
+
+	return ret;
+
+remap_page_error:
+	do_munmap(vma->vm_mm, vma->vm_start, size);
+	return ret;
+}
+
+static unsigned int pxa_camera_poll(struct file *file, poll_table * wait)
+{
+	unsigned long flags;
+
+	if (!*(g_camdrv_status.p_capture_started)) {
+		if (pxa_camera_ioctl_streamon(&g_camdrv_status)) {
+			return -EIO;
+		}
+	}
+
+	spin_lock_irqsave(&report_list_lock, flags);
+	if (!list_empty(g_camdrv_status.p_report_head)) {
+		spin_unlock_irqrestore(&report_list_lock, flags);
+		return POLLIN | POLLRDNORM;
+	}
+	spin_unlock_irqrestore(&report_list_lock, flags);
+
+	g_camdrv_status.task_waiting = 1;
+	poll_wait(file, &(g_camdrv_status.camera_wait_q), wait);
+
+	spin_lock_irqsave(&report_list_lock, flags);
+	if (!list_empty(g_camdrv_status.p_report_head)) {
+		spin_unlock_irqrestore(&report_list_lock, flags);
+		return POLLIN | POLLRDNORM;
+	} else {
+		spin_unlock_irqrestore(&report_list_lock, flags);
+		return 0;
+	}
+}
+
+static int pxa_camera_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long param)
+{
+	return video_usercopy(inode, file, cmd, param, camera_do_ioctl);
+}
+
+static void pxa_camera_release(struct video_device *dev)
+{
+}
+
+#ifdef CONFIG_PM
+/*
+ * Suspend the Camera Module.
+ */
+static int pxa_camera_suspend(struct device *dev, u32 state, u32 level)
+{
+	p_camera_context_t cam_ctx = g_camera_context;
+
+	g_camdrv_status.suspended = 1;
+
+	if (!(g_camdrv_status.driver_opened)) {
+		if (g_camdrv_status.i2c_inited) {
+			g_camdrv_status.i2c_inited = 0;
+		}
+		return 0;
+	}
+
+	mcam_suspend(cam_ctx);
+	disable_irq(IRQ_CAMERA);
+	if (g_camdrv_status.i2c_inited) {
+		g_camdrv_status.i2c_inited = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Resume the Camera Module.
+ */
+static int pxa_camera_resume(struct device *dev, u32 level)
+{
+	p_camera_context_t cam_ctx = g_camera_context;
+	struct buf_node *buf_node;
+	unsigned long flags;
+	struct pxa_camera_driver_status_t *p_camdrv_status;
+
+	int buf_type;
+
+	g_camdrv_status.suspended = 0;
+
+	if (!(g_camdrv_status.driver_opened)) {
+		if (!g_camdrv_status.i2c_inited) {
+			g_camdrv_status.i2c_inited = 1;
+		}
+		return 0;
+	}
+
+	p_camdrv_status = &(g_camdrv_status);
+
+	buf_type = (cam_ctx->capture_mode == CAMERA_MODE_STILL) ?
+		STILL_CAPTURE_BUFFER : VIDEO_CAPTURE_BUFFER;
+	switch (level) {
+		case RESUME_POWER_ON:
+			/* init to output 3.2v temporarily.
+			 * should be done by system
+			 */
+			mhn_pmic_set_voltage(VCC_CAMERA_ANA, 3200);
+
+			/* enable QCI clock  */
+			pxa_set_cken(CKEN_CAMERA, 1);
+
+			spin_lock_irqsave(&report_list_lock, flags);
+			/* Empty report head and put its buf into head queue */
+			while (!list_empty(p_camdrv_status->p_report_head)) {
+				buf_node =
+					list_entry(g_camdrv_status.p_report_head->next,
+							struct buf_node, report_head);
+				list_del_init(&buf_node->report_head);
+				if (camera_submit_buffer(cam_ctx, buf_node->buf_index)) {
+					spin_unlock_irqrestore(&report_list_lock,
+							flags);
+					return -EIO;
+				}
+			}
+			spin_unlock_irqrestore(&report_list_lock, flags);
+
+			mcam_resume(cam_ctx);
+
+			mcam_set_interrupt_mask(cam_ctx, INT_MASK);
+			enable_irq(IRQ_CAMERA);
+
+			if (cam_ctx->dma_running) {
+				spin_lock_irqsave(&report_list_lock, flags);
+				if (list_empty(g_camdrv_status.p_report_head)) {
+					g_camdrv_status.task_waiting = 1;
+					spin_unlock_irqrestore(&report_list_lock,
+							flags);
+					wait_event_interruptible(g_camdrv_status.
+							camera_wait_q,
+							!list_empty
+							(g_camdrv_status.
+							 p_report_head));
+				} else {
+					spin_unlock_irqrestore(&report_list_lock,
+							flags);
+				}
+			}
+
+		default:
+			break;
+	}
+	return 0;
+}
+
+#endif
+
+static int __devinit pxa_camera_probe(struct device *dev)
+{
+
+	g_camdrv_status.i2c_inited = 1;
+	g_camdrv_status.suspended = 0;
+
+	/* allocte camera context */
+	g_camera_context = kzalloc(sizeof(camera_context_t), GFP_KERNEL);
+	if (!g_camera_context) {
+		pr_debug("Can't allocate buffer for" "camera control structure \n");
+		return -ENOMEM;
+	}
+
+	/* allocte camera functions context */
+	g_camera_context->camera_functions = kzalloc(sizeof(camera_function_t),
+			GFP_KERNEL);
+	if (!g_camera_context->camera_functions) {
+		pr_debug("Can't allocate buffer for"
+				"camera functions structure \n");
+		goto malloc_camera_functions_err;
+		return -ENOMEM;
+	}
+
+	if (video_register_device(&vd, VFL_TYPE_GRABBER, pxa_camera_minor) < 0) {
+		goto register_video_error;
+	}
+
+	pr_info("PXA_CAMERA: PXA Camera driver loaded for /dev/video%d\n",
+			pxa_camera_minor);
+
+	g_camdrv_status.driver_opened = 0;
+	/* request irq */
+	if (request_irq(IRQ_CAMERA, pxa_camera_irq, 0, "PXA Camera", &vd)) {
+		pr_debug("PXA_CAMERA: Camera interrupt register failed \n");
+		goto register_video_error;
+	}
+	disable_irq(IRQ_CAMERA);
+
+
+	return 0;
+
+register_video_error:
+	if (g_camera_context->camera_functions) {
+		kfree(g_camera_context->camera_functions);
+	}
+
+malloc_camera_functions_err:
+	if (g_camera_context) {
+		kfree(g_camera_context);
+	}
+	return -EIO;
+}
+
+static int __devexit pxa_camera_remove(struct device *dev)
+{
+
+	g_camdrv_status.i2c_inited = 0;
+
+	free_irq(IRQ_CAMERA, &vd);
+	video_unregister_device(&vd);
+	kfree(g_camera_context->camera_functions);
+	kfree(g_camera_context);
+	return 0;
+}
+
+static struct device_driver pxa_camera_driver = {
+	.name 		= "pxa2xx-camera",
+	.bus 		= &platform_bus_type,
+	.probe 		= pxa_camera_probe,
+	.remove 	= __devexit_p(pxa_camera_remove),
+#ifdef CONFIG_PM
+	.suspend 	= pxa_camera_suspend,
+	.resume 	= pxa_camera_resume,
+#endif
+};
+
+static int __devinit pxa_camera_init(void)
+{
+	return driver_register(&pxa_camera_driver);
+}
+
+static void __exit pxa_camera_exit(void)
+{
+	return driver_unregister(&pxa_camera_driver);
+}
+
+module_init(pxa_camera_init);
+module_exit(pxa_camera_exit);
+
+MODULE_DESCRIPTION("Zylonite/Monahans Camera Interface driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/include/linux/pxa_camera_zl.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/pxa_camera_zl.h
@@ -0,0 +1,148 @@
+/*
+    pxa_camera - PXA camera driver header file
+
+    Copyright (C) 2003, Intel Corporation
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __LINUX_PXA_CAMERA_H_
+#define __LINUX_PXA_CAMERA_H_
+
+#include <asm/ioctl.h>
+#include <linux/videodev2.h>
+
+
+
+
+/*
+ * histogram feature
+ */
+
+typedef enum {
+    HST_COLOR_RED,
+    HST_COLOR_BLUE,
+    HST_COLOR_GREEN1,
+    HST_COLOR_GREEN2
+} hst_color_type;
+
+
+
+struct hst_context_s{
+	hst_color_type color;
+	unsigned short *hst;
+	unsigned int sum;
+	unsigned int size;
+};
+
+#define WCAM_VIDIOCGHST       _IOWR('v', 217, struct hst_context_s)
+
+
+
+
+/*
+ * private pxa-camera register I/O control
+ */
+struct reg_set_s {
+    int  val1;
+    int  val2;
+};
+
+#define WCAM_VIDIOCSCAMREG       _IOW('v', 211, struct reg_set_s)
+#define WCAM_VIDIOCGCAMREG       _IOWR('v', 212, struct reg_set_s)
+#define WCAM_VIDIOCSCIREG        _IOW('v', 213, struct reg_set_s)
+#define WCAM_VIDIOCGCIREG        _IOWR('v', 214, struct reg_set_s)
+#define WCAM_VIDIOCSINFOR        _IOW('v', 215, struct reg_set_s)
+#define WCAM_VIDIOCGINFOR        _IOWR('v', 216, struct reg_set_s)
+
+/*
+ *Image format definition
+ */
+#define CAMERA_IMAGE_FORMAT_RAW8                0
+#define CAMERA_IMAGE_FORMAT_RAW9                1
+#define CAMERA_IMAGE_FORMAT_RAW10               2
+
+#define CAMERA_IMAGE_FORMAT_RGB444              3
+#define CAMERA_IMAGE_FORMAT_RGB555              4
+#define CAMERA_IMAGE_FORMAT_RGB565              5
+#define CAMERA_IMAGE_FORMAT_RGB666_PACKED       6
+#define CAMERA_IMAGE_FORMAT_RGB666_PLANAR       7
+#define CAMERA_IMAGE_FORMAT_RGB888_PACKED       8
+#define CAMERA_IMAGE_FORMAT_RGB888_PLANAR       9
+#define CAMERA_IMAGE_FORMAT_RGBT555_0          10  //RGB+Transparent bit 0
+#define CAMERA_IMAGE_FORMAT_RGBT888_0          11
+#define CAMERA_IMAGE_FORMAT_RGBT555_1          12  //RGB+Transparent bit 1
+#define CAMERA_IMAGE_FORMAT_RGBT888_1          13
+
+#define CAMERA_IMAGE_FORMAT_YCBCR400           14
+#define CAMERA_IMAGE_FORMAT_YCBCR422_PACKED    15
+#define CAMERA_IMAGE_FORMAT_YCBCR422_PLANAR    16
+#define CAMERA_IMAGE_FORMAT_YCBCR444_PACKED    17
+#define CAMERA_IMAGE_FORMAT_YCBCR444_PLANAR    18
+
+/*
+ * Bpp definition
+ */
+
+#define YUV422_BPP                16
+#define RGB565_BPP                16
+#define RGB666_UNPACKED_BPP       32
+#define RGB666_PACKED_BPP         24
+
+/*
+ *VIDIOCCAPTURE Arguments
+ */
+#define STILL_IMAGE                2
+#define VIDEO_START                1
+#define VIDEO_STOP                 0
+
+/*
+ *VIDIOCSWIN Arguments
+ */
+#define CAPTURE_TYPE_STILL         8
+
+/*
+ * VIDIOC_S_INPUT/VIDIOC_G_INPUT arguments
+ */
+#define OV7660_SENSOR 0
+#define OV2620_SENSOR 1
+#define OV2630_SENSOR 2
+#define OV5623_SENSOR 3
+
+
+/*
+ * SSU scaling parameter
+ */
+typedef enum {
+    CI_SSU_SCALE_DISABLE   = 0,    // disabled
+    CI_SSU_SCALE_HALF      = 1,    // 2:1
+    CI_SSU_SCALE_QUARTER   = 2     // 4:1
+} CI_SSU_SCALE;
+
+
+
+/*
+ * extended pixel format for V4l1
+ */
+#define VIDEO_PALETTE_RGGB8        17
+#define VIDEO_PALETTE_RGGB10       18
+
+/*
+ * extended pixel format for V4l2
+ */
+#define V4L2_PIX_FMT_SRGGB8  v4l2_fourcc('R','A','8','1') /*  8  RGRG.. GBGB.. */
+#define V4L2_PIX_FMT_SRGGB10 v4l2_fourcc('R','A','A','1') /*  10  RGRG.. GBGB.. */
+
+#endif /* __LINUX_PXA_CAMERA_H_ */
Index: linux-2.6.10/arch/arm/mach-pxa/zylonite.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-pxa/zylonite.c
+++ linux-2.6.10/arch/arm/mach-pxa/zylonite.c
@@ -647,39 +647,41 @@ void zylonite_enable_i2c_pins(void)
 	mhn_mfp_set_configs(zylonite_i2c_pins, ARRAY_SIZE(zylonite_i2c_pins));
 }
 
-static struct mhn_pin_config zylonite_cif_pins[] = {
+#ifdef CONFIG_PXA_CAMERA_ZL
+
+struct mhn_pin_config zylonite_cif_pins[] = {
 	MHN_MFP_CFG("CIF DD<0>",  MFP_CIF_DD_0,         MFP_CIF_DD_0_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<1>",  MFP_CIF_DD_1,         MFP_CIF_DD_1_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<2>",  MFP_CIF_DD_2,         MFP_CIF_DD_2_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<3>",  MFP_CIF_DD_3,         MFP_CIF_DD_3_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<4>",  MFP_CIF_DD_4,         MFP_CIF_DD_4_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<5>",  MFP_CIF_DD_5,         MFP_CIF_DD_5_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<6>",  MFP_CIF_DD_6,         MFP_CIF_DD_6_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<7>",  MFP_CIF_DD_7,         MFP_CIF_DD_7_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<8>",  MFP_CIF_DD_8,         MFP_CIF_DD_8_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF DD<9>",  MFP_CIF_DD_9,         MFP_CIF_DD_9_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
-	MHN_MFP_CFG("CIF MCLK",   MFP_CIF_MCLK,         MFP_CIF_MCLK_AF,
 			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF PCLK",   MFP_CIF_PCLK,         MFP_CIF_PCLK_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF HSYNC",  MFP_CIF_HSYNC,        MFP_CIF_HSYNC_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF VSYNC",  MFP_CIF_VSYNC,        MFP_CIF_VSYNC_AF,
-			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF HIPWDN", MFP_CIF_HI_PWDN_GPI0, MFP_CIF_HI_PWDN_GPI0_AF,
-			MFP_DS04X, 0, MFP_LPM_PULL_HIGH, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
 	MHN_MFP_CFG("CIF LOPWDN", MFP_CIF_LO_PWDN_GPI0, MFP_CIF_LO_PWDN_GPI0_AF,
-			MFP_DS04X, 0, MFP_LPM_PULL_HIGH, MFP_EDGE_NONE),
+			MFP_DS04X, 0, MFP_LPM_FLOAT, MFP_EDGE_NONE),
+	MHN_MFP_CFG("CIF MCLK",   MFP_CIF_MCLK,         MFP_CIF_MCLK_AF,
+			MFP_DS04X, 0, MFP_LPM_PULL_LOW, MFP_EDGE_NONE),
 };
 
 void zylonite_enable_cif_pins(void)
@@ -687,6 +689,7 @@ void zylonite_enable_cif_pins(void)
 	mhn_mfp_set_configs(zylonite_cif_pins, ARRAY_SIZE(zylonite_cif_pins));
 }
 
+#endif /* CONFIG_PXA_CAMERA_ZL */
 
 static struct mhn_pin_config zylonite_keyp_pins[] = {
 	MHN_MFP_CFG("KEYP DKIN0",  MFP_KP_DKIN_0,  MFP_KP_DKIN_0_AF,
@@ -1121,7 +1124,9 @@ EXPORT_SYMBOL_GPL(zylonite_enable_dfc_pi
 #ifdef CONFIG_FB_PXA
 EXPORT_SYMBOL_GPL(zylonite_enable_lcd_pins);
 #endif
+#ifdef CONFIG_PXA_CAMERA_ZL
 EXPORT_SYMBOL_GPL(zylonite_enable_cif_pins);
+#endif
 EXPORT_SYMBOL_GPL(zylonite_enable_keyp_pins);
 EXPORT_SYMBOL_GPL(zylonite_enable_ac97_pins);
 EXPORT_SYMBOL_GPL(zylonite_enable_mmc1_pins);
Index: linux-2.6.10/include/asm-arm/arch-pxa/pxa-regs.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-pxa/pxa-regs.h
+++ linux-2.6.10/include/asm-arm/arch-pxa/pxa-regs.h
@@ -3308,14 +3308,14 @@
 #define CIDADR1		__REG_3(0x50000250)	/* DMA Descriptor Address Channel 1 register */
 #define CIDADR2		__REG_3(0x50000260)	/* DMA Descriptor Address Channel 2 register */
 #define CIDADR3		__REG_3(0x50000270)	/* DMA Descriptor Address Channel 3 register */
-#define CITADR0		__REG_3(0x50000244)	/* DMA Target Address Channel 0 register */
-#define CITADR1		__REG_3(0x50000254)	/* DMA Target Address Channel 1 register */
-#define CITADR2		__REG_3(0x50000264)	/* DMA Target Address Channel 2 register */
-#define CITADR3		__REG_3(0x50000274)	/* DMA Target Address Channel 3 register */
-#define CISADR0		__REG_3(0x50000248)	/* DMA Source Address Channel 0 register */
-#define CISADR1		__REG_3(0x50000258)	/* DMA Source Address Channel 1 register */
-#define CISADR2		__REG_3(0x50000268)	/* DMA Source Address Channel 2 register */
-#define CISADR3		__REG_3(0x50000278)	/* DMA Source Address Channel 3 register */
+#define CITADR0		__REG_3(0x50000248)	/* DMA Target Address Channel 0 register */
+#define CITADR1		__REG_3(0x50000258)	/* DMA Target Address Channel 1 register */
+#define CITADR2		__REG_3(0x50000268)	/* DMA Target Address Channel 2 register */
+#define CITADR3		__REG_3(0x50000278)	/* DMA Target Address Channel 3 register */
+#define CISADR0		__REG_3(0x50000244)	/* DMA Source Address Channel 0 register */
+#define CISADR1		__REG_3(0x50000254)	/* DMA Source Address Channel 1 register */
+#define CISADR2		__REG_3(0x50000264)	/* DMA Source Address Channel 2 register */
+#define CISADR3		__REG_3(0x50000274)	/* DMA Source Address Channel 3 register */
 #define CICMD0		__REG_3(0x5000024C)	/* DMA Command Channel 0 register */
 #define CICMD1		__REG_3(0x5000025C)	/* DMA Command Channel 1 register */
 #define CICMD2		__REG_3(0x5000026C)	/* DMA Command Channel 2 register */
Index: linux-2.6.10/mvl_patches/pro-1448.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1448.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1448);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

