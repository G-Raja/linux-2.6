#! /usr/bin/env bash
# Patch: -pro_mips_cmbvr4133_candy_eth
# Date: Tue Nov 28 11:33:14 2006
# Source: MontaVista Software, Inc.
# MR: 18842
# Type: Enhancement
# Disposition: needs submitting to netdev@vger.kernel.org
# Signed-off-by: Wade Farnsworth <wfarnsworth@mvista.com>
# Description:
#     Support for the NEC "Candy" Ethernet devices on the CMB-VR4133.
# 

PATCHNUM=998
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 18842
Type: Enhancement
Disposition: needs submitting to netdev@vger.kernel.org
Signed-off-by: Wade Farnsworth <wfarnsworth@mvista.com>
Description:
    Support for the NEC "Candy" Ethernet devices on the CMB-VR4133.

Index: linux-2.6.10/arch/mips/vr41xx/nec-cmbvr4133/setup.c
===================================================================
--- linux-2.6.10.orig/arch/mips/vr41xx/nec-cmbvr4133/setup.c
+++ linux-2.6.10/arch/mips/vr41xx/nec-cmbvr4133/setup.c
@@ -55,6 +55,87 @@ static struct mtd_partition cmbvr4133_mt
 #define number_partitions (sizeof(cmbvr4133_mtd_parts)/sizeof(struct mtd_partition))
 #endif
 
+#ifdef CONFIG_NEC_CANDY
+#include <linux/nec_candy_pd.h>
+
+#define VR4133_ETHER0_START	0x0f001400
+#define VR4133_ETHER0_END	0x0f00163f
+
+#define VR4133_ETHER1_START	0x0f001700
+#define VR4133_ETHER1_END	0x0f00193f
+
+#define CMBVR4133_MAC0_FLASH	0xbdbffe00
+#define CMBVR4133_MAC1_FLASH	0xbdbffe06
+
+static struct nec_candy_platform_data nec_candy0_pdata = {
+	.pmd_addr = 0,
+};
+
+static struct platform_device nec_candy0_device = {
+	.name = "nec_candy",
+	.id = 0,
+	.dev.platform_data = &nec_candy0_pdata,
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start  = VR4133_ETHER0_START,
+			.end    = VR4133_ETHER0_END,
+			.flags  = IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start  = ETHERNET_IRQ,
+			.end    = ETHERNET_IRQ,
+			.flags  = IORESOURCE_IRQ,
+		},
+	},
+};
+
+
+static struct nec_candy_platform_data nec_candy1_pdata = {
+	.pmd_addr = 0,
+};
+
+static struct platform_device nec_candy1_device = {
+	.name = "nec_candy",
+	.id = 1,
+	.dev.platform_data = &nec_candy1_pdata,
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start  = VR4133_ETHER1_START,
+			.end    = VR4133_ETHER1_END,
+			.flags  = IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start  = ETHERNET_IRQ,
+			.end    = ETHERNET_IRQ,
+			.flags  = IORESOURCE_IRQ,
+		},
+	},
+};
+#endif
+
+static int __init nec_cmbvr4133_arch_setup(void)
+{
+#ifdef CONFIG_NEC_CANDY
+	vr41xx_supply_clock(ETHER0_CLOCK);
+	vr41xx_supply_clock(ETHER1_CLOCK);
+
+	vr41xx_enable_macint(MACINT_ALL);
+
+	memcpy(nec_candy0_pdata.mac_addr, (void *) CMBVR4133_MAC0_FLASH, 6);
+	platform_device_register(&nec_candy0_device);
+	memcpy(nec_candy1_pdata.mac_addr, (void *) CMBVR4133_MAC1_FLASH, 6);
+	platform_device_register(&nec_candy1_device);
+#endif
+	return 0;
+}
+arch_initcall(nec_cmbvr4133_arch_setup);
+
 static void __init vr4133_serial_init(void)
 {
 	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
Index: linux-2.6.10/include/linux/nec_candy_pd.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/nec_candy_pd.h
@@ -0,0 +1,22 @@
+/*
+ * include/linux/nec_candy_pd.h
+ *
+ * Platform data for the NEC Candy Ethernet device.
+ *
+ * Author: Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef NEC_CANDY_PD_H
+#define NEC_CANDY_PD_H
+
+struct nec_candy_platform_data {
+	unsigned char mac_addr[6];
+	unsigned long pmd_addr;
+};
+
+#endif
Index: linux-2.6.10/drivers/net/nec_candy.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/nec_candy.c
@@ -0,0 +1,1956 @@
+/*
+ * drivers/net/nec_candy.c
+ *
+ * NEC candy ethernet driver.
+ *
+ * Author: Jun Sun <jsun@mvista.com>
+ *
+ * 2001-2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Changes:
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added MII interface library support
+ *  - Added Linux ethtool package support (based on 8139cp.c driver)
+ *  - Added network interface message level support
+ *  - Fixed VLTP register initialisation (set to zero)
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added support for VR4133 (CCR register defines additional bits).
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added support for NEC VR7701.
+ *
+ *  MontaVista Software Inc.<asapkov@ru.mvista.com> or <source@mvista.com>
+ *  - Added support for NEC CMB-VR4133.
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Ported to 2.6 kernel.
+ *  - Added platform device support
+ *  - Added NAPI support
+ */
+
+#define DRV_NAME		"nec_candy"
+#define DRV_VERSION		"0.4"
+#define DRV_RELDATE		"June 20, 2006"
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/param.h>
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/timer.h>
+#include <linux/nec_candy_pd.h>
+
+#include <asm/addrspace.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+#include "nec_candy.h"
+
+/***********************************************************************
+ * debug
+ ***********************************************************************/
+
+#define CANDY_DEF_MSG_ENABLE	(NETIF_MSG_DRV		| \
+				 NETIF_MSG_PROBE 	| \
+				 NETIF_MSG_LINK)
+
+static int debug = -1;
+// #define	DEBUG_NEC_CANDY
+// #define	DEBUG_VERBOSE_NEC_CANDY
+// #define	SHOW_BUG		/* targeted bug reporting msgs */
+
+#ifdef DEBUG_VERBOSE_NEC_CANDY
+#define DEBUG_NEC_CANDY
+#endif
+
+#ifdef DEBUG_NEC_CANDY
+#define DEBUG(x)  do { x; } while (0)
+#else
+#define DEBUG(x)
+#endif
+
+#ifdef DEBUG_VERBOSE_NEC_CANDY
+#define DEBUG_VERBOSE(x)  do { x; } while (0)
+#else
+#define DEBUG_VERBOSE(x)
+#endif
+
+/***********************************************************************
+ * global data
+ ***********************************************************************/
+
+/* These identify the driver base version and may not be removed. */
+static char version[] __devinitdata =
+    DRV_NAME ": 10/100 Ethernet driver v" DRV_VERSION " (" DRV_RELDATE ")";
+
+static struct candy_private *candy_priv_head = NULL;
+
+/***********************************************************************
+ * helpers
+ ***********************************************************************/
+#define	candy_in(x)	readl((void __iomem *) &x)
+#define	candy_out(x, y)	writel((unsigned long)y, (void __iomem *)&x)
+
+#define	candy_set_bits(x, mask)  candy_out(x, candy_in(x) | mask)
+#define	candy_clear_bits(x, mask)  candy_out(x, candy_in(x) & ~mask)
+
+#define	candy_set_macc1_bits(x, mask) \
+		candy_out(x, (candy_in(x) | mask) & MACC1_RESERVED)
+#define	candy_clear_macc1_bits(x, mask) \
+		candy_out(x, (candy_in(x) & ~mask) & MACC1_RESERVED)
+
+#define	candy_set_macc2_bits(x, mask) \
+		candy_out(x, (candy_in(x) | mask) & MACC2_RESERVED)
+#define	candy_clear_macc2_bits(x, mask) \
+		candy_out(x, (candy_in(x) & ~mask) & MACC2_RESERVED)
+
+#ifdef CANDY_NAPI
+#define candy_unmask_napi_ints(p) \
+		candy_out((p)->msr, candy_in((p)->msr) | INT_ISR_RX_MASK)
+#define candy_mask_napi_ints(p) \
+		candy_out((p)->msr, candy_in((p)->msr) | INT_ISR_RX_MASK)
+#endif
+
+
+/***********************************************************************
+ * low-level hardware functions
+ ***********************************************************************/
+
+static void
+mdio_write(struct net_device *dev, int phy_id, int location, int val)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	/* start the write */
+
+	candy_out(p->madr,
+		  ((phy_id << FIAD_SHIFT) & FIAD_MASK) |
+		  (location & RGAD_MASK));
+	candy_out(p->mwtd, (ulong) val);
+}
+
+static int
+mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	/*  mac_reg->mcmd = 0; */
+	candy_out(p->madr,
+		  ((phy_id << FIAD_SHIFT) & FIAD_MASK) |
+		  (location & RGAD_MASK));
+	candy_out(p->mcmd, RSTAT);
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	return (ushort) candy_in(p->mrdd);
+}
+
+static void
+candy_set_media_speed(struct net_device *dev)
+{
+	struct candy_private *pp = dev->priv;
+	int lpa, advertise, media, reg;
+	ulong ccr = RMII_MODE | MII_PIN_SELECT;
+
+	lpa = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_LPA);
+	advertise = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_ADVERTISE);
+
+	if(lpa == 0 || advertise == 0) {
+		reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMCR);
+		pp->link_status.fullduplex = (reg & BMCR_FULLDPLX) ? 1 : 0;
+		if (reg & BMCR_SPEED100) {
+			candy_out(pp->regs->ccr, ccr);
+			pp->link_status.speed100 = 1;
+		} else {
+			candy_out(pp->regs->ccr, ccr | SPD100);
+			pp->link_status.speed100 = 0;
+		}
+		return;
+	}
+
+	media = mii_nway_result(lpa & advertise);
+	switch(media) {
+		case LPA_10FULL:
+		case LPA_10HALF:
+			ccr |= SPD100;
+			pp->link_status.speed100 = 0;
+			break;
+		default:
+			pp->link_status.speed100 = 1;
+	}
+
+	switch(media) {
+		case LPA_10HALF:
+		case LPA_100HALF:
+			pp->link_status.fullduplex = 0;
+			break;
+		default:
+			pp->link_status.fullduplex = 1;
+	}
+
+	candy_out(pp->regs->ccr, ccr);
+}
+
+static int
+candy_ethtool_ioctl(struct candy_private *pp, void *useraddr)
+{
+	u32 ethcmd;
+
+	/* dev_ioctl() in ../../net/core/dev.c has already checked
+	   capable(CAP_NET_ADMIN), so don't bother with that here.  */
+
+	if (get_user(ethcmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (ethcmd) {
+
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strcpy(info.driver, DRV_NAME);
+			strcpy(info.version, DRV_VERSION);
+			strcpy(info.bus_info, "");
+			info.regdump_len = CANDY_REGS_SIZE;
+			info.n_stats = 0;
+			if (copy_to_user(useraddr, &info, sizeof(info)))
+				return -EFAULT;
+			return 0;
+		}
+		/* get settings */
+	case ETHTOOL_GSET:{
+			struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+			spin_lock_irq(&pp->lock);
+			mii_ethtool_gset(&pp->mii_if, &ecmd);
+			spin_unlock_irq(&pp->lock);
+			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+				return -EFAULT;
+			return 0;
+		}
+		/* set settings */
+	case ETHTOOL_SSET:{
+			int r;
+			struct ethtool_cmd ecmd;
+			if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+				return -EFAULT;
+			spin_lock_irq(&pp->lock);
+			r = mii_ethtool_sset(&pp->mii_if, &ecmd);
+			spin_unlock_irq(&pp->lock);
+			return r;
+		}
+		/* restart autonegotiation */
+	case ETHTOOL_NWAY_RST:{
+			return mii_nway_restart(&pp->mii_if);
+		}
+		/* get link status */
+	case ETHTOOL_GLINK:{
+			struct ethtool_value edata = { ETHTOOL_GLINK };
+			edata.data = mii_link_ok(&pp->mii_if);
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+
+		/* get message-level */
+	case ETHTOOL_GMSGLVL:{
+			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+			edata.data = pp->msg_enable;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+		/* set message-level */
+	case ETHTOOL_SMSGLVL:{
+			struct ethtool_value edata;
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+			pp->msg_enable = edata.data;
+			return 0;
+		}
+
+		/* register's dump */
+	case ETHTOOL_GREGS:{
+			struct ethtool_regs regs;
+			u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
+			int rc;
+
+			if (!regbuf)
+				return -ENOMEM;
+			memset(regbuf, 0, CANDY_REGS_SIZE);
+
+			rc = copy_from_user(&regs, useraddr, sizeof(regs));
+			if (rc) {
+				rc = -EFAULT;
+				goto err_out_gregs;
+			}
+
+			if (regs.len > CANDY_REGS_SIZE)
+				regs.len = CANDY_REGS_SIZE;
+			if (regs.len < CANDY_REGS_SIZE) {
+				rc = -EINVAL;
+				goto err_out_gregs;
+			}
+
+			regs.version = CANDY_REGS_VER;
+			rc = copy_to_user(useraddr, &regs, sizeof(regs));
+			if (rc) {
+				rc = -EFAULT;
+				goto err_out_gregs;
+			}
+
+			useraddr += offsetof(struct ethtool_regs, data);
+
+			spin_lock_irq(&pp->lock);
+			memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
+			spin_unlock_irq(&pp->lock);
+
+			if (copy_to_user(useraddr, regbuf, regs.len))
+				rc = -EFAULT;
+
+		      err_out_gregs:
+			kfree(regbuf);
+			return rc;
+		}
+
+		/* get/set TX checksumming */
+	case ETHTOOL_GTXCSUM:{
+			struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+			edata.data = (pp->ndev->features &
+				      NETIF_F_IP_CSUM) != 0;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_STXCSUM:{
+			struct ethtool_value edata;
+
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+
+			if (edata.data)
+				pp->ndev->features |= NETIF_F_IP_CSUM;
+			else
+				pp->ndev->features &= ~NETIF_F_IP_CSUM;
+
+			return 0;
+		}
+
+		/* get/set scatter-gather */
+	case ETHTOOL_GSG:{
+			struct ethtool_value edata = { ETHTOOL_GSG };
+
+			edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_SSG:{
+			struct ethtool_value edata;
+
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+
+			if (edata.data)
+				pp->ndev->features |= NETIF_F_SG;
+			else
+				pp->ndev->features &= ~NETIF_F_SG;
+
+			return 0;
+		}
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int
+candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct candy_private *pp = dev->priv;
+	struct mii_ioctl_data *mii = (struct mii_ioctl_data *) &rq->ifr_data;
+	int rc;
+
+	if (cmd == SIOCETHTOOL)
+		return candy_ethtool_ioctl(pp, (void *) rq->ifr_data);
+
+	spin_lock_irq(&pp->lock);
+	rc = generic_mii_ioctl(&pp->mii_if, mii, cmd, NULL);
+	spin_unlock_irq(&pp->lock);
+	return rc;
+}
+
+static void
+set_mac_addr(struct net_device *dev, u_char * addr)
+{
+	candy_regs *p = ((struct candy_private *) dev->priv)->regs;
+
+	candy_out(p->lsa2, (addr[0] << 8 | addr[1]) & LSA2_MASK);
+	candy_out(p->lsa1,
+		  addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5]);
+}
+
+/*
+ * This is called when system boots up and/or after ether chip is reset.
+ */
+static void
+candy_hw_init(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	unsigned int temp;
+
+	/*
+	 * software reset
+	 */
+	candy_out(p->ccr, SRT);
+	candy_in(p->isr);
+
+	/*
+	 * MAC software reset
+	 */
+	candy_out(p->macc2, MCRST);
+	candy_out(p->macc2, 0x0);
+
+	/*
+	 * MII software reset
+	 */
+	candy_out(p->miic, MISRT);
+	candy_out(p->miic, 0);
+
+	/*
+	 * initialize MAC
+	 */
+	temp = TXFC | RXFC | CRCEN | PADEN;
+#ifdef WORKAROUND_E13_TXFC
+	temp &= ~TXFC;
+#endif
+#ifdef WORKAROUND_E21_PAD
+	temp &= ~PADEN;
+#endif
+	candy_out(p->macc1, temp);
+	candy_out(p->macc2, APD);
+	candy_out(p->ipgt, IPGT);
+	candy_out(p->ipgr, IPGR1 | IPGR2);
+	candy_out(p->clrt, LCOLW | RETRY);
+	candy_out(p->lmax, MAXF);
+	set_mac_addr(dev, dev->dev_addr);
+	candy_out(p->vltp, 0x0);
+	candy_out(p->miic, CLKS66);
+
+	/*
+	 * initialize DMA / FIFO
+	 */
+#ifdef WORKAROUND_E7_AFCE
+	candy_out(p->txcfg, DTBS8);
+#else
+	candy_out(p->txcfg, DTBS8 | AFCE);
+#endif
+	candy_out(p->txfc, TPTV | TX_DRTH | TX_FLTH);
+	candy_out(p->rxcfg, DRBS8);
+	candy_out(p->rxfc, UWM | LWM | RX_DRTH16W);
+	candy_out(p->rxpd, AL);
+
+	/* Set pins for RMII use */
+	candy_set_media_speed(dev);
+
+	/*
+	 * disable all interrupts until dev is opened later
+	 */
+	candy_out(p->msr, 0);
+}
+
+static void
+candy_down(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	DEBUG_VERBOSE(printk("candy_down() invoked.\n"));
+
+	candy_clear_macc1_bits(p->macc1, SRXEN);
+
+	candy_clear_bits(p->txcfg, TXE);
+	candy_clear_bits(p->rxcfg, RXE);
+}
+
+static void
+candy_up(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	DEBUG_VERBOSE(printk("candy_up() invoked.\n"));
+
+	/* soft reset rx/tx */
+	candy_set_macc2_bits(p->macc2, TFRST);
+	candy_clear_macc2_bits(p->macc2, TFRST);
+	candy_set_macc2_bits(p->macc2, RFRST);
+	candy_clear_macc2_bits(p->macc2, RFRST);
+
+#ifdef	WORKAROUND_E10_PRM_AMC
+	candy_out(p->afr, ABC);
+#else
+	candy_out(p->afr, PRM | ABC | AMC);
+#endif
+
+	/* enable transmit and receive */
+	candy_set_bits(p->txcfg, TXE);
+	candy_out(p->rxcfg, RXE | DRBS4);
+
+	/* set number of descriptors */
+	candy_out(p->rxpd, AL | (RX_RING_SIZE & RNOD_MASK));
+
+	/* set the receive descriptor pointer */
+	candy_out(p->rxdp, CPHYSADDR(&pp->rx_ring[pp->rx_head]));
+
+	candy_set_macc1_bits(p->macc1, SRXEN);
+
+	candy_set_media_speed(dev);
+
+	/* turn on interrupts */
+	candy_in(p->isr);
+	candy_out(p->msr, 0xffffffff & ISR_RESERVED);
+}
+
+static unsigned int
+hashit(char *addr)
+{
+	int i;
+	int j;
+	unsigned char nibblehigh;
+	unsigned char nibblelow;
+	unsigned long da_crc = 0L;
+	unsigned long hash_p = 0L;
+	unsigned long hash_byte = 0L;
+	unsigned long hash_bit = 0L;
+	unsigned long crc32 = 0xffffffffL;
+	unsigned long crcpoly2 = 0xedb88320L;
+
+	for (i = 0; i < 6; i++) {
+		nibblelow = addr[i] & 0x0f;
+		nibblehigh = addr[i] >> 4;
+		crc32 ^= nibblelow;
+		for (j = 0; j < 4; j++) {
+			if (crc32 & 1) {
+				crc32 = (crc32 >> 1) ^ crcpoly2;
+			} else {
+				crc32 >>= 1;
+			}
+		}
+		crc32 ^= nibblehigh;
+		for (j = 0; j < 4; j++) {
+			if (crc32 & 1) {
+				crc32 = (crc32 >> 1) ^ crcpoly2;
+			} else {
+				crc32 >>= 1;
+			}
+		}
+	}
+	da_crc = crc32 & 0x000001f8L;
+	for (j = 31; j >= 23; j--) {
+		hash_p = hash_p * 2 + da_crc % 2;
+		da_crc = da_crc / 2;
+	}
+	hash_byte = (hash_p & 0x00000038) >> 3;
+	hash_bit = (hash_p & 0x00000007);
+	return ((hash_byte << 16) | (hash_bit & 0xFFFF));
+}
+
+static void
+candy_set_filter(struct net_device *dev, int on)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct dev_mc_list *mclist = dev->mc_list;
+	unsigned long ht1 = 0;
+	unsigned long ht2 = 0;
+	int i;
+	union {
+		unsigned long fusion;
+		unsigned short byte;
+		unsigned short bit;
+	} val;
+
+	DEBUG_VERBOSE(printk
+		      ("candy_set_filter() invoked - %s\n", on ? "on" : "off"));
+
+	for (i = 0, mclist = dev->mc_list;
+	     mclist && i < dev->mc_count; i++, mclist = mclist->next) {
+		val.fusion = hashit(mclist->dmi_addr);
+		if (val.byte > 3)
+			ht1 |= (1 << ((val.byte - 4) * 8 + val.bit));
+		else
+			ht2 |= (1 << (val.byte * 8 + val.bit));
+	}
+
+	/* lock ints */
+	candy_out(p->ht1, ht1);
+	candy_out(p->ht2, ht2);
+}
+
+/*
+ * Apparently candy tx can stall due to various reasons.
+ * This routine will attempt to recover from tx stall.
+ */
+static void
+candy_error_recover(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	spin_lock(&pp->lock);
+
+	netif_stop_queue(dev);
+
+	candy_down(dev);
+	candy_hw_init(dev);
+	candy_up(dev);
+
+	netif_wake_queue(dev);
+
+	/* restart transmitting */
+	pp->tx_stop = pp->tx_tail;
+	candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+
+	spin_unlock(&pp->lock);
+}
+
+#if defined(WORKAROUND_E8_TX_STALL)
+/*
+ * This implements the workaround described for E-8
+ */
+static void
+tx_stall_recover(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* E-8 bug only happens when receiving is on */
+	if ((candy_in(p->macc1) & SRXEN) && (candy_in(p->rxcfg) & RXE)) {
+
+		candy_clear_macc1_bits(p->macc1, SRXEN);
+		candy_clear_bits(p->rxcfg, RXE);
+
+		udelay(20);
+
+		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+
+		candy_set_bits(p->rxcfg, RXE);
+		candy_set_macc1_bits(p->macc1, SRXEN);
+
+	} else {
+		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+	}
+}
+#endif
+
+/***********************************************************************
+ * hardware-independent helper routine
+ ***********************************************************************/
+static void
+candy_init_rings(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int i;
+
+	DEBUG_VERBOSE(printk("candy_init_rings() invoked.\n"));
+
+	/* tx rings */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		pp->tx_ring[i].status = 0;
+		pp->tx_ring[i].size = 0;
+		pp->tx_ring[i].pointer = 0;
+	}
+	/* this may be not necessary, if we reset every txdpr in intr */
+	pp->tx_ring[TX_RING_SIZE].status = 0;
+	pp->tx_ring[TX_RING_SIZE].size = 0x0;
+	pp->tx_ring[TX_RING_SIZE].pointer = CPHYSADDR(pp->tx_ring);
+
+	pp->tx_tail = pp->tx_stop = pp->tx_head = 0;
+	pp->tx_count = 0;
+
+	/* rx rings */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		pp->rx_ring[i].status = DB_LP;
+		pp->rx_ring[i].size = RX_BUF_SIZE;
+		pp->rx_ring[i].pointer = CPHYSADDR(pp->rx_skb[i]->data);
+	}
+	pp->rx_ring[RX_RING_SIZE].status = 0;	/* link back to the beginning */
+	pp->rx_ring[RX_RING_SIZE].size = 0xffff;
+	pp->rx_ring[RX_RING_SIZE].pointer = CPHYSADDR(pp->rx_ring);
+
+	pp->rx_head = 0;
+	pp->rx_disable = 0;
+}
+
+static void
+candy_check_intr(ulong isr)
+{
+	static const char *intr_name[32] = {
+		"carry flag",
+		"reserved",
+		"reserved",
+		"link failed",
+		"overflow",
+		"receive buffer desc request at zero",
+		"receive buffer desc request at alert level",
+		"receive done",
+
+		"reserved",
+		"reserved",
+		"control frame transmit",
+		"transmit aborted",
+		"underrun",
+		"transmit frame length exceed",
+		"transmit buffer descriptor request at NULL",
+		"transmit done",
+
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",	/* 4 */
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",
+
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",	/* 4 */
+		"reserved",
+		"reserved",
+		"reserved",
+		"IBUS error"
+	};
+	ulong i, j;
+
+	for (i = 0, j = 1; i < 32; j <<= 1, i++) {
+		if (j & isr)
+			printk("\t%s\n", intr_name[i]);
+	}
+}
+
+#ifdef CANDY_NAPI
+static void
+handle_rx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *)dev->priv;
+	struct sk_buff *newskb;
+
+	dev_kfree_skb(pp->rx_skb[pp->rx_head]);
+
+	newskb = dev_alloc_skb(RX_BUF_SIZE);    /* allocate a new skb */
+	if (newskb == NULL) {
+		printk(KERN_ERR "%s: memory squeeze.\n", dev->name);
+			return;
+	}
+	newskb->dev = dev;
+	skb_reserve(newskb, 2); /* to align IP/UDP_TCP header to 4-bytes */
+	pp->rx_skb[pp->rx_head] = newskb;
+	dp->status = DB_LP;     /* 1 stands for buffer vs link ptr */
+	dp->size = RX_BUF_SIZE;
+	dp->pointer = CPHYSADDR(newskb->data);
+	dma_cache_wback_inv(KSEG0ADDR(dp->pointer), RX_BUF_SIZE);
+
+	/* log some errors that hardware doesn't log */
+	pp->stats.rx_errors++;
+
+	if (isr & OF)
+		pp->stats.rx_fifo_errors++;
+	if (isr & RBDRU)
+		pp->stats.rx_missed_errors++;
+	if (dp->status & OVRN)
+		pp->stats.rx_over_errors++;
+}
+
+static int candy_napi_rx(struct net_device *dev, int budget)
+{
+	struct candy_private *pp = (struct candy_private *)dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+	struct sk_buff *rxskb, *newskb;
+	int pkt_len;
+	int received = 0;
+	int rnod = 0;
+
+	while (!((dp->status & OWN) == 0) && (received < budget)) {
+		if ((dp->status & RXOK) == 0) { /* handle the error case */
+			handle_rx_error(dev, dp, 0);
+			if (++pp->rx_head == RX_RING_SIZE)
+				pp->rx_head = 0;
+			dp = &pp->rx_ring[pp->rx_head];
+				received++;
+			rnod++;
+			continue;
+		}
+
+		/* oversize? */
+		if (dp->size > ETH_FRAME_SIZE) {
+			if (netif_msg_rx_status(pp))
+				printk(KERN_DEBUG "%s: rx, oversized pkt\n",
+				       dev->name);
+
+			handle_rx_error(dev, dp, 0);
+			if (++pp->rx_head == RX_RING_SIZE)
+				pp->rx_head = 0;
+			dp = &pp->rx_ring[pp->rx_head];
+			received++;
+			rnod++;
+			continue;
+		} else {
+			pkt_len = dp->size;
+		}
+
+		/*
+		 * we got a good packet, use the new skb to replace the received
+		 * one
+		 */
+		rxskb = pp->rx_skb[pp->rx_head];
+
+		newskb = dev_alloc_skb(RX_BUF_SIZE);    /* allocate a new skb */
+		if (newskb == NULL) {
+			printk(KERN_ERR "%s: memory squeeze.\n", dev->name);
+			break;
+		}
+
+		newskb->dev = dev;
+		skb_reserve(newskb, 2); /* to align IP/UDP_TCP header to
+					   4-bytes */
+		pp->rx_skb[pp->rx_head] = newskb;
+		dp->status = DB_LP;     /* 1 stands for buffer vs link ptr */
+		dp->size = RX_BUF_SIZE;
+		dp->pointer = CPHYSADDR(newskb->data);
+		dma_cache_wback_inv(KSEG0ADDR(dp->pointer), RX_BUF_SIZE);
+		rnod++;
+
+		if (++(pp->rx_head) == RX_RING_SIZE)
+			pp->rx_head = 0;
+
+		skb_put(rxskb, pkt_len);
+		rxskb->protocol = eth_type_trans(rxskb, dev);
+		rxskb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(rxskb);
+		received++;
+		dev->last_rx = jiffies;
+
+		dp = &pp->rx_ring[pp->rx_head];
+	}
+
+	if (netif_msg_rx_status(pp))
+		printk(KERN_DEBUG "%s: rx, processed %d frames.\n",
+		       dev->name, received);
+
+	candy_out(p->rxpd, AL | rnod);
+
+	if (pp->rx_disable == 1) {
+		candy_out(p->rxdp, candy_in(p->rxdp));
+		pp->rx_disable = 0;
+	}
+
+	return received;
+}
+
+static int candy_napi_poll(struct net_device *dev, int *budget)
+{
+	struct candy_private *pp = (struct candy_private *)dev->priv;
+	int not_done;
+	int orig_budget = *budget;
+	int received = 0;
+
+	spin_lock(&pp->rxlock);
+
+	not_done = 0;
+
+	if (orig_budget > dev->quota)
+		orig_budget = dev->quota;
+
+	received = candy_napi_rx(dev, orig_budget);
+
+	*budget -= received;
+	dev->quota -= received;
+
+	if (received >= orig_budget)
+		not_done = 1;
+
+	if (!not_done) {
+		netif_rx_complete(dev);
+		candy_unmask_napi_ints(pp->regs);
+	}
+
+	spin_unlock(&pp->rxlock);
+
+	return not_done;
+}
+
+#else
+static void
+reclaim_one_rx_desc(struct net_device *dev, char *buf)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+
+	if (buf != NULL) {
+		dp->pointer = CPHYSADDR(buf);
+	}
+	dp->status = DB_LP;	/* 1 stands for buffer vs link ptr */
+	dp->size = RX_BUF_SIZE;
+
+	/* we need to clean up cache here.  Otherwise we may have some
+	 * dirty cache while ether controller is feeding fresh pkt data
+	 * to the physical RAM.  Data corruption could happen.
+	 */
+	dma_cache_wback_inv(KSEG0ADDR(dp->pointer), RX_BUF_SIZE);
+
+	if (++pp->rx_head == RX_RING_SIZE)
+		pp->rx_head = 0;
+
+	/* tell hardware we have one descriptor to work with */
+	candy_out(p->rxpd, AL | 1);
+
+	/* check rx_disable */
+	if (pp->rx_disable) {
+		pp->rx_disable = 0;
+		candy_out(p->rxdp, CPHYSADDR(dp));
+		candy_set_macc1_bits(p->macc1, SRXEN);
+		DEBUG(printk(KERN_WARNING "%s : re-enable SRXEN\n", dev->name));
+	}
+}
+
+static void
+handle_rx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	if (netif_msg_rx_err(pp))
+		printk(KERN_DEBUG "%s: rx_err, rx_ring[%d] error,"
+		       "status =%04x, size=%d, isr = 0x%08lx.\n",
+		       dev->name, pp->rx_head, dp->status, dp->size, isr);
+
+	/* log some errors that hardware doesn't log */
+	pp->stats.rx_errors++;
+	if (isr & OF)
+		pp->stats.rx_fifo_errors++;
+	if (isr & RBDRU)
+		pp->stats.rx_missed_errors++;
+	if (dp->status & OVRN)
+		pp->stats.rx_over_errors++;
+}
+
+static void
+candy_rx(struct net_device *dev, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+	int pkt_len;
+	struct sk_buff *newskb;
+	struct sk_buff *rxskb;
+	int i;
+	int skb_size;
+
+	if (netif_msg_rx_status(pp)) {
+		printk(KERN_DEBUG "%s: rx, stat=0x%08lx\n",
+		       dev->name, (ulong) candy_in(p->rxst));
+		printk(KERN_DEBUG "\trx_head = %d, {0x%04x, %u, 0x%08lx}\n",
+		       pp->rx_head, dp->status, dp->size, dp->pointer);
+	}
+
+	/* check if we still have any empty receive descriptor */
+	if (isr & RBDRU) {
+		printk(KERN_ERR
+		       "%s : no more receive buffers.  Stop receiving.",
+		       dev->name);
+		candy_clear_bits(p->macc1, SRXEN);
+		pp->rx_disable = 1;
+	}
+
+	/* FIXME : we are fetching packets.  How do we know where the
+	 * end is?  When OWN bit is 0 (in previous linux driver)?
+	 *
+	 * Checking OWN bit alone is not reliable especially when kgdb
+	 * is used.  Hack to work around.  We really need to understand
+	 * what entries we can consume here.
+	 */
+	for (i = 0;; i++) {
+		dp = &pp->rx_ring[pp->rx_head];
+
+		if (((dp->status & OWN) == 0) &&
+				((pp->rx_disable == 0) || (i != 0))) {
+			/* no frame received in this descriptor yet */
+			break;
+		}
+
+		/* handle the error case */
+		if ((dp->status & RXOK) == 0) {
+			handle_rx_error(dev, dp, isr);
+			reclaim_one_rx_desc(dev, NULL);
+			continue;
+		}
+
+		/* oversize? */
+		if (dp->size > ETH_FRAME_LEN) {
+			if (netif_msg_rx_status(pp))
+				printk(KERN_DEBUG "%s: rx, oversized pkt\n",
+				       dev->name);
+			pkt_len = ETH_FRAME_LEN;
+		} else {
+			pkt_len = dp->size;
+		}
+
+		/* we got a good packet */
+
+		/* STRATEGY: ether packet has 14 bytes.  So we will
+		 * suffer from emulated unaligned access if we pass
+		 * the skb straight to upper layer.  An alternative is
+		 * to copy the buffer by offset of 2 and then pass it up.
+		 * Then the overhead is copying.
+		 *
+		 * In general, it is more beneficial to copy if we have smaller
+		 * packet.  Also, it is more beneficial to copy if we have
+		 * faster machines.
+		 *
+		 * To keep it flexible, we will leave rx_copybreak flexible.
+		 */
+
+		if (pkt_len < rx_copybreak) {
+			skb_size = pkt_len + 2;
+		} else {
+			skb_size = RX_BUF_SIZE;
+		}
+
+		/* allocate a new skb */
+		newskb = dev_alloc_skb(skb_size);
+		if (newskb == NULL) {
+			printk(KERN_ERR
+			       "%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			reclaim_one_rx_desc(dev, NULL);
+			pp->stats.rx_dropped++;
+			continue;
+		}
+
+		if (pkt_len <= rx_copybreak) {
+			/* we will copy */
+			rxskb = pp->rx_skb[pp->rx_head];
+
+			newskb->dev = dev;
+			skb_reserve(newskb, 2);	/* align IP pkt to 16-byte */
+			eth_copy_and_sum(newskb, rxskb->data, pkt_len, 0);
+
+			rxskb = newskb;
+			reclaim_one_rx_desc(dev, NULL);
+		} else {
+			/* use the new skb to replace the recived one */
+			rxskb = pp->rx_skb[pp->rx_head];
+
+			newskb->dev = dev;
+			pp->rx_skb[pp->rx_head] = newskb;
+			reclaim_one_rx_desc(dev, newskb->data);
+
+		}
+
+		skb_put(rxskb, pkt_len);
+		rxskb->protocol = eth_type_trans(rxskb, dev);
+		rxskb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_rx(rxskb);
+
+		dev->last_rx = jiffies;
+
+	}
+
+	/*
+	 * when we are out here, should rxdp be the same as
+	 * &pp->rx_ring[pp->head]?
+	 */
+	if (netif_msg_rx_status(pp))
+		printk(KERN_DEBUG "%s: rx, processed %d frames.\n",
+		       dev->name, i);
+#ifdef SHOW_BUG
+	if ((candy_in(p->rxdp) != CPHYSADDR(&pp->rx_ring[pp->rx_head])) &&
+	    (candy_in(p->rxdp) != CPHYSADDR(&pp->rx_ring[RX_RING_SIZE]))) {
+		int i;
+		printk
+		    ("%s : unexpected out of rx - rx_ring[rx_head] = (%04x, %d)\n",
+		     dev->name, dp->status, dp->size);
+		for (i = 0; i < RX_RING_SIZE + 1; i++) {
+			if (p->rxdp == CPHYSADDR(&pp->rx_ring[i]))
+				break;
+		}
+		if (i == RX_RING_SIZE + 1)
+			panic("cannot find current rx tail");
+		printk("\trx_head = %d, rx_tail = %d\n", pp->rx_head, i);
+	}
+#endif
+	return;
+}
+#endif
+
+static void
+append_one_tx_desc(struct net_device *dev,
+		   ushort status,
+		   ushort size, ulong pointer, struct sk_buff *skb)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp = &pp->tx_ring[pp->tx_tail];
+#ifdef WORKAROUND_E10_VR4133
+	int i, shift = pointer % 4;
+#endif
+
+	dp->status = status;
+	dp->size = size;
+	dp->pointer = pointer;
+
+#ifdef WORKAROUND_E10_VR4133
+	if (shift && (size == 30 || size == 31)) {
+		if (skb_tailroom(skb) >= 4 - shift) {
+			shift = 4 - shift;
+			skb->data += shift;
+			dp->pointer += shift;
+			for (i = size + shift - 1; i >= 0; i--)
+				skb->data[i] = skb->data[i - shift];
+			dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		} else if (skb_headroom(skb) >=  shift) {
+			skb->data -= shift;
+			dp->pointer -= shift;
+			for (i = 0; i < size; i++)
+				skb->data[i] = skb->data[i + shift];
+			dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		} else {
+			panic("nec_candy.c: Unable to do a workaround for hardware bug (Restriction 10 for VR4133).\n");
+		}
+	}
+#endif
+	pp->tx_skb[pp->tx_tail] = skb;
+
+	pp->tx_count++;
+	if (++pp->tx_tail == TX_RING_SIZE)
+		pp->tx_tail = 0;
+}
+
+static void
+reclaim_one_tx_desc(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp = &pp->tx_ring[pp->tx_head];
+
+	dp->status = 0;
+	dp->size = 0;
+	dp->pointer = 0;
+
+	/* free skb */
+	if (pp->tx_skb[pp->tx_head]) {
+		dev_kfree_skb_irq(pp->tx_skb[pp->tx_head]);
+		pp->tx_skb[pp->tx_head] = NULL;
+	}
+
+	pp->tx_count--;
+	if (++pp->tx_head == TX_RING_SIZE)
+		pp->tx_head = 0;
+}
+
+static void
+restart_tx_hw(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	append_one_tx_desc(dev, 0, 0, 0, NULL);
+
+	/* start */
+	pp->tx_stop = pp->tx_tail;
+	candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+}
+
+static void
+handle_tx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	if (netif_msg_tx_err(pp))
+		printk(KERN_DEBUG "%s: tx err, tx_ring[%d] error, "
+		       "status = %04x, isr = 0x%08lx.\n",
+		       dev->name, pp->tx_head, dp->status, isr);
+
+#if defined(WORKAROUND_E8_TX_STALL)
+	tx_stall_recover(dev);
+#endif
+
+	pp->stats.tx_errors++;
+	pp->stats.tx_aborted_errors++;
+	if (dp->status & TUDR)
+		pp->stats.tx_fifo_errors++;
+	if (dp->status & HBF)
+		pp->stats.tx_heartbeat_errors++;
+}
+
+static void
+candy_tx_done(struct net_device *dev, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp;
+
+	if (netif_msg_tx_done(pp))
+		printk(KERN_DEBUG "%s: tx done, process %d frames from %d\n",
+		       dev->name, pp->tx_tail > pp->tx_head ?
+		       pp->tx_tail - pp->tx_head :
+		       pp->tx_tail + TX_RING_SIZE - pp->tx_head, pp->tx_head);
+
+	spin_lock(&pp->lock);	/* sync with xmit() */
+
+	while (pp->tx_head != pp->tx_stop) {
+		dp = &pp->tx_ring[pp->tx_head];
+
+		/* deal with null descriptor, the "stop" packet */
+		if (dp->status == 0) {
+			reclaim_one_tx_desc(dev);
+			continue;
+		}
+
+		/* how about checking OWN bit */
+		if (!(dp->status & OWN)) {
+			if (netif_msg_tx_done(pp))
+				printk(KERN_DEBUG "%s: tx done, "
+				       "found pkt being sent. Break the loop\n",
+				       dev->name);
+			break;
+		}
+
+		/* handle error */
+		if (!(dp->status & TOK)) {
+			handle_tx_error(dev, dp, isr);
+			/* transmitter should have stopped */
+			break;
+		}
+
+		/* reclaim the descriptor */
+		if (!pp->tx_skb[pp->tx_head]) {
+			printk(KERN_ERR "%s: tx_done but without skb!\n",
+			       dev->name);
+		}
+		reclaim_one_tx_desc(dev);
+
+		/* FIXME: The Japanese version has a tx restart under
+		 * certain error conditions.  Don't understand it.
+		 */
+	}
+
+	/* check if tx has stopped */
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+		restart_tx_hw(dev);
+	}
+
+	/* check if queue were stopped */
+	if (netif_queue_stopped(dev) && (pp->tx_count < TX_RING_SIZE - 2)) {
+		if (netif_msg_tx_done(pp))
+			printk(KERN_DEBUG "%s: tx done, queue becomes free,"
+			       "wake up net queue\n", dev->name);
+		netif_wake_queue(dev);
+	}
+
+	spin_unlock(&pp->lock);
+}
+
+static void
+candy_update_stats(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* some stats we get from hardware, while the rest we do
+	 * counting by ourselves
+	 */
+	pp->stats.rx_packets = candy_in(p->rpkt);
+	pp->stats.tx_packets = candy_in(p->tpct);
+	pp->stats.rx_bytes = candy_in(p->rbyt);
+	pp->stats.tx_bytes = candy_in(p->tbyt);
+
+	/* we count rx_errors, tx_errors, rx_dropped, tx_dropped */
+
+	pp->stats.multicast = candy_in(p->rmca);
+	pp->stats.multicast = candy_in(p->tncl);
+
+	pp->stats.rx_length_errors = candy_in(p->rund) +
+	    candy_in(p->rovr) + candy_in(p->rfrg) + candy_in(p->rjbr);
+
+	/* we count rx_over_errors */
+
+	pp->stats.rx_crc_errors = candy_in(p->rfcs);
+	pp->stats.rx_frame_errors = candy_in(p->raln);
+
+	/* we count rx_fifo_errors and rx_missed_errors */
+
+	/* we count tx_aborted_errors */
+
+	pp->stats.tx_carrier_errors = candy_in(p->tcse);
+
+	/* we count tx_fifo_errors, heartbeat_errors */
+
+	pp->stats.tx_window_errors = candy_in(p->tlcl);
+
+	/* we don't have rx_compressed and tx_compressed */
+}
+
+/***********************************************************************
+ * high-level linux-related functions
+ ***********************************************************************/
+static int candy_open(struct net_device *dev);
+static int candy_close(struct net_device *dev);
+static irqreturn_t
+candy_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_instance;
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	ulong isr;
+
+	isr = candy_in(p->isr);
+
+	if (netif_msg_intr(pp)) {
+		printk(KERN_DEBUG "%s: intr, isr = 0x%08lx\n", dev->name, isr);
+		candy_check_intr(isr);
+	}
+
+	if (isr & BUSERR) {
+		printk(KERN_ERR "%s: bus error ... resetting\n", dev->name);
+		candy_error_recover(dev);
+		return IRQ_HANDLED;
+
+	}
+#ifdef CANDY_NAPI
+	if (isr & RBDRU) {
+		pp->rx_disable = 1;
+	}
+
+	if (isr & INT_ISR_RX_MASK) {
+		if (netif_rx_schedule_prep(dev)) {
+			candy_mask_napi_ints(p);
+			__netif_rx_schedule(dev);
+		}
+	}
+#else
+	if (isr & INT_ISR_RX_MASK) {
+		candy_rx(dev, isr);
+	}
+#endif
+
+	if (isr & INT_ISR_TX_MASK) {
+		candy_tx_done(dev, isr);
+	}
+
+	/* we may need to do something with other intrs too in the future */
+
+	return IRQ_HANDLED;
+}
+
+static void
+candy_get_phy_status(struct net_device *dev, int *duplex, int *linkup,
+		     int *speed)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	u16 reg;
+
+	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMCR);
+
+	if (!(reg & BMCR_ANENABLE)) {
+		/*
+		 * Auto-negotiation is disabled so the full duplex bit in
+		 * the control register tells us if the PHY is running
+		 * half or full duplex.
+		 */
+		*duplex = (reg & BMCR_FULLDPLX) ? 1 : 0;
+		*speed = (reg & BMCR_SPEED100) ? 1: 0;
+	} else {
+		/*
+		 * Auto-negotiation is enabled.  Figure out what was
+		 * negotiated by looking for the best mode in the union
+		 * of what we and our partner advertise.
+		 */
+		u16 advertise, partner, negotiated;
+
+		advertise = mdio_read(pp->mii_if.dev,
+				      pp->mii_if.phy_id, MII_ADVERTISE);
+		partner = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_LPA);
+
+		negotiated = advertise & partner & ADVERTISE_ALL;
+		if (negotiated & ADVERTISE_100FULL) {
+			*duplex = 1;
+			*speed = 1;
+		} else if (negotiated & ADVERTISE_100HALF) {
+			*duplex = 0;
+			*speed = 1;
+		} else if (negotiated & ADVERTISE_10FULL) {
+			*duplex = 1;
+			*speed = 0;
+		} else {
+			*duplex = 0;
+			*speed = 0;
+		}
+	}
+
+	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMSR);
+
+	*linkup = (reg & BMSR_LSTATUS) != 0;
+}
+
+static void
+candy_poll_mii(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int phy_duplex, mac_duplex;
+	int phy_carrier, netif_carrier;
+	int phy_speed, mac_speed;
+
+	/* First, find out what's going on with the PHY. */
+	candy_get_phy_status(dev, &phy_duplex, &phy_carrier, &phy_speed);
+
+	/* Second, figure out the speed/duplex of the EMAC */
+	mac_duplex = pp->link_status.fullduplex;
+	mac_speed = pp->link_status.speed100;
+
+	/* Now see if there is a mismatch. */
+	if ((mac_duplex != phy_duplex || phy_speed != mac_speed)
+	    && phy_carrier) {
+		/* reset */
+		netif_stop_queue(dev);
+
+		candy_down(dev);
+		candy_hw_init(dev);
+		candy_up(dev);
+
+		netif_wake_queue(dev);
+		printk(KERN_INFO "%s: Link has been changed: now ", dev->name);
+		if (phy_duplex == 1 && phy_speed == 1) {
+			candy_out(pp->regs->ccr,
+				  candy_in(pp->regs->ccr) | SPD100);
+			candy_set_macc1_bits(pp->regs->macc1, FULLD);
+			printk("100Mbps Full Duplex\n");
+		} else if (phy_duplex == 1 && phy_speed == 0) {
+			candy_out(pp->regs->ccr,
+				  candy_in(pp->regs->ccr) & ~SPD100);
+			candy_set_macc1_bits(pp->regs->macc1, FULLD);
+			printk("10Mbps Full Duplex\n");
+		} else if (phy_duplex == 0 && phy_speed == 1) {
+			candy_out(pp->regs->ccr,
+				  candy_in(pp->regs->ccr) | SPD100);
+			candy_clear_macc1_bits(pp->regs->macc1, FULLD);
+			printk("100Mbps Half Duplex\n");
+		} else if (phy_duplex == 0 && phy_speed == 0) {
+			candy_out(pp->regs->ccr,
+				  candy_in(pp->regs->ccr) & ~SPD100);
+			candy_clear_macc1_bits(pp->regs->macc1, FULLD);
+			printk("10Mbps Half Duplex\n");
+		}
+
+		pp->link_status.fullduplex = phy_duplex;
+		pp->link_status.speed100 = phy_speed;
+		pp->mii_if.full_duplex = phy_duplex;
+	}
+	netif_carrier = netif_carrier_ok(dev) != 0;
+
+	if (phy_carrier != netif_carrier) {
+		if (phy_carrier) {
+			candy_set_media_speed(dev);
+			printk(KERN_INFO "%s: Link carrier restored.\n",
+			       dev->name);
+			netif_carrier_on(dev);
+		} else {
+			printk(KERN_INFO "%s: Link carrier lost.\n", dev->name);
+			netif_carrier_off(dev);
+		}
+	}
+
+	/* Set up the timer so we'll get called again in 2 seconds. */
+	mod_timer(&pp->phy_timer, jiffies + 2 * HZ);
+}
+
+static int
+candy_open(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int retval;
+	int count = 0;
+
+	if (netif_msg_ifup(pp))
+		printk(KERN_DEBUG "%s: enabling interface\n", dev->name);
+
+	candy_init_rings(dev);
+
+	candy_hw_init(dev);
+	candy_up(dev);
+
+	dev->flags |= IFF_RUNNING;
+
+	/* request IRQ */
+	retval = request_irq(dev->irq, &candy_interrupt, SA_SHIRQ,
+			     dev->name, dev);
+	if (retval) {
+		printk(KERN_ERR "%s: unable to get IRQ %d\n",
+		       dev->name, dev->irq);
+		return retval;
+	}
+
+	netif_carrier_off(dev);
+	mii_check_media(&pp->mii_if, netif_msg_link(pp), 1);
+
+	if (pp->mii_if.full_duplex)
+		candy_set_macc1_bits(pp->regs->macc1, FULLD);
+	else
+		candy_clear_macc1_bits(pp->regs->macc1, FULLD);
+
+	candy_set_media_speed(dev);
+
+	init_timer(&pp->phy_timer);
+
+	pp->phy_timer.data = (unsigned long) dev;
+	pp->phy_timer.function = &candy_poll_mii;
+	candy_poll_mii((unsigned long) dev);
+
+	while (!netif_carrier_ok(dev) && ++count < 5) {
+		udelay(10);
+	}
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int
+candy_close(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	if (netif_msg_ifdown(pp))
+		printk(KERN_DEBUG "%s: disabling interface\n", dev->name);
+
+	del_timer_sync(&pp->phy_timer);
+
+	dev->flags &= ~(IFF_UP | IFF_RUNNING);
+
+	if (netif_device_present(dev)) {
+		netif_stop_queue(dev);
+		netif_carrier_off(dev);
+		candy_down(dev);
+
+		/* free tx skb */
+		while (pp->tx_tail != pp->tx_head) {
+			if (pp->tx_skb[pp->tx_head]) {
+				dev_kfree_skb_irq(pp->tx_skb[pp->tx_head]);
+				pp->tx_skb[pp->tx_head] = NULL;
+			}
+
+			pp->tx_count--;
+			if (++pp->tx_head == TX_RING_SIZE)
+				pp->tx_head = 0;
+		}
+	}
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+static int
+candy_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	ulong flags;
+
+	if (netif_msg_tx_queued(pp))
+		printk(KERN_DEBUG "%s: tx queued, skblen %d\n",
+		       dev->name, skb->len);
+
+	/* check packet size */
+	if (skb->len > ETH_FRAME_SIZE) {
+		printk(KERN_ERR "%s: packet size too big, %d\n", dev->name,
+		       skb->len);
+		pp->stats.tx_dropped++;
+		return 1;
+	}
+
+	spin_lock_irqsave(&pp->lock, flags);
+
+	/* check to see if tx_ring is full */
+	if (pp->tx_count >= TX_RING_SIZE - 1) {
+		printk(KERN_ERR "%s: TX ring full, packet dropped.\n",
+		       dev->name);
+		pp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&pp->lock, flags);
+		/* why the queue was not stopped before we get here? */
+		netif_stop_queue(dev);
+		return 1;
+	}
+
+	/* add the descriptor */
+	{
+		ushort temp = skb->len;
+#ifdef WORKAROUND_E21_PAD
+		if (temp < 60)
+			temp = 60;
+#endif
+		dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		append_one_tx_desc(dev, LAST | DB_LP, temp,
+				   CPHYSADDR(skb->data), skb);
+	}
+
+	/* logistics */
+	dev->trans_start = jiffies;
+
+	/* do we need to start sending or just append */
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+		restart_tx_hw(dev);
+	}
+
+	if (pp->tx_count >= TX_RING_SIZE - 2) {
+		netif_stop_queue(dev);
+	}
+
+	spin_unlock_irqrestore(&pp->lock, flags);
+
+	return 0;
+}
+
+static struct net_device_stats *
+candy_get_stats(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	unsigned long flags;
+
+	if (netif_device_present(dev)) {
+		spin_lock_irqsave(&pp->lock, flags);
+		candy_update_stats(dev);
+		spin_unlock_irqrestore(&pp->lock, flags);
+	}
+	return &pp->stats;
+}
+
+static void
+candy_set_rx_mode(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	ulong val;
+
+	DEBUG_VERBOSE(printk("candy_set_rx_mode() invoked.\n"));
+
+	/* TODO: need to acquire spinlock and stop receiving */
+
+	val = candy_in(p->afr);
+	val &= ~PRO;
+	if (dev->flags & IFF_PROMISC) {
+		val |= PRO;
+	} else if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 64)) {
+		/* disable promiscuous mode, use normal mode */
+		candy_set_filter(dev, 0);
+	} else if (dev->mc_count) {
+		/* walk the address list, and load the filter */
+		candy_set_filter(dev, 1);
+	}
+#ifdef	WORKAROUND_E10_PRM_AMC
+	candy_out(p->afr, val & ABC);
+#else
+	candy_out(p->afr, val);
+#endif
+}
+
+static void
+candy_tx_timeout(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	printk(KERN_ERR "%s : tx_timeout.\n", dev->name);
+
+	pp->stats.tx_errors++;
+
+	candy_error_recover(dev);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void candy_napi_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	candy_interrupt(dev->irq, dev, NULL);
+	enable_irq(dev->irq);
+}
+#endif
+
+static int nec_candy_probe(struct device *dev)
+{
+	int i, ret;
+	struct resource *res;
+	struct net_device *ndev;
+	candy_regs *p;
+	struct candy_private *pp;
+	struct nec_candy_platform_data *pdata = dev->platform_data;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	printk(KERN_INFO "%s\n", version);
+
+	/*
+	 * hardware is already initialized.  We just need do some Linux
+	 * related initialization.
+	 */
+
+	/* create net_device structure */
+	ndev = alloc_etherdev(sizeof(struct candy_private));
+	if (!ndev) {
+		printk(KERN_ERR "ether device alloc failed. aborting\n");
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	/* init some device related data/func ptrs */
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "nec_candy_regs");
+	if (!res) {
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				"NEC_CANDY")) {
+		ret = -EBUSY;
+		goto err2;
+	}
+
+	ndev->base_addr = (unsigned long) ioremap(res->start,
+						  res->end - res->start + 1);
+	if (!ndev->base_addr) {
+		ret = -ENOMEM;
+		goto err3;
+	}
+
+	ndev->irq = platform_get_irq_byname(pdev, "nec_candy_irq");
+
+	for (i = 0; i < 6; i++)
+		ndev->dev_addr[i] = pdata->mac_addr[i];
+
+	ndev->open = candy_open;
+	ndev->stop = candy_close;
+	ndev->do_ioctl = candy_ioctl;
+	ndev->hard_start_xmit = candy_xmit;
+	ndev->get_stats = candy_get_stats;
+	ndev->set_multicast_list = candy_set_rx_mode;
+	ndev->tx_timeout = candy_tx_timeout;
+	ndev->watchdog_timeo = TX_TIMEOUT;
+
+#ifdef CANDY_NAPI
+	ndev->poll = candy_napi_poll;
+	ndev->weight = 64;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	ndev->poll_controller = candy_napi_poll_controller;
+#endif
+#endif
+
+	/* init private data */
+	pp = (struct candy_private *) ndev->priv;
+	p = pp->regs = (candy_regs *) ndev->base_addr;
+	pp->dev = dev;
+
+	/* alloc tx/rx rings and rx buffers */
+
+	pp->tx_ring = kmalloc(sizeof(struct candy_desc) * (TX_RING_SIZE + 1), GFP_ATOMIC);
+	if (!pp->tx_ring) {
+		ret = -ENOMEM;
+		goto err4;
+	}
+	pp->rx_ring = kmalloc(sizeof(struct candy_desc) * (RX_RING_SIZE + 1), GFP_ATOMIC);
+	if (!pp->rx_ring) {
+		ret = -ENOMEM;
+		goto err5;
+	}
+
+	dma_cache_inv((ulong) pp->tx_ring,
+		      sizeof(struct candy_desc) * (TX_RING_SIZE + 1));
+	dma_cache_inv((ulong) pp->rx_ring,
+		      sizeof(struct candy_desc) * (RX_RING_SIZE + 1));
+
+	pp->tx_ring = (void *) KSEG1ADDR(pp->tx_ring);
+	pp->rx_ring = (void *) KSEG1ADDR(pp->rx_ring);
+
+	/* allocate rx skbs */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		pp->rx_skb[i] = dev_alloc_skb(RX_BUF_SIZE);
+		if (pp->rx_skb[i] == NULL) {
+			panic("%s: failed to alloc rx skb!", ndev->name);
+		}
+		pp->rx_skb[i]->dev = ndev;
+		dma_cache_inv((ulong) pp->rx_skb[i]->data, RX_BUF_SIZE);
+	}
+
+	/* set up links */
+	pp->ndev = ndev;
+	pp->msg_enable = (debug < 0 ? CANDY_DEF_MSG_ENABLE : debug);
+	pp->next = candy_priv_head;
+	candy_priv_head = pp;
+	pp->mii_if.dev = ndev;
+	pp->mii_if.mdio_read = mdio_read;
+	pp->mii_if.mdio_write = mdio_write;
+	pp->mii_if.phy_id = pdata->pmd_addr;
+	pp->mii_if.phy_id_mask = 0x1f;
+	pp->mii_if.reg_num_mask = 0x1f;
+
+	spin_lock_init(&pp->lock);
+	spin_lock_init(&pp->rxlock);
+
+	/*==============================================================
+	 * hardware initialization
+	 *==============================================================
+	 */
+
+	/* TODO: maybe we want to make sure the chip is there */
+
+	/*
+	 * zero out counters
+	 */
+	candy_out(p->rbyt, 0);
+	candy_out(p->rpkt, 0);
+	candy_out(p->rfcs, 0);
+	candy_out(p->rmca, 0);
+	candy_out(p->rbca, 0);
+	candy_out(p->rxcf, 0);
+	candy_out(p->rxpf, 0);
+	candy_out(p->rxuo, 0);
+	candy_out(p->raln, 0);
+	candy_out(p->rflr, 0);
+	candy_out(p->rcde, 0);
+	candy_out(p->rfcr, 0);
+	candy_out(p->rund, 0);
+	candy_out(p->rovr, 0);
+	candy_out(p->rfrg, 0);
+	candy_out(p->rjbr, 0);
+	candy_out(p->r64, 0);
+	candy_out(p->r127, 0);
+	candy_out(p->r255, 0);
+	candy_out(p->r511, 0);
+	candy_out(p->r1k, 0);
+	candy_out(p->rmax, 0);
+	candy_out(p->rvbt, 0);
+
+	candy_out(p->tbyt, 0);
+	candy_out(p->tpct, 0);
+	candy_out(p->tfcs, 0);
+	candy_out(p->tmca, 0);
+	candy_out(p->tbca, 0);
+	candy_out(p->tuca, 0);
+	candy_out(p->txpf, 0);
+	candy_out(p->tdfr, 0);
+	candy_out(p->txdf, 0);
+	candy_out(p->tscl, 0);
+	candy_out(p->tmcl, 0);
+	candy_out(p->tlcl, 0);
+	candy_out(p->txcl, 0);
+	candy_out(p->tncl, 0);
+	candy_out(p->tcse, 0);
+	candy_out(p->time, 0);
+
+	candy_hw_init(ndev);
+	ret = register_netdev(ndev);
+	if (ret != 0)
+		goto err6;
+
+	printk (KERN_INFO DRV_NAME ": Probe candy chip at "
+		"0x%08lx, irq %d, Phy ID 0x%08x, "
+		"MAC Addr %02x:%02x:%02x:%02x:%02x:%02x\n",
+		res->start, ndev->irq, pp->mii_if.phy_id,
+		ndev->dev_addr[0], ndev->dev_addr[1],
+		ndev->dev_addr[2], ndev->dev_addr[3],
+		ndev->dev_addr[4], ndev->dev_addr[5]);
+
+	return 0;
+
+err6:
+	printk(KERN_ERR "Failed to register ethernet device\n");
+	for (i = 0; i < RX_RING_SIZE; i++)
+		dev_kfree_skb(pp->rx_skb[i]);
+	kfree(pp->rx_ring);
+err5:
+	kfree(pp->tx_ring);
+err4:
+	iounmap((void *) ndev->base_addr);
+err3:
+	release_mem_region(res->start, res->end - res->start + 1);
+err2:
+	free_netdev(ndev);
+err1:
+	return ret;
+}
+
+static int nec_candy_remove(struct device *dev)
+{
+	int i;
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct candy_private *pp = netdev_priv(ndev);
+	struct resource *res =
+		platform_get_resource_byname(to_platform_device(dev),
+					     IORESOURCE_MEM,
+					     "nec_candy_regs");
+
+	for (i = 0; i < RX_RING_SIZE; i++)
+		dev_kfree_skb(pp->rx_skb[i]);
+
+	kfree(pp->rx_ring);
+	kfree(pp->tx_ring);
+
+	iounmap((void *)ndev->base_addr);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static struct device_driver nec_candy_driver = {
+	.name		= "nec_candy",
+	.bus		= &platform_bus_type,
+	.probe		= nec_candy_probe,
+	.remove		= nec_candy_remove,
+};
+
+static int __init nec_candy_module_init(void)
+{
+	return driver_register(&nec_candy_driver);
+	return 0;
+}
+
+static void __exit nec_candy_module_exit(void)
+{
+	driver_unregister(&nec_candy_driver);
+}
+
+module_init(nec_candy_module_init);
+module_exit(nec_candy_module_exit);
+
+#if defined(MODULE)
+MODULE_AUTHOR("Jun Sun, jsun@mvista.com or jsun@junsun.net");
+MODULE_DESCRIPTION("Ether driver for NEC Candy controller");
+MODULE_LICENSE("GPL");
+#endif
Index: linux-2.6.10/drivers/net/nec_candy.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/nec_candy.h
@@ -0,0 +1,614 @@
+/*
+ * drivers/net/nec_candy.h
+ *
+ * NEC Candy Ethernet driver.
+ *
+ * Author: Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * 2001-2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef NEC_CANDY_H
+#define NEC_CANDY_H
+
+/***********************************************************************
+ * Configure
+ ***********************************************************************/
+
+#define TX_RING_SIZE	32
+#define RX_RING_SIZE	512
+
+#define RX_BUF_SIZE	1536
+#define ETH_FRAME_SIZE	1536
+
+#define TX_TIMEOUT	4*HZ
+
+#ifdef CONFIG_NEC_CMBVR4133
+#define CANDY_NAPI
+#endif
+
+#ifndef CANDY_NAPI
+/* rx_copybreak:  for smaller packet we copy them to avoid emulated
+ * unaligned access overhead.
+ *
+ * Set it to 1518 to always copy ( you should do that on fast machines)
+ *
+ * Set it to 0 to avoid any copy.
+ *
+ * On Korva, some value in the middle might be appropriate.
+ */
+static int rx_copybreak = 1518;
+#endif
+
+/***********************************************************************
+ * hardware bug workarounds
+ ***********************************************************************/
+
+#define WORKAROUND_E7_AFCE
+#define WORKAROUND_E10_PRM_AMC
+#define WORKAROUND_E13_TXFC
+#define WORKAROUND_E8_TX_STALL
+
+#if defined(CONFIG_NEC_CMB_VR7701)
+#undef WORKAROUND_E7_AFCE
+#undef WORKAROUND_E10_PRM_AMC
+#undef WORKAROUND_E13_TXFC
+#undef WORKAROUND_E8_TX_STALL
+#endif
+
+#ifdef CONFIG_NEC_CMBVR4133
+#undef WORKAROUND_E7_AFCE
+#undef WORKAROUND_E10_PRM_AMC
+#undef WORKAROUND_E13_TXFC
+#define WORKAROUND_E21_PAD
+#define WORKAROUND_E10_VR4133
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* MACC1 - MAC configuration register 1 (00H R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define MACLB		0x00004000	/* MAC loopback */
+#define TXFC		0x00000800	/* Transmit flow control enable */
+#define RXFC		0x00000400	/* Receive flow control enable */
+#define SRXEN		0x00000200	/* Receive enable */
+#define PARF		0x00000100	/* Control packet pass */
+#define PUREP		0x00000080	/* Pure preamble */
+#define FLCHT		0x00000040	/* Length field check */
+#define NOBO		0x00000020	/* No Back Off */
+#define CRCEN		0x00000008	/* CRC append enable */
+#define PADEN		0x00000004	/* PAD append enable */
+#define FULLD		0x00000002	/* Full duplex enable */
+#define HUGEN		0x00000001	/* Large packet enable */
+#define MACC1_RESERVED	0x00004fef	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MACC2 - MAC configuration register 2 (04H R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define MCRST		0x00000400	/* MAC Control Block software reset */
+#define RFRST		0x00000200	/* Rx Function Block software reset */
+#define TFRST		0x00000100	/* Tx Function Block software reset */
+#define BPNB		0x00000040	/* Back Pressure No Back Off */
+#define APD		0x00000020	/* Auto VLAN PAD */
+#define VPD		0x00000010	/* VLAN PAD mode */
+#define MACC2_RESERVED	0x00000770	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* IPGT - Back-to-Back IPG register (08H R/W)                                */
+/*---------------------------------------------------------------------------*/
+#define IPGT		0x00000013	/* Back-To-Back IPG default value */
+#define IPGT_RESERVED	0x0000007f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* IPGR - Non Back-to-Back IPG register (0CH R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define IPGR1		0x00000e00	/* Back-To-Back IPG default value */
+#define IPGR2		0x00000013	/* Back-To-Back IPG default value */
+#define IPGR_RESERVED	0x00007f7f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* CLRT - Collision register (10H R/W)                                       */
+/*---------------------------------------------------------------------------*/
+#define LCOLW		0x00003800	/* Late collision window dflt value */
+#define RETRY		0x0000000f	/* Max number of retry default value */
+#define CLRT_RESERVED	0x00003f0f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LMAX - Maximum Packet Length register (14H R/W)                           */
+/*---------------------------------------------------------------------------*/
+#define MAXF		0x000005f2	/* Max pkt length value (1522 bytes) */
+#define LMAX_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RETX - Retry count register (20H R/W)                                     */
+/*---------------------------------------------------------------------------*/
+#define RETX_MASK	0x0000000f	/* Retry counter */
+#define RETX_RESERVED	0x0000000f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LSA2 - Station address register 2 (54H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define LSA2_MASK	0x0000ffff  	/* Station address SA (47:32) */
+#define LSA2_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LSA1 - Station address register 1 (58H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define LSA1_MASK	0xffffffff	/* Station address SA(31:0) */
+
+/*---------------------------------------------------------------------------*/ /* PTVR - Pause timer read register (5CH Read)                               */
+/*---------------------------------------------------------------------------*/
+#define PTCT_MASK	0x0000ffff	/* Pause timer counter */
+
+/*---------------------------------------------------------------------------*/
+/* VLTP - VLAN type register (64H R/W)                                       */
+/*---------------------------------------------------------------------------*/
+#define VLTP		0x00008100	/* VLAN type ( etpid:0x81 tci:0x00 ) */
+#define VLTP_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MIIC - MII Configuration register (80H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define MISRT		0x00008000	/* MII Mgmt Interface Block s/w reset */
+#define CLKS25		0x00000000	/* HCLK <= 25 MHz */
+#define CLKS33		0x00000004	/* HCLK <= 33 MHz */
+#define CLKS50		0x00000008	/* HCLK <= 50 MHz */
+#define CLKS66		0x0000000c	/* HCLK <= 66 MHz */
+#define MIIC_RESERVED	0x0000800c	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MCMD - MII command register (94H Write)                                   */
+/*---------------------------------------------------------------------------*/
+#define SCANC		0x00000002	/* SCAN command */
+#define RSTAT		0x00000001	/* MII management read */
+#define MCMD_RESERVED	0x00000003	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MADR - MII address register (98H R/W)                                     */
+/*---------------------------------------------------------------------------*/
+#define FIAD_MASK	0x00001f00	/* MII PHY address */
+#define FIAD_SHIFT  	8
+#define RGAD_MASK   	0x0000001f	/* MII register address */
+#define MADR_RESERVED	0x00001f1f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MIND - MII indicator register (A4H Read)                                  */
+/*---------------------------------------------------------------------------*/
+#define NVALID		0x00000004	/* SCAN command start status */
+#define SCANA		0x00000002	/* SCAN command active */
+#define BUSY		0x00000001	/* BUSY */
+#define MIND_RESERVED	0x00000007	/* reserved bit 0 */
+
+
+/*---------------------------------------------------------------------------*/
+/* STLC - STL configuration register (C0H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define ATZ		0x00000004	/* Statistics counter read reset */
+#define STLC_RESERVED	0x00000004	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* AFR - Address Filter register (C8H R/W)                                   */
+/*---------------------------------------------------------------------------*/
+#define PRO		0x00000008	/* Promiscuous mode */
+#define PRM		0x00000004	/* Accept Multicast */
+#define AMC		0x00000002	/* Accept Multicast ( qualified ) */
+#define ABC		0x00000001	/* Accept Broadcast */
+#define AFR_RESERVED	0x0000000f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* CAR1 - CARRY register1 (DCH R/W)                                          */
+/*---------------------------------------------------------------------------*/
+#define C1VT		0x00008000	/* RVBT counter carry bit */
+#define C1UT		0x00004000	/* TUCA counter carry bit */
+#define C1BT		0x00002000	/* TBCA counter carry bit */
+#define C1MT		0x00001000	/* TMCA counter carry bit */
+#define C1PT		0x00000800	/* TPCT counter carry bit */
+#define C1TB		0x00000400	/* TBYT counter carry bit */
+#define C1MX		0x00000200	/* RMAX counter carry bit */
+#define C11K		0x00000100	/* R1K counter carry bit */
+#define C1FE		0x00000080	/* R511 counter carry bit */
+#define C1TF		0x00000040	/* R255 counter carry bit */
+#define C1OT		0x00000020	/* R127 counter carry bit */
+#define C1SF		0x00000010	/* R64 counter carry bit */
+#define C1BR		0x00000008	/* RBCA counter carry bit */
+#define C1MR		0x00000004	/* RBCA counter carry bit */
+#define C1PR		0x00000002	/* RPKT counter carry bit */
+#define C1RB		0x00000001	/* RBYT counter carry bit */
+#define CAR1_RESERVED	0x0000ffff	/* reserved bit 0  */
+
+/*---------------------------------------------------------------------------*/
+/* CAR2 - CARRY register2 (E0H R/W)                                          */ /*---------------------------------------------------------------------------*/
+#define C2SV		0x80000000	/* Status vector overrun bit */
+#define C2IM		0x00400000	/* TIME counter carry bit */
+#define C2CS		0x00200000	/* TCSE counter carry bit */
+#define C2BC		0x00100000	/* TNCL counter carry bit */
+#define C2XC		0x00080000	/* TXCL counter carry bit */
+#define C2LC		0x00040000	/* TLCL counter carry bit */
+#define C2MC		0x00020000	/* TMCL counter carry bit */
+#define C2SC		0x00010000	/* TSCL counter carry bit */
+#define C2XD		0x00008000	/* TXDF counter carry bit */
+#define C2DF		0x00004000	/* TDFR counter carry bit */
+#define C2XF		0x00002000	/* TXPF counter carry bit */
+#define C2TE		0x00001000	/* TFCS counter carry bit */
+#define C2JB		0x00000800	/* RBJR counter carry bit */
+#define C2FG		0x00000400	/* RFRG counter carry bit */
+#define C2OV		0x00000200	/* ROVR counter carry bit */
+#define C2UN		0x00000100	/* RUND counter carry bit */
+#define C2FC		0x00000080	/* RFCR counter carry bit */
+#define C2CD		0x00000040	/* RCDE counter carry bit */
+#define C2FO		0x00000020	/* RFLR counter carry bit */
+#define C2AL		0x00000010	/* RALN counter carry bit */
+#define C2UO		0x00000008	/* RXUO counter carry bit */
+#define C2PF		0x00000004	/* RXPF counter carry bit */
+#define C2CF		0x00000002	/* RXCF counter carry bit */
+#define C2RE		0x00000001	/* RFCS counter carry bit */
+#define CAR2_RESERVED   0x807fffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* TXCFG - Transmit Configuration (200H R/W)                                 */
+/*---------------------------------------------------------------------------*/
+#define AFCE		0x00000001	/* Automatic Flow Control Enable */
+#define DTBS1		0x00000000	/* DMA Transmit Burst Size 1 word */
+#define DTBS2		0x00010000	/* DMA Transmit Burst Size 2 word */
+#define DTBS4		0x00020000	/* DMA Transmit Burst Size 4 word */
+#define DTBS8		0x00030000	/* DMA Transmit Burst Size 8 word */
+#define DTBS16		0x00040000	/* DMA Transmit Burst Size 16 word */
+#define DTBS32		0x00050000	/* DMA Transmit Burst Size 32 word */
+#define DTBS64		0x00060000	/* DMA Transmit Burst Size 64 word */
+#define TXE		0x80000000	/* Transmit Enable */
+#define TXCFG_RESERVED	0x80070001	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* TXFC - Transmit FIFO Control (204H R/W)                                   */
+/*---------------------------------------------------------------------------*/
+#define TPTV_MASK	0xffff0000	/* Tx Pause Timer Value mask */
+#define TPTV		0x10000000	/* default 0x1000 slot time */
+#define TX_DRTH_MASK	0x0000fc00	/* Tx Fill Threshold Level mask */
+#define TX_DRTH		0x00004000	/* default 010000b (16word, 64byte) */
+#define TX_FLTH_MASK	0x000000fc	/* Tx Drain Threshold Level mask */
+#ifdef CONFIG_NEC_CMBVR4133
+/*
+ * We set this to 160 bytes for VR4133 because of the hardware restriction:
+ * the sum of TX_FLTH and DTBS should be <= 192 bytes. DTBS is set to 32 bytes
+ * for VR4133.
+ */
+#define TX_FLTH		0x000000a0	/* 101000b (160byte) */
+#else
+#define TX_FLTH		0x000000c0	/* default 110000b (48word, 192byte) */
+#endif
+#define TXFC_RESERVED	0xfffffcfc	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* TXST - Transmit Status  (20CH R)                                          */
+/*---------------------------------------------------------------------------*/
+#define CSE_AB		0x80000000	/* carrier lost (abort) */
+#define TBP		0x40000000	/* back pressure occurred */
+#define TPP		0x20000000	/* packet requested during PAUSE */
+#define TPCF		0x10000000	/* transmit PAUSE control frame */
+#define TCFR		0x08000000	/* transmit control frame */
+#define TUDR_AB		0x04000000	/* underrun (abort) */
+#define TGNT_AB		0x02000000	/* greater than LMAX (abort) */
+#define LCOL_AB		0x01000000	/* late collision  (abort) */
+#define ECOL_AB		0x00800000	/* excessive collisions (abort) */
+#define TEDFR_AB	0x00400000	/* excessive defer (abort) */
+#define TDFR		0x00200000	/* single defer */
+#define TBRO		0x00100000	/* broadcast packet */
+#define TMUL		0x00080000	/* multicast packet */
+#define TDONE		0x00040000	/* transmit complete */
+#define TFLOR		0x00020000	/* length field  was over 1518 bytes */
+#define TFLER		0x00010000	/* length field != actual length */
+#define TCRCE		0x00008000	/* CRC error */
+#define TCBC_MASK	0x00007800	/* number of collisions */
+#define TBYT_MASK	0x000007ff	/* number of the transmitted bytes */
+
+/*---------------------------------------------------------------------------*/
+/* RXCFG - Receive Configuration (218H R/W)                                  */
+/*---------------------------------------------------------------------------*/
+#define DRBS1		0x00000000	/* DMA Receive Burst Size 1 word */
+#define DRBS2		0x00010000	/* DMA Receive Burst Size 2 word */
+#define DRBS4		0x00020000	/* DMA Receive Burst Size 4 word */
+#define DRBS8		0x00030000	/* DMA Receive Burst Size 8 word */
+#define DRBS16		0x00040000	/* DMA Receive Burst Size 16 word */
+#define DRBS32		0x00050000	/* DMA Receive Burst Size 32 word */
+#define DRBS64		0x00060000	/* DMA Receive Burst Size 64 word */
+#define RXE		0x80000000	/* Receive Enable */
+#define RXCFG_RESERVED	0x80070000	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RXFC - Receive FIFO Control (21CH R/W)                                    */
+/*---------------------------------------------------------------------------*/
+#define UWM_MASK	0xfc000000	/* Upper Water Mark mask */
+#define UWM		0xc0000000	/* default 110000b (48word, 192byte) */
+#define LWM_MASK	0x00fc0000	/* Lower Water Mark mask */
+#define LWM		0x00400000	/* default 010000b (16word, 64byte) */
+#define RX_DRTH_MASK	0x000000fc	/* Receive Drain Threshold Level */
+#define RX_DRTH16W	0x00000040	/* default 010000b (16word, 64byte) */
+#define RX_DRTH28W	0x00000070	/* default 011100b (28word, 112byte) */
+#define RXFC_RESERVED	0xfcfc00fc	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RXPD - Receive Pool Descriptor (230H R/W)                                 */
+/*---------------------------------------------------------------------------*/
+#define AL		0x70000000	/* Alert Level default value */
+#define RNOD_MASK	0x0000ffff	/* Remaining Number of Descriptor */
+
+/*---------------------------------------------------------------------------*/
+/* RXST - Receive Status (224H R)                                            */
+/*---------------------------------------------------------------------------*/
+#define RLENE		0x80000000	/* less than 64 or larger than 1518 */
+#define VLAN		0x40000000  	/* match VLTP */
+#define USOP 		0x20000000	/* unknown OP code control frame */
+#define RPCF		0x10000000	/* receive PAUSE control frame */
+#define RCFR		0x08000000	/* receive control frame */
+#define DBNB		0x04000000	/* alignment error */
+#define RBRO		0x02000000	/* broadcast packet */
+#define RMUL		0x01000000	/* multicast packet */
+#define RX_OK		0x00800000	/* receive OK */
+#define RLOR		0x00400000	/* length field was over 1518 bytes */
+#define RLER		0x00200000	/* length field != actual length */
+#define RCRCE		0x00100000	/* CRC error */
+#define RCVE		0x00080000	/* RXER was detected (PHY error) */
+#define CEPS		0x00040000	/* false Carrier */
+#define REPS		0x00020000	/* preamble+SFD or +one data nibble */
+#define PAIG		0x00010000	/* carrier length 3036 octets,
+					   Short IPG, invalid preamble
+					   or invalid SFD */
+#define RBYT_MASK	0x0000ffff	/* received byte count */
+
+/*---------------------------------------------------------------------------*/
+/* RXPD - Receive Pool Descriptor (230H R/W)                                 */
+/*---------------------------------------------------------------------------*/
+#define AL		0x70000000	/* Alert Level default value */
+#define AL_MASK		0x70000000
+#define RNOD_MASK	0x0000ffff	/* Remaining Number of Descriptor */
+#define RXPD_RESERVED	0x7000ffff	/* reserved bit */
+
+/*---------------------------------------------------------------------------*/
+/* CCR - Candy Configuration Register (234H R / 240H W)                      */
+/*---------------------------------------------------------------------------*/
+#define SRT		0x00000001	/* Candy Software Reset */
+#define MII_PIN_SELECT	0x20000000	/* MII pin selection */
+#define RMII_MODE	0x40000000	/* RMII mode */
+#define SPD100		0x80000000	/* Operation speed in RMII mode */
+
+/*---------------------------------------------------------------------------*/
+/* ISR - Interrupt Status Register (238H R with clear)                       */
+/* MSR - Mask Interrupt Register   (23cH R/W)                                */
+/*---------------------------------------------------------------------------*/
+#define BUSERR		0x80000000	/* IBUS Error */
+#define XMTDN		0x00008000	/* Transmit Done */
+#define TBDR		0x00004000	/* Transmit BD Request at Null */
+#define TFLE		0x00002000	/* Transmit Frame Length Exceed */
+#define UR		0x00001000	/* Underrun */
+#define TABR		0x00000800	/* Transmit Aborted */
+#define TCF		0x00000400	/* Transmit Control Frame */
+#define RCVDN		0x00000080	/* Receive Done */
+#define RBDRS		0x00000040	/* Receive BD Request at alert level */
+#define RBDRU		0x00000020	/* Rx Buffer Desc Request at zero */
+#define OF		0x00000010	/* Overflow */
+#define LFAL		0x00000008	/* Link Failed */
+#define CARRY		0x00000001	/* statistics counters carry flag */
+#define ISR_RESERVED	0x8000fcf9	/* reserved bit */
+
+#define INT_ISR_TX_MASK	0x0000FC00	/* ISR TX bits mask */
+#define INT_ISR_RX_MASK	0x000000F0	/* ISR RX bits mask */
+
+/*---------------------------------------------------------------------------*/
+/* Transmit/Receive Status bit definition in Transmit/Receive Descriptor     */
+/*---------------------------------------------------------------------------*/
+#define LAST		0x8000		/* Last Descriptor */
+#define DB_LP		0x4000		/* Data Buffer / Link Pointer */
+#define OWN		0x2000		/* Owner 1:used by candy, 0:host set */
+
+/*---------------------------------------------------------------------------*/
+/* Transmit Status bit definition in Transmit Descriptor                     */
+/*---------------------------------------------------------------------------*/
+#define DBRE		0x1000		/* Data Buffer Read Error */
+#define TUDR		0x0800		/* Transmit Underrun Error */
+#define CSE		0x0400		/* Carrier Sense Lost Error */
+#define LCOL		0x0200		/* Late Collision */
+#define ECOL		0x0100		/* Excessive Collision */
+#define EDFR		0x0080		/* Excessive Deferral */
+#define TGNT		0x0004		/* Transmit Giant Frame */
+#define HBF		0x0002		/* Heart Beat Fail for ENDEC mode */
+#define TOK		0x0001		/* Transmit OK */
+
+/*---------------------------------------------------------------------------*/
+/* Receive Status bit definition in Receive Descriptor                       */
+/*---------------------------------------------------------------------------*/
+#define DBWE		0x1000		/* Data Buffer Write Error */
+#define FTYP_MASK	0x0e00		/* Frame Type */
+#define BCASTF		0x0000		/* Broadcast Frame */
+#define MCASTF		0x0200		/* Multicast Frame */
+#define UCASTF		0x0400		/* Unicast Frame */
+#define VLANF		0x0600		/* VLAN Frame */
+#define PAUSEF		0x0800		/* PAUSE control Frame */
+#define CTLF		0x0a00		/* Control Frame */
+#define OVRN		0x0100		/* Overrun Error */
+#define RUNT		0x0080		/* Runt packet */
+#define FRGE		0x0040		/* Fragment Error */
+#define RCV		0x0020		/* Detects RXER */
+#define FC		0x0010		/* False Carrier */
+#define CRCE		0x0008		/* CRC Error */
+#define FAE		0x0004		/* Frame Alignment Error */
+#define RFLE		0x0002		/* Receive Frame Length Error */
+#define RXOK		0x0001		/* Receive OK */
+
+#if defined(CONFIG_NEC_CMBVR4133)
+#define CANDY_REGS_VER	2		/* version 2 */
+#else
+#define CANDY_REGS_VER	1		/* version 1 */
+#endif
+
+#define CANDY_REGS_SIZE	(0x3ff + 1)
+
+/***********************************************************************
+ * data structure
+ ***********************************************************************/
+typedef volatile struct {
+	ulong macc1;		/* 0x00  MAC configuration register 1 */
+	ulong macc2;		/* 0x04  MAC configuration register 2 */
+	ulong ipgt;		/* 0x08  Back-to-Back IPG register */
+	ulong ipgr;		/* 0x0c  Non Back-to-Back IPG register */
+	ulong clrt;		/* 0x10  Collision register */
+	ulong lmax;		/* 0x14  Max packet length register */
+	ulong reserved0[2];
+	ulong retx;		/* 0x20  Retry count register */
+	ulong reserved1[12];
+	ulong lsa2;		/* 0x54  Station Address register 2 */
+	ulong lsa1;		/* 0x58  Station Address register 1 */
+	ulong ptvr;		/* 0x5c  Pause timer value read register */
+	ulong reserved2[1];
+	ulong vltp;		/* 0x64  VLAN type register */
+	ulong reserved3[6];
+	ulong miic;		/* 0x80  MII configuration register */
+	ulong reserved4[4];
+	ulong mcmd;		/* 0x94  MII command register */
+	ulong madr;		/* 0x98  MII address register */
+	ulong mwtd;		/* 0x9c  MII write data register */
+	ulong mrdd;		/* 0xa0  MII read data register */
+	ulong mind;		/* 0xa4  MII indicator register */
+	ulong reserved5[6];
+	ulong stlc;		/* 0xc0  Statistics counter config register */
+	ulong reserved6[1];
+	ulong afr;		/* 0xc8  Address filter register */
+	ulong ht1;		/* 0xcc  Hash table register 1 */
+	ulong ht2;		/* 0xd0  Hash table register 2 */
+	ulong reserved7[2];
+	ulong car1;		/* 0xdc  Carry register 1 */
+	ulong car2;		/* 0xe0  Carry register 2 */
+	ulong reserved8[19];
+	ulong cam1;		/* 0x130 Carry mask register 1 */
+	ulong cam2;		/* 0x134 Carry mask register 2 */
+	ulong reserved9[2];
+
+	/* RX Statistics Counters */
+	ulong rbyt;		/* 0x140 Rx Byte Counter */
+	ulong rpkt;		/* 0x144 Rx Pkt Counter */
+	ulong rfcs;		/* 0x148 Rx FCS Error Counter */
+	ulong rmca;		/* 0x14c Rx Multicast Pkt Counter */
+	ulong rbca;		/* 0x150 Rx Broadcast Pkt Counter */
+	ulong rxcf;		/* 0x154 Rx Control Frame Pkt Counter */
+	ulong rxpf;		/* 0x158 Rx PAUSE Frame Pkt Counter */
+	ulong rxuo;		/* 0x15c Rx Unknown OP code Counter */
+	ulong raln;		/* 0x160 Rx Alignment Error Counter */
+	ulong rflr;		/* 0x164 Rx Frame Length Out of Range Counter */
+	ulong rcde;		/* 0x168 Rx Code Error Counter */
+	ulong rfcr;		/* 0x16c Rx False Carrier Counter */
+	ulong rund;		/* 0x170 Rx Undersize Pkt Counter */
+	ulong rovr;		/* 0x174 Rx Oversize Pkt Counter */
+	ulong rfrg;		/* 0x178 Rx Error Undersize Pkt Counter */
+	ulong rjbr;		/* 0x17c Rx Error Oversize Pkt Counter */
+	ulong r64;		/* 0x180 Rx 64 Byte Frame Counter */
+	ulong r127;		/* 0x184 Rx 65 to 127 Byte Frame Counter */
+	ulong r255;		/* 0x188 Rx 128 to 255 Byte Frame Counter */
+	ulong r511;		/* 0x18c Rx 256 to 511 Byte Frame Counter */
+	ulong r1k;		/* 0x190 Rx 512 to 1023 Byte Frame Counter */
+	ulong rmax;		/* 0x194 Rx Over 1023 Byte Frame Counter */
+	ulong rvbt;		/* 0x198 Rx Valid Byte Counter */
+	ulong reserved10[9];
+
+	/* Tx Statistics Counter */
+	ulong tbyt;		/* 0x1c0 Tx Byte Counter */
+	ulong tpct;		/* 0x1c4 Tx Pkt Counter */
+	ulong tfcs;		/* 0x1c8 Tx CRC Error Pkt Counter */
+	ulong tmca;		/* 0x1cc Tx Multicast Pkt Counter */
+	ulong tbca;		/* 0x1d0 Tx Broadcast Pkt Counter */
+	ulong tuca;		/* 0x1d4 Tx Unicast Pkt Counter */
+	ulong txpf;		/* 0x1d8 Tx PAUSE control Frame Counter */
+	ulong tdfr;		/* 0x1dc Tx Single Deferral Pkt Counter */
+	ulong txdf;		/* 0x1e0 Tx Excessive Deferral Pkt Counter */
+	ulong tscl;		/* 0x1e4 Tx Single Collision Pkt Counter */
+	ulong tmcl;		/* 0x1e8 Tx Multiple Collision Pkt Counter */
+	ulong tlcl;		/* 0x1ec Tx Late Collision Pkt Counter */
+	ulong txcl;		/* 0x1f0 Tx Excessive Collision Pkt Counter */
+	ulong tncl;		/* 0x1f4 Tx Total Collision Counter */
+	ulong tcse;		/* 0x1f8 Tx Carrier Sense Error Counter */
+	ulong time;		/* 0x1fc Tx Internal MAC Error Counter */
+
+	/*-------------------------------------------------------------------*/
+	/* Candy DMA and FIFO Management registers                           */
+	/*-------------------------------------------------------------------*/
+	ulong txcfg;		/* 0x200 Transmit Configuration */
+	ulong txfc;		/* 0x204 Transmit FIFO Control  */
+	ulong txd;		/* 0x208 Transmit Data */
+	ulong txst;		/* 0x20c Transmit Status */
+	ulong txfap;		/* 0x210 Tx FIFO access pointer */
+	ulong txdp;		/* 0x214 Transmit Descriptor Pointer */
+	ulong rxcfg;		/* 0x218 Receive Configuration */
+	ulong rxfc;		/* 0x21c Receive FIFO Control  */
+	ulong rxd;		/* 0x220 Receive Data */
+	ulong rxst;		/* 0x224 Receive Status */
+	ulong rxfap;		/* 0x228 Rx FIFO access pointer */
+	ulong rxdp;		/* 0x22c Receive Descriptor Pointer */
+	ulong rxpd;		/* 0x230 Receive Pool Descriptor */
+
+	/*-------------------------------------------------------------------*/
+	/* Candy Interrupt and Configuration registers                       */
+	/*-------------------------------------------------------------------*/
+	ulong ccr;		/* 0x234 CANDY Config Read/Write register */
+	ulong isr;		/* 0x238 Interrupt Status register */
+	ulong msr;		/* 0x23c Mask Interuupt register */
+} candy_regs;
+
+/*
+ * descriptor structure
+ */
+struct candy_desc {
+#if defined(__LITTLE_ENDIAN)
+	ushort size;
+	ushort status;
+#elif defined(__BIG_ENDIAN)
+	ushort status;
+	ushort size;
+#else
+#error "No endian format defined!"
+#endif
+	ulong pointer;
+};
+
+/*
+ * private data structure for candy driver.
+ */
+struct candy_private {
+	struct candy_desc *tx_ring;
+	struct sk_buff *tx_skb[TX_RING_SIZE];
+
+	struct candy_desc *rx_ring;
+	struct sk_buff *rx_skb[RX_RING_SIZE];
+	int rx_disable;
+
+	uint rx_head;
+	uint tx_head, tx_stop, tx_tail;
+	int tx_count;
+
+	struct net_device_stats stats;
+
+	u32 msg_enable;
+
+	spinlock_t lock;
+	spinlock_t rxlock;
+
+	struct mii_if_info mii_if;
+
+	/* MII status */
+	struct link_status {
+		uint fullduplex:1;
+		uint speed100:1;
+		uint linkOK:1;
+	} link_status;
+
+	struct timer_list phy_timer;
+
+	/* hardware related */
+	candy_regs *regs;
+
+	/* house keeping */
+	struct net_device *ndev;
+	struct device *dev;
+	struct candy_private *next;
+};
+
+#endif
Index: linux-2.6.10/drivers/net/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/net/Kconfig
+++ linux-2.6.10/drivers/net/Kconfig
@@ -1269,6 +1269,13 @@ config XILINX_EMAC
 	help
 	  This driver supports 10/100 Mbit EMAC IP from Xilinx EDK
 
+config NEC_CANDY
+	tristate "NEC Candy Ethernet support"
+	depends on NEC_CMBVR4133
+	help
+	  This driver supports the NEC "Candy" Ethernet devices found
+	  on some NEC MIPS boards.
+
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
 	depends on NET_ETHERNET && (ISA || EISA || PCI)
Index: linux-2.6.10/drivers/net/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/net/Makefile
+++ linux-2.6.10/drivers/net/Makefile
@@ -195,6 +195,7 @@ obj-$(CONFIG_SMC91X) += smc91x.o
 obj-$(CONFIG_FEC_8XX) += fec_8xx/
 obj-$(CONFIG_XILINX_EMAC) += xilinx_emac/
 obj-$(CONFIG_XILINX_TEMAC) += xilinx_temac/
+obj-$(CONFIG_NEC_CANDY) += nec_candy.o
 
 obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_NET_FC) += fc/
Index: linux-2.6.10/arch/mips/vr41xx/common/icu.c
===================================================================
--- linux-2.6.10.orig/arch/mips/vr41xx/common/icu.c
+++ linux-2.6.10/arch/mips/vr41xx/common/icu.c
@@ -67,7 +67,9 @@ static unsigned char sysint2_assign[16] 
 #define MSYSINT1REG	0x0c
 #define MPIUINTREG	0x0e
 #define MAIUINTREG	0x10
+#define MACINTREG	0x10
 #define MKIUINTREG	0x12
+#define MMACINTREG	0x12
 #define MGIUINTLREG	0x14
 #define MDSIUINTREG	0x16
 #define NMIREG		0x18
@@ -211,6 +213,32 @@ void vr41xx_disable_aiuint(uint16_t mask
 
 EXPORT_SYMBOL(vr41xx_disable_aiuint);
 
+void vr41xx_enable_macint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + ETHERNET_IRQ;
+	unsigned long flags;
+	if (current_cpu_data.cputype == CPU_VR4133) {
+		spin_lock_irqsave(&desc->lock, flags);
+		icu1_set(MMACINTREG, mask);
+		spin_unlock_irqrestore(&desc->lock, flags);
+	}
+}
+
+EXPORT_SYMBOL(vr41xx_enable_macint);
+
+void vr41xx_disable_macint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + ETHERNET_IRQ;
+	unsigned long flags;
+	if (current_cpu_data.cputype == CPU_VR4133) {
+		spin_lock_irqsave(&desc->lock, flags);
+		icu1_clear(MMACINTREG, mask);
+		spin_unlock_irqrestore(&desc->lock, flags);
+	}
+}
+
+EXPORT_SYMBOL(vr41xx_disable_macint);
+
 void vr41xx_enable_kiuint(uint16_t mask)
 {
 	irq_desc_t *desc = irq_desc + KIU_IRQ;
Index: linux-2.6.10/include/asm-mips/vr41xx/vr41xx.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/vr41xx/vr41xx.h
+++ linux-2.6.10/include/asm-mips/vr41xx/vr41xx.h
@@ -151,6 +151,11 @@ extern void vr41xx_disable_piuint(uint16
 extern void vr41xx_enable_aiuint(uint16_t mask);
 extern void vr41xx_disable_aiuint(uint16_t mask);
 
+#define MACINT_ALL		0x0003
+
+extern void vr41xx_enable_macint(uint16_t mask);
+extern void vr41xx_disable_macint(uint16_t mask);
+
 #define KIUINT_DATALOST		0x0004
 #define KIUINT_DATAREADY	0x0002
 #define KIUINT_SCAN		0x0001
Index: linux-2.6.10/mvl_patches/pro-0998.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0998.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(998);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

