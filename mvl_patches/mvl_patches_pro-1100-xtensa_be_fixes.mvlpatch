#! /usr/bin/env bash
# Patch: -xtensa_be_fixes
# Date: Fri Feb 16 17:19:29 2007
# Source: MontaVista Software, Inc. | http://source.mvista.com | Manish Lachwani <mlachwani@mvista.com>
# MR: 17389
# Type: Defect Fix & Enhancement 
# Disposition: needs submitting to community by Tensilica
# Signed-off-by: Chris Zankel (czankel@tensilica.com) & Manish Lachwani (mlachwani@mvista.com)
# Description:
# 
# The patch handles the following:
# 
# 1. Bug fixes to get the userland (GLIBC) to work
# 2. MMU optimizations
# 3. FPGA core config file changes
# 
#  arch/xtensa/Kconfig                        |   11 
#  arch/xtensa/Makefile                       |    3 
#  arch/xtensa/boot/boot-elf/bootstrap.S      |    3 
#  arch/xtensa/boot/boot-redboot/bootstrap.S  |   76 +++---
#  arch/xtensa/kernel/align.S                 |   40 +--
#  arch/xtensa/kernel/coprocessor.S           |    2 
#  arch/xtensa/kernel/entry.S                 |   42 ++-
#  arch/xtensa/kernel/head.S                  |   80 ++++--
#  arch/xtensa/kernel/pci-dma.c               |   40 ++-
#  arch/xtensa/kernel/process.c               |   45 ++-
#  arch/xtensa/kernel/ptrace.c                |    2 
#  arch/xtensa/kernel/setup.c                 |   18 -
#  arch/xtensa/kernel/signal.c                |    4 
#  arch/xtensa/kernel/syscalls.c              |   11 
#  arch/xtensa/kernel/vectors.S               |    5 
#  arch/xtensa/kernel/vmlinux.lds.S           |   26 --
#  arch/xtensa/lib/checksum.S                 |    5 
#  arch/xtensa/lib/memcopy.S                  |    2 
#  arch/xtensa/lib/memset.S                   |    2 
#  arch/xtensa/lib/strncpy_user.S             |    2 
#  arch/xtensa/lib/strnlen_user.S             |    2 
#  arch/xtensa/lib/usercopy.S                 |    2 
#  arch/xtensa/mm/fault.c                     |    2 
#  arch/xtensa/mm/init.c                      |   27 +-
#  arch/xtensa/mm/misc.S                      |  198 +++++++++++-----
#  arch/xtensa/mm/tlb.c                       |   26 +-
#  include/asm-xtensa/asmmacro.h              |   66 +++--
#  include/asm-xtensa/cache.h                 |    6 
#  include/asm-xtensa/coprocessor.h           |   12 
#  include/asm-xtensa/cpu-linux_be/config.h   |  352 +++++++++++++++++++++++++++++
#  include/asm-xtensa/dma.h                   |    2 
#  include/asm-xtensa/elf.h                   |   11 
#  include/asm-xtensa/io.h                    |   65 ++---
#  include/asm-xtensa/mmu_context.h           |  100 ++------
#  include/asm-xtensa/page.h                  |    7 
#  include/asm-xtensa/pgtable.h               |   74 +++---
#  include/asm-xtensa/platform-iss/hardware.h |    4 
#  include/asm-xtensa/posix_types.h           |    2 
#  include/asm-xtensa/processor.h             |   20 -
#  include/asm-xtensa/ptrace.h                |    2 
#  include/asm-xtensa/resource.h              |    2 
#  include/asm-xtensa/sigcontext.h            |    2 
#  include/asm-xtensa/stat.h                  |   36 +-
#  include/asm-xtensa/syscalls.h              |    3 
#  include/asm-xtensa/timex.h                 |   19 -
#  include/asm-xtensa/tlbflush.h              |   32 +-
#  include/asm-xtensa/unistd.h                |    4 
#  47 files changed, 1037 insertions(+), 460 deletions(-)
# 

PATCHNUM=1100
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. | http://source.mvista.com | Manish Lachwani <mlachwani@mvista.com>
MR: 17389
Type: Defect Fix & Enhancement 
Disposition: needs submitting to community by Tensilica
Signed-off-by: Chris Zankel (czankel@tensilica.com) & Manish Lachwani (mlachwani@mvista.com)
Description:

The patch handles the following:

1. Bug fixes to get the userland (GLIBC) to work
2. MMU optimizations
3. FPGA core config file changes

 arch/xtensa/Kconfig                        |   11 
 arch/xtensa/Makefile                       |    3 
 arch/xtensa/boot/boot-elf/bootstrap.S      |    3 
 arch/xtensa/boot/boot-redboot/bootstrap.S  |   76 +++---
 arch/xtensa/kernel/align.S                 |   40 +--
 arch/xtensa/kernel/coprocessor.S           |    2 
 arch/xtensa/kernel/entry.S                 |   42 ++-
 arch/xtensa/kernel/head.S                  |   80 ++++--
 arch/xtensa/kernel/pci-dma.c               |   40 ++-
 arch/xtensa/kernel/process.c               |   45 ++-
 arch/xtensa/kernel/ptrace.c                |    2 
 arch/xtensa/kernel/setup.c                 |   18 -
 arch/xtensa/kernel/signal.c                |    4 
 arch/xtensa/kernel/syscalls.c              |   11 
 arch/xtensa/kernel/vectors.S               |    5 
 arch/xtensa/kernel/vmlinux.lds.S           |   26 --
 arch/xtensa/lib/checksum.S                 |    5 
 arch/xtensa/lib/memcopy.S                  |    2 
 arch/xtensa/lib/memset.S                   |    2 
 arch/xtensa/lib/strncpy_user.S             |    2 
 arch/xtensa/lib/strnlen_user.S             |    2 
 arch/xtensa/lib/usercopy.S                 |    2 
 arch/xtensa/mm/fault.c                     |    2 
 arch/xtensa/mm/init.c                      |   27 +-
 arch/xtensa/mm/misc.S                      |  198 +++++++++++-----
 arch/xtensa/mm/tlb.c                       |   26 +-
 include/asm-xtensa/asmmacro.h              |   66 +++--
 include/asm-xtensa/cache.h                 |    6 
 include/asm-xtensa/coprocessor.h           |   12 
 include/asm-xtensa/cpu-linux_be/config.h   |  352 +++++++++++++++++++++++++++++
 include/asm-xtensa/dma.h                   |    2 
 include/asm-xtensa/elf.h                   |   11 
 include/asm-xtensa/io.h                    |   65 ++---
 include/asm-xtensa/mmu_context.h           |  100 ++------
 include/asm-xtensa/page.h                  |    7 
 include/asm-xtensa/pgtable.h               |   74 +++---
 include/asm-xtensa/platform-iss/hardware.h |    4 
 include/asm-xtensa/posix_types.h           |    2 
 include/asm-xtensa/processor.h             |   20 -
 include/asm-xtensa/ptrace.h                |    2 
 include/asm-xtensa/resource.h              |    2 
 include/asm-xtensa/sigcontext.h            |    2 
 include/asm-xtensa/stat.h                  |   36 +-
 include/asm-xtensa/syscalls.h              |    3 
 include/asm-xtensa/timex.h                 |   19 -
 include/asm-xtensa/tlbflush.h              |   32 +-
 include/asm-xtensa/unistd.h                |    4 
 mvl_patches/pro-1100.c                     |   16 +
 48 files changed, 1053 insertions(+), 460 deletions(-)

Index: linux-2.6.10/include/asm-xtensa/asmmacro.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/asmmacro.h
+++ linux-2.6.10/include/asm-xtensa/asmmacro.h
@@ -11,7 +11,7 @@
 #ifndef _XTENSA_ASMMACRO_H
 #define _XTENSA_ASMMACRO_H
 
-#include <asm/config/core.h>
+#include <asm/cpu/config.h>
 
 /* Iterate from 'from' to 'to' for command 'cmd'. */
   
@@ -29,22 +29,25 @@
  *
  * __loopi ar, as, size, inc
  *         ar	register initialized with the start address
- *	   as	available
+ *	   as	scratch register used by macro
  *	   size	size immediate value
  *	   inc	increment
  *
- * __loops ar, as, at, inc_log2
+ * __loops ar, as, at, inc_log2[, mask_log2][, cond][, ncond]
  *	   ar	register initialized with the start address
- *	   as	available
+ *	   as	scratch register use by macro
  *	   at	register initialized with the size
- *	   inc_log2	increment in log2
+ *	   inc_log2	increment [in log2]
+ *	   mask_log2	mask [in log2]
+ *	   cond		true condition (used in loop'cond')
+ *	   ncond	false condition (used in b'ncond')
  *
  * __loop  as
  *	   restart loop. 'as' register must not have been modified!
  *
  * __endla ar, as, incr
  *	   ar	start address (modified)
- *	   as	used by loop macro
+ *	   as	scratch register used by macro
  *	   inc	increment
  */
 
@@ -52,27 +55,47 @@
 
 	.macro	__loopi ar, as, size, incr
 #if XCHAL_HAVE_LOOPS
-		movi	\as, (\size + \incr - 1) / (\incr)
+		movi	\as, ((\size + \incr - 1) / (\incr))
 		loop	\as, 99f
 #else
 		addi	\as, \ar, \size
-		99:
+		98:
 #endif		
 	.endm
 
 	/* loop for given size in register */
 
-	.macro	__loops	ar, as, at, incr_log2
+	.macro	__loops	ar, as, at, incr_log2, mask_log2, cond, ncond
 #if XCHAL_HAVE_LOOPS
 		.ifgt \incr_log2 - 1
 			addi	\as, \at, (1 << \incr_log2) - 1
-			srli	\as, \as, \incr_log2
+			.ifnc \mask_log2,
+				extui	\as, \as, \incr_log2, \mask_log2
+			.else
+				srli	\as, \as, \incr_log2
+			.endif
 		.endif
-		loop	\as, 99f
+		loop\cond	\as, 99f
 #else
-		add	\as, \ar, \at
-		99:
+		.ifnc \mask_log2,
+			extui	\as, \at, \incr_log2, \mask_log2
+		.else
+			.ifnc \ncond,
+				srli	\as, \at, \incr_log2
+			.endif
+		.endif
+		.ifnc \ncond, 
+			b\ncond	\as, 99f
+
+		.endif
+		.ifnc \mask_log2,
+			slli	\as, \as, \incr_log2
+			add	\as, \ar, \as
+		.else
+			add	\as, \ar, \at
+		.endif
 #endif
+		98:
 	.endm
 
 	/* loop from ar to at */
@@ -86,7 +109,7 @@
 		.endif
 		loop	\as, 99f
 #else
-		99:
+		98:
 #endif
 	.endm
 
@@ -94,23 +117,24 @@
 #if XCHAL_HAVE_LOOPS
 		loop	\as, 99f
 #else
-		99:
+		98:
 #endif
 	.endm
 
 	/* end of loop; no add! */
 
-	.macro	__endl	ar, as, incr
-#if XCHAL_HAVE_LOOPS
-		99:
-#else
-		bltu	\ar, \as, 99b
+	.macro	__endl	ar, as
+#if !XCHAL_HAVE_LOOPS
+		bltu	\ar, \as, 98b
 #endif
+		99:
 	.endm
 
 	/* end of loop and add. */
 
 	.macro	__endla	ar, as, incr
 		addi	\ar, \ar, \incr
-		__endl	\ar \as \incr
+		__endl	\ar \as
 	.endm
+
+#endif /* _XTENSA_ASMMACRO_H */
Index: linux-2.6.10/include/asm-xtensa/cache.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/cache.h
+++ linux-2.6.10/include/asm-xtensa/cache.h
@@ -25,7 +25,9 @@
 # endif
 #endif
 
-#define L1_CACHE_SHIFT		XCHAL_CACHE_LINEWIDTH_MAX
-#define L1_CACHE_BYTES		XCHAL_CACHE_LINESIZE_MAX
+#define __MAX(x,y) ((x) > (y) ? (x) : (y))
+
+#define L1_CACHE_SHIFT	__MAX(XCHAL_ICACHE_LINEWIDTH, XCHAL_DCACHE_LINEWIDTH)
+#define L1_CACHE_BYTES	__MAX(XCHAL_ICACHE_LINESIZE, XCHAL_DCACHE_LINESIZE)
 
 #endif	/* _XTENSA_CACHE_H */
Index: linux-2.6.10/include/asm-xtensa/coprocessor.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/coprocessor.h
+++ linux-2.6.10/include/asm-xtensa/coprocessor.h
@@ -11,7 +11,15 @@
 #ifndef _XTENSA_COPROCESSOR_H
 #define _XTENSA_COPROCESSOR_H
 
-#include <asm/config/tie.h>
+#include <asm/cpu/config.h>
+
+#if !XCHAL_HAVE_CP
+
+#define XTENSA_CP_EXTRA_OFFSET 	0
+#define XTENSA_CP_EXTRA_ALIGN	1	/* must be a power of 2 */
+#define XTENSA_CP_EXTRA_SIZE	0
+
+#else
 
 #define XTOFS(last_start,last_size,align) \
 	((last_start+last_size+align-1) & -align)
@@ -67,4 +75,6 @@ extern void save_coprocessor_registers(v
 # endif
 #endif
 
+#endif
+
 #endif	/* _XTENSA_COPROCESSOR_H */
Index: linux-2.6.10/include/asm-xtensa/cpu-linux_be/config.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/cpu-linux_be/config.h
@@ -0,0 +1,352 @@
+/*
+ * include/asm-xtensa/core/config.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Tensilica Inc.
+ */
+
+#ifndef _XTENSA_CORE_CONFIG_H
+#define _XTENSA_CORE_CONFIG_H
+
+
+/****************************************************************************
+	    Parameters Useful for Any Code, USER or PRIVILEGED
+ ****************************************************************************/
+
+/*
+ *  Note:  Macros of the form XCHAL_HAVE_*** have a value of 1 if the option is
+ *  configured, and a value of 0 otherwise.  These macros are always defined.
+ */
+
+
+/*----------------------------------------------------------------------
+				ISA
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_HAVE_BE			1	/* big-endian byte ordering */
+#define XCHAL_HAVE_WINDOWED		1	/* windowed registers option */
+#define XCHAL_NUM_AREGS			64	/* num of physical addr regs */
+#define XCHAL_NUM_AREGS_LOG2		6	/* log2(XCHAL_NUM_AREGS) */
+#define XCHAL_MAX_INSTRUCTION_SIZE	3	/* max instr bytes (3..8) */
+#define XCHAL_HAVE_DEBUG		1	/* debug option */
+#define XCHAL_HAVE_DENSITY		1	/* 16-bit instructions */
+#define XCHAL_HAVE_LOOPS		1	/* zero-overhead loops */
+#define XCHAL_HAVE_NSA			0	/* NSA/NSAU instructions */
+#define XCHAL_HAVE_MINMAX		0	/* MIN/MAX instructions */
+#define XCHAL_HAVE_SEXT			0	/* SEXT instruction */
+#define XCHAL_HAVE_CLAMPS		0	/* CLAMPS instruction */
+#define XCHAL_HAVE_MUL16		0	/* MUL16S/MUL16U instructions */
+#define XCHAL_HAVE_MUL32		0	/* MULL instruction */
+#define XCHAL_HAVE_MUL32_HIGH		0	/* MULUH/MULSH instructions */
+#define XCHAL_HAVE_L32R			1	/* L32R instruction */
+#define XCHAL_HAVE_ABSOLUTE_LITERALS	0	/* non-PC-rel (extended) L32R */
+#define XCHAL_HAVE_CONST16		0	/* CONST16 instruction */
+#define XCHAL_HAVE_ADDX			1	/* ADDX#/SUBX# instructions */
+#define XCHAL_HAVE_WIDE_BRANCHES	0	/* B*.W18 or B*.W15 instr's */
+#define XCHAL_HAVE_PREDICTED_BRANCHES	0	/* B[EQ/EQZ/NE/NEZ]T instr's */
+#define XCHAL_HAVE_CALL4AND12		1	/* CALL[X][4/12] instructions */
+#define XCHAL_HAVE_ABS			1	/* ABS instruction */
+/*#define XCHAL_HAVE_POPC		0*/	/* CRC instruction */
+/*#define XCHAL_HAVE_CRC		0*/	/* POPC instruction */
+#define XCHAL_HAVE_RELEASE_SYNC		0	/* L32AI/S32RI instructions */
+#define XCHAL_HAVE_S32C1I		0	/* S32C1I instruction */
+#define XCHAL_HAVE_SPECULATION		0	/* speculation */
+#define XCHAL_NUM_CONTEXTS		1	/* */
+#define XCHAL_NUM_MISC_REGS		2	/* num of scratch regs (0..4) */
+#define XCHAL_HAVE_TAP_MASTER		0	/* JTAG TAP control instr's */
+#define XCHAL_HAVE_PRID			0	/* processor ID register */
+#define XCHAL_HAVE_THREADPTR		0	/* THREADPTR register */
+#define XCHAL_HAVE_BOOLEANS		0	/* boolean registers */
+#define XCHAL_HAVE_CP			0	/* CPENABLE reg (coprocessor) */
+#define XCHAL_CP_MAXCFG			0	/* max allowed cp id plus one */
+#define XCHAL_HAVE_MAC16		0	/* MAC16 package */
+#define XCHAL_HAVE_VECTORFPU2005	0	/* vector floating-point pkg */
+#define XCHAL_HAVE_FP			0	/* floating point pkg */
+#define XCHAL_HAVE_VECTRA1		0	/* Vectra I  pkg */
+#define XCHAL_HAVE_VECTRALX		0	/* Vectra LX pkg */
+
+
+/*----------------------------------------------------------------------
+				MISC
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_NUM_WRITEBUFFER_ENTRIES	4	/* size of write buffer */
+#define XCHAL_INST_FETCH_WIDTH		4	/* instr-fetch width in bytes */
+#define XCHAL_DATA_WIDTH		4	/* data width in bytes */
+/*  In T1050, applies to selected core load and store instructions (see ISA): */
+#define XCHAL_UNALIGNED_LOAD_EXCEPTION	1	/* unaligned loads cause exc. */
+#define XCHAL_UNALIGNED_STORE_EXCEPTION	1	/* unaligned stores cause exc.*/
+
+#define XCHAL_CORE_ID			"linux_be_1050b"	/* alphanum core name
+						   (CoreID) set in the Xtensa
+						   Processor Generator */
+
+#define XCHAL_BUILD_UNIQUE_ID		0x002C5B01	/* 22-bit sw build ID */
+
+/*
+ *  These definitions describe the hardware targeted by this software.
+ */
+#define XCHAL_HW_CONFIGID0		0xC103D1FF	/* ConfigID hi 32 bits*/
+#define XCHAL_HW_CONFIGID1		0x00803256	/* ConfigID lo 32 bits*/
+#define XCHAL_HW_VERSION_NAME		"T1050.3"	/* full version name */
+#define XCHAL_HW_VERSION_MAJOR		1050	/* major ver# of targeted hw */
+#define XCHAL_HW_VERSION_MINOR		3	/* minor ver# of targeted hw */
+#define XTHAL_HW_REL_T1050		1
+#define XTHAL_HW_REL_T1050_3		1
+#define XCHAL_HW_CONFIGID_RELIABLE	1
+/*  If software targets a *range* of hardware versions, these are the bounds: */
+#define XCHAL_HW_MIN_VERSION_MAJOR	1050	/* major v of earliest tgt hw */
+#define XCHAL_HW_MIN_VERSION_MINOR	1	/* minor v of earliest tgt hw */
+#define XCHAL_HW_MAX_VERSION_MAJOR	1050	/* major v of latest tgt hw */
+#define XCHAL_HW_MAX_VERSION_MINOR	3	/* minor v of latest tgt hw */
+
+
+/*----------------------------------------------------------------------
+				CACHE
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_ICACHE_LINESIZE		16	/* I-cache line size in bytes */
+#define XCHAL_DCACHE_LINESIZE		16	/* D-cache line size in bytes */
+#define XCHAL_ICACHE_LINEWIDTH		4	/* log2(I line size in bytes) */
+#define XCHAL_DCACHE_LINEWIDTH		4	/* log2(D line size in bytes) */
+
+#define XCHAL_ICACHE_SIZE		8192	/* I-cache size in bytes or 0 */
+#define XCHAL_DCACHE_SIZE		8192	/* D-cache size in bytes or 0 */
+
+#define XCHAL_DCACHE_IS_WRITEBACK	0	/* writeback feature */
+
+
+
+
+/****************************************************************************
+    Parameters Useful for PRIVILEGED (Supervisory or Non-Virtualized) Code
+ ****************************************************************************/
+
+
+#ifndef XTENSA_HAL_NON_PRIVILEGED_ONLY
+
+/*----------------------------------------------------------------------
+				CACHE
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_HAVE_PIF			1	/* any outbound PIF present */
+
+/*  If present, cache size in bytes == (ways * 2^(linewidth + setwidth)).  */
+
+/*  Number of cache sets in log2(lines per way):  */
+#define XCHAL_ICACHE_SETWIDTH		8
+#define XCHAL_DCACHE_SETWIDTH		8
+
+/*  Cache set associativity (number of ways):  */
+#define XCHAL_ICACHE_WAYS		2
+#define XCHAL_DCACHE_WAYS		2
+
+/*  Cache features:  */
+#define XCHAL_ICACHE_LINE_LOCKABLE	0
+#define XCHAL_DCACHE_LINE_LOCKABLE	0
+
+/*  Number of encoded cache attr bits (see <xtensa/hal.h> for decoded bits):  */
+#define XCHAL_CA_BITS			4
+
+
+/*----------------------------------------------------------------------
+			INTERNAL I/D RAM/ROMs and XLMI
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_NUM_INSTROM		0	/* number of core instr. ROMs */
+#define XCHAL_NUM_INSTRAM		0	/* number of core instr. RAMs */
+#define XCHAL_NUM_DATAROM		0	/* number of core data ROMs */
+#define XCHAL_NUM_DATARAM		0	/* number of core data RAMs */
+#define XCHAL_NUM_XLMI			0	/* number of core XLMI ports */
+
+
+/*----------------------------------------------------------------------
+			INTERRUPTS and TIMERS
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_HAVE_INTERRUPTS		1	/* interrupt option */
+#define XCHAL_HAVE_HIGHPRI_INTERRUPTS	1	/* med/high-pri. interrupts */
+#define XCHAL_HAVE_NMI			0	/* non-maskable interrupt */
+#define XCHAL_HAVE_CCOUNT		1	/* CCOUNT reg. (timer option) */
+#define XCHAL_NUM_TIMERS		3	/* number of CCOMPAREn regs */
+#define XCHAL_NUM_INTERRUPTS		17	/* number of interrupts */
+#define XCHAL_NUM_INTERRUPTS_LOG2	5	/* ceil(log2(NUM_INTERRUPTS)) */
+#define XCHAL_NUM_EXTINTERRUPTS		10	/* num of external interrupts */
+#define XCHAL_NUM_INTLEVELS		4	/* number of interrupt levels
+						   (not including level zero) */
+#define XCHAL_EXCM_LEVEL		1	/* level masked by PS.EXCM */
+	/* (always 1 in XEA1; levels 2 .. EXCM_LEVEL are "medium priority") */
+
+/*  Masks of interrupts at each interrupt level:  */
+#define XCHAL_INTLEVEL1_MASK		0x000064F9
+#define XCHAL_INTLEVEL2_MASK		0x00008902
+#define XCHAL_INTLEVEL3_MASK		0x00011204
+#define XCHAL_INTLEVEL4_MASK		0x00000000
+#define XCHAL_INTLEVEL5_MASK		0x00000000
+#define XCHAL_INTLEVEL6_MASK		0x00000000
+#define XCHAL_INTLEVEL7_MASK		0x00000000
+
+/*  Masks of interrupts at each range 1..n of interrupt levels:  */
+#define XCHAL_INTLEVEL1_ANDBELOW_MASK	0x000064F9
+#define XCHAL_INTLEVEL2_ANDBELOW_MASK	0x0000EDFB
+#define XCHAL_INTLEVEL3_ANDBELOW_MASK	0x0001FFFF
+#define XCHAL_INTLEVEL4_ANDBELOW_MASK	0x0001FFFF
+#define XCHAL_INTLEVEL5_ANDBELOW_MASK	0x0001FFFF
+#define XCHAL_INTLEVEL6_ANDBELOW_MASK	0x0001FFFF
+#define XCHAL_INTLEVEL7_ANDBELOW_MASK	0x0001FFFF
+
+/*  Level of each interrupt:  */
+#define XCHAL_INT0_LEVEL		1
+#define XCHAL_INT1_LEVEL		2
+#define XCHAL_INT2_LEVEL		3
+#define XCHAL_INT3_LEVEL		1
+#define XCHAL_INT4_LEVEL		1
+#define XCHAL_INT5_LEVEL		1
+#define XCHAL_INT6_LEVEL		1
+#define XCHAL_INT7_LEVEL		1
+#define XCHAL_INT8_LEVEL		2
+#define XCHAL_INT9_LEVEL		3
+#define XCHAL_INT10_LEVEL		1
+#define XCHAL_INT11_LEVEL		2
+#define XCHAL_INT12_LEVEL		3
+#define XCHAL_INT13_LEVEL		1
+#define XCHAL_INT14_LEVEL		1
+#define XCHAL_INT15_LEVEL		2
+#define XCHAL_INT16_LEVEL		3
+#define XCHAL_DEBUGLEVEL		4	/* debug interrupt level */
+#define XCHAL_HAVE_DEBUG_EXTERN_INT	0	/* OCD external db interrupt */
+
+/*  Type of each interrupt:  */
+#define XCHAL_INT0_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT1_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT2_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT3_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT4_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT5_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT6_TYPE 	XTHAL_INTTYPE_EXTERN_LEVEL
+#define XCHAL_INT7_TYPE 	XTHAL_INTTYPE_EXTERN_EDGE
+#define XCHAL_INT8_TYPE 	XTHAL_INTTYPE_EXTERN_EDGE
+#define XCHAL_INT9_TYPE 	XTHAL_INTTYPE_EXTERN_EDGE
+#define XCHAL_INT10_TYPE 	XTHAL_INTTYPE_TIMER
+#define XCHAL_INT11_TYPE 	XTHAL_INTTYPE_TIMER
+#define XCHAL_INT12_TYPE 	XTHAL_INTTYPE_TIMER
+#define XCHAL_INT13_TYPE 	XTHAL_INTTYPE_SOFTWARE
+#define XCHAL_INT14_TYPE 	XTHAL_INTTYPE_SOFTWARE
+#define XCHAL_INT15_TYPE 	XTHAL_INTTYPE_SOFTWARE
+#define XCHAL_INT16_TYPE 	XTHAL_INTTYPE_SOFTWARE
+
+/*  Masks of interrupts for each type of interrupt:  */
+#define XCHAL_INTTYPE_MASK_UNCONFIGURED	0xFFFE0000
+#define XCHAL_INTTYPE_MASK_SOFTWARE	0x0001E000
+#define XCHAL_INTTYPE_MASK_EXTERN_EDGE	0x00000380
+#define XCHAL_INTTYPE_MASK_EXTERN_LEVEL	0x0000007F
+#define XCHAL_INTTYPE_MASK_TIMER	0x00001C00
+#define XCHAL_INTTYPE_MASK_NMI		0x00000000
+#define XCHAL_INTTYPE_MASK_WRITE_ERROR	0x00000000
+
+/*  Interrupt numbers assigned to specific interrupt sources:  */
+#define XCHAL_TIMER0_INTERRUPT		10	/* CCOMPARE0 */
+#define XCHAL_TIMER1_INTERRUPT		11	/* CCOMPARE1 */
+#define XCHAL_TIMER2_INTERRUPT		12	/* CCOMPARE2 */
+#define XCHAL_TIMER3_INTERRUPT		XTHAL_TIMER_UNCONFIGURED
+
+/*  Interrupt numbers for levels at which only one interrupt is configured:  */
+/*  (There are many interrupts each at level(s) 1, 2, 3.)  */
+
+
+/*
+ *  External interrupt vectors/levels.
+ *  These macros describe how Xtensa processor interrupt numbers
+ *  (as numbered internally, eg. in INTERRUPT and INTENABLE registers)
+ *  map to external BInterrupt<n> pins, for those interrupts
+ *  configured as external (level-triggered, edge-triggered, or NMI).
+ *  See the Xtensa processor databook for more details.
+ */
+
+/*  Core interrupt numbers mapped to each EXTERNAL interrupt number:  */
+#define XCHAL_EXTINT0_NUM		0	/* (intlevel 1) */
+#define XCHAL_EXTINT1_NUM		1	/* (intlevel 2) */
+#define XCHAL_EXTINT2_NUM		2	/* (intlevel 3) */
+#define XCHAL_EXTINT3_NUM		3	/* (intlevel 1) */
+#define XCHAL_EXTINT4_NUM		4	/* (intlevel 1) */
+#define XCHAL_EXTINT5_NUM		5	/* (intlevel 1) */
+#define XCHAL_EXTINT6_NUM		6	/* (intlevel 1) */
+#define XCHAL_EXTINT7_NUM		7	/* (intlevel 1) */
+#define XCHAL_EXTINT8_NUM		8	/* (intlevel 2) */
+#define XCHAL_EXTINT9_NUM		9	/* (intlevel 3) */
+
+
+/*----------------------------------------------------------------------
+			EXCEPTIONS and VECTORS
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_XEA_VERSION		2	/* Xtensa Exception Architecture
+						   number: 1 == XEA1 (old)
+							   2 == XEA2 (new)
+							   0 == XEAX (extern) */
+#define XCHAL_HAVE_XEA1			0	/* Exception Architecture 1 */
+#define XCHAL_HAVE_XEA2			1	/* Exception Architecture 2 */
+#define XCHAL_HAVE_XEAX			0	/* External Exception Arch. */
+#define XCHAL_HAVE_EXCEPTIONS		1	/* exception option */
+
+#define XCHAL_RESET_VECTOR_VADDR	0xFE000020
+#define XCHAL_RESET_VECTOR_PADDR	0xFE000020
+#define XCHAL_USER_VECTOR_VADDR		0xD0000220
+#define XCHAL_USER_VECTOR_PADDR		0x00000220
+#define XCHAL_KERNEL_VECTOR_VADDR	0xD0000200
+#define XCHAL_KERNEL_VECTOR_PADDR	0x00000200
+#define XCHAL_DOUBLEEXC_VECTOR_VADDR	0xD0000290
+#define XCHAL_DOUBLEEXC_VECTOR_PADDR	0x00000290
+#define XCHAL_WINDOW_VECTORS_VADDR	0xD0000000
+#define XCHAL_WINDOW_VECTORS_PADDR	0x00000000
+#define XCHAL_INTLEVEL2_VECTOR_VADDR	0xD0000240
+#define XCHAL_INTLEVEL2_VECTOR_PADDR	0x00000240
+#define XCHAL_INTLEVEL3_VECTOR_VADDR	0xD0000250
+#define XCHAL_INTLEVEL3_VECTOR_PADDR	0x00000250
+#define XCHAL_INTLEVEL4_VECTOR_VADDR	0xFE000520
+#define XCHAL_INTLEVEL4_VECTOR_PADDR	0xFE000520
+#define XCHAL_DEBUG_VECTOR_VADDR	XCHAL_INTLEVEL4_VECTOR_VADDR
+#define XCHAL_DEBUG_VECTOR_PADDR	XCHAL_INTLEVEL4_VECTOR_PADDR
+
+
+/*----------------------------------------------------------------------
+				DEBUG
+  ----------------------------------------------------------------------*/
+
+#define XCHAL_HAVE_OCD			1	/* OnChipDebug option */
+#define XCHAL_NUM_IBREAK		2	/* number of IBREAKn regs */
+#define XCHAL_NUM_DBREAK		2	/* number of DBREAKn regs */
+#define XCHAL_HAVE_OCD_DIR_ARRAY	1	/* faster OCD option */
+
+
+/*----------------------------------------------------------------------
+				MMU
+  ----------------------------------------------------------------------*/
+
+/*  See <xtensa/config/core-matmap.h> header file for more details.  */
+
+#define XCHAL_HAVE_TLBS			1	/* inverse of HAVE_CACHEATTR */
+#define XCHAL_HAVE_SPANNING_WAY		0	/* one way maps I+D 4GB vaddr */
+#define XCHAL_HAVE_IDENTITY_MAP		0	/* vaddr == paddr always */
+#define XCHAL_HAVE_CACHEATTR		0	/* CACHEATTR register present */
+#define XCHAL_HAVE_MIMIC_CACHEATTR	0	/* region protection */
+#define XCHAL_HAVE_XLT_CACHEATTR	0	/* region prot. w/translation */
+#define XCHAL_HAVE_PTP_MMU		1	/* full MMU (with page table
+						   [autorefill] and protection)
+						   usable for an MMU-based OS */
+/*  If one of the above last 4 is not set, it's a custom TLB configuration.  */
+#define XCHAL_ITLB_ARF_ENTRIES_LOG2	2	/* log2(autorefill way size) */
+#define XCHAL_DTLB_ARF_ENTRIES_LOG2	2	/* log2(autorefill way size) */
+
+#define XCHAL_MMU_ASID_BITS		8	/* number of bits in ASIDs */
+#define XCHAL_MMU_RINGS			4	/* number of rings (1..4) */
+#define XCHAL_MMU_RING_BITS		2	/* num of bits in RING field */
+
+#endif /* !XTENSA_HAL_NON_PRIVILEGED_ONLY */
+
+
+#endif /* _XTENSA_CORE_CONFIG_H */
+
Index: linux-2.6.10/include/asm-xtensa/dma.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/dma.h
+++ linux-2.6.10/include/asm-xtensa/dma.h
@@ -45,7 +45,7 @@
  *	enters another area, and virt_to_phys() may not return
  *	the value desired).
  */
-#define MAX_DMA_ADDRESS		(PAGE_OFFSET + XCHAL_KSEG_CACHED_SIZE - 1)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + XCHAL_KSEG_SIZE - 1)
 
 /* Reserve and release a DMA channel */
 extern int request_dma(unsigned int dmanr, const char * device_id);
Index: linux-2.6.10/include/asm-xtensa/elf.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/elf.h
+++ linux-2.6.10/include/asm-xtensa/elf.h
@@ -67,6 +67,7 @@ typedef elf_greg_t elf_gregset_t[ELF_NGR
  *
  */
 
+#if XCHAL_HAVE_CP
 #ifndef XCHAL_EXTRA_SA_CONTENTS_LIBDB_NUM
 # define XTENSA_CPE_LTABLE_SIZE		0
 #else
@@ -85,6 +86,7 @@ typedef elf_greg_t elf_gregset_t[ELF_NGR
 		)
 # define XTENSA_CPE_LTABLE_SIZE		(XTENSA_CPE_LTABLE_ENTRIES * 8)
 #endif
+#endif
 
 
 /*
@@ -119,8 +121,13 @@ typedef elf_greg_t elf_gregset_t[ELF_NGR
  * to allow optimizations of layout and copying.
  */
 
-#define TOTAL_FPREGS_SIZE						\
+#if XCHAL_HAVE_CP
+# define TOTAL_FPREGS_SIZE						\
   	(4 + XTENSA_CPE_LTABLE_SIZE + XTENSA_CP_EXTRA_SIZE)
+#else
+# define TOTAL_FPREGS_SIZE 0
+#endif
+
 #define ELF_NFPREG							\
 	((TOTAL_FPREGS_SIZE + sizeof(elf_fpreg_t) - 1) / sizeof(elf_fpreg_t))
 
@@ -207,6 +214,8 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #define SET_PERSONALITY(ex, ibcs2) set_personality(PER_LINUX_32BIT)
 
+struct task_struct;
+
 extern void do_copy_regs (xtensa_gregset_t*, struct pt_regs*,
 			  struct task_struct*);
 extern void do_restore_regs (xtensa_gregset_t*, struct pt_regs*,
Index: linux-2.6.10/include/asm-xtensa/io.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/io.h
+++ linux-2.6.10/include/asm-xtensa/io.h
@@ -14,12 +14,12 @@
 #ifdef __KERNEL__
 #include <linux/config.h>
 #include <asm/byteorder.h>
-
 #include <linux/types.h>
-#include <asm/fixmap.h>
-
-#define _IO_BASE 0
 
+#define XCHAL_KIO_CACHED_VADDR	0xf0000000
+#define XCHAL_KIO_BYPASS_VADDR	0xf8000000
+#define XCHAL_KIO_PADDR		0xf0000000
+#define XCHAL_KIO_SIZE		0x08000000
 
 /*
  * swap functions to change byte order from little-endian to big-endian and
@@ -43,40 +43,43 @@ static inline unsigned int _swapl (unsig
 
 static inline unsigned long virt_to_phys(volatile void * address)
 {
-	return PHYSADDR((unsigned long)address);
+	return __pa(address);
 }
 
 static inline void * phys_to_virt(unsigned long address)
 {
-	return (void*) CACHED_ADDR(address);
+	return __va(address);
 }
 
 /*
- * IO bus memory addresses are also 1:1 with the physical address
+ * virt_to_bus and bus_to_virt are deprecated.
  */
 
-static inline unsigned long virt_to_bus(volatile void * address)
-{
-	return PHYSADDR((unsigned long)address);
-}
-
-static inline void * bus_to_virt (unsigned long address)
-{
-	return (void *) CACHED_ADDR(address);
-}
+#define virt_to_bus(x)	virt_to_phys(x)
+#define bus_to_virt(x)	phys_to_virt(x)
 
-/*
- * Change "struct page" to physical address.
+/* 
+ * Return the virtual (cached) address for the specified bus memory.
+ * Note that we currently don't support any address outside the KIO segment.
  */
 
 static inline void *ioremap(unsigned long offset, unsigned long size)
 {
-        return (void *) CACHED_ADDR_IO(offset);
+	if (offset >= XCHAL_KIO_PADDR 
+	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_BYPASS_VADDR);
+
+	else
+		BUG();
 }
 
 static inline void *ioremap_nocache(unsigned long offset, unsigned long size)
 {
-        return (void *) BYPASS_ADDR_IO(offset);
+	if (offset >= XCHAL_KIO_PADDR
+	    && offset < XCHAL_KIO_PADDR + XCHAL_KIO_SIZE)
+		return (void*)(offset-XCHAL_KIO_PADDR+XCHAL_KIO_CACHED_VADDR);
+	else
+		BUG();
 }
 
 static inline void iounmap(void *addr)
@@ -122,9 +125,6 @@ static inline void __raw_writel(__u32 b,
           *(__force volatile __u32 *)(addr) = b;
 }
 
-
-
-
 /* These are the definitions for the x86 IO instructions
  * inb/inw/inl/outb/outw/outl, the "string" versions
  * insb/insw/insl/outsb/outsw/outsl, and the "pausing" versions
@@ -132,11 +132,11 @@ static inline void __raw_writel(__u32 b,
  * The macros don't do byte-swapping.
  */
 
-#define inb(port)		readb((u8 *)((port)+_IO_BASE))
-#define outb(val, port)		writeb((val),(u8 *)((unsigned long)(port)+_IO_BASE))
-#define inw(port)		readw((u16 *)((port)+_IO_BASE))
-#define outw(val, port)		writew((val),(u16 *)((unsigned long)(port)+_IO_BASE))
-#define inl(port)		readl((u32 *)((port)+_IO_BASE))
+#define inb(port)		readb((u8 *)((port)))
+#define outb(val, port)		writeb((val),(u8 *)((unsigned long)(port)))
+#define inw(port)		readw((u16 *)((port)))
+#define outw(val, port)		writew((val),(u16 *)((unsigned long)(port)))
+#define inl(port)		readl((u32 *)((port)))
 #define outl(val, port)		writel((val),(u32 *)((unsigned long)(port)))
 
 #define inb_p(port)		inb((port))
@@ -181,14 +181,13 @@ extern void outsl (unsigned long port, c
 
 
 /*
- *  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
- *   * access
- *    */
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem access
+ */
 #define xlate_dev_mem_ptr(p)    __va(p)
 
 /*
- *  * Convert a virtual cached pointer to an uncached pointer
- *   */
+ * Convert a virtual cached pointer to an uncached pointer
+ */
 #define xlate_dev_kmem_ptr(p)   p
 
 
Index: linux-2.6.10/include/asm-xtensa/mmu_context.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/mmu_context.h
+++ linux-2.6.10/include/asm-xtensa/mmu_context.h
@@ -17,7 +17,6 @@
 #include <linux/stringify.h>
 
 #include <asm/pgtable.h>
-#include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
@@ -33,10 +32,15 @@
  * remove it altogether if you think you know what you're doing.  :)
  */
 
+#define XCHAL_MMU_ASID_BITS	8
+
 #if (XCHAL_HAVE_TLBS != 1)
 # error "Linux must have an MMU!"
 #endif
 
+extern unsigned long asid_cache;
+
+#if 0
 #if ((XCHAL_ITLB_ARF_WAYS == 0) || (XCHAL_DTLB_ARF_WAYS == 0))
 # error "MMU must have auto-refill ways"
 #endif
@@ -199,6 +203,12 @@ extern pgd_t *current_pgd;
 #define ASID_FIRST_VERSION						\
 	((unsigned long)(~ASID_VERSION_MASK) + 1 + ASID_FIRST_NONRESERVED)
 
+#endif
+#define NO_CONTEXT		0
+#define ASID_USER_FIRST		4
+#define ASID_MASK	((1 << XCHAL_MMU_ASID_BITS) - 1)
+#define ASID_INSERT(x)	(0x03020001 | (((x) & ASID_MASK) << 8))
+
 static inline void set_rasid_register (unsigned long val)
 {
 	__asm__ __volatile__ (" wsr %0, "__stringify(RASID)"\n\t"
@@ -212,63 +222,24 @@ static inline unsigned long get_rasid_re
 	return tmp;
 }
 
-
-#if ((XCHAL_MMU_ASID_INVALID == 0) && (XCHAL_MMU_ASID_KERNEL == 1))
-
 static inline void
-get_new_mmu_context(struct mm_struct *mm, unsigned long asid)
+__get_new_mmu_context(struct mm_struct *mm)
 {
 	extern void flush_tlb_all(void);
-	if (! ((asid += ASID_INC) & ASID_MASK) ) {
+	if (! (++asid_cache & ASID_MASK) ) {
 		flush_tlb_all(); /* start new asid cycle */
-		if (!asid)      /* fix version if needed */
-			asid = ASID_FIRST_VERSION - ASID_FIRST_NONRESERVED;
-		asid += ASID_FIRST_NONRESERVED;
+		asid_cache += ASID_USER_FIRST;
 	}
-	mm->context = asid_cache = asid;
-}
-
-#else
-#warning ASID_{INVALID,KERNEL} values impose non-optimal get_new_mmu_context implementation
-
-/* XCHAL_MMU_ASID_INVALID == 0 and XCHAL_MMU_ASID_KERNEL ==1 are
-   really the best, but if you insist... */
-
-static inline int validate_asid (unsigned long asid)
-{
-	switch (asid) {
-	case XCHAL_MMU_ASID_INVALID:
-	case XCHAL_MMU_ASID_KERNEL:
-	case ASID_RESERVED_1:
-	case ASID_RESERVED_2:
-	case ASID_RESERVED_3:
-		return 0; /* can't use these values as ASIDs */
-	}
-	return 1; /* valid */
+	mm->context = asid_cache;
 }
 
 static inline void
-get_new_mmu_context(struct mm_struct *mm, unsigned long asid)
+__load_mmu_context(struct mm_struct *mm)
 {
-	extern void flush_tlb_all(void);
-	while (1) {
-		asid += ASID_INC;
-		if ( ! (asid & ASID_MASK) ) {
-			flush_tlb_all(); /* start new asid cycle */
-			if (!asid)      /* fix version if needed */
-				asid = ASID_FIRST_VERSION - ASID_FIRST_NONRESERVED;
-			asid += ASID_FIRST_NONRESERVED;
-			break; /* no need to validate here */
-		}
-		if (validate_asid (asid & ASID_MASK))
-			break;
-	}
-	mm->context = asid_cache = asid;
+	set_rasid_register(ASID_INSERT(mm->context));
+	invalidate_page_directory();
 }
 
-#endif
-
-
 /*
  * Initialize the context related info for a new mm_struct
  * instance.
@@ -281,6 +252,20 @@ init_new_context(struct task_struct *tsk
 	return 0;
 }
 
+/*
+ * After we have set current->mm to a new value, this activates
+ * the context for the new mm so we see the new mappings.
+ */
+static inline void
+activate_mm(struct mm_struct *prev, struct mm_struct *next)
+{
+	/* Unconditionally get a new ASID.  */
+
+	__get_new_mmu_context(next);
+	__load_mmu_context(next);
+}
+
+
 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
                              struct task_struct *tsk)
 {
@@ -288,11 +273,10 @@ static inline void switch_mm(struct mm_s
 
 	/* Check if our ASID is of an older version and thus invalid */
 
-	if ((next->context ^ asid) & ASID_VERSION_MASK)
-		get_new_mmu_context(next, asid);
+	if (next->context == NO_CONTEXT || ((next->context^asid) & ~ASID_MASK))
+		__get_new_mmu_context(next);
 
-	set_rasid_register (ASID_INSERT(next->context));
-	invalidate_page_directory();
+	__load_mmu_context(next);
 }
 
 #define deactivate_mm(tsk, mm)	do { } while(0)
@@ -303,20 +287,6 @@ static inline void switch_mm(struct mm_s
  */
 static inline void destroy_context(struct mm_struct *mm)
 {
-	/* Nothing to do. */
-}
-
-/*
- * After we have set current->mm to a new value, this activates
- * the context for the new mm so we see the new mappings.
- */
-static inline void
-activate_mm(struct mm_struct *prev, struct mm_struct *next)
-{
-	/* Unconditionally get a new ASID.  */
-
-	get_new_mmu_context(next, asid_cache);
-	set_rasid_register (ASID_INSERT(next->context));
 	invalidate_page_directory();
 }
 
Index: linux-2.6.10/include/asm-xtensa/page.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/page.h
+++ linux-2.6.10/include/asm-xtensa/page.h
@@ -16,6 +16,11 @@
 #include <asm/processor.h>
 #include <linux/config.h>
 
+#define XCHAL_KSEG_CACHED_VADDR 0xd0000000
+#define XCHAL_KSEG_BYPASS_VADDR 0xd8000000
+#define XCHAL_KSEG_PADDR        0x00000000
+#define XCHAL_KSEG_SIZE         0x08000000
+
 /*
  * PAGE_SHIFT determines the page size
  * PAGE_ALIGN(x) aligns the pointer to the (next) page boundary
@@ -28,6 +33,8 @@
 
 #define DCACHE_WAY_SIZE		(XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS)
 #define PAGE_OFFSET		XCHAL_KSEG_CACHED_VADDR
+#define MAX_MEM_PFN		XCHAL_KSEG_SIZE
+#define PGTABLE_START		0x80000000
 
 #ifdef __ASSEMBLY__
 
Index: linux-2.6.10/include/asm-xtensa/pgtable.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/pgtable.h
+++ linux-2.6.10/include/asm-xtensa/pgtable.h
@@ -17,6 +17,7 @@
 
 #ifdef CONFIG_MMU
 
+#if 0
 #if (XCHAL_MMU_RINGS < 2)
 # error Linux build assumes at least 2 ring levels.
 #endif
@@ -48,7 +49,7 @@
 #  error Page coloring requires its own wired dtlb way!
 # endif
 #endif
-
+#endif
 #endif /* CONFIG_MMU */
 
 /*
@@ -100,7 +101,7 @@
 #define PTRS_PER_PMD		1
 #define PTRS_PER_PGD		1024
 #define USER_PTRS_PER_PGD	(TASK_SIZE/PGDIR_SIZE)
-#define FIRST_USER_ADDRESS      XCHAL_SEG_MAPPABLE_VADDR
+#define FIRST_USER_ADDRESS	0
 #define FIRST_USER_PGD_NR	(FIRST_USER_ADDRESS >> PGDIR_SHIFT)
 
 /* virtual memory area. We keep a distance to other memory regions to be
@@ -128,8 +129,8 @@
  * See further below for PTE layout for swapped-out pages.
  */
 
-#define _PAGE_EXEC		(1<<0)	/* hardware: page is executable */
-#define _PAGE_WEN		(1<<1)	/* hardware: page is writable */
+#define _PAGE_HWEXEC		(1<<0)	/* hardware: page is executable */
+#define _PAGE_HWWRITE		(1<<1)	/* hardware: page is writable */
 #define _PAGE_FILE		(1<<1)	/* nonlinear file mapping (if invalid)*/
 
 /* None of these cache modes include MP coherency:  */
@@ -148,40 +149,39 @@
 #define _PAGE_KERNEL		(0<<4)	/* kernel access (ring=0) */
 
 /* Software */
-#define _PAGE_RW		(1<<6)	/* software: page writable */
+#define _PAGE_WRITABLE		(1<<6)	/* software: page writable */
+#define _PAGE_WRITABLE_BIT	6
 #define _PAGE_DIRTY		(1<<7)	/* software: page dirty */
 #define _PAGE_ACCESSED		(1<<8)	/* software: page accessed (read) */
 
-#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_CACHE_MASK | _PAGE_DIRTY)
-#if XCHAL_HAVE_PTE_EXECUTABLE
+
+#define _PAGE_CHG_MASK	(PAGE_MASK|_PAGE_ACCESSED|_PAGE_CACHE_MASK|_PAGE_DIRTY)
+
+#ifdef XCHAL_HAVE_CA_EXEC
 # define _PAGE_PRESENT	(_PAGE_WRITEBACK | _PAGE_ACCESSED)
 #else
-# define _PAGE_PRESENT	(_PAGE_WRITEBACK | _PAGE_ACCESSED | _PAGE_EXEC)
+# define _PAGE_PRESENT	(_PAGE_WRITEBACK | _PAGE_ACCESSED | _PAGE_HWEXEC)
 #endif
 
+#define	_PAGE_DIRECTORY	(_PAGE_PRESENT)
+
 #ifdef CONFIG_MMU
 
+/*
+ * Use the first min-wired way for mapping page-table pages.
+ * Page coloring requires a second min-wired way.
+ */
+
 # define PAGE_NONE	    __pgprot(_PAGE_PRESENT)
-# define PAGE_SHARED_EXEC						      \
-	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_RW | _PAGE_EXEC)
-# define PAGE_SHARED	    __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_RW)
-# define PAGE_COPY_EXEC	    __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_EXEC)
+# define PAGE_SHARED_EXEC   __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_WRITABLE | _PAGE_HWEXEC)
+# define PAGE_SHARED	    __pgprot(_PAGE_PRESENT | _PAGE_USER |_PAGE_WRITABLE)
+# define PAGE_COPY_EXEC	    __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_HWEXEC)
 # define PAGE_COPY	    __pgprot(_PAGE_PRESENT | _PAGE_USER)
-# define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_EXEC)
+# define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_HWEXEC)
 # define PAGE_READONLY	    __pgprot(_PAGE_PRESENT | _PAGE_USER)
-# define PAGE_KERNEL_EXEC						      \
-	__pgprot(_PAGE_PRESENT | _PAGE_KERNEL | _PAGE_WEN | _PAGE_EXEC)
-# define PAGE_KERNEL	    __pgprot(_PAGE_PRESENT | _PAGE_KERNEL | _PAGE_WEN)
-
-# if (DCACHE_WAY_SIZE > PAGE_SIZE)
-#  if XCHAL_HAVE_PTE_EXECUTABLE
-#   define PAGE_DIRECTORY  __pgprot(_PAGE_VALID | _PAGE_ACCESSED | _PAGE_KERNEL)
-#  else
-#   define PAGE_DIRECTORY  __pgprot(_PAGE_ACCESSED | _PAGE_KERNEL)
-#  endif
-# else
-#  define PAGE_DIRECTORY  __pgprot(_PAGE_PRESENT | _PAGE_KERNEL)
-# endif
+# define PAGE_KERNEL_EXEC   __pgprot(_PAGE_PRESENT | _PAGE_HWWRITE | _PAGE_HWEXEC)
+# define PAGE_KERNEL	    __pgprot(_PAGE_PRESENT | _PAGE_HWWRITE)
+
 
 #else /* no mmu */
 
@@ -268,18 +268,22 @@ extern pgd_t swapper_pg_dir[PAGE_SIZE/si
 /* Note: We use the _PAGE_USER bit to indicate write-protect kernel memory */
 
 static inline int pte_read(pte_t pte)  { return pte_val(pte) & _PAGE_USER; }
-static inline int pte_write(pte_t pte) { return pte_val(pte) & _PAGE_RW; }
+static inline int pte_write(pte_t pte) { return pte_val(pte) & _PAGE_WRITABLE; }
 static inline int pte_dirty(pte_t pte) { return pte_val(pte) & _PAGE_DIRTY; }
 static inline int pte_young(pte_t pte) { return pte_val(pte) & _PAGE_ACCESSED; }
 static inline int pte_file(pte_t pte)  { return pte_val(pte) & _PAGE_FILE; }
-static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~(_PAGE_RW | _PAGE_WEN); return pte; }
-static inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_USER; return pte; }
-static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
-static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
-static inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) |= _PAGE_USER; return pte; }
-static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
-static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
-static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= _PAGE_RW; return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	
+	{ pte_val(pte) &= ~(_PAGE_WRITABLE | _PAGE_HWWRITE); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)
+	{ pte_val(pte) &= ~(_PAGE_DIRTY | _PAGE_HWWRITE); return pte; }
+static inline pte_t pte_mkold(pte_t pte)
+	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)
+	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)
+	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)
+	{ pte_val(pte) |= _PAGE_WRITABLE; return pte; }
 
 /*
  * Conversion functions: convert a page and protection to a page entry,
Index: linux-2.6.10/include/asm-xtensa/platform-iss/hardware.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/platform-iss/hardware.h
+++ linux-2.6.10/include/asm-xtensa/platform-iss/hardware.h
@@ -19,8 +19,8 @@
  * Memory configuration.
  */
 
-#define PLATFORM_DEFAULT_MEM_START XSHAL_RAM_PADDR
-#define PLATFORM_DEFAULT_MEM_SIZE XSHAL_RAM_VSIZE
+#define PLATFORM_DEFAULT_MEM_START	0x00000000
+#define PLATFORM_DEFAULT_MEM_SIZE	0x08000000
 
 /*
  * Interrupt configuration.
Index: linux-2.6.10/include/asm-xtensa/posix_types.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/posix_types.h
+++ linux-2.6.10/include/asm-xtensa/posix_types.h
@@ -21,7 +21,7 @@
 
 typedef unsigned long	__kernel_ino_t;
 typedef unsigned int	__kernel_mode_t;
-typedef unsigned short	__kernel_nlink_t;
+typedef unsigned long	__kernel_nlink_t;
 typedef long		__kernel_off_t;
 typedef int		__kernel_pid_t;
 typedef unsigned short	__kernel_ipc_pid_t;
Index: linux-2.6.10/include/asm-xtensa/processor.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/processor.h
+++ linux-2.6.10/include/asm-xtensa/processor.h
@@ -11,18 +11,14 @@
 #ifndef _XTENSA_PROCESSOR_H
 #define _XTENSA_PROCESSOR_H
 
-#ifdef __ASSEMBLY__
-#define _ASMLANGUAGE
-#endif
-
+#include <asm/cpu/config.h>
 
-#include <asm/regs.h>
 #include <asm/ptrace.h>
 #include <asm/types.h>
+#include <asm/regs.h>
 #include <asm/coprocessor.h>
 
-#include <asm/config/core.h>
-#include <asm/config/tie.h>
+
 
 /* Assertions. */
 
@@ -144,11 +140,11 @@ struct thread_struct {
  * Note: We set-up ps as if we did a call4 to the new pc.
  *       set_thread_state in signal.c depends on it.
  */
-#define USER_PS_VALUE ( (1 << XCHAL_PS_WOE_SHIFT) + \
-                        (1 << XCHAL_PS_CALLINC_SHIFT) + \
-                        (USER_RING << XCHAL_PS_RING_SHIFT) + \
-                        (1 << XCHAL_PS_PROGSTACK_SHIFT) + \
-                        (1 << XCHAL_PS_EXCM_SHIFT) )
+#define USER_PS_VALUE ( (1 << PS_WOE_SHIFT) + \
+                        (1 << PS_CALLINC_SHIFT) + \
+                        (USER_RING << PS_RING_SHIFT) + \
+                        (1 << PS_PROGSTACK_SHIFT) + \
+                        (1 << PS_EXCM_SHIFT) )
 
 /* Clearing a0 terminates the backtrace. */
 #define start_thread(regs, new_pc, new_sp) \
Index: linux-2.6.10/include/asm-xtensa/ptrace.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/ptrace.h
+++ linux-2.6.10/include/asm-xtensa/ptrace.h
@@ -13,7 +13,7 @@
 #ifndef _XTENSA_PTRACE_H
 #define _XTENSA_PTRACE_H
 
-#include <asm/config/core.h>
+#include <asm/cpu/config.h>
 
 /*
  * Kernel stack
Index: linux-2.6.10/include/asm-xtensa/resource.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/resource.h
+++ linux-2.6.10/include/asm-xtensa/resource.h
@@ -26,7 +26,7 @@
 #define RLIMIT_AS 9			/* mapped memory */
 #define RLIMIT_LOCKS	10		/* maximum file locks held */
 
-#define RLIM_NLIMITS 		11      /* Number of limit flavors.  */
+#define RLIM_NLIMITS 		13      /* Number of limit flavors.  */
 #define RLIMIT_SIGPENDING	11	/* max number of pending signals */
 #define RLIMIT_MSGQUEUE		12	/* maximum bytes in POSIX mqueues */
 
Index: linux-2.6.10/include/asm-xtensa/sigcontext.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/sigcontext.h
+++ linux-2.6.10/include/asm-xtensa/sigcontext.h
@@ -11,7 +11,7 @@
 #ifndef _XTENSA_SIGCONTEXT_H
 #define _XTENSA_SIGCONTEXT_H
 
-#include <asm/config/core.h>
+#include <asm/cpu/config.h>
 #include <asm/coprocessor.h>
 
 
Index: linux-2.6.10/include/asm-xtensa/stat.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/stat.h
+++ linux-2.6.10/include/asm-xtensa/stat.h
@@ -13,24 +13,10 @@
 
 #include <linux/types.h>
 
-struct __old_kernel_stat {
-	unsigned short st_dev;
-	unsigned short st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned long  st_size;
-	unsigned long  st_atime;
-	unsigned long  st_mtime;
-	unsigned long  st_ctime;
-};
-
 #define STAT_HAVE_NSEC 1
 
 struct stat {
-	unsigned int	st_dev;
+	unsigned long	st_dev;
 	ino_t		st_ino;
 	mode_t		st_mode;
 	nlink_t		st_nlink;
@@ -50,7 +36,7 @@ struct stat {
 	unsigned long	__unused5;
 };
 
-/* This matches struct stat64 in glibc-2.2.3. */
+/* This matches struct stat64 in glibc-2.3 */
 
 struct stat64  {
 	unsigned long long st_dev;	/* Device */
@@ -60,18 +46,24 @@ struct stat64  {
 	unsigned int  st_uid;		/* User ID of the file's owner. */
 	unsigned int  st_gid;		/* Group ID of the file's group. */
 	unsigned long long st_rdev;	/* Device number, if device. */
-        unsigned short int __pad2;
-	long long int  st_size;		/* Size of file, in bytes. */
-	long int st_blksize;		/* Optimal block size for I/O. */
-	long long st_blocks;		/* Number 512-byte blocks allocated. */
+	long long st_size;		/* Size of file, in bytes. */
+	long st_blksize;		/* Optimal block size for I/O. */
+	unsigned long __unused2;
+#ifdef __XTENSA_EB__
+	unsigned long __unused3;
+	long st_blocks;			/* Number 512-byte blocks allocated. */
+#else
+	long st_blocks;			/* Number 512-byte blocks allocated. */
+	unsigned long __unused3;
+#endif
 	long st_atime;			/* Time of last access. */
 	unsigned long st_atime_nsec;
 	long st_mtime;			/* Time of last modification. */
 	unsigned long st_mtime_nsec;
 	long st_ctime;			/* Time of last status change. */
 	unsigned long st_ctime_nsec;
-	unsigned long  __unused4;
-	unsigned long  __unused5;
+	unsigned long __unused4;
+	unsigned long __unused5;
 };
 
 #endif	/* _XTENSA_STAT_H */
Index: linux-2.6.10/include/asm-xtensa/syscalls.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/syscalls.h
+++ linux-2.6.10/include/asm-xtensa/syscalls.h
@@ -17,5 +17,4 @@ asmlinkage long sys_rt_sigaction(int,
 				 const struct sigaction __user *,
 				 struct sigaction __user *,
 				 size_t);
-
-
+asmlinkage long xtensa_shmat(int shmid, char __user *shmaddr, int shmflg);
Index: linux-2.6.10/include/asm-xtensa/timex.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/timex.h
+++ linux-2.6.10/include/asm-xtensa/timex.h
@@ -16,17 +16,22 @@
 #include <asm/processor.h>
 #include <linux/stringify.h>
 
-#if XCHAL_INT_LEVEL(XCHAL_TIMER0_INTERRUPT) == 1
-# define LINUX_TIMER     0
-#elif XCHAL_INT_LEVEL(XCHAL_TIMER1_INTERRUPT) == 1
-# define LINUX_TIMER     1
-#elif XCHAL_INT_LEVEL(XCHAL_TIMER2_INTERRUPT) == 1
-# define LINUX_TIMER     2
+#define _INTLEVEL(x) XCHAL_INT ##x ## _LEVEL
+#define INTLEVEL(x) _INTLEVEL(x)
+
+#if INTLEVEL(XCHAL_TIMER0_INTERRUPT) == 1
+# define LINUX_TIMER		0
+# define LINUX_TIMER_INT	XCHAL_TIMER0_INTERRUPT
+#elif INTLEVEL(XCHAL_TIMER1_INTERRUPT) == 1
+# define LINUX_TIMER		1
+# define LINUX_TIMER_INT	XCHAL_TIMER1_INTERRUPT
+#elif INTLEVEL(XCHAL_TIMER2_INTERRUPT) == 1
+# define LINUX_TIMER		2
+# define LINUX_TIMER_INT	XCHAL_TIMER2_INTERRUPT
 #else
 # error "Bad timer number for Linux configurations!"
 #endif
 
-#define LINUX_TIMER_INT         XCHAL_TIMER_INTERRUPT(LINUX_TIMER)
 #define LINUX_TIMER_MASK        (1L << LINUX_TIMER_INT)
 
 #define CLOCK_TICK_RATE 	1193180	/* (everyone is using this value) */
Index: linux-2.6.10/include/asm-xtensa/tlbflush.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/tlbflush.h
+++ linux-2.6.10/include/asm-xtensa/tlbflush.h
@@ -11,12 +11,20 @@
 #ifndef _XTENSA_TLBFLUSH_H
 #define _XTENSA_TLBFLUSH_H
 
-#define DEBUG_TLB
-
 #ifdef __KERNEL__
 
-#include <asm/processor.h>
 #include <linux/stringify.h>
+#include <asm/processor.h>
+
+#define DTLB_WAY_PGD	7
+
+#define ITLB_ARF_WAYS	4
+#define DTLB_ARF_WAYS	4
+
+#define ITLB_HIT_BIT	3
+#define DTLB_HIT_BIT	4
+
+#ifndef __ASSEMBLY__
 
 /* TLB flushing:
  *
@@ -46,11 +54,6 @@ static inline void flush_tlb_pgtables(st
 
 /* TLB operations. */
 
-#define ITLB_WAYS_LOG2      XCHAL_ITLB_WAY_BITS
-#define DTLB_WAYS_LOG2      XCHAL_DTLB_WAY_BITS
-#define ITLB_PROBE_SUCCESS  (1 << ITLB_WAYS_LOG2)
-#define DTLB_PROBE_SUCCESS  (1 << DTLB_WAYS_LOG2)
-
 static inline unsigned long itlb_probe(unsigned long addr)
 {
 	unsigned long tmp;
@@ -131,21 +134,23 @@ static inline void write_itlb_entry (pte
 
 static inline void invalidate_page_directory (void)
 {
-	invalidate_dtlb_entry (DTLB_WAY_PGTABLE);
+	invalidate_dtlb_entry (DTLB_WAY_PGD);
+	invalidate_dtlb_entry (DTLB_WAY_PGD+1);
+	invalidate_dtlb_entry (DTLB_WAY_PGD+2);
 }
 
 static inline void invalidate_itlb_mapping (unsigned address)
 {
 	unsigned long tlb_entry;
-	while ((tlb_entry = itlb_probe (address)) & ITLB_PROBE_SUCCESS)
-		invalidate_itlb_entry (tlb_entry);
+	if (((tlb_entry = itlb_probe(address)) & (1 << ITLB_HIT_BIT)) != 0)
+		invalidate_itlb_entry(tlb_entry);
 }
 
 static inline void invalidate_dtlb_mapping (unsigned address)
 {
 	unsigned long tlb_entry;
-	while ((tlb_entry = dtlb_probe (address)) & DTLB_PROBE_SUCCESS)
-		invalidate_dtlb_entry (tlb_entry);
+	if (((tlb_entry = dtlb_probe(address)) & (1 << DTLB_HIT_BIT)) != 0) 
+		invalidate_dtlb_entry(tlb_entry);
 }
 
 #define check_pgt_cache()	do { } while (0)
@@ -194,5 +199,6 @@ static inline unsigned long read_itlb_tr
 }
 
 #endif	/* DEBUG_TLB */
+#endif	/* __ASSEMBLY__ */
 #endif	/* __KERNEL__ */
 #endif	/* _XTENSA_TLBFLUSH_H */
Index: linux-2.6.10/include/asm-xtensa/unistd.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/unistd.h
+++ linux-2.6.10/include/asm-xtensa/unistd.h
@@ -214,6 +214,8 @@ __SYSCALL( 90, sys_mincore, 3)
 __SYSCALL( 91, sys_madvise, 3)
 #define __NR_shmget				 92
 __SYSCALL( 92, sys_shmget, 4)
+#define __NR_shmat				 93
+__SYSCALL( 93, xtensa_shmat, 4)
 #define __NR_shmctl				 94
 __SYSCALL( 94, sys_shmctl, 4)
 #define __NR_shmdt				 95
@@ -356,6 +358,8 @@ __SYSCALL(157, sys_sched_getaffinity, 3)
 __SYSCALL(158, sys_capget, 2)
 #define __NR_capset 				159
 __SYSCALL(159, sys_capset, 2)
+#define __NR_ptrace 				160
+__SYSCALL(160, xtensa_ptrace, 4)
 #define __NR_semtimedop				161
 __SYSCALL(161, sys_semtimedop, 5)
 #define __NR_semget				162
Index: linux-2.6.10/arch/xtensa/Makefile
===================================================================
--- linux-2.6.10.orig/arch/xtensa/Makefile
+++ linux-2.6.10/arch/xtensa/Makefile
@@ -78,11 +78,12 @@ prepare: $(archinc)/.platform $(archinc)
 # them changed.
 
 $(archinc)/.platform: $(wildcard include/config/arch/*.h) include/config/MARKER
-	@echo '  SYMLINK $(archinc)/xtensa/config -> $(archinc)/config-$(CPU)'
+	@echo '  SYMLINK $(archinc)/cpu -> $(archinc)/cpu-$(CPU)'
 	$(Q)mkdir -p $(archinc)
 	$(Q)mkdir -p $(archinc)/xtensa
 	$(Q)ln -fsn $(srctree)/$(archinc)/xtensa/config-$(CPU) $(archinc)/config
 	$(Q)ln -fsn $(srctree)/$(archinc)/xtensa/config-$(CPU) $(archinc)/xtensa/config
+	$(Q)ln -fsn $(srctree)/$(archinc)/cpu-$(CPU) $(archinc)/cpu
 	@echo '  SYMLINK $(archinc)/platform -> $(archinc)/platform-$(PLATFORM)'
 	$(Q)ln -fsn $(srctree)/$(archinc)/platform-$(PLATFORM) $(archinc)/platform
 	@touch $@
Index: linux-2.6.10/arch/xtensa/boot/boot-elf/bootstrap.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/boot/boot-elf/bootstrap.S
+++ linux-2.6.10/arch/xtensa/boot/boot-elf/bootstrap.S
@@ -1,7 +1,4 @@
 
-#include <xtensa/config/specreg.h>
-#include <xtensa/config/core.h>
-
 #include <linux/config.h>
 #include <asm/bootparam.h>
 
Index: linux-2.6.10/arch/xtensa/boot/boot-redboot/bootstrap.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/boot/boot-redboot/bootstrap.S
+++ linux-2.6.10/arch/xtensa/boot/boot-redboot/bootstrap.S
@@ -1,6 +1,6 @@
-
-#include <asm/processor.h>
-
+#include <asm/cpu/config.h>
+#include <asm/regs.h>
+#include <asm/asmmacro.h>
 	/*
 	 * RB-Data: RedBoot data/bss
 	 * P:	    Boot-Parameters
@@ -106,27 +106,30 @@ _start:
 
 	/* We have to flush and invalidate the caches here before we jump. */
 
-#if XCHAL_DCACHE_IS_WRITEBACK
-	movi	a5, 0
-	movi	a6, XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS
+#undef __DCACHE_WAYSIZE
+#define __DCACHE_WAYSIZE        (XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS)
+#undef __ICACHE_WAYSIZE
+#define __ICACHE_WAYSIZE        (XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS)
 
-1:	diwb	a5, 0 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 1 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 2 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 3 * XCHAL_DCACHE_LINESIZE
-	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
-	bltu	a5, a6, 1b
+#if XCHAL_DCACHE_IS_WRITEBACK
+	movi    a5, 0
+	__loopi a5, a6, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	dii     a5, 0 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 1 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 2 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 3 * XCHAL_DCACHE_LINESIZE
+	__endla a5, a6, XCHAL_DCACHE_LINESIZE * 4
 #endif
 
-	movi	a5, 0
-	movi	a6, XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS
+	movi    a5, 0
+	__loopi a5, a6, __ICACHE_WAYSIZE, XCHAL_ICACHE_LINESIZE * 4
+	iii     a5, 0 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 1 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 2 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 3 * XCHAL_ICACHE_LINESIZE
+	__endla a5, a6, XCHAL_ICACHE_LINESIZE * 4
 
-1:	iii	a5, 0 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 1 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 2 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 3 * XCHAL_DCACHE_LINESIZE
-	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
-	bltu	a5, a6, 1b
+	isync
 
 	movi	a11, _reloc
 	jx	a11
@@ -226,28 +229,25 @@ _reloc:
 
 	/* jump to the kernel */
 2:
-
 #if XCHAL_DCACHE_IS_WRITEBACK
-	movi	a5, 0
-	movi	a6, XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS
-
-1:	diwb	a5, 0 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 1 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 2 * XCHAL_DCACHE_LINESIZE
-	diwb	a5, 3 * XCHAL_DCACHE_LINESIZE
-	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
-	bltu	a5, a6, 1b
+	movi    a5, 0
+	__loopi a5, a6, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	dii     a5, 0 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 1 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 2 * XCHAL_DCACHE_LINESIZE
+	dii     a5, 3 * XCHAL_DCACHE_LINESIZE
+	__endla a5, a6, XCHAL_DCACHE_LINESIZE * 4
 #endif
 
-	movi	a5, 0
-	movi	a6, XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS
+	movi    a5, 0
+	__loopi a5, a6, __ICACHE_WAYSIZE, XCHAL_ICACHE_LINESIZE * 4
+	iii     a5, 0 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 1 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 2 * XCHAL_ICACHE_LINESIZE
+	iii     a5, 3 * XCHAL_ICACHE_LINESIZE
+	__endla a5, a6, XCHAL_ICACHE_LINESIZE * 4
 
-1:	iii	a5, 0 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 1 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 2 * XCHAL_DCACHE_LINESIZE
-	iii	a5, 3 * XCHAL_DCACHE_LINESIZE
-	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
-	bltu	a5, a6, 1b
+	isync
 
 	movi	a5, __start
 	movi	a3, boot_initrd_start
Index: linux-2.6.10/arch/xtensa/kernel/align.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/align.S
+++ linux-2.6.10/arch/xtensa/kernel/align.S
@@ -16,14 +16,9 @@
  */
 
 #include <linux/linkage.h>
-#include <asm/ptrace.h>
-#include <asm/ptrace.h>
 #include <asm/current.h>
 #include <asm/offsets.h>
-#include <asm/pgtable.h>
 #include <asm/processor.h>
-#include <asm/page.h>
-#include <asm/thread_info.h>
 
 #if XCHAL_UNALIGNED_LOAD_EXCEPTION || XCHAL_UNALIGNED_STORE_EXCEPTION
 
@@ -216,7 +211,7 @@ ENTRY(fast_unaligned)
 
 	extui	a5, a4, INSN_OP0, 4	# get insn.op0 nibble
 
-#if XCHAL_HAVE_NARROW
+#if XCHAL_HAVE_DENSITY
 	_beqi	a5, OP0_L32I_N, .Lload	# L32I.N, jump
 	addi	a6, a5, -OP0_S32I_N
 	_beqz	a6, .Lstore		# S32I.N, do a store
@@ -251,7 +246,7 @@ ENTRY(fast_unaligned)
 #endif
 	__src_b	a3, a5, a6		# a3 has the data word
 
-#if XCHAL_HAVE_NARROW
+#if XCHAL_HAVE_DENSITY
 	addi	a7, a7, 2		# increment PC (assume 16-bit insn)
 
 	extui	a5, a4, INSN_OP0, 4
@@ -279,14 +274,14 @@ ENTRY(fast_unaligned)
 
 1:
 
-#if XCHAL_HAVE_LOOP
-	rsr	a3, LEND		# check if we reached LEND
-	bne	a7, a3, 1f
-	rsr	a3, LCOUNT		# and LCOUNT != 0
-	beqz	a3, 1f
-	addi	a3, a3, -1		# decrement LCOUNT and set
+#if XCHAL_HAVE_LOOPS
+	rsr	a5, LEND		# check if we reached LEND
+	bne	a7, a5, 1f
+	rsr	a5, LCOUNT		# and LCOUNT != 0
+	beqz	a5, 1f
+	addi	a5, a5, -1		# decrement LCOUNT and set
 	rsr	a7, LBEG		# set PC to LBEGIN
-	wsr	a3, LCOUNT
+	wsr	a5, LCOUNT
 #endif
 
 1:	wsr	a7, EPC_1		# skip load instruction
@@ -336,7 +331,7 @@ ENTRY(fast_unaligned)
 
 	movi	a6, 0			# mask: ffffffff:00000000
 
-#if XCHAL_HAVE_NARROW
+#if XCHAL_HAVE_DENSITY
 	addi	a7, a7, 2		# incr. PC,assume 16-bit instruction
 
 	extui	a5, a4, INSN_OP0, 4	# extract OP0
@@ -359,14 +354,14 @@ ENTRY(fast_unaligned)
 	/* Get memory address */
 
 1:
-#if XCHAL_HAVE_LOOP
-	rsr	a3, LEND		# check if we reached LEND
-	bne	a7, a3, 1f
-	rsr	a3, LCOUNT		# and LCOUNT != 0
-	beqz	a3, 1f
-	addi	a3, a3, -1		# decrement LCOUNT and set
+#if XCHAL_HAVE_LOOPS
+	rsr	a4, LEND		# check if we reached LEND
+	bne	a7, a4, 1f
+	rsr	a4, LCOUNT		# and LCOUNT != 0
+	beqz	a4, 1f
+	addi	a4, a4, -1		# decrement LCOUNT and set
 	rsr	a7, LBEG		# set PC to LBEGIN
-	wsr	a3, LCOUNT
+	wsr	a4, LCOUNT
 #endif
 
 1:	wsr	a7, EPC_1		# skip store instruction
@@ -416,6 +411,7 @@ ENTRY(fast_unaligned)
 
 	/* Restore working register */
 
+	l32i	a8, a2, PT_AREG8
 	l32i	a7, a2, PT_AREG7
 	l32i	a6, a2, PT_AREG6
 	l32i	a5, a2, PT_AREG5
Index: linux-2.6.10/arch/xtensa/kernel/coprocessor.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/coprocessor.S
+++ linux-2.6.10/arch/xtensa/kernel/coprocessor.S
@@ -91,7 +91,6 @@ ENTRY(enable_coprocessor)
 	rsync
 	retw
 
-#endif
 
 ENTRY(save_coprocessor_extra)
 	entry	sp, 16
@@ -198,4 +197,5 @@ _xtensa_reginfo_tables:
 	XCHAL_CP7_SA_CONTENTS_LIBDB
 	.word	0xFC000000	/* invalid register number,marks end of table*/
 _xtensa_reginfo_table_end:
+#endif
 
Index: linux-2.6.10/arch/xtensa/kernel/entry.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/entry.S
+++ linux-2.6.10/arch/xtensa/kernel/entry.S
@@ -26,6 +26,7 @@
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/signal.h>
+#include <asm/tlbflush.h>
 
 /* Unimplemented features. */
 
@@ -1596,10 +1597,11 @@ ENTRY(fast_second_level_miss)
 	l32i	a0, a1, TASK_MM		# tsk->mm
 	beqz	a0, 9f
 
-8:	rsr	a1, EXCVADDR		# fault address
-	_PGD_OFFSET(a0, a1, a1)
+	/* we deliberately destroy a3 (= exc-table) */
+
+8:	rsr	a3, EXCVADDR		# fault address
+	_PGD_OFFSET(a0, a3, a1)
 	l32i	a0, a0, 0		# read pmdval
-	//beqi	a0, _PAGE_USER, 2f
 	beqz	a0, 2f
 
 	/* Read ptevaddr and convert to top of page-table page.
@@ -1621,19 +1623,34 @@ ENTRY(fast_second_level_miss)
 	xor	a0, a0, a1
 
 
-	movi	a1, PAGE_DIRECTORY
+	movi	a1, _PAGE_DIRECTORY
 	or	a0, a0, a1		# ... | PAGE_DIRECTORY
 
+	/*
+	 * We utilize all three wired-ways (7-9) to hold pmd translations.
+	 * Memory reagions are mapped to the DTLBs according to bits 28 and 29.
+	 * This allows to map the three most common regions to three different
+	 * DTLBs:
+	 *  0,1	-> way 7	program (0040.0000), virtual (c000.0000)
+	 *  2	-> way 8	shared libraries (2000.0000)
+	 *  3	-> way 9	stack (3000.0000)
+	 */
+
+	extui	a3, a3, 28, 2		# addr bit 28,29	0, 1, 2, 3
 	rsr	a1, PTEVADDR
+	addx2	a3, a3, a3		# ->			0, 3, 6, 9
 	srli	a1, a1, PAGE_SHIFT
+	extui	a3, a3, 2, 2		# ->			0, 0, 1, 2
 	slli	a1, a1, PAGE_SHIFT	# ptevaddr & PAGE_MASK
-	addi	a1, a1, DTLB_WAY_PGTABLE	# ... + way_number
+	addi	a3, a3, DTLB_WAY_PGD
+	add	a1, a1, a3		# ... + way_number
 
 	wdtlb	a0, a1
 	dsync
 
 	/* Exit critical section. */
 
+	movi	a3, exc_table
 	movi	a0, 0
 	s32i	a0, a3, EXC_TABLE_FIXUP
 
@@ -1662,6 +1679,7 @@ ENTRY(fast_second_level_miss)
 
 2:	/* Invalid PGD, default exception handling */
 
+	movi	a3, exc_table
 	rsr	a1, DEPC
 	xsr	a3, EXCSAVE_1
 	s32i	a1, a2, PT_AREG2
@@ -1706,16 +1724,15 @@ ENTRY(fast_store_prohibited)
 8:	rsr	a1, EXCVADDR		# fault address
 	_PGD_OFFSET(a0, a1, a4)
 	l32i	a0, a0, 0
-	//beqi	a0, _PAGE_INVALID, 2f	## FIXME
 	beqz	a0, 2f
+
+	/* Note, we assume _WRITABLE is only set if pte is not invalid */
+
 	_PTE_OFFSET(a0, a1, a4)
 	l32i	a4, a0, 0		# read pteval
-	beqi	a4, _PAGE_INVALID, 2f	# invalid entry?
-	movi	a1, _PAGE_RW
-	//movi	a1, _PAGE_EXEC | _PAGE_WEN
-	bnall	a4, a1, 2f
+	bbci.l	a4, _PAGE_WRITABLE_BIT, 2f
 
-	movi	a1, _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_WEN
+	movi	a1, _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_HWWRITE
 	or	a4, a4, a1
 	rsr	a1, EXCVADDR
 	s32i	a4, a0, 0
@@ -1726,7 +1743,6 @@ ENTRY(fast_store_prohibited)
 #endif
 	pdtlb	a0, a1
 	beqz	a0, 1f
-	idtlb	a0		// FIXME do we need this?
 	wdtlb	a4, a0
 1:
 
@@ -2021,7 +2037,7 @@ ENTRY(_switch_to)
 
 	/* Disable ints while we manipulate the stack pointer; spill regs. */
 
-	movi	a5, PS_EXCM_MASK | LOCKLEVEL
+	movi	a5, (1 << PS_EXCM_SHIFT) | LOCKLEVEL
 	xsr	a5, PS
 	rsr	a3, EXCSAVE_1
 	rsync
Index: linux-2.6.10/arch/xtensa/kernel/head.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/head.S
+++ linux-2.6.10/arch/xtensa/kernel/head.S
@@ -15,10 +15,10 @@
  * Kevin Chea
  */
 
-#include <xtensa/cacheasm.h>
 #include <linux/config.h>
 #include <asm/processor.h>
 #include <asm/page.h>
+#include <asm/asmmacro.h>
 
 /*
  * This module contains the entry code for kernel images. It performs the
@@ -33,13 +33,6 @@
  *
  */
 
-	.macro	iterate	from, to , cmd
-		.ifeq	((\to - \from) & ~0xfff)
-			\cmd	\from
-			iterate "(\from+1)", \to, \cmd
-		.endif
-	.endm
-
 /*
  *  _start
  *
@@ -63,9 +56,9 @@ _start:	_j	2f
 	.align 4
 _startup:
 
-	/* Disable interrupts and exceptions. */
+	/* Disable interrupts. */
 
-	movi	a0, XCHAL_PS_EXCM_MASK
+	movi	a0, LOCKLEVEL 
 	wsr	a0, PS
 
 	/* Preserve the pointer to the boot parameter list in EXCSAVE_1 */
@@ -96,13 +89,9 @@ _startup:
 	wsr	a0, DBREAKC + \num
 	.endm
 
-        iterate 0, XCHAL_NUM_IBREAK-1, reset_dbreak
+        iterate 0, XCHAL_NUM_DBREAK-1, reset_dbreak
 #endif
 
-	/* Clear CCOUNT (not really necessary, but nice) */
-
-	wsr	a0, CCOUNT	# not really necessary, but nice
-
 	/* Disable zero-loops. */
 
 #if XCHAL_HAVE_LOOPS
@@ -118,7 +107,7 @@ _startup:
 
 	/* Interrupt initialization. */
 
-	movi	a2, XCHAL_INTTYPE_MASK_SOFTWARE | XCHAL_INTTYPE_MASK_EXTERN_EDGE
+	movi	a2, XCHAL_INTTYPE_MASK_SOFTWARE|XCHAL_INTTYPE_MASK_EXTERN_EDGE
 	wsr	a0, INTENABLE
 	wsr	a2, INTCLEAR
 
@@ -140,12 +129,49 @@ _startup:
 	rsync
 
 	/*  Initialize the caches.
-	 *  Does not include flushing writeback d-cache.
-	 *  a6, a7 are just working registers (clobbered).
+	 *  a2, a3 are just working registers (clobbered).
 	 */
 
-	icache_reset  a2, a3
-	dcache_reset  a2, a3
+#undef __DCACHE_WAYSIZE
+#define __DCACHE_WAYSIZE	(XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS)
+#undef __ICACHE_WAYSIZE
+#define __ICACHE_WAYSIZE	(XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS)
+
+#if XCHAL_DCACHE_LINE_LOCKABLE
+	movi	a2, 0
+	__loopi	a2, a3, XCHAL_DCACHE_SIZE, XCHAL_DCACHE_LINESIZE * 4
+	diu	a2, 0 * XCHAL_DCACHE_LINESIZE
+	diu	a2, 1 * XCHAL_DCACHE_LINESIZE
+	diu	a2, 2 * XCHAL_DCACHE_LINESIZE
+	diu	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+#endif
+	movi	a2, 0
+	__loopi	a2, a3, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	dii	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+#if XCHAL_ICACHE_LINE_LOCKABLE
+	movi	a2, 0
+	__loopi	a2, a3, XCHAL_ICACHE_SIZE, XCHAL_ICACHE_LINESIZE * 4
+	iiu	a2, 0 * XCHAL_ICACHE_LINESIZE
+	iiu	a2, 1 * XCHAL_ICACHE_LINESIZE
+	iiu	a2, 2 * XCHAL_ICACHE_LINESIZE
+	iiu	a2, 3 * XCHAL_ICACHE_LINESIZE
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE * 4
+#endif
+	movi	a2, 0
+	__loopi	a2, a3, __ICACHE_WAYSIZE, XCHAL_ICACHE_LINESIZE * 4
+	iii	a2, 0 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 1 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 2 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 3 * XCHAL_ICACHE_LINESIZE
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE * 4
+
+	isync
 
 	/* Unpack data sections
 	 *
@@ -182,9 +208,9 @@ _startup:
 	movi	a2, _bss_start	# start of BSS
 	movi	a3, _bss_end	# end of BSS
 
-1:	addi	a2, a2, 4
+	__loopt	a2, a4, a3, 2
 	s32i	a0, a2, 0
-	blt	a2, a3, 1b
+	__endla	a2, a4, 4
 
 #if XCHAL_DCACHE_IS_WRITEBACK
 
@@ -192,7 +218,13 @@ _startup:
 	 * instructions/data are available.
 	 */
 
-	dcache_writeback_all	a2, a3
+	movi	a2, 0
+	__loopi	a2, a3, XCHAL_DCACHE_SIZE, XCHAL_DCACHE_LINESIZE * 4
+	dhwb	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
 #endif
 
 	/* Setup stack and enable window exceptions (keep irqs disabled) */
@@ -204,7 +236,7 @@ _startup:
 	wsr	a2, PS			# (enable reg-windows; progmode stack)
 	rsync
 
-	/* Set up EXCSAVE[DEBUGLEVEL] to point to the Debug Exception Handler.*/
+	/*Set up EXCSAVE[DEBUGLEVEL] to point to the Debug Exception Handler.*/
 
 	movi	a2, debug_exception
 	wsr	a2, EXCSAVE + XCHAL_DEBUGLEVEL
Index: linux-2.6.10/arch/xtensa/kernel/pci-dma.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/pci-dma.c
+++ linux-2.6.10/arch/xtensa/kernel/pci-dma.c
@@ -29,28 +29,44 @@
  */
 
 void *
-dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, int gfp)
+dma_alloc_coherent(struct device *dev,size_t size,dma_addr_t *handle, int flag)
 {
-	void *ret;
+	unsigned long ret;
 
 	/* ignore region speicifiers */
-	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
 
-	if (dev == NULL || (*dev->dma_mask < 0xffffffff))
-		gfp |= GFP_DMA;
-	ret = (void *)__get_free_pages(gfp, get_order(size));
-
-	if (ret != NULL) {
-		memset(ret, 0, size);
-		*handle = virt_to_bus(ret);
+	flag &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	if (dev == NULL || (dev->coherent_dma_mask < 0xffffffff))
+		flag |= GFP_DMA;
+	ret = (unsigned long)__get_free_pages(flag, get_order(size));
+
+	if (ret == 0)
+		return NULL;
+
+	/* We currently don't support coherent memory outside KSEG */
+
+	if (ret < XCHAL_KSEG_CACHED_VADDR
+	    || ret >= XCHAL_KSEG_CACHED_VADDR + XCHAL_KSEG_SIZE)
+		BUG();
+
+	if (ret != 0) {
+		memset((void*)ret, 0, size);
+		*handle = virt_to_bus((void*)ret);
 	}
-	return (void*) BYPASS_ADDR((unsigned long)ret);
+
+	return (void*)(ret + XCHAL_KSEG_BYPASS_VADDR-XCHAL_KSEG_CACHED_VADDR);
 }
 
 void dma_free_coherent(struct device *hwdev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle)
 {
-	free_pages(CACHED_ADDR((unsigned long)vaddr), get_order(size));
+	long addr=(long)vaddr+XCHAL_KSEG_CACHED_VADDR-XCHAL_KSEG_BYPASS_VADDR;
+
+	if (addr < 0 || addr >= XCHAL_KSEG_SIZE)
+		BUG();
+
+	free_pages(addr, get_order(size));
 }
 
 
Index: linux-2.6.10/arch/xtensa/kernel/process.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/process.c
+++ linux-2.6.10/arch/xtensa/kernel/process.c
@@ -65,8 +65,8 @@ EXPORT_SYMBOL(init_task);
 
 struct task_struct *current_set[NR_CPUS] = {&init_task, };
 
-
-#if XCHAL_CP_NUM > 0
+#if XCHAL_HAVE_CP 
+# if XCHAL_CP_NUM > 0
 
 /*
  * Coprocessor ownership.
@@ -83,6 +83,7 @@ coprocessor_info_t coprocessor_info[] = 
 	{ 0, XTENSA_CPE_CP7_OFFSET },
 };
 
+# endif
 #endif
 
 /*
@@ -108,12 +109,16 @@ void cpu_idle(void)
 
 void exit_thread(void)
 {
+#if XCHAL_HAVE_CP
 	release_coprocessors(current);	/* Empty macro if no CPs are defined */
+#endif
 }
 
 void flush_thread(void)
 {
+#if XCHAL_HAVE_CP
 	release_coprocessors(current);	/* Empty macro if no CPs are defined */
+#endif
 }
 
 /*
@@ -231,7 +236,7 @@ unsigned long get_wchan(struct task_stru
  *
  */
 
-void do_copy_regs (xtensa_gregset_t *elfregs,struct pt_regs *regs,
+void do_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs,
 		   struct task_struct *tsk)
 {
 	int i, n, wb_offset;
@@ -249,7 +254,7 @@ void do_copy_regs (xtensa_gregset_t *elf
 	 */
 
 	elfregs->pc		= regs->pc;
-	elfregs->ps		= (regs->ps & ~XCHAL_PS_EXCM_MASK);
+	elfregs->ps		= (regs->ps & ~PS_EXCM_MASK);
 	elfregs->exccause	= regs->exccause;
 	elfregs->excvaddr	= regs->excvaddr;
 	elfregs->windowbase	= regs->windowbase;
@@ -270,7 +275,7 @@ void do_copy_regs (xtensa_gregset_t *elf
 	memset (elfregs->ar, 0, sizeof(elfregs->ar));
 
 	wb_offset = regs->windowbase * 4;
-	n = (regs->wmask&1)? 4 : (regs->wmask&2)? 8 : (regs->wmask&4)? 12 : 16;
+	n = (regs->wmask&2)? 4 : (regs->wmask&4)? 8 : (regs->wmask&8)? 12 : 16;
 
 	for (i = 0; i < n; i++)
 		elfregs->ar[(wb_offset + i) % XCHAL_NUM_AREGS] = regs->areg[i];
@@ -281,7 +286,10 @@ void do_copy_regs (xtensa_gregset_t *elf
 		elfregs->ar[(wb_offset + i) % XCHAL_NUM_AREGS] = regs->areg[i];
 }
 
-
+void xtensa_elf_core_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs)
+{
+	do_copy_regs ((xtensa_gregset_t *)elfregs, regs, current);
+}
 
 
 /* The inverse of do_copy_regs().  No error or sanity checking. */
@@ -290,13 +298,15 @@ void do_restore_regs (xtensa_gregset_t *
 		      struct task_struct *tsk)
 {
 	int i, n, wb_offset;
+	unsigned int wb, ws;
+	int nwin;
 
 	/* Note:  PS.EXCM is not set while user task is running; it
 	 * needs to be set in regs->ps is for exception handling convenience.
 	 */
 
 	regs->pc		= elfregs->pc;
-	regs->ps		= (elfregs->ps | XCHAL_PS_EXCM_MASK);
+	regs->ps		= (elfregs->ps | PS_EXCM_MASK);
 	regs->exccause		= elfregs->exccause;
 	regs->excvaddr		= elfregs->excvaddr;
 	regs->windowbase	= elfregs->windowbase;
@@ -311,18 +321,28 @@ void do_restore_regs (xtensa_gregset_t *
 
 	memset (regs->areg, 0, sizeof(regs->areg));
 
+	/* Generate wmask */
+
+	ws = regs->windowstart;
+	wb = regs->windowbase;
+
+	ws = ((ws >> wb) | (ws << (WSBITS - wb))) & ((1 << WSBITS) - 1);
+
+	nwin = ws != 1 ? WSBITS - __ffs(ws - 1) : 0;
+	regs->wmask = (ws & 0xf) | (nwin << 4);
+
 	/* Copy regs from live window frame. */
 
 	wb_offset = regs->windowbase * 4;
-	n = (regs->wmask&1)? 4 : (regs->wmask&2)? 8 : (regs->wmask&4)? 12 : 16;
+	n = (regs->wmask&2)? 4 : (regs->wmask&4)? 8 : (regs->wmask&8)? 12 : 16;
 
 	for (i = 0; i < n; i++)
-		regs->areg[(wb_offset+i) % XCHAL_NUM_AREGS] = elfregs->ar[i];
+		regs->areg[i] = elfregs->ar[(wb_offset+i) % XCHAL_NUM_AREGS];
 
 	n = (regs->wmask >> 4) * 4;
 
 	for (i = XCHAL_NUM_AREGS - n; n > 0; i++, n--)
-		regs->areg[(wb_offset+i) % XCHAL_NUM_AREGS] = elfregs->ar[i];
+		regs->areg[i] = elfregs->ar[(wb_offset+i) % XCHAL_NUM_AREGS];
 }
 
 /*
@@ -430,8 +450,9 @@ int  do_restore_fpregs (elf_fpregset_t *
 int
 dump_task_fpu(struct pt_regs *regs, struct task_struct *task, elf_fpregset_t *r)
 {
+#if XCHAL_HAVE_CP
 /* see asm/coprocessor.h for this magic number 16 */
-#if TOTAL_CPEXTRA_SIZE > 16
+#if XTENSA_CP_EXTRA_SIZE > 16
 	do_save_fpregs (r, regs, task);
 
 	/*  For now, bit 16 means some extra state may be present:  */
@@ -440,6 +461,8 @@ dump_task_fpu(struct pt_regs *regs, stru
 #else
 	return 0;	/* no coprocessors active on this processor */
 #endif
+#endif
+	return 0;
 }
 
 /*
Index: linux-2.6.10/arch/xtensa/kernel/ptrace.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/ptrace.c
+++ linux-2.6.10/arch/xtensa/kernel/ptrace.c
@@ -144,7 +144,7 @@ int xtensa_ptrace(long request, long pid
 			/* Note:  PS.EXCM is not set while user task is running;
 			 * its being set in regs is for exception handling
 			 * convenience.  */
-			tmp = (regs->ps & ~XCHAL_PS_EXCM_MASK);
+			tmp = (regs->ps & ~PS_EXCM_MASK);
 			break;
 		case REG_WB:
 			tmp = regs->windowbase;
Index: linux-2.6.10/arch/xtensa/kernel/setup.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/setup.c
+++ linux-2.6.10/arch/xtensa/kernel/setup.c
@@ -43,8 +43,6 @@
 #include <asm/page.h>
 #include <asm/setup.h>
 
-#include <xtensa/config/system.h>
-
 #if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)
 struct screen_info screen_info = { 0, 24, 0, 0, 0, 80, 0, 0, 0, 24, 1, 16};
 #endif
@@ -203,8 +201,8 @@ void __init init_arch(bp_tag_t *bp_start
 {
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	initrd_start = &__initrd_start;
-	initrd_end = &__initrd_end;
+	initrd_start = (void *)CONFIG_INITRD_START_ADDRESS;
+	initrd_end = (void *)CONFIG_INITRD_END_ADDRESS;
 #endif
 
 	sysmem.nr_banks = 0;
@@ -304,7 +302,7 @@ void __init setup_arch(char **cmdline_p)
 # endif
 #endif
 
-#if CONFIG_PCI
+#ifdef CONFIG_PCI
 	platform_pcibios_init();
 #endif
 }
@@ -325,6 +323,10 @@ void machine_power_off(void)
 	platform_power_off();
 	while (1);
 }
+
+void (*pm_power_off)(void) = machine_power_off;
+EXPORT_SYMBOL_GPL(pm_power_off);
+
 #ifdef CONFIG_PROC_FS
 
 /*
@@ -337,7 +339,7 @@ c_show(struct seq_file *f, void *slot)
 	/* high-level stuff */
 	seq_printf(f,"processor\t: 0\n"
 		     "vendor_id\t: Tensilica\n"
-		     "model\t\t: Xtensa " XCHAL_HW_RELEASE_NAME "\n"
+		     "model\t\t: Xtensa " XCHAL_HW_VERSION_NAME "\n"
 		     "core ID\t\t: " XCHAL_CORE_ID "\n"
 		     "build ID\t: 0x%x\n"
 		     "byte order\t: %s\n"
@@ -428,6 +430,7 @@ c_show(struct seq_file *f, void *slot)
 	seq_printf(f, "coprocessors\t: none\n");
 #endif
 
+#if 0
 	/* {I,D}{RAM,ROM} and XLMI */
 	seq_printf(f,"inst ROMs\t: %d\n"
 		     "inst RAMs\t: %d\n"
@@ -439,6 +442,7 @@ c_show(struct seq_file *f, void *slot)
 		     XCHAL_NUM_DROM,
 		     XCHAL_NUM_DRAM,
 		     XCHAL_NUM_XLMI);
+#endif
 
 	/* Cache */
 	seq_printf(f,"icache line size: %d\n"
@@ -468,6 +472,7 @@ c_show(struct seq_file *f, void *slot)
 		     XCHAL_DCACHE_SIZE);
 
 	/* MMU */
+#if 0
 	seq_printf(f,"ASID bits\t: %d\n"
 		     "ASID invalid\t: %d\n"
 		     "ASID kernel\t: %d\n"
@@ -484,6 +489,7 @@ c_show(struct seq_file *f, void *slot)
 		     XCHAL_ITLB_ARF_WAYS,
 		     XCHAL_DTLB_WAYS,
 		     XCHAL_DTLB_ARF_WAYS);
+#endif
 
 	return 0;
 }
Index: linux-2.6.10/arch/xtensa/kernel/signal.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/signal.c
+++ linux-2.6.10/arch/xtensa/kernel/signal.c
@@ -151,8 +151,8 @@ restore_sigcontext(struct pt_regs *regs,
 	 * handler, or the user mode value doesn't matter (e.g. PS.OWB).
 	 */
 	err |= __get_user(ps, &sc->sc_ps);
-	regs->ps = (regs->ps & ~XCHAL_PS_CALLINC_MASK)
-		| (ps & XCHAL_PS_CALLINC_MASK);
+	regs->ps = (regs->ps & ~PS_CALLINC_MASK)
+		| (ps & PS_CALLINC_MASK);
 
 	/* Additional corruption checks */
 
Index: linux-2.6.10/arch/xtensa/kernel/syscalls.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/syscalls.c
+++ linux-2.6.10/arch/xtensa/kernel/syscalls.c
@@ -26,6 +26,7 @@
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/mman.h>
+#include <linux/shm.h>
 
 typedef void (*syscall_t)(void);
 
@@ -82,4 +83,14 @@ out:
 	return error;
 }
 
+asmlinkage long xtensa_shmat(int shmid, char __user *shmaddr, int shmflg)
+{
+	unsigned long ret;
+	long err;
+
+	err = do_shmat(shmid, shmaddr, shmflg, &ret);
+	if (err)
+		return err;
+	return (long)ret;
+}
 
Index: linux-2.6.10/arch/xtensa/kernel/vectors.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/vectors.S
+++ linux-2.6.10/arch/xtensa/kernel/vectors.S
@@ -53,6 +53,7 @@
 #include <asm/thread_info.h>
 #include <asm/processor.h>
 
+#define WINDOW_VECTORS_SIZE	0x180
 
 /*
  * User exception vector. (Exceptions with PS.UM == 1, PS.EXCM == 0)
@@ -219,7 +220,7 @@ ENTRY(_DoubleExceptionVector)
 
 	movi	a3, XCHAL_WINDOW_VECTORS_VADDR
 	_bltu	a0, a3, .Lfixup
-	addi	a3, a3, 0x180		# WINDOW_VECTORS_SIZE
+	addi	a3, a3, WINDOW_VECTORS_SIZE
 	_bgeu	a0, a3, .Lfixup
 
 	/* Window overflow/underflow exception. Get stack pointer. */
@@ -245,7 +246,7 @@ ENTRY(_DoubleExceptionVector)
 
 	wsr	a2, DEPC		# save stack pointer temporarily
 	rsr	a0, PS
-	extui	a0, a0, XCHAL_PS_OWB_SHIFT, XCHAL_PS_OWB_BITS
+	extui	a0, a0, PS_OWB_SHIFT, 4
 	wsr	a0, WINDOWBASE
 	rsync
 
Index: linux-2.6.10/arch/xtensa/kernel/vmlinux.lds.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/vmlinux.lds.S
+++ linux-2.6.10/arch/xtensa/kernel/vmlinux.lds.S
@@ -17,19 +17,17 @@
 #include <asm-generic/vmlinux.lds.h>
 
 #include <linux/config.h>
-#define _NOCLANGUAGE
-#include <xtensa/config/core.h>
-#include <xtensa/config/system.h>
+#include <asm/cpu/config.h>
 OUTPUT_ARCH(xtensa)
 ENTRY(_start)
 
-#if XCHAL_MEMORY_ORDER == XTHAL_BIGENDIAN
+#if XCHAL_HAVE_BE
 jiffies = jiffies_64 + 4;
 #else
 jiffies = jiffies_64;
 #endif
 
-#define KERNELOFFSET 0x1000
+#define KERNELOFFSET 0xd0001000
 
 /* Note: In the following macros, it would be nice to specify only the
    vector name and section kind and construct "sym" and "section" using
@@ -76,7 +74,7 @@ jiffies = jiffies_64;
 
 SECTIONS
 {
-  . = XCHAL_KSEG_CACHED_VADDR + KERNELOFFSET;
+  . = KERNELOFFSET;
   /* .text section */
 
   _text = .;
@@ -160,7 +158,7 @@ SECTIONS
 
   /* Initialization code and data: */
 
-  . = ALIGN(1<<XCHAL_MMU_MIN_PTE_PAGE_SIZE);
+  . = ALIGN(1 << 12);
   __init_begin = .;
   .init.text : {
   	_sinittext = .;
@@ -230,32 +228,32 @@ SECTIONS
 		  .dummy)
   SECTION_VECTOR (_DebugInterruptVector_literal,
 		  .DebugInterruptVector.literal,
-		  XCHAL_INTLEVEL_VECTOR_VADDR(XCHAL_DEBUGLEVEL) - 4,
+		  XCHAL_DEBUG_VECTOR_VADDR - 4,
 		  SIZEOF(.WindowVectors.text),
 		  .WindowVectors.text)
   SECTION_VECTOR (_DebugInterruptVector_text,
 		  .DebugInterruptVector.text,
-		  XCHAL_INTLEVEL_VECTOR_VADDR(XCHAL_DEBUGLEVEL),
+		  XCHAL_DEBUG_VECTOR_VADDR,
 		  4,
 		  .DebugInterruptVector.literal)
   SECTION_VECTOR (_KernelExceptionVector_literal,
 		  .KernelExceptionVector.literal,
-		  XCHAL_KERNELEXC_VECTOR_VADDR - 4,
+		  XCHAL_KERNEL_VECTOR_VADDR - 4,
 		  SIZEOF(.DebugInterruptVector.text),
 		  .DebugInterruptVector.text)
   SECTION_VECTOR (_KernelExceptionVector_text,
 		  .KernelExceptionVector.text,
-		  XCHAL_KERNELEXC_VECTOR_VADDR,
+		  XCHAL_KERNEL_VECTOR_VADDR,
 		  4,
 		  .KernelExceptionVector.literal)
   SECTION_VECTOR (_UserExceptionVector_literal,
 		  .UserExceptionVector.literal,
-		  XCHAL_USEREXC_VECTOR_VADDR - 4,
+		  XCHAL_USER_VECTOR_VADDR - 4,
 		  SIZEOF(.KernelExceptionVector.text),
 		  .KernelExceptionVector.text)
   SECTION_VECTOR (_UserExceptionVector_text,
 		  .UserExceptionVector.text,
-		  XCHAL_USEREXC_VECTOR_VADDR,
+		  XCHAL_USER_VECTOR_VADDR,
 		  4,
 		  .UserExceptionVector.literal)
   SECTION_VECTOR (_DoubleExceptionVector_literal,
@@ -270,7 +268,7 @@ SECTIONS
 		  .DoubleExceptionVector.literal)
 
   . = (LOADADDR( .DoubleExceptionVector.text ) + SIZEOF( .DoubleExceptionVector.text ) + 3) & ~ 3;
-  . = ALIGN(1<<XCHAL_MMU_MIN_PTE_PAGE_SIZE);
+  . = ALIGN(1 << 12);
 
   __init_end = .;
 
Index: linux-2.6.10/arch/xtensa/lib/checksum.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/checksum.S
+++ linux-2.6.10/arch/xtensa/lib/checksum.S
@@ -14,10 +14,9 @@
  *		2 of the License, or (at your option) any later version.
  */
 
-#include <asm/errno.h>
 #include <linux/linkage.h>
-#define _ASMLANGUAGE
-#include <xtensa/config/core.h>
+#include <asm/errno.h>
+#include <asm/cpu/config.h>
 
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
Index: linux-2.6.10/arch/xtensa/lib/memcopy.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/memcopy.S
+++ linux-2.6.10/arch/xtensa/lib/memcopy.S
@@ -9,7 +9,7 @@
  * Copyright (C) 2002 - 2005 Tensilica Inc.
  */
 
-#include <xtensa/coreasm.h>
+#include <asm/cpu/config.h>
 
 	.macro	src_b	r, w0, w1
 #ifdef __XTENSA_EB__
Index: linux-2.6.10/arch/xtensa/lib/memset.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/memset.S
+++ linux-2.6.10/arch/xtensa/lib/memset.S
@@ -11,7 +11,7 @@
  *  Copyright (C) 2002 Tensilica Inc.
  */
 
-#include <xtensa/coreasm.h>
+#include <asm/cpu/config.h>
 
 /*
  * void *memset(void *dst, int c, size_t length)
Index: linux-2.6.10/arch/xtensa/lib/strncpy_user.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/strncpy_user.S
+++ linux-2.6.10/arch/xtensa/lib/strncpy_user.S
@@ -11,8 +11,8 @@
  *  Copyright (C) 2002 Tensilica Inc.
  */
 
-#include <xtensa/coreasm.h>
 #include <linux/errno.h>
+#include <asm/cpu/config.h>
 
 /* Load or store instructions that may cause exceptions use the EX macro. */
 
Index: linux-2.6.10/arch/xtensa/lib/strnlen_user.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/strnlen_user.S
+++ linux-2.6.10/arch/xtensa/lib/strnlen_user.S
@@ -11,7 +11,7 @@
  *  Copyright (C) 2002 Tensilica Inc.
  */
 
-#include <xtensa/coreasm.h>
+#include <asm/cpu/config.h>
 
 /* Load or store instructions that may cause exceptions use the EX macro. */
 
Index: linux-2.6.10/arch/xtensa/lib/usercopy.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/lib/usercopy.S
+++ linux-2.6.10/arch/xtensa/lib/usercopy.S
@@ -53,7 +53,7 @@
  *	a11/ original length
  */
 
-#include <xtensa/coreasm.h>
+#include <asm/cpu/config.h>
 
 #ifdef __XTENSA_EB__
 #define ALIGN(R, W0, W1) src	R, W0, W1
Index: linux-2.6.10/arch/xtensa/mm/fault.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/fault.c
+++ linux-2.6.10/arch/xtensa/mm/fault.c
@@ -26,7 +26,7 @@
 
 #define DEBUG_PAGE_FAULT 0
 
-unsigned long asid_cache = ASID_FIRST_VERSION;
+unsigned long asid_cache = ASID_USER_FIRST;
 void bad_page_fault(struct pt_regs*, unsigned long, int);
 
 /*
Index: linux-2.6.10/arch/xtensa/mm/init.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/init.c
+++ linux-2.6.10/arch/xtensa/mm/init.c
@@ -142,8 +142,8 @@ void __init bootmem_init(void)
 	if (min_low_pfn > max_pfn)
 		panic("No memory found!\n");
 
-	max_low_pfn = max_pfn < MAX_LOW_MEMORY >> PAGE_SHIFT ?
-		max_pfn : MAX_LOW_MEMORY >> PAGE_SHIFT;
+	max_low_pfn = max_pfn < MAX_MEM_PFN >> PAGE_SHIFT ?
+		max_pfn : MAX_MEM_PFN >> PAGE_SHIFT;
 
 	/* Find an area to use for the bootmem bitmap. */
 
@@ -216,7 +216,7 @@ void __init init_mmu (void)
 
 	/* Set rasid register to a known value. */
 
-	set_rasid_register (ASID_ALL_RESERVED);
+	set_rasid_register (ASID_USER_FIRST);
 
 	/* Set PTEVADDR special register to the start of the page
 	 * table, which is in kernel mappable space (ie. not
@@ -327,6 +327,7 @@ void show_mem(void)
 /* ------------------------------------------------------------------------- */
 
 #if (DCACHE_WAY_SIZE > PAGE_SIZE)
+
 /*
  * With cache aliasing, the page color of the page in kernel space and user
  * space might mismatch. We temporarily map the page to a different virtual
@@ -335,6 +336,7 @@ void show_mem(void)
 
 void clear_user_page(void *kaddr, unsigned long vaddr, struct page* page)
 {
+#if 0
 
   	/*  There shouldn't be any entries for this page. */
 
@@ -362,6 +364,7 @@ void clear_user_page(void *kaddr, unsign
 	/* We need to make sure that i$ and d$ are coherent. */
 
 	clear_bit(PG_cache_clean, &page->flags);
+#endif
 }
 
 /*
@@ -382,6 +385,7 @@ void clear_user_page(void *kaddr, unsign
 void copy_user_page(void* to, void* from, unsigned long vaddr,
     		    struct page* to_page)
 {
+#if 0
 	/* There shouldn't be any entries for the new page. */
 
 	__flush_invalidate_dcache_page_phys(__pa(page_address(to_page)));
@@ -413,6 +417,7 @@ void copy_user_page(void* to, void* from
 	/* We need to make sure that i$ and d$ are coherent. */
 
 	clear_bit(PG_cache_clean, &to_page->flags);
+#endif
 }
 
 
@@ -477,14 +482,14 @@ void flush_cache_page(struct vm_area_str
 
 pte_t* pte_alloc_one_kernel (struct mm_struct* mm, unsigned long addr)
 {
-	pte_t* pte = (pte_t*)__get_free_pages(GFP_KERNEL|__GFP_REPEAT, 0);
-	if (likely(pte)) {
-	       	pte_t* ptep = (pte_t*)(pte_val(*pte) + PAGE_OFFSET);
+	unsigned long page = __get_free_pages(GFP_KERNEL|__GFP_REPEAT, 0);
+	if (likely(page)) {
+		pte_t* ptep = (pte_t*)page;
 		int i;
 		for (i = 0; i < 1024; i++, ptep++)
 			pte_clear(ptep);
 	}
-	return pte;
+	return (pte_t*) page;
 }
 
 struct page* pte_alloc_one(struct mm_struct *mm, unsigned long addr)
@@ -524,20 +529,14 @@ update_mmu_cache(struct vm_area_struct *
 	if (!pfn_valid(pfn))
 		return;
 
-	page = pfn_to_page(pfn);
-
 	invalidate_itlb_mapping(addr);
 	invalidate_dtlb_mapping(addr);
 
-	/* We have a new mapping. Use it. */
-
-	write_dtlb_entry(pte, dtlb_probe(addr));
-
 	/* If the processor can execute from this page, synchronize D$/I$. */
 
 	if ((vma->vm_flags & VM_EXEC) != 0) {
 
-		write_itlb_entry(pte, itlb_probe(addr));
+	  page = pfn_to_page(pfn);
 
 		/* Synchronize caches, if not clean. */
 
Index: linux-2.6.10/arch/xtensa/mm/misc.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/misc.S
+++ linux-2.6.10/arch/xtensa/mm/misc.S
@@ -12,25 +12,26 @@
  * Chris Zankel	<chris@zankel.net>
  */
 
-/* Note: we might want to implement some of the loops as zero-overhead-loops,
- *	 where applicable and if supported by the processor.
- */
 
 #include <linux/linkage.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
+#include <asm/asmmacro.h>
 
-#include <xtensa/cacheasm.h>
-#include <xtensa/cacheattrasm.h>
+#define __DCACHE_WAYSIZE	(XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS)
+#define __ICACHE_WAYSIZE	(XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS)
 
-/* clear_page (page) */
+/*
+ * clear_page (unsigned long page)
+ *                    a2
+ */
 
 ENTRY(clear_page)
 	entry	a1, 16
-	addi	a4, a2, PAGE_SIZE
 	movi	a3, 0
 
-1:	s32i	a3, a2, 0
+	__loopi	a2, a4, PAGE_SIZE, 32
+	s32i	a3, a2, 0
 	s32i	a3, a2, 4
 	s32i	a3, a2, 8
 	s32i	a3, a2, 12
@@ -38,8 +39,7 @@ ENTRY(clear_page)
 	s32i	a3, a2, 20
 	s32i	a3, a2, 24
 	s32i	a3, a2, 28
-	addi	a2, a2, 32
-	blt	a2, a4, 1b
+	__endla	a2, a4, 32
 
 	retw
 
@@ -50,9 +50,9 @@ ENTRY(clear_page)
 
 ENTRY(copy_page)
 	entry	a1, 16
-	addi	a4, a2, PAGE_SIZE
 
-1:	l32i	a5, a3, 0
+	__loopi	a2, a4, PAGE_SIZE, 32
+	l32i	a5, a3, 0
 	l32i	a6, a3, 4
 	l32i	a7, a3, 8
 	s32i	a5, a2, 0
@@ -70,19 +70,34 @@ ENTRY(copy_page)
 	s32i	a6, a2, 28
 	addi	a2, a2, 32
 	addi	a3, a3, 32
-	blt	a2, a4, 1b
+	__endl	a2, a4
 
 	retw
 
-
 /*
  * void __flush_invalidate_cache_all(void)
  */
 
 ENTRY(__flush_invalidate_cache_all)
 	entry	sp, 16
-	dcache_writeback_inv_all a2, a3
-	icache_invalidate_all a2, a3
+
+	movi	a2, 0
+	__loopi	a2, a3, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	diwb	a2, 0 * XCHAL_DCACHE_LINESIZE
+	diwb	a2, 1 * XCHAL_DCACHE_LINESIZE
+	diwb	a2, 2 * XCHAL_DCACHE_LINESIZE
+	diwb	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	movi	a2, 0
+	__loopi	a2, a3, __ICACHE_WAYSIZE, XCHAL_ICACHE_LINESIZE * 4
+	iii	a2, 0 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 1 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 2 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 3 * XCHAL_ICACHE_LINESIZE
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE * 4
+
+	isync
 	retw
 
 /*
@@ -91,7 +106,16 @@ ENTRY(__flush_invalidate_cache_all)
 
 ENTRY(__invalidate_icache_all)
 	entry	sp, 16
-	icache_invalidate_all a2, a3
+
+	movi	a2, 0
+	__loopi	a2, a3, __ICACHE_WAYSIZE, XCHAL_ICACHE_LINESIZE * 4
+	iii	a2, 0 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 1 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 2 * XCHAL_ICACHE_LINESIZE
+	iii	a2, 3 * XCHAL_ICACHE_LINESIZE
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE * 4
+
+	isync
 	retw
 
 /*
@@ -100,49 +124,81 @@ ENTRY(__invalidate_icache_all)
 
 ENTRY(__flush_invalidate_dcache_all)
 	entry	sp, 16
-	dcache_writeback_inv_all a2, a3
-	retw
 
+	movi	a2, 0
+	__loopi	a2, a3, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	diwbi	a2, 0 * XCHAL_DCACHE_LINESIZE
+	diwbi	a2, 1 * XCHAL_DCACHE_LINESIZE
+	diwbi	a2, 2 * XCHAL_DCACHE_LINESIZE
+	diwbi	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	dsync
+	retw
 
 /*
- * void __flush_invalidate_cache_range(ulong start, ulong size)
+ * void __invalidate_dcache_all(void)
  */
 
-ENTRY(__flush_invalidate_cache_range)
+ENTRY(__invalidate_dcache_all)
 	entry	sp, 16
-	mov	a4, a2
-	mov	a5, a3
-	dcache_writeback_inv_region a4, a5, a6
-	icache_invalidate_region a2, a3, a4
+
+	movi	a2, 0
+	__loopi	a2, a3, __DCACHE_WAYSIZE, XCHAL_DCACHE_LINESIZE * 4
+	dii	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dii	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	dsync
 	retw
 
 /*
- * void __invalidate_icache_page(ulong start)
+ * void __flush_invalidate_cache_range(ulong start, ulong size)
  */
 
-ENTRY(__invalidate_icache_page)
+ENTRY(__flush_invalidate_cache_range)
 	entry	sp, 16
-	movi	a3, PAGE_SIZE
-	icache_invalidate_region a2, a3, a4
+
+	mov	a4, a2
+	__loops	a4, a3, a3, XCHAL_DCACHE_LINEWIDTH
+	dhwbi	a4, 0
+	__endla	a4, a3, XCHAL_DCACHE_LINESIZE
+
+	__loop	a3
+	ihi	a2, 0
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE
+
+	isync
 	retw
 
 /*
- * void __invalidate_dcache_page(ulong start)
+ * void __invalidate_icache_range(ulong start, ulong size)
  */
 
-ENTRY(__invalidate_dcache_page)
+ENTRY(__invalidate_icache_range)
 	entry	sp, 16
-	movi	a3, PAGE_SIZE
-	dcache_invalidate_region a2, a3, a4
+
+	__loops	a2, a3, a3, XCHAL_ICACHE_LINEWIDTH
+	ihi	a2, 0
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE
+
+	isync
 	retw
 
 /*
- * void __invalidate_icache_range(ulong start, ulong size)
+ * void __flush_invalidate_dcache_range(ulong start, ulong size)
  */
 
-ENTRY(__invalidate_icache_range)
+ENTRY(__flush_invalidate_dcache_range)
 	entry	sp, 16
-	icache_invalidate_region a2, a3, a4
+
+	__loops	a2, a3, a3, XCHAL_DCACHE_LINEWIDTH
+	dhwbi	a2, 0
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE
+
+	dsync
 	retw
 
 /*
@@ -151,45 +207,80 @@ ENTRY(__invalidate_icache_range)
 
 ENTRY(__invalidate_dcache_range)
 	entry	sp, 16
-	dcache_invalidate_region a2, a3, a4
+
+	__loops	a2, a3, a3, XCHAL_DCACHE_LINEWIDTH
+	dhi	a2, 0
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE
+
+	dsync
 	retw
 
 /*
- * void __flush_dcache_page(ulong start)
+ * void __invalidate_icache_page(ulong start)
  */
 
-ENTRY(__flush_dcache_page)
+ENTRY(__invalidate_icache_page)
 	entry	sp, 16
-	movi	a3, PAGE_SIZE
-	dcache_writeback_region a2, a3, a4
+
+	__loopi	a2, a3, PAGE_SIZE, XCHAL_ICACHE_LINESIZE * 4
+	ihi	a2, 0 * XCHAL_ICACHE_LINESIZE
+	ihi	a2, 1 * XCHAL_ICACHE_LINESIZE
+	ihi	a2, 2 * XCHAL_ICACHE_LINESIZE
+	ihi	a2, 3 * XCHAL_ICACHE_LINESIZE
+	__endla	a2, a3, XCHAL_ICACHE_LINESIZE * 4
+
+	isync
 	retw
 
 /*
- * void __flush_invalidate_dcache_page(ulong start)
+ * void __invalidate_dcache_page(ulong start)
  */
 
-ENTRY(__flush_invalidate_dcache_page)
+ENTRY(__invalidate_dcache_page)
 	entry	sp, 16
-	movi	a3, PAGE_SIZE
-	dcache_writeback_inv_region a2, a3, a4
+
+	__loopi	a2, a3, PAGE_SIZE, XCHAL_DCACHE_LINESIZE * 4
+	dhi	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dhi	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dhi	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dhi	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	dsync
 	retw
 
 /*
- * void __flush_invalidate_dcache_range(ulong start, ulong size)
+ * void __flush_invalidate_dcache_page(ulong start)
  */
 
-ENTRY(__flush_invalidate_dcache_range)
+ENTRY(__flush_invalidate_dcache_page)
 	entry	sp, 16
-	dcache_writeback_inv_region a2, a3, a4
+
+	__loopi	a2, a3, PAGE_SIZE, XCHAL_DCACHE_LINESIZE * 4
+	dhwbi	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dhwbi	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dhwbi	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dhwbi	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	dsync
 	retw
 
 /*
- * void __invalidate_dcache_all(void)
+ * void __flush_dcache_page(ulong start)
  */
 
-ENTRY(__invalidate_dcache_all)
+ENTRY(__flush_dcache_page)
 	entry	sp, 16
-	dcache_invalidate_all a2, a3
+
+	__loopi	a2, a3, PAGE_SIZE, XCHAL_DCACHE_LINESIZE * 4
+	dhwb	a2, 0 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 1 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 2 * XCHAL_DCACHE_LINESIZE
+	dhwb	a2, 3 * XCHAL_DCACHE_LINESIZE
+	__endla	a2, a3, XCHAL_DCACHE_LINESIZE * 4
+
+	dsync
 	retw
 
 /*
@@ -367,8 +458,3 @@ ENTRY(__invalidate_icache_page_index)
 
 #endif
 
-
-
-
-
-
Index: linux-2.6.10/arch/xtensa/mm/tlb.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/tlb.c
+++ linux-2.6.10/arch/xtensa/mm/tlb.c
@@ -26,8 +26,8 @@ static inline void __flush_itlb_all (voi
 {
 	int way, index;
 
-	for (way = 0; way < XCHAL_ITLB_ARF_WAYS; way++) {
-		for (index = 0; index < ITLB_ENTRIES_PER_ARF_WAY; index++) {
+	for (way = 0; way < ITLB_ARF_WAYS; way++) {
+		for (index = 0; index < (1 << XCHAL_ITLB_ARF_ENTRIES_LOG2); index++) {
 			int entry = way + (index << PAGE_SHIFT);
 			invalidate_itlb_entry_no_isync (entry);
 		}
@@ -39,8 +39,8 @@ static inline void __flush_dtlb_all (voi
 {
 	int way, index;
 
-	for (way = 0; way < XCHAL_DTLB_ARF_WAYS; way++) {
-		for (index = 0; index < DTLB_ENTRIES_PER_ARF_WAY; index++) {
+	for (way = 0; way < DTLB_ARF_WAYS; way++) {
+		for (index = 0; index < (1 << XCHAL_DTLB_ARF_ENTRIES_LOG2); index++) {
 			int entry = way + (index << PAGE_SHIFT);
 			invalidate_dtlb_entry_no_isync (entry);
 		}
@@ -70,14 +70,22 @@ void flush_tlb_mm(struct mm_struct *mm)
 	if (mm == current->active_mm) {
 		int flags;
 		local_save_flags(flags);
-		get_new_mmu_context(mm, asid_cache);
-		set_rasid_register(ASID_INSERT(mm->context));
+		__get_new_mmu_context(mm);
+		__load_mmu_context(mm);
 		local_irq_restore(flags);
 	}
 	else
 		mm->context = 0;
 }
 
+#define _ITLB_ENTRIES (ITLB_ARF_WAYS << XCHAL_ITLB_ARF_ENTRIES_LOG2)
+#define _DTLB_ENTRIES (DTLB_ARF_WAYS << XCHAL_DTLB_ARF_ENTRIES_LOG2)
+#if _ITLB_ENTRIES > _DTLB_ENTRIES
+# define _TLB_ENTRIES _ITLB_ENTRIES
+#else
+# define _TLB_ENTRIES _DTLB_ENTRIES
+#endif
+
 void flush_tlb_range (struct vm_area_struct *vma,
     		      unsigned long start, unsigned long end)
 {
@@ -93,7 +101,7 @@ void flush_tlb_range (struct vm_area_str
 #endif
 	local_save_flags(flags);
 
-	if (end-start + (PAGE_SIZE-1) <= SMALLEST_NTLB_ENTRIES << PAGE_SHIFT) {
+	if (end-start + (PAGE_SIZE-1) <= _TLB_ENTRIES << PAGE_SHIFT) {
 		int oldpid = get_rasid_register();
 		set_rasid_register (ASID_INSERT(mm->context));
 		start &= PAGE_MASK;
@@ -111,9 +119,7 @@ void flush_tlb_range (struct vm_area_str
 
 		set_rasid_register(oldpid);
 	} else {
-		get_new_mmu_context(mm, asid_cache);
-		if (mm == current->active_mm)
-			set_rasid_register(ASID_INSERT(mm->context));
+		flush_tlb_mm(mm);
 	}
 	local_irq_restore(flags);
 }
Index: linux-2.6.10/arch/xtensa/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/xtensa/Kconfig
+++ linux-2.6.10/arch/xtensa/Kconfig
@@ -242,6 +242,16 @@ source "fs/Kconfig"
 menu "Xtensa initrd options"
 	depends on BLK_DEV_INITRD
 
+	config INITRD_START_ADDRESS
+	 hex "initrd start address"
+	 depends on BLK_DEV_INITRD
+	 default "0xd4000000"
+                                                                                            
+	config INITRD_END_ADDRESS
+	 hex "initrd end address"
+	 depends on BLK_DEV_INITRD
+	 default "0xd4a00000"
+
 	config EMBEDDED_RAMDISK
 	bool "Embed root filesystem ramdisk into the kernel"
 
@@ -254,6 +264,7 @@ config EMBEDDED_RAMDISK_IMAGE
 	  kernel.  Relative pathnames are relative to arch/xtensa/boot/ramdisk/.
 	  The ramdisk image is not part of the kernel distribution; you must
 	  provide one yourself.
+
 endmenu
 
 source "arch/xtensa/Kconfig.debug"
Index: linux-2.6.10/mvl_patches/pro-1100.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1100.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1100);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

