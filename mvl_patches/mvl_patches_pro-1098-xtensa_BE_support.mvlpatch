#! /usr/bin/env bash
# Patch: -xtensa_BE_support
# Date: Fri Feb 16 17:18:25 2007
# Source: Chris Zankel (chris@zankel.net) and Manish Lachwani (mlachwani@mvista.com)
# Type: Defect Fix
# Disposition: MontaVista
# Signed-off-by: Manish Lachwani (mlachwani@mvista.com)
# Description:
# 
# Support for Xtensa in PRO 4.0.2 (Patagonia Tree):
# 
#  arch/xtensa/Kconfig                              |   17 
#  arch/xtensa/Makefile                             |    3 
#  arch/xtensa/boot/boot-redboot/bootstrap.S        |   56 +
#  arch/xtensa/kernel/asm-offsets.c                 |    7 
#  arch/xtensa/kernel/entry.S                       |  248 +++--
#  arch/xtensa/kernel/process.c                     |   88 +-
#  arch/xtensa/kernel/ptrace.c                      |   47 -
#  arch/xtensa/kernel/semaphore.c                   |    8 
#  arch/xtensa/kernel/signal.c                      |  242 -----
#  arch/xtensa/kernel/syscalls.c                    |  234 -----
#  arch/xtensa/kernel/time.c                        |    8 
#  arch/xtensa/kernel/traps.c                       |   69 -
#  arch/xtensa/kernel/vectors.S                     |    6 
#  arch/xtensa/kernel/xtensa_ksyms.c                |    8 
#  arch/xtensa/mm/fault.c                           |   28 
#  arch/xtensa/mm/init.c                            |    9 
#  arch/xtensa/platform-xt2000/Makefile             |   14 
#  arch/xtensa/platform-xt2000/i2c.c                |  242 +++++
#  arch/xtensa/platform-xt2000/pci.c                |  434 +++++++++
#  arch/xtensa/platform-xt2000/setup.c              |  112 ++
#  arch/xtensa/platform-xt2000/time.c               |   98 ++
#  drivers/input/serio/serio.c                      |    3 
#  drivers/net/Kconfig                              |    6 
#  drivers/net/Makefile                             |    1 
#  drivers/net/sonic.c                              |   10 
#  drivers/net/sonic.h                              |   27 
#  drivers/net/xt2000_sonic.c                       |  296 ++++++
#  include/asm-xtensa/bitops.h                      |   57 -
#  include/asm-xtensa/bug.h                         |    2 
#  include/asm-xtensa/cacheflush.h                  |    2 
#  include/asm-xtensa/checksum.h                    |   12 
#  include/asm-xtensa/kgdb.h                        |   26 
#  include/asm-xtensa/page.h                        |   28 
#  include/asm-xtensa/pgalloc.h                     |   14 
#  include/asm-xtensa/pgtable.h                     |   30 
#  include/asm-xtensa/platform-xt2000/hardware.h    |   35 
#  include/asm-xtensa/platform-xt2000/pci.h         |   86 +
#  include/asm-xtensa/platform-xt2000/pci_v320usc.h | 1008 +++++++++++++++++++++++
#  include/asm-xtensa/platform-xt2000/serial.h      |   47 +
#  include/asm-xtensa/platform-xt2000/system.h      |  198 ++++
#  include/asm-xtensa/platform-xt2000/xt2000-uart.h |  155 +++
#  include/asm-xtensa/platform-xt2000/xt2000.h      |  408 +++++++++
#  include/asm-xtensa/relay.h                       |    5 
#  include/asm-xtensa/resource.h                    |    4 
#  include/asm-xtensa/semaphore.h                   |   59 -
#  include/asm-xtensa/stat.h                        |   90 --
#  include/asm-xtensa/string.h                      |   19 
#  include/asm-xtensa/system.h                      |   15 
#  include/asm-xtensa/uaccess.h                     |    5 
#  include/asm-xtensa/unistd.h                      |   10 
#  kernel/kthread.c                                 |    2 
#  51 files changed, 3807 insertions(+), 831 deletions(-)
# 

PATCHNUM=1098
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Chris Zankel (chris@zankel.net) and Manish Lachwani (mlachwani@mvista.com)
Type: Defect Fix
Disposition: MontaVista
Signed-off-by: Manish Lachwani (mlachwani@mvista.com)
Description:

Support for Xtensa in PRO 4.0.2 (Patagonia Tree):

 arch/xtensa/Kconfig                              |   17 
 arch/xtensa/Makefile                             |    3 
 arch/xtensa/boot/boot-redboot/bootstrap.S        |   56 +
 arch/xtensa/kernel/asm-offsets.c                 |    7 
 arch/xtensa/kernel/entry.S                       |  248 +++--
 arch/xtensa/kernel/process.c                     |   88 +-
 arch/xtensa/kernel/ptrace.c                      |   47 -
 arch/xtensa/kernel/semaphore.c                   |    8 
 arch/xtensa/kernel/signal.c                      |  242 -----
 arch/xtensa/kernel/syscalls.c                    |  234 -----
 arch/xtensa/kernel/time.c                        |    8 
 arch/xtensa/kernel/traps.c                       |   69 -
 arch/xtensa/kernel/vectors.S                     |    6 
 arch/xtensa/kernel/xtensa_ksyms.c                |    8 
 arch/xtensa/mm/fault.c                           |   28 
 arch/xtensa/mm/init.c                            |    9 
 arch/xtensa/platform-xt2000/Makefile             |   14 
 arch/xtensa/platform-xt2000/i2c.c                |  242 +++++
 arch/xtensa/platform-xt2000/pci.c                |  434 +++++++++
 arch/xtensa/platform-xt2000/setup.c              |  112 ++
 arch/xtensa/platform-xt2000/time.c               |   98 ++
 drivers/input/serio/serio.c                      |    3 
 drivers/net/Kconfig                              |    6 
 drivers/net/Makefile                             |    1 
 drivers/net/sonic.c                              |   10 
 drivers/net/sonic.h                              |   27 
 drivers/net/xt2000_sonic.c                       |  296 ++++++
 include/asm-xtensa/bitops.h                      |   57 -
 include/asm-xtensa/bug.h                         |    2 
 include/asm-xtensa/cacheflush.h                  |    2 
 include/asm-xtensa/checksum.h                    |   12 
 include/asm-xtensa/kgdb.h                        |   26 
 include/asm-xtensa/page.h                        |   28 
 include/asm-xtensa/pgalloc.h                     |   14 
 include/asm-xtensa/pgtable.h                     |   30 
 include/asm-xtensa/platform-xt2000/hardware.h    |   35 
 include/asm-xtensa/platform-xt2000/pci.h         |   86 +
 include/asm-xtensa/platform-xt2000/pci_v320usc.h | 1008 +++++++++++++++++++++++
 include/asm-xtensa/platform-xt2000/serial.h      |   47 +
 include/asm-xtensa/platform-xt2000/system.h      |  198 ++++
 include/asm-xtensa/platform-xt2000/xt2000-uart.h |  155 +++
 include/asm-xtensa/platform-xt2000/xt2000.h      |  408 +++++++++
 include/asm-xtensa/relay.h                       |    5 
 include/asm-xtensa/resource.h                    |    4 
 include/asm-xtensa/semaphore.h                   |   59 -
 include/asm-xtensa/stat.h                        |   90 --
 include/asm-xtensa/string.h                      |   19 
 include/asm-xtensa/system.h                      |   15 
 include/asm-xtensa/uaccess.h                     |    5 
 include/asm-xtensa/unistd.h                      |   10 
 kernel/kthread.c                                 |    2 
 mvl_patches/pro-1098.c                           |   16 
 52 files changed, 3823 insertions(+), 831 deletions(-)

Index: linux-2.6.10/arch/xtensa/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/xtensa/Kconfig
+++ linux-2.6.10/arch/xtensa/Kconfig
@@ -22,9 +22,17 @@ config UID16
 	bool
 	default n
 
+config RWSEM_GENERIC_SPINLOCK
+        bool
+        default y
+                                                                                                         
 config RWSEM_XCHGADD_ALGORITHM
-	bool
-	default y
+        bool
+        depends on !RWSEM_GENERIC_SPINLOCK && !PREEMPT_RT
+                                                                                                         
+config ASM_SEMAPHORES
+        bool
+        default y
 
 config HAVE_DEC_LOCK
 	bool
@@ -132,7 +140,7 @@ config XTENSA_CPU_CLOCK
 config GENERIC_CALIBRATE_DELAY
 	bool "Auto calibration of the BogoMIPS value"
 	---help---
-	The BogoMIPS value can easily be derived from the CPU frequency.
+	The BogoMIPS value can easily derived from the CPU frequency.
 
 config CMDLINE_BOOL
 	bool "Default bootloader kernel arguments"
@@ -158,9 +166,8 @@ config XTENSA_ISS_NETWORK
 	depends on XTENSA_PLATFORM_ISS
 	default y
 
-endmenu
 
-source "mm/Kconfig
+endmenu
 
 menu "Bus options"
 
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/pci.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/pci.h
@@ -0,0 +1,86 @@
+/*
+ * include/asm-xtensa/platform-xt2000/pci.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Tensilica Inc.
+ */
+
+/*
+ * This file defines the aperture windows for the V3 device.
+ */
+
+#ifndef _XTENSA_XT2000_PCI_H
+#define _XTENSA_XT2000_PCI_H
+
+#include <asm/platform/xt2000.h>
+
+#define PCI_V320_BASE	XTBOARD_V3PCI_VADDR
+
+/* 
+ * PCI -> Local Memory
+ */
+
+#define PCI_LOCAL_MEM_CPU_BASE	0
+#define PCI_LOCAL_MEM_PCI_BASE	0
+#define PCI_LOCAL_MEM_SIZE	XTBOARD_MEMORY_SIZE
+#define PCI_LOCAL_MEM_MAP_REG	\
+	(PCI_MEM_PCI_RD_MB_00 |	\
+	PCI_MEM_PCI_WR_MB_00 |	\
+	PCI_MEM_MAP_REG_EN |	\
+	PCI_MEM_MAP_ENABLE)
+
+	 /* PCI_MEM_BYTE_SWAP_8 | \ */
+	/* XTFIXME: need something like XTBOARD_MEMORY_SIZE_LOG2 */
+
+/*
+ * CPU -> PCI Memory space
+ */
+
+#define PCI_MEM_SPACE_CPU_BASE	XTBOARD_PCI_MEM_VADDR
+#define PCI_MEM_SPACE_PCI_BASE	XTBOARD_PCI_MEM_VADDR
+#define PCI_MEM_SPACE_SIZE	XTBOARD_PCI_MEM_SIZE
+#define PCI_MEM_SPACE_SWAP	0		// FIXME: do we need to bswap?
+#define PCI_MEM_SPACE_BASE_REG_DEFAULT	\
+	(PCI_MEM_SPACE_CPU_BASE | 	\
+	(PCI_MEM_SPACE_PCI_BASE >> 8) | \
+	LB_PCI_BASEX_SIZE_128MB |	\
+	LB_PCI_BASEX_MEMORY | 		\
+	PCI_MEM_SPACE_SWAP)
+
+
+/*
+ * CPU -> PCI IO space
+ */
+
+#define PCI_IO_SPACE_CPU_BASE	XTBOARD_PCI_IO_VADDR
+#define PCI_IO_SPACE_PCI_BASE	0
+#define PCI_IO_SPACE_SIZE	XTBOARD_PCI_IO_SIZE
+#define PCI_IO_SPACE_SWAP	0		// FIXME: do we need to bswap?
+#define PCI_IO_SPACE_BASE_REG_DEFAULT	\
+	(PCI_IO_SPACE_CPU_BASE |	\
+	(PCI_IO_SPACE_PCI_BASE >> 8) |	\
+	LB_PCI_BASEX_IO |		\
+	PCI_IO_SPACE_SWAP |		\
+	LB_PCI_BASEX_SIZE_16MB |	\
+	LB_PCI_BASEX_ERR_EN)
+
+/*
+ * CPU -> PCI Config space
+ */
+
+#define PCI_CFG_SPACE_CPU_BASE	XTBOARD_PCI_IO_VADDR
+#define PCI_CFG_SPACE_PCI_BASE	0
+#define PCI_CFG_SPACE_SIZE	XTBOARD_PCI_IO_SIZE
+#define PCI_CFG_SPACE_SWAP	0		// FIXME: do we need to bswap?
+#define PCI_CFG_SPACE_BASE_REG_DEFAULT	\
+	(PCI_CFG_SPACE_CPU_BASE |	\
+	PCI_CFG_SPACE_SWAP |		\
+	LB_PCI_BASEX_CONFIG |		\
+	LB_PCI_BASEX_SIZE_16MB)
+
+//	LB_PCI_BASEX_ERR_EN
+
+#endif /* _XTENSA_XT2000_H */
Index: linux-2.6.10/include/asm-xtensa/resource.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/resource.h
+++ linux-2.6.10/include/asm-xtensa/resource.h
@@ -26,12 +26,10 @@
 #define RLIMIT_AS 9			/* mapped memory */
 #define RLIMIT_LOCKS	10		/* maximum file locks held */
 
-#define RLIM_NLIMITS 11			/* Number of limit flavors.  */
+#define RLIM_NLIMITS 		11      /* Number of limit flavors.  */
 #define RLIMIT_SIGPENDING	11	/* max number of pending signals */
 #define RLIMIT_MSGQUEUE		12	/* maximum bytes in POSIX mqueues */
 
-#define RLIM_NLIMITS		13
-
 /*
  * SuS says limits have to be unsigned.
  * Which makes a ton more sense anyway.
Index: linux-2.6.10/include/asm-xtensa/semaphore.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/semaphore.h
+++ linux-2.6.10/include/asm-xtensa/semaphore.h
@@ -16,7 +16,9 @@
 #include <linux/wait.h>
 #include <linux/rwsem.h>
 
-struct semaphore {
+# define compat_semaphore semaphore
+
+struct compat_semaphore {
 	atomic_t count;
 	int sleepers;
 	wait_queue_head_t wait;
@@ -32,25 +34,25 @@ struct semaphore {
 # define __SEM_DEBUG_INIT(name)
 #endif
 
-#define __SEMAPHORE_INITIALIZER(name,count)			\
+#define __COMPAT_SEMAPHORE_INITIALIZER(name,count)		\
 	{ ATOMIC_INIT(count), 					\
 	  0,							\
 	  __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)		\
 	__SEM_DEBUG_INIT(name) }
 
-#define __MUTEX_INITIALIZER(name) \
-	__SEMAPHORE_INITIALIZER(name, 1)
-
-#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
-	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+#define __COMPAT_MUTEX_INITIALIZER(name) \
+	__COMPAT_SEMAPHORE_INITIALIZER(name, 1)
 
-#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
-#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+#define __COMPAT_DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct compat_semaphore name = __COMPAT_SEMAPHORE_INITIALIZER(name,count)
+   
+#define COMPAT_DECLARE_MUTEX(name) __COMPAT_DECLARE_SEMAPHORE_GENERIC(name,1)
+#define COMPAT_DECLARE_MUTEX_LOCKED(name) __COMPAT_DECLARE_SEMAPHORE_GENERIC(name,0)
 
-static inline void sema_init (struct semaphore *sem, int val)
+static inline void compat_sema_init (struct compat_semaphore *sem, int val)
 {
 /*
- *	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
+ *    *sem = (struct compat_semaphore)__COMPAT_SEMAPHORE_INITIALIZER((*sem),val);
  *
  * i'd rather use the more flexible initialization above, but sadly
  * GCC 2.7.2.3 emits a bogus warning. EGCS doesnt. Oh well.
@@ -62,34 +64,34 @@ static inline void sema_init (struct sem
 #endif
 }
 
-static inline void init_MUTEX (struct semaphore *sem)
+static inline void compat_init_MUTEX (struct compat_semaphore *sem)
 {
-	sema_init(sem, 1);
+	compat_sema_init(sem, 1);
 }
 
-static inline void init_MUTEX_LOCKED (struct semaphore *sem)
+static inline void compat_init_MUTEX_LOCKED (struct compat_semaphore *sem)
 {
-	sema_init(sem, 0);
+	compat_sema_init(sem, 0);
 }
 
-asmlinkage void __down(struct semaphore * sem);
-asmlinkage int  __down_interruptible(struct semaphore * sem);
-asmlinkage int  __down_trylock(struct semaphore * sem);
-asmlinkage void __up(struct semaphore * sem);
+asmlinkage void __compat_down(struct compat_semaphore * sem);
+asmlinkage int  __compat_down_interruptible(struct compat_semaphore * sem);
+asmlinkage int  __compat_down_trylock(struct compat_semaphore * sem);
+asmlinkage void __compat_up(struct compat_semaphore * sem);
 
 extern spinlock_t semaphore_wake_lock;
 
-static inline void down(struct semaphore * sem)
+static inline void compat_down(struct semaphore * sem)
 {
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
 	if (atomic_sub_return(1, &sem->count) < 0)
-		__down(sem);
+		__compat_down(sem);
 }
 
-static inline int down_interruptible(struct semaphore * sem)
+static inline int compat_down_interruptible(struct semaphore * sem)
 {
 	int ret = 0;
 #if WAITQUEUE_DEBUG
@@ -97,11 +99,11 @@ static inline int down_interruptible(str
 #endif
 
 	if (atomic_sub_return(1, &sem->count) < 0)
-		ret = __down_interruptible(sem);
+		ret = __compat_down_interruptible(sem);
 	return ret;
 }
 
-static inline int down_trylock(struct semaphore * sem)
+static inline int compat_down_trylock(struct semaphore * sem)
 {
 	int ret = 0;
 #if WAITQUEUE_DEBUG
@@ -109,7 +111,7 @@ static inline int down_trylock(struct se
 #endif
 
 	if (atomic_sub_return(1, &sem->count) < 0)
-		ret = __down_trylock(sem);
+		ret = __compat_down_trylock(sem);
 	return ret;
 }
 
@@ -117,13 +119,16 @@ static inline int down_trylock(struct se
  * Note! This is subtle. We jump to wake people up only if
  * the semaphore was negative (== somebody was waiting on it).
  */
-static inline void up(struct semaphore * sem)
+static inline void compat_up(struct semaphore * sem)
 {
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 	if (atomic_add_return(1, &sem->count) <= 0)
-		__up(sem);
+		__compat_up(sem);
 }
 
+extern int compat_sem_is_locked(struct compat_semaphore *sem);
+#define compat_sema_count(sem) atomic_read(&(sem)->count)
+
 #endif /* _XTENSA_SEMAPHORE_H */
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/pci_v320usc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/pci_v320usc.h
@@ -0,0 +1,1008 @@
+/*********************************************************************
+ **
+ * Module: V3USCDRV
+ **
+ * File Name: v3uscreg.h
+ **
+ * Authors: Phil Sikora, Jan Skibinski, Vadim Monshinsky, Dan Aizenstros
+ **
+ * Copyright (c) 1997-1999 V3 Semiconductor. All rights reserved.
+ *
+ * V3 Semiconductor makes no warranties for the use of its products.	V3 does
+ * not assume any liability for errors which may appear in these files or
+ * documents, however, we will attempt to notify customers of such errors.
+ *
+ * V3 Semiconductor retains the right to make changes to components,
+ * documentation or specifications without notice.
+ *
+ * Please verify with V3 Semiconductor to be sure you have the latest
+ * specifications before finalizing a design.
+ **
+ * $Revision: 1.1.1.1 $	$Date: 2002/08/28 16:11:31 $
+ * $NoKeywords: $
+ **
+ * Description:
+ **
+ * This is the header file for the registers in V3 USC family of devices.
+ * There are two basic approaches to accessing registers, one approach
+ * has a known base address of the registers to which an offset is added,
+ * for each access.
+ * The second approach is to map a data structure matching the registers
+ * to the physical device.  Writing and reading values from this data
+ * structure has the effect of accessing the physical device's registers.
+ * For convenience both methods are supported from this include file.
+ *
+ * Equates in this file are for the most recent stepping of the PCI
+ * bridge devices, check the data sheets for older steppings.
+ **
+ * This include file CAN support three basic modes each of which may
+ * have a little and big endian offset and/or data structures.
+ * Check the _V3USCREG_H_MODE_XX_ defines determine exactly what is
+ * currently supported.
+ **
+ * Added support for MIPS assembler, which can not handle enum statements
+ * or structure definitions. 
+ * Support for PMON defines that use pointers, se below table for details
+ * of each mode supported by this include file.
+ * A separate define enables the little endian data structures when
+ * needed.
+ **
+ ********************************************************************/
+
+#ifndef _V3USCREG_H_
+#define _V3USCREG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define V3USCREG_VER 200
+#define V3USCREG_VER_STR "V3 Semiconductor (c) 1997-1999 V3USCREG Version 2.00"
+
+/*********************************************************************
+ *
+ * This section is the base address and offset definition approach
+ *
+ ********************************************************************/
+
+/*
+ * PCI Configuration registers bit definitions
+ *
+ * For those bit fields larger than one bit a _MASK definition is provide
+ * to isolate the value. As well a _SHIFT definition is provide to
+ * convert the value to and from its register position and a number
+ *
+ * The table describes how Register names and their width will be encoded.
+ * The DMA_LENGTHX register is a special case since it is 24 bits wide and
+ * must be accessed as a 32 bit or 16 and 8 bit quantity or 16 bits with CSR.
+ *
+ * |--------------------------------------|
+ * | Register Name | Suffix       | Width |
+ * |--------------------------------------|
+ * | LB_IMASK      | LB_IMASK_B   | 8     |
+ * |--------------------------------------|
+ * | PCI_VENDOR    | PCI_VENDOR_W | 16    |
+ * |--------------------------------------|
+ * | PCI_CC_REV    | PCI_CC_REV   | 32    |
+ * |--------------------------------------|
+ * | DMA_LENGHTX   | DMA_LENGHTX  | 24    |
+ * |--------------------------------------|
+ */
+
+/*
+ * Selection of which #defines to select can be determined from
+ * the following table:
+ **
+ * #define _V3USCREG_H_CL_
+ * - little endian register offsets
+ * - USC base address plus register offset mode
+ *   Note: The register equate is both base and offset, creating a
+ *   pointer to the register in memory. (No function call)
+ * Must call the v3uscreg_init_base() function to initialize the base
+ * address of USC variable defined in this include file. 
+ ** 
+ * #define _V3USCREG_H_CB_ 
+ * - big endian register offsets
+ * - USC base address plus register offset mode
+ *   Note: The register equate is both base and offset, creating a
+ *   pointer to the register in memory. (No function call)
+ * Must call the v3uscreg_init_base() function to initialize the base
+ * address of USC variable defined in this include file. 
+ */  
+
+/* Mode A - Little Endian */
+#ifdef _V3USCREG_H_AL_
+
+#define V3REGW(x)		(x)
+#define V3REGH(x)		(x)
+#define V3REGB(x)		(x)
+#endif
+
+/* Mode A - Big Endian */
+#ifdef _V3USCREG_H_AB_
+
+#define V3REGW(x)		(x)
+#define V3REGH(x)		((x)^2)
+#define V3REGB(x)		((x)^3)
+#endif
+
+/* Mode B - Little Endian */
+#ifdef _V3USCREG_H_BL_
+
+#define V3REGW(x)		(x)
+#define V3REGH(x)		(x)
+#define V3REGB(x)		(x)
+#endif
+
+/* Mode B - Big Endian */
+#ifdef _V3USCREG_H_BB_
+
+#define V3REGW(x)		(x)
+#define V3REGH(x)		((x)^2)
+#define V3REGB(x)		((x)^3)
+#endif
+
+
+/* Mode C - Little Endian */
+#ifdef _V3USCREG_H_CL_
+
+/* To use this mode the v3uscreg_init_base() function must be */
+/* called with the non-cached address of the V320USC internal registers */
+
+extern char *_v3uscp;
+
+#define V3REGW(x)		*(volatile unsigned long *)(_v3uscp + (x))
+#define V3REGH(x)		*(volatile unsigned short *)(_v3uscp + (x))
+#define V3REGB(x)		*(volatile unsigned char *)(_v3uscp + (x)) 	
+#endif
+
+/* Mode C - Big Endian */
+#ifdef _V3USCREG_H_CB_
+
+/* To use this mode the v3uscreg_init_base() function must be */
+/* called with the non-cached address of the V320USC internal registers */
+
+extern char *_v3uscp;
+
+#define V3REGW(x)		*(volatile unsigned long *)(_v3uscp + (x))
+#define V3REGH(x)		*(volatile unsigned short *)(_v3uscp + ((x)^2))
+#define V3REGB(x)		*(volatile unsigned char *)(_v3uscp + ((x)^3))
+#endif
+ 
+/*
+ * PCI Vendor ID
+ * - Offset 00h, Size 16 bits
+ */
+
+/*
+ * PCI Device ID
+ * - Offset 02h, Size 16 bits
+ */
+
+/*
+ * PCI Command Register
+ * - Offset 04h, Size 16 bits
+ */
+#define PCI_CMD_W_IO_EN				0x0001		/* I/O access */
+#define PCI_CMD_W_MEM_EN			0x0002		/* Memory access */
+#define PCI_CMD_W_MASTER_EN			0x0004		/* PCI Master */
+#define PCI_CMD_W_MWI_EN			0x0010		/* Memory Write and */
+									/* Invalidate enable            */
+#define PCI_CMD_W_PAR_EN			0x0040		/* Parity error */
+#define PCI_CMD_W_SERR_EN			0x0100		/* System error */
+									/* If PAR_EN is enabled then SERR is  */
+									/* driven in response to parity error */
+#define PCI_CMD_W_FBB_EN			0x0200		/* Fast back to back */
+									/* transfers when Bus Master     */
+
+/*
+ * PCI Status Register
+ * - Offset 06h, Size 16 bits
+ */
+#define PCI_STAT_W_NEW_CAP			0x0010		/* New Capabilites          */
+#define PCI_STAT_W_UDF				0x0040		/* User Defined Feature     */
+#define PCI_STAT_W_FAST_BACK		0x0008		/* Fast Back to Back Target */
+									/* - Used to indicate ability of this   */
+									/* device to other Bus Masters          */
+#define PCI_STAT_W_PAR_REP			0x0010		/* Data Parity Report when    */
+									/* USC is a Bus Master and PERR is driven */
+#define PCI_STAT_W_DEVSEL_MASK		0x03		/* 10-9 Bits Device Select */
+									/* Timing                              */
+#define PCI_STAT_W_DEVSEL_SHIFT	9
+
+#define PCI_STAT_W_T_ABORT			0x1000		/* Target Abort - set in */
+									/* response to a target abort detected */
+									/* while USC was a Bus Master          */
+#define PCI_STAT_W_M_ABORT			0x2000		/* Master Abort - set in   */
+									/* response to a master abort detected */
+									/* while USC was a Bus Master          */
+#define PCI_STAT_W_SYS_ERR			0x4000		/* System Error - set in */
+									/* response to a system error on the */
+									/* SERR pin                          */
+#define PCI_STAT_W_PAR_ERR			0x8000		/* Parity Error - set in */
+									/* response to a parity error on the */
+									/* PCI bus                           */
+
+/*
+ * PCI Class and Revision Register
+ * - Offset 08h, Size 32 bits
+ */
+#define PCI_CC_REV_VREV_MASK		0x0f		/* 3-0 Bits Stepping ID  */
+									/* Rev A = 0,Rev B0 = 1, Rev B1 = 2, */
+									/* Rev B2 = 3 */
+#define PCI_CC_REV_VREV_SHIFT		0
+
+#define PCI_CC_REV_UREV_MASK		0x0f		/* 7-4 Bits User Revision ID */
+									/* user definable for system revisions   */
+#define PCI_CC_REV_UREV_SHIFT		4
+
+#define PCI_CC_REV_PROG_IF_MASK		0x0ff	/* 15-8 Bits PCI Programming */
+									/* Interface code                        */
+#define PCI_CC_REV_PROG_IF_SHIFT	8
+
+#define PCI_CC_REV_SUB_CLASS_MASK	0x0ff	/* 23-16 Bits PCI Sub Class */
+#define PCI_CC_REV_SUB_CLASS_SHIFT	16
+
+#define PCI_CC_REV_BASE_CLASS_MASK	0x0ff	/* 32-24 Bits PCI Base Class */
+#define PCI_CC_REV_BASE_CLASS_SHIFT 24
+
+/*
+ * PCI Header and Configuration Register
+ * - Offset 0ch, Size 32 bits
+ */
+
+/* see pcivar.h */
+
+/*
+ * PCI Access to local memory map access
+ * - Offset 10h, Size 32 bits (I2O mode)
+ */
+#define PCI_I2O_BASE_IO				0x00000001	/* I/O 1 - I/O space */
+									/* 0 - Memory Space              */
+#define PCI_I2O_BASE_TYPE_MASK		0x03		/* 2-1 Bits Address range */
+									/* type                               */
+#define PCI_I2O_BASE_TYPE_SHIFT		1			/* 0 - device can be mapped */
+									/* any where in a 32 bit address space  */
+#define PCI_I2O_BASE_PREFETCH		0x00000008	/* Prefetchable - no effect */
+#define PCI_I2O_BASE_ADR_BASE_MASK	0x0fff	/* 31-20 Bits Base address */
+									/* of ATU                              */
+#define PCI_I2O_BASE_ADR_BASE_SHIFT	20
+
+/*
+ * PCI Access to local memory map access
+ * - Offset 14h, Size 32 bits
+ */
+#define PCI_MEM_BASE_IO				0x00000001	/* I/O 1 - I/O space */
+									/* 0 - Memory Space              */
+#define PCI_MEM_BASE_TYPE_MASK		0x03	/* 2-1 Bits Address range */
+									/* type                               */
+#define PCI_MEM_BASE_TYPE_SHIFT		1			/* 0 - device can be mapped */
+									/* any where in a 32 bit address space  */
+#define PCI_MEM_BASE_PREFETCH		0x00000008	/* Prefetchable - no effect */
+#define PCI_MEM_BASE_ADR_BASE_MASK	0x0fff	/* 31-20 Bits Base address */
+									/* of ATU                              */
+#define PCI_MEM_BASE_ADR_BASE_SHIFT	20
+
+/*
+ * PCI Access to Internal USC Register
+ * - Offset 18h, Size 32 bits
+ */
+#define PCI_REG_BASE_IO				0x00000001	/* I/O 1 - I/O space */
+									/* 0 - Memory Space              */
+#define PCI_REG_BASE_TYPE_MASK		0x03	/* 2-1 Bits Address range */
+									/* type                               */
+#define PCI_REG_BASE_TYPE_SHIFT		1			/* 0 - device can be mapped */
+									/* any where in a 32 bit address space  */
+#define PCI_REG_BASE_PREFETCH		0x00000008	/* Prefetchable - no effect */
+#define PCI_REG_BASE_ADR_BASE_MASK	0x07fffff	/* 31-20 Bits Base address */
+									/* of USC registers                    */
+#define PCI_REG_BASE_ADR_BASE_SHIFT	9
+
+/*
+ * PCI Base Address for Peripheral Access
+ * - Offset 1ch, Size 32 bits
+ */
+#define PCI_PCU_BASE_IO				0x00000001	/* I/O 1 - I/O space */
+									/* 0 - Memory Space              */
+#define PCI_PCU_BASE_TYPE_MASK		0x03		/* 2-1 Bits Address range */
+									/* type                               */
+#define PCI_PCU_BASE_TYPE_SHIFT		1			/* 0 - device can be mapped */
+									/* any where in a 32 bit address space  */
+#define PCI_PCU_BASE_PREFETCH		0x00000008	/* Prefetchable - no effect */
+#define PCI_PCU_BASE_SIZE_MASK		0x0f	/* 7-4 Bits size of aperture */
+#define PCI_PCU_BASE_SIZE_SHIFT		4
+#define PCI_PCU_BASE_ADR_BASE_MASK	0x0ffffff	/* 31-20 Bits Base address */
+									/* of peripheral access                */
+#define PCI_PCU_BASE_ADR_BASE_SHIFT	8
+
+/*
+ * PCI CARDBUS CIS Pointer
+ * - Offset 28h, Size 32 bits
+ */
+
+/*
+ * PCI Sub Vendor ID
+ * - Offset 2ch, Size 16 bits
+ * - This value must be assigned by PCI SIG
+ */
+
+/*
+ * PCI Sub System ID
+ * - Offset 2eh, Size 16 bits
+ * - This value is managed by the vendor
+ */
+
+/*
+ * PCI Read Only Memory Register
+ * - Offset 30h, Size 32 bits
+ */
+#define PCI_ROM_BASE_ENABLE			0x00000001	/* Expansion ROM enable */
+#define PCI_ROM_BASE_PREFETCH		0x00000008	/* Prefetchable enable  */
+#define PCI_ROM_BASE_SIZE_MASK		0x03	/* 5-4 Bits Aperture size */
+#define PCI_ROM_BASE_SIZE_SHIFT		4
+#define PCI_ROM_BASE_MAP_MASK		0x0ff	/* 15-8 Bits Map address */
+#define PCI_ROM_BASE_MAP_SHIFT		8
+#define PCI_ROM_BASE_ADR_BASE_MASK	0x0ffff	/* 31-16 Bits Base address */
+#define PCI_ROM_BASE_ADR_BASE_SHIFT	16
+
+/*
+ * PCI Capablities
+ * - Offset 34h, Size 8 bits
+ */
+
+/*
+ * PCI Bus Parameters Register
+ * - Offset 3ch, Size 32 bits
+ */
+
+/* see pcireg.h */
+
+/*
+ * PCI I2O Map Register
+ * - Offset 50h, Size 32 bits
+ */
+#define PCI_I2O_MAP_ENABLE			0x00000001	/* Enable aperture */
+#define PCI_I2O_MAP_REG_EN			0x00000002	/* Register enable */
+#define PCI_I2O_MAP_I2O_MODE		0x00000004	/* I2O Mode enable */
+#define PCI_I2O_MAP_RD_POST_INH		0x00000008
+#define PCI_I2O_MAP_SIZE_1MB		0x00000000
+#define PCI_I2O_MAP_SIZE_2MB		0x00000010
+#define PCI_I2O_MAP_SIZE_4MB		0x00000020
+#define PCI_I2O_MAP_SIZE_8MB		0x00000030
+#define PCI_I2O_MAP_SIZE_16MB		0x00000040
+#define PCI_I2O_MAP_SIZE_32MB		0x00000050
+#define PCI_I2O_MAP_SIZE_64MB		0x00000060
+#define PCI_I2O_MAP_SIZE_128MB		0x00000070
+#define PCI_I2O_MAP_SIZE_256MB		0x00000080
+#define PCI_I2O_MAP_SIZE_512MB		0x00000090
+#define PCI_I2O_MAP_SIZE_1GB		0x000000a0
+#define PCI_I2O_BYTE_SWAP_NO		0x00000000	/* No swap 32 bits */
+#define PCI_I2O_BYTE_SWAP_16		0x00000100	/* 16 bits */
+#define PCI_I2O_BYTE_SWAP_8			0x00000200	/* bits */
+#define PCI_I2O_BYTE_SWAP_AUTO		0x00000300	/* Auto swap use BE[3:0]   */
+#define PCI_I2O_PCI_RD_MB_00		0x00000000
+#define PCI_I2O_PCI_RD_MB_01		0x00001000
+#define PCI_I2O_PCI_RD_MB_10		0x00002000
+#define PCI_I2O_PCI_WR_MB_00		0x00000000
+#define PCI_I2O_PCI_WR_MB_01		0x00004000
+#define PCI_I2O_PCI_WR_MB_10		0x00008000
+#define PCI_I2O_W_FLUSH				0x00010000	/* write prefetch reads */
+#define PCI_I2O_MAP_ADR_MASK		0x03ff
+#define PCI_I2O_MAP_ADR_SHIFT		20
+
+/*
+ * PCI MEM Map Register
+ * - Offset 54h, Size 32 bits
+ */
+#define PCI_MEM_MAP_ENABLE			0x00000001	/* Enable aperture */
+#define PCI_MEM_MAP_REG_EN			0x00000002	/* Register enable */
+#define PCI_MEM_MAP_I2O_MODE		0x00000004	/* I2O Mode enable */
+#define PCI_MEM_MAP_RD_POST_INH		0x00000008
+#define PCI_MEM_MAP_SIZE_1MB		0x00000000
+#define PCI_MEM_MAP_SIZE_2MB		0x00000010
+#define PCI_MEM_MAP_SIZE_4MB		0x00000020
+#define PCI_MEM_MAP_SIZE_8MB		0x00000030
+#define PCI_MEM_MAP_SIZE_16MB		0x00000040
+#define PCI_MEM_MAP_SIZE_32MB		0x00000050
+#define PCI_MEM_MAP_SIZE_64MB		0x00000060
+#define PCI_MEM_MAP_SIZE_128MB		0x00000070
+#define PCI_MEM_MAP_SIZE_256MB		0x00000080
+#define PCI_MEM_MAP_SIZE_512MB		0x00000090
+#define PCI_MEM_MAP_SIZE_1GB		0x000000a0
+#define PCI_MEM_BYTE_SWAP_NO		0x00000000	/* No swap 32 bits */
+#define PCI_MEM_BYTE_SWAP_16		0x00000100	/* 16 bits */
+#define PCI_MEM_BYTE_SWAP_8			0x00000200	/* bits */
+#define PCI_MEM_BYTE_SWAP_AUTO		0x00000300	/* Auto swap use BE[3:0]   */
+#define PCI_MEM_PCI_RD_MB_00		0x00000000
+#define PCI_MEM_PCI_RD_MB_01		0x00001000
+#define PCI_MEM_PCI_RD_MB_10		0x00002000
+#define PCI_MEM_PCI_WR_MB_00		0x00000000
+#define PCI_MEM_PCI_WR_MB_01		0x00004000
+#define PCI_MEM_PCI_WR_MB_10		0x00008000
+#define PCI_MEM_W_FLUSH				0x00010000	/* write prefetch reads */
+#define PCI_MEM_MAP_ADR_MASK		0x03ff
+#define PCI_MEM_MAP_ADR_SHIFT		20
+
+/*
+ * PCI BUS CFG Register
+ * -5ch Offset 5ch, Size 32 bits
+ */
+#define PCI_BUS_CFG_CFG_RETRY		0x00000100
+#define PCI_BUS_CFG_PCI_INH			0x00000200
+#define PCI_BUS_CFG_I2O_ONLINE		0x00003000
+#define PCI_BUS_CFG_I2O_EN			0x00004000
+#define PCI_BUS_CFG_I2O_EN_EN		0x00008000
+#define PCI_BUS_CFG_PBRST_MAX_4		0x00000000
+#define PCI_BUS_CFG_PBRST_MAX_8		0x00010000
+#define PCI_BUS_CFG_PBRST_MAX_16	0x00020000
+#define PCI_BUS_CFG_PBRST_MAX_256	0x00030000
+#define PCI_BUS_CFG_TRDY_STOP		0x00100000
+#define PCI_BUS_CFG_PCU_SWAP_00		0x00000000
+#define PCI_BUS_CFG_PCU_SWAP_01		0x01000000
+#define PCI_BUS_CFG_PCU_SWAP_10		0x02000000
+#define PCI_BUS_CFG_PCU_SWAP_11		0x03000000
+#define PCI_BUS_CFG_FAST_SCL		0x80000000
+
+/*
+ * LB_PCI_BASEx Registers
+ * - Offset 60h, Size 32 bits
+ * - Offset 64h, Size 32 bits
+ */
+#define LB_PCI_BASEX_ALOW_MASK		0x03	/* select value AD1:0 */
+#define LB_PCI_BASEX_ALOW_SHIFT		0x00000000
+#define LB_PCI_BASEX_ERR_EN			0x00000004	
+#define LB_PCI_BASEX_PREFETCH		0x00000008	/* prefetch */
+#define LB_PCI_BASEX_SIZE_DISABLE	0x00000000
+#define LB_PCI_BASEX_SIZE_16MB		0x00000010
+#define LB_PCI_BASEX_SIZE_32MB		0x00000020
+#define LB_PCI_BASEX_SIZE_64MB		0x00000030
+#define LB_PCI_BASEX_SIZE_128MB		0x00000040
+#define LB_PCI_BASEX_SIZE_256MB		0x00000050
+#define LB_PCI_BASEX_SIZE_512MB		0x00000060
+#define LB_PCI_BASEX_SIZE_1GB		0x00000070
+#define LB_PCI_BASEX_BYTE_SWAP_NO	0x00000000	/* No swap 32 bits */
+#define LB_PCI_BASEX_BYTE_SWAP_16	0x00000100	/* 16 bits */
+#define LB_PCI_BASEX_BYTE_SWAP_8	0x00000200	/* bits */
+#define LB_PCI_BASEX_BYTE_SWAP_AUTO	0x00000300	/* Auto swap use BE[3:0]   */
+#define LB_PCI_BASEX_COMBINE		0x00000800	/* Burst Write Combine */
+
+#define LB_PCI_BASEX_PCI_CMD_MASK	0x07
+#define LB_PCI_BASEX_PCI_CMD_SHIFT	13
+#define LB_PCI_BASEX_INT_ACK		0x00000000	/* Interrupt Ack */
+#define LB_PCI_BASEX_IO				0x00002000	/* I/O Read/Write */
+#define LB_PCI_BASEX_MEMORY			0x00006000	/* Memory Read/Write */
+#define LB_PCI_BASEX_CONFIG			0x0000a000	/* Configuration Read/Write */
+#define LB_PCI_BASEX_MULTI_MEMORY	0x0000c000	/* Multiple Memory Read/Write */
+#define LB_PCI_BASEX_MEMORY_INVALIDATE	0x0000e000	/* Multiple Memory Read/e */
+												/* Write Invalidate           */
+#define LB_PCI_BASEX_MAP_ADR_MASK	0x0ff	/* PCI Address map */
+#define LB_PCI_BASEX_MAP_ADR_SHIFT	16
+#define LB_PCI_BASEX_BASE			0xff000000	/* Local Address base */
+#define LB_PCI_BASEX_BASE_ADR_SHIFT	24
+
+
+/*
+ * System Register
+ * - Offset 73h, Size 8 bits
+ */
+#define SYSTEM_B_SPROM_EN			0x01		/* 1 - Software control     */
+									/* 0 - Hardware control                 */
+#define SYSTEM_B_SDA_IN				0x02		/* Serial EEPROM data input */
+#define SYSTEM_B_SDA_IN_SHIFT		1
+#define SYSTEM_B_SDA_OUT			0x04		/* Serial EEPROM data output */
+									/* SPROM_EN must be enabled              */
+#define SYSTEM_B_SCL				0x08		/* Serial EEPROM clock output */
+#define SYSTEM_B_LOO_EN				0x10		/* Hot swap LED control       */
+#define SYSTEM_B_CFG_LOCK			0x20		/* Configuration Lock         */
+#define SYSTEM_B_LOCK				0x40		/* Lock Register Contents set */										/* to 1 the contents become unwritable    */
+									/* Clear lock by writing 0xa5 Writing     */									/* 0xa5 will not overwrite the current    */									/* system status values                   */
+#define SYSTEM_B_UNLOCK_TOKEN		0xa5
+#define SYSTEM_B_RST_OUT			0x80		/* Reset output control */
+
+/*
+ * SDRAM Local Base Address Register 
+ * - Offset 78h, Size 32 bits
+ */
+#define LB_SDRAM_BASE_ENABLE		0x1			/* must be enabled to access */
+#define LB_SDRAM_BASE_SIZE_64M		0x0
+#define LB_SDRAM_BASE_SIZE_128M		0x10
+#define LB_SDRAM_BASE_SIZE_256M		0x20
+#define LB_SDRAM_BASE_SIZE_512M		0x30
+#define LB_SDRAM_BASE_SIZE_1G		0x40
+
+#define LB_SDRAM_BASE_MASK			0x03f
+#define LB_SDRAM_BASE_SHIFT			26
+
+/*
+ * Local Bus aperture control 
+ * - Offset 84h, Size 16 bits
+ */
+
+#define PCI_CNT_WR_PCI_SHIFT				14
+#define PCI_CNT_WR_PCI_FIFO_00			(0x0 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_WR_PCI_FIFO_01			(0x1 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_WR_PCI_FIFO_10			(0x2 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_WR_PCI_FIFO_11			(0x3 << PCI_CNT_WR_PCI_SHIFT)
+
+#define PCI_CNT_RD_PCI_SHIFT				8
+#define PCI_CNT_RD_PCI_FIFO_00			(0x0 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_RD_PCI_FIFO_01			(0x1 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_RD_PCI_FIFO_10			(0x2 << PCI_CNT_WR_PCI_SHIFT)
+#define PCI_CNT_RD_PCI_FIFO_11			(0x3 << PCI_CNT_WR_PCI_SHIFT)
+
+#define PCI_CNT_ONE_RD_BUF_SHIFT			7
+
+#define PCI_CNT_WFLUSH1_SHIFT				2
+#define PCI_CNT_WFLUSH1_00				(0x0 << PCI_CNT_WFLUSH1_SHIFT)
+#define PCI_CNT_WFLUSH1_01				(0x1 << PCI_CNT_WFLUSH1_SHIFT)
+#define PCI_CNT_WFLUSH1_10				(0x2 << PCI_CNT_WFLUSH1_SHIFT)
+#define PCI_CNT_WFLUSH1_11				(0x3 << PCI_CNT_WFLUSH1_SHIFT)
+
+#define PCI_CNT_WFLUSH0_SHIFT				0
+#define PCI_CNT_WFLUSH0_00				(0x0 << PCI_CNT_WFLUSH0_SHIFT)
+#define PCI_CNT_WFLUSH0_01				(0x1 << PCI_CNT_WFLUSH0_SHIFT)
+#define PCI_CNT_WFLUSH0_10				(0x2 << PCI_CNT_WFLUSH0_SHIFT)
+#define PCI_CNT_WFLUSH0_11				(0x3 << PCI_CNT_WFLUSH0_SHIFT)
+
+
+
+
+/*
+ * SDRAM Timing Parameters
+ * - Offset 8ch, Size 32 bits
+ */
+#define SDRAM_CFG_TCAS_RD_1			0x0			/* CAS latency */
+#define SDRAM_CFG_TCAS_RD_2			0x1			/* comment is cycles */
+#define SDRAM_CFG_TCAS_RD_3			0x2
+
+#define SDRAM_CFG_RCD_1				0x0			/* RAS to CAS delay */
+#define SDRAM_CFG_RCD_2				0x40		/* comment is cycles */
+#define SDRAM_CFG_RCD_3				0x80
+
+#define SDRAM_CFG_RP_1				0x0			/* RAS precharge */
+#define SDRAM_CFG_RP_2				0x100		/* comment is cycles */
+#define SDRAM_CFG_RP_3				0x200
+#define SDRAM_CFG_RP_4				0x300
+
+#define SDRAM_CFG_RAS_2				0x0			/* RAS pulse width */
+#define SDRAM_CFG_RAS_3				0x400		/* comment is cycles */
+#define SDRAM_CFG_RAS_4				0x800
+#define SDRAM_CFG_RAS_5				0xc00
+
+#define SDRAM_CFG_DPL_1				0x0			/* Last data write precharge */
+#define SDRAM_CFG_DPL_2				0x1000		/* comment is cycles */
+
+#define SDRAM_CFG_REF_SCALE_MASK	0x01
+#define SDRAM_CFG_REF_SCALE_SHIFT	21
+#define SDRAM_CFG_REF_NDIV_MASK		0x03f
+#define SDRAM_CFG_REF_NDIV_SHIFT	22
+
+/*
+ * SDRAM Command Register
+ * - Offset 8ah, Size 16 bits
+ */
+#define SDRAM_CMD_W_CMD_IPR			0x1			/* initiate command */
+
+#define SDRAM_CMD_W_CS_SEL_0		0x2			/* Chip select bank 0 */
+#define SDRAM_CMD_W_CS_SEL_1		0x4			/* Chip select bank 1 */
+#define SDRAM_CMD_W_CS_SEL_2		0x8			/* Chip select bank 2 */
+#define SDRAM_CMD_W_CS_SEL_3		0x10		/* Chip select bank 3 */
+
+#define SDRAM_CMD_W_NOOP			0x0			/* SDRAM Commands */
+#define SDRAM_CMD_W_BURST_TERM		0x20
+#define SDRAM_CMD_W_READ			0x40
+#define SDRAM_CMD_W_WRITE			0x60
+#define SDRAM_CMD_W_BANK_ACTIVATE	0x80
+#define SDRAM_CMD_W_PRECHARGE		0xa0
+#define SDRAM_CMD_W_AUTO_REFRESH	0xc0
+#define SDRAM_CMD_W_MODE_REGISTER	0xe0
+
+/*
+ * SDRAM Block Control Register
+ * - Offset 90h, Size 32 bits
+ * - Offset 94h, Size 32 bits
+ * - Offset 98h, Size 32 bits
+ * - Offset 9ch, Size 32 bits
+ */
+#define SDRAM_BANKX_ENABLE			0x1			/* Enable Bank */
+#define SDRAM_BANKX_READ_ONLY		0x2			/* Read only */
+#define SDRAM_BANKX_SIZE_512K		0x0
+#define SDRAM_BANKX_SIZE_1M			0x10
+#define SDRAM_BANKX_SIZE_2M			0x20
+#define SDRAM_BANKX_SIZE_4M			0x30
+#define SDRAM_BANKX_SIZE_8M			0x40
+#define SDRAM_BANKX_SIZE_16M		0x50
+#define SDRAM_BANKX_SIZE_32M		0x60
+#define SDRAM_BANKX_SIZE_64M		0x70
+#define SDRAM_BANKX_SIZE_128M		0x80
+#define SDRAM_BANKX_SIZE_256M		0x90
+
+#define SDRAM_BANKX_ROW_MUX_MODE_0	0x0
+#define SDRAM_BANKX_ROW_MUX_MODE_1	0x100
+#define SDRAM_BANKX_ROW_MUX_MODE_2	0x200
+#define SDRAM_BANKX_ROW_MUX_MODE_3	0x300
+#define SDRAM_BANKX_ROW_MUX_MODE_4	0x400
+#define SDRAM_BANKX_ROW_MUX_MODE_5	0x500
+#define SDRAM_BANKX_ROW_MUX_MODE_6	0x600
+#define SDRAM_BANKX_ROW_MUX_MODE_7	0x700
+#define SDRAM_BANKX_ROW_MUX_MODE_8	0x800
+#define SDRAM_BANKX_ROW_MUX_MODE_9	0x900
+#define SDRAM_BANKX_ROW_MUX_MODE_A	0xa00
+#define SDRAM_BANKX_ROW_MUX_MODE_B	0xb00
+#define SDRAM_BANKX_ROW_MUX_MODE_C	0xc00
+
+#define SDRAM_BANKX_COL_MUX_MODE_0	0x0
+#define SDRAM_BANKX_COL_MUX_MODE_1	0x1000
+#define SDRAM_BANKX_COL_MUX_MODE_2	0x2000
+#define SDRAM_BANKX_COL_MUX_MODE_3	0x3000
+#define SDRAM_BANKX_COL_MUX_MODE_4	0x4000
+#define SDRAM_BANKX_COL_MUX_MODE_5	0x5000
+#define SDRAM_BANKX_COL_MUX_MODE_6	0x6000
+#define SDRAM_BANKX_COL_MUX_MODE_7	0x7000
+
+#define SDRAM_BANKX_OFFSET_MASK		0x07ff
+#define SDRAM_BANKX_OFFSET_SHIFT	19
+
+
+/*
+ * Interrupt Configuration Register
+ * - Offset e0h, Size 32 bits
+ * - Offset e4h, Size 32 bits
+ * - Offset e8h, Size 32 bits
+ * - Offset 158h, Size 32 bits
+ */
+#define INT_CFGX_LB_MBI				0x00000001
+#define INT_CFGX_PCI_MBI			0x00000002
+#define INT_CFGX_I2O_OP_NE			0x00000008
+#define INT_CFGX_I2O_IF_NF			0x00000010
+#define INT_CFGX_I2O_IP_NE			0x00000020
+#define INT_CFGX_I2O_OP_NF			0x00000040
+#define INT_CFGX_I2O_OF_NE			0x00000080
+#define INT_CFGX_INT0				0x00000100
+#define INT_CFGX_INT1				0x00000200
+#define INT_CFGX_INT2				0x00000400
+#define INT_CFGX_INT3				0x00000800
+#define INT_CFGX_TIMER0				0x00001000
+#define INT_CFGX_TIMER1				0x00002000
+#define INT_CFGX_ENUM				0x00004000
+#define INT_CFGX_DMA0				0x00010000
+#define INT_CFGX_DMA1				0x00020000
+#define INT_CFGX_PWR_STATE			0x00100000
+#define INT_CFGX_HBI				0x00200000
+#define INT_CFGX_WDI				0x00400000
+#define INT_CFGX_BWI				0x00800000
+#define INT_CFGX_PSLAVE_PI			0x01000000
+#define INT_CFGX_PMASTER_PI			0x02000000
+#define INT_CFGX_PCI_T_ABORT		0x04000000
+#define INT_CFGX_PCI_M_ABORT		0x08000000
+#define INT_CFGX_DRA_PI				0x10000000
+#define INT_CFGX_MODE				0x20000000
+#define INT_CFGX_DI0				0x40000000
+#define INT_CFGX_DI1				0x80000000
+
+
+/*
+ * General Purpose Timer Control Register
+ * - Offset 150h, Size 16 bits
+ * - Offset 152h, Size 16 bits
+ */
+#define TIMER_CTLX_W_TI_MODE_0		0x0000		/* Timer input event */
+#define TIMER_CTLX_W_TI_MODE_1		0x0001
+#define TIMER_CTLX_W_TI_MODE_2		0x0002
+#define TIMER_CTLX_W_TI_MODE_3		0x0003
+
+#define TIMER_CTLX_W_CNT_EN_0		0x0000		/* Count enable */
+#define TIMER_CTLX_W_CNT_EN_1		0x0004
+#define TIMER_CTLX_W_CNT_EN_2		0x0008
+#define TIMER_CTLX_W_CNT_EN_3		0x000C
+
+#define TIMER_CTLX_W_TRG_MODE_0		0x0000		/* Trigger mode */
+#define TIMER_CTLX_W_TRG_MODE_1		0x0010
+#define TIMER_CTLX_W_TRG_MODE_2		0x0020
+#define TIMER_CTLX_W_TRG_MODE_3		0x0030
+
+#define TIMER_CTLX_W_TO_MODE_0		0x0000		/* Timer output mode */
+#define TIMER_CTLX_W_TO_MODE_1		0x0100
+#define TIMER_CTLX_W_TO_MODE_2		0x0200
+#define TIMER_CTLX_W_TO_MODE_3		0x0300
+#define TIMER_CTLX_W_TO_MODE_4		0x0400
+#define TIMER_CTLX_W_TO_MODE_5		0x0500
+
+#define TIMER_CTLX_W_DLTCH_0		0x0000		/* Data latch mode */
+#define TIMER_CTLX_W_DLTCH_1		0x0800
+#define TIMER_CTLX_W_DLTCH_2		0x1000
+
+#define TIMER_CTLX_W_ENABLE			0x8000		/* Timer enable */
+
+
+/*
+ * DMA Delay Register
+ * - Offset 16Ch, Size 8 bits
+ */
+#define DMA_DELAY_MASK		0x0ff	
+#define DMA_DELAY_SHIFT		0
+
+/*
+ * DMA Command / Status Register
+ * - Offset 170h, Size 32 bits
+ * - Offset 174h, Size 32 bits
+ */
+#define DMA_CSR_IPR				0x00000001	/* initiate DMA transfer */
+#define DMA_CSR_HALT			0x00000002	/* pause DMA transfer */
+#define DMA_CSR_DONE			0x00000004	/* DMA transfer complete */
+#define DMA_CSR_DCI				0x00000008	/* DMA control interrupt status	*/
+#define DMA_CSR_DPE				0x00000010	/* DMA PCI BUS error status */
+#define DMA_CSR_DONE_EN			0x00000400	/* DONE interrupt enable */
+#define DMA_CSR_DCI_EN			0x00000800	/* DCI interrupt enable */
+#define DMA_CSR_DPE_EN			0x00001000	/* DPE interrupt enable */
+#define DMA_CSR_PRIORITY		0x00008000	/* DMA channel priority */
+#define DMA_CSR_PCI_CMD0_MASK	0x07	/* PCI Command Type 0 */
+#define DMA_CSR_PCI_CMD0_SHIFT	17
+#define DMA_CSR_PCI_CMD1_MASK	0x07	/* PCI Command Type 1 */
+#define DMA_CSR_PCI_CMD1_SHIFT	21
+ 
+/*
+ * DMA Transfer Control Register
+ * - Offset 180h, Size 32 bits
+ * - Offset 190h, Size 32 bits
+ */
+#define DMA_XFER_DMA_CNT_MASK	0x0FFFFF	/* DMA transfer count */
+#define DMA_XFER_DMA_CNT_SHIFT	0
+#define DMA_XFER_DTERM_EN		0x00400000	/* External terminate count enable */
+#define DMA_XFER_BLOCK_FILL		0x00800000	/* Block fill feature enable */
+#define DMA_XFER_DST_BUS		0x01000000	/* DMA destination BUS */
+#define DMA_XFER_SRC_BUS		0x02000000	/* DMA source BUS */
+#define DMA_XFER_PDST_TYPE		0x04000000	/* PCI destination command type */
+#define DMA_XFER_PSRC_TYPE		0x08000000	/* PCI source command type */
+#define DMA_XFER_SWAP_MASK		0x03	/* Byte swap control */
+#define DMA_XFER_SWAP_SHIFT		28
+#define DMA_XFER_UPDT_CNT		0x40000000	/* Update count */
+#define DMA_XFER_DREQ_EN		0x80000000	/* External DRQ enable */
+
+
+/*
+ * DMA Control Block Register
+ * - Offset 180h, Size 32 bits
+ * - Offset 190h, Size 32 bits
+ */
+#define DMA_CTLB_BUS			0x00000001	/* DMA Control block address space */
+#define DMA_CTLB_SA_INC_DIS		0x00000004	/* Source BUS address increment disable */
+#define DMA_CTLB_DA_INC_DIS		0x00000008	/* Dest BUS address increment disable */
+#define DMA_CTLB_ADDR_MASK		0x0FFFFFFF	/* DMA Control block address mask */
+#define DMA_CTLB_ADDR_SHIFT		4
+
+
+/*
+ * PCI Configuration registers offsets
+ */
+#define	V3USC_PCI_VENDOR_W			V3REGH(0x00)
+#define	V3USC_PCI_DEVICE_W			V3REGH(0x02)
+#define	V3USC_PCI_CMD_W		 		V3REGH(0x04)
+#define	V3USC_PCI_STAT_W			V3REGH(0x06)
+#define	V3USC_PCI_CC_REV			V3REGW(0x08)
+#define	V3USC_PCI_HDR_CFG	 		V3REGW(0x0c)
+#define	V3USC_PCI_I2O_BASE	 		V3REGW(0x10)
+#define	V3USC_PCI_MEM_BASE	 		V3REGW(0x14)
+#define	V3USC_PCI_REG_BASE			V3REGW(0x18)
+#define	V3USC_PCI_PCU_BASE			V3REGW(0x1c)
+#define	V3USC_PCI_CIS				V3REGW(0x28)
+#define	V3USC_PCI_SUB_VENDOR_W		V3REGH(0x2c)
+#define	V3USC_PCI_SUB_ID_W			V3REGH(0x2e)
+#define	V3USC_PCI_ROM_BASE	 		V3REGW(0x30)
+#define	V3USC_PCI_CAPABLITY_B 		V3REGB(0x34)
+#define	V3USC_PCI_BPARM				V3REGW(0x3c)
+#define	V3USC_PM_CAP_ID_B			V3REGB(0x40)
+#define	V3USC_PM_NEXT_ID_B			V3REGB(0x41)
+#define	V3USC_PM_CAP_W				V3REGH(0x42)
+#define	V3USC_PM_CRS_W				V3REGH(0x44)
+#define	V3USC_PM_DATA_B				V3REGB(0x47)
+#define	V3USC_PM_PWR_CON			V3REGW(0x48)
+#define	V3USC_PM_PWR_DIS			V3REGW(0x4c)
+#define	V3USC_PCI_I2O_MAP			V3REGW(0x50)
+#define	V3USC_PCI_MEM_MAP			V3REGW(0x54)
+#define	V3USC_PCI_BUS_CFG			V3REGW(0x5c)
+#define	V3USC_LB_PCI_BASE0			V3REGW(0x60)
+#define	V3USC_LB_PCI_BASE1			V3REGW(0x64)
+#define	V3USC_LB_PCU_BASE			V3REGW(0x6c)
+#define	V3USC_LB_REG_BASE_W			V3REGH(0x70)
+#define	V3USC_SYSTEM_B				V3REGB(0x73)
+#define	V3USC_LB_ROM_BASE			V3REGW(0x74)
+#define	V3USC_LB_SDRAM_BASE			V3REGW(0x78)
+#define	V3USC_LB_BUS_CFG			V3REGW(0x7c)
+#define	V3USC_HS_CAP_ID_B			V3REGB(0x80)
+#define	V3USC_HS_NEXT_ID_B			V3REGB(0x81)
+#define	V3USC_HS_CSR_B				V3REGB(0x82)
+#define	V3USC_LB_PCI_CTL_W			V3REGH(0x84)
+#define	V3USC_T_CY_B				V3REGB(0x87)
+#define	V3USC_SDRAM_MA_W			V3REGH(0x88)
+#define	V3USC_SDRAM_CMD_W			V3REGH(0x8a)
+#define	V3USC_SDRAM_CFG				V3REGW(0x8c)
+#define	V3USC_SDRAM_BANK0			V3REGW(0x90)
+#define	V3USC_SDRAM_BANK1			V3REGW(0x94)
+#define	V3USC_SDRAM_BANK2			V3REGW(0x98)
+#define	V3USC_SDRAM_BANK3			V3REGW(0x9c)
+#define	V3USC_PCU_SUB0				V3REGW(0xa0)
+#define	V3USC_PCU_SUB1				V3REGW(0xa4)
+#define	V3USC_PCU_SUB2				V3REGW(0xa8)
+#define	V3USC_PCU_TC_WR0			V3REGW(0xb0)
+#define	V3USC_PCU_TC_WR1			V3REGW(0xb4)
+#define	V3USC_PCU_TC_WR2			V3REGW(0xb8)
+#define	V3USC_PCU_TC_WR3			V3REGW(0xbc)
+#define	V3USC_PCU_TC_WR4			V3REGW(0xc0)
+#define	V3USC_PCU_TC_RD0			V3REGW(0xc8)
+#define	V3USC_PCU_TC_RD1			V3REGW(0xcc)
+#define	V3USC_PCU_TC_RD2			V3REGW(0xd0)
+#define	V3USC_PCU_TC_RD3			V3REGW(0xd4)
+#define	V3USC_PCU_TC_RD4			V3REGW(0xd8)
+#define	V3USC_INT_CFG0				V3REGW(0xe0)
+#define	V3USC_INT_CFG1				V3REGW(0xe4)
+#define	V3USC_INT_CFG2				V3REGW(0xe8)
+#define	V3USC_INT_STAT				V3REGW(0xec)
+#define	V3USC_IOS					V3REGW(0xf0)
+#define	V3USC_WD_HBI_W				V3REGH(0xf4)
+#define	V3USC_MAIL_WR_STAT_B		V3REGB(0xf8)
+#define	V3USC_MAIL_RD_STAT_B		V3REGB(0xf9)
+#define	V3USC_PCI_MAIL_IEWR_B		V3REGB(0xfc)
+#define	V3USC_PCI_MAIL_IERD_B		V3REGB(0xfd)
+#define	V3USC_LB_MAIL_IEWR_B		V3REGB(0xfe)
+#define	V3USC_LB_MAIL_IERD_B		V3REGB(0xff)
+#define	V3USC_MAIL_DATA0_B			V3REGB(0x100)
+#define	V3USC_MAIL_DATA1_B			V3REGB(0x104)
+#define	V3USC_MAIL_DATA2_B			V3REGB(0x108)
+#define	V3USC_MAIL_DATA3_B			V3REGB(0x10c)
+#define	V3USC_MAIL_DATA4_B			V3REGB(0x110)
+#define	V3USC_MAIL_DATA5_B			V3REGB(0x114)
+#define	V3USC_MAIL_DATA6_B			V3REGB(0x118)
+#define	V3USC_MAIL_DATA7_B			V3REGB(0x11c)
+#define	V3USC_TIMER_DATA0			V3REGW(0x140)
+#define	V3USC_TIMER_DATA1			V3REGW(0x144)
+#define	V3USC_TIMER_CTL0_W			V3REGH(0x150)
+#define	V3USC_TIMER_CTL1_W			V3REGH(0x152)
+#define	V3USC_INT_CFG3				V3REGW(0x158)
+#define	V3USC_I2O_ISTAT				V3REGW(0x160)
+#define	V3USC_I2O_IMASK				V3REGW(0x164)
+#define	V3USC_DMA_DELAY				V3REGW(0x16C)
+#define	V3USC_DMA_CSR0				V3REGW(0x170)
+#define	V3USC_DMA_CSR1				V3REGW(0x174)
+#define	V3USC_DMA_XFER_CTL0			V3REGW(0x180)
+#define	V3USC_DMA_SRC_ADR0			V3REGW(0x184)
+#define	V3USC_DMA_DST_ADR0			V3REGW(0x188)
+#define	V3USC_DMA_CTLB_ADR0			V3REGW(0x18C)
+#define	V3USC_DMA_XFER_CTL1			V3REGW(0x190)
+#define	V3USC_DMA_SRC_ADR1			V3REGW(0x194)
+#define	V3USC_DMA_DST_ADR1			V3REGW(0x198)
+#define	V3USC_DMA_CTLB_ADR1			V3REGW(0x19C)
+
+/*
+ * I2O Mode offsets 
+ */
+#define	V3USC_IFL					V3USC_MAIL_DATA0_B
+#define	V3USC_IPL					V3USC_MAIL_DATA2_B
+#define	V3USC_OPL					V3USC_MAIL_DATA4_B
+#define	V3USC_OFL					V3USC_MAIL_DATA6_B
+
+/*********************************************************************
+ *
+ * This section defines some common tables by the registers
+ *
+ ********************************************************************/
+
+/*
+ * PCI Vendor ID
+ * - Offset 00h, Size 16 bits
+ */
+#define	V3_VENDOR_ID				0x11b0		/* V3 PCI Vendor ID */
+
+/*
+ * PCI Device ID
+ * - Offset 02h, Size 16 bits
+ */
+#define V960PBC						0x1			/* V3 Device ID for V960PBC */
+#define V961PBC						0x2			/* V3 Device ID for V961PBC */
+#define V962PBC						0x4			/* V3 Device ID for V962PBC */
+#define V292PBC						0x10		/* V3 Device ID for V292PBC */
+												/* MIPS MODE */ 
+#define V320USC						0x100		/* V3 Device ID for V320USC */
+												/* MIPS mode 9 bit SYSCMD   */ 
+#define V320USC_5					0x101		/* V3 Device ID for V320USC */
+												/* MIPS mode 5 bit SYSCMD   */ 
+#define V320USC_SH3					0x102		/* V3 Device ID for V320USC */
+												/* SH3 mode */ 
+#define V320USC_SH4					0x103		/* V3 Device ID for V320USC */
+												/* SH4 mode */ 
+#define V370PDC						0x200		/* V3 Device ID for V370PDC */
+
+/*
+ * Stepping of V3USC320 as read back from V3USC_PCI_CC_REV register
+ */
+#define V3USC_REV_A0 0
+#define V3USC_REV_B0 1
+#define V3USC_REV_B1 2
+
+/*
+ * PCI Bus Parameters Register
+ * - Offset 3ch, Size 32 bits
+ */
+#define INTERRUPT_PIN_DISABLE		0x0			/* Disabled */
+#define INTERRUPT_PIN_INTA			0x1			/* Use INTA */
+#define INTERRUPT_PIN_INTB			0x2			/* Use INTA */
+#define INTERRUPT_PIN_INTC			0x3			/* Use INTA */
+#define INTERRUPT_PIN_INTD			0x4			/* Use INTA */
+
+/*
+ * PCI Base Address for Peripheral Access 
+ * - Offset 1ch, Size 32 bits
+ * PCI Intelligent I/O Address Translation Unit Local Bus Address Map Register
+ * - Offset ??h, Size 32 bits
+ */
+#define BYTE_SWAP_NO				0x0			/* No swap 32 bits */
+#define BYTE_SWAP_16				0x1			/* 16 bits */
+#define BYTE_SWAP_8					0x2			/* 8 bits */
+#define BYTE_SWAP_AUTO				0x3			/* Auto swap use BE[3:0]   */
+#define APERTURE_SIZE_1M			0x0			/* Aperture size of 1 MB   */
+#define APERTURE_SIZE_2M			0x1			/* Aperture size of 2 MB   */
+#define APERTURE_SIZE_4M			0x2			/* Aperture size of 4 MB   */
+#define APERTURE_SIZE_8M			0x3			/* Aperture size of 8 MB   */
+#define APERTURE_SIZE_16M			0x4			/* Aperture size of 16 MB  */
+#define APERTURE_SIZE_32M			0x5			/* Aperture size of 32 MB  */
+#define APERTURE_SIZE_64M			0x6			/* Aperture size of 64 MB  */
+#define APERTURE_SIZE_128M			0x7			/* Aperture size of 128 MB */
+#define APERTURE_SIZE_256M			0x8			/* Aperture size of 256 MB */
+#define APERTURE_SIZE_512M			0x9			/* Aperture size of 512 MB */
+#define APERTURE_SIZE_1G			0xa			/* Aperture size of 1 GB   */
+
+/*
+ * Mail box registers short equates
+ */
+#define EN0							0x0001		/* mailbox bit 0 */
+#define EN1							0x0002		/* mailbox bit 1 */
+#define EN2							0x0004		/* mailbox bit 2 */
+#define EN3							0x0008		/* mailbox bit 3 */
+#define EN4							0x0010		/* mailbox bit 4 */
+#define EN5							0x0020		/* mailbox bit 5 */
+#define EN6							0x0040		/* mailbox bit 6 */
+#define EN7							0x0080		/* mailbox bit 7 */
+
+/*
+ * Enumerate bits 0-31 for KRF-Tech layer
+ */
+
+#define	BIT0 = 0x00000001,
+#define	BIT1 = 0x00000002,
+#define	BIT2 = 0x00000004,
+#define	BIT3 = 0x00000008,
+#define	BIT4 = 0x00000010,
+#define	BIT5 = 0x00000020,
+#define	BIT6 = 0x00000040,
+#define	BIT7 = 0x00000080,
+#define	BIT8 = 0x00000100,
+#define	BIT9 = 0x00000200,
+#define	BIT10 = 0x00000400,
+#define	BIT11 = 0x00000800,
+#define	BIT12 = 0x00001000,
+#define	BIT13 = 0x00002000,
+#define	BIT14 = 0x00004000,
+#define	BIT15 = 0x00008000,
+#define	BIT16 = 0x00010000,
+#define	BIT17 = 0x00020000,
+#define	BIT18 = 0x00040000,
+#define	BIT19 = 0x00080000,
+#define	BIT20 = 0x00100000,
+#define	BIT21 = 0x00200000,
+#define	BIT22 = 0x00400000,
+#define	BIT23 = 0x00800000,
+#define	BIT24 = 0x01000000,
+#define	BIT25 = 0x02000000,
+#define	BIT26 = 0x04000000,
+#define	BIT27 = 0x08000000,
+#define	BIT28 = 0x10000000,
+#define	BIT29 = 0x20000000,
+#define	BIT30 = 0x40000000,
+#define	BIT31 = 0x80000000
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _V3USCREG_H_ */
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/serial.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/serial.h
@@ -0,0 +1,47 @@
+/*
+ * include/asm-xtensa/platform-xt2000/serial.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Tensilica Inc.
+ */
+
+#ifndef __ASM_XTENSA_XT2000_SERIAL_H
+#define __ASM_XTENSA_XT2000_SERIAL_H
+
+#include <linux/config.h>
+#include <asm/platform/xt2000.h>
+
+#define BASE_BAUD ( DUART16552_XTAL_FREQ / 16 )
+
+#if XCHAL_HAVE_LE
+#define IO_BASE_1 (DUART16552_1_VADDR)
+#define IO_BASE_2 (DUART16552_2_VADDR)
+#elif XCHAL_HAVE_BE
+#define IO_BASE_1 (DUART16552_1_VADDR + 3)
+#define IO_BASE_2 (DUART16552_2_VADDR + 3)
+#else
+#error endianess not defined
+#endif
+
+#define RS_TABLE_SIZE 2
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF|ASYNC_SKIP_TEST)
+
+#define _SERIAL_PORT(intnr, base)				\
+	{ .baud_base = BASE_BAUD, 				\
+	  .irq = intnr,						\
+	  .flags = STD_COM_FLAGS,				\
+	  .iomem_base = (u8*) base,				\
+          .iomem_reg_shift = 2,					\
+	  .io_type = SERIAL_IO_MEM, }				\
+
+#define STD_SERIAL_PORT_DFNS 					\
+	_SERIAL_PORT (DUART16552_1_INTNUM, IO_BASE_1), 		\
+	_SERIAL_PORT (DUART16552_2_INTNUM, IO_BASE_2),
+
+#define SERIAL_PORT_DFNS STD_SERIAL_PORT_DFNS
+
+#endif /* __ASM_XTENSA_XT2000_H */
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/system.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/system.h
@@ -0,0 +1,198 @@
+/*
+ * xtensa/config/system.h -- HAL definitions that are dependent on SYSTEM configuration
+ *
+ *  NOTE: The location and contents of this file are highly subject to change.
+ *
+ *  Source for configuration-independent binaries (which link in a
+ *  configuration-specific HAL library) must NEVER include this file.
+ *  The HAL itself has historically included this file in some instances,
+ *  but this is not appropriate either, because the HAL is meant to be
+ *  core-specific but system independent.
+ */
+
+/*
+ * Copyright (c) 2003 Tensilica, Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2.1 of the GNU Lesser General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307,
+ * USA.
+ */
+
+
+#ifndef XTENSA_CONFIG_SYSTEM_H
+#define XTENSA_CONFIG_SYSTEM_H
+
+/*#include <xtensa/hal.h>*/
+
+
+
+/*----------------------------------------------------------------------
+				DEVICE ADDRESSES
+  ----------------------------------------------------------------------*/
+
+/*
+ *  Strange place to find these, but the configuration GUI
+ *  allows moving these around to account for various core
+ *  configurations.  Specific boards (and their BSP software)
+ *  will have specific meanings for these components.
+ */
+
+/*  I/O Block areas:  */
+#define XSHAL_IOBLOCK_CACHED_VADDR	0xE0000000
+#define XSHAL_IOBLOCK_CACHED_PADDR	0xF0000000
+#define XSHAL_IOBLOCK_CACHED_SIZE	0x0E000000
+
+#define XSHAL_IOBLOCK_BYPASS_VADDR	0xF0000000
+#define XSHAL_IOBLOCK_BYPASS_PADDR	0xF0000000
+#define XSHAL_IOBLOCK_BYPASS_SIZE	0x0E000000
+
+/*  System ROM:  */
+#define XSHAL_ROM_VADDR		0xEE000000
+#define XSHAL_ROM_PADDR		0xFE000000
+#define XSHAL_ROM_SIZE		0x00400000
+/*  Largest available area (free of vectors):  */
+#define XSHAL_ROM_AVAIL_VADDR	0xEE00052C
+#define XSHAL_ROM_AVAIL_VSIZE	0x003FFAD4
+
+/*  System RAM:  */
+#define XSHAL_RAM_VADDR		0xD0000000
+#define XSHAL_RAM_PADDR		0x00000000
+#define XSHAL_RAM_VSIZE		0x08000000
+#define XSHAL_RAM_PSIZE		0x10000000
+#define XSHAL_RAM_SIZE		XSHAL_RAM_PSIZE
+/*  Largest available area (free of vectors):  */
+#define XSHAL_RAM_AVAIL_VADDR	0xD0000370
+#define XSHAL_RAM_AVAIL_VSIZE	0x07FFFC90
+
+/*
+ *  Shadow system RAM (same device as system RAM, at different address).
+ *  (Emulation boards need this for the SONIC Ethernet driver
+ *   when data caches are configured for writeback mode.)
+ *  NOTE: on full MMU configs, this points to the BYPASS virtual address
+ *  of system RAM, ie. is the same as XSHAL_RAM_* except that virtual
+ *  addresses are viewed through the BYPASS static map rather than
+ *  the CACHED static map.
+ */
+#define XSHAL_RAM_BYPASS_VADDR		0xD8000000
+#define XSHAL_RAM_BYPASS_PADDR		0x00000000
+#define XSHAL_RAM_BYPASS_PSIZE		0x08000000
+
+/*  Alternate system RAM (different device than system RAM):  */
+#define XSHAL_ALTRAM_VADDR		0xCEE00000
+#define XSHAL_ALTRAM_PADDR		0xC0000000
+#define XSHAL_ALTRAM_SIZE		0x00200000
+
+
+/*----------------------------------------------------------------------
+ *			DEVICE-ADDRESS DEPENDENT...
+ *
+ *  Values written to CACHEATTR special register (or its equivalent)
+ *  to enable and disable caches in various modes.
+ *----------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------
+			BACKWARD COMPATIBILITY ...
+  ----------------------------------------------------------------------*/
+
+/*
+ *  NOTE:  the following two macros are DEPRECATED.  Use the latter
+ *  board-specific macros instead, which are specially tuned for the
+ *  particular target environments' memory maps.
+ */
+#define XSHAL_CACHEATTR_BYPASS		XSHAL_XT2000_CACHEATTR_BYPASS	/* disable caches in bypass mode */
+#define XSHAL_CACHEATTR_DEFAULT		XSHAL_XT2000_CACHEATTR_DEFAULT	/* default setting to enable caches (no writeback!) */
+
+/*----------------------------------------------------------------------
+			ISS (Instruction Set Simulator) SPECIFIC ...
+  ----------------------------------------------------------------------*/
+
+#define XSHAL_ISS_CACHEATTR_WRITEBACK	0x1122222F	/* enable caches in write-back mode */
+#define XSHAL_ISS_CACHEATTR_WRITEALLOC	0x1122222F	/* enable caches in write-allocate mode */
+#define XSHAL_ISS_CACHEATTR_WRITETHRU	0x1122222F	/* enable caches in write-through mode */
+#define XSHAL_ISS_CACHEATTR_BYPASS	0x2222222F	/* disable caches in bypass mode */
+#define XSHAL_ISS_CACHEATTR_DEFAULT	XSHAL_ISS_CACHEATTR_WRITEBACK	/* default setting to enable caches */
+
+/*  For Coware only:  */
+#define XSHAL_COWARE_CACHEATTR_WRITEBACK	0x11222222	/* enable caches in write-back mode */
+#define XSHAL_COWARE_CACHEATTR_WRITEALLOC	0x11222222	/* enable caches in write-allocate mode */
+#define XSHAL_COWARE_CACHEATTR_WRITETHRU	0x11222222	/* enable caches in write-through mode */
+#define XSHAL_COWARE_CACHEATTR_BYPASS		0x22222222	/* disable caches in bypass mode */
+#define XSHAL_COWARE_CACHEATTR_DEFAULT		XSHAL_COWARE_CACHEATTR_WRITEBACK	/* default setting to enable caches */
+
+/*  For BFM and other purposes:  */
+#define XSHAL_ALLVALID_CACHEATTR_WRITEBACK	0x11222222	/* enable caches without any invalid regions */
+#define XSHAL_ALLVALID_CACHEATTR_DEFAULT	XSHAL_ALLVALID_CACHEATTR_WRITEBACK	/* default setting for caches without any invalid regions */
+
+#define XSHAL_ISS_PIPE_REGIONS	0
+#define XSHAL_ISS_SDRAM_REGIONS	0
+
+
+/*----------------------------------------------------------------------
+			XT2000 BOARD SPECIFIC ...
+  ----------------------------------------------------------------------*/
+
+#define XSHAL_XT2000_CACHEATTR_WRITEBACK	0x22FFFFFF	/* enable caches in write-back mode */
+#define XSHAL_XT2000_CACHEATTR_WRITEALLOC	0x22FFFFFF	/* enable caches in write-allocate mode */
+#define XSHAL_XT2000_CACHEATTR_WRITETHRU	0x22FFFFFF	/* enable caches in write-through mode */
+#define XSHAL_XT2000_CACHEATTR_BYPASS		0x22FFFFFF	/* disable caches in bypass mode */
+#define XSHAL_XT2000_CACHEATTR_DEFAULT		XSHAL_XT2000_CACHEATTR_WRITEBACK	/* default setting to enable caches */
+
+#define XSHAL_XT2000_PIPE_REGIONS	0x00001000	/* BusInt pipeline regions */
+#define XSHAL_XT2000_SDRAM_REGIONS	0x00000005	/* BusInt SDRAM regions */
+
+
+/*----------------------------------------------------------------------
+				VECTOR SIZES
+  ----------------------------------------------------------------------*/
+
+/*
+ *  Sizes allocated to vectors by the system (memory map) configuration.
+ *  These sizes are constrained by core configuration (eg. one vector's
+ *  code cannot overflow into another vector) but are dependent on the
+ *  system or board (or LSP) memory map configuration.
+ *
+ *  Whether or not each vector happens to be in a system ROM is also
+ *  a system configuration matter, sometimes useful, included here also:
+ */
+#define XSHAL_RESET_VECTOR_SIZE	0x000004E0
+#define XSHAL_RESET_VECTOR_ISROM	1
+#define XSHAL_USER_VECTOR_SIZE	0x0000001C
+#define XSHAL_USER_VECTOR_ISROM	0
+#define XSHAL_PROGRAMEXC_VECTOR_SIZE	XSHAL_USER_VECTOR_SIZE	/* for backward compatibility */
+#define XSHAL_USEREXC_VECTOR_SIZE	XSHAL_USER_VECTOR_SIZE	/* for backward compatibility */
+#define XSHAL_KERNEL_VECTOR_SIZE	0x0000001C
+#define XSHAL_KERNEL_VECTOR_ISROM	0
+#define XSHAL_STACKEDEXC_VECTOR_SIZE	XSHAL_KERNEL_VECTOR_SIZE	/* for backward compatibility */
+#define XSHAL_KERNELEXC_VECTOR_SIZE	XSHAL_KERNEL_VECTOR_SIZE	/* for backward compatibility */
+#define XSHAL_DOUBLEEXC_VECTOR_SIZE	0x000000E0
+#define XSHAL_DOUBLEEXC_VECTOR_ISROM	0
+#define XSHAL_WINDOW_VECTORS_SIZE	0x00000180
+#define XSHAL_WINDOW_VECTORS_ISROM	0
+#define XSHAL_INTLEVEL2_VECTOR_SIZE	0x0000000C
+#define XSHAL_INTLEVEL2_VECTOR_ISROM	0
+#define XSHAL_INTLEVEL3_VECTOR_SIZE	0x0000000C
+#define XSHAL_INTLEVEL3_VECTOR_ISROM	0
+#define XSHAL_INTLEVEL4_VECTOR_SIZE	0x0000000C
+#define XSHAL_INTLEVEL4_VECTOR_ISROM	1
+#define XSHAL_DEBUG_VECTOR_SIZE		XSHAL_INTLEVEL4_VECTOR_SIZE
+#define XSHAL_DEBUG_VECTOR_ISROM	XSHAL_INTLEVEL4_VECTOR_ISROM
+
+
+#endif /*XTENSA_CONFIG_SYSTEM_H*/
+
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/xt2000-uart.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/xt2000-uart.h
@@ -0,0 +1,155 @@
+#ifndef _uart_h_included_
+#define _uart_h_included_
+
+/*
+ * THIS FILE IS GENERATED -- DO NOT MODIFY BY HAND
+ *
+ * include/asm-xtensa/xtensa/xt2000-uart.h -- NatSemi PC16552D DUART
+ * definitions
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002 Tensilica Inc.
+ */
+
+
+#include <asm/platform/xt2000.h>
+
+
+/* 16550 UART DEVICE REGISTERS
+   The XT2000 board aligns each register to a 32-bit word but the UART device only uses
+   one byte of the word, which is the least-significant byte regardless of the
+   endianness of the core (ie. byte offset 0 for little-endian and 3 for big-endian).
+   So if using word accesses then endianness doesn't matter.
+   The macros provided here do that.
+*/
+struct uart_dev_s {
+  union {
+    unsigned int rxb;	/* DLAB=0: receive buffer, read-only */
+    unsigned int txb;	/* DLAB=0: transmit buffer, write-only */
+    unsigned int dll;	/* DLAB=1: divisor, least-significant byte latch (was write-only?) */
+  } w0;
+  union {
+    unsigned int ier;	/* DLAB=0: interrupt-enable register (was write-only?) */
+    unsigned int dlm;	/* DLAB=1: divisor, most-significant byte latch (was write-only?) */
+  } w1;
+
+  union {
+    unsigned int isr;	/* DLAB=0: interrupt status register, read-only */
+    unsigned int fcr;	/* DLAB=0: FIFO control register, write-only */
+    unsigned int afr;	/* DLAB=1: alternate function register */
+  } w2;
+
+  unsigned int lcr;	/* line control-register, write-only */
+  unsigned int mcr;	/* modem control-regsiter, write-only */
+  unsigned int lsr;	/* line status register, read-only */
+  unsigned int msr;	/* modem status register, read-only */
+  unsigned int scr;	/* scratch regsiter, read/write */
+};
+
+#define _RXB(u) ((u)->w0.rxb)
+#define _TXB(u) ((u)->w0.txb)
+#define _DLL(u) ((u)->w0.dll)
+#define _IER(u) ((u)->w1.ier)
+#define _DLM(u) ((u)->w1.dlm)
+#define _ISR(u) ((u)->w2.isr)
+#define _FCR(u) ((u)->w2.fcr)
+#define _AFR(u) ((u)->w2.afr)
+#define _LCR(u) ((u)->lcr)
+#define _MCR(u) ((u)->mcr)
+#define _LSR(u) ((u)->lsr)
+#define _MSR(u) ((u)->msr)
+#define _SCR(u) ((u)->scr)
+
+typedef volatile struct uart_dev_s uart_dev_t;
+
+/* IER bits */
+#define RCVR_DATA_REG_INTENABLE 0x01
+#define XMIT_HOLD_REG_INTENABLE    0x02
+#define RCVR_STATUS_INTENABLE   0x04
+#define MODEM_STATUS_INTENABLE     0x08
+
+/* FCR bits */
+#define _FIFO_ENABLE      0x01
+#define RCVR_FIFO_RESET  0x02
+#define XMIT_FIFO_RESET  0x04
+#define DMA_MODE_SELECT  0x08
+#define RCVR_TRIGGER_LSB 0x40
+#define RCVR_TRIGGER_MSB 0x80
+
+/* AFR bits */
+#define AFR_CONC_WRITE	0x01
+#define AFR_BAUDOUT_SEL	0x02
+#define AFR_RXRDY_SEL	0x04
+
+/* ISR bits */
+#define INT_STATUS(r)   ((r)&1)
+#define INT_PRIORITY(r) (((r)>>1)&0x7)
+
+/* LCR bits */
+#define WORD_LENGTH(n)  (((n)-5)&0x3)
+#define STOP_BIT_ENABLE 0x04
+#define PARITY_ENABLE   0x08
+#define EVEN_PARITY     0x10
+#define FORCE_PARITY    0x20
+#define XMIT_BREAK      0x40
+#define DLAB_ENABLE     0x80
+
+/* MCR bits */
+#define _DTR 0x01
+#define _RTS 0x02
+#define _OP1 0x04
+#define _OP2 0x08
+#define LOOP_BACK 0x10
+
+/* LSR Bits */
+#define RCVR_DATA_READY 0x01
+#define OVERRUN_ERROR   0x02
+#define PARITY_ERROR    0x04
+#define FRAMING_ERROR   0x08
+#define BREAK_INTERRUPT 0x10
+#define XMIT_HOLD_EMPTY 0x20
+#define XMIT_EMPTY      0x40
+#define FIFO_ERROR      0x80
+#define RCVR_READY(u)   (_LSR(u)&RCVR_DATA_READY)
+#define XMIT_READY(u)   (_LSR(u)&XMIT_HOLD_EMPTY)
+
+/* MSR bits */
+#define _RDR       0x01
+#define DELTA_DSR 0x02
+#define DELTA_RI  0x04
+#define DELTA_CD  0x08
+#define _CTS       0x10
+#define _DSR       0x20
+#define _RI        0x40
+#define _CD        0x80
+
+/* prototypes */
+void uart_init( uart_dev_t *u, int bitrate );
+void uart_out( uart_dev_t *u, char c );
+void uart_puts( uart_dev_t *u, char *s );
+char uart_in( uart_dev_t *u );
+void uart_enable_rcvr_int( uart_dev_t *u );
+void uart_disable_rcvr_int( uart_dev_t *u );
+
+#ifdef DUART16552_1_VADDR
+/*  DUART present.  */
+#define DUART_1_BASE	(*(uart_dev_t*)DUART16552_1_VADDR)
+#define DUART_2_BASE	(*(uart_dev_t*)DUART16552_2_VADDR)
+#define UART1_PUTS(s)	uart_puts( &DUART_1_BASE, s )
+#define UART2_PUTS(s)	uart_puts( &DUART_2_BASE, s )
+#else
+/*  DUART not configured, use dummy placeholders to allow compiles to work.  */
+#define DUART_1_BASE	(*(uart_dev_t*)0)
+#define DUART_2_BASE	(*(uart_dev_t*)0)
+#define UART1_PUTS(s)
+#define UART2_PUTS(s)
+#endif
+
+/*  Compute 16-bit divisor for baudrate generator, with rounding:  */
+#define DUART_DIVISOR(crystal,speed)	(((crystal)/16 + (speed)/2)/(speed))
+
+#endif /*_uart_h_included_*/
+
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/xt2000.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/xt2000.h
@@ -0,0 +1,408 @@
+#ifndef _INC_XT2000_H_
+#define _INC_XT2000_H_
+
+/*
+ * THIS FILE IS GENERATED -- DO NOT MODIFY BY HAND
+ *
+ * include/asm-xtensa/xtensa/xt2000.h - Definitions specific to the
+ * Tensilica XT2000 Emulation Board
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002 Tensilica Inc.
+ */
+
+
+#include <asm/processor.h>
+#include <asm/platform/system.h>
+
+
+/*
+ *  Default assignment of XT2000 devices to external interrupts.
+ */
+
+/*  Ethernet interrupt:  */
+#ifdef XCHAL_EXTINT3_NUM
+#define SONIC83934_INTNUM	XCHAL_EXTINT3_NUM
+#define SONIC83934_INTLEVEL	XCHAL_EXTINT3_LEVEL
+#define SONIC83934_INTMASK	XCHAL_EXTINT3_MASK
+#else
+#define SONIC83934_INTMASK	0
+#endif
+
+/*  DUART channel 1 interrupt (P1 - console):  */
+#ifdef XCHAL_EXTINT4_NUM
+#define DUART16552_1_INTNUM	XCHAL_EXTINT4_NUM
+#define DUART16552_1_INTLEVEL	XCHAL_EXTINT4_LEVEL
+#define DUART16552_1_INTMASK	XCHAL_EXTINT4_MASK
+#else
+#define DUART16552_1_INTMASK	0
+#endif
+
+/*  DUART channel 2 interrupt (P2 - 2nd serial port):  */
+#ifdef XCHAL_EXTINT5_NUM
+#define DUART16552_2_INTNUM	XCHAL_EXTINT5_NUM
+#define DUART16552_2_INTLEVEL	XCHAL_EXTINT5_LEVEL
+#define DUART16552_2_INTMASK	XCHAL_EXTINT5_MASK
+#else
+#define DUART16552_2_INTMASK	0
+#endif
+
+/*  FPGA-combined PCI/etc interrupts:  */
+#ifdef XCHAL_EXTINT6_NUM
+#define XT2000_FPGAPCI_INTNUM	XCHAL_EXTINT6_NUM
+#define XT2000_FPGAPCI_INTLEVEL	XCHAL_EXTINT6_LEVEL
+#define XT2000_FPGAPCI_INTMASK	XCHAL_EXTINT6_MASK
+#else
+#define XT2000_FPGAPCI_INTMASK	0
+#endif
+
+
+
+/*
+ *  Device addresses.
+ *
+ *  Note:  for endianness-independence, use 32-bit loads and stores for all
+ *  register accesses to Ethernet, DUART and LED devices.  Undefined bits
+ *  may need to be masked out if needed when reading if the actual register
+ *  size is smaller than 32 bits.
+ *
+ *  Note:  XT2000 bus byte lanes are defined in terms of msbyte and lsbyte
+ *  relative to the processor.  So 32-bit registers are accessed consistently
+ *  from both big and little endian processors.  However, this means byte
+ *  sequences are not consistent between big and little endian processors.
+ *  This is fine for RAM, and for ROM if ROM is created for a specific
+ *  processor (and thus has correct byte sequences).  However this may be
+ *  unexpected for Flash, which might contain a file-system that one wants
+ *  to use for multiple processor configurations (eg. the Flash might contain
+ *  the Ethernet card's address, endianness-independent application data, etc).
+ *  That is, byte sequences written in Flash by a core of a given endianness
+ *  will be byte-swapped when seen by a core of the other endianness.
+ *  Someone implementing an endianness-independent Flash file system will
+ *  likely handle this byte-swapping issue in the Flash driver software.
+ */
+
+#define DUART16552_XTAL_FREQ	18432000	/* crystal frequency in Hz */
+#define XTBOARD_FLASH_MAXSIZE	0x4000000	/* 64 MB (max; depends on what is socketed!) */
+#define XTBOARD_EPROM_MAXSIZE	0x0400000	/* 4 MB (max; depends on what is socketed!) */
+#define XTBOARD_EEPROM_MAXSIZE	0x0080000	/* 512 kB (max; depends on what is socketed!) */
+#define XTBOARD_ASRAM_SIZE	0x0100000	/* 1 MB */
+#define XTBOARD_PCI_MEM_SIZE	0x8000000	/* 128 MB (allocated) */
+#define XTBOARD_PCI_IO_SIZE	0x1000000	/* 16 MB (allocated) */
+
+#ifdef XSHAL_IOBLOCK_BYPASS_PADDR
+/*  PCI memory space:  */
+# define XTBOARD_PCI_MEM_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0x0000000)
+/*  Socketed Flash (eg. 2 x 16-bit devices):  */
+# define XTBOARD_FLASH_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0x8000000)
+/*  PCI I/O space:  */
+# define XTBOARD_PCI_IO_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xC000000)
+/*  V3 PCI interface chip register/config space:  */
+# define XTBOARD_V3PCI_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD000000)
+/*  Bus Interface registers:  */
+# define XTBOARD_BUSINT_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD010000)
+/*  FPGA registers:  */
+# define XT2000_FPGAREGS_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD020000)
+/*  SONIC SN83934 Ethernet controller/transceiver:  */
+# define SONIC83934_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD030000)
+/*  8-character bitmapped LED display:  */
+# define XTBOARD_LED_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD040000)
+/*  National-Semi PC16552D DUART:  */
+# define DUART16552_1_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD050020)	/* channel 1 (P1 - console) */
+# define DUART16552_2_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD050000)	/* channel 2 (P2) */
+/*  Asynchronous Static RAM:  */
+# define XTBOARD_ASRAM_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD400000)
+/*  8-bit EEPROM:  */
+# define XTBOARD_EEPROM_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD600000)
+/*  2 x 16-bit EPROMs:  */
+# define XTBOARD_EPROM_PADDR	(XSHAL_IOBLOCK_BYPASS_PADDR+0xD800000)
+#endif /* XSHAL_IOBLOCK_BYPASS_PADDR */
+
+/*  These devices might be accessed cached:  */
+#ifdef XSHAL_IOBLOCK_CACHED_PADDR
+# define XTBOARD_PCI_MEM_CACHED_PADDR	(XSHAL_IOBLOCK_CACHED_PADDR+0x0000000)
+# define XTBOARD_FLASH_CACHED_PADDR	(XSHAL_IOBLOCK_CACHED_PADDR+0x8000000)
+# define XTBOARD_ASRAM_CACHED_PADDR	(XSHAL_IOBLOCK_CACHED_PADDR+0xD400000)
+# define XTBOARD_EEPROM_CACHED_PADDR	(XSHAL_IOBLOCK_CACHED_PADDR+0xD600000)
+# define XTBOARD_EPROM_CACHED_PADDR	(XSHAL_IOBLOCK_CACHED_PADDR+0xD800000)
+#endif /* XSHAL_IOBLOCK_CACHED_PADDR */
+
+
+/***  Same thing over again, this time with virtual addresses:  ***/
+
+#ifdef XSHAL_IOBLOCK_BYPASS_VADDR
+/*  PCI memory space:  */
+# define XTBOARD_PCI_MEM_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0x0000000)
+/*  Socketed Flash (eg. 2 x 16-bit devices):  */
+# define XTBOARD_FLASH_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0x8000000)
+/*  PCI I/O space:  */
+# define XTBOARD_PCI_IO_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xC000000)
+/*  V3 PCI interface chip register/config space:  */
+# define XTBOARD_V3PCI_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD000000)
+/*  Bus Interface registers:  */
+# define XTBOARD_BUSINT_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD010000)
+/*  FPGA registers:  */
+# define XT2000_FPGAREGS_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD020000)
+/*  SONIC SN83934 Ethernet controller/transceiver:  */
+# define SONIC83934_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD030000)
+/*  8-character bitmapped LED display:  */
+# define XTBOARD_LED_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD040000)
+/*  National-Semi PC16552D DUART:  */
+# define DUART16552_1_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD050020)	/* channel 1 (P1 - console) */
+# define DUART16552_2_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD050000)	/* channel 2 (P2) */
+/*  Asynchronous Static RAM:  */
+# define XTBOARD_ASRAM_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD400000)
+/*  8-bit EEPROM:  */
+# define XTBOARD_EEPROM_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD600000)
+/*  2 x 16-bit EPROMs:  */
+# define XTBOARD_EPROM_VADDR	(XSHAL_IOBLOCK_BYPASS_VADDR+0xD800000)
+#endif /* XSHAL_IOBLOCK_BYPASS_VADDR */
+
+/*  These devices might be accessed cached:  */
+#ifdef XSHAL_IOBLOCK_CACHED_VADDR
+# define XTBOARD_PCI_MEM_CACHED_VADDR	(XSHAL_IOBLOCK_CACHED_VADDR+0x0000000)
+# define XTBOARD_FLASH_CACHED_VADDR	(XSHAL_IOBLOCK_CACHED_VADDR+0x8000000)
+# define XTBOARD_ASRAM_CACHED_VADDR	(XSHAL_IOBLOCK_CACHED_VADDR+0xD400000)
+# define XTBOARD_EEPROM_CACHED_VADDR	(XSHAL_IOBLOCK_CACHED_VADDR+0xD600000)
+# define XTBOARD_EPROM_CACHED_VADDR	(XSHAL_IOBLOCK_CACHED_VADDR+0xD800000)
+#endif /* XSHAL_IOBLOCK_CACHED_VADDR */
+
+
+/*  System ROM:  */
+#define XTBOARD_ROM_SIZE		XSHAL_ROM_SIZE
+#ifdef XSHAL_ROM_VADDR
+#define XTBOARD_ROM_VADDR		XSHAL_ROM_VADDR
+#endif
+#ifdef XSHAL_ROM_PADDR
+#define XTBOARD_ROM_PADDR		XSHAL_ROM_PADDR
+#endif
+
+/*  System RAM:  */
+#define XTBOARD_RAM_SIZE		XSHAL_RAM_SIZE
+#ifdef XSHAL_RAM_VADDR
+#define XTBOARD_RAM_VADDR		XSHAL_RAM_VADDR
+#endif
+#ifdef XSHAL_RAM_PADDR
+#define XTBOARD_RAM_PADDR		XSHAL_RAM_PADDR
+#endif
+#define XTBOARD_RAM_BYPASS_VADDR	XSHAL_RAM_BYPASS_VADDR
+#define XTBOARD_RAM_BYPASS_PADDR	XSHAL_RAM_BYPASS_PADDR
+
+
+
+/*
+ *  Things that depend on device addresses.
+ */
+
+
+#define XTBOARD_CACHEATTR_WRITEBACK	XSHAL_XT2000_CACHEATTR_WRITEBACK
+#define XTBOARD_CACHEATTR_WRITEALLOC	XSHAL_XT2000_CACHEATTR_WRITEALLOC
+#define XTBOARD_CACHEATTR_WRITETHRU	XSHAL_XT2000_CACHEATTR_WRITETHRU
+#define XTBOARD_CACHEATTR_BYPASS	XSHAL_XT2000_CACHEATTR_BYPASS
+#define XTBOARD_CACHEATTR_DEFAULT	XSHAL_XT2000_CACHEATTR_DEFAULT
+
+#define XTBOARD_BUSINT_PIPE_REGIONS	XSHAL_XT2000_PIPE_REGIONS
+#define XTBOARD_BUSINT_SDRAM_REGIONS	XSHAL_XT2000_SDRAM_REGIONS
+
+
+
+/*
+ *  BusLogic (FPGA) registers.
+ *  All these registers are normally accessed using 32-bit loads/stores.
+ */
+
+/*  Register offsets:  */
+#define XT2000_DATECD_OFS	0x00	/* date code (read-only) */
+#define XT2000_STSREG_OFS	0x04	/* status (read-only) */
+#define XT2000_SYSLED_OFS	0x08	/* system LED */
+#define XT2000_WRPROT_OFS	0x0C	/* write protect */
+#define XT2000_SWRST_OFS	0x10	/* software reset */
+#define XT2000_SYSRST_OFS	0x14	/* system (peripherals) reset */
+#define XT2000_IMASK_OFS	0x18	/* interrupt mask */
+#define XT2000_ISTAT_OFS	0x1C	/* interrupt status */
+#define XT2000_V3CFG_OFS	0x20	/* V3 config (V320 PCI) */
+
+/*  Physical register addresses:  */
+#ifdef XT2000_FPGAREGS_PADDR
+#define XT2000_DATECD_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_DATECD_OFS)
+#define XT2000_STSREG_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_STSREG_OFS)
+#define XT2000_SYSLED_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_SYSLED_OFS)
+#define XT2000_WRPROT_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_WRPROT_OFS)
+#define XT2000_SWRST_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_SWRST_OFS)
+#define XT2000_SYSRST_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_SYSRST_OFS)
+#define XT2000_IMASK_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_IMASK_OFS)
+#define XT2000_ISTAT_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_ISTAT_OFS)
+#define XT2000_V3CFG_PADDR	(XT2000_FPGAREGS_PADDR+XT2000_V3CFG_OFS)
+#endif
+
+/*  Virtual register addresses:  */
+#ifdef XT2000_FPGAREGS_VADDR
+#define XT2000_DATECD_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_DATECD_OFS)
+#define XT2000_STSREG_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_STSREG_OFS)
+#define XT2000_SYSLED_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_SYSLED_OFS)
+#define XT2000_WRPROT_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_WRPROT_OFS)
+#define XT2000_SWRST_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_SWRST_OFS)
+#define XT2000_SYSRST_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_SYSRST_OFS)
+#define XT2000_IMASK_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_IMASK_OFS)
+#define XT2000_ISTAT_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_ISTAT_OFS)
+#define XT2000_V3CFG_VADDR	(XT2000_FPGAREGS_VADDR+XT2000_V3CFG_OFS)
+/*  Register access (for C code):  */
+#define XT2000_DATECD_REG	(*(volatile unsigned*) XT2000_DATECD_VADDR)
+#define XT2000_STSREG_REG	(*(volatile unsigned*) XT2000_STSREG_VADDR)
+#define XT2000_SYSLED_REG	(*(volatile unsigned*) XT2000_SYSLED_VADDR)
+#define XT2000_WRPROT_REG	(*(volatile unsigned*) XT2000_WRPROT_VADDR)
+#define XT2000_SWRST_REG	(*(volatile unsigned*) XT2000_SWRST_VADDR)
+#define XT2000_SYSRST_REG	(*(volatile unsigned*) XT2000_SYSRST_VADDR)
+#define XT2000_IMASK_REG	(*(volatile unsigned*) XT2000_IMASK_VADDR)
+#define XT2000_ISTAT_REG	(*(volatile unsigned*) XT2000_ISTAT_VADDR)
+#define XT2000_V3CFG_REG	(*(volatile unsigned*) XT2000_V3CFG_VADDR)
+#endif
+
+/*  DATECD (date code) bit fields:  */
+
+/*  BCD-coded month (01..12):  */
+#define XT2000_DATECD_MONTH_SHIFT	24
+#define XT2000_DATECD_MONTH_BITS	8
+#define XT2000_DATECD_MONTH_MASK	0xFF000000
+/*  BCD-coded day (01..31):  */
+#define XT2000_DATECD_DAY_SHIFT		16
+#define XT2000_DATECD_DAY_BITS		8
+#define XT2000_DATECD_DAY_MASK		0x00FF0000
+/*  BCD-coded year (2001..9999):  */
+#define XT2000_DATECD_YEAR_SHIFT	0
+#define XT2000_DATECD_YEAR_BITS		16
+#define XT2000_DATECD_YEAR_MASK		0x0000FFFF
+
+/*  STSREG (status) bit fields:  */
+
+/*  Switch SW3 setting bit fields (0=off/up, 1=on/down):  */
+#define XT2000_STSREG_SW3_SHIFT		0
+#define XT2000_STSREG_SW3_BITS		4
+#define XT2000_STSREG_SW3_MASK		0x0000000F
+/*  Boot-select bits of switch SW3:  */
+#define XT2000_STSREG_BOOTSEL_SHIFT	0
+#define XT2000_STSREG_BOOTSEL_BITS	2
+#define XT2000_STSREG_BOOTSEL_MASK	0x00000003
+/*  Boot-select values:  */
+#define XT2000_STSREG_BOOTSEL_FLASH	0
+#define XT2000_STSREG_BOOTSEL_EPROM16	1
+#define XT2000_STSREG_BOOTSEL_PROM8	2
+#define XT2000_STSREG_BOOTSEL_ASRAM	3
+/*  User-defined bits of switch SW3:  */
+#define XT2000_STSREG_SW3_2_SHIFT	2
+#define XT2000_STSREG_SW3_2_MASK	0x00000004
+#define XT2000_STSREG_SW3_3_SHIFT	3
+#define XT2000_STSREG_SW3_3_MASK	0x00000008
+
+/*  SYSLED (system LED) bit fields:  */
+
+/*  LED control bit (0=off, 1=on):  */
+#define XT2000_SYSLED_LEDON_SHIFT	0
+#define XT2000_SYSLED_LEDON_MASK	0x00000001
+
+/*  WRPROT (write protect) bit fields (0=writable, 1=write-protected [default]):  */
+
+/*  Flash write protect:  */
+#define XT2000_WRPROT_FLWP_SHIFT	0
+#define XT2000_WRPROT_FLWP_MASK		0x00000001
+/*  Reserved but present write protect bits:  */
+#define XT2000_WRPROT_WRP_SHIFT		1
+#define XT2000_WRPROT_WRP_BITS		7
+#define XT2000_WRPROT_WRP_MASK		0x000000FE
+
+/*  SWRST (software reset; allows s/w to generate power-on equivalent reset):  */
+
+/*  Software reset bits:  */
+#define XT2000_SWRST_SWR_SHIFT		0
+#define XT2000_SWRST_SWR_BITS		16
+#define XT2000_SWRST_SWR_MASK		0x0000FFFF
+/*  Software reset value -- writing this value resets the board:  */
+#define XT2000_SWRST_RESETVALUE		0x0000DEAD
+
+/*  SYSRST (system reset; controls reset of individual peripherals):  */
+
+/*  All-device reset:  */
+#define XT2000_SYSRST_ALL_SHIFT		0
+#define XT2000_SYSRST_ALL_BITS		4
+#define XT2000_SYSRST_ALL_MASK		0x0000000F
+/*  HDSP-2534 LED display reset (1=reset, 0=nothing):  */
+#define XT2000_SYSRST_LED_SHIFT		0
+#define XT2000_SYSRST_LED_MASK		0x00000001
+/*  Sonic DP83934 Ethernet controller reset (1=reset, 0=nothing):  */
+#define XT2000_SYSRST_SONIC_SHIFT	1
+#define XT2000_SYSRST_SONIC_MASK	0x00000002
+/*  DP16552 DUART reset (1=reset, 0=nothing):  */
+#define XT2000_SYSRST_DUART_SHIFT	2
+#define XT2000_SYSRST_DUART_MASK	0x00000004
+/*  V3 V320 PCI bridge controller reset (1=reset, 0=nothing):  */
+#define XT2000_SYSRST_V3_SHIFT		3
+#define XT2000_SYSRST_V3_MASK		0x00000008
+
+/*  IMASK (interrupt mask; 0=disable, 1=enable):  */
+/*  ISTAT (interrupt status; 0=inactive, 1=pending):  */
+
+/*  PCI INTP interrupt:  */
+#define XT2000_INTMUX_PCI_INTP_SHIFT	2
+#define XT2000_INTMUX_PCI_INTP_MASK	0x00000004
+/*  PCI INTS interrupt:  */
+#define XT2000_INTMUX_PCI_INTS_SHIFT	3
+#define XT2000_INTMUX_PCI_INTS_MASK	0x00000008
+/*  PCI INTD interrupt:  */
+#define XT2000_INTMUX_PCI_INTD_SHIFT	4
+#define XT2000_INTMUX_PCI_INTD_MASK	0x00000010
+/*  V320 PCI controller interrupt:  */
+#define XT2000_INTMUX_V3_SHIFT		5
+#define XT2000_INTMUX_V3_MASK		0x00000020
+/*  PCI ENUM interrupt:  */
+#define XT2000_INTMUX_PCI_ENUM_SHIFT	6
+#define XT2000_INTMUX_PCI_ENUM_MASK	0x00000040
+/*  PCI DEG interrupt:  */
+#define XT2000_INTMUX_PCI_DEG_SHIFT	7
+#define XT2000_INTMUX_PCI_DEG_MASK	0x00000080
+
+/*  V3CFG (V3 config, V320 PCI controller):  */
+
+/*  V3 address control (0=pass-thru, 1=V3 address bits 31:28 set to 4'b0001 [default]):  */
+#define XT2000_V3CFG_V3ADC_SHIFT	0
+#define XT2000_V3CFG_V3ADC_MASK		0x00000001
+
+/* I2C Devices */
+
+#define	XT2000_I2C_RTC_ID		0x68
+#define	XT2000_I2C_NVRAM0_ID		0x56	/* 1st 256 byte block */
+#define	XT2000_I2C_NVRAM1_ID		0x57	/* 2nd 256 byte block */
+
+/*  NVRAM Board Info structure:  */
+
+#define XT2000_NVRAM_SIZE		512
+
+#define XT2000_NVRAM_BINFO_START	0x100
+#define XT2000_NVRAM_BINFO_SIZE		0x20
+#define XT2000_NVRAM_BINFO_VERSION	0x10	/* version 1.0 */
+#if 0
+#define XT2000_NVRAM_BINFO_VERSION_OFFSET	0x00
+#define XT2000_NVRAM_BINFO_VERSION_SIZE			0x1
+#define XT2000_NVRAM_BINFO_ETH_ADDR_OFFSET	0x02
+#define XT2000_NVRAM_BINFO_ETH_ADDR_SIZE		0x6
+#define XT2000_NVRAM_BINFO_SN_OFFSET		0x10
+#define XT2000_NVRAM_BINFO_SN_SIZE			0xE
+#define	XT2000_NVRAM_BINFO_CRC_OFFSET		0x1E
+#define	XT2000_NVRAM_BINFO_CRC_SIZE			0x2
+#endif /*0*/
+
+#if !defined(__ASSEMBLY__) && !defined(_NOCLANGUAGE)
+typedef struct xt2000_nvram_binfo {
+    unsigned char	version;
+    unsigned char	reserved1;
+    unsigned char	eth_addr[6];
+    unsigned char	reserved8[8];
+    unsigned char	serialno[14];
+    unsigned char	crc[2];		/* 16-bit CRC */
+} xt2000_nvram_binfo;
+#endif /*!__ASSEMBLY__ && !_NOCLANGUAGE*/
+
+
+#endif /*_INC_XT2000_H_*/
+
Index: linux-2.6.10/arch/xtensa/kernel/entry.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/entry.S
+++ linux-2.6.10/arch/xtensa/kernel/entry.S
@@ -24,7 +24,6 @@
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/signal.h>
-#include <xtensa/coreasm.h>
 
 /* Unimplemented features. */
 
@@ -125,8 +124,9 @@ _user_exception:
 
 	movi	a2, 0
 	rsr	a3, SAR
-	wsr	a2, ICOUNTLEVEL
+	xsr	a2, ICOUNTLEVEL
 	s32i	a3, a1, PT_SAR
+	s32i	a2, a1, PT_ICOUNTLEVEL
 
 	/* Rotate ws so that the current windowbase is at bit0. */
 	/* Assume ws = xxwww1yyyy. Rotate ws right, so that a2 = yyyyxxwww1 */
@@ -276,8 +276,9 @@ _kernel_exception:
 
 	movi	a2, 0
 	rsr	a3, SAR
-	wsr	a2, ICOUNTLEVEL
+	xsr	a2, ICOUNTLEVEL
 	s32i	a3, a1, PT_SAR
+	s32i	a2, a1, PT_ICOUNTLEVEL
 
 	/* Rotate ws so that the current windowbase is at bit0. */
 	/* Assume ws = xxwww1yyyy. Rotate ws right, so that a2 = yyyyxxwww1 */
@@ -330,7 +331,7 @@ _kernel_exception:
 
 common_exception:
 
-	/* Save EXCVADDR, DEBUGCAUSE, and PC, and clear LCOUNT */
+	/* Save EXCVADDR, DEBUGCAUSE, and PC, and clear LCOUNT and SYSCALL */
 
 	rsr	a2, DEBUGCAUSE
 	rsr	a3, EPC_1
@@ -340,6 +341,7 @@ common_exception:
 	rsr	a3, EXCVADDR
 	movi	a2, 0
 	s32i	a3, a1, PT_EXCVADDR
+	s32i	a2, a1, PT_SYSCALL
 	xsr	a2, LCOUNT
 	s32i	a2, a1, PT_LCOUNT
 
@@ -388,7 +390,9 @@ common_exception:
 	addx4	a4, a0, a4
 	l32i	a4, a4, EXC_TABLE_DEFAULT		# load handler
 
-	/* Call the second-level handler */
+	/* Call the second-level handler 
+	 * (*handler)(struct pt_regs* regs, int EXCCAUSE) 
+	 */
 
 	callx4	a4
 
@@ -461,15 +465,13 @@ common_exception_return:
 
 	l32i	a3, a2, TI_TASK
 	l32i	a3, a3, TASK_PTRACE
+	l32i	a4, a1, PT_ICOUNTLEVEL
 	bbci.l	a3, PT_SINGLESTEP_BIT, 1f # jump if single-step flag is not set
 
 	movi	a3, -2			# PT_SINGLESTEP flag is set,
 	movi	a4, 1			# icountlevel of 1 means it won't
 	wsr	a3, ICOUNT		# start counting until after rfe
-	wsr	a4, ICOUNTLEVEL		# so setup icount & icountlevel.
-	isync
-
-1:
+1:	wsr	a4, ICOUNTLEVEL		# so setup icount & icountlevel.
 
 #if XCHAL_EXTRA_SA_SIZE
 
@@ -567,17 +569,25 @@ kernel_exception_exit:
 	/* Check current_thread_info->preempt_count */
 
 	GET_THREAD_INFO(a2)
-	l32i	a3, a2, TI_PREEMPT
-	bnez	a3, 1f
+	l32i	a4, a2, TI_PREEMPT
+	bnez	a4, 1f
 
 	l32i	a2, a2, TI_FLAGS
+	bbci	TIF_NEED_RESCHED, a2, 1f
+
+	movi	a4, preempt_schedule_irq
+	callx4	a4
+
+
 
 1:
 
+
 #endif
 
 #endif
 
+
 	/* Check if we have to do a movsp.
 	 *
 	 * We only have to do a movsp if the previous window-frame has
@@ -1004,9 +1014,7 @@ ENTRY(fast_syscall_kernel)
 
 	rsr	a0, DEPC			# get syscall-nr
 	_beqz	a0, fast_syscall_spill_registers
-
-	addi	a0, a0, -__NR_sysxtensa
-	_beqz	a0, fast_syscall_sysxtensa
+	_beqi	a0, __NR_xtensa, fast_syscall_xtensa
 
 	j	kernel_exception
 
@@ -1024,9 +1032,7 @@ ENTRY(fast_syscall_user)
 
 	rsr	a0, DEPC			# get syscall-nr
 	_beqz	a0, fast_syscall_spill_registers
-
-	addi	a0, a0, -__NR_sysxtensa
-	_beqz	a0, fast_syscall_sysxtensa
+	_beqi	a0, __NR_xtensa, fast_syscall_xtensa
 
 	j	user_exception
 
@@ -1047,11 +1053,11 @@ ENTRY(fast_syscall_unrecoverable)
 /*
  * sysxtensa syscall handler
  *
- * int sysxtensa (XTENSA_ATOMIC_SET, ptr, val, unused);
- * int sysxtensa (XTENSA_ATOMIC_ADD, ptr, val, unused);
- * int sysxtensa (XTENSA_ATOMIC_EXG_ADD, ptr, val, unused);
- * int sysxtensa (XTENSA_ATOMIC_CMP_SWP, ptr, oldval, newval);
- * a2                    a6              a3    a4      a5
+ * int sysxtensa (SYS_XTENSA_ATOMIC_SET,     ptr, val,    unused);
+ * int sysxtensa (SYS_XTENSA_ATOMIC_ADD,     ptr, val,    unused);
+ * int sysxtensa (SYS_XTENSA_ATOMIC_EXG_ADD, ptr, val,    unused);
+ * int sysxtensa (SYS_XTENSA_ATOMIC_CMP_SWP, ptr, oldval, newval);
+ * a2                    a6                   a3    a4      a5
  *
  * Entry condition:
  *
@@ -1059,6 +1065,7 @@ ENTRY(fast_syscall_unrecoverable)
  *   a1:	a1
  *   a2:	new stack pointer, original in DEPC
  *   a3:	dispatch table
+ *   a4..a15:	unchanged
  *   depc:	a2, original value saved on stack (PT_DEPC)
  *   excsave_1:	a3
  *
@@ -1091,59 +1098,58 @@ ENTRY(fast_syscall_unrecoverable)
 #define CATCH								\
 67:
 
-ENTRY(fast_syscall_sysxtensa)
-
-	_beqz	a6, 1f
-	_blti	a6, SYSXTENSA_COUNT, 2f
+ENTRY(fast_syscall_xtensa)
 
-1:	j	user_exception
-
-2:	xsr	a3, EXCSAVE_1		# restore a3, excsave1
-	s32i	a7, a2, PT_AREG7
+	xsr	a3, EXCSAVE_1		# restore a3, excsave1
+	wsr	a7, DEPC		# use DEPC to save a7
 
 	movi	a7, 4			# sizeof(unsigned int)
-	verify_area a3, a7, a0, a2, .Leac
+	access_ok a3, a7, a0, a2, .Leac
 
-	_beqi	a6, SYSXTENSA_ATOMIC_SET, .Lset
-	_beqi	a6, SYSXTENSA_ATOMIC_EXG_ADD, .Lexg
-	_beqi	a6, SYSXTENSA_ATOMIC_ADD, .Ladd
+	addi	a6, a6, -1
+	l32i	a0, a2, PT_AREG0	# restore a0
+	_bgeui	a6, SYS_XTENSA_COUNT - 1, .Lill
+	_bnei	a6, SYS_XTENSA_ATOMIC_CMP_SWP - 1, .Lnswp
 
-	/* Fall through for SYSXTENSA_ATOMIC_CMP_SWP */
+	/* Fall through for ATOMIC_CMP_SWP. */
 
 .Lswp:	/* Atomic compare and swap */
 
+
 TRY	l32i	a7, a3, 0		# read old value
 	bne	a7, a4, 1f		# same as old value? jump
-	s32i	a5, a3, 0		# different, modify value
-	movi	a7, 1			# and return 1
-	j	.Lret
-
-1:	movi	a7, 0			# same values: return 0
-	j	.Lret
-
-.Ladd:	/* Atomic add */
-.Lexg:	/* Atomic (exchange) add */
-
-TRY	l32i	a7, a3, 0
-	add	a4, a4, a7
-	s32i	a4, a3, 0
-	j	.Lret
-
-.Lset:	/* Atomic set */
-
-TRY	l32i	a7, a3, 0		# read old value as return value
-	s32i	a4, a3, 0		# write new value
-
-.Lret:	mov	a0, a2
-	mov	a2, a7
-	l32i	a7, a0, PT_AREG7
-	l32i	a3, a0, PT_AREG3
-	l32i	a0, a0, PT_AREG0
+TRY	s32i	a5, a3, 0		# different, modify value
+	movi	a2, 1			# and return 1
+	rsr	a7, DEPC
+	addi	a6, a6, 1		# restore a6 (really necessary?)
+	rfe
+
+1:	movi	a2, 0			# return 0 (note that we cannot set
+	rsr	a7, DEPC		# a2 before the store!)
+	addi	a6, a6, 1		# restore a6 (really necessary?)
+	rfe
+
+.Lnswp:	/* Atomic set, add, and exg_add. */
+
+TRY	l32i	a5, a3, 0		# orig
+	add	a7, a4, a5		# + arg
+	movnez	a4, a7, a6		# !set
+	s32i	a7, a3, 0		# write new value
+
+	rsr	a7, DEPC
+	mov	a2, a5			# note that we cannot use a2 before
+	addi	a6, a6, 1		# restore a6 (really necessary?)
 	rfe
 
 CATCH
-.Leac:	movi	a7, -EFAULT
-	j	.Lret
+.Leac:	movi	a2, -EFAULT
+	rsr	a7, DEPC
+	rfe
+
+.Lill:	movi	a2, -EINVAL
+	rsr	a7, DEPC
+	rfe
+
 
 
 
@@ -1691,15 +1697,16 @@ ENTRY(fast_store_prohibited)
 8:	rsr	a1, EXCVADDR		# fault address
 	_PGD_OFFSET(a0, a1, a4)
 	l32i	a0, a0, 0
-	//beqi	a0, _PAGE_USER, 2f	# FIXME use _PAGE_INVALID
+	//beqi	a0, _PAGE_INVALID, 2f	## FIXME
 	beqz	a0, 2f
-
 	_PTE_OFFSET(a0, a1, a4)
 	l32i	a4, a0, 0		# read pteval
-	movi	a1, _PAGE_VALID | _PAGE_RW
+	beqi	a4, _PAGE_INVALID, 2f	# invalid entry?
+	movi	a1, _PAGE_RW
+	//movi	a1, _PAGE_EXEC | _PAGE_WEN
 	bnall	a4, a1, 2f
 
-	movi	a1, _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_WRENABLE
+	movi	a1, _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_WEN
 	or	a4, a4, a1
 	rsr	a1, EXCVADDR
 	s32i	a4, a0, 0
@@ -1907,6 +1914,87 @@ ENTRY(fast_coprocessor)
 #endif /* XCHAL_EXTRA_SA_SIZE */
 
 /*
+ * System Calls.
+ *
+ * void system_call (struct pt_regs* regs, int exccause)
+ *                            a2                 a3
+ */
+
+ENTRY(system_call)
+	entry	a1, 32
+
+	/* regs->syscall = regs->areg[2] */
+
+	l32i	a3, a2, PT_AREG2
+	mov	a6, a2
+	movi	a4, do_syscall_trace_enter
+	s32i	a3, a2, PT_SYSCALL
+	callx4	a4
+
+	/* syscall = sys_call_table[syscall_nr] */
+	
+	movi	a4, sys_call_table;
+	movi	a5, __NR_syscall_count
+	movi	a6, -ENOSYS
+	bgeu	a3, a5, 1f
+
+	addx4	a4, a3, a4
+	l32i	a4, a4, 0
+	movi	a5, sys_ni_syscall;
+	beq	a4, a5, 1f
+
+	/* Load args: arg0 - arg5 are passed via regs. */
+
+	l32i	a6, a2, PT_AREG6
+	l32i	a7, a2, PT_AREG3
+	l32i	a8, a2, PT_AREG4
+	l32i	a9, a2, PT_AREG5
+	l32i	a10, a2, PT_AREG8
+	l32i	a11, a2, PT_AREG9
+
+	/* Pass one additional argument to the syscall: pt_regs (on stack) */
+	s32i	a2, a1, 0
+
+	callx4	a4
+
+1:	/* regs->areg[2] = return_value */
+
+	s32i	a6, a2, PT_AREG2
+	movi	a4, do_syscall_trace_leave
+	mov	a6, a2
+	callx4	a4
+	retw
+
+
+/*
+ * Create a kernel thread
+ *
+ * int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+ * a2                    a2                 a3             a4
+ */
+
+ENTRY(kernel_thread)
+	entry a1, 16
+
+	mov	a5, a2			# preserve fn over syscall
+	mov	a7, a3			# preserve args over syscall
+
+	movi	a3, _CLONE_VM | _CLONE_UNTRACED
+	movi	a2, __NR_clone
+	or	a6, a4, a3		# arg0: flags
+	mov	a3, a1			# arg1: sp
+	syscall
+
+	beq	a3, a1, 1f		# branch if parent
+	mov	a6, a7			# args
+	callx4	a5			# fn(args)
+
+	movi	a2, __NR_exit
+	syscall				# return value of fn(args) still in a6
+
+1:	retw
+
+/*
  * Task switch.
  *
  * struct task*  _switch_to (struct task* prev, struct task* next)
@@ -1964,33 +2052,9 @@ ENTRY(ret_from_fork)
 	movi	a4, schedule_tail
 	callx4	a4
 
-	movi	a4, do_syscall_trace
+	movi	a4, do_syscall_trace_leave
+	mov	a6, a1
 	callx4	a4
 
 	j	common_exception_return
 
-
-
-/*
- * Table of syscalls
- */
-
-.data
-.align  4
-.global sys_call_table
-sys_call_table:
-
-#define SYSCALL(call, narg) .word call
-#include "syscalls.h"
-
-/*
- * Number of arguments of each syscall
- */
-
-.global sys_narg_table
-sys_narg_table:
-
-#undef SYSCALL
-#define SYSCALL(call, narg) .byte narg
-#include "syscalls.h"
-
Index: linux-2.6.10/arch/xtensa/kernel/process.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/process.c
+++ linux-2.6.10/arch/xtensa/kernel/process.c
@@ -32,6 +32,7 @@
 #include <linux/prctl.h>
 #include <linux/init_task.h>
 #include <linux/module.h>
+#include <linux/fs.h>
 #include <linux/mqueue.h>
 
 #include <asm/pgtable.h>
@@ -165,11 +166,17 @@ int copy_thread(int nr, unsigned long cl
 
 		int len = childregs->wmask & ~0xf;
 		childregs->areg[1] = usp;
+#if 1
 		memcpy(&childregs->areg[XCHAL_NUM_AREGS - len/4],
 		       &regs->areg[XCHAL_NUM_AREGS - len/4], len);
+#else
+		memcpy(&childregs->areg[4], &regs->areg[4], XCHAL_NUM_AREGS * 4 - 16);
+#endif
 
+#if 0	// FIXME
 		if (clone_flags & CLONE_SETTLS)
-			childregs->areg[2] = childregs->areg[6];
+			childregs->areg[2] = childregs->areg[5];
+#endif
 
 	} else {
 		/* In kernel space, we start a new thread with a new stack. */
@@ -180,36 +187,6 @@ int copy_thread(int nr, unsigned long cl
 
 
 /*
- * Create a kernel thread
- */
-
-int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
-{
-	long retval;
-	__asm__ __volatile__
-		("mov           a5, %4\n\t" /* preserve fn in a5 */
-		 "mov           a6, %3\n\t" /* preserve and setup arg in a6 */
-		 "movi		a2, %1\n\t" /* load __NR_clone for syscall*/
-		 "mov		a3, sp\n\t" /* sp check and sys_clone */
-		 "mov		a4, %5\n\t" /* load flags for syscall */
-		 "syscall\n\t"
-		 "beq		a3, sp, 1f\n\t" /* branch if parent */
-		 "callx4	a5\n\t"     /* call fn */
-		 "movi		a2, %2\n\t" /* load __NR_exit for syscall */
-		 "mov		a3, a6\n\t" /* load fn return value */
-		 "syscall\n"
-		 "1:\n\t"
-		 "mov		%0, a2\n\t" /* parent returns zero */
-		 :"=r" (retval)
-		 :"i" (__NR_clone), "i" (__NR_exit),
-		 "r" (arg), "r" (fn),
-		 "r" (flags | CLONE_VM)
-		 : "a2", "a3", "a4", "a5", "a6" );
-	return retval;
-}
-
-
-/*
  * These bracket the sleeping functions..
  */
 
@@ -254,7 +231,7 @@ unsigned long get_wchan(struct task_stru
  *
  */
 
-void do_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs,
+void do_copy_regs (xtensa_gregset_t *elfregs,struct pt_regs *regs,
 		   struct task_struct *tsk)
 {
 	int i, n, wb_offset;
@@ -304,10 +281,7 @@ void do_copy_regs (xtensa_gregset_t *elf
 		elfregs->ar[(wb_offset + i) % XCHAL_NUM_AREGS] = regs->areg[i];
 }
 
-void xtensa_elf_core_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs)
-{
-	do_copy_regs ((xtensa_gregset_t *)elfregs, regs, current);
-}
+
 
 
 /* The inverse of do_copy_regs().  No error or sanity checking. */
@@ -331,7 +305,7 @@ void do_restore_regs (xtensa_gregset_t *
 	regs->lend		= elfregs->lend;
 	regs->lcount		= elfregs->lcount;
 	regs->sar		= elfregs->sar;
-	regs->syscall	= elfregs->syscall;
+	regs->syscall		= elfregs->syscall;
 
 	/* Clear everything. */
 
@@ -480,3 +454,43 @@ int  dump_fpu(struct pt_regs *regs, elf_
 {
 	return dump_task_fpu(regs, current, r);
 }
+
+asmlinkage 
+long xtensa_clone(unsigned long clone_flags, unsigned long newsp,
+		  void __user *parent_tid, void *child_tls,
+		  void __user *child_tid, long a5,
+		  struct pt_regs *regs)
+{
+	if (!newsp)
+		newsp = regs->areg[1];
+	return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);
+}
+
+/*
+ * xtensa_execve() executes a new program.
+ */
+
+asmlinkage 
+long xtensa_execve(char __user *name, char __user * __user *argv,
+		   char __user * __user *envp, 
+		   long a3, long a4, long a5,
+		   struct pt_regs *regs)
+{
+	long error;
+	char * filename;
+
+	filename = getname(name);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	// FIXME: release coprocessor??
+	error = do_execve(filename, argv, envp, regs);
+	if (error == 0) {
+		task_lock(current);
+		current->ptrace &= ~PT_DTRACE;
+		task_unlock(current);
+	}
+	putname(filename);
+out:
+	return error;
+}
Index: linux-2.6.10/arch/xtensa/kernel/signal.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/signal.c
+++ linux-2.6.10/arch/xtensa/kernel/signal.c
@@ -1,19 +1,20 @@
-// TODO coprocessor stuff
 /*
- *  linux/arch/xtensa/kernel/signal.c
+ * arch/xtensa/kernel/signal.c
  *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- *  1997-11-28  Modified for POSIX.1b signals by Richard Henderson
- *
- *  Joe Taylor <joe@tensilica.com>
- *  Chris Zankel <chris@zankel.net>
+ * Default platform functions.
  *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
+ * Copyright (C) 2005 Tensilica Inc.
+ * Copyright (C) 1991, 1992  Linus Torvalds
+ * 1997-11-28  Modified for POSIX.1b signals by Richard Henderson
  *
+ * Joe Taylor <joe@tensilica.com>
+ * Chris Zankel <chris@zankel.net>
  */
 
-#include <xtensa/config/core.h>
-#include <xtensa/hal.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -46,39 +47,20 @@ extern struct task_struct *coproc_owners
  * Atomically swap in the new signal mask, and wait for a signal.
  */
 
-int sys_sigsuspend(struct pt_regs *regs)
+asmlinkage long xtensa_rt_sigsuspend(sigset_t __user *unewset, 
+    				     size_t sigsetsize,
+    				     long a2, long a3, long a4, long a5, 
+				     struct pt_regs *regs)
 {
-	old_sigset_t mask = (old_sigset_t) regs->areg[3];
-	sigset_t saveset;
-
-	mask &= _BLOCKABLE;
-	spin_lock_irq(&current->sighand->siglock);
-	saveset = current->blocked;
-	siginitset(&current->blocked, mask);
-	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
-
-	regs->areg[2] = -EINTR;
-	while (1) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule();
-		if (do_signal(regs, &saveset))
-			return -EINTR;
-	}
-}
-
-asmlinkage int
-sys_rt_sigsuspend(struct pt_regs *regs)
-{
-	sigset_t *unewset = (sigset_t *) regs->areg[4];
-	size_t sigsetsize = (size_t) regs->areg[3];
 	sigset_t saveset, newset;
+
 	/* XXX: Don't preclude handling different sized sigset_t's.  */
 	if (sigsetsize != sizeof(sigset_t))
 		return -EINVAL;
 
 	if (copy_from_user(&newset, unewset, sizeof(newset)))
 		return -EFAULT;
+
 	sigdelsetmask(&newset, ~_BLOCKABLE);
 	spin_lock_irq(&current->sighand->siglock);
 	saveset = current->blocked;
@@ -95,48 +77,11 @@ sys_rt_sigsuspend(struct pt_regs *regs)
 	}
 }
 
-asmlinkage int
-sys_sigaction(int sig, const struct old_sigaction *act,
-	      struct old_sigaction *oact)
+asmlinkage long xtensa_sigaltstack(const stack_t __user *uss, 
+				   stack_t __user *uoss,
+    				   long a2, long a3, long a4, long a5,
+				   struct pt_regs *regs)
 {
-	struct k_sigaction new_ka, old_ka;
-	int ret;
-
-	if (act) {
-		old_sigset_t mask;
-		if (verify_area(VERIFY_READ, act, sizeof(*act)) ||
-		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
-		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
-			return -EFAULT;
-		__get_user(new_ka.sa.sa_flags, &act->sa_flags);
-		__get_user(mask, &act->sa_mask);
-		siginitset(&new_ka.sa.sa_mask, mask);
-	}
-
-	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
-
-	if (!ret && oact) {
-		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
-		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
-		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
-			return -EFAULT;
-		__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
-		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
-	}
-
-	return ret;
-}
-
-asmlinkage int
-sys_sigaltstack(struct pt_regs *regs)
-{
-	const stack_t *uss = (stack_t *) regs->areg[4];
-	stack_t *uoss = (stack_t *) regs->areg[3];
-
-	if (regs->depc > 64)
-		panic ("Double exception sys_sigreturn\n");
-
-
 	return do_sigaltstack(uss, uoss, regs->areg[1]);
 }
 
@@ -145,16 +90,6 @@ sys_sigaltstack(struct pt_regs *regs)
  * Do a signal return; undo the signal stack.
  */
 
-struct sigframe
-{
-	struct sigcontext sc;
-	struct _cpstate cpstate;
-	unsigned long extramask[_NSIG_WORDS-1];
-	unsigned char retcode[6];
-	unsigned int reserved[4]; /* Reserved area for chaining */
-	unsigned int window[4]; /* Window of 4 registers for initial context */
-};
-
 struct rt_sigframe
 {
 	struct siginfo info;
@@ -236,7 +171,7 @@ restore_sigcontext(struct pt_regs *regs,
 	err |= __copy_from_user (regs->areg, sc->sc_areg, XCHAL_NUM_AREGS*4);
 	err |= __get_user(buf, &sc->sc_cpstate);
 	if (buf) {
-		if (verify_area(VERIFY_READ, buf, sizeof(*buf)))
+		if (!access_ok(VERIFY_READ, buf, sizeof(*buf)))
 			goto badframe;
 		err |= restore_cpextra(buf);
 	}
@@ -323,7 +258,6 @@ setup_sigcontext(struct sigcontext *sc, 
 	struct thread_struct *thread;
 	int err = 0;
 
-//printk("setup_sigcontext\n");
 #define COPY(x)	err |= __put_user(regs->x, &sc->sc_##x)
 	COPY(pc);
 	COPY(ps);
@@ -350,39 +284,9 @@ setup_sigcontext(struct sigcontext *sc, 
 	return err;
 }
 
-asmlinkage int sys_sigreturn(struct pt_regs *regs)
-{
-	struct sigframe *frame = (struct sigframe *)regs->areg[1];
-	sigset_t set;
-	if (regs->depc > 64)
-		panic ("Double exception sys_sigreturn\n");
-
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
-		goto badframe;
-
-	if (__get_user(set.sig[0], &frame->sc.oldmask)
-	    || (_NSIG_WORDS > 1
-		&& __copy_from_user(&set.sig[1], &frame->extramask,
-				    sizeof(frame->extramask))))
-		goto badframe;
-
-	sigdelsetmask(&set, ~_BLOCKABLE);
 
-	spin_lock_irq(&current->sighand->siglock);
-	current->blocked = set;
-	recalc_sigpending();
-	spin_unlock_irq(&current->sighand->siglock);
-
-	if (restore_sigcontext(regs, &frame->sc))
-		goto badframe;
-	return regs->areg[2];
-
-badframe:
-	force_sig(SIGSEGV, current);
-	return 0;
-}
-
-asmlinkage int sys_rt_sigreturn(struct pt_regs *regs)
+asmlinkage long xtensa_rt_sigreturn(long a0, long a1, long a2, long a3, 
+    				    long a4, long a5, struct pt_regs *regs)
 {
 	struct rt_sigframe *frame = (struct rt_sigframe *)regs->areg[1];
 	sigset_t set;
@@ -394,7 +298,7 @@ asmlinkage int sys_rt_sigreturn(struct p
 		return 0;
 	}
 
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 
 	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
@@ -408,10 +312,12 @@ asmlinkage int sys_rt_sigreturn(struct p
 
 	if (restore_sigcontext(regs, &frame->uc.uc_mcontext))
 		goto badframe;
+
 	ret = regs->areg[2];
 
 	if (__copy_from_user(&st, &frame->uc.uc_stack, sizeof(st)))
 		goto badframe;
+
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
 	do_sigaltstack(&st, NULL, regs->areg[1]);
@@ -439,13 +345,9 @@ get_sigframe(struct k_sigaction *ka, uns
 	return (void *)((sp - frame_size) & -16ul);
 }
 
-#define USE_SIGRETURN		0
-#define USE_RT_SIGRETURN	1
-
 static int
-gen_return_code(unsigned char *codemem, unsigned int use_rt_sigreturn)
+gen_return_code(unsigned char *codemem)
 {
-	unsigned int retcall;
 	int err = 0;
 
 #if 0
@@ -458,7 +360,6 @@ gen_return_code(unsigned char *codemem, 
 #endif /* 0 */
 	{
 
-#if (__NR_sigreturn > 255) || (__NR_rt_sigreturn > 255)
 
 /* The 12-bit immediate is really split up within the 24-bit MOVI
  * instruction.  As long as the above system call numbers fit within
@@ -466,26 +367,25 @@ gen_return_code(unsigned char *codemem, 
  * details.
  */
 
-#error Generating the MOVI instruction below breaks!
+#if __NR_rt_sigreturn > 255
+# error Generating the MOVI instruction below breaks!
 #endif
 
-		retcall = use_rt_sigreturn ? __NR_rt_sigreturn : __NR_sigreturn;
-
 #ifdef __XTENSA_EB__   /* Big Endian version */
-		/* Generate instruction:  MOVI a2, retcall */
+		/* Generate instruction:  MOVI a2, __NR_rt_sigreturn */
 		err |= __put_user(0x22, &codemem[0]);
 		err |= __put_user(0x0a, &codemem[1]);
-		err |= __put_user(retcall, &codemem[2]);
+		err |= __put_user(__NR_rt_sigreturn, &codemem[2]);
 		/* Generate instruction:  SYSCALL */
 		err |= __put_user(0x00, &codemem[3]);
 		err |= __put_user(0x05, &codemem[4]);
 		err |= __put_user(0x00, &codemem[5]);
 
 #elif defined __XTENSA_EL__   /* Little Endian version */
-		/* Generate instruction:  MOVI a2, retcall */
+		/* Generate instruction:  MOVI a2, __NR_rt_sigreturn */
 		err |= __put_user(0x22, &codemem[0]);
 		err |= __put_user(0xa0, &codemem[1]);
-		err |= __put_user(retcall, &codemem[2]);
+		err |= __put_user(__NR_rt_sigreturn, &codemem[2]);
 		/* Generate instruction:  SYSCALL */
 		err |= __put_user(0x00, &codemem[3]);
 		err |= __put_user(0x50, &codemem[4]);
@@ -519,70 +419,9 @@ set_thread_state(struct pt_regs *regs, v
 	regs->areg[8] = (unsigned long) arg3;
 }
 
-static void setup_frame(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs *regs)
-{
-	struct sigframe *frame;
-	int err = 0;
-	int signal;
-
-	frame = get_sigframe(ka, regs->areg[1], sizeof(*frame));
-	if (regs->depc > 64)
-	{
-		printk("!!!!!!! DEPC !!!!!!!\n");
-		return;
-	}
-
-
-	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
-		goto give_sigsegv;
-
-	signal = current_thread_info()->exec_domain
-		&& current_thread_info()->exec_domain->signal_invmap
-		&& sig < 32
-		? current_thread_info()->exec_domain->signal_invmap[sig]
-		: sig;
-
-	err |= setup_sigcontext(&frame->sc, &frame->cpstate, regs, set->sig[0]);
-
-	if (_NSIG_WORDS > 1) {
-		err |= __copy_to_user(frame->extramask, &set->sig[1],
-				      sizeof(frame->extramask));
-	}
-
-	/* Create sys_sigreturn syscall in stack frame */
-	err |= gen_return_code(frame->retcode, USE_SIGRETURN);
-
-	if (err)
-		goto give_sigsegv;
-
-	/* Create signal handler execution context.
-	 * Return context not modified until this point.
-	 */
-	set_thread_state(regs, frame, frame->retcode,
-		ka->sa.sa_handler, signal, &frame->sc, NULL);
-
-	/* Set access mode to USER_DS.  Nomenclature is outdated, but
-	 * functionality is used in uaccess.h
-	 */
-	set_fs(USER_DS);
-
 
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): signal=%d sp=%p pc=%08x\n",
-		current->comm, current->pid, signal, frame, regs->pc);
-#endif
-
-	return;
-
-give_sigsegv:
-	if (sig == SIGSEGV)
-		ka->sa.sa_handler = SIG_DFL;
-	force_sig(SIGSEGV, current);
-}
-
-static void setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
-			   sigset_t *set, struct pt_regs *regs)
+static void setup_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
+			sigset_t *set, struct pt_regs *regs)
 {
 	struct rt_sigframe *frame;
 	int err = 0;
@@ -616,7 +455,7 @@ static void setup_rt_frame(int sig, stru
 	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 
 	/* Create sys_rt_sigreturn syscall in stack frame */
-	err |= gen_return_code(frame->retcode, USE_RT_SIGRETURN);
+	err |= gen_return_code(frame->retcode);
 
 	if (err)
 		goto give_sigsegv;
@@ -687,24 +526,19 @@ int do_signal(struct pt_regs *regs, sigs
 				regs->pc -= 3;
 		}
 	}
-
 	if (signr == 0)
 		return 0;		/* no signals delivered */
 
 	/* Whee!  Actually deliver the signal.  */
-
 	/* Set up the stack frame */
-	if (ka.sa.sa_flags & SA_SIGINFO)
-		setup_rt_frame(signr, &ka, &info, oldset, regs);
-	else
-		setup_frame(signr, &ka, oldset, regs);
+	setup_frame(signr, &ka, &info, oldset, regs);
 
 	if (ka.sa.sa_flags & SA_ONESHOT)
 		ka.sa.sa_handler = SIG_DFL;
 
 	if (!(ka.sa.sa_flags & SA_NODEFER)) {
 		spin_lock_irq(&current->sighand->siglock);
-		sigorsets(&current->blocked, &current->blocked, &ka.sa.sa_mask);
+		sigorsets(&current->blocked,&current->blocked,&ka.sa.sa_mask);
 		sigaddset(&current->blocked, signr);
 		recalc_sigpending();
 		spin_unlock_irq(&current->sighand->siglock);
Index: linux-2.6.10/include/asm-xtensa/bitops.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/bitops.h
+++ linux-2.6.10/include/asm-xtensa/bitops.h
@@ -174,35 +174,43 @@ static __inline__ int test_bit(int nr, c
 	return 1UL & (((const volatile unsigned int *)addr)[nr>>5] >> (nr&31));
 }
 
-#if XCHAL_HAVE_NSAU
 
-static __inline__ int __cntlz (unsigned long x)
+/* Return number of leading zeros: f(0) = 32, f(1) = 31, f(0x8000000)=0 */
+
+
+static __inline__ unsigned long __cntlz (unsigned long x)
 {
+#if XCHAL_HAVE_NSA
+
 	int lz;
 	asm ("nsau %0, %1" : "=r" (lz) : "r" (x));
-	return 31 - lz;
-}
+	return lz;
 
 #else
 
-static __inline__ int __cntlz (unsigned long x)
-{
-	unsigned long sum, x1, x2, x4, x8, x16;
-	x1  = x & 0xAAAAAAAA;
-	x2  = x & 0xCCCCCCCC;
-	x4  = x & 0xF0F0F0F0;
-	x8  = x & 0xFF00FF00;
-	x16 = x & 0xFFFF0000;
-	sum = x2 ? 2 : 0;
-	sum += (x16 != 0) * 16;
-	sum += (x8 != 0) * 8;
-	sum += (x4 != 0) * 4;
-	sum += (x1 != 0);
+	unsigned long sum = 0;
+
+	if (x == 0)
+		return 32;
+
+	sum  = x >> 16 == 0 ? 16 : 0;
+	x    = x >> 16 == 0 ?  x : x >> 16;
+
+	sum += x >>  8 == 0 ?  8 : 0;
+	x    = x >>  8 == 0 ?  x : x >> 8;
+
+	sum += x >>  4 == 0 ?  4 : 0;
+	x    = x >>  4 == 0 ?  x : x >> 4;
+
+	sum += x >>  2 == 0 ?  2 : 0;
+	x    = x >>  2 == 0 ?  x : x >> 2;
+
+	sum += x == 1 ?  1 : 0;
 
 	return sum;
+#endif
 }
 
-#endif
 
 /*
  * ffz: Find first zero in word. Undefined if no zero exists.
@@ -211,9 +219,7 @@ static __inline__ int __cntlz (unsigned 
 
 static __inline__ int ffz(unsigned long x)
 {
-	if ((x = ~x) == 0)
-		return 32;
-	return __cntlz(x & -x);
+	return 31 - __cntlz(~x & -~x);
 }
 
 /*
@@ -222,7 +228,7 @@ static __inline__ int ffz(unsigned long 
 
 static __inline__ int __ffs(unsigned long x)
 {
-	return __cntlz(x & -x);
+	return 31 - __cntlz(x & -x);
 }
 
 /*
@@ -233,7 +239,7 @@ static __inline__ int __ffs(unsigned lon
 
 static __inline__ int ffs(unsigned long x)
 {
-	return __cntlz(x & -x) + 1;
+	return 32 - __cntlz(x & -x);
 }
 
 /*
@@ -243,7 +249,7 @@ static __inline__ int ffs(unsigned long 
 
 static __inline__ int fls (unsigned int x)
 {
-	return __cntlz(x);
+	return 32 - __cntlz(x);
 }
 
 static __inline__ int
@@ -327,9 +333,10 @@ find_next_zero_bit(const unsigned long *
 	if (!size)
 		return result;
 	tmp = *p;
-
 found_first:
 	tmp |= ~0UL << size;
+	if (tmp == ~0UL)
+		return result + size;
 found_middle:
 	return result + ffz(tmp);
 }
Index: linux-2.6.10/include/asm-xtensa/checksum.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/checksum.h
+++ linux-2.6.10/include/asm-xtensa/checksum.h
@@ -88,7 +88,8 @@ static __inline__ unsigned int csum_fold
 		"addi	%0, %0, -1\n\t"
 		"extui	%0, %0, 0, 16\n\t"
 		: "=r" (sum), "=&r" (__dummy)
-		: "0" (sum));
+		: "0" (sum)
+		: "memory");
 	return sum;
 }
 
@@ -124,7 +125,8 @@ static __inline__ unsigned short ip_fast
 	   are modified, we must also specify them as outputs, or gcc
 	   will assume they contain their original values. */
 		: "=r" (sum), "=r" (iph), "=r" (ihl), "=&r" (tmp), "=&r" (endaddr)
-		: "1" (iph), "2" (ihl));
+		: "1" (iph), "2" (ihl)
+		: "memory");
 
 	return	csum_fold(sum);
 }
@@ -156,7 +158,8 @@ static __inline__ unsigned long csum_tcp
 		"addi	%0, %0, 1\n\t"
 		"1:\t"
 		: "=r" (sum), "=r" (len_proto)
-		: "r" (daddr), "r" (saddr), "1" (len_proto), "0" (sum));
+		: "r" (daddr), "r" (saddr), "1" (len_proto), "0" (sum)
+		: "memory");
 	return sum;
 }
 
@@ -241,7 +244,8 @@ static __inline__ unsigned short int csu
 		"1:\t"
 		: "=r" (sum), "=&r" (__dummy)
 		: "r" (saddr), "r" (daddr),
-		  "r" (htonl(len)), "r" (htonl(proto)), "0" (sum));
+		  "r" (htonl(len)), "r" (htonl(proto)), "0" (sum)
+		: "memory");
 
 	return csum_fold(sum);
 }
Index: linux-2.6.10/include/asm-xtensa/page.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/page.h
+++ linux-2.6.10/include/asm-xtensa/page.h
@@ -60,27 +60,21 @@ typedef struct { unsigned long pgprot; }
 
 static inline int get_order(unsigned long size)
 {
+#if XCHAL_HAVE_NSA
+      int lz;
+      asm ("nsau %0, %1" : "=r" (lz) : "r" ((size - 1) >> PAGE_SHIFT));
+      return 32 - lz;
+#else
 	int order;
-#ifndef XCHAL_HAVE_NSU
-	unsigned long x1, x2, x4, x8, x16;
 
-	size = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
-	x1  = size & 0xAAAAAAAA;
-	x2  = size & 0xCCCCCCCC;
-	x4  = size & 0xF0F0F0F0;
-	x8  = size & 0xFF00FF00;
-	x16 = size & 0xFFFF0000;
-	order = x2 ? 2 : 0;
-	order += (x16 != 0) * 16;
-	order += (x8 != 0) * 8;
-	order += (x4 != 0) * 4;
-	order += (x1 != 0);
+       size = (size-1) >> (PAGE_SHIFT-1);
+       order = -1;
+       do {
+               size >>= 1;
+               order++;
+       } while (size);
 
 	return order;
-#else
-	size = (size - 1) >> PAGE_SHIFT;
-	asm ("nsau %0, %1" : "=r" (order) : "r" (size));
-	return 32 - order;
 #endif
 }
 
Index: linux-2.6.10/include/asm-xtensa/pgalloc.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/pgalloc.h
+++ linux-2.6.10/include/asm-xtensa/pgalloc.h
@@ -16,6 +16,8 @@
 #include <linux/config.h>
 #include <linux/threads.h>
 #include <linux/highmem.h>
+#include <linux/mm.h>
+
 #include <asm/processor.h>
 #include <asm/cacheflush.h>
 
@@ -93,15 +95,23 @@ pmd_populate(struct mm_struct *mm, pmd_t
 
 #endif
 
+
+#define pmd_alloc_one(mm, addr)         ({ BUG(); ((pmd_t *)2); })
+#define pmd_free(pmd)                 do { } while (0)
+#define __pmd_free_tlb(tlb,x)		do { } while (0)
+
+
 static inline pgd_t*
 pgd_alloc(struct mm_struct *mm)
 {
 	pgd_t *pgd;
 
-	pgd = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, PGD_ORDER);
+	pgd = (pgd_t *)__get_free_pages(GFP_KERNEL, PGD_ORDER);
 
-	if (likely(pgd != NULL))
+	if (likely(pgd != NULL)) {
+		memset(pgd, 0, (PAGE_SIZE << PGD_ORDER));
 		__flush_dcache_page((unsigned long)pgd);
+	}
 
 	return pgd;
 }
Index: linux-2.6.10/include/asm-xtensa/pgtable.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/pgtable.h
+++ linux-2.6.10/include/asm-xtensa/pgtable.h
@@ -93,6 +93,8 @@
  * Entries per page directory level: we use two-level, so
  * we don't really have any PMD directory physically.
  */
+#define PGD_ORDER      0
+#define PMD_ORDER      0
 #define PTRS_PER_PTE		1024
 #define PTRS_PER_PTE_SHIFT	10
 #define PTRS_PER_PMD		1
@@ -218,6 +220,8 @@
 
 #ifndef __ASSEMBLY__
 
+#define pmd_ERROR(e) \
+        printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
 #define pgd_ERROR(e) \
@@ -241,10 +245,10 @@ extern pgd_t swapper_pg_dir[PAGE_SIZE/si
 /*
  * The following only work if pte_present() is true.
  */
-#define pte_none(pte)	 (!(pte_val(pte) ^ (_PAGE_USER | _PAGE_INVALID)))
+#define pte_none(pte)	 (pte_val(pte) == _PAGE_INVALID)
 #define pte_present(pte) ((pte_val(pte) & _PAGE_CACHE_MASK) != _PAGE_INVALID)
-#define pte_clear(mm,addr,ptep)						\
-	do { update_pte(ptep, __pte(_PAGE_USER)); } while(0)
+#define pte_clear(ptep)						\
+	do { update_pte(ptep, __pte(_PAGE_INVALID)); } while(0)
 
 #define pmd_none(pmd)	 (!pmd_val(pmd))
 #define pmd_present(pmd) (pmd_val(pmd) & PAGE_MASK)
@@ -312,6 +316,10 @@ set_pte_at(struct mm_struct *mm, unsigne
 	update_pte(ptep, pteval);
 }
 
+static inline void set_pte(pte_t *ptep, pte_t pteval)
+{
+       *ptep = pteval;
+}
 
 static inline void
 set_pmd(pmd_t *pmdp, pmd_t pmdval)
@@ -322,8 +330,8 @@ set_pmd(pmd_t *pmdp, pmd_t pmdval)
 #endif
 }
 
-extern inline void 
-set_pgd(pgd_t *pgdp, pmd_t pgdval)
+static inline void 
+set_pgd(pgd_t *pgdp, pgd_t pgdval)
 {
 	*pgdp = pgdval;
 #if (DCACHE_WAY_SIZE > PAGE_SIZE) && XCHAL_DCACHE_IS_WRITEBACK
@@ -333,8 +341,7 @@ set_pgd(pgd_t *pgdp, pmd_t pgdval)
 
 
 static inline int
-ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned long addr,
-    			  pte_t *ptep)
+ptep_test_and_clear_young(pte_t *ptep)
 {
 	pte_t pte = *ptep;
 	if (!pte_young(pte))
@@ -344,8 +351,7 @@ ptep_test_and_clear_young(struct vm_area
 }
 
 static inline int
-ptep_test_and_clear_dirty(struct vm_area_struct *vma, unsigned long addr,
-   			  pte_t *ptep)
+ptep_test_and_clear_dirty(pte_t *ptep)
 {
 	pte_t pte = *ptep;
 	if (!pte_dirty(pte))
@@ -355,15 +361,15 @@ ptep_test_and_clear_dirty(struct vm_area
 }
 
 static inline pte_t
-ptep_get_and_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
+ptep_get_and_clear(pte_t *ptep)
 {
 	pte_t pte = *ptep;
-	pte_clear(mm, addr, ptep);
+	pte_clear(ptep);
 	return pte;
 }
 
 static inline void
-ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
+ptep_set_wrprotect(pte_t *ptep)
 {
   	pte_t pte = *ptep;
   	update_pte(ptep, pte_wrprotect(pte));
Index: linux-2.6.10/arch/xtensa/kernel/time.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/time.c
+++ linux-2.6.10/arch/xtensa/kernel/time.c
@@ -68,7 +68,7 @@ void __init time_init(void)
 	 * speed for the CALIBRATE.
 	 */
 
-#if CONFIG_XTENSA_CALIBRATE_CCOUNT
+#ifdef CONFIG_XTENSA_CALIBRATE_CCOUNT
 	printk("Calibrating CPU frequency ");
 	platform_calibrate_ccount();
 	printk("%d.%02d MHz\n", (int)ccount_per_jiffy/(1000000/HZ),
@@ -122,6 +122,7 @@ int do_settimeofday(struct timespec *tv)
 	set_normalized_timespec(&xtime, sec, nsec);
 	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
 
+	//ntp_clear();
 	time_adjust = 0;                /* stop active adjtime() */
 	time_status |= STA_UNSYNC;
 	time_maxerror = NTP_PHASE_LIMIT;
@@ -139,7 +140,7 @@ void do_gettimeofday(struct timeval *tv)
 	unsigned long sec, usec, delta, lost, seq;
 
 	do {
-		seq = read_seqbegin_irqsave(&xtime_lock, flags);
+		seq = read_seqbegin(&xtime_lock);
 
 		delta = get_ccount() - last_ccount_stamp;
 		sec = xtime.tv_sec;
@@ -147,7 +148,7 @@ void do_gettimeofday(struct timeval *tv)
 
 		lost = jiffies - wall_jiffies;
 
-	} while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
+	} while (read_seqretry(&xtime_lock, seq));
 
 	usec += lost * (1000000UL/HZ) + (delta * CCOUNT_NSEC) / NSEC_PER_USEC;
 	for (; usec >= 1000000; sec++, usec -= 1000000)
@@ -184,6 +185,7 @@ again:
 		next += CCOUNT_PER_JIFFY;
 		do_timer (regs); /* Linux handler in kernel/timer.c */
 
+		//if (ntp_synced() &&
 		if ((time_status & STA_UNSYNC) == 0 &&
 		    xtime.tv_sec - last_rtc_update >= 659 &&
 		    abs((xtime.tv_nsec/1000)-(1000000-1000000/HZ))<5000000/HZ &&
Index: linux-2.6.10/arch/xtensa/kernel/traps.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/traps.c
+++ linux-2.6.10/arch/xtensa/kernel/traps.c
@@ -29,6 +29,7 @@
 #include <linux/module.h>
 #include <linux/stringify.h>
 #include <linux/kallsyms.h>
+#include <linux/delay.h>
 
 #include <asm/ptrace.h>
 #include <asm/timex.h>
@@ -74,7 +75,7 @@ extern void system_call (struct pt_regs*
 #define USER		0x02
 
 #define COPROCESSOR(x)							\
-{ XCHAL_EXCCAUSE_COPROCESSOR ## x ## _DISABLED, USER, fast_coprocessor }
+{ EXCCAUSE_COPROCESSOR ## x ## _DISABLED, USER, fast_coprocessor }
 
 typedef struct {
 	int cause;
@@ -84,38 +85,38 @@ typedef struct {
 
 dispatch_init_table_t __init dispatch_init_table[] = {
 
-{ XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION,	0,	   do_illegal_instruction},
-{ XCHAL_EXCCAUSE_SYSTEM_CALL,		KRNL,	   fast_syscall_kernel },
-{ XCHAL_EXCCAUSE_SYSTEM_CALL,		USER,	   fast_syscall_user },
-{ XCHAL_EXCCAUSE_SYSTEM_CALL,		0,	   system_call },
-/* XCHAL_EXCCAUSE_INSTRUCTION_FETCH unhandled */
-/* XCHAL_EXCCAUSE_LOAD_STORE_ERROR unhandled*/
-{ XCHAL_EXCCAUSE_LEVEL1_INTERRUPT,	0,	   do_interrupt },
-{ XCHAL_EXCCAUSE_ALLOCA,		USER|KRNL, fast_alloca },
-/* XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO unhandled */
-/* XCHAL_EXCCAUSE_PRIVILEGED unhandled */
+{ EXCCAUSE_ILLEGAL_INSTRUCTION,	0,	   do_illegal_instruction},
+{ EXCCAUSE_SYSTEM_CALL,		KRNL,	   fast_syscall_kernel },
+{ EXCCAUSE_SYSTEM_CALL,		USER,	   fast_syscall_user },
+{ EXCCAUSE_SYSTEM_CALL,		0,	   system_call },
+/* EXCCAUSE_INSTRUCTION_FETCH unhandled */
+/* EXCCAUSE_LOAD_STORE_ERROR unhandled*/
+{ EXCCAUSE_LEVEL1_INTERRUPT,	0,	   do_interrupt },
+{ EXCCAUSE_ALLOCA,		USER|KRNL, fast_alloca },
+/* EXCCAUSE_INTEGER_DIVIDE_BY_ZERO unhandled */
+/* EXCCAUSE_PRIVILEGED unhandled */
 #if XCHAL_UNALIGNED_LOAD_EXCEPTION || XCHAL_UNALIGNED_STORE_EXCEPTION
 #ifdef CONFIG_UNALIGNED_USER
-{ XCHAL_EXCCAUSE_UNALIGNED,		USER,	   fast_unaligned },
+{ EXCCAUSE_UNALIGNED,		USER,	   fast_unaligned },
 #else
-{ XCHAL_EXCCAUSE_UNALIGNED,		0,	   do_unaligned_user },
+{ EXCCAUSE_UNALIGNED,		0,	   do_unaligned_user },
 #endif
-{ XCHAL_EXCCAUSE_UNALIGNED,		KRNL,	   fast_unaligned },
+{ EXCCAUSE_UNALIGNED,		KRNL,	   fast_unaligned },
 #endif
-{ XCHAL_EXCCAUSE_ITLB_MISS,		0,	   do_page_fault },
-{ XCHAL_EXCCAUSE_ITLB_MISS,		USER|KRNL, fast_second_level_miss},
-{ XCHAL_EXCCAUSE_ITLB_MULTIHIT,		0,	   do_multihit },
-{ XCHAL_EXCCAUSE_ITLB_PRIVILEGE,	0,	   do_page_fault },
-/* XCHAL_EXCCAUSE_SIZE_RESTRICTION unhandled */
-{ XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE,	0,	   do_page_fault },
-{ XCHAL_EXCCAUSE_DTLB_MISS,		USER|KRNL, fast_second_level_miss},
-{ XCHAL_EXCCAUSE_DTLB_MISS,		0,	   do_page_fault },
-{ XCHAL_EXCCAUSE_DTLB_MULTIHIT,		0,	   do_multihit },
-{ XCHAL_EXCCAUSE_DTLB_PRIVILEGE,	0,	   do_page_fault },
-/* XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION unhandled */
-{ XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE,	USER|KRNL, fast_store_prohibited },
-{ XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE,	0,	   do_page_fault },
-{ XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE,	0,	   do_page_fault },
+{ EXCCAUSE_ITLB_MISS,		0,	   do_page_fault },
+{ EXCCAUSE_ITLB_MISS,		USER|KRNL, fast_second_level_miss},
+{ EXCCAUSE_ITLB_MULTIHIT,		0,	   do_multihit },
+{ EXCCAUSE_ITLB_PRIVILEGE,	0,	   do_page_fault },
+/* EXCCAUSE_SIZE_RESTRICTION unhandled */
+{ EXCCAUSE_FETCH_CACHE_ATTRIBUTE,	0,	   do_page_fault },
+{ EXCCAUSE_DTLB_MISS,		USER|KRNL, fast_second_level_miss},
+{ EXCCAUSE_DTLB_MISS,		0,	   do_page_fault },
+{ EXCCAUSE_DTLB_MULTIHIT,		0,	   do_multihit },
+{ EXCCAUSE_DTLB_PRIVILEGE,	0,	   do_page_fault },
+/* EXCCAUSE_DTLB_SIZE_RESTRICTION unhandled */
+{ EXCCAUSE_STORE_CACHE_ATTRIBUTE,	USER|KRNL, fast_store_prohibited },
+{ EXCCAUSE_STORE_CACHE_ATTRIBUTE,	0,	   do_page_fault },
+{ EXCCAUSE_LOAD_CACHE_ATTRIBUTE,	0,	   do_page_fault },
 /* XCCHAL_EXCCAUSE_FLOATING_POINT unhandled */
 #if (XCHAL_CP_MASK & 1)
 COPROCESSOR(0),
@@ -348,12 +349,13 @@ void show_regs(struct pt_regs * regs)
 
 	wmask = regs->wmask & ~1;
 
-	for (i = 0; i < 32; i++) {
-		if (wmask & (1 << (i / 4)))
-			break;
+	for (i = 0; i < 16; i++) {
 		if ((i % 8) == 0)
 			printk ("\n" KERN_INFO "a%02d: ", i);
-		printk("%08lx ", regs->areg[i]);
+		if (wmask & (1 << (i / 4)))
+			printk("xxxxxxxx ");
+		else
+			printk("%08lx ", regs->areg[i]);
 	}
 	printk("\n");
 
@@ -488,8 +490,7 @@ void die(const char * str, struct pt_reg
 
 	if (panic_on_oops) {
 		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(5 * HZ);
+		ssleep(5);
 		panic("Fatal exception");
 	}
 	do_exit(err);
Index: linux-2.6.10/include/asm-xtensa/unistd.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/unistd.h
+++ linux-2.6.10/include/asm-xtensa/unistd.h
@@ -214,8 +214,6 @@ __SYSCALL( 90, sys_mincore, 3)
 __SYSCALL( 91, sys_madvise, 3)
 #define __NR_shmget				 92
 __SYSCALL( 92, sys_shmget, 4)
-#define __NR_shmat				 93
-__SYSCALL( 93, sys_shmat, 4)
 #define __NR_shmctl				 94
 __SYSCALL( 94, sys_shmctl, 4)
 #define __NR_shmdt				 95
@@ -358,8 +356,6 @@ __SYSCALL(157, sys_sched_getaffinity, 3)
 __SYSCALL(158, sys_capget, 2)
 #define __NR_capset 				159
 __SYSCALL(159, sys_capset, 2)
-#define __NR_ptrace 				160
-__SYSCALL(160, xtensa_ptrace, 4)
 #define __NR_semtimedop				161
 __SYSCALL(161, sys_semtimedop, 5)
 #define __NR_semget				162
@@ -485,10 +481,6 @@ __SYSCALL(217, sys_sched_get_priority_mi
 __SYSCALL(218, sys_sched_rr_get_interval, 2)
 #define __NR_sched_yield 			219
 __SYSCALL(219, sys_sched_yield, 0)
-#define __NR_ioprio_set 			220
-__SYSCALL(220, sys_ioprio_set, 0)		// nargs??
-#define __NR_ioprio_get 			221
-__SYSCALL(221, sys_ioprio_get, 0)		// nargs??
 #define __NR_reserved222 			222
 __SYSCALL(222, sys_ni_syscall, 0)
 #define __NR_reserved219 			223
@@ -580,8 +572,6 @@ __SYSCALL(257, sys_request_key, 5)
 __SYSCALL(258, sys_keyctl, 5)
 #define __NR_available259			259
 __SYSCALL(259, sys_ni_syscall, 0)
-#define __NR_kexec_load 			260
-__SYSCALL(260, sys_kexec_load, 5)
 
 #define __NR_syscall_count			261
 
Index: linux-2.6.10/arch/xtensa/kernel/vectors.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/vectors.S
+++ linux-2.6.10/arch/xtensa/kernel/vectors.S
@@ -219,7 +219,7 @@ ENTRY(_DoubleExceptionVector)
 
 	movi	a3, XCHAL_WINDOW_VECTORS_VADDR
 	_bltu	a0, a3, .Lfixup
-	addi	a3, a3, XSHAL_WINDOW_VECTORS_SIZE
+	addi	a3, a3, 0x180		# WINDOW_VECTORS_SIZE
 	_bgeu	a0, a3, .Lfixup
 
 	/* Window overflow/underflow exception. Get stack pointer. */
@@ -312,8 +312,8 @@ ENTRY(_DoubleExceptionVector)
 .Lksp:	/* a0: a0, a1: a1, a2: a2, a3: trashed, depc: depc, excsave: a3 */
 
 	rsr	a3, EXCCAUSE
-	beqi	a3, XCHAL_EXCCAUSE_ITLB_MISS, 1f
-	addi	a3, a3, -XCHAL_EXCCAUSE_DTLB_MISS
+	beqi	a3, EXCCAUSE_ITLB_MISS, 1f
+	addi	a3, a3, -EXCCAUSE_DTLB_MISS
 	bnez	a3, .Lunrecoverable
 1:	movi	a3, fast_second_level_miss_double_kernel
 	jx	a3
Index: linux-2.6.10/arch/xtensa/kernel/xtensa_ksyms.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/xtensa_ksyms.c
+++ linux-2.6.10/arch/xtensa/kernel/xtensa_ksyms.c
@@ -88,10 +88,10 @@ EXPORT_SYMBOL(__umoddi3);
 /*
  * Semaphore operations
  */
-EXPORT_SYMBOL(__down);
-EXPORT_SYMBOL(__down_interruptible);
-EXPORT_SYMBOL(__down_trylock);
-EXPORT_SYMBOL(__up);
+EXPORT_SYMBOL(__compat_down);
+EXPORT_SYMBOL(__compat_down_interruptible);
+EXPORT_SYMBOL(__compat_down_trylock);
+EXPORT_SYMBOL(__compat_up);
 
 #ifdef CONFIG_NET
 /*
Index: linux-2.6.10/arch/xtensa/mm/fault.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/fault.c
+++ linux-2.6.10/arch/xtensa/mm/fault.c
@@ -20,6 +20,9 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/pgalloc.h>
+#include <asm/processor.h>
+
+#define DEBUG_PAGE_FAULT 0
 
 unsigned long asid_cache = ASID_FIRST_VERSION;
 void bad_page_fault(struct pt_regs*, unsigned long, int);
@@ -39,9 +42,18 @@ void do_page_fault(struct pt_regs *regs)
 	unsigned int exccause = regs->exccause;
 	unsigned int address = regs->excvaddr;
 	siginfo_t info;
-
 	int is_write, is_exec;
 
+	is_write = (exccause == EXCCAUSE_STORE_CACHE_ATTRIBUTE) ? 1 : 0;
+	is_exec =  (exccause == EXCCAUSE_ITLB_PRIVILEGE ||
+		    exccause == EXCCAUSE_ITLB_MISS ||
+		    exccause == EXCCAUSE_FETCH_CACHE_ATTRIBUTE) ? 1 : 0;
+
+#if DEBUG_PAGE_FAULT
+	printk("[%s:%d:%08x:%d:%08lx:%s%s]\n", current->comm, current->pid,
+	       address, exccause, regs->pc, is_write? "w":"", is_exec? "x":"");
+#endif
+
 	info.si_code = SEGV_MAPERR;
 
 	/* We fault-in kernel-space virtual memory on-demand. The
@@ -58,16 +70,6 @@ void do_page_fault(struct pt_regs *regs)
 		return;
 	}
 
-	is_write = (exccause == XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE) ? 1 : 0;
-	is_exec =  (exccause == XCHAL_EXCCAUSE_ITLB_PRIVILEGE ||
-		    exccause == XCHAL_EXCCAUSE_ITLB_MISS ||
-		    exccause == XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE) ? 1 : 0;
-
-#if 0
-	printk("[%s:%d:%08x:%d:%08x:%s%s]\n", current->comm, current->pid,
-	       address, exccause, regs->pc, is_write? "w":"", is_exec? "x":"");
-#endif
-
 	down_read(&mm->mmap_sem);
 	vma = find_vma(mm, address);
 
@@ -218,9 +220,11 @@ bad_page_fault(struct pt_regs *regs, uns
 	extern void die(const char*, struct pt_regs*, long);
 	const struct exception_table_entry *entry;
 
+	printk ("bad_page_fault \n");
+
 	/* Are we prepared to handle this kernel fault?  */
 	if ((entry = search_exception_tables(regs->pc)) != NULL) {
-#if 1
+#if DEBUG_PAGE_FAULT
 		printk(KERN_DEBUG "%s: Exception at pc=%#010lx (%lx)\n",
 				current->comm, regs->pc, entry->fixup);
 #endif
Index: linux-2.6.10/arch/xtensa/mm/init.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/mm/init.c
+++ linux-2.6.10/arch/xtensa/mm/init.c
@@ -239,7 +239,7 @@ void __init mem_init(void)
 	high_memory = (void *) __va(max_mapnr << PAGE_SHIFT);
 	highmemsize = 0;
 
-#if CONFIG_HIGHMEM
+#ifdef CONFIG_HIGHMEM
 #error HIGHGMEM not implemented in init.c
 #endif
 
@@ -327,7 +327,6 @@ void show_mem(void)
 /* ------------------------------------------------------------------------- */
 
 #if (DCACHE_WAY_SIZE > PAGE_SIZE)
-
 /*
  * With cache aliasing, the page color of the page in kernel space and user
  * space might mismatch. We temporarily map the page to a different virtual
@@ -473,7 +472,7 @@ void flush_cache_page(struct vm_area_str
 	}
 }
 
-#endif	/* (DCACHE_WAY_SIZE > PAGE_SIZE) */
+#endif
 
 
 pte_t* pte_alloc_one_kernel (struct mm_struct* mm, unsigned long addr)
@@ -483,7 +482,7 @@ pte_t* pte_alloc_one_kernel (struct mm_s
 	       	pte_t* ptep = (pte_t*)(pte_val(*pte) + PAGE_OFFSET);
 		int i;
 		for (i = 0; i < 1024; i++, ptep++)
-			pte_clear(mm, addr, ptep);
+			pte_clear(ptep);
 	}
 	return pte;
 }
@@ -499,7 +498,7 @@ struct page* pte_alloc_one(struct mm_str
 		int i;
 
 		for (i = 0; i < 1024; i++, ptep++)
-			pte_clear(mm, addr, ptep);
+			pte_clear(ptep);
 
 		kunmap_atomic(ptep, KM_USER0);
 	}
Index: linux-2.6.10/arch/xtensa/platform-xt2000/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/xtensa/platform-xt2000/Makefile
@@ -0,0 +1,14 @@
+# $Id: Makefile,v 1.2 2002/09/19 07:06:12 sfoehner Exp $
+#
+# Makefile for the Tensilica XT2000 Emulation Board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are in the main makefile...
+
+obj-y 			= time.o setup.o i2c.o
+obj-$(CONFIG_PCI)	+= pci.o
+## obj-$(CONFIG_KGDB) 	+= gdb_hook.o
+
Index: linux-2.6.10/arch/xtensa/platform-xt2000/i2c.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/xtensa/platform-xt2000/i2c.c
@@ -0,0 +1,242 @@
+/*
+ * arch/xtensa/platform-xt2000/i2c.c
+ *
+ * V320 I2C.
+ *
+ * Copyright (C) 2001 - 2004 Tensilica Inc.
+ *
+ * Kevin Chea <kchea@tensilica.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <asm/platform.h>
+#include <asm/platform/xt2000.h>
+
+#if XCHAL_HAVE_BE
+#define DEFAULT_BASE XTBOARD_V3PCI_PADDR+(0x73^3)
+#else
+#define DEFAULT_BASE XTBOARD_V3PCI_PADDR+(0x73)
+#endif
+
+#define V3USC_SYSTEM_B          *(volatile unsigned char *)(DEFAULT_BASE)
+#define V3USC_SYS_OUT(__byte__) V3USC_SYSTEM_B = (__byte__)
+#define V3USC_SYS_IN()          V3USC_SYSTEM_B
+
+#define SYSTEM_B_SPROM_EN       0x01    /* 1 - Software control         */
+                                        /* 0 - Hardware control         */
+#define SYSTEM_B_SDA_IN         0x02    /* Serial EEPROM data input     */
+#define SYSTEM_B_SDA_IN_SHIFT   1
+#define SYSTEM_B_SDA_OUT        0x04    /* Serial EEPROM data output    */
+                                        /* SPROM_EN must be enabled     */
+#define SYSTEM_B_SCL            0x08    /* Serial EEPROM clock output   */
+#define SYSTEM_B_SCL_IN_SHIFT   3
+#define SYSTEM_B_LOCK		0x40	/* Lock Register Contents set	*/ 
+#define SYSTEM_B_UNLOCK_TOKEN   0xa5
+
+void *memcpy(void *, const void *, unsigned);
+
+#define bit_delay() udelay(10)
+
+static void bit_xt2000_setscl(int state)
+{
+        if (state)
+                V3USC_SYS_OUT(V3USC_SYS_IN() | SYSTEM_B_SCL);
+        else
+                V3USC_SYS_OUT(V3USC_SYS_IN() & ~SYSTEM_B_SCL);
+	bit_delay();
+}
+
+static void bit_xt2000_setsda(int state)
+{
+        if (state)
+                V3USC_SYS_OUT(V3USC_SYS_IN() | SYSTEM_B_SDA_OUT);
+        else
+                V3USC_SYS_OUT(V3USC_SYS_IN() & ~SYSTEM_B_SDA_OUT);
+	bit_delay();
+}
+
+static int bit_xt2000_getsda(void)
+{
+        return ((V3USC_SYS_IN() >> SYSTEM_B_SDA_IN_SHIFT) & 1);
+}
+
+static void i2c_start(void)
+{
+	bit_xt2000_setsda(1);
+	bit_xt2000_setscl(1);
+	bit_xt2000_setsda(0);
+	bit_xt2000_setscl(0);
+}
+
+static void i2c_stop(void)
+{
+	bit_xt2000_setscl(0);
+	bit_xt2000_setsda(0);
+	bit_xt2000_setscl(1);
+	bit_xt2000_setsda(1);
+}
+
+static unsigned i2c_send_byte(unsigned char byte)
+{
+	int i;
+	for (i=0x80; i>0; i>>=1) {
+		bit_xt2000_setsda(byte&i);
+		bit_xt2000_setscl(1);
+		bit_xt2000_setscl(0);
+	}
+	bit_xt2000_setsda(1);
+	bit_xt2000_setscl(1);
+	i = (bit_xt2000_getsda()==0);
+	bit_xt2000_setscl(0);
+	return i;
+}
+
+static unsigned char i2c_recv_byte(void)
+{
+	int i;
+	unsigned char byte = 0;
+	bit_xt2000_setsda(1);
+	for (i = 8; i; i--) {
+		bit_xt2000_setscl(1);
+		byte = (byte << 1) | bit_xt2000_getsda();
+		bit_xt2000_setscl(0);
+	}
+	return byte;
+}
+
+static void i2c_ack(unsigned ack)
+{
+	bit_xt2000_setsda(ack);
+	bit_xt2000_setscl(1);
+	bit_xt2000_setscl(0);
+}
+
+static void i2c_read_data(unsigned id, unsigned char *buf,
+	unsigned addr, unsigned size)
+{
+	int i;
+        char system;
+
+        V3USC_SYS_OUT(SYSTEM_B_UNLOCK_TOKEN);
+        V3USC_SYS_OUT(V3USC_SYS_IN() | SYSTEM_B_SPROM_EN);
+	i2c_start();
+	i2c_send_byte((id << 1) | (0));
+	i2c_send_byte(addr);
+	i2c_start();
+	i2c_send_byte((id << 1) | (1));
+	for(i=0; i<size; i++) {
+		buf[i] = i2c_recv_byte();
+		i2c_ack(i == size-1);
+	}
+	i2c_stop();
+        system = V3USC_SYS_IN() & ~ SYSTEM_B_SPROM_EN;
+        V3USC_SYS_OUT(system);
+        V3USC_SYS_OUT(system | SYSTEM_B_LOCK);
+}
+
+static int i2c_write_data(unsigned id, unsigned char *buf,
+	unsigned addr, unsigned size)
+{
+	int i;
+        char system;
+        V3USC_SYS_OUT(SYSTEM_B_UNLOCK_TOKEN);
+        V3USC_SYS_OUT(V3USC_SYS_IN() | SYSTEM_B_SPROM_EN);
+	i2c_start();
+	i2c_send_byte((id << 1) | (0));
+	i2c_send_byte(addr);
+	for(i=0; i<size; i++)
+		i2c_send_byte(buf[i]);
+	i2c_ack(1);
+	i2c_stop();
+        system = V3USC_SYS_IN() & ~ SYSTEM_B_SPROM_EN;
+        V3USC_SYS_OUT(system);
+        V3USC_SYS_OUT(system | SYSTEM_B_LOCK);
+	return 0;
+}
+
+static const unsigned short crc16_ltab[16] =
+{
+	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
+	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7
+};
+
+static const unsigned short crc16_utab[16] =
+{
+	0x0000, 0x1081, 0x2102, 0x3183, 0x4204, 0x5285, 0x6306, 0x7387,
+	0x8408, 0x9489, 0xa50a, 0xb58b, 0xc60c, 0xd68d, 0xe70e, 0xf78f
+};
+
+static unsigned calc_crc16(char* buf, int len)
+{
+    unsigned short fcs = 0;
+    unsigned char c;
+    while (len--) {
+        c = (fcs ^ *buf++)&0xff;
+        fcs = fcs >> 8 ^ crc16_ltab[c&0x0f] ^ crc16_utab[c>>4];
+    }
+    return fcs;
+}
+
+int platform_get_rtc_time(time_t *time)
+{
+    unsigned char buf[8];
+    i2c_read_data(XT2000_I2C_RTC_ID, buf, 0, 6);
+    if (buf[4]&0x80)
+	return -2;
+    *time = (buf[3]<<24)+(buf[2]<<16)+(buf[1]<<8)+buf[0];
+    return 0;
+}
+
+int platform_set_rtc_time(time_t time)
+{
+    unsigned char buf[8];
+    buf[0] = time&0xff;
+    buf[1] = (time>>8)&0xff;
+    buf[2] = (time>>16)&0xff;
+    buf[3] = (time>>24)&0xff;
+    buf[4] = 0;	/* Enable Oscillator */
+    buf[5] = 0;	/* Disable trickle charger */
+    return i2c_write_data(XT2000_I2C_RTC_ID, buf, 0, 6);
+}
+
+static unsigned nvram_data_valid = 0;
+static struct xt2000_nvram_binfo nvram_data;
+
+unsigned xtboard_nvram_valid(void)
+{
+    if (nvram_data_valid)
+	return 1;
+    i2c_read_data(XT2000_I2C_NVRAM1_ID, (unsigned char *)&nvram_data,
+	XT2000_NVRAM_BINFO_START, XT2000_NVRAM_BINFO_SIZE);
+    if (calc_crc16((char *)&nvram_data, XT2000_NVRAM_BINFO_SIZE)==0)
+	nvram_data_valid = 1;
+
+    return nvram_data_valid;
+}
+
+unsigned xtboard_get_nvram_contents(unsigned char *buf)
+{
+    if (xtboard_nvram_valid());
+	memcpy(buf, &nvram_data, XT2000_NVRAM_BINFO_SIZE);
+    return nvram_data_valid;
+}
+
+#define ETH_ADDR_SIZE  6
+
+void xtboard_get_ether_addr(unsigned char *buf)
+{
+    if (nvram_data_valid)
+	    memcpy(buf, &nvram_data.eth_addr, ETH_ADDR_SIZE);
+    else {
+	    unsigned eth_offset = (unsigned) &nvram_data.eth_addr;
+	    eth_offset -= (unsigned) &nvram_data;
+	    i2c_read_data(XT2000_I2C_NVRAM1_ID, buf, eth_offset, ETH_ADDR_SIZE);
+    }
+}
+
Index: linux-2.6.10/arch/xtensa/platform-xt2000/pci.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/xtensa/platform-xt2000/pci.c
@@ -0,0 +1,434 @@
+/*
+ * arch/xtensa/platform-xt2000/pci.c
+ *
+ * PCI functions for V320USC host PCI bridge
+ *
+ * Copyright (C) 2001 - 2004 Tensilica Inc.
+ *
+ * Chris Zankel <chris@zankel.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/platform/pci.h>
+
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/pci-bridge.h>
+#include <asm/platform/pci.h>
+
+#if XCHAL_HAVE_LE
+#define _V3USCREG_H_CL_
+#elif XCHAL_HAVE_BE
+#define _V3USCREG_H_CB_
+#else
+#error endianess not defined
+#endif
+#include <asm/platform/pci_v320usc.h>
+
+
+extern struct pci_ops v320usc_pci_ops;
+extern void v320usc_pci_init(void);
+
+char *_v3uscp = (char *)PCI_V320_BASE;
+
+static spinlock_t v320usc_lock = SPIN_LOCK_UNLOCKED;
+
+
+/* ------------------------------------------------------------------------- */
+
+/* V320 interrupt device. */
+
+static void v320usc_enable_irq(unsigned int irq)
+{
+	int lirq = irq - XTENSA_NR_IRQS;
+
+	/* INTA..INTC */
+	if (lirq >=0 && lirq <= 2)
+		V3USC_INT_CFG3 |= (INT_CFGX_INT0 << lirq);
+	/* INTD */
+	/* if (lirq == 3) */
+
+}
+
+static unsigned int v320usc_startup_irq(unsigned int irq)
+{
+	v320usc_enable_irq(irq);
+
+	return 0;
+}
+
+static void v320usc_disable_irq(unsigned int irq)
+{
+	int lirq = irq + XTENSA_NR_IRQS;
+
+	if (lirq >=0 && lirq <= 3)
+		V3USC_INT_CFG3 &= ~(INT_CFGX_INT0 << lirq);
+}
+
+static void v320usc_end_irq(unsigned int irq)
+{
+
+}
+
+struct hw_interrupt_type v320usc_irq_type = {
+	"V320USC-IRQ",
+	v320usc_startup_irq,
+	v320usc_disable_irq,		/* shutdown_irq */
+	v320usc_enable_irq,
+	v320usc_disable_irq,
+	v320usc_disable_irq,		/* mask_and_ack */
+	v320usc_end_irq
+};
+
+extern unsigned int do_IRQ(int irq, struct pt_regs *regs);
+
+irqreturn_t v320usc_action(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int cause;
+	int ret = IRQ_NONE;
+
+	cause = V3USC_INT_STAT & V3USC_INT_CFG3;
+
+	if (cause & INT_CFGX_INT0)
+		ret = do_IRQ(XTENSA_NR_IRQS, regs);
+	if (cause & INT_CFGX_INT1)
+		ret = do_IRQ(XTENSA_NR_IRQS+1, regs);
+	if (cause & INT_CFGX_INT2)
+		ret = do_IRQ(XTENSA_NR_IRQS+2, regs);
+
+	V3USC_INT_STAT = 0xFFFFFFFF;
+	return ret;
+}
+
+void __init v320_init_irq(void)
+{
+	int i;
+
+	/* Enable V3_int and intd interrupt */
+
+	writel(readl(XT2000_IMASK_PADDR)|(1<<4)|(1<<5), XT2000_IMASK_PADDR);
+
+	for (i = XTENSA_NR_IRQS; i < NR_IRQS; i++)
+		irq_desc[i].handler = &v320usc_irq_type;
+
+	if(request_irq(XCHAL_EXTINT6_NUM, v320usc_action, 0, "v320usc", 0)) {
+
+		printk(KERN_ERR "Unable to get V320USC IRQ %d for cascade\n",
+		       XCHAL_EXTINT6_NUM);
+	}
+}
+
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Map slot and pin number to an interrupt number. Since we don't do
+ * swizzling, this is fairly easy.
+ */
+
+static int __init map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (pin == 0)
+		return -1;
+	return XTENSA_NR_IRQS + pin - 1;
+}
+
+
+/*
+ * This function initializes the V3 bridge and enumerates the PCI bus.
+ */
+
+void __init platform_pcibios_init(void)
+{
+	struct pci_controller *pci_ctrl;
+
+	/* Setup pci_controller */
+	pci_ctrl = pcibios_alloc_controller();
+
+	if (!pci_ctrl) {
+		printk("PCI: cannot allocate space for the pci controller\n");
+		return;
+	}
+
+ 	/* Move V3USC to 0xFD000000 */
+	V3USC_LB_REG_BASE_W = PCI_V320_BASE >> 16;
+	*(unsigned int*)(XT2000_V3CFG_PADDR) = 0;
+	
+	/* Initialize the V3 */
+	v320usc_pci_init();
+
+	/* Setup the controller */
+	pci_ctrl->first_busno = 0;
+	pci_ctrl->last_busno = 0xff;
+	pci_ctrl->ops = &v320usc_pci_ops;
+	pci_ctrl->map_irq = map_irq;
+
+	pci_ctrl->io_space.start = PCI_IO_SPACE_PCI_BASE;
+	pci_ctrl->io_space.end = PCI_IO_SPACE_PCI_BASE + PCI_IO_SPACE_SIZE;
+	pci_ctrl->io_space.base = PCI_IO_SPACE_CPU_BASE;
+	pci_ctrl->mem_space.start = PCI_MEM_SPACE_PCI_BASE;
+	pci_ctrl->mem_space.end = PCI_MEM_SPACE_PCI_BASE + PCI_MEM_SPACE_SIZE;
+	pci_ctrl->mem_space.base = 0;
+
+	pcibios_init_resource(&pci_ctrl->io_resource,
+			PCI_IO_SPACE_PCI_BASE, 
+			PCI_IO_SPACE_PCI_BASE + PCI_IO_SPACE_SIZE,
+			IORESOURCE_IO, "PCI host bridge");
+	pcibios_init_resource(&pci_ctrl->mem_resources[0],
+			PCI_MEM_SPACE_CPU_BASE, 
+			PCI_MEM_SPACE_CPU_BASE + PCI_MEM_SPACE_SIZE,
+			IORESOURCE_MEM, "PCI host bridge");
+
+	/* Enumerate the PCI bus */
+
+	pci_ctrl->last_busno = pciauto_bus_scan(pci_ctrl,pci_ctrl->first_busno);
+}
+
+/*
+ * The V320USC PCI interface chip provides two windows from the local
+ * bus memory into the PCI 'spaces'.
+ * 
+ * Address                    Usage
+ * 
+ * V3_PCI_LOWER_IO ...        PCI I/O space		- Base0
+ * ... V3_PCI_UPPER_IO
+ * V3_PCI_LOWER_MEM	      PCI MEM space		- Base1
+ * ... V3_PCI_UPPER_MEM
+ * V3_PCI_LOWER_PREFMEM       PCI MEM Prefetch space	- Not Used
+ * ... V3_PCI_UPPER_PREFMEM
+ * V3_PCI_LOWER_CONFIG        PCI Configuration		- Shared with I/O space
+ * ... V3_PCI_UPPER_CONFIG
+ * 
+ * There are only two V3 windows. We use Base0 for PCI I/O and PCI CONFIG space,
+ * and Base1 for the PCI MEMORY space (only in non-prefetch mode).
+ */
+
+
+/* 
+ * Open a configuration window. This temporarily uses the IO aperture window.
+ */
+
+unsigned long v320usc_pci_open_config_window(struct pci_bus *bus, int devfn,
+					     int offset)
+{
+	unsigned long addr, conf;
+	int busnr;
+	
+	busnr = bus->number;
+	conf = PCI_CFG_SPACE_BASE_REG_DEFAULT;
+	
+	/* Trap out illegal values */
+	
+	if (offset > 255 || busnr > 255 || devfn > 255)
+		BUG();
+	
+	if (busnr == 0) {
+		/* Type 0 config cycle: Local busnr segment */
+		unsigned int idsel = 1 << PCI_SLOT(devfn);
+		conf |= (idsel >> 8) & ~0xffff;
+		addr = (idsel & 0x00fff800) | ((devfn & 0x7) << 8);
+	} else {
+		/* Type 1 config cycle: Not the local bus segment */
+		/* a23..a16 = bus nr, a15..a8: device_function nr, a7..a0 = offset */
+		addr = (busnr << 16) | (devfn << 8);
+		conf |= 1;	/* set type 1 config cycle */
+	}
+	/* Set aperture window to config space */
+	V3USC_LB_PCI_BASE0 = conf;
+	V3USC_PCI_STAT_W |= PCI_STAT_W_M_ABORT | PCI_STAT_W_T_ABORT;
+
+	return (unsigned long)PCI_CFG_SPACE_CPU_BASE + addr + offset;
+}
+
+
+/* v320usc_pci_close_config_window()
+ * 
+ * Close the aperture window into the config space and restore
+ * the IO window.
+ */
+
+static inline void v320usc_pci_close_config_window(void)
+{
+	/* Reassign base0 for use by PCI IO space */
+	V3USC_LB_PCI_BASE0 = PCI_IO_SPACE_BASE_REG_DEFAULT;
+}
+
+int v320usc_read_config(struct pci_bus *bus, unsigned int devfn, int offset, 
+			int len, u32 *val)
+{
+	unsigned long addr;
+	unsigned long flags;
+
+        if ((bus->number == 0) && (PCI_SLOT(devfn) < 11))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&v320usc_lock, flags);
+	addr = v320usc_pci_open_config_window(bus, devfn, offset);
+
+	/* Note: the offset (off) is already aligned */
+
+	if (len == 1)
+		*val = (u32) *(volatile u8*)  (addr ^ 3);
+	else if (len == 2) 
+		*val = (u32) *(volatile u16*) (addr ^ 2);
+	else
+		*val = *(volatile u32*) addr;
+
+	v320usc_pci_close_config_window();
+	spin_unlock_irqrestore(&v320usc_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int v320usc_write_config(struct pci_bus *bus, unsigned int devfn, int offset, 
+			 int len, u32 val)
+{
+	unsigned long addr;
+	unsigned long flags;
+
+        if ((bus->number == 0) && (PCI_SLOT(devfn) < 11))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&v320usc_lock, flags);
+	addr = v320usc_pci_open_config_window(bus, devfn, offset);
+
+	if (len == 1)
+		*(volatile u8*)  (addr ^ 3) = val;
+	else if (len == 2) 
+		*(volatile u16*) (addr ^ 2) = val;
+	else
+		*(volatile u32*) addr       = val;
+
+	v320usc_pci_close_config_window();
+	spin_unlock_irqrestore(&v320usc_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+struct pci_ops v320usc_pci_ops = {
+	v320usc_read_config,
+	v320usc_write_config
+};
+
+
+/*
+ * v320usc_pci_init() - Initialize the V320USC device.
+ */
+
+void __init v320usc_pci_init(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&v320usc_lock, flags);
+
+	/* stop the V3 chip from servicing any further PCI requests */
+	V3USC_PCI_CMD_W = 0x0;
+	
+	/* reset the PCI bus */
+	V3USC_SYSTEM_B = 0xa5;
+	V3USC_SYSTEM_B &= ~SYSTEM_B_RST_OUT;
+ 
+	/* enable bridge to PCI, plus error handling */
+	V3USC_PCI_CMD_W = PCI_CMD_W_MASTER_EN
+		| PCI_CMD_W_MEM_EN;
+	//	| PCI_CMD_W_MWI_EN;
+	//      | PCI_CMD_W_SERR_EN
+	//      | PCI_CMD_W_PAR_EN;
+
+	/* clear errors and say we do fast back-to-back transfers */
+	V3USC_PCI_STAT_W = PCI_STAT_W_PAR_ERR
+		| PCI_STAT_W_SYS_ERR
+		| PCI_STAT_W_M_ABORT
+		| PCI_STAT_W_T_ABORT
+		| PCI_STAT_W_PAR_REP
+		| PCI_STAT_W_FAST_BACK;
+
+	/* reset PCI Bus Configuration Register */
+	V3USC_PCI_BUS_CFG = 0x00200000;	
+
+	/* Disable I2O */
+	V3USC_PCI_I2O_MAP = 0;
+	V3USC_PCI_I2O_BASE = 0;
+
+	/* Setup PCI -> Local Memory */
+	V3USC_PCI_MEM_MAP = PCI_LOCAL_MEM_MAP_REG;
+	V3USC_PCI_MEM_BASE = 0;
+
+	/* CPU -> PCI translations. */
+	V3USC_LB_PCI_BASE0 = PCI_IO_SPACE_BASE_REG_DEFAULT;	/* 0: PCI-IO  */
+	V3USC_LB_PCI_BASE1 = PCI_MEM_SPACE_BASE_REG_DEFAULT;	/* 1: PCI-MEM */
+
+	/* Disable PCI access to V3 */
+	V3USC_PCI_REG_BASE = 0;
+  	V3USC_PCI_ROM_BASE = 0;
+	V3USC_PCI_PCU_BASE = 0x0F << PCI_PCU_BASE_SIZE_SHIFT;
+	
+	/* disable CPU -> SDRAM */
+	V3USC_LB_SDRAM_BASE = 0;
+
+	/* Setup SDRAM controller */
+	V3USC_SDRAM_CFG = (0x7 << SDRAM_CFG_REF_NDIV_SHIFT)|
+		SDRAM_CFG_RP_2 |
+		SDRAM_CFG_RCD_2 |
+		SDRAM_CFG_TCAS_RD_2 ;
+
+	V3USC_SDRAM_BANK0 = SDRAM_BANKX_ENABLE |
+		SDRAM_BANKX_SIZE_256M |
+		SDRAM_BANKX_ROW_MUX_MODE_9 |
+		SDRAM_BANKX_COL_MUX_MODE_5;
+ 
+	V3USC_SDRAM_BANK1 = 0x0;
+	V3USC_SDRAM_BANK2 = 0x0;
+	V3USC_SDRAM_BANK3 = 0x0;
+
+	//V3USC_LB_BUS_CFG = 0x80000022;
+	//V3USC_HS_CSR_B = 0x080; /* clear INS bit after reset */
+	V3USC_LB_PCI_CTL_W = PCI_CNT_WR_PCI_FIFO_10
+		| PCI_CNT_RD_PCI_FIFO_00
+		| PCI_CNT_WFLUSH1_11
+		| PCI_CNT_WFLUSH0_11;
+
+	/* clear all interrupts */
+	V3USC_INT_CFG0 = 0x0;
+	V3USC_INT_CFG1 = 0x0;
+	V3USC_INT_CFG2 = 0x0;
+	V3USC_INT_CFG3 = 0x0;
+	V3USC_INT_STAT = 0xFFFFFFFF;
+ 
+	/* finally unreset the PCI bus */
+	V3USC_SYSTEM_B |= SYSTEM_B_RST_OUT;
+ 
+	spin_unlock_irqrestore(&v320usc_lock, flags);
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Initialize v320.
+ */
+
+static int __init xt2000_v320_init(void)
+{
+	v320_init_irq();
+	return 0;
+}
+
+postcore_initcall(xt2000_v320_init);
+
Index: linux-2.6.10/arch/xtensa/platform-xt2000/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/xtensa/platform-xt2000/setup.c
@@ -0,0 +1,112 @@
+// TODO
+/*
+ *
+ * arch/xtensa/platform-xt2000/setup.c
+ *
+ * ...
+ *
+ * Authors:	Chris Zankel <chris@zankel.net>
+ *		Joe Taylor <joe@tensilica.com>
+ *
+ * Copyright 2001 - 2004 Tensilica Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/stringify.h>
+
+#include <asm/processor.h>
+#include <asm/platform.h>
+#include <asm/bootparam.h>
+#include <asm/platform/xt2000.h>
+
+
+/* Assumes s points to an 8-chr string.  No checking for NULL. */
+
+static void led_print (int f, char *s)
+{
+	unsigned long* led_addr = (unsigned long*) (XTBOARD_LED_VADDR+0xE0) + f;
+	int i;
+	for (i = f; i < 8; i++)
+		*led_addr++ = *s++;
+}
+
+void platform_halt(void)
+{
+	led_print (0, "  HALT  ");
+	local_irq_disable();
+	while (1);
+}
+
+void platform_power_off(void)
+{
+	led_print (0, "POWEROFF");
+	local_irq_disable();
+	while (1);
+}
+
+void platform_restart(void)
+{
+	/* Flush and reset the mmu, simulate a processor reset, and
+	 * jump to the reset vector. */
+
+	__asm__ __volatile__ ("movi	a2, 15\n\t"
+			      "wsr	a2, " __stringify(ICOUNTLEVEL) "\n\t"
+			      "movi	a2, 0\n\t"
+			      "wsr	a2, " __stringify(ICOUNT) "\n\t"
+			      "wsr	a2, " __stringify(IBREAKENABLE) "\n\t"
+			      "wsr	a2, " __stringify(LCOUNT) "\n\t"
+			      "movi	a2, 0x1f\n\t"
+			      "wsr	a2, " __stringify(PS) "\n\t"
+			      "isync\n\t"
+			      "jx	%0\n\t"
+			      :
+			      : "a" (XCHAL_RESET_VECTOR_VADDR)
+			      : "a2"
+			      );
+
+	/* control never gets here */
+}
+
+void __init platform_setup(char** cmdline)
+{
+	led_print (0, "LINUX   ");
+}
+
+/* early initialization */
+
+void platform_init(bp_tag_t* first)
+{
+	/* Nothing to be done here. */
+}
+
+/* Heartbeat. Let the LED blink. */
+
+void platform_heartbeat(void)
+{
+	static int i=0, t = 0;
+
+	if (--t < 0)
+	{
+		t = 59;
+		led_print(7, i ? ".": " ");
+		i ^= 1;
+	}
+}
+
+
+
Index: linux-2.6.10/arch/xtensa/platform-xt2000/time.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/xtensa/platform-xt2000/time.c
@@ -0,0 +1,98 @@
+/*
+ * arch/xtensa/platform-xt2000/time.c
+ *
+ * System clock and time.
+ *
+ * Copyright (C) 2001 - 2004 Tensilica Inc.
+ *
+ * Kevin Chea <kchea@tensilica.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/time.h>
+#include <asm/delay.h>
+#include <asm/processor.h>
+#include <asm/platform/xt2000-uart.h>
+
+extern volatile unsigned long wall_jiffies;
+
+#define USECS_PER_JIFFY (1000000/HZ)
+#define TICK_SIZE tick
+
+
+#if CONFIG_XTENSA_CALIBRATE_CCOUNT
+/*
+ *  Before we initialize the UART, use it to measure system clock speed.
+ *  The XT2000's UART crystal should always be 18.432 MHz, but the
+ *  system clock can vary widely.  So we use the UART crystal as
+ *  a reference point to measure system clock rate.
+ *
+ *  The 16552 DUART is put temporarily in loopback mode so we can measure
+ *  character transmission delay without outputting junk on the console.
+ */
+
+void platform_calibrate_ccount(void)
+{
+	uart_dev_t *u = &DUART_1_BASE;
+	unsigned int tstart, tend, tperiod;
+	unsigned char baud_hi, baud_lo, lcr, mcr, fcr;
+
+	/*  Divisor for 100bps loopback speed (turns out to be 11520):  */
+	#define DIV100BPS	DUART_DIVISOR(DUART16552_XTAL_FREQ, 100)
+
+	lcr = _LCR(u);
+
+	_LCR(u) = DLAB_ENABLE;      	/* DLAB=1 on UART1 at least */
+
+	baud_hi = _DLM(u);
+	baud_lo = _DLL(u);
+	mcr = _MCR(u);
+	fcr = _FCR(u);
+
+	_DLL(u) = (DIV100BPS & 0xFF);	/* set baudrate gen. divider LSB */
+	_DLM(u) = (DIV100BPS >> 8);	/* set baudrate gen. divider MSB */
+	_AFR(u) = AFR_CONC_WRITE;	/* enable writes to both ports */
+	_MCR(u) = LOOP_BACK;		/* enable loopback mode */
+	_LCR(u) = 0;			/* DLAB=0 on both ports */
+	_IER(u) = 0;			/* disable interrupts */
+	_FCR(u) = (RCVR_FIFO_RESET | XMIT_FIFO_RESET);
+	_FCR(u) = _FIFO_ENABLE;
+	_LCR(u) = DLAB_ENABLE;		/* DLAB=1 on both ports */
+	_AFR(u) = 0;			/* turn off concurrent writes */
+	_LCR(u) = WORD_LENGTH(8);	/* DLAB=0, 8N1 (10 bits tot per char) */
+
+	/*
+	 *  Send two characters at 10 chars/sec.  The first lets us sync up with
+	 *  the UART clock, and we then measure transmission time of the second
+	 *  character (time from receipt of the 1st to that of the 2nd character).
+	 */
+	_TXB(u) = '@';
+	_TXB(u) = '@';
+	while (!RCVR_READY(u));
+	tstart = get_ccount();
+	_RXB(u);		/* clear Rx ready status */
+	while (!RCVR_READY(u));
+	tend = get_ccount();
+	_RXB(u);		/* clear Rx ready status */
+
+	_LCR(u) = DLAB_ENABLE;
+	_DLM(u) = baud_hi;
+	_DLL(u) = baud_lo;
+	_MCR(u) = mcr;
+	_FCR(u) = fcr;
+	_LCR(u) = lcr;
+	tperiod = (tend - tstart)*10;
+	tperiod += 5000;		/* Round to nearest .01 MHZ */
+	tperiod = tperiod / 10000;
+	tperiod = tperiod * 10000;
+	ccount_per_jiffy = tperiod/HZ;
+	ccount_nsec = 1000000000UL / tperiod;
+}
+#endif
Index: linux-2.6.10/include/asm-xtensa/kgdb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/kgdb.h
@@ -0,0 +1,26 @@
+#ifdef __KERNEL__
+#ifndef _ASM_KGDB_H_
+#define _ASM_KGDB_H_
+
+#include <asm-generic/kgdb.h>
+
+#ifndef __ASSEMBLY__
+#define BUFMAX			2048
+#define NUMREGBYTES		(90*(BITS_PER_LONG/8))
+#define NUMCRITREGBYTES		(12*sizeof(long))
+#define BREAK_INSTR_SIZE	4
+#define BREAKPOINT()		__asm__ __volatile__ (		\
+					".globl breakinst\n\t"	\
+					".set\tnoreorder\n\t"	\
+					"nop\n"			\
+					"breakinst:\tbreak\n\t"	\
+					"nop\n\t"		\
+					".set\treorder")
+#define CHECK_EXCEPTION_STACK()	1
+#define CACHE_FLUSH_IS_SAFE	0
+
+extern int kgdb_early_setup;
+
+#endif				/* !__ASSEMBLY__ */
+#endif				/* _ASM_KGDB_H_ */
+#endif				/* __KERNEL__ */
Index: linux-2.6.10/include/asm-xtensa/relay.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/relay.h
@@ -0,0 +1,5 @@
+#ifndef _ASM_RELAY_H
+#define _ASM_RELAY_H
+
+#include <asm-generic/relay.h>
+#endif
Index: linux-2.6.10/include/asm-xtensa/system.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/system.h
+++ linux-2.6.10/include/asm-xtensa/system.h
@@ -19,13 +19,16 @@
 /* interrupt control */
 
 #define local_save_flags(x)						\
-	__asm__ __volatile__ ("rsr %0,"__stringify(PS) : "=a" (x));
-#define local_irq_restore(x)	do {					\
+	__asm__ __volatile__ ("rsr %0,"__stringify(PS) : "=a" (x))
+
+
+#define local_irq_restore(x)						\
 	__asm__ __volatile__ ("wsr %0, "__stringify(PS)" ; rsync" 	\
-	    		      :: "a" (x) : "memory"); } while(0);
-#define local_irq_save(x)	do {					\
+	    		      :: "a" (x) : "memory")
+
+#define local_irq_save(x)						\
 	__asm__ __volatile__ ("rsil %0, "__stringify(LOCKLEVEL) 	\
-	    		      : "=a" (x) :: "memory");} while(0);
+	    		      : "=a" (x) :: "memory")
 
 static inline void local_irq_disable(void)
 {
@@ -123,6 +126,8 @@ do {						\
  * cmpxchg
  */
 
+#define __HAVE_ARCH_CMPXCHG   1
+
 static inline unsigned long
 __cmpxchg_u32(volatile int *p, int old, int new)
 {
Index: linux-2.6.10/include/asm-xtensa/uaccess.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/uaccess.h
+++ linux-2.6.10/include/asm-xtensa/uaccess.h
@@ -182,6 +182,11 @@
 #define __access_ok(addr,size) (__kernel_ok || __user_ok((addr),(size)))
 #define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
 
+static inline int verify_area(int type, const void * addr, unsigned long size)
+{
+        return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
 /*
  * These are the main single-value transfer routines.  They
  * automatically use the right size if we just have the right pointer
Index: linux-2.6.10/arch/xtensa/kernel/semaphore.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/semaphore.c
+++ linux-2.6.10/arch/xtensa/kernel/semaphore.c
@@ -133,7 +133,7 @@ spinlock_t semaphore_wake_lock;
  * where we want to avoid any extra jumps and calls.
  */
 
-void __up(struct semaphore *sem)
+void __compat_up(struct semaphore *sem)
 {
 	wake_one_more(sem);
 	wake_up(&sem->wait);
@@ -191,7 +191,7 @@ void __up(struct semaphore *sem)
 	tsk->state = TASK_RUNNING;		\
 	remove_wait_queue(&sem->wait, &wait);
 
-void __sched __down(struct semaphore * sem)
+void __sched __compat_down(struct semaphore * sem)
 {
 	DOWN_VAR
 	DOWN_HEAD(TASK_UNINTERRUPTIBLE)
@@ -201,7 +201,7 @@ void __sched __down(struct semaphore * s
 	DOWN_TAIL(TASK_UNINTERRUPTIBLE)
 }
 
-int __sched __down_interruptible(struct semaphore * sem)
+int __sched __compat_down_interruptible(struct semaphore * sem)
 {
 	int ret = 0;
 	DOWN_VAR
@@ -220,7 +220,7 @@ int __sched __down_interruptible(struct 
 	return ret;
 }
 
-int __down_trylock(struct semaphore * sem)
+int __compat_down_trylock(struct semaphore * sem)
 {
 	return waking_non_zero_trylock(sem);
 }
Index: linux-2.6.10/drivers/input/serio/serio.c
===================================================================
--- linux-2.6.10.orig/drivers/input/serio/serio.c
+++ linux-2.6.10/drivers/input/serio/serio.c
@@ -36,6 +36,7 @@
 #include <linux/smp_lock.h>
 #include <linux/suspend.h>
 #include <linux/slab.h>
+#include <linux/semaphore.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
 MODULE_DESCRIPTION("Serio abstraction core");
@@ -114,7 +115,7 @@ enum serio_event_type {
 	SERIO_UNREGISTER_PORT,
 };
 
-static DEFINE_SPINLOCK(serio_event_lock);	/* protects serio_event_list */
+static spinlock_t serio_event_lock = SPIN_LOCK_UNLOCKED;	/* protects serio_event_list */
 static LIST_HEAD(serio_event_list);
 static DECLARE_WAIT_QUEUE_HEAD(serio_wait);
 static DECLARE_COMPLETION(serio_exited);
Index: linux-2.6.10/include/asm-xtensa/bug.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/bug.h
+++ linux-2.6.10/include/asm-xtensa/bug.h
@@ -38,4 +38,6 @@
   }									   \
 } while (0)
 
+# define WARN_ON_RT(condition) do { } while (0)
+
 #endif	/* _XTENSA_BUG_H */
Index: linux-2.6.10/include/asm-xtensa/cacheflush.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/cacheflush.h
+++ linux-2.6.10/include/asm-xtensa/cacheflush.h
@@ -94,7 +94,7 @@ extern void flush_cache_page(struct vm_a
 
 #define flush_dcache_page(page)				do { } while (0)
 
-#define flush_cache_page(vma,addr,pfn)			do { } while (0)
+#define flush_cache_page(vma,addr)			do { } while (0)
 #define flush_cache_range(vma,start,end)		do { } while (0)
 
 #endif
Index: linux-2.6.10/include/asm-xtensa/stat.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/stat.h
+++ linux-2.6.10/include/asm-xtensa/stat.h
@@ -30,76 +30,48 @@ struct __old_kernel_stat {
 #define STAT_HAVE_NSEC 1
 
 struct stat {
-	unsigned short st_dev;
-	unsigned short __pad1;
-	unsigned long st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned short __pad2;
-	unsigned long  st_size;
-	unsigned long  st_blksize;
-	unsigned long  st_blocks;
-	unsigned long  st_atime;
-	unsigned long  st_atime_nsec;
-	unsigned long  st_mtime;
-	unsigned long  st_mtime_nsec;
-	unsigned long  st_ctime;
-	unsigned long  st_ctime_nsec;
-	unsigned long  __unused4;
-	unsigned long  __unused5;
+	unsigned int	st_dev;
+	ino_t		st_ino;
+	mode_t		st_mode;
+	nlink_t		st_nlink;
+	uid_t		st_uid;
+	gid_t		st_gid;
+	unsigned int	st_rdev;
+	off_t		st_size;
+	unsigned long	st_blksize;
+	unsigned long	st_blocks;
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+	unsigned long	__unused4;
+	unsigned long	__unused5;
 };
 
 /* This matches struct stat64 in glibc-2.2.3. */
 
 struct stat64  {
-#ifdef __XTENSA_EL__
-	unsigned short	st_dev;		/* Device */
-	unsigned char	__pad0[10];
-#else
-	unsigned char	__pad0[6];
-	unsigned short	st_dev;
-	unsigned char	__pad1[2];
-#endif
-
-#define STAT64_HAS_BROKEN_ST_INO	1
-	unsigned long __st_ino;		/* 32bit file serial number. */
-
+	unsigned long long st_dev;	/* Device */
+	unsigned long long st_ino;	/* File serial number */
 	unsigned int  st_mode;		/* File mode. */
 	unsigned int  st_nlink;		/* Link count. */
 	unsigned int  st_uid;		/* User ID of the file's owner. */
 	unsigned int  st_gid;		/* Group ID of the file's group. */
-
-#ifdef __XTENSA_EL__
-	unsigned short	st_rdev;	/* Device number, if device. */
-	unsigned char	__pad3[10];
-#else
-	unsigned char	__pad2[6];
-	unsigned short	st_rdev;
-	unsigned char	__pad3[2];
-#endif
-
+	unsigned long long st_rdev;	/* Device number, if device. */
+        unsigned short int __pad2;
 	long long int  st_size;		/* Size of file, in bytes. */
 	long int st_blksize;		/* Optimal block size for I/O. */
-
-#ifdef __XTENSA_EL__
-	unsigned long  st_blocks;	/* Number 512-byte blocks allocated. */
-	unsigned long  __pad4;
-#else
-	unsigned long  __pad4;
-	unsigned long  st_blocks;
-#endif
-
-	unsigned long  __pad5;
-	long int st_atime;		/* Time of last access. */
-	unsigned long  st_atime_nsec;
-	long int st_mtime;		/* Time of last modification. */
-	unsigned long  st_mtime_nsec;
-	long int  st_ctime;		/* Time of last status change. */
-	unsigned long  st_ctime_nsec;
-	unsigned long long int st_ino;	/* File serial number. */
+	long long st_blocks;		/* Number 512-byte blocks allocated. */
+	long st_atime;			/* Time of last access. */
+	unsigned long st_atime_nsec;
+	long st_mtime;			/* Time of last modification. */
+	unsigned long st_mtime_nsec;
+	long st_ctime;			/* Time of last status change. */
+	unsigned long st_ctime_nsec;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
 };
 
 #endif	/* _XTENSA_STAT_H */
Index: linux-2.6.10/include/asm-xtensa/string.h
===================================================================
--- linux-2.6.10.orig/include/asm-xtensa/string.h
+++ linux-2.6.10/include/asm-xtensa/string.h
@@ -15,25 +15,6 @@
 #ifndef _XTENSA_STRING_H
 #define _XTENSA_STRING_H
 
-#define __HAVE_ARCH_STRCPY
-static inline char *strcpy(char *__dest, const char *__src)
-{
-	register char *__xdest = __dest;
-	unsigned long __dummy;
-
-	__asm__ __volatile__("1:\n\t"
-		"l8ui	%2, %1, 0\n\t"
-		"s8i	%2, %0, 0\n\t"
-		"addi	%1, %1, 1\n\t"
-		"addi	%0, %0, 1\n\t"
-		"bnez	%2, 1b\n\t"
-		: "=r" (__dest), "=r" (__src), "=&r" (__dummy)
-		: "0" (__dest), "1" (__src)
-		: "memory");
-
-	return __xdest;
-}
-
 #define __HAVE_ARCH_STRNCPY
 static inline char *strncpy(char *__dest, const char *__src, size_t __n)
 {
Index: linux-2.6.10/kernel/kthread.c
===================================================================
--- linux-2.6.10.orig/kernel/kthread.c
+++ linux-2.6.10/kernel/kthread.c
@@ -12,6 +12,8 @@
 #include <linux/unistd.h>
 #include <linux/file.h>
 #include <linux/module.h>
+
+#include <linux/semaphore.h>
 #include <asm/semaphore.h>
 
 /*
Index: linux-2.6.10/arch/xtensa/kernel/ptrace.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/ptrace.c
+++ linux-2.6.10/arch/xtensa/kernel/ptrace.c
@@ -1,4 +1,3 @@
-// TODO some minor issues
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -22,6 +21,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/security.h>
+#include <linux/signal.h>
 
 #include <asm/pgtable.h>
 #include <asm/page.h>
@@ -44,7 +44,7 @@ void ptrace_disable(struct task_struct *
 	/* Nothing to do.. */
 }
 
-int sys_ptrace(long request, long pid, long addr, long data)
+int xtensa_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
 	int ret = -EPERM;
@@ -107,9 +107,9 @@ int sys_ptrace(long request, long pid, l
 		ret = -EIO;
 		if (copied != sizeof(tmp))
 			break;
-		ret = put_user(tmp,(unsigned long *) data);
+		ret = put_user(tmp,(unsigned long __user *) data);
 
-		goto out;
+		break;
 	}
 
 	/* Read the word at location addr in the USER area.  */
@@ -179,10 +179,10 @@ int sys_ptrace(long request, long pid, l
 		default:
 			tmp = 0;
 			ret = -EIO;
-			goto out;
+			break;
 		}
 		ret = put_user(tmp, (unsigned long *) data);
-		goto out;
+		break;
 		}
 
 	case PTRACE_POKETEXT: /* write the word at location addr. */
@@ -191,7 +191,7 @@ int sys_ptrace(long request, long pid, l
 		    == sizeof(data))
 			break;
 		ret = -EIO;
-		goto out;
+		break;
 
 	case PTRACE_POKEUSR:
 		{
@@ -240,7 +240,8 @@ int sys_ptrace(long request, long pid, l
 	{
 		ret = -EIO;
 		if ((unsigned long) data > _NSIG)
-			break;
+                        break;
+
 		if (request == PTRACE_SYSCALL)
 			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
 		else
@@ -270,7 +271,8 @@ int sys_ptrace(long request, long pid, l
 	case PTRACE_SINGLESTEP:
 		ret = -EIO;
 		if ((unsigned long) data > _NSIG)
-			break;
+                        break;
+
 		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
 		child->ptrace |= PT_SINGLESTEP;
 		child->exit_code = data;
@@ -372,7 +374,7 @@ int sys_ptrace(long request, long pid, l
 
 	default:
 		ret = ptrace_request(child, request, addr, data);
-		goto out;
+		break;
 	}
 out_tsk:
 	put_task_struct(child);
@@ -383,12 +385,6 @@ out:
 
 void do_syscall_trace(void)
 {
-	if (!test_thread_flag(TIF_SYSCALL_TRACE))
-		return;
-
-	if (!(current->ptrace & PT_PTRACED))
-		return;
-
 	/*
 	 * The 0x80 provides a way for the tracing parent to distinguish
 	 * between a syscall stop and SIGTRAP delivery
@@ -405,3 +401,22 @@ void do_syscall_trace(void)
 		current->exit_code = 0;
 	}
 }
+
+void do_syscall_trace_enter(struct pt_regs *regs)
+{
+	if (test_thread_flag(TIF_SYSCALL_TRACE)
+	    && (current->ptrace & PT_PTRACED))
+		do_syscall_trace();
+
+#if 0
+	if (unlikely(current->audit_context))
+		audit_syscall_entry(current, AUDIT_ARCH_XTENSA..);
+#endif
+}
+
+void do_syscall_trace_leave(struct pt_regs *regs)
+{
+	if ((test_thread_flag(TIF_SYSCALL_TRACE))
+	    && (current->ptrace & PT_PTRACED))
+		do_syscall_trace();
+}
Index: linux-2.6.10/arch/xtensa/boot/boot-redboot/bootstrap.S
===================================================================
--- linux-2.6.10.orig/arch/xtensa/boot/boot-redboot/bootstrap.S
+++ linux-2.6.10/arch/xtensa/boot/boot-redboot/bootstrap.S
@@ -1,8 +1,5 @@
 
-#define _ASMLANGUAGE
-#include <xtensa/config/specreg.h>
-#include <xtensa/config/core.h>
-#include <xtensa/cacheasm.h>
+#include <asm/processor.h>
 
 	/*
 	 * RB-Data: RedBoot data/bss
@@ -77,9 +74,13 @@ _start:
 	/* Note: The assembler cannot relax "addi a0, a0, ..." to an
 	   l32r, so we load to a4 first. */
 
-	addi	a4, a0, __start - __start_a0
-	mov	a0, a4
+
+	// addi	a4, a0, __start - __start_a0
+	// mov	a0, a4
+	movi	a4, __start_a0
+	sub	a0, a0, a4
 	movi	a4, __start
+	add	a0, a0, a4
 	movi	a5, __reloc_end
 
 	# a0: address where this code has been loaded
@@ -106,9 +107,26 @@ _start:
 	/* We have to flush and invalidate the caches here before we jump. */
 
 #if XCHAL_DCACHE_IS_WRITEBACK
-	dcache_writeback_all  a5, a6
+	movi	a5, 0
+	movi	a6, XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS
+
+1:	diwb	a5, 0 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 1 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 2 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 3 * XCHAL_DCACHE_LINESIZE
+	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
+	bltu	a5, a6, 1b
 #endif
-	icache_invalidate_all a5, a6
+
+	movi	a5, 0
+	movi	a6, XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS
+
+1:	iii	a5, 0 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 1 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 2 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 3 * XCHAL_DCACHE_LINESIZE
+	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
+	bltu	a5, a6, 1b
 
 	movi	a11, _reloc
 	jx	a11
@@ -208,10 +226,28 @@ _reloc:
 
 	/* jump to the kernel */
 2:
+
 #if XCHAL_DCACHE_IS_WRITEBACK
-	dcache_writeback_all a5, a6
+	movi	a5, 0
+	movi	a6, XCHAL_DCACHE_SIZE / XCHAL_DCACHE_WAYS
+
+1:	diwb	a5, 0 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 1 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 2 * XCHAL_DCACHE_LINESIZE
+	diwb	a5, 3 * XCHAL_DCACHE_LINESIZE
+	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
+	bltu	a5, a6, 1b
 #endif
-	icache_invalidate_all a5, a6
+
+	movi	a5, 0
+	movi	a6, XCHAL_ICACHE_SIZE / XCHAL_ICACHE_WAYS
+
+1:	iii	a5, 0 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 1 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 2 * XCHAL_DCACHE_LINESIZE
+	iii	a5, 3 * XCHAL_DCACHE_LINESIZE
+	addi	a5, a5, XCHAL_DCACHE_LINESIZE * 4
+	bltu	a5, a6, 1b
 
 	movi	a5, __start
 	movi	a3, boot_initrd_start
Index: linux-2.6.10/drivers/net/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/net/Kconfig
+++ linux-2.6.10/drivers/net/Kconfig
@@ -544,6 +544,12 @@ config HAPPYMEAL
 	  To compile this driver as a module, choose M here: the module
 	  will be called sunhme.
 
+config XT2000_SONIC
+        tristate "Xtensa XT2000 sonic ethernet support"
+        depends on NET_ETHERNET && XTENSA_PLATFORM_XT2000
+        help
+          If you have an XT2000 board, you probably want to enable this driver.
+
 config SUNBMAC
 	tristate "Sun BigMAC 10/100baseT support (EXPERIMENTAL)"
 	depends on NET_ETHERNET && SBUS && EXPERIMENTAL
Index: linux-2.6.10/drivers/net/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/net/Makefile
+++ linux-2.6.10/drivers/net/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_SK_G16) += sk_g16.o
 obj-$(CONFIG_HP100) += hp100.o
 obj-$(CONFIG_SMC9194) += smc9194.o
 obj-$(CONFIG_FEC) += fec.o
+obj-$(CONFIG_XT2000_SONIC) += xt2000_sonic.o
 obj-$(CONFIG_68360_ENET) += 68360enet.o
 obj-$(CONFIG_ARM_ETHERH) += 8390.o
 obj-$(CONFIG_WD80x3) += wd.o 8390.o
Index: linux-2.6.10/drivers/net/xt2000_sonic.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xt2000_sonic.c
@@ -0,0 +1,296 @@
+/*
+ * xtsonic.c
+ *
+ * (C) 2001 - 2003 Tensilica Inc.
+ *	by Kevin Chea <kchea@yahoo.com> (2001)
+ *	by Marc Gauthier (marc@tensilica.com, marc@alumni.uwaterloo.ca) (2003)
+ *
+ * (C) 1996,1998 by Thomas Bogendoerfer (tsbogend@alpha.franken.de)
+ * 
+ * This driver is based on work from Andreas Busse, but most of
+ * the code is rewritten.
+ * 
+ * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)
+ *
+ * A driver for the onboard Sonic ethernet controller on the XT2000.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/pci.h>
+#include <asm/platform/xt2000.h>
+
+#define SONIC_MODE32
+
+#undef SONIC_DEBUG 
+
+#define SONIC_MEM_SIZE 0x100
+
+extern unsigned xtboard_nvram_valid(void);
+extern void xtboard_get_ether_addr(unsigned char *buf);
+
+#include "sonic.h"
+
+/*
+ *      SONIC uses a normal IRQ
+ */
+#define sonic_request_irq       request_irq
+#define sonic_free_irq          free_irq
+
+#define CPHYSADDR(x) (x)
+#define vdma_alloc(vaddr,len)						\
+	pci_map_single(NULL, vaddr, len + 4, PCI_DMA_TODEVICE)
+#define vdma_sync(vaddr,len)						\
+	pci_map_single(NULL, vaddr, len + 4, PCI_DMA_FROMDEVICE)
+#define vdma_free(baz)
+
+#define sonic_chiptomem(x)      phys_to_virt(x);
+#undef flush_cache_all
+#define flush_cache_all()
+
+
+/*
+ * Macros to access SONIC registers
+ */
+#define SONIC_READ(reg) \
+	(0xffff & *((volatile unsigned int *)base_addr+reg))
+
+#define SONIC_WRITE(reg,val) \
+	*((volatile unsigned int *)base_addr+reg) = val
+
+/* use 0 for production, 1 for verification, >2 for debug */
+#ifdef SONIC_DEBUG
+static unsigned int sonic_debug = SONIC_DEBUG;
+#else 
+static unsigned int sonic_debug = 1;
+#endif
+
+/*
+ * We cannot use station (ethernet) address prefixes to detect the
+ * sonic controller since these are board manufacturer depended.
+ * So we check for known Silicon Revision IDs instead. 
+ */
+static unsigned short known_revisions[] =
+{
+  0x101, 			/* SONIC 83934 */
+  0xffff			/* end of list */
+};
+
+/* Index to functions, as function prototypes. */
+
+//extern int sonic_probe(struct net_device *dev);
+static int sonic_probe1(struct net_device *dev, unsigned int base_addr, unsigned int irq);
+
+/*
+ * Probe for a SONIC ethernet controller on an XT2000 board.
+ * Actually probing is superfluous but we're paranoid.
+ */
+static int __devinit sonic_probe(struct net_device *dev)
+{
+    unsigned int base_addr = dev ? dev->base_addr : 0;
+
+    if (base_addr == 0xFFE0)
+	return -ENODEV;  
+    if (base_addr != 0)	/* Check a single specified location. */
+	return sonic_probe1(dev, base_addr, dev->irq);
+    
+    base_addr = SONIC83934_VADDR;
+    if (!check_mem_region(base_addr, 0x100)) {
+	if (sonic_probe1(dev, base_addr, SONIC83934_INTNUM) == 0)
+	    return 0;
+    }
+    return -ENODEV;
+}
+
+static int __init sonic_probe1(struct net_device *dev,
+                               unsigned int base_addr, unsigned int irq)
+{
+    static unsigned version_printed = 0;
+    unsigned int silicon_revision;
+    struct sonic_local *lp;
+    unsigned char *priv;
+    dma_addr_t dma;
+    unsigned int size;
+    int i;
+    
+    /*
+     * get the Silicon Revision ID. If this is one of the known
+     * one assume that we found a SONIC ethernet controller at
+     * the expected location.
+     */
+    silicon_revision = SONIC_READ(SONIC_SR);
+    if (sonic_debug > 1)
+      printk("SONIC Silicon Revision = 0x%04x\n",silicon_revision);
+
+    i = 0;
+    while ((known_revisions[i] != 0xffff) &&
+	   (known_revisions[i] != silicon_revision))
+      i++;
+	
+    if (known_revisions[i] == 0xffff) {
+	printk("SONIC ethernet controller not found (0x%4x)\n",
+	       silicon_revision);
+	return -ENODEV;
+    }
+    
+    request_region(base_addr, SONIC_MEM_SIZE, "SONIC");
+    
+    /* Allocate a new 'dev' if needed. */
+    if (!dev)
+	    return -ENOMEM;
+
+    SET_MODULE_OWNER(dev);
+
+    if (sonic_debug  &&  version_printed++ == 0)
+      printk(version);
+
+    printk("%s: %s found at 0x%08x, ",
+	   dev->name, "SONIC ethernet", base_addr);
+
+    /* Fill in the 'dev' fields. */
+    dev->base_addr = base_addr;
+    dev->irq = irq;
+
+    /*
+     * Put the sonic into software reset, then
+     * retrieve and print the ethernet address.
+     */
+    SONIC_WRITE(SONIC_CMD,SONIC_CR_RST);
+    SONIC_WRITE(SONIC_DCR,SONIC_DCR_WC0|SONIC_DCR_DW|SONIC_DCR_LBR|SONIC_DCR_SBUS);
+    SONIC_WRITE(SONIC_CEP,0);
+    SONIC_WRITE(SONIC_IMR,0);
+
+    if (xtboard_nvram_valid()) {
+	xtboard_get_ether_addr(dev->dev_addr);
+    } else {
+	/* Bogus ethernet address */
+	dev->dev_addr[0]=0x0;
+	dev->dev_addr[1]=0x1;
+	dev->dev_addr[2]=0x2;
+	dev->dev_addr[3]=0x3;
+	dev->dev_addr[4]=0x4;
+	dev->dev_addr[5]=0x5;
+	printk("WARNING: Bogus ");
+    }
+
+    printk("HW Address ");
+    for (i = 0; i < 6; i++) {
+	printk("%2.2x", dev->dev_addr[i]);
+	if (i<5)
+	  printk(":");
+    }
+    
+    printk(" IRQ %d\n", irq);
+    
+    /* Initialize the device structure. */
+    if (dev->priv != NULL)
+	printk("%s: preallocated priv field ignored\n", dev->name);
+
+    /*
+     *  Allocate local private descriptor areas in uncached space.
+     *  The entire structure must be located within the same 64kb segment.
+     *  Because we request consistent memory, the address should be page 
+     *  aligned.
+     */
+    priv = pci_alloc_consistent(NULL, sizeof (struct sonic_local), &dma);
+    lp = (struct sonic_local*) priv;
+
+    /*  For debugging:  */
+    printk("%s: SONIC priv area at 0x%X-0x%X (local 0x%X), dev at 0x%X\n",
+	    dev->name, (unsigned)lp, (unsigned)lp + size, dma, (unsigned) dev);
+
+    memset(lp, 0, sizeof(struct sonic_local));
+
+    /* get the virtual dma address */
+    lp->cda_laddr = dma;
+    lp->tda_laddr = lp->cda_laddr + sizeof (lp->cda);
+    lp->rra_laddr = lp->tda_laddr + sizeof (lp->tda);
+    lp->rda_laddr = lp->rra_laddr + sizeof (lp->rra);
+
+    /* allocate receive buffer area */
+    /* FIXME, maybe we should use skbs */
+    lp->rba = kmalloc(SONIC_NUM_RRS * SONIC_RBSIZE, GFP_KERNEL);
+    if (!lp->rba) {
+	    printk("%s: couldn't allocate receive buffers\n", dev->name);
+	    goto out2;
+    }
+
+    lp->rba_laddr = virt_to_phys(lp->rba);
+    dev->priv = lp;
+
+    dev->open = sonic_open;
+    dev->stop = sonic_close;
+    dev->hard_start_xmit    = sonic_send_packet;
+    dev->get_stats	    = sonic_get_stats;
+    dev->set_multicast_list = &sonic_multicast_list;
+
+    /*
+     * clear tally counter
+     */
+    SONIC_WRITE(SONIC_CRCT,0xffff);
+    SONIC_WRITE(SONIC_FAET,0xffff);
+    SONIC_WRITE(SONIC_MPT,0xffff);
+
+    ether_setup(dev);
+    return 0;
+
+out3:
+	kfree(lp->rba);
+out2:
+	vdma_free(lp->cda_laddr);
+out1:
+	kfree(lp);
+out:
+	release_region(base_addr, SONIC_MEM_SIZE);
+	return -1;
+}
+
+static struct net_device dev_xtsonic = {
+    name:	"",
+    init:	sonic_probe
+};
+
+static int
+xtsonic_init_module(void)
+{
+    if (register_netdev(&dev_xtsonic) != 0) {
+	printk(KERN_WARNING "xtsonic.c: No card found\n");
+	return -ENODEV;
+    }
+    return 0;
+}
+
+static void
+xtsonic_cleanup_module(void)
+{
+    if (dev_xtsonic.priv != NULL) {
+	unregister_netdev(&dev_xtsonic);
+	kfree((char *)dev_xtsonic.priv);
+	dev_xtsonic.priv = NULL;
+    }
+}
+
+module_init(xtsonic_init_module);
+module_exit(xtsonic_cleanup_module);
+
+MODULE_DESCRIPTION("XT2000 Sonic driver.");
+MODULE_LICENSE("GPL");
+
+#include "sonic.c"
Index: linux-2.6.10/drivers/net/sonic.c
===================================================================
--- linux-2.6.10.orig/drivers/net/sonic.c
+++ linux-2.6.10/drivers/net/sonic.c
@@ -92,12 +92,19 @@ static void sonic_tx_timeout(struct net_
 	printk("%s: transmit timed out.\n", dev->name);
 
 	/* Try to restart the adaptor. */
+	/*
+	 * Nasty.  Just reinitializing like this will leak all
+	 * the kernel resources (e.g., skb's) associated with
+	 * the transmit and receive descriptors.
+	 */
 	sonic_init(dev);
 	lp->stats.tx_errors++;
+	lp->tx_full = 0;
 	dev->trans_start = jiffies;
 	netif_wake_queue(dev);
 }
 
+
 /*
  * transmit packet
  */
@@ -323,6 +330,7 @@ static void sonic_rx(struct net_device *
 				lp->stats.rx_dropped++;
 				break;
 			}
+			vdma_sync(pkt_ptr, pkt_len);
 			skb->dev = dev;
 			skb_reserve(skb, 2);	/* 16 byte align */
 			skb_put(skb, pkt_len);	/* Make room */
@@ -494,7 +502,7 @@ static int sonic_init(struct net_device 
 	SONIC_WRITE(SONIC_RRP, rra_start);
 	SONIC_WRITE(SONIC_RWP, rra_end);
 	SONIC_WRITE(SONIC_URRA, lp->rra_laddr >> 16);
-	SONIC_WRITE(SONIC_EOBC, (SONIC_RBSIZE - 2) >> 1);
+	SONIC_WRITE(SONIC_EOBC, SONIC_EOBCSIZE >> 1);
 
 	lp->cur_rra =
 	    lp->rra_laddr + (SONIC_NUM_RRS - 1) * sizeof(sonic_rr_t);
Index: linux-2.6.10/drivers/net/sonic.h
===================================================================
--- linux-2.6.10.orig/drivers/net/sonic.h
+++ linux-2.6.10/drivers/net/sonic.h
@@ -217,8 +217,24 @@
 
 #define	SONIC_END_OF_LINKS	0x0001
 
+/*
+ * The SONIC DP83934C datasheets recommend setting EOBC 2 or 4 bytes less
+ * than the buffer size (for 16-bit and 32-bit modes respectively)
+ * when buffering a single packet per RBA, as this driver does.
+ * And they indicate EOBC must be set to 1518 or 1520 for 16-bit
+ * and 32-bit modes respectively.
+ */
+#ifdef SONIC_MODE32
+#define SONIC_RBSIZE	1524
+#define SONIC_EOBCSIZE	1520
+#define SREGS_PAD(n)	u16 n;
+#else
+#define SONIC_RBSIZE	1520
+#define SONIC_EOBCSIZE	1518
+#define SREGS_PAD(n)
+#endif
 
-#ifdef CONFIG_MACSONIC
+#if defined(CONFIG_MACSONIC) || defined(__XTENSA_EB__)
 /*
  * Big endian like structures on 680x0 Macs
  */
@@ -237,7 +253,7 @@ typedef struct {
  */
 
 typedef struct {
-	SREGS_PAD(pad0);
+	 SREGS_PAD(pad0);
 	u16 rx_status;		/* status after reception of a packet */
 	 SREGS_PAD(pad1);
 	u16 rx_pktlen;		/* length of the packet incl. CRC */
@@ -273,7 +289,7 @@ typedef struct {
  * Describes a Transmit Descriptor
  */
 typedef struct {
-	SREGS_PAD(pad0);
+	 SREGS_PAD(pad0);
 	u16 tx_status;		/* status after transmission of a packet */
 	 SREGS_PAD(pad1);
 	u16 tx_config;		/* transmit configuration for this packet */
@@ -299,7 +315,7 @@ typedef struct {
  */
 
 typedef struct {
-	SREGS_PAD(pad0);
+	 SREGS_PAD(pad0);
 	u16 cam_entry_pointer;
 	 SREGS_PAD(pad1);
 	u16 cam_cap0;
@@ -426,7 +442,7 @@ typedef struct {
  *
  * MSch: use more buffer space for the slow m68k Macs!
  */
-#ifdef CONFIG_MACSONIC
+#if (defined CONFIG_MACSONIC) || (defined CONFIG_XT2000_SONIC)
 #define SONIC_NUM_RRS    32	/* number of receive resources */
 #define SONIC_NUM_RDS    SONIC_NUM_RRS	/* number of receive descriptors */
 #define SONIC_NUM_TDS    32	/* number of transmit descriptors */
@@ -435,7 +451,6 @@ typedef struct {
 #define SONIC_NUM_RDS    SONIC_NUM_RRS	/* number of receive descriptors */
 #define SONIC_NUM_TDS    16	/* number of transmit descriptors */
 #endif
-#define SONIC_RBSIZE   1520	/* size of one resource buffer */
 
 #define SONIC_RDS_MASK   (SONIC_NUM_RDS-1)
 #define SONIC_TDS_MASK   (SONIC_NUM_TDS-1)
Index: linux-2.6.10/arch/xtensa/kernel/asm-offsets.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/asm-offsets.c
+++ linux-2.6.10/arch/xtensa/kernel/asm-offsets.c
@@ -39,6 +39,7 @@ int main(void)
 	DEFINE(PT_LEND, offsetof (struct pt_regs, lend));
 	DEFINE(PT_LCOUNT, offsetof (struct pt_regs, lcount));
 	DEFINE(PT_SAR, offsetof (struct pt_regs, sar));
+	DEFINE(PT_ICOUNTLEVEL, offsetof (struct pt_regs, icountlevel));
 	DEFINE(PT_SYSCALL, offsetof (struct pt_regs, syscall));
 	DEFINE(PT_AREG, offsetof (struct pt_regs, areg[0]));
 	DEFINE(PT_AREG0, offsetof (struct pt_regs, areg[0]));
@@ -87,6 +88,12 @@ int main(void)
 	DEFINE(MM_CONTEXT, offsetof (struct mm_struct, context));
 	BLANK();
 	DEFINE(PT_SINGLESTEP_BIT, PT_SINGLESTEP_BIT);
+	BLANK();
+
+       /* constants */
+       DEFINE(_CLONE_VM, CLONE_VM);
+       DEFINE(_CLONE_UNTRACED, CLONE_UNTRACED);
+
 	return 0;
 }
 
Index: linux-2.6.10/arch/xtensa/kernel/syscalls.c
===================================================================
--- linux-2.6.10.orig/arch/xtensa/kernel/syscalls.c
+++ linux-2.6.10/arch/xtensa/kernel/syscalls.c
@@ -15,45 +15,36 @@
  * Kevin Chea
  *
  */
-
-#define DEBUG	0
-
+#include <asm/uaccess.h>
+#include <asm/syscalls.h>
+#include <asm/unistd.h>
 #include <linux/config.h>
 #include <linux/linkage.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/smp_lock.h>
-#include <linux/mman.h>
-#include <linux/sched.h>
-#include <linux/file.h>
-#include <linux/slab.h>
-#include <linux/utsname.h>
-#include <linux/unistd.h>
 #include <linux/stringify.h>
-#include <linux/syscalls.h>
-#include <linux/sem.h>
-#include <linux/msg.h>
-#include <linux/shm.h>
 #include <linux/errno.h>
-#include <asm/ptrace.h>
-#include <asm/signal.h>
-#include <asm/uaccess.h>
-#include <asm/hardirq.h>
-#include <asm/mman.h>
-#include <asm/shmparam.h>
-#include <asm/page.h>
-
-extern void do_syscall_trace(void);
-typedef int (*syscall_t)(void *a0,...);
-extern syscall_t sys_call_table[];
-extern unsigned char sys_narg_table[];
+#include <linux/syscalls.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/mman.h>
+
+typedef void (*syscall_t)(void);
+
+syscall_t sys_call_table[__NR_syscall_count] /* FIXME __cacheline_aligned */= {
+	[0 ... __NR_syscall_count - 1] = (syscall_t)&sys_ni_syscall,
 
+#undef __SYSCALL
+#define __SYSCALL(nr,symbol,nargs) [ nr ] = (syscall_t)symbol,
+#undef _XTENSA_UNISTD_H
+#undef  __KERNEL_SYSCALLS__
+#include <asm/unistd.h>
+};
+ 
 /*
- * sys_pipe() is the normal C calling standard for creating a pipe. It's not
+ * xtensa_pipe() is the normal C calling standard for creating a pipe. It's not
  * the way unix traditional does this, though.
  */
 
-int sys_pipe(int __user *userfds)
+asmlinkage long xtensa_pipe(int __user *userfds)
 {
 	int fd[2];
 	int error;
@@ -66,11 +57,10 @@ int sys_pipe(int __user *userfds)
 	return error;
 }
 
-/*
- * Common code for old and new mmaps.
- */
-long sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
-	       unsigned long flags, unsigned long fd, unsigned long pgoff)
+
+asmlinkage long xtensa_mmap2(unsigned long addr, unsigned long len, 
+   			     unsigned long prot, unsigned long flags, 
+			     unsigned long fd, unsigned long pgoff)
 {
 	int error = -EBADF;
 	struct file * file = NULL;
@@ -92,178 +82,4 @@ out:
 	return error;
 }
 
-int sys_clone(struct pt_regs *regs)
-{
-	unsigned long clone_flags;
-	unsigned long newsp;
-	int __user *parent_tidptr, *child_tidptr;
-	clone_flags = regs->areg[4];
-	newsp = regs->areg[3];
-	parent_tidptr = (int __user *)regs->areg[5];
-	child_tidptr = (int __user *)regs->areg[6];
-	if (!newsp)
-		newsp = regs->areg[1];
-	return do_fork(clone_flags,newsp,regs,0,parent_tidptr,child_tidptr);
-}
-
-/*
- * sys_execve() executes a new program.
- */
-
-int sys_execve(struct pt_regs *regs)
-{
-	int error;
-	char * filename;
-
-	filename = getname((char *) (long)regs->areg[5]);
-	error = PTR_ERR(filename);
-	if (IS_ERR(filename))
-		goto out;
-	error = do_execve(filename, (char **) (long)regs->areg[3],
-	                  (char **) (long)regs->areg[4], regs);
-	putname(filename);
-
-out:
-	return error;
-}
-
-int sys_uname(struct old_utsname * name)
-{
-	if (name && !copy_to_user(name, &system_utsname, sizeof (*name)))
-		return 0;
-	return -EFAULT;
-}
-
-/*
- * Build the string table for the builtin "poor man's strace".
- */
 
-#if DEBUG
-#define SYSCALL(fun, narg) #fun,
-static char *sfnames[] = {
-#include "syscalls.h"
-};
-#undef SYS
-#endif
-
-void system_call (struct pt_regs *regs)
-{
-	syscall_t syscall;
-	unsigned long parm0, parm1, parm2, parm3, parm4, parm5;
-	int nargs, res;
-	unsigned int syscallnr;
-	int ps;
-
-#if DEBUG
-	int i;
-	unsigned long parms[6];
-	char *sysname;
-#endif
-
-	regs->syscall = regs->areg[2];
-
-	do_syscall_trace();
-
-	/* Have to load after syscall_trace because strace
-	 * sometimes changes regs->syscall.
-	 */
-	syscallnr = regs->syscall;
-
-	parm0 = parm1 = parm2 = parm3 = parm4 = parm5 = 0;
-
-	/* Restore interrupt level to syscall invoker's.
-	 * If this were in assembly, we wouldn't disable
-	 * interrupts in the first place:
-	 */
-	local_save_flags (ps);
-	local_irq_restore((ps & ~XCHAL_PS_INTLEVEL_MASK) |
-			  (regs->ps & XCHAL_PS_INTLEVEL_MASK) );
-
-	if (syscallnr > __NR_Linux_syscalls) {
-		regs->areg[2] = -ENOSYS;
-		return;
-	}
-
-	syscall = sys_call_table[syscallnr];
-	nargs = sys_narg_table[syscallnr];
-
-	if (syscall == NULL) {
-		regs->areg[2] = -ENOSYS;
-		return;
-	}
-
-	/* There shouldn't be more than six arguments in the table! */
-
-	if (nargs > 6)
-		panic("Internal error - too many syscall arguments (%d)!\n",
-		      nargs);
-
-	/* Linux takes system-call arguments in registers.  The ABI
-         * and Xtensa software conventions require the system-call
-         * number in a2.  If an argument exists in a2, we move it to
-         * the next available register.  Note that for improved
-         * efficiency, we do NOT shift all parameters down one
-         * register to maintain the original order.
-	 *
-         * At best case (zero arguments), we just write the syscall
-         * number to a2.  At worst case (1 to 6 arguments), we move
-         * the argument in a2 to the next available register, then
-         * write the syscall number to a2.
-	 *
-         * For clarity, the following truth table enumerates all
-         * possibilities.
-	 *
-         * arguments	syscall number	arg0, arg1, arg2, arg3, arg4, arg5
-         * ---------	--------------	----------------------------------
-	 *	0	      a2
-	 *	1	      a2	a3
-	 *	2	      a2	a4,   a3
-	 *	3	      a2	a5,   a3,   a4
-	 *	4	      a2	a6,   a3,   a4,   a5
-	 *	5	      a2	a7,   a3,   a4,   a5,   a6
-	 *	6	      a2	a8,   a3,   a4,   a5,   a6,   a7
-	 */
-	if (nargs) {
-		parm0 = regs->areg[nargs+2];
-		parm1 = regs->areg[3];
-		parm2 = regs->areg[4];
-		parm3 = regs->areg[5];
-		parm4 = regs->areg[6];
-		parm5 = regs->areg[7];
-	} else /* nargs == 0 */
-		parm0 = (unsigned long) regs;
-
-#if DEBUG
-	parms[0] = parm0;
-	parms[1] = parm1;
-	parms[2] = parm2;
-	parms[3] = parm3;
-	parms[4] = parm4;
-	parms[5] = parm5;
-
-	sysname = sfnames[syscallnr];
-	if (strncmp(sysname, "sys_", 4) == 0)
-		sysname = sysname + 4;
-
-	printk("\017SYSCALL:I:%x:%d:%s  %s(", regs->pc, current->pid,
-	       current->comm, sysname);
-	for (i = 0; i < nargs; i++)
-		printk((i>0) ? ", %#lx" : "%#lx", parms[i]);
-	printk(")\n");
-#endif
-
-	res = syscall((void *)parm0, parm1, parm2, parm3, parm4, parm5);
-
-#if DEBUG
-	printk("\017SYSCALL:O:%d:%s  %s(",current->pid, current->comm, sysname);
-	for (i = 0; i < nargs; i++)
-		printk((i>0) ? ", %#lx" : "%#lx", parms[i]);
-	if (res < 4096)
-		printk(") = %d\n", res);
-	else
-		printk(") = %#x\n", res);
-#endif /* DEBUG */
-
-	regs->areg[2] = res;
-	do_syscall_trace();
-}
Index: linux-2.6.10/include/asm-xtensa/platform-xt2000/hardware.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-xtensa/platform-xt2000/hardware.h
@@ -0,0 +1,35 @@
+/*
+ * include/asm-xtensa/platform-xt2000/hardware.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Tensilica Inc.
+ */
+
+/*
+ * This file contains the hardware configuration of the XT2000 board.
+ */
+
+#ifndef _XTENSA_XT2000_HARDWARE_H
+#define _XTENSA_XT2000_HARDWARE_H
+
+/* 
+ * Memory configuration.
+ */
+
+#define PLATFORM_DEFAULT_MEM_START 0x00000000
+#define PLATFORM_DEFAULT_MEM_SIZE 0x08000000
+
+/*
+ * Interrupt configuration.
+ */
+
+/* The XT2000 uses the V3 as a cascaded interrupt controller for the PCI bus */
+#define PLATFORM_NR_IRQS 3
+#define IRQ_PCI_A (XCHAL_NUM_INTERRUPTS + 0)
+#define IRQ_PCI_B (XCHAL_NUM_INTERRUPTS + 1)
+#define IRQ_PCI_C (XCHAL_NUM_INTERRUPTS + 2)
+
+#endif /* _XTENSA_XT2000_HARDWARE_H */
Index: linux-2.6.10/arch/xtensa/Makefile
===================================================================
--- linux-2.6.10.orig/arch/xtensa/Makefile
+++ linux-2.6.10/arch/xtensa/Makefile
@@ -78,9 +78,10 @@ prepare: $(archinc)/.platform $(archinc)
 # them changed.
 
 $(archinc)/.platform: $(wildcard include/config/arch/*.h) include/config/MARKER
-	@echo '  SYMLINK $(archinc)/xtensa/config -> $(archinc)/xtensa/config-$(CPU)'
+	@echo '  SYMLINK $(archinc)/xtensa/config -> $(archinc)/config-$(CPU)'
 	$(Q)mkdir -p $(archinc)
 	$(Q)mkdir -p $(archinc)/xtensa
+	$(Q)ln -fsn $(srctree)/$(archinc)/xtensa/config-$(CPU) $(archinc)/config
 	$(Q)ln -fsn $(srctree)/$(archinc)/xtensa/config-$(CPU) $(archinc)/xtensa/config
 	@echo '  SYMLINK $(archinc)/platform -> $(archinc)/platform-$(PLATFORM)'
 	$(Q)ln -fsn $(srctree)/$(archinc)/platform-$(PLATFORM) $(archinc)/platform
Index: linux-2.6.10/mvl_patches/pro-1098.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1098.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1098);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

