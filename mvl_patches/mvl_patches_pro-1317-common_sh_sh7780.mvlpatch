#! /usr/bin/env bash
# Patch: -common_sh_sh7780
# Date: Fri May  4 10:06:54 2007
# Source: Renessans 
# MR: 20464
# Type: Integration 
# Disposition: needs submitting to open-source
# Signed-off-by: dmitry pervushin <dpervushin@ru.mvista.com>
# Description:
# 	This is patch for base support of SH7780 board
# 

PATCHNUM=1317
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Renessans 
MR: 20464
Type: Integration 
Disposition: needs submitting to open-source
Signed-off-by: dmitry pervushin <dpervushin@ru.mvista.com>
Description:
	This is patch for base support of SH7780 board

Index: linux-2.6.10/arch/sh/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/sh/Kconfig
+++ linux-2.6.10/arch/sh/Kconfig
@@ -45,6 +45,13 @@ config SH_7751_SOLUTION_ENGINE
 	  Select 7751 SolutionEngine if configuring for a Hitachi SH7751
 	  evalutation board.
 
+config SH_7780_SOLUTION_ENGINE
+	bool "SolutionEngine7780"
+	help
+	  Select 7780 SolutionEngine if configuring for a Hitachi SH7780
+	  evalutation board.
+
+
 config SH_7300_SOLUTION_ENGINE
 	bool "SolutionEngine7300"
 	help
@@ -217,6 +224,9 @@ config CPU_SH4
 
 endchoice
 
+config CPU_SH4A
+ 	bool "SH-4A support"
+
 choice
 	prompt "Processor subtype"
 
@@ -270,6 +280,12 @@ config CPU_SUBTYPE_SH7760
 	bool "SH7760"
 	depends on CPU_SH4
 
+config CPU_SUBTYPE_SH7780
+	bool "SH7780"
+	depends on CPU_SH4
+	help
+	  Select SH7780 if you have a 400 Mhz SH-4A R8A7780 CPU.
+
 config CPU_SUBTYPE_SH73180
        bool "SH73180"
        depends on CPU_SH4
Index: linux-2.6.10/arch/sh/Makefile
===================================================================
--- linux-2.6.10.orig/arch/sh/Makefile
+++ linux-2.6.10/arch/sh/Makefile
@@ -19,8 +19,13 @@ cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	:= -m
 
 cflags-$(CONFIG_CPU_SH2)		+= -m2
 cflags-$(CONFIG_CPU_SH3)		+= -m3
+#ifdef CONFIG_CPU_SH4A
+#cflags-$(CONFIG_CPU_SH4)               += -m4a \
+#       $(call cc-option,-mno-implicit-fp,-m4a-nofpu)
+#else
 cflags-$(CONFIG_CPU_SH4)		+= -m4 \
 	$(call cc-option,-mno-implicit-fp,-m4-nofpu)
+#endif
 
 cflags-$(CONFIG_SH_DSP)			+= -Wa,-dsp
 
@@ -65,6 +70,7 @@ machdir-$(CONFIG_SH_SOLUTION_ENGINE)		:=
 machdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se/7751
 machdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)	:= se/7300
 machdir-$(CONFIG_SH_73180_SOLUTION_ENGINE)	:= se/73180
+machdir-$(CONFIG_SH_7780_SOLUTION_ENGINE)       := se/7780
 machdir-$(CONFIG_SH_STB1_HARP)			:= harp
 machdir-$(CONFIG_SH_STB1_OVERDRIVE)		:= overdrive
 machdir-$(CONFIG_SH_HP620)			:= hp6xx/hp620
@@ -93,6 +99,7 @@ incdir-y			:= $(notdir $(machdir-y))
 
 incdir-$(CONFIG_SH_SOLUTION_ENGINE)		:= se
 incdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se7751
+incdir-$(CONFIG_SH_7780_SOLUTION_ENGINE)       := se7780
 incdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)        := se7300
 incdir-$(CONFIG_SH_73180_SOLUTION_ENGINE)	:= se73180
 incdir-$(CONFIG_SH_HP600)			:= hp6xx
Index: linux-2.6.10/arch/sh/boards/se/7780/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the 7780SE specific parts of the kernel
+#
+
+obj-y	 := mach.o setup.o io.o irq.o led.o
+
+obj-$(CONFIG_PCI) += pci.o
+
Index: linux-2.6.10/arch/sh/boards/se/7780/io.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/io.c
@@ -0,0 +1,157 @@
+/*
+ * linux/arch/sh/boards/se/7780/io.c
+ *
+ * Copyright (C) 2004  Takashi Kusuda
+ *
+ * Based largely on linux/arch/sh/boards/se/77xx/io.c
+ *
+ * I/O routine for Hitachi 7780 SolutionEngine.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/addrspace.h>
+
+#include <linux/pci.h>
+#include <asm/cpu/pci-sh7780.h>
+
+#define PCI_IO_AREA	SH7780_PCI_IO_BASE
+#define PCI_MEM_AREA	SH7780_PCI_MEMORY_BASE
+
+#define SH7780_PCIIOBR_MASK	0xFFE00000
+#define PCI_IOMAP(adr)	(PCI_IO_AREA + (adr & ~SH7780_PCIIOBR_MASK))
+
+
+/* In case someone configures the kernel w/o PCI support: in that */
+/* scenario, don't ever bother to check for PCI-window addresses */
+
+/* NOTE: WINDOW CHECK MAY BE A BIT OFF, HIGH PCIBIOS_MIN_IO WRAPS? */
+#if defined(CONFIG_PCI)
+#define CHECK_SH7780_PCIIO(port) \
+  ((port >= PCIBIOS_MIN_IO) && (port < (PCIBIOS_MIN_IO + SH7780_PCI_IO_SIZE)))
+#define CHECK_SH7780_PCIMEM(addr) \
+  ((addr >= PCIBIOS_MIN_MEM) && (addr < (PCIBIOS_MIN_MEM + SH7780_PCI_MEM_SIZE)))
+#else
+#define CHECK_SH7780_PCIIO(port) (0)
+#define CHECK_SH7780_PCIMEM(addr) (0)
+#endif
+
+
+static inline void delay(void)
+{
+	ctrl_inw(0xa0000000);
+}
+
+static inline unsigned long sh7780se_port2adr(unsigned long port, unsigned char access_size)
+{
+	if (CHECK_SH7780_PCIIO(port)) {
+		/* SH7780 PCI I/O */
+		return PCI_IOMAP(port);
+#if defined(CONFIG_SMC91X)
+	} else if (0x300 <= port && port <= 0x30f) {
+		/* Ethernet SMC LAN91C111 */
+		return (PA_LAN + port);
+#endif
+	} else if (PXSEG(port)) {
+		return port;
+	}
+
+	return (PA_EXT5 + port);
+}
+
+unsigned char sh7780se_inb(unsigned long port)
+{
+	return *(volatile unsigned char *)sh7780se_port2adr(port, 1);
+}
+
+unsigned char sh7780se_inb_p(unsigned long port)
+{
+	unsigned char v = sh7780se_inb(port);
+	delay();
+	return v;
+}
+
+unsigned short sh7780se_inw(unsigned long port)
+{
+	return *(volatile unsigned short *)sh7780se_port2adr(port, 2);
+}
+
+unsigned int sh7780se_inl(unsigned long port)
+{
+	return *(volatile unsigned int *)sh7780se_port2adr(port, 4);
+}
+
+void sh7780se_outb(unsigned char value, unsigned long port)
+{
+	*(volatile unsigned char *)sh7780se_port2adr(port, 1) = value;
+}
+
+void sh7780se_outb_p(unsigned char value, unsigned long port)
+{
+	sh7780se_outb(value, port);
+	delay();
+}
+
+void sh7780se_outw(unsigned short value, unsigned long port)
+{
+	*(volatile unsigned short *)sh7780se_port2adr(port, 2) = value;
+}
+
+void sh7780se_outl(unsigned int value, unsigned long port)
+{
+	*(volatile unsigned int *)sh7780se_port2adr(port, 4) = value;
+}
+
+void sh7780se_insb(unsigned long port, void *addr, unsigned long count)
+{
+	unsigned char *p = addr;
+	while (count--) *p++ = sh7780se_inb(port);
+}
+
+void sh7780se_insw(unsigned long port, void *addr, unsigned long count)
+{
+	unsigned short *p = addr;
+	while (count--) *p++ = sh7780se_inw(port);
+}
+
+void sh7780se_insl(unsigned long port, void *addr, unsigned long count)
+{
+	unsigned int *p = addr;
+	while (count--) *p++ = sh7780se_inl(port);
+}
+
+void sh7780se_outsb(unsigned long port, const void *addr, unsigned long count)
+{
+	unsigned char *p = (unsigned char*)addr;
+	while (count--) sh7780se_outb(*p++, port);
+}
+
+void sh7780se_outsw(unsigned long port, const void *addr, unsigned long count)
+{
+	unsigned short *p = (unsigned short*)addr;
+	while (count--) sh7780se_outw(*p++, port);
+}
+
+void sh7780se_outsl(unsigned long port, const void *addr, unsigned long count)
+{
+	unsigned int *p = (unsigned int*)addr;
+	while (count--) sh7780se_outl(*p++, port);
+}
+
+void * sh7780se_ioremap(unsigned long offset, unsigned long size)
+{
+	if(offset >= 0xfd000000)
+		return (void *)offset;
+	else
+		return (void *)P2SEGADDR(offset);
+}
+
+void sh7780se_iounmap(void *addr)
+{
+}
+
+EXPORT_SYMBOL(sh7780se_iounmap);
+EXPORT_SYMBOL(sh7780se_ioremap);
+
Index: linux-2.6.10/arch/sh/boards/se/7780/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/irq.c
@@ -0,0 +1,79 @@
+/*
+ * linux/arch/sh/boards/se/7780/irq.c
+ *
+ * Copyright (C) 2005  Takashi Kusuda (Feb.4 2005)
+ *
+ * Hitachi SH7780 SolutionEngine Support.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+/*
+ * interrupt demuxer
+ */
+int sh7780se_irq_demux(int irq)
+{
+	return irq;
+}
+
+/*
+ * Initialize IRQ setting
+ */
+void __init init_sh7780se_IRQ(void)
+{
+    /* setup SH7780 INTC (board depends). INTC2 initialized at "init_IRQ()" */
+    ctrl_outl(0x00C00020, INTC_ICR0);       /* ICR0: IRL=use separately */
+
+#if defined(CONFIG_SH7780_1ST_CUT)
+    ctrl_outl(0xFFFF0000, INTC_ICR1);	/* ICR1: detect low level(for 1stcut) */
+#else
+    ctrl_outl(0xAAAA0000, INTC_ICR1);	/* ICR1: detect low level(for 2ndcut) */
+#endif
+    ctrl_outl(0x33333333, INTC_INTPRI);	/* INTPRI: priority=3(all) */
+
+    /* interrupt controlled at CPU's INTC(INTC2) */
+    ctrl_outw(0, FPGA_INTMSK1); /* enable all interrupt at FPGA */
+    ctrl_outw((ctrl_inw(FPGA_INTMSK1) | 0x0002), FPGA_INTMSK1); /* mask SM501 interrupt */
+    ctrl_outw(0, FPGA_INTMSK2); /* enable all interrupt at FPGA */
+
+    /*
+     * IRQ0:  daughter board EXTINT1
+     * IRQ1:  daughter board EXTINT2
+     * IRQ2:  daughter board EXTINT3
+     * IRQ3:  LAN (SMC91C111)
+     * IRQ4:  daughter board EXTINT4
+     * IRQ5:  PC Card 0
+     * IRQ6:  PC Card 2
+     * IRQ7:  SM501/PC Card PowerIC
+     */
+
+    /* set FPGA INTSEL register */
+    ctrl_outw(((IRQPIN_PCC2 << IRQPOS_PCC2) |
+	       (IRQPIN_PCC0 << IRQPOS_PCC0) |
+	       (IRQPIN_SM501 << IRQPOS_SM501) |
+	       (IRQPIN_SMC91CX << IRQPOS_SMC91CX)), FPGA_INTSEL1);
+
+    ctrl_outw(((IRQPIN_EXTINT4 << IRQPOS_EXTINT4) |
+	       (IRQPIN_EXTINT3 << IRQPOS_EXTINT3) |
+	       (IRQPIN_EXTINT2 << IRQPOS_EXTINT2) |
+	       (IRQPIN_EXTINT1 << IRQPOS_EXTINT1)), FPGA_INTSEL2);
+
+    ctrl_outw((IRQPIN_PCCPW << IRQPOS_PCCPW), FPGA_INTSEL3);
+
+    /* register IRQ interrupts */
+    make_sh4a_intc_irq(SH7780_IRQ0_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ0_POS);
+    make_sh4a_intc_irq(SH7780_IRQ1_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ1_POS);
+    make_sh4a_intc_irq(SH7780_IRQ2_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ2_POS);
+    make_sh4a_intc_irq(SH7780_IRQ3_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ3_POS);
+    make_sh4a_intc_irq(SH7780_IRQ4_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ4_POS);
+    make_sh4a_intc_irq(SH7780_IRQ5_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ5_POS);
+    make_sh4a_intc_irq(SH7780_IRQ6_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ6_POS);
+    make_sh4a_intc_irq(SH7780_IRQ7_INTNUM, INTC_INTMSK0, INTC_INTMSKCLR0, SH7780_IRQ7_POS);
+}
+
Index: linux-2.6.10/arch/sh/boards/se/7780/led.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/led.c
@@ -0,0 +1,70 @@
+/*
+ * linux/arch/sh/boards/se/7780/led.c
+ *
+ * Copyright (C) 2000 Stuart Menefy <stuart.menefy@st.com>
+ * Copyright (C) 2004 Takashi Kusuda
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * This file contains SH7780 Solution Engine specific LED code.
+ */
+
+#include <linux/config.h>
+#include <asm/mach/map.h>
+
+static void mach_led(int position, int value)
+{
+	volatile unsigned short* p = (volatile unsigned short*)FPGA_DBG_LED;
+
+	if (value) {
+		*p &= ~1;
+	} else {
+		*p |= 1;
+	}
+}
+
+#ifdef CONFIG_HEARTBEAT
+
+#define LED_CHAR_NUM	24
+static char disp_chars[LED_CHAR_NUM] = " SH-Linux on MS7780SE03 ";
+static int disp_chars_start_pos = 0;
+
+#include <linux/sched.h>
+
+/* Cycle the LED's in the clasic Knightrider/Sun pattern */
+void heartbeat_7780se(void)
+{
+	static unsigned int cnt = 0, period = 0;
+	int i, tmp;
+	unsigned short offset;
+
+	cnt += 1;
+	if (cnt < period) {
+		return;
+	}
+
+	cnt = 0;
+
+	/* Go through the points (roughly!):
+	 * f(0)=10, f(1)=16, f(2)=20, f(5)=35,f(inf)->110
+	 */
+	period = 165 - ( (300<<FSHIFT)/
+			 ((avenrun[0]/5) + (3<<FSHIFT)) );
+
+
+	for (i=0; i < 8; i++){
+		if((disp_chars_start_pos + i) >= LED_CHAR_NUM)
+			tmp = disp_chars_start_pos + i - LED_CHAR_NUM;
+		else
+			tmp = disp_chars_start_pos + i;
+		offset = ((7<<3) + i)<<1;
+		*(volatile unsigned short *)(PA_LED_DISP + offset) = disp_chars[tmp];
+	}
+
+	if(disp_chars_start_pos < (LED_CHAR_NUM-1))
+		disp_chars_start_pos++;
+	else
+		disp_chars_start_pos = 0;
+}
+#endif /* CONFIG_HEARTBEAT */
Index: linux-2.6.10/arch/sh/boards/se/7780/mach.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/mach.c
@@ -0,0 +1,63 @@
+/*
+ * linux/arch/sh/boards/se/7780/mach.c
+ *
+ * Copyright (C)  Takashi Kusuda (Nov, 2004)
+ *
+ * Machine vector for the Hitachi 7780 SolutionEngine
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+
+#include <asm/machvec.h>
+#include <asm/rtc.h>
+#include <asm/machvec_init.h>
+
+#include <asm/se7780/io.h>
+#include <asm/irq.h>
+
+void heartbeat_7780se(void);
+void init_sh7780se_IRQ(void);
+int sh7780se_irq_demux(int);
+void *sh7780se_ioremap(unsigned long, unsigned long);
+void sh7780se_iounmap(void *);
+
+/*
+ * The Machine Vector
+ */
+
+struct sh_machine_vector mv_7780se __initmv = {
+	.mv_nr_irqs		= NR_IRQS,
+
+	.mv_inb			= sh7780se_inb,
+	.mv_inw			= sh7780se_inw,
+	.mv_inl			= sh7780se_inl,
+	.mv_outb		= sh7780se_outb,
+	.mv_outw		= sh7780se_outw,
+	.mv_outl		= sh7780se_outl,
+
+	.mv_inb_p		= sh7780se_inb_p,
+	.mv_inw_p		= sh7780se_inw,
+	.mv_inl_p		= sh7780se_inl,
+	.mv_outb_p		= sh7780se_outb_p,
+	.mv_outw_p		= sh7780se_outw,
+	.mv_outl_p		= sh7780se_outl,
+
+	.mv_insb		= sh7780se_insb,
+	.mv_insw		= sh7780se_insw,
+	.mv_insl		= sh7780se_insl,
+	.mv_outsb		= sh7780se_outsb,
+	.mv_outsw		= sh7780se_outsw,
+	.mv_outsl		= sh7780se_outsl,
+
+	.mv_ioremap		= sh7780se_ioremap,
+	.mv_iounmap		= sh7780se_iounmap,
+
+	.mv_irq_demux		= sh7780se_irq_demux,
+	.mv_init_irq		= init_sh7780se_IRQ,
+
+#ifdef CONFIG_HEARTBEAT
+	.mv_heartbeat		= heartbeat_7780se,
+#endif
+};
+ALIAS_MV(7780se)
Index: linux-2.6.10/arch/sh/boards/se/7780/pci.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/pci.c
@@ -0,0 +1,245 @@
+/*
+ * linux/arch/sh/boards/se/7780/pci.c
+ *
+ * Copyright (C)  Takashi Kusuda  (Nov, 2004)
+ *  modified to support MS7780SE01(SH7780 SolutionEngine).
+ *
+ * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * PCI initialization for Hitachi MS7780SE01
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+
+#include <asm/io.h>
+#include <asm/cpu/pci-sh7780.h>
+#include <asm/mach/map.h>
+
+#define PCIMCR_MRSET_OFF	0xBFFFFFFF
+#define PCIMCR_RFSH_OFF		0xFFFFFFFB
+
+#define PCIPAR PCI_REG(SH7780_PCI_PAR)
+#define PCIPDR PCI_REG(SH7780_PCI_PDR)
+
+static void __init sh7780se_pci_write_config(unsigned long busNo,
+                                             unsigned long devNo,
+                                             unsigned long fncNo,
+                                             unsigned long cnfAdd,
+                                             unsigned long cnfData)
+{
+	ctrl_outl((0x80000000
+		+ ((busNo & 0xff)<<16)
+		+ ((devNo & 0x1f)<<11)
+		+ ((fncNo & 0x7)<<8)
+		+ (cnfAdd & 0xfc)), PCIPAR);
+
+	ctrl_outl(cnfData, PCIPDR);
+}
+
+static long __init sh7780se_pci_read_config(unsigned long busNo,
+                                            unsigned long devNo,
+                                            unsigned long fncNo,
+                                            unsigned long cnfAdd)
+{
+	ctrl_outl((0x80000000
+		+ ((busNo & 0xff)<<16)
+		+ ((devNo & 0x1f)<<11)
+		+ ((fncNo & 0x7)<<8)
+		+ (cnfAdd & 0xfc)), PCIPAR);
+
+	return (ctrl_inl(PCIPDR));
+}
+
+#define PCI_SLOT1_DEVNO	0
+#define PCI_SLOT2_DEVNO	1
+#define S_ATA_DEVNO	2
+#define USB_H_DEVNO	3
+
+#if defined(CONFIG_USB)
+/*
+ * Configure the NEC USB Host Controller chip
+ */
+static void __init init_7780se_usbc(void)
+{
+	unsigned long tmp, value;
+
+	/* 4 port setting */
+	tmp = sh7780se_pci_read_config(0, USB_H_DEVNO, 0, 0xe0);
+	value = ((tmp & ~7) | 0x5);
+	sh7780se_pci_write_config(0, USB_H_DEVNO, 0, 0xe0, value);
+
+	/* ehci setting */
+	tmp = sh7780se_pci_read_config(0, USB_H_DEVNO, 0, 0xe4);
+	value = tmp & 0xfffffffe;
+	sh7780se_pci_write_config(0, USB_H_DEVNO, 0, 0xe4, value);
+	printk("PCIBIOS: USB Host port num set 4\n");
+}
+#endif
+
+#if defined(CONFIG_CARDBUS)
+/*
+ * Configure the T.I PCI1420 PC Card Controller
+ */
+static void __init init_7780se_pci1420(void)
+{
+	unsigned long tmp, value;
+
+	tmp = sh7780se_pci_read_config(0, PCCARD_DEVNO, 0, 0x80);
+	value = (tmp & 0x1fffffff)|0x20000000; /* tie */
+	sh7780se_pci_write_config(0, PCCARD_DEVNO, 0, 0x80, value); /* set sys ctl reg(0x80) */
+
+	sh7780se_pci_write_config(0, PCCARD_DEVNO, 0, 0x8c, 0x0ac2cd22); /* set mfunc reg(0x8c) */
+
+	printk("PCIBIOS: PC Card multifunc reg set.\n");
+}
+#endif
+
+#if defined(CONFIG_BLK_DEV_SIIMAGE)
+/*
+ * Configure the Silicon Image Serial ATA Controller
+ */
+static void __init init_7780se_sata(void)
+{
+	/* Nothing to do */
+}
+#endif
+
+/*
+ * Only long word accesses of the PCIC's internal local registers and the
+ * configuration registers from the CPU is supported.
+ */
+#define PCIC_WRITE(x,v) writel((v), PCI_REG(x))
+#define PCIC_READ(x) readl(PCI_REG(x))
+
+/*
+ * Description:  This function sets up and initializes the pcic, sets
+ * up the BARS, maps the DRAM into the address space etc, etc.
+ */
+int __init pcibios_init_platform(void)
+{
+   ctrl_outl(0x00000001, SH7780_PCI_ECR);
+
+   /* Enable all interrupts, so we know what to fix */
+   PCIC_WRITE(SH7780_PCI_IMR, 0x0000C3FF);
+   PCIC_WRITE(SH7780_PCI_AINTM, 0x0000380F);
+
+   /* Set up standard PCI config registers */
+   ctrl_outw(0xFB00, PCI_REG(SH7780_PCI_STATUS));
+   ctrl_outw(0x0047, PCI_REG(SH7780_PCI_CMD));
+   ctrl_outb(  0x00, PCI_REG(SH7780_PCI_PIF));
+   ctrl_outb(  0x00, PCI_REG(SH7780_PCI_SUB));
+   ctrl_outb(  0x06, PCI_REG(SH7780_PCI_BCC));
+   ctrl_outw(0x1912, PCI_REG(SH7780_PCI_SVID));
+   ctrl_outw(0x0001, PCI_REG(SH7780_PCI_SID));
+
+   ctrl_outl(0x08000000, PCI_REG(SH7780_PCI_MBAR0));  /* PCI               */
+   ctrl_outl(0x08000000, PCI_REG(SH7780_PCI_LAR0));   /* SHwy              */
+   ctrl_outl(0x07F00001, PCI_REG(SH7780_PCI_LSR0));   /* size 128M w/ MBAR */
+
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_MBAR1));  /* unused            */
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_LAR1));
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_LSR1));
+
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_CSCR0));
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_CSAR0));
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_CSCR1));
+   ctrl_outl(0x00000000, PCI_REG(SH7780_PCI_CSAR1));
+   ctrl_outl(0xAB000801, PCI_REG(SH7780_PCI_IBAR));   /* who? me?         */
+
+   /*
+    * Set the MBR so PCI address is one-to-one with window,
+    * meaning all calls go straight through... use ifdef to
+    * catch erroneous assumption.
+    */
+   PCIC_WRITE(SH7780_PCI_MBR0,  0xFD000000);
+   PCIC_WRITE(SH7780_PCI_MBMR0, 0x00FC0000);	/* 16M */
+
+   /* Set IOBR for window containing area specified in pci.h */
+   PCIC_WRITE(SH7780_PCI_IOBR, PCIBIOS_MIN_IO & ~(SH7780_PCI_IO_SIZE-1));
+   PCIC_WRITE(SH7780_PCI_IOBMR, (SH7780_PCI_IO_SIZE-1)&(7 << 18));
+
+   /* Now turn it on... */
+   PCIC_WRITE(SH7780_PCI_CR, 0xA5000C01);
+
+   /* All done, may as well say so... */
+   printk("SH7780 PCI: Finished initialization of the PCI controller\n");
+
+   /*
+    * FPGA PCISEL register initialize
+    *
+    *  CPU  || SLOT1 | SLOT2 | S-ATA | USB
+    *  -------------------------------------
+    *  INTA || INTA  | INTD  |  --   | INTB
+    *  -------------------------------------
+    *  INTB || INTB  | INTA  |  --   | INTC
+    *  -------------------------------------
+    *  INTC || INTC  | INTB  | INTA  |  --
+    *  -------------------------------------
+    *  INTD || INTD  | INTC  |  --   | INTA
+    *  -------------------------------------
+    */
+   ctrl_outw(0x0013, FPGA_PCI_INTSEL1);
+   ctrl_outw(0xE402, FPGA_PCI_INTSEL2);
+
+#if defined(CONFIG_USB)
+   init_7780se_usbc();
+#endif
+#if defined(CONFIG_CARDBUS)
+   init_7780se_pci1420();
+#endif
+#if defined(CONFIG_BLK_DEV_SIIMAGE)
+   init_7780se_sata();
+#endif
+
+   return 1;
+}
+
+int __init pcibios_map_platform_irq(u8 slot, u8 pin)
+{
+	/*
+	 * IDSEL = AD16  PCI slot
+	 * IDSEL = AD17  PCI slot
+	 * IDSEL = AD18  Serial ATA Controller (Silicon Image SiL3512A)
+	 * IDSEL = AD19  USB Host Controller (NEC uPD7210100A)
+	 */
+
+	int irq[4][16] = {
+/* IDSEL       [16][17][18][19][20][21][22][23][24][25][26][27][28][29][30][31] */
+/* INTA */     { 65, 68, 67, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+/* INTB */     { 66, 65, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+/* INTC */     { 67, 66, -1, 66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+/* INTD */     { 68, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
+	};
+
+	return irq[pin-1][slot];
+}
+
+static struct resource sh7780_io_resource = {
+	.name   = "SH7780 IO",
+	.start  = 0x1000,
+	.end    = 0x1000 + SH7780_PCI_IO_SIZE - 1,
+	.flags  = IORESOURCE_IO
+};
+
+static struct resource sh7780_mem_resource = {
+	.name   = "SH7780 mem",
+	.start  = SH7780_PCI_MEMORY_BASE,
+	.end    = SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
+	.flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops sh7780_pci_ops;
+
+struct pci_channel board_pci_channels[] = {
+	{ &sh7780_pci_ops, &sh7780_io_resource, &sh7780_mem_resource, 0, 0xff },
+	{ NULL, NULL, NULL, 0, 0 },
+};
+
Index: linux-2.6.10/arch/sh/boards/se/7780/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/boards/se/7780/setup.c
@@ -0,0 +1,222 @@
+/*
+ * linux/arch/sh/boards/se/7780/setup.c
+ *
+ * Copyright (C) 2005  Takashi Kusuda
+ *
+ * Hitachi SolutionEngine 7780 Support.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/cpu/pci-sh7780.h>
+
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition sh_se_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .size = 0x20000,	/* 64KB *//* x16 */
+	 .offset = 0,
+	 },
+	{
+	 .name = "kernel",
+	 .size = 0x120000,	/* 1088KB *//* x16 */
+	 .offset = MTDPART_OFS_APPEND,
+	 },
+	{
+	 .name = "userland",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = MTDPART_OFS_APPEND,
+	 }
+};
+#endif
+
+const char *get_system_type(void)
+{
+	return "7780 SolutionEngine";
+}
+
+#ifdef CONFIG_SH_KGDB
+static int kgdb_uart_setup(void);
+static struct kgdb_sermap kgdb_uart_sermap =
+{ "ttyS", 0, kgdb_uart_setup, NULL };
+#endif
+
+/*
+ * Initialize the board
+ */
+void __init platform_setup(void)
+{
+	/* "SH-Linux" on LED Display */
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL0_ADDR << 1)) = 'S';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL1_ADDR << 1)) = 'H';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL2_ADDR << 1)) = '-';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL3_ADDR << 1)) = 'L';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL4_ADDR << 1)) = 'i';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL5_ADDR << 1)) = 'n';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL6_ADDR << 1)) = 'u';
+	*(volatile unsigned short *)(PA_LED_DISP + (DISP_SEL7_ADDR << 1)) = 'x';
+
+	/*
+	 * PCI REQ/GNT setting
+	 *   REQ0/GNT0 -> USB
+	 *   REQ1/GNT1 -> PC Card
+	 *   REQ2/GNT2 -> Serial ATA
+	 *   REQ3/GNT3 -> PCI slot
+	 */
+	ctrl_outw(0x0213, FPGA_REQSEL); /* test */
+
+	/* GPIO setting */
+	ctrl_outw(0x0000, GPIO_PECR);
+	ctrl_outw(ctrl_inw(GPIO_PHCR)&0xfff3, GPIO_PHCR);
+	ctrl_outw(0x0c00, GPIO_PMSELR);
+
+	/* iVDR Power ON */
+	ctrl_outw(0x0001, FPGA_IVDRPW);
+
+#ifdef CONFIG_SH_KGDB
+	kgdb_register_sermap(&kgdb_uart_sermap);
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+	physmap_set_partitions(sh_se_partitions,
+		sizeof(sh_se_partitions)/sizeof(sh_se_partitions[0]));
+#endif
+}
+
+/*********************************************************************
+ * Currently a hack (e.g. does not interact well w/serial.c, lots of *
+ * hardcoded stuff) but may be useful if SCI/F needs debugging.      *
+ * Mostly copied from x86 code (see files asm-i386/kgdb_local.h and  *
+ * arch/i386/lib/kgdb_serial.c).                                     *
+ *********************************************************************/
+
+#ifdef CONFIG_SH_KGDB
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+
+#define COM1_PORT 0x3f8  /* Base I/O address */
+#define COM1_IRQ  4      /* IRQ not used yet */
+#define COM2_PORT 0x2f8  /* Base I/O address */
+#define COM2_IRQ  3      /* IRQ not used yet */
+
+#define SB_CLOCK 1843200 /* Serial baud clock */
+#define SB_BASE (SB_CLOCK/16)
+#define SB_MCR UART_MCR_OUT2 | UART_MCR_DTR | UART_MCR_RTS
+
+struct uart_port {
+	int base;
+};
+#define UART_NPORTS 2
+struct uart_port uart_ports[] = {
+	{ COM1_PORT },
+	{ COM2_PORT },
+};
+struct uart_port *kgdb_uart_port;
+
+#define UART_IN(reg)	inb_p(kgdb_uart_port->base + reg)
+#define UART_OUT(reg,v)	outb_p((v), kgdb_uart_port->base + reg)
+
+/* Basic read/write functions for the UART */
+#define UART_LSR_RXCERR    (UART_LSR_BI | UART_LSR_FE | UART_LSR_PE)
+static int kgdb_uart_getchar(void)
+{
+	int lsr;
+	int c = -1;
+
+	while (c == -1) {
+		lsr = UART_IN(UART_LSR);
+		if (lsr & UART_LSR_DR)
+			c = UART_IN(UART_RX);
+		if ((lsr & UART_LSR_RXCERR))
+			c = -1;
+	}
+	return c;
+}
+
+static void kgdb_uart_putchar(int c)
+{
+	while ((UART_IN(UART_LSR) & UART_LSR_THRE) == 0)
+		;
+	UART_OUT(UART_TX, c);
+}
+
+/*
+ * Initialize UART to configured/requested values.
+ * (But we don't interrupts yet, or interact w/serial.c)
+ */
+static int kgdb_uart_setup(void)
+{
+	int port;
+	int lcr = 0;
+	int bdiv = 0;
+
+	if (kgdb_portnum >= UART_NPORTS) {
+		KGDB_PRINTK("uart port %d invalid.\n", kgdb_portnum);
+		return -1;
+	}
+
+	kgdb_uart_port = &uart_ports[kgdb_portnum];
+
+	/* Init sequence from gdb_hook_interrupt */
+	UART_IN(UART_RX);
+	UART_OUT(UART_IER, 0);
+
+	UART_IN(UART_RX);	/* Serial driver comments say */
+	UART_IN(UART_IIR);	/* this clears interrupt regs */
+	UART_IN(UART_MSR);
+
+	/* Figure basic LCR values */
+	switch (kgdb_bits) {
+	case '7':
+		lcr |= UART_LCR_WLEN7;
+		break;
+	default: case '8':
+		lcr |= UART_LCR_WLEN8;
+		break;
+	}
+	switch (kgdb_parity) {
+	case 'O':
+		lcr |= UART_LCR_PARITY;
+		break;
+	case 'E':
+		lcr |= (UART_LCR_PARITY | UART_LCR_EPAR);
+		break;
+	default: break;
+	}
+
+	/* Figure the baud rate divisor */
+	bdiv = (SB_BASE/kgdb_baud);
+
+	/* Set the baud rate and LCR values */
+	UART_OUT(UART_LCR, (lcr | UART_LCR_DLAB));
+	UART_OUT(UART_DLL, (bdiv & 0xff));
+	UART_OUT(UART_DLM, ((bdiv >> 8) & 0xff));
+	UART_OUT(UART_LCR, lcr);
+
+	/* Set the MCR */
+	UART_OUT(UART_MCR, SB_MCR);
+
+	/* Turn off FIFOs for now */
+	UART_OUT(UART_FCR, 0);
+
+	/* Setup complete: initialize function pointers */
+	kgdb_getchar = kgdb_uart_getchar;
+	kgdb_putchar = kgdb_uart_putchar;
+
+	return 0;
+}
+#endif /* CONFIG_SH_KGDB */
Index: linux-2.6.10/arch/sh/drivers/pci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/sh/drivers/pci/Makefile
+++ linux-2.6.10/arch/sh/drivers/pci/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_PCI_AUTO)			+= pci-auto.o
 
 obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= pci-st40.o
 obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o 
+obj-$(CONFIG_CPU_SUBTYPE_SH7780)        += pci-sh7780.o
 
 obj-$(CONFIG_SH_DREAMCAST)		+= ops-dreamcast.o fixups-dreamcast.o \
 					   dma-dreamcast.o
Index: linux-2.6.10/arch/sh/drivers/pci/pci-sh7780.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/drivers/pci/pci-sh7780.c
@@ -0,0 +1,266 @@
+/*
+ *	Low-Level PCI Support for the SH7780
+ *
+ *  Copyright (C)  Takashi Kusuda  (Nov. 24, 2004)
+ *
+ *  Dustin McIntire (dustin@sensoria.com)
+ *	Derived from arch/i386/kernel/pci-*.c which bore the message:
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *
+ *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
+ *  With cleanup by Paul van Gool <pvangool@mimotech.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/machvec.h>
+#include <asm/io.h>
+#include <asm/cpu/pci-sh7780.h>
+
+static unsigned int pci_probe = PCI_PROBE_CONF1;
+extern int pci_fixup_pcic(void);
+
+/*
+ * Direct access to PCI hardware...
+ */
+
+#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+static int sh7780_pci_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	/*
+	 * PCIPDR may only be accessed as 32 bit words,
+	 * so we must do byte alignment by hand
+	 */
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7780_PCI_PAR));
+	data = inl(PCI_REG(SH7780_PCI_PDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffff;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * Since SH7780 only does 32bit access we'll have to do a read,
+ * mask,write operation.
+ * We'll allow an odd byte offset, though it should be illegal.
+ */
+static int sh7780_pci_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	unsigned long flags;
+	int shift;
+	u32 data;
+
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7780_PCI_PAR));
+	data = inl(PCI_REG(SH7780_PCI_PDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xff << shift);
+		data |= ((val & 0xff) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffff << shift);
+		data |= ((val & 0xffff) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	outl(data, PCI_REG(SH7780_PCI_PDR));
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+#undef CONFIG_CMD
+
+struct pci_ops sh7780_pci_ops = {
+	.read 		= sh7780_pci_read,
+	.write		= sh7780_pci_write,
+};
+
+static int __init pci_check_direct(void)
+{
+	unsigned int tmp, id;
+
+	/* check for SH7780 hardware */
+        id = ctrl_inl(PCI_REG(SH7780_PCI_VID));
+        if ((id != ((SH7780_DEVICE_ID << 16) | SH7780_VENDOR_ID)) &&
+	    (id != ((SH7781_DEVICE_ID << 16) | SH7780_VENDOR_ID))){
+                PCIDBG(2,"PCI: This is not an SH7780/SH7781\n");
+                return -ENODEV;
+        }
+
+	/*
+	 * Check if configuration works.
+	 */
+	if (pci_probe & PCI_PROBE_CONF1) {
+		tmp = inl (PCI_REG(SH7780_PCI_PAR));
+		outl (0x80000000, PCI_REG(SH7780_PCI_PAR));
+		if (inl (PCI_REG(SH7780_PCI_PAR)) == 0x80000000) {
+			outl (tmp, PCI_REG(SH7780_PCI_PAR));
+			printk(KERN_INFO "PCI: Using configuration type 1\n");
+			request_region(PCI_REG(SH7780_PCI_PAR), 8, "PCI conf1");
+			return 0;
+		}
+		outl (tmp, PCI_REG(SH7780_PCI_PAR));
+	}
+
+	pr_debug("PCI: pci_check_direct failed\n");
+	return -EINVAL;
+}
+
+/***************************************************************************************/
+
+/*
+ *  Handle bus scanning and fixups ....
+ */
+
+static void __init pci_fixup_ide_bases(struct pci_dev *d)
+{
+	int i;
+
+	/*
+	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
+	 */
+	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+	pr_debug("PCI: IDE base address fixup for %s\n", d->slot_name);
+	for(i=0; i<4; i++) {
+		struct resource *r = &d->resource[i];
+		if ((r->start & ~0x80) == 0x374) {
+			r->start |= 2;
+			r->end = r->start;
+		}
+	}
+}
+
+/* Add future fixups here... */
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
+
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+
+void __init pcibios_fixup_bus(struct pci_bus *b)
+{
+	pci_read_bridge_bases(b);
+}
+
+/*
+ * Initialization. Try all known PCI access methods. Note that we support
+ * using both PCI BIOS and direct access: in such cases, we use I/O ports
+ * to access config space.
+ *
+ * Note that the platform specific initialization (BSC registers, and memory
+ * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
+ * exitst and via the platform defined function pcibios_init_platform().
+ * See pci_bigsur.c for implementation;
+ *
+ * The BIOS version of the pci functions is not yet implemented but it is left
+ * in for completeness.  Currently an error will be genereated at compile time.
+ */
+
+static int __init sh7780_pci_init(void)
+{
+	int ret;
+
+	pr_debug("PCI: Starting intialization.\n");
+	if ((ret = pci_check_direct()) != 0)
+		return ret;
+
+	return 1;
+}
+
+subsys_initcall(sh7780_pci_init);
+
+int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
+{
+	/* SH7780 PCIC enable */
+	ctrl_outl (0x00000001, SH7780_PCI_ECR);
+	return 1;
+}
+
+char * __init pcibios_setup(char *str)
+{
+	if (!strcmp(str, "off")) {
+		pci_probe = 0;
+		return NULL;
+	}
+
+	return str;
+}
+
+/*
+ * 	IRQ functions
+ */
+static u8 __init sh7780_no_swizzle(struct pci_dev *dev, u8 *pin)
+{
+	/* no swizzling */
+	return PCI_SLOT(dev->devfn);
+}
+
+static int sh7780_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
+	irq = pcibios_map_platform_irq(slot,pin);
+	if( irq < 0 ) {
+		pr_debug("PCI: Error mapping IRQ on device %s\n", dev->slot_name);
+		return irq;
+	}
+
+	pr_debug("Setting IRQ for slot %s to %d\n", dev->slot_name, irq);
+
+	return irq;
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+	pci_fixup_irqs(sh7780_no_swizzle, sh7780_pci_lookup_irq);
+}
+
Index: linux-2.6.10/arch/sh/drivers/pci/pci.c
===================================================================
--- linux-2.6.10.orig/arch/sh/drivers/pci/pci.c
+++ linux-2.6.10/arch/sh/drivers/pci/pci.c
@@ -23,6 +23,8 @@ static int __init pcibios_init(void)
 	struct pci_bus *bus;
 	int busno;
 
+	pcibios_init_platform();
+
 #ifdef CONFIG_PCI_AUTO
 	/* assign resources */
 	busno = 0;
Index: linux-2.6.10/arch/sh/kernel/cpu/sh4/Makefile
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/cpu/sh4/Makefile
+++ linux-2.6.10/arch/sh/kernel/cpu/sh4/Makefile
@@ -5,6 +5,7 @@
 obj-y	:= ex.o probe.o
 
 obj-$(CONFIG_SH_FPU)                    += fpu.o
+obj-$(CONFIG_CPU_SH4A)                 += irq_sh4a_intc.o
 obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= irq_intc2.o
 obj-$(CONFIG_SH_STORE_QUEUES)		+= sq.o
 
Index: linux-2.6.10/arch/sh/kernel/cpu/sh4/ex.S
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/cpu/sh4/ex.S
+++ linux-2.6.10/arch/sh/kernel/cpu/sh4/ex.S
@@ -225,6 +225,69 @@ ENTRY(interrupt_table)
 	.long	exception_error
 	.long	do_IRQ	! ADC	adi
 	.long	do_IRQ	! CMT	cmti	/* FA0 */
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+       .long   do_IRQ  !  50 0x840
+       .long   do_IRQ  !  51 0x860
+       .long   do_IRQ  !  52 0x880
+       .long   do_IRQ  !  53 0x8a0
+       .long   do_IRQ  !  54 0x8c0
+       .long   do_IRQ  !  55 0x8e0
+       .long   do_IRQ  !  56 0x900
+       .long   do_IRQ  !  57 0x920
+       .long   do_IRQ  !  58 0x940
+       .long   do_IRQ  !  59 0x960
+       .long   do_IRQ  !  60 0x980
+       .long   do_IRQ  !  61 0x9a0
+       .long   do_IRQ  !  62 0x9c0
+       .long   do_IRQ  !  63 0x9e0
+       .long   do_IRQ  !  64 0xa00
+       .long   do_IRQ  !  65 0xa20
+       .long   do_IRQ  !  66 0xa4d
+       .long   do_IRQ  !  67 0xa60
+       .long   do_IRQ  !  68 0xa80
+       .long   do_IRQ  !  69 0xaa0
+       .long   do_IRQ  !  70 0xac0
+       .long   do_IRQ  !  71 0xae0
+       .long   do_IRQ  !  72 0xb00
+       .long   do_IRQ  !  73 0xb20
+       .long   do_IRQ  !  74 0xb40
+       .long   do_IRQ  !  75 0xb60
+       .long   do_IRQ  !  76 0xb80
+       .long   do_IRQ  !  77 0xba0
+       .long   do_IRQ  !  78 0xbc0
+       .long   do_IRQ  !  79 0xbe0
+       .long   do_IRQ  !  80 0xc00
+       .long   do_IRQ  !  81 0xc20
+       .long   do_IRQ  !  82 0xc40
+       .long   do_IRQ  !  83 0xc60
+       .long   do_IRQ  !  84 0xc80
+       .long   do_IRQ  !  85 0xca0
+       .long   do_IRQ  !  86 0xcc0
+       .long   do_IRQ  !  87 0xce0
+       .long   do_IRQ  !  88 0xd00
+       .long   do_IRQ  !  89 0xd20
+       .long   do_IRQ  !  90 0xd40
+       .long   do_IRQ  !  91 0xd60
+       .long   do_IRQ  !  92 0xd80
+       .long   do_IRQ  !  93 0xda0
+       .long   do_IRQ  !  94 0xdc0
+       .long   do_IRQ  !  95 0xde0
+       .long   do_IRQ  !  96 0xe00
+       .long   do_IRQ  !  97 0xe20
+       .long   do_IRQ  !  98 0xe40
+       .long   do_IRQ  !  99 0xe60
+       .long   do_IRQ  ! 100 0xe80
+       .long   do_IRQ  ! 101 0xea0
+       .long   do_IRQ  ! 102 0xec0
+       .long   do_IRQ  ! 103 0xee0
+       .long   do_IRQ  ! 104 0xf00
+       .long   do_IRQ  ! 105 0xf20
+       .long   do_IRQ  ! 106 0xf40
+       .long   do_IRQ  ! 107 0xf60
+       .long   do_IRQ  ! 108 0xf80
+       .long   do_IRQ  ! 109 0xfa0
+       .long   do_IRQ  ! 110 0xfc0
+       .long   do_IRQ  ! 111 0xfe0
 #elif defined(CONFIG_CPU_SUBTYPE_SH73180)
 	.long	do_IRQ	!  50 0x840
 	.long	do_IRQ	!  51 0x860
Index: linux-2.6.10/arch/sh/kernel/cpu/sh4/irq_intmsk.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/kernel/cpu/sh4/irq_intmsk.c
@@ -0,0 +1,151 @@
+/*
+ * linux/arch/sh/kernel/cpu/sh4/irq_intmsk.c
+ *
+ * Copyright (C) 2004  Takashi Kusuda
+ *
+ * Interrupt handling for INTMSK based IRQ.
+ *
+ *  Support for Renesas HD6417760(SH7760).
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+
+
+struct intmsk_data {
+	unsigned int addr;	/* address of INTMSKxx */
+	unsigned int pos;	/* position of INTMSKxx */
+};
+
+#define NR_INTMSK_IRQS	(INTMSK_MAX_IRQ - INTMSK_MIN_IRQ + 1)
+
+static struct intmsk_data intmsk_data[NR_INTMSK_IRQS];
+
+static void enable_intmsk_irq(unsigned int irq);
+static void disable_intmsk_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_intmsk_irq disable_intmsk_irq
+
+static void mask_and_ack_intmsk(unsigned int);
+static void end_intmsk_irq(unsigned int irq);
+
+static unsigned int startup_intmsk_irq(unsigned int irq)
+{
+	enable_intmsk_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type intmsk_irq_type = {
+	"INTMSK-IRQ",
+	startup_intmsk_irq,
+	shutdown_intmsk_irq,
+	enable_intmsk_irq,
+	disable_intmsk_irq,
+	mask_and_ack_intmsk,
+	end_intmsk_irq
+};
+
+static void disable_intmsk_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+	unsigned int offset = irq - INTMSK_MIN_IRQ;
+	unsigned int addr, mask;
+
+	/* Sanity check */
+	if(offset < 0 || offset >= NR_INTMSK_IRQS)
+		return;
+
+	mask = 1 << (intmsk_data[offset].pos);
+	addr = intmsk_data[offset].addr;
+
+	local_irq_save(flags);
+	val = ctrl_inl(addr);
+	val |= mask;
+	ctrl_outl(val, addr);
+	local_irq_restore(flags);
+}
+
+static void enable_intmsk_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+	unsigned int offset = irq - INTMSK_MIN_IRQ;
+	unsigned int addr, mask_clr;
+
+	/* Sanity check */
+	if(offset < 0 || offset >= NR_INTMSK_IRQS)
+		return;
+
+	mask_clr = 1 << (intmsk_data[offset].pos);
+	addr = (intmsk_data[offset].addr + INTMSKCLR_OFFSET);
+
+	local_irq_save(flags);
+	val = ctrl_inl(addr);
+	val |= mask_clr;
+	ctrl_outl(val, addr);
+	local_irq_restore(flags);
+}
+
+static void mask_and_ack_intmsk(unsigned int irq)
+{
+	disable_intmsk_irq(irq);
+}
+
+static void end_intmsk_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_intmsk_irq(irq);
+}
+
+void make_intmsk_irq(unsigned int irq, unsigned int pri_addr,
+		     unsigned int pri_pos, unsigned int priority,
+		     unsigned int msk_addr, unsigned int msk_pos)
+{
+	unsigned long val, flags;
+	unsigned int offset = irq - INTMSK_MIN_IRQ;
+
+	/* Sanity check */
+	if(offset < 0 || offset >= NR_INTMSK_IRQS)
+		return;
+
+	disable_irq_nosync(irq);
+
+	intmsk_data[offset].addr = msk_addr;
+	intmsk_data[offset].pos = msk_pos;
+
+	/* Set the priority level */
+	local_irq_save(flags);
+	val = ctrl_inl(pri_addr);
+	val |= priority << (4 * pri_pos);
+	ctrl_outl(val, pri_addr);
+	local_irq_restore(flags);
+
+	irq_desc[irq].handler=&intmsk_irq_type;
+	disable_intmsk_irq(irq);
+}
+
+#if defined(SH_INTMSK_INIT_TABLE)
+static struct sh_intmsk_irq_info sh_intmsk_regs_init[] __initdata = SH_INTMSK_INIT_TABLE;
+#endif
+
+void __init init_intmsk_IRQ(void)
+{
+#if defined(SH_INTMSK_INIT_TABLE)
+	int i;
+
+	for(i = 0; sh_intmsk_regs_init[i].irq != 0; i++){
+		make_intmsk_irq(sh_intmsk_regs_init[i].irq,
+				sh_intmsk_regs_init[i].pri_addr,
+				sh_intmsk_regs_init[i].pri_pos,
+				sh_intmsk_regs_init[i].priority,
+				sh_intmsk_regs_init[i].mask_addr,
+				sh_intmsk_regs_init[i].mask_pos);
+	}
+#endif
+}
+
Index: linux-2.6.10/arch/sh/kernel/cpu/sh4/irq_sh4a_intc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/sh/kernel/cpu/sh4/irq_sh4a_intc.c
@@ -0,0 +1,132 @@
+/*
+ *  arch/sh/kernel/cpu/sh4/irq_sh4a_intc.c
+ *
+ *  Copyright (C)  Takashi Kusuda (Nov. 2004)
+ *
+ *   SH-4A INTC/INTC2 interrupt handler.
+ *   Support CPUs are SH7780 and SH7781.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+
+/* for initializing SH7780 INTC/INTC2 regs */
+struct sh4a_intc_irq_info
+{
+	unsigned int irq;
+	unsigned int mask_addr;
+	unsigned int unmask_addr;
+	int  pos;
+};
+
+struct sh4a_intc_sys {
+	unsigned long mask_addr;
+	unsigned long unmask_addr;
+	unsigned long pos;
+};
+
+static struct sh4a_intc_sys sh4a_intc_data[NR_IRQS];
+
+static void enable_sh4a_intc_irq(unsigned int irq);
+static void disable_sh4a_intc_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_sh4a_intc_irq disable_sh4a_intc_irq
+
+static void mask_and_ack_sh4a_intc(unsigned int);
+static void end_sh4a_intc_irq(unsigned int irq);
+
+static unsigned int startup_sh4a_intc_irq(unsigned int irq)
+{
+	enable_sh4a_intc_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type sh4a_intc_irq_type = {
+	"SH4A INTC/INTC2-IRQ",
+	startup_sh4a_intc_irq,
+	shutdown_sh4a_intc_irq,
+	enable_sh4a_intc_irq,
+	disable_sh4a_intc_irq,
+	mask_and_ack_sh4a_intc,
+	end_sh4a_intc_irq
+};
+
+static void disable_sh4a_intc_irq(unsigned int irq)
+{
+	unsigned long flags;
+
+        local_irq_save(flags);
+	*(volatile unsigned long *)(sh4a_intc_data[irq].mask_addr) = (1 << sh4a_intc_data[irq].pos);
+        local_irq_restore(flags);
+}
+
+static void enable_sh4a_intc_irq(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	*(volatile unsigned long *)(sh4a_intc_data[irq].unmask_addr) = (1 << sh4a_intc_data[irq].pos);
+	local_irq_restore(flags);
+}
+
+static void mask_and_ack_sh4a_intc(unsigned int irq)
+{
+	disable_sh4a_intc_irq(irq);
+}
+
+static void end_sh4a_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_sh4a_intc_irq(irq);
+}
+
+void make_sh4a_intc_irq(unsigned int irq, unsigned int mask_addr,
+			  unsigned int unmask_addr, int pos)
+{
+	disable_irq_nosync(irq);
+	sh4a_intc_data[irq].mask_addr = mask_addr;
+	sh4a_intc_data[irq].unmask_addr = unmask_addr;
+	sh4a_intc_data[irq].pos = pos;
+
+	irq_desc[irq].handler = &sh4a_intc_irq_type;
+	disable_sh4a_intc_irq(irq);
+}
+
+#if defined(SH4A_INTC2_INIT_TABLE)
+static struct sh4a_intc_irq_info sh4a_intc2_regs_init[] __initdata = SH4A_INTC2_INIT_TABLE;
+#endif
+
+void __init init_sh4a_intc2_IRQ(void)
+{
+	int i;
+
+	/*
+	 *  Initialize INTC2 (These are for internal modules).
+	 *  IRL[0:7](IRQ0-7) depends on Platform.
+	 *  So, these INTC setting on arch/sh/boards/xx/xx/irq.c
+	 */
+
+	/* setting INTC2 interrupt priority */
+#if defined(SH4A_INTC2_PRIORITY_SETTING)
+	SH4A_INTC2_PRIORITY_SETTING;
+#endif
+
+	/* register INTC2 IRQs */
+#if defined(SH4A_INTC2_INIT_TABLE)
+	for(i = 0; sh4a_intc2_regs_init[i].irq != 0; i++){
+		make_sh4a_intc_irq(sh4a_intc2_regs_init[i].irq,
+				   sh4a_intc2_regs_init[i].mask_addr,
+				   sh4a_intc2_regs_init[i].unmask_addr,
+				   sh4a_intc2_regs_init[i].pos);
+	}
+#endif
+}
+
+EXPORT_SYMBOL(make_sh4a_intc_irq);
Index: linux-2.6.10/arch/sh/kernel/cpu/sh4/probe.c
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/cpu/sh4/probe.c
+++ linux-2.6.10/arch/sh/kernel/cpu/sh4/probe.c
@@ -15,9 +15,44 @@
 #include <asm/processor.h>
 #include <asm/cache.h>
 #include <asm/io.h>
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+	#include <asm/cpu/pci-sh7780.h>
+#endif
 
 int __init detect_cpu_and_cache_system(void)
 {
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+	unsigned long tmp;
+
+	/* Setup icache */
+	cpu_data->icache.way_incr       = (1 << 13);
+	cpu_data->icache.entry_shift    = 5;
+	cpu_data->icache.entry_mask     = 0x1fe0;
+	cpu_data->icache.sets           = 256;
+	cpu_data->icache.ways           = 4;
+	cpu_data->icache.linesz         = L1_CACHE_BYTES;
+
+	/* Setup dcache */
+	cpu_data->dcache.way_incr       = (1 << 13);
+	cpu_data->dcache.entry_shift    = 5;
+	cpu_data->dcache.entry_mask     = 0x1fe0;
+	cpu_data->dcache.sets           = 256;
+	cpu_data->dcache.ways           = 4;
+	cpu_data->dcache.linesz         = L1_CACHE_BYTES;
+
+	/* Set the FPU flag, virtually all SH-4's have one */
+	cpu_data->flags |= CPU_HAS_FPU;
+
+	/* Set CPU type */
+	ctrl_outl(0x00000001, SH7780_PCI_ECR); /* enable PCI */
+	tmp = ctrl_inl(PCI_REG(SH7780_PCI_VID)) >> 16; /* read devID */
+
+	if(tmp == SH7780_DEVICE_ID) {
+		cpu_data->type = CPU_SH7780;
+	} else {
+		cpu_data->type = CPU_SH_NONE;
+	}
+#else
 	unsigned long pvr, prr, cvr;
 	unsigned long size;
 
@@ -97,13 +132,19 @@ int __init detect_cpu_and_cache_system(v
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
 		break;
-	case 0x500 ... 0x501:
+	case 0x500:
 		switch (prr) {
 		    case 0x10: cpu_data->type = CPU_SH7750R; break;
 		    case 0x11: cpu_data->type = CPU_SH7751R; break;
-		    case 0x50: cpu_data->type = CPU_SH7760;  break;
 		}
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
 
+		break;
+	case 0x501:
+		switch (prr&0xf0) {
+			case 0x50: cpu_data->type = CPU_SH7760; break;
+		}
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
 
@@ -132,7 +173,7 @@ int __init detect_cpu_and_cache_system(v
 		cpu_data->dcache.entry_mask	=
 			(cpu_data->dcache.way_incr - (1 << 5));
 	}
-
+#endif
 	return 0;
 }
 
Index: linux-2.6.10/arch/sh/kernel/cpufreq.c
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/cpufreq.c
+++ linux-2.6.10/arch/sh/kernel/cpufreq.c
@@ -41,9 +41,13 @@ struct clock_set {
 #if defined(CONFIG_CPU_SH3) || defined(CONFIG_CPU_SH2)
 	{ 0, 0, 0 },	/* not implemented yet */
 #elif defined(CONFIG_CPU_SH4)
+#if defined(CONFIG_CPU_SH4A)
+	{ 0, 0, 0 },    /* not implemented yet */
+#else
 	{ 4, 8, 8 },	/* min - IFC: 1/4, BFC: 1/8, PFC: 1/8 */
 	{ 1, 2, 2 },	/* max - IFC: 1, BFC: 1/2, PFC: 1/2 */
 #endif
+#endif
 };
 
 #define NR_CLOCK_SETS	(sizeof(clock_sets) / sizeof(struct clock_set))
@@ -93,7 +97,7 @@ static int sh_cpufreq_setstate(unsigned 
 	cpus_allowed = current->cpus_allowed;
 	allowable_cpu_map = 1 << cpu;
 	set_cpus_allowed(current, allowable_cpu_map);
-	
+
 	BUG_ON(!(allowable_cpu_map & (1 << smp_processor_id())));
 
 	freqs.cpu = cpu;
@@ -105,6 +109,10 @@ static int sh_cpufreq_setstate(unsigned 
 	frqcr |= (newstate & 0x4000) << 14;
 	frqcr |= (newstate & 0x000c) <<  2;
 #elif defined(CONFIG_CPU_SH4)
+#if defined(CONFIG_CPU_SH4A)
+	/* Not Implement yet */
+#else
+
 	/*
 	 * FRQCR.PLL2EN is 1, we need to allow the PLL to stabilize by
 	 * initializing the WDT.
@@ -129,12 +137,13 @@ static int sh_cpufreq_setstate(unsigned 
 	frqcr |= get_bfc_value(clock_sets[set].bfc) << 3;
 	frqcr |= get_pfc_value(clock_sets[set].pfc);
 #endif
+#endif
 	ctrl_outw(frqcr, FRQCR);
 	sh_cpufreq_update_clocks(set);
 
 	set_cpus_allowed(current, cpus_allowed);
 	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
-	
+
 	return 0;
 }
 
Index: linux-2.6.10/arch/sh/kernel/entry.S
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/entry.S
+++ linux-2.6.10/arch/sh/kernel/entry.S
@@ -40,7 +40,7 @@
 ! GNU as (as of 2.9.1) changes bf/s into bt/s and bra, when the address
 ! to be jumped is too far, but it causes illegal slot exception.
 
-/*	
+/*
  * entry.S contains the system-call and fault low-level handling routines.
  * This also contains the timer-interrupt handler, as well as all interrupts
  * and faults that can result in a task-switch.
@@ -78,8 +78,10 @@ EINVAL = 22
 #if defined(CONFIG_CPU_SH3)
 TRA     = 0xffffffd0
 EXPEVT  = 0xffffffd4
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
+#if defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7706) || defined(CONFIG_CPU_SUBTYPE_SH7707) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7709) || defined(CONFIG_CPU_SUBTYPE_SH7710) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7720) || defined(CONFIG_CPU_SUBTYPE_SH7727)
 INTEVT  = 0xa4000000		! INTEVTE2(0xa4000000)
 #else
 INTEVT  = 0xffffffd8
Index: linux-2.6.10/arch/sh/kernel/setup.c
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/setup.c
+++ linux-2.6.10/arch/sh/kernel/setup.c
@@ -439,6 +439,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7751]	= "SH7751",
 	[CPU_SH7751R]	= "SH7751R",
 	[CPU_SH7760]	= "SH7760",
+	[CPU_SH7780]    = "SH7780",
 	[CPU_SH73180]	= "SH73180",
 	[CPU_ST40RA]	= "ST40RA",
 	[CPU_ST40GX1]	= "ST40GX1",
Index: linux-2.6.10/arch/sh/kernel/time.c
===================================================================
--- linux-2.6.10.orig/arch/sh/kernel/time.c
+++ linux-2.6.10/arch/sh/kernel/time.c
@@ -127,6 +127,13 @@ static int ifc_values[] = { 0, 1, 2, 3, 
 #define bfc_values ifc_values
 #define pfc_divisors ifc_divisors	/* Same */
 #define pfc_values ifc_values
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+static int ifc_divisors[] = { 1, 1, 1, 1, 1, 1, 1, 1 };
+static int ifc_values[] =   { 0, 1, 2, 3, 4, 5, 6, 7 };
+static int bfc_divisors[] = { 1, 1, 1, 1, 1, 8,12, 1 };
+#define bfc_values ifc_values
+static int pfc_divisors[] = { 1, 8, 1,10,12,16, 1, 1 };
+#define pfc_values ifc_values
 #else
 static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
 static int ifc_values[]   = { 0, 1, 2, 3, 0, 4, 0, 5 };
@@ -342,7 +349,7 @@ static unsigned int __init get_timer_fre
 	 * have it count down at its natural rate.
 	 */
 	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
+#if defined(TMU_TOCR)
 	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
 #endif
 	ctrl_outw(TMU0_TCR_CALIB, TMU0_TCR);
@@ -402,7 +409,11 @@ static struct irqaction irq0  = { timer_
 
 void get_current_frequency_divisors(unsigned int *ifc, unsigned int *bfc, unsigned int *pfc)
 {
-	unsigned int frqcr = ctrl_inw(FRQCR);
+#if defined(CONFIG_CPU_SH4A)
+	unsigned int frqcr = ctrl_inl(FRQCR);
+#else
+        unsigned int frqcr = ctrl_inw(FRQCR);
+#endif
 
 #if defined(CONFIG_CPU_SH3)
 #if defined(CONFIG_CPU_SUBTYPE_SH7300)
@@ -431,6 +442,10 @@ void get_current_frequency_divisors(unsi
 	*ifc = ifc_divisors[(frqcr>> 20) & 0x0007];
 	*bfc = bfc_divisors[(frqcr>> 12) & 0x0007];
 	*pfc = pfc_divisors[frqcr & 0x0007];
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+	*ifc = ((int[]){2,4})[(frqcr>>24)&(2-1)];
+	*bfc = ((int[]){0,0,0,8,12,16,24,0})[(frqcr>>16)&(8-1)];
+	*pfc = ((int[]){0,16,24,0})[(frqcr>>0)&(4-1)];
 #else
 	*ifc = ifc_divisors[(frqcr >> 6) & 0x0007];
 	*bfc = bfc_divisors[(frqcr >> 3) & 0x0007];
@@ -676,7 +691,7 @@ void __init time_init(void)
 
 	/* Stop all timers. */
 	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
+#if defined(TMU_TOCR)
 	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
 #endif
 
Index: linux-2.6.10/arch/sh/tools/mach-types
===================================================================
--- linux-2.6.10.orig/arch/sh/tools/mach-types
+++ linux-2.6.10/arch/sh/tools/mach-types
@@ -9,6 +9,11 @@ SE			SH_SOLUTION_ENGINE
 7751SE			SH_7751_SOLUTION_ENGINE		
 7300SE			SH_7300_SOLUTION_ENGINE
 73180SE			SH_73180_SOLUTION_ENGINE
+SE2ND                  SH_SOLUTION_ENGINE_2ND
+SELIGHT                        SH_SOLUTION_ENGINE_LIGHT
+SEPLUS                 SH_SOLUTION_ENGINE_PLUS
+MSSECSH                        SH_MSSECSH
+SH_MS3306EVA           SH_MS3306EVA
 7751SYSTEMH		SH_7751_SYSTEMH
 HP600			SH_HP600
 HP620			SH_HP620
Index: linux-2.6.10/include/asm-sh/bugs.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/bugs.h
+++ linux-2.6.10/include/asm-sh/bugs.h
@@ -32,6 +32,10 @@ static void __init check_bugs(void)
 	case CPU_SH7750 ... CPU_SH4_501:
 		*p++ = '4';
 		break;
+	case CPU_SH73180 ... CPU_SH7781:
+		*p++ = '4';
+		*p++ = 'a';
+		break;
 	default:
 		*p++ = '?';
 		*p++ = '!';
Index: linux-2.6.10/include/asm-sh/cpu-sh4/cache.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/cache.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/cache.h
@@ -22,7 +22,11 @@
 #define CCR_CACHE_ICE	0x0100	/* Instruction Cache Enable */
 #define CCR_CACHE_ICI	0x0800	/* IC Invalidate */
 #define CCR_CACHE_IIX	0x8000	/* IC Index Enable */
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#undef CCR_CACHE_EMODE
+#else	/* CONFIG_CPU_SUBTYPE_SH7780 */
 #define CCR_CACHE_EMODE	0x80000000	/* EMODE Enable */
+#endif	/* CONFIG_CPU_SUBTYPE_SH7780 */
 
 /* Default CCR setup: 8k+16k-byte cache,P1-wb,enable */
 #define CCR_CACHE_ENABLE	(CCR_CACHE_OCE|CCR_CACHE_ICE)
Index: linux-2.6.10/include/asm-sh/cpu-sh4/dma.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/dma.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/dma.h
@@ -1,17 +1,196 @@
+/*
+ * linux/include/asm-sh/cpu-sh4/dma.h
+ *
+ *  Copyright (C)  Takashi Kusuda & Nobuhiro Iwamatsu (June 18, 2005)
+ *
+*/
+
 #ifndef __ASM_CPU_SH4_DMA_H
 #define __ASM_CPU_SH4_DMA_H
 
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define SH_DMAC_BASE0  0xFC808000
+#define SH_DMAC_BASE1  0xFC818000
+
+#define SAR    ((unsigned long[]){SH_DMAC_BASE0 + 0x20, SH_DMAC_BASE0 + 0x30, \
+                                  SH_DMAC_BASE0 + 0x40, SH_DMAC_BASE0 + 0x50, \
+                                  SH_DMAC_BASE0 + 0x70, SH_DMAC_BASE0 + 0x80, \
+                                  SH_DMAC_BASE1 + 0x20, SH_DMAC_BASE1 + 0x30, \
+                                  SH_DMAC_BASE1 + 0x40, SH_DMAC_BASE1 + 0x50, \
+                                  SH_DMAC_BASE1 + 0x70, SH_DMAC_BASE1 + 0x80})
+#define DAR    ((unsigned long[]){SH_DMAC_BASE0 + 0x24, SH_DMAC_BASE0 + 0x34, \
+                                  SH_DMAC_BASE0 + 0x44, SH_DMAC_BASE0 + 0x54, \
+                                  SH_DMAC_BASE0 + 0x74, SH_DMAC_BASE0 + 0x84, \
+                                  SH_DMAC_BASE1 + 0x24, SH_DMAC_BASE1 + 0x34, \
+                                  SH_DMAC_BASE1 + 0x44, SH_DMAC_BASE1 + 0x54, \
+                                  SH_DMAC_BASE1 + 0x74, SH_DMAC_BASE1 + 0x84})
+#define DMATCR ((unsigned long[]){SH_DMAC_BASE0 + 0x28, SH_DMAC_BASE0 + 0x38, \
+                                  SH_DMAC_BASE0 + 0x48, SH_DMAC_BASE0 + 0x58, \
+                                  SH_DMAC_BASE0 + 0x78, SH_DMAC_BASE0 + 0x88, \
+                                  SH_DMAC_BASE1 + 0x28, SH_DMAC_BASE1 + 0x38, \
+                                  SH_DMAC_BASE1 + 0x48, SH_DMAC_BASE1 + 0x58, \
+                                  SH_DMAC_BASE1 + 0x78, SH_DMAC_BASE1 + 0x88})
+#define CHCR   ((unsigned long[]){SH_DMAC_BASE0 + 0x2C, SH_DMAC_BASE0 + 0x3C, \
+                                  SH_DMAC_BASE0 + 0x4C, SH_DMAC_BASE0 + 0x5C, \
+                                  SH_DMAC_BASE0 + 0x7C, SH_DMAC_BASE0 + 0x8C, \
+                                  SH_DMAC_BASE1 + 0x2C, SH_DMAC_BASE1 + 0x3C, \
+                                  SH_DMAC_BASE1 + 0x4C, SH_DMAC_BASE2 + 0x5C, \
+                                  SH_DMAC_BASE1 + 0x7C, SH_DMAC_BASE1 + 0x8C})
+#define DMAOR  ((unsigned long[]){SH_DMAC_BASE0 + 0x60, SH_DMAC_BASE1 + 0x60}
+
+#define SARB_0 ((unsigned long[]){SH_DMAC_BASE0 + 0x120, SH_DMAC_BASE0 + 0x130, \
+                                  SH_DMAC_BASE0 + 0x140, SH_DMAC_BASE0 + 0x150})
+#define SARB_6 ((unsigned long[]){SH_DMAC_BASE1 + 0x120, SH_DMAC_BASE1 + 0x130, \
+                                  SH_DMAC_BASE1 + 0x140, SH_DMAC_BASE1 + 0x150})
+#define DARB_0 ((unsigned long[]){SH_DMAC_BASE0 + 0x124, SH_DMAC_BASE0 + 0x134, \
+                                  SH_DMAC_BASE0 + 0x144, SH_DMAC_BASE0 + 0x154})
+#define DARB_6 ((unsigned long[]){SH_DMAC_BASE1 + 0x124, SH_DMAC_BASE1 + 0x134, \
+                                  SH_DMAC_BASE1 + 0x144, SH_DMAC_BASE1 + 0x154})
+#define TCRB_0 ((unsigned long[]){SH_DMAC_BASE0 + 0x128, SH_DMAC_BASE0 + 0x138, \
+                                  SH_DMAC_BASE0 + 0x148, SH_DMAC_BASE0 + 0x158})
+#define TCRB_6 ((unsigned long[]){SH_DMAC_BASE1 + 0x128, SH_DMAC_BASE1 + 0x138, \
+                                  SH_DMAC_BASE1 + 0x148, SH_DMAC_BASE1 + 0x158})
+
+/* DMA EXT RSC */
+#define DMAC_EXT_RSC_0         0xFC809000UL
+#define DMAC_EXT_RSC_1         0xFC809004UL
+#define DMAC_EXT_RSC_2         0xFC809008UL
+
+
+#elif defined(CONFIG_CPU_SUBTYPE_SH73180)
+#define SH_DMAC_BASE   0xFE008000
+
+#define SAR    ((unsigned long[]){SH_DMAC_BASE + 0x20, SH_DMAC_BASE + 0x30, \
+                                  SH_DMAC_BASE + 0x40, SH_DMAC_BASE + 0x50, \
+                                  SH_DMAC_BASE + 0x70, SH_DMAC_BASE + 0x80})
+#define DAR    ((unsigned long[]){SH_DMAC_BASE + 0x24, SH_DMAC_BASE + 0x34, \
+                                  SH_DMAC_BASE + 0x44, SH_DMAC_BASE + 0x54, \
+                                  SH_DMAC_BASE + 0x74, SH_DMAC_BASE + 0x84})
+#define DMATCR ((unsigned long[]){SH_DMAC_BASE + 0x28, SH_DMAC_BASE + 0x38, \
+                                  SH_DMAC_BASE + 0x48, SH_DMAC_BASE + 0x58, \
+                                  SH_DMAC_BASE + 0x78, SH_DMAC_BASE + 0x88})
+#define CHCR   ((unsigned long[]){SH_DMAC_BASE + 0x2C, SH_DMAC_BASE + 0x3C, \
+                                  SH_DMAC_BASE + 0x4C, SH_DMAC_BASE + 0x5C, \
+                                  SH_DMAC_BASE + 0x7C, SH_DMAC_BASE + 0x8C})
+#define DMAOR  (SH_DMAC_BASE + 0x60)
+
+#else
 #define SH_DMAC_BASE	0xffa00000
 
 #define SAR	((unsigned long[]){SH_DMAC_BASE + 0x00, SH_DMAC_BASE + 0x10, \
-				   SH_DMAC_BASE + 0x20, SH_DMAC_BASE + 0x30})
+                                  SH_DMAC_BASE + 0x20, SH_DMAC_BASE + 0x30, \
+                                  SH_DMAC_BASE + 0x50, SH_DMAC_BASE + 0x60, \
+                                  SH_DMAC_BASE + 0x70, SH_DMAC_BASE + 0x80})
 #define DAR	((unsigned long[]){SH_DMAC_BASE + 0x04, SH_DMAC_BASE + 0x14, \
-				   SH_DMAC_BASE + 0x24, SH_DMAC_BASE + 0x34})
+                                  SH_DMAC_BASE + 0x24, SH_DMAC_BASE + 0x34, \
+                                  SH_DMAC_BASE + 0x54, SH_DMAC_BASE + 0x64, \
+                                  SH_DMAC_BASE + 0x74, SH_DMAC_BASE + 0x84})
 #define DMATCR	((unsigned long[]){SH_DMAC_BASE + 0x08, SH_DMAC_BASE + 0x18, \
-				   SH_DMAC_BASE + 0x28, SH_DMAC_BASE + 0x38})
-#define CHCR	((unsigned long[]){SH_DMAC_BASE + 0x0c, SH_DMAC_BASE + 0x1c, \
-				   SH_DMAC_BASE + 0x2c, SH_DMAC_BASE + 0x3c})
+                                  SH_DMAC_BASE + 0x28, SH_DMAC_BASE + 0x38, \
+                                  SH_DMAC_BASE + 0x58, SH_DMAC_BASE + 0x68, \
+                                  SH_DMAC_BASE + 0x78, SH_DMAC_BASE + 0x88})
+#define CHCR	((unsigned long[]){SH_DMAC_BASE + 0x0C, SH_DMAC_BASE + 0x1C, \
+                                  SH_DMAC_BASE + 0x2C, SH_DMAC_BASE + 0x3C, \
+                                  SH_DMAC_BASE + 0x5C, SH_DMAC_BASE + 0x6C, \
+                                  SH_DMAC_BASE + 0x7C, SH_DMAC_BASE + 0x8C})
 #define DMAOR	(SH_DMAC_BASE + 0x40)
+#endif
+
+/* DMAOR regster access method */
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define DMAOR_ERR_CLEAR        \
+{ \
+       unsigned long dmaor0 = ctrl_inl(DMAOR[0]); \
+       unsigned long dmaor1 = ctrl_inl(DMAOR[1]); \
+\
+       printk("DMAE: DMAOR0=%lx\n", dmaor0); \
+       printk("DMAE: DMAOR1=%lx\n", dmaor1); \
+\
+       ctrl_outl(ctrl_inl(DMAOR[0]) & ~DMAOR_NMIF, DMAOR[0]); \
+       ctrl_outl(ctrl_inl(DMAOR[0]) & ~DMAOR_AE, DMAOR[0]); \
+       ctrl_outl(ctrl_inl(DMAOR[0]) | DMAOR_DME, DMAOR[0]); \
+\
+       ctrl_outl(ctrl_inl(DMAOR[1]) & ~DMAOR_NMIF, DMAOR[1]); \
+       ctrl_outl(ctrl_inl(DMAOR[1]) & ~DMAOR_AE, DMAOR[1]); \
+       ctrl_outl(ctrl_inl(DMAOR[1]) | DMAOR_DME, DMAOR[1]); \
+}
+
+#define DMAOR_INIT             ctrl_outw(DMAOR_DME, DMAOR)
+#else
+
+#define DMAOR_ERR_CLEAR        \
+{ \
+       unsigned long dmaor = ctrl_inl(DMAOR); \
+\
+       printk("DMAE: DMAOR=%lx\n", dmaor); \
+\
+       ctrl_outl(ctrl_inl(DMAOR) & ~DMAOR_NMIF, DMAOR); \
+       ctrl_outl(ctrl_inl(DMAOR) & ~DMAOR_AE, DMAOR); \
+       ctrl_outl(ctrl_inl(DMAOR) | DMAOR_DME, DMAOR); \
+}
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7760)
+#define DMAOR_INIT             ctrl_outl(DMAOR_DME, DMAOR)
+#else
+#define DMAOR_INIT             ctrl_outl((0x8000 | DMAOR_DME), DMAOR)
+#endif
+#endif
+
+/* Definitions for the SuperH DMAC */
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+/* command */
+/* CHCR bit */
+#define LCKN           (1 << 30)
+#define RPT_NORMAL     (0 << 25)
+#define RPT_RP_ALL     (1 << 25)
+#define RPT_RP_D_T     (2 << 25)
+#define RPT_RP_S_T     (3 << 25)
+#define RPT_RL_ALL     (5 << 25)
+#define RPT_RL_D_T     (6 << 25)
+#define RPT_RL_S_T     (7 << 25)
+#define OVRRN_DT0      (0 << 23)
+#define OVRRN_DT1      (1 << 23)
+#define RACK_L         (0 << 22)
+#define RACK_H         (1 << 22)
+#define TS_8           0
+#define TS_16          (1 << 3)
+#define TS_32          (2 << 3)
+#define TS_128         (3 << 3) /* 16byte */
+#define TS_256         (1 << 20) /* 32byte */
+#define DMAC_HE                (1 << 19)
+#define DMAC_HIE       (1 << 18)
+#define ACK_R          (0 << 17)
+#define ACK_W          (1 << 17)
+#define ACK_L          (0 << 16)
+#define ACK_H          (1 << 16)
+#define REQ_L_L                (0 << 6)
+#define REQ_D_E                (1 << 6)
+#define REQ_H_L                (2 << 6)
+#define REQ_U_E                (3 << 6)
+#define TM_BURST       (1 << 5)
+
+/* DMAOR bit */
+#define CMS            (0 << 12)
+#define CMS_16         (2 << 12)
+#define CMS_64         (3 << 12)
+
+#else
+#define REQ_L_L                (0 << 19)
+#define REQ_D_E                (1 << 19)
+#define RACK_H         (0 << 18)
+#define RACK_L         (1 << 18)
+#define ACK_R          (0 << 17)
+#define ACK_W          (1 << 17)
+#define ACK_H          (0 << 16)
+#define ACK_L          (1 << 16)
+#define TM_BURST       (1 << 7)
+#define TS_64          (0 << 4)
+#define TS_8           (1 << 4)
+#define TS_16          (2 << 4)
+#define TS_32          (3 << 4)
+#define TS_BLK         (4 << 4)
+#endif
 
 #endif /* __ASM_CPU_SH4_DMA_H */
 
Index: linux-2.6.10/include/asm-sh/cpu-sh4/freq.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/freq.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/freq.h
@@ -12,6 +12,8 @@
 
 #if defined(CONFIG_CPU_SUBTYPE_SH73180)
 #define FRQCR		        0xa4150000
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define FRQCR                  0xffc80000
 #else
 #define FRQCR			0xffc00000
 #endif
Index: linux-2.6.10/include/asm-sh/cpu-sh4/mmu_context.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/mmu_context.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/mmu_context.h
@@ -35,5 +35,9 @@
 #define MMU_I_ENTRY_SHIFT	    8
 #define MMU_ITLB_VALID		0x100
 
+#if defined(CONFIG_CPU_SH4A)
+#define MMU_PASCR              0xFF000070
+#endif
+
 #endif /* __ASM_CPU_SH4_MMU_CONTEXT_H */
 
Index: linux-2.6.10/include/asm-sh/cpu-sh4/pci-sh7780.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/cpu-sh4/pci-sh7780.h
@@ -0,0 +1,130 @@
+/*
+ *	Low-Level PCI Support for SH7780 targets
+ *
+ *  Copyright (C) 2004  Takashi Yoshii, Takashi Kusuda
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#ifndef ASM_SH_CPU_SH4__PCI_SH7780_H
+#define ASM_SH_CPU_SH4__PCI_SH7780_H
+
+#include <linux/pci.h>
+
+/* set debug level 4=verbose...1=terse */
+#undef DEBUG_PCI
+
+#ifdef DEBUG_PCI
+#define PCIDBG(n, x...) { if(DEBUG_PCI>=n) printk(x); }
+#else
+#define PCIDBG(n, x...)
+#endif
+
+/* startup values */
+#define PCI_PROBE_BIOS		1
+#define PCI_PROBE_CONF1		2
+#define PCI_PROBE_CONF2		4
+#define PCI_NO_SORT		0x100
+#define PCI_BIOS_SORT		0x200
+#define PCI_NO_CHECKS		0x400
+#define PCI_ASSIGN_ROMS		0x1000
+#define PCI_BIOS_IRQ_SCAN	0x2000
+
+/* Platform Specific Values */
+#define SH7780_VENDOR_ID	0x1912
+#define SH7780_DEVICE_ID	0x0002
+#define SH7781_DEVICE_ID	0x0001
+
+/* control register */
+#define SH7780_PCI_ECR		0xFE000008
+
+/* SH7780 Specific Values */
+#define SH7780_PCI_CONFIG_BASE	0xFD000000  /* Config space base addr */
+#define SH7780_PCI_CONFIG_SIZE	0x01000000  /* Config space size */
+#define SH7780_PCI_MEMORY_BASE	0xFD000000  /* Memory space base addr */
+#define SH7780_PCI_MEM_SIZE	0x01000000  /* Size of Memory window */
+#define SH7780_PCI_IO_BASE	0xFE200000  /* IO space base address */
+#define SH7780_PCI_IO_SIZE	0x00200000  /* Size of IO window */
+
+#define SH7780_PCIREG_BASE	0xFE040000  /* PCI regs base address */
+#define PCI_REG(n)		(SH7780_PCIREG_BASE + n)
+
+#define SH7780_PCI_VID		0x000
+#define SH7780_PCI_DID		0x002
+#define SH7780_PCI_CMD		0x004
+#define SH7780_PCI_STATUS	0x006
+#define SH7780_PCI_RID		0x008
+#define SH7780_PCI_PIF		0x009
+#define SH7780_PCI_SUB		0x00a
+#define SH7780_PCI_BCC		0x00b
+#define SH7780_PCI_CLS		0x00c
+#define SH7780_PCI_LTM		0x00d
+#define SH7780_PCI_HDR		0x00e
+#define SH7780_PCI_BIST		0x00f
+#define SH7780_PCI_IBAR		0x010
+#define SH7780_PCI_MBAR0	0x014
+#define SH7780_PCI_MBAR1	0x018
+#define SH7780_PCI_SVID		0x02c
+#define SH7780_PCI_SID		0x02e
+#define SH7780_PCI_CP		0x034
+#define SH7780_PCI_INTLINE	0x03c
+#define SH7780_PCI_INTPIN	0x03d
+#define SH7780_PCI_MINGNT	0x03e
+#define SH7780_PCI_MAXLAT	0x03f
+#define SH7780_PCI_CID		0x040
+#define SH7780_PCI_NIP		0x041
+#define SH7780_PCI_PMC		0x042
+#define SH7780_PCI_PMCSR	0x044
+#define SH7780_PCI_PMCSR_BSE	0x046
+#define SH7780_PCI_PCDD		0x047
+
+
+/* SH7780 Internal PCI Registers */
+#define SH7780_PCI_CR		0x100		/* PCI Control Register */
+  #define SH7780_PCICR_PREFIX	0xA5000000	/* CR prefix for write */
+  #define SH7780_PCICR_TRSB	0x00000200	/* Target Read Single */
+  #define SH7780_PCICR_BSWP	0x00000100	/* Target Byte Swap */
+  #define SH7780_PCICR_PLUP	0x00000080	/* Enable PCI Pullup */
+  #define SH7780_PCICR_ARBM	0x00000040	/* PCI Arbitration Mode */
+  #define SH7780_PCICR_MD	0x00000030	/* MD9 and MD10 status */
+  #define SH7780_PCICR_SERR	0x00000008	/* SERR output assert */
+  #define SH7780_PCICR_INTA	0x00000004	/* INTA output assert */
+  #define SH7780_PCICR_PRST	0x00000002	/* PCI Reset Assert */
+  #define SH7780_PCICR_CFIN	0x00000001	/* Central Fun. Init Done */
+
+#define SH7780_PCI_LSR0		0x104	/* PCI Local Space Register0 */
+#define SH7780_PCI_LSR1		0x108	/* PCI Local Space Register1 */
+#define SH7780_PCI_LAR0		0x10C	/* PCI Local Address Register1 */
+#define SH7780_PCI_LAR1		0x110	/* PCI Local Address Register1 */
+#define SH7780_PCI_IR		0x114	/* PCI Interrupt Register */
+#define SH7780_PCI_IMR		0x118	/* PCI Interrupt Mask Register */
+#define SH7780_PCI_AIR		0x11C	/* Error Address Register */
+#define SH7780_PCI_CIR		0x120	/* Error Command/Data Register */
+#define SH7780_PCI_AINT		0x130	/* Arbiter Interrupt Register */
+#define SH7780_PCI_AINTM	0x134	/* Arbiter Int. Mask Register */
+#define SH7780_PCIBMIR		0x138	/* Error Bus Master Register */
+#define SH7780_PCI_PAR		0x1C0	/* PIO Address Register */
+#define SH7780_PCI_PINT		0x1CC	/* Power Mgmnt Int. Register */
+#define SH7780_PCI_PINTM	0x1D0	/* Power Mgmnt Mask Register */
+#define SH7780_PCI_MBR0		0x1E0
+#define SH7780_PCI_MBMR0	0x1E4
+#define SH7780_PCI_MBR1		0x1E8
+#define SH7780_PCI_MBMR1	0x1EC
+#define SH7780_PCI_MBR2		0x1F0
+#define SH7780_PCI_MBMR2	0x1F4
+#define SH7780_PCI_IOBR		0x1F8
+#define SH7780_PCI_IOBMR	0x1FC
+#define SH7780_PCI_CSCR0	0x210
+#define SH7780_PCI_CSCR1	0x214
+#define SH7780_PCI_CSAR0	0x218
+#define SH7780_PCI_CSAR1	0x21c
+#define SH7780_PCI_PDR		0x220	/* Port IO Data Register */
+
+
+extern int pcibios_init_platform(void);
+extern int pcibios_map_platform_irq(u8 slot, u8 pin);
+
+#endif /* ASM_SH_CPU_SH4__PCI_SH7780_H */
+
Index: linux-2.6.10/include/asm-sh/cpu-sh4/rtc.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/rtc.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/rtc.h
@@ -2,22 +2,28 @@
 #define __ASM_CPU_SH4_RTC_H
 
 /* SH-4 RTC */
-#define R64CNT  	0xffc80000
-#define RSECCNT 	0xffc80004
-#define RMINCNT 	0xffc80008
-#define RHRCNT  	0xffc8000c
-#define RWKCNT  	0xffc80010
-#define RDAYCNT 	0xffc80014
-#define RMONCNT 	0xffc80018
-#define RYRCNT  	0xffc8001c  /* 16bit */
-#define RSECAR  	0xffc80020
-#define RMINAR  	0xffc80024
-#define RHRAR   	0xffc80028
-#define RWKAR   	0xffc8002c
-#define RDAYAR  	0xffc80030
-#define RMONAR  	0xffc80034
-#define RCR1    	0xffc80038
-#define RCR2    	0xffc8003c
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define SH_RTC_REG_BASE                0xFFE80000
+#else
+#define SH_RTC_REG_BASE                0xFFC80000
+#endif
+
+#define R64CNT         (SH_RTC_REG_BASE + 0)
+#define RSECCNT                (SH_RTC_REG_BASE + 4)
+#define RMINCNT                (SH_RTC_REG_BASE + 8)
+#define RHRCNT         (SH_RTC_REG_BASE + 12)
+#define RWKCNT         (SH_RTC_REG_BASE + 16)
+#define RDAYCNT                (SH_RTC_REG_BASE + 20)
+#define RMONCNT                (SH_RTC_REG_BASE + 24)
+#define RYRCNT         (SH_RTC_REG_BASE + 28) /* 16bit */
+#define RSECAR         (SH_RTC_REG_BASE + 32)
+#define RMINAR         (SH_RTC_REG_BASE + 36)
+#define RHRAR          (SH_RTC_REG_BASE + 40)
+#define RWKAR          (SH_RTC_REG_BASE + 44)
+#define RDAYAR         (SH_RTC_REG_BASE + 48)
+#define RMONAR         (SH_RTC_REG_BASE + 52)
+#define RCR1           (SH_RTC_REG_BASE + 56)
+#define RCR2           (SH_RTC_REG_BASE + 60)
 
 #define RTC_BIT_INVERTED	0x40	/* bug on SH7750, SH7750S */
 
Index: linux-2.6.10/include/asm-sh/cpu-sh4/sh7780.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/cpu-sh4/sh7780.h
@@ -0,0 +1,273 @@
+#ifndef __ASM_SH_CPU_SH4_SH7780_H
+#define __ASM_SH_CPU_SH4_SH7780_H
+/*
+ * linux/include/asm-sh/cpu-sh4a/sh7780.h
+ *
+ * Copyright (C) 2005 Takashi Kusuda (Feb 4, 2005)
+ */
+
+
+/* INTC register */
+#define INTC_ICR0		0xFFD00000
+#define INTC_INTPRI		0xFFD00010
+#define INTC_ICR1		0xFFD0001C
+#define INTC_INTREQ		0xFFD00024
+#define INTC_INTMSK0		0xFFD00044
+#define INTC_INTMSK1		0xFFD00048
+#define INTC_INTMSK2		0xFFD40080
+#define INTC_INTMSKCLR0		0xFFD00064
+#define INTC_INTMSKCLR1		0xFFD00068
+#define INTC_INTMSKCLR2 	0xFFD40084
+#define INTC_INTNMICR		0xFFD000C0
+#define INTC_USERIMASK  	0xFFD30000
+
+/* INTC2 register */
+#define INTC_INT2PRI0		0xFFD40000
+#define INTC_INT2PRI1		0xFFD40004
+#define INTC_INT2PRI2		0xFFD40008
+#define INTC_INT2PRI3		0xFFD4000C
+#define INTC_INT2PRI4		0xFFD40010
+#define INTC_INT2PRI5		0xFFD40014
+#define INTC_INT2PRI6		0xFFD40018
+#define INTC_INT2PRI7		0xFFD4001C
+
+#define INTC_INT2A0		0xFFD40030
+#define INTC_INT2A1		0xFFD40034
+#define INTC_INT2MSKRG		0xFFD40038
+#define INTC_INT2MSKCR		0xFFD4003C
+#define INTC_INT2B0		0xFFD40040
+#define INTC_INT2B1		0xFFD40044
+#define INTC_INT2B2		0xFFD40048
+#define INTC_INT2B3		0xFFD4004C
+#define INTC_INT2B4		0xFFD40050
+#define INTC_INT2B5		0xFFD40054
+#define INTC_INT2B6		0xFFD40058
+#define INTC_INT2B7		0xFFD4005C
+
+#define INTC_INT2GPIC		0xFFD40090
+
+
+/* Timer IRQ */
+#define TIMER_IRQ	INTEVT2_TO_IRQ(0x580)
+
+/* SH DMAC */
+#define DMTE0_IRQ	INTEVT2_TO_IRQ(0x640)
+#define DMTE4_IRQ	INTEVT2_TO_IRQ(0x780)
+#define DMTE8_IRQ	INTEVT2_TO_IRQ(0xD80)
+#define DMAE_IRQ	INTEVT2_TO_IRQ(0x6C0)
+
+
+/* IPR Initialize info table */
+#define SH4A_INTC2_INIT_TABLE  \
+{ \
+	/* IPRA */ \
+	{TIMER_IRQ, INTC_INT2MSKRG, INTC_INT2MSKCR, 0}, /* TMU0 */ \
+	{INTEVT2_TO_IRQ(0x5A0), INTC_INT2MSKRG, INTC_INT2MSKCR, 0}, /* TMU1 */ \
+	{INTEVT2_TO_IRQ(0x5C0), INTC_INT2MSKRG, INTC_INT2MSKCR, 0}, /* TMU2 */ \
+	{INTEVT2_TO_IRQ(0x5E0), INTC_INT2MSKRG, INTC_INT2MSKCR, 0}, /* TMU2IC */ \
+\
+	{INTEVT2_TO_IRQ(0xE00), INTC_INT2MSKRG, INTC_INT2MSKCR, 1}, /* TMU3 */ \
+	{INTEVT2_TO_IRQ(0xE20), INTC_INT2MSKRG, INTC_INT2MSKCR, 1}, /* TMU4 */ \
+	{INTEVT2_TO_IRQ(0xE40), INTC_INT2MSKRG, INTC_INT2MSKCR, 1}, /* TMU5 */ \
+\
+	{INTEVT2_TO_IRQ(0x480), INTC_INT2MSKRG, INTC_INT2MSKCR, 2}, /* RTC ati */ \
+	{INTEVT2_TO_IRQ(0x4A0), INTC_INT2MSKRG, INTC_INT2MSKCR, 2}, /* RTC pri */ \
+	{INTEVT2_TO_IRQ(0x4C0), INTC_INT2MSKRG, INTC_INT2MSKCR, 2}, /* RTC cui */ \
+\
+	{INTEVT2_TO_IRQ(0x700), INTC_INT2MSKRG, INTC_INT2MSKCR, 3}, /* SCIF0 eri */ \
+	{INTEVT2_TO_IRQ(0x720), INTC_INT2MSKRG, INTC_INT2MSKCR, 3}, /* SCIF0 rxi */ \
+	{INTEVT2_TO_IRQ(0x740), INTC_INT2MSKRG, INTC_INT2MSKCR, 3}, /* SCIF0 bri */ \
+	{INTEVT2_TO_IRQ(0x760), INTC_INT2MSKRG, INTC_INT2MSKCR, 3}, /* SCIF0 txi */ \
+\
+	{INTEVT2_TO_IRQ(0xB80), INTC_INT2MSKRG, INTC_INT2MSKCR, 4}, /* SCIF1 eri */ \
+	{INTEVT2_TO_IRQ(0xBA0), INTC_INT2MSKRG, INTC_INT2MSKCR, 4}, /* SCIF1 rxi */ \
+	{INTEVT2_TO_IRQ(0xBC0), INTC_INT2MSKRG, INTC_INT2MSKCR, 4}, /* SCIF1 bri */ \
+	{INTEVT2_TO_IRQ(0xBE0), INTC_INT2MSKRG, INTC_INT2MSKCR, 4}, /* SCIF1 txi */ \
+\
+	{INTEVT2_TO_IRQ(0x560), INTC_INT2MSKRG, INTC_INT2MSKCR, 5}, /* WDT */ \
+\
+	{DMTE0_IRQ, INTC_INT2MSKRG, INTC_INT2MSKCR, 8},		   /* SuperHwy DMAC0 */ \
+	{INTEVT2_TO_IRQ(0x660), INTC_INT2MSKRG, INTC_INT2MSKCR, 8}, /* SuperHwy DMAC1 */ \
+	{INTEVT2_TO_IRQ(0x680), INTC_INT2MSKRG, INTC_INT2MSKCR, 8}, /* SuperHwy DMAC2 */ \
+	{INTEVT2_TO_IRQ(0x6A0), INTC_INT2MSKRG, INTC_INT2MSKCR, 8}, /* SuperHwy DMAC3 */ \
+	{DMTE4_IRQ, INTC_INT2MSKRG, INTC_INT2MSKCR, 8},		   /* SuperHwy DMAC4 */ \
+	{INTEVT2_TO_IRQ(0x7A0), INTC_INT2MSKRG, INTC_INT2MSKCR, 8}, /* SuperHwy DMAC5 */ \
+	{DMAE_IRQ, INTC_INT2MSKRG, INTC_INT2MSKCR, 8}, /* SuperHwy DMAC dmae */ \
+\
+	{INTEVT2_TO_IRQ(0x7C0), INTC_INT2MSKRG, INTC_INT2MSKCR, 9}, /* SuperHwy DMAC6 */ \
+	{INTEVT2_TO_IRQ(0x7E0), INTC_INT2MSKRG, INTC_INT2MSKCR, 9}, /* SuperHwy DMAC7 */ \
+	{DMTE8_IRQ, INTC_INT2MSKRG, INTC_INT2MSKCR, 9},		   /* SuperHwy DMAC8 */ \
+	{INTEVT2_TO_IRQ(0xDA0), INTC_INT2MSKRG, INTC_INT2MSKCR, 9}, /* SuperHwy DMAC9 */ \
+	{INTEVT2_TO_IRQ(0xDC0), INTC_INT2MSKRG, INTC_INT2MSKCR, 9}, /* SuperHwy DMAC10 */ \
+	{INTEVT2_TO_IRQ(0xDE0), INTC_INT2MSKRG, INTC_INT2MSKCR, 9}, /* SuperHwy DMAC11 */ \
+\
+	{INTEVT2_TO_IRQ(0x900), INTC_INT2MSKRG, INTC_INT2MSKCR, 12},/* CMT */ \
+\
+	{INTEVT2_TO_IRQ(0xA00), INTC_INT2MSKRG, INTC_INT2MSKCR, 14},/* PCI SERR */ \
+	{INTEVT2_TO_IRQ(0xA20), INTC_INT2MSKRG, INTC_INT2MSKCR, 15},/* PCI INTA */ \
+	{INTEVT2_TO_IRQ(0xA40), INTC_INT2MSKRG, INTC_INT2MSKCR, 16},/* PCI INTB */ \
+	{INTEVT2_TO_IRQ(0xA60), INTC_INT2MSKRG, INTC_INT2MSKCR, 17},/* PCI INTC */ \
+	{INTEVT2_TO_IRQ(0xA80), INTC_INT2MSKRG, INTC_INT2MSKCR, 18},/* PCI INTD */ \
+	{INTEVT2_TO_IRQ(0xAA0), INTC_INT2MSKRG, INTC_INT2MSKCR, 19},/* PCI ERR */ \
+	{INTEVT2_TO_IRQ(0xAC0), INTC_INT2MSKRG, INTC_INT2MSKCR, 19},/* PCI PWD3 */ \
+	{INTEVT2_TO_IRQ(0xAE0), INTC_INT2MSKRG, INTC_INT2MSKCR, 19},/* PCI PWD2 */ \
+	{INTEVT2_TO_IRQ(0xB00), INTC_INT2MSKRG, INTC_INT2MSKCR, 19},/* PCI PWD1 */ \
+	{INTEVT2_TO_IRQ(0xB20), INTC_INT2MSKRG, INTC_INT2MSKCR, 19},/* PCI PWD0 */ \
+\
+	{INTEVT2_TO_IRQ(0xC00), INTC_INT2MSKRG, INTC_INT2MSKCR, 20},/* SIOF */ \
+\
+	{INTEVT2_TO_IRQ(0xD00), INTC_INT2MSKRG, INTC_INT2MSKCR, 22},/* MMC fstat */ \
+	{INTEVT2_TO_IRQ(0xD20), INTC_INT2MSKRG, INTC_INT2MSKCR, 22},/* MMC tran */ \
+	{INTEVT2_TO_IRQ(0xD40), INTC_INT2MSKRG, INTC_INT2MSKCR, 22},/* MMC err */ \
+	{INTEVT2_TO_IRQ(0xD60), INTC_INT2MSKRG, INTC_INT2MSKCR, 22},/* MMC frdy */ \
+\
+	{INTEVT2_TO_IRQ(0xE80), INTC_INT2MSKRG, INTC_INT2MSKCR, 23},/* SSI */ \
+\
+	{INTEVT2_TO_IRQ(0xF00), INTC_INT2MSKRG, INTC_INT2MSKCR, 24},/* FLCTL flste */ \
+	{INTEVT2_TO_IRQ(0xF20), INTC_INT2MSKRG, INTC_INT2MSKCR, 24},/* FLCTL fltend */ \
+	{INTEVT2_TO_IRQ(0xF40), INTC_INT2MSKRG, INTC_INT2MSKCR, 24},/* FLCTL fltrq0 */ \
+	{INTEVT2_TO_IRQ(0xF60), INTC_INT2MSKRG, INTC_INT2MSKCR, 24},/* FLCTL fltrq1 */ \
+\
+	{INTEVT2_TO_IRQ(0xF80), INTC_INT2MSKRG, INTC_INT2MSKCR, 25},/* GPIO0 */ \
+	{INTEVT2_TO_IRQ(0xFA0), INTC_INT2MSKRG, INTC_INT2MSKCR, 25},/* GPIO1 */ \
+	{INTEVT2_TO_IRQ(0xFC0), INTC_INT2MSKRG, INTC_INT2MSKCR, 25},/* GPIO2 */ \
+	{INTEVT2_TO_IRQ(0xFE0), INTC_INT2MSKRG, INTC_INT2MSKCR, 25},/* GPIO3 */ \
+\
+	/* End */ \
+	{0, 0, 0, 0} \
+}
+
+/*
+ * INTC2 controled by INTMSK reg/INTMSKCR reg.
+ * So, interrupt priority set at first. (This priority not change)
+ */
+#define SH4A_INTC2_PRIORITY_SETTING { \
+  ctrl_outl(0x1E040404, INTC_INT2PRI0); /* TMU0-ch0/TMU0-ch1/TMU0-ch2/TMU0-ch2IC */ \
+  ctrl_outl(0x04040404, INTC_INT2PRI1); /* TMU0-ch3/TMU0-ch4/TMU0-ch5/RTC */ \
+  ctrl_outl(0x0E0E0400, INTC_INT2PRI2); /* SCIF0/SCIF1/WDT/reserve */ \
+  ctrl_outl(0x00090900, INTC_INT2PRI3); /* H-UDI/SHwy-DMAC0/SHwy-DMAC1/reserve */ \
+  ctrl_outl(0x04000614, INTC_INT2PRI4); /* CMT/HAC/PCIC0/PCIC1 */ \
+  ctrl_outl(0x16181A00, INTC_INT2PRI5); /* PCIC2/PCIC3/PCIC4/PCIC5 */ \
+  ctrl_outl(0x0A00040A, INTC_INT2PRI6); /* SIOF/HSPI/MMC/SSI */ \
+  ctrl_outl(0x04040000, INTC_INT2PRI7); /* FLCTL/GPIO/reserve/reserve */ \
+}
+
+
+/* IRL/IRQ[0:7] IRQ number */
+#define SH7780_IRQ0_INTNUM	2	/* INTEVT2: 0x220 */
+#define SH7780_IRQ1_INTNUM	4	/* INTEVT2: 0x240 */
+#define SH7780_IRQ2_INTNUM	6	/* INTEVT2: 0x260 */
+#define SH7780_IRQ3_INTNUM	8	/* INTEVT2: 0x280 */
+#define SH7780_IRQ4_INTNUM	10	/* INTEVT2: 0x2A0 */
+#define SH7780_IRQ5_INTNUM	12	/* INTEVT2: 0x2C0 */
+#define SH7780_IRQ6_INTNUM	14	/* INTEVT2: 0x2E0 */
+#define SH7780_IRQ7_INTNUM	0	/* INTEVT2: 0x200 */
+
+/*
+ * INTEVT code of IRL7:4 is the same as IRL3:0.
+ * SH7780_IRL15 is the highest priority
+ */
+#define SH7780_IRL15_INTNUM	0	/* INTEVT2: 0x200 */
+#define SH7780_IRL14_INTNUM	1	/* INTEVT2: 0x220 */
+#define SH7780_IRL13_INTNUM	2	/* INTEVT2: 0x240 */
+#define SH7780_IRL12_INTNUM	3	/* INTEVT2: 0x260 */
+#define SH7780_IRL11_INTNUM	4	/* INTEVT2: 0x280 */
+#define SH7780_IRL10_INTNUM	5	/* INTEVT2: 0x2A0 */
+#define SH7780_IRL9_INTNUM	6	/* INTEVT2: 0x2C0 */
+#define SH7780_IRL8_INTNUM	7	/* INTEVT2: 0x2E0 */
+#define SH7780_IRL7_INTNUM	8	/* INTEVT2: 0x300 */
+#define SH7780_IRL6_INTNUM	9	/* INTEVT2: 0x320 */
+#define SH7780_IRL5_INTNUM	10	/* INTEVT2: 0x340 */
+#define SH7780_IRL4_INTNUM	11	/* INTEVT2: 0x360 */
+#define SH7780_IRL3_INTNUM	12	/* INTEVT2: 0x380 */
+#define SH7780_IRL2_INTNUM	13	/* INTEVT2: 0x3A0 */
+#define SH7780_IRL1_INTNUM	14	/* INTEVT2: 0x3C0 */
+
+/* IRL/IRQ[0:7] INTMSK/INTMSKCLR register bit position */
+/* SH7780_IRQx_POS is at INTMSK0/INTMSKCLR0 */
+#define SH7780_IRQ0_POS		31
+#define SH7780_IRQ1_POS		30
+#define SH7780_IRQ2_POS		29
+#define SH7780_IRQ3_POS		28
+#define SH7780_IRQ4_POS		27
+#define SH7780_IRQ5_POS		26
+#define SH7780_IRQ6_POS		25
+#define SH7780_IRQ7_POS		24
+
+/* SH7780_IRLx_POS is at INTMSK2/INTMSKCLR2 */
+#define SH7780_IM015_POS		31
+#define SH7780_IM014_POS		30
+#define SH7780_IM013_POS		29
+#define SH7780_IM012_POS		28
+#define SH7780_IM011_POS		27
+#define SH7780_IM010_POS		26
+#define SH7780_IM09_POS			25
+#define SH7780_IM08_POS			24
+#define SH7780_IM07_POS			23
+#define SH7780_IM06_POS			22
+#define SH7780_IM05_POS			21
+#define SH7780_IM04_POS			20
+#define SH7780_IM03_POS			19
+#define SH7780_IM02_POS			18
+#define SH7780_IM01_POS			17
+#define SH7780_IM115_POS		15
+#define SH7780_IM114_POS		14
+#define SH7780_IM113_POS		13
+#define SH7780_IM112_POS		12
+#define SH7780_IM111_POS		11
+#define SH7780_IM110_POS		10
+#define SH7780_IM19_POS			9
+#define SH7780_IM18_POS			8
+#define SH7780_IM17_POS			7
+#define SH7780_IM16_POS			6
+#define SH7780_IM15_POS			5
+#define SH7780_IM14_POS			4
+#define SH7780_IM13_POS			3
+#define SH7780_IM12_POS			2
+#define SH7780_IM11_POS			1
+
+
+/* ONCHIP_NR_IRQS */
+# define ONCHIP_NR_IRQS		112
+# define PINT_NR_IRQS		 0
+
+
+/* GPIO control register */
+#define GPIO_PACR	0xFFEA0000
+#define GPIO_PBCR	0xFFEA0002
+#define GPIO_PCCR	0xFFEA0004
+#define GPIO_PDCR	0xFFEA0006
+#define GPIO_PECR	0xFFEA0008
+#define GPIO_PFCR	0xFFEA000A
+#define GPIO_PGCR	0xFFEA000C
+#define GPIO_PHCR	0xFFEA000E
+#define GPIO_PJCR	0xFFEA0010
+#define GPIO_PKCR	0xFFEA0012
+#define GPIO_PLCR	0xFFEA0014
+#define GPIO_PMCR	0xFFEA0016
+
+/* GPIO data register */
+#define GPIO_PADR	0xFFEA0020
+#define GPIO_PBDR	0xFFEA0022
+#define GPIO_PCDR	0xFFEA0024
+#define GPIO_PDDR	0xFFEA0026
+#define GPIO_PEDR	0xFFEA0028
+#define GPIO_PFDR	0xFFEA002A
+#define GPIO_PGDR	0xFFEA002C
+#define GPIO_PHDR	0xFFEA002E
+#define GPIO_PJDR	0xFFEA0030
+#define GPIO_PKDR	0xFFEA0032
+#define GPIO_PLDR	0xFFEA0034
+#define GPIO_PMDR	0xFFEA0036
+
+/* GPIO pull-up control register */
+#define GPIO_PEPUPR	0xFFEA0048
+#define GPIO_PHPUPR	0xFFEA004E
+#define GPIO_PJPUPR	0xFFEA0050
+#define GPIO_PKPUPR	0xFFEA0052
+#define GPIO_PMPUPR	0xFFEA0056
+#define GPIO_PPUPR1	0xFFEA0060
+#define GPIO_PPUPR2	0xFFEA0062
+#define GPIO_PMSELR	0xFFEA0080
+
+#endif /* __ASM_SH_CPU_SH4_SH7780_H */
Index: linux-2.6.10/include/asm-sh/cpu-sh4/watchdog.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/cpu-sh4/watchdog.h
+++ linux-2.6.10/include/asm-sh/cpu-sh4/watchdog.h
@@ -11,8 +11,18 @@
 #define __ASM_CPU_SH4_WATCHDOG_H
 
 /* Register definitions */
-#define WTCNT		0xffc00008
-#define WTCSR		0xffc0000c
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define SH_WDT_BASE_ADDR       0xFFCC0000
+#define WTST                   (SH_WDT_BASE_ADDR + 0)
+#define WTCSR                  (SH_WDT_BASE_ADDR + 4)
+#define WTBST                  (SH_WDT_BASE_ADDR + 8)
+#define WTCNT                  (SH_WDT_BASE_ADDR + 16)
+#define WTBCST                 (SH_WDT_BASE_ADDR + 24)
+#else
+#define SH_WDT_BASE_ADDR       0xFFC00000
+#define WTCNT                  (SH_WDT_BASE_ADDR + 8)
+#define WTCSR                  (SH_WDT_BASE_ADDR + 12)
+#endif
 
 /* Bit definitions */
 #define WTCSR_TME	0x80
Index: linux-2.6.10/include/asm-sh/ide.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/ide.h
+++ linux-2.6.10/include/asm-sh/ide.h
@@ -20,7 +20,66 @@
 #define MAX_HWIFS	CONFIG_IDE_MAX_HWIFS
 #endif
 
+#define IDE_ARCH_OBSOLETE_DEFAULTS
+
+/*
+ * IRQ_IDEx must be defined at asm/mach/irq.h
+ * (Because this interrupt numbers depend on platform.)
+ */
+#ifndef IRQ_IDE0
+#define IRQ_IDE0       0
+#endif
+#ifndef IRQ_IDE1
+#define IRQ_IDE1       0
+#endif
+#ifndef IRQ_IDE2
+#define IRQ_IDE2       0
+#endif
+#ifndef IRQ_IDE3
+#define IRQ_IDE3       0
+#endif
+#ifndef IRQ_IDE4
+#define IRQ_IDE4       0
+#endif
+#ifndef IRQ_IDE5
+#define IRQ_IDE5        0
+#endif
+static __inline__ int ide_default_irq(unsigned long base)
+{
+       switch (base) {
+               case 0x1f0: return IRQ_IDE0;
+               case 0x170: return IRQ_IDE1;
+               case 0x1e8: return IRQ_IDE2;
+               case 0x168: return IRQ_IDE3;
+               case 0x1e0: return IRQ_IDE4;
+               case 0x160: return IRQ_IDE5;
+               default:
+                       return 0;
+       }
+}
+
+static __inline__ unsigned long ide_default_io_base(int index)
+{
+       switch (index) {
+               case 0: return 0x1f0;
+               case 1: return 0x170;
+               case 2: return 0x1e8;
+               case 3: return 0x168;
+               case 4: return 0x1e0;
+               case 5: return 0x160;
+               default:
+                       return 0;
+       }
+}
+
+#define IDE_ARCH_OBSOLETE_INIT
+
 #define ide_default_io_ctl(base)	(0)
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#define ide_init_default_irq(base)     (0)
+#else
+#define ide_init_default_irq(base)     ide_default_irq(base)
+#endif
 
 #include <asm-generic/ide_iops.h>
 
Index: linux-2.6.10/include/asm-sh/io.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/io.h
+++ linux-2.6.10/include/asm-sh/io.h
@@ -295,6 +295,13 @@ out:
 #define dma_cache_wback(_start,_size) \
     __flush_wback_region(_start,_size)
 
+#define ioread8(a)     readb(a)
+#define ioread16(a)    readw(a)
+#define ioread32(a)    readl(a)
+#define iowrite8(a,b)  writeb(a,b)
+#define iowrite16(a,b) writew(a,b)
+#define iowrite32(a,b) writel(a,b)
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASM_SH_IO_H */
Index: linux-2.6.10/include/asm-sh/irq.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/irq.h
+++ linux-2.6.10/include/asm-sh/irq.h
@@ -12,15 +12,53 @@
  */
 
 #include <linux/config.h>
+#include <linux/init.h>
 #include <asm/machvec.h>
 #include <asm/ptrace.h>		/* for pt_regs */
 
+/* for initializing IPR regs */
+struct sh_ipr_irq_info
+{
+       unsigned int irq;
+       unsigned int addr;
+       unsigned int pos;
+       unsigned int priority;
+};
+
+/* for initializing INTC2 regs */
+struct sh_intc2_irq_info
+{
+       unsigned int irq;
+       unsigned int addr;
+       unsigned int group;
+       unsigned int pos;
+       unsigned int priority;
+};
+
+/* for initializing INTMSK regs */
+struct sh_intmsk_irq_info
+{
+       unsigned int irq;
+       unsigned int pri_addr;
+       unsigned int pri_pos;
+       unsigned int priority;
+       unsigned int mask_addr;
+       unsigned int mask_pos;
+};
+
 #if defined(CONFIG_SH_HP600) || \
     defined(CONFIG_SH_RTS7751R2D) || \
     defined(CONFIG_SH_HS7751RVOIP)
 #include <asm/mach/ide.h>
 #endif
 
+#if defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define INTEVT2_TO_IRQ(evt)    ((evt-0x200)/32)
+# include <asm/cpu/sh7780.h>
+extern void make_sh4a_intc_irq(unsigned int irq, unsigned int mask_addr,
+		                                unsigned int unmask_addr, int pos);
+#else /* CONFIG_CPU_SUBTYPE_SH7780 */
+
 #if defined(CONFIG_CPU_SH3)
 #define INTC_IPRA	0xfffffee2UL
 #define INTC_IPRB	0xfffffee4UL
@@ -236,6 +274,7 @@
 #define SCIF1_PRIORITY	3
 #endif
 #endif
+#endif /* CONFIG_CPU_SUBTYPE_SH7780 */
 
 /* NR_IRQS is made from three components:
  *   1. ONCHIP_NR_IRQS - number of IRLS + on-chip peripherial modules
Index: linux-2.6.10/include/asm-sh/module.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/module.h
+++ linux-2.6.10/include/asm-sh/module.h
@@ -19,7 +19,11 @@ struct mod_arch_specific {
 # elif defined  CONFIG_CPU_SH3
 #  define MODULE_PROC_FAMILY "SH3LE "
 # elif defined  CONFIG_CPU_SH4
-#  define MODULE_PROC_FAMILY "SH4LE "
+#  if defined CONFIG_CPU_SH4A
+#   define MODULE_PROC_FAMILY "SH4ALE "
+#  else
+#   define MODULE_PROC_FAMILY "SH4LE "
+#  endif
 # else
 #  error unknown processor family
 # endif
@@ -29,7 +33,11 @@ struct mod_arch_specific {
 # elif defined  CONFIG_CPU_SH3
 #  define MODULE_PROC_FAMILY "SH3BE "
 # elif defined  CONFIG_CPU_SH4
-#  define MODULE_PROC_FAMILY "SH4BE "
+#  if defined CONFIG_CPU_SH4A
+#   define MODULE_PROC_FAMILY "SH4ABE "
+#  else
+#   define MODULE_PROC_FAMILY "SH4BE "
+#  endif
 # else
 #  error unknown processor family
 # endif
Index: linux-2.6.10/include/asm-sh/processor.h
===================================================================
--- linux-2.6.10.orig/include/asm-sh/processor.h
+++ linux-2.6.10/include/asm-sh/processor.h
@@ -44,12 +44,36 @@ enum cpu_type {
 	/* SH-4 types */
 	CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
 	CPU_SH7760, CPU_ST40RA, CPU_ST40GX1, CPU_SH4_202, CPU_SH4_501,
-	CPU_SH73180,
+
+	/* SH-4A types */
+	CPU_SH73180, CPU_SH7780, CPU_SH7781,
 
 	/* Unknown subtype */
 	CPU_SH_NONE
 };
 
+/* CPU ID */
+/* bit[31:28] depend on chip version */
+#define SH7300_CPU_ID  (0x0025200F & 0x0fffffff)
+#define SH7705_CPU_ID  (0x001A200F & 0x0fffffff)
+#define SH7710_CPU_ID  (0x001E200F & 0x0fffffff)
+#define SH7720_CPU_ID  (0x002F200F & 0x0fffffff)
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7705)
+#define SDID_H_ADDR    0xA4000214
+#define SDID_L_ADDR    0xA4000216
+#elif defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7710) || \
+      defined(CONFIG_CPU_SUBTYPE_SH7720)
+#define SDID_H_ADDR    0xA4100214
+#define SDID_L_ADDR    0xA4100216
+#endif
+
+#if defined(SDID_H_ADDR)
+#define CPU_ID ((((unsigned long)(ctrl_inw(SDID_H_ADDR)<<16)) | ctrl_inw(SDID_L_ADDR)) & (0x0fffffff))
+#else
+#define CPU_ID         (0)
+#endif
+
 struct sh_cpuinfo {
 	enum cpu_type type;
 	char	hard_math;
Index: linux-2.6.10/include/asm-sh/se7780/io.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/se7780/io.h
@@ -0,0 +1,44 @@
+/*
+ * include/asm-sh/se7780/io.h
+ *
+ * Copyright (C)  2005  Takashi Kusuda
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * IO functions for an Hitachi SH7780 SolutionEngine
+ */
+
+#ifndef _ASM_SH_SE7780_IO_H
+#define _ASM_SH_SE7780_IO_H
+
+extern unsigned char sh7780se_inb(unsigned long port);
+extern unsigned short sh7780se_inw(unsigned long port);
+extern unsigned int sh7780se_inl(unsigned long port);
+
+extern void sh7780se_outb(unsigned char value, unsigned long port);
+extern void sh7780se_outw(unsigned short value, unsigned long port);
+extern void sh7780se_outl(unsigned int value, unsigned long port);
+
+extern unsigned char sh7780se_inb_p(unsigned long port);
+extern void sh7780se_outb_p(unsigned char value, unsigned long port);
+
+extern void sh7780se_insb(unsigned long port, void *addr, unsigned long count);
+extern void sh7780se_insw(unsigned long port, void *addr, unsigned long count);
+extern void sh7780se_insl(unsigned long port, void *addr, unsigned long count);
+extern void sh7780se_outsb(unsigned long port, const void *addr, unsigned long count);
+extern void sh7780se_outsw(unsigned long port, const void *addr, unsigned long count);
+extern void sh7780se_outsl(unsigned long port, const void *addr, unsigned long count);
+
+extern unsigned char sh7780se_readb(unsigned long addr);
+extern unsigned short sh7780se_readw(unsigned long addr);
+extern unsigned int sh7780se_readl(unsigned long addr);
+extern void sh7780se_writeb(unsigned char b, unsigned long addr);
+extern void sh7780se_writew(unsigned short b, unsigned long addr);
+extern void sh7780se_writel(unsigned int b, unsigned long addr);
+
+extern unsigned long sh7780se_isa_port2addr(unsigned long offset);
+extern void * sh7780se_ioremap(unsigned long offset, unsigned long size);
+extern void sh7780se_iounmap(void *addr);
+
+#endif /* _ASM_SH_SE7780_IO_H */
Index: linux-2.6.10/include/asm-sh/se7780/irq.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/se7780/irq.h
@@ -0,0 +1,60 @@
+#ifndef __ASM_SH_SE7780_IRQ_H
+#define __ASM_SH_SE7780_IRQ_H
+
+/*
+ * linux/include/asm-sh/se7780/irq.h
+ *
+ * Copyright (C) 2004  Takashi Kusuda
+ *
+ *  Hitachi SolutionEngine support
+ *
+ *  Modified for 7780 Solution Engine
+ */
+
+#include <asm/mach/map.h>
+#include <asm/irq.h>
+
+/* interrupt numer */
+#define IRQ_SM501		SH7780_IRQ7_INTNUM	/* 0 */
+#define IRQ_PCCPW		SH7780_IRQ7_INTNUM	/* 0 */
+#define IRQ_EXTINT1		SH7780_IRQ0_INTNUM	/* 2 */
+#define IRQ_EXTINT2		SH7780_IRQ1_INTNUM	/* 4 */
+#define IRQ_EXTINT3		SH7780_IRQ2_INTNUM	/* 6 */
+#define IRQ_SMC91CX		SH7780_IRQ3_INTNUM	/* 8 */
+#define IRQ_EXTINT4		SH7780_IRQ4_INTNUM	/* 10 */
+#define IRQ_PCC0		SH7780_IRQ5_INTNUM	/* 12 */
+#define IRQ_PCC2		SH7780_IRQ6_INTNUM	/* 14 */
+
+/* interrupt pin */
+#define IRQPIN_EXTINT1		0 /* IRQ0 pin */
+#define IRQPIN_EXTINT2		1 /* IRQ1 pin */
+#define IRQPIN_EXTINT3		2 /* IRQ2 pin */
+#define IRQPIN_SMC91CX		3 /* IRQ3 pin */
+#define IRQPIN_EXTINT4		4 /* IRQ4 pin */
+#define IRQPIN_PCC0		5 /* IRQ5 pin */
+#define IRQPIN_PCC2		6 /* IRQ6 pin */
+#define IRQPIN_SM501		7 /* IRQ7 pin */
+#define IRQPIN_PCCPW		7 /* IRQ7 pin */
+
+/* FPGA INTSEL position */
+/* INTSEL1 */
+#define IRQPOS_SMC91CX		(0 * 4)
+#define IRQPOS_SM501		(1 * 4)
+#define IRQPOS_PCC0		(2 * 4)
+#define IRQPOS_PCC2		(3 * 4)
+/* INTSEL2 */
+#define IRQPOS_EXTINT1		(0 * 4)
+#define IRQPOS_EXTINT2		(1 * 4)
+#define IRQPOS_EXTINT3		(2 * 4)
+#define IRQPOS_EXTINT4		(3 * 4)
+/* INTSEL3 */
+#define IRQPOS_PCCPW		(0 * 4)
+
+/* IDE interrupt */
+#define IRQ_IDE0		67 /* iVDR */
+#define IRQ_IDE1		65 /* PCI slot */
+
+/* SMC interrupt */
+#define SMC_IRQ			IRQ_SMC91CX /* 8 */
+
+#endif  /* __ASM_SH_SE7780_IRQ_H */
Index: linux-2.6.10/include/asm-sh/se7780/map.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/se7780/map.h
@@ -0,0 +1,76 @@
+#ifndef __ASM_SH_SE7780_MAP_H
+#define __ASM_SH_SE7780_MAP_H
+
+/*
+ * linux/include/asm-sh/se7780/map.h
+ *
+ * Copyright (C) 2005  Takashi Kusuda
+ *
+ *  Hitachi SH7780 SolutionEngine support
+ *
+ *  Modified for SH7780 Solution Engine
+ */
+
+/* Box specific addresses.  */
+
+#define SE_AREA0_WIDTH	4		/* Area0: 32bit */
+#define PA_ROM		0xa0000000	/* EPROM */
+#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
+#define PA_FROM		0xa1000000	/* Flash-ROM */
+#define PA_FROM_SIZE	0x01000000	/* Flash-ROM size 16M byte */
+#define PA_EXT1		0xa4000000
+#define PA_EXT1_SIZE	0x04000000
+#define PA_SM501	PA_EXT1		/* Graphic IC (SM501) */
+#define PA_SDRAM	0xa8000000	/* DDR-SDRAM(Area2/3) 128MB */
+#define PA_SDRAM_SIZE	0x08000000
+
+#define PA_EXT4		0xb0000000
+#define PA_EXT4_SIZE	0x04000000
+#define PA_EXT_FLASH	PA_EXT4		/* Expansion Flash-ROM */
+
+#define PA_EXT5		0xb4000000
+#define PA_EXT5_SIZE	0x04000000
+#define PA_EXT6		0xb8000000
+#define PA_EXT6_SIZE	0x04000000
+
+#define PA_PERIPHERAL	PA_EXT6		/* SW6-6=ON */
+
+#define PA_LAN		(PA_PERIPHERAL + 0) /* SMC LAN91C111 */
+#define PA_SWITCH_L	(PA_PERIPHERAL + 0x01000000) /* DipSW(SW2,3)
+							SW2: D15-D8
+							SW3: D7-D0 */
+#define PA_SWITCH_U	(PA_PERIPHERAL + 0x01000002) /* DipSW(SW4,5)
+							SW4: D15-D8
+							SW5: D7-D0 */
+#define PA_LED_DISP	(PA_PERIPHERAL + 0x02000000) /* 8words LED Display */
+#define DISP_CHAR_RAM	(7 << 3)
+#define DISP_SEL0_ADDR	(DISP_CHAR_RAM + 0)
+#define DISP_SEL1_ADDR	(DISP_CHAR_RAM + 1)
+#define DISP_SEL2_ADDR	(DISP_CHAR_RAM + 2)
+#define DISP_SEL3_ADDR	(DISP_CHAR_RAM + 3)
+#define DISP_SEL4_ADDR	(DISP_CHAR_RAM + 4)
+#define DISP_SEL5_ADDR	(DISP_CHAR_RAM + 5)
+#define DISP_SEL6_ADDR	(DISP_CHAR_RAM + 6)
+#define DISP_SEL7_ADDR	(DISP_CHAR_RAM + 7)
+
+#define DISP_UDC_RAM	(5 << 3)
+#define PA_FPGA		(PA_PERIPHERAL + 0x03000000) /* FPGA base address */
+
+/* FPGA register address and bit */
+#define FPGA_SFTRST		(PA_FPGA + 0)	/* Soft reset register */
+#define FPGA_INTMSK1		(PA_FPGA + 2)	/* Interrupt Mask register 1 */
+#define FPGA_INTMSK2		(PA_FPGA + 4)	/* Interrupt Mask register 2 */
+#define FPGA_INTSEL1		(PA_FPGA + 6)	/* Interrupt select register 1 */
+#define FPGA_INTSEL2		(PA_FPGA + 8)	/* Interrupt select register 2 */
+#define FPGA_INTSEL3		(PA_FPGA + 10)	/* Interrupt select register 3 */
+#define FPGA_PCI_INTSEL1	(PA_FPGA + 12)	/* PCI Interrupt select register 1 */
+#define FPGA_PCI_INTSEL2	(PA_FPGA + 14)	/* PCI Interrupt select register 2 */
+#define FPGA_INTSTS1		(PA_FPGA + 18)	/* Interrupt status register 1 */
+#define FPGA_INTSTS2		(PA_FPGA + 20)	/* Interrupt status register 2 */
+#define FPGA_REQSEL		(PA_FPGA + 22)	/* REQ/GNT select register */
+#define FPGA_DBG_LED		(PA_FPGA + 32)	/* Debug LED(D-LED[8:1] */
+#define FPGA_IVDRID		(PA_FPGA + 36)	/* iVDR ID Register */
+#define FPGA_IVDRPW		(PA_FPGA + 38)	/* iVDR Power ON Register */
+#define FPGA_MMCID		(PA_FPGA + 40)	/* MMC ID Register */
+
+#endif  /* __ASM_SH_SE7780_MAP_H */
Index: linux-2.6.10/include/asm-sh/vga.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-sh/vga.h
@@ -0,0 +1,21 @@
+/*
+ *     Access to VGA videoram
+ *
+ *     (c) 1998 Martin Mares <mj@ucw.cz>
+ */
+
+#ifndef _LINUX_ASM_VGA_H_
+#define _LINUX_ASM_VGA_H_
+
+/*
+ *     On the PC, we can just recalculate addresses and then
+ *     access the videoram directly without any black magic.
+ */
+
+#define VGA_MAP_MEM(x) (unsigned long)phys_to_virt(x)
+
+#define vga_readb(x) (*(x))
+#define vga_writeb(x,y) (*(y) = (x))
+
+#endif
+
Index: linux-2.6.10/mvl_patches/pro-1317.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1317.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1317);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

