#! /usr/bin/env bash
# Patch: -pro_arm_davinci_mv_1_0_rndis_cdc_hid_support_029
# Date: Mon Jan 21 23:04:06 2008
# Source: Texas Instruments Inc.
# MR: 23073
# Type: Enhancement 
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
#  
# Comments from TI
#   This patch provides RNDIS, CDC and HID support on DaVinci.
# 

PATCHNUM=1655
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments Inc.
MR: 23073
Type: Enhancement 
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:
 
Comments from TI
  This patch provides RNDIS, CDC and HID support on DaVinci.

Index: linux-2.6.10/drivers/usb/musb/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/Kconfig
+++ linux-2.6.10/drivers/usb/musb/Kconfig
@@ -126,6 +126,7 @@ config USB_MUSB_HDRC_HCD
 config USB_INVENTRA_FIFO
 	bool 'Disable DMA (always use PIO)'
 	depends on USB_MUSB_HDRC
+	default n
 	help
 	  All data is copied between memory and FIFO by the CPU.
 	  DMA controllers (from Mentor or otherwise) are ignored.
@@ -143,7 +144,7 @@ config USB_INVENTRA_DMA
 config USB_TI_CPPI_DMA
 	bool
 	depends on USB_MUSB_HDRC && !USB_INVENTRA_FIFO
-	default ARCH_DAVINCI
+	default (ARCH_DAVINCI)
 	help
 	  Enable DMA transfers when TI CPPI DMA is available.
 
Index: linux-2.6.10/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.10/drivers/usb/musb/cppi_dma.c
@@ -12,7 +12,6 @@
 #include "musbdefs.h"
 #include "musb_host.h"
 
-
 /* CPPI DMA status 7-mar:
  *
  * - See musb_{host,gadget}.c for more info
@@ -28,14 +27,14 @@
 #define NUM_TXCHAN_BD       64
 #define NUM_RXCHAN_BD       64
 
-static struct dma_controller *cppi_controller_new(
-		MGC_pfDmaChannelStatusChanged pfDmaChannelStatusChanged,
-		void *musb, u8 *pCoreBase);
+static struct dma_controller *cppi_controller_new(MGC_pfDmaChannelStatusChanged
+						  pfDmaChannelStatusChanged,
+						  void *musb, u8 * pCoreBase);
 static void cppi_controller_destroy(struct dma_controller *pController);
 
 struct dma_controller_factory dma_controller_factory = {
-	.pfNewDmaController	= cppi_controller_new,
-	.pfDestroyDmaController	= cppi_controller_destroy,
+	.pfNewDmaController = cppi_controller_new,
+	.pfDestroyDmaController = cppi_controller_destroy,
 };
 
 static inline void cpu_drain_writebuffer(void)
@@ -49,10 +48,9 @@ static inline void cpu_drain_writebuffer
 #endif
 }
 
-static inline struct cppi_descriptor *
-cppi_bd_alloc(struct cppi_channel *c)
+static inline struct cppi_descriptor *cppi_bd_alloc(struct cppi_channel *c)
 {
-	struct cppi_descriptor	*bd = c->bdPoolHead;
+	struct cppi_descriptor *bd = c->bdPoolHead;
 
 	if (bd)
 		c->bdPoolHead = bd->next;
@@ -79,18 +77,18 @@ cppi_bd_free(struct cppi_channel *c, str
 /* zero out entire rx state RAM entry for the channel */
 static void cppi_reset_rx(struct cppi_rx_stateram *__iomem rx)
 {
-	musb_writel(CAST &rx->buffOffset, 0, 0);
-	musb_writel(CAST &rx->headPtr, 0, 0);
-	musb_writel(CAST &rx->sopDescPtr, 0, 0);
-	musb_writel(CAST &rx->currDescPtr, 0, 0);
-	musb_writel(CAST &rx->currBuffPtr, 0, 0);
-	musb_writel(CAST &rx->pktLength, 0, 0);
-	musb_writel(CAST &rx->byteCount, 0, 0);
+	musb_writel(CAST & rx->buffOffset, 0, 0);
+	musb_writel(CAST & rx->headPtr, 0, 0);
+	musb_writel(CAST & rx->sopDescPtr, 0, 0);
+	musb_writel(CAST & rx->currDescPtr, 0, 0);
+	musb_writel(CAST & rx->currBuffPtr, 0, 0);
+	musb_writel(CAST & rx->pktLength, 0, 0);
+	musb_writel(CAST & rx->byteCount, 0, 0);
 }
 
 static void __init cppi_pool_init(struct cppi *cppi, struct cppi_channel *c)
 {
-	int	j;
+	int j;
 
 	/* initialize channel fields */
 	c->activeQueueHead = NULL;
@@ -104,8 +102,8 @@ static void __init cppi_pool_init(struct
 
 	/* build the BD Free list for the channel */
 	for (j = 0; j < NUM_TXCHAN_BD + 1; j++) {
-		struct cppi_descriptor	*bd;
-		dma_addr_t		dma;
+		struct cppi_descriptor *bd;
+		dma_addr_t dma;
 
 		bd = dma_pool_alloc(cppi->pool, SLAB_KERNEL, &dma);
 		bd->dma = dma;
@@ -117,10 +115,10 @@ static int cppi_channel_abort(struct dma
 
 static void cppi_pool_free(struct cppi_channel *c)
 {
-	struct cppi		*cppi = c->pController;
-	struct cppi_descriptor	*bd;
+	struct cppi *cppi = c->pController;
+	struct cppi_descriptor *bd;
 
-	(void) cppi_channel_abort(&c->Channel);
+	(void)cppi_channel_abort(&c->Channel);
 	c->Channel.bStatus = MGC_DMA_STATUS_UNKNOWN;
 	c->pController = NULL;
 
@@ -136,9 +134,9 @@ static void cppi_pool_free(struct cppi_c
 
 static u8 __init cppi_controller_start(void *pPrivateData)
 {
-	struct cppi	*pController = pPrivateData;
-	void		*__iomem regBase;
-	int		i;
+	struct cppi *pController = pPrivateData;
+	void *__iomem regBase;
+	int i;
 
 	/* do whatever is necessary to start controller */
 	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
@@ -157,13 +155,13 @@ static u8 __init cppi_controller_start(v
 		cppi_pool_init(pController, pController->rxCppi + i);
 
 	/* Do Necessary configuartion in H/w to get started */
-	regBase =  pController->pCoreBase - DAVINCI_BASE_OFFSET;
+	regBase = pController->pCoreBase - DAVINCI_BASE_OFFSET;
 
 	INIT_LIST_HEAD(&pController->tx_complete);
 
 	/* initialise tx/rx channel head pointers to zero */
 	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
-		struct cppi_channel	*txChannel = pController->txCppi + i;
+		struct cppi_channel *txChannel = pController->txCppi + i;
 		struct cppi_tx_stateram *__iomem txState;
 
 		INIT_LIST_HEAD(&txChannel->tx_complete);
@@ -182,7 +180,7 @@ static u8 __init cppi_controller_start(v
 
 	}
 	for (i = 0; i < ARRAY_SIZE(pController->rxCppi); i++) {
-		struct cppi_channel	*rxChannel = pController->rxCppi + i;
+		struct cppi_channel *rxChannel = pController->rxCppi + i;
 		struct cppi_rx_stateram *__iomem rxState;
 
 		INIT_LIST_HEAD(&rxChannel->tx_complete);
@@ -194,9 +192,9 @@ static u8 __init cppi_controller_start(v
 
 	/* enable individual cppi channels */
 	musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
-			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
+		    DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 	musb_writel(regBase, DAVINCI_RXCPPI_INTENAB_REG,
-			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
+		    DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 
 	/* enable tx/rx CPPI control */
 	musb_writel(regBase, DAVINCI_TXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_ENABLE);
@@ -216,16 +214,16 @@ static u8 __init cppi_controller_start(v
 
 static u8 cppi_controller_stop(void *pPrivateData)
 {
-	struct cppi		*pController = pPrivateData;
-	void __iomem		*regBase;
-	int			i;
+	struct cppi *pController = pPrivateData;
+	void __iomem *regBase;
+	int i;
 
 	regBase = pController->pCoreBase - DAVINCI_BASE_OFFSET;
 	/* DISABLE INDIVIDUAL CHANNEL Interrupts */
 	musb_writel(regBase, DAVINCI_TXCPPI_INTCLR_REG,
-			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
+		    DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 	musb_writel(regBase, DAVINCI_RXCPPI_INTCLR_REG,
-			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
+		    DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 
 	DBG(1, "Tearing down RX and TX Channels\n");
 	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
@@ -253,15 +251,18 @@ static u8 cppi_controller_stop(void *pPr
  * (and deallocating) is mostly a way to notice bad housekeeping on
  * the software side.  We assume the irqs are always active.
  */
-static struct dma_channel *
-cppi_channel_allocate(void *pPrivateData, u8 bLocalEnd,
-		u8 bTransmit, u8 bProtocol, u16 wMaxPacketSize)
-{
-	struct cppi		*pController = pPrivateData;
-	u8			chNum;
-	struct cppi_channel	*otgCh;
-	struct musb		*pThis = pController->musb;
-	struct musb_hw_ep	*ep = pThis->aLocalEnd + bLocalEnd;
+static struct dma_channel *cppi_channel_allocate(void *pPrivateData,
+						 u8 bLocalEnd, u8 bTransmit,
+						 u8 bProtocol,
+						 u16 wMaxPacketSize)
+{
+	struct cppi *pController = pPrivateData;
+	u8 chNum;
+	struct cppi_channel *otgCh;
+	struct musb *pThis = pController->musb;
+	struct musb_hw_ep *ep = (struct musb_hw_ep *)(pThis->aLocalEnd +
+						      (bTransmit) ? bLocalEnd *
+						      2 - 1 : bLocalEnd * 2);
 
 	/* remember bLocalEnd: 1..Max_EndPt, and cppi ChNum:0..Max_EndPt-1 */
 	chNum = bLocalEnd - 1;
@@ -286,7 +287,7 @@ cppi_channel_allocate(void *pPrivateData
 	 */
 	if (otgCh->pEndPt)
 		DBG(1, "re-allocating DMA%d %cX channel %p\n",
-				chNum, bTransmit ? 'T' : 'R', otgCh);
+		    chNum, bTransmit ? 'T' : 'R', otgCh);
 	otgCh->pEndPt = ep;
 	otgCh->Channel.bStatus = MGC_DMA_STATUS_FREE;
 
@@ -298,7 +299,7 @@ cppi_channel_allocate(void *pPrivateData
 /* Release a CPPI Channel.  */
 static void cppi_channel_release(struct dma_channel *channel)
 {
-	struct cppi_channel	*c;
+	struct cppi_channel *c;
 
 	/* REVISIT:  for paranoia, check state and abort if needed... */
 
@@ -312,70 +313,50 @@ static void cppi_channel_release(struct 
 }
 
 /* Context: controller irqlocked */
-static void
-cppi_dump_rx(int level, struct cppi_channel *c, const char *tag)
+static void cppi_dump_rx(int level, struct cppi_channel *c, const char *tag)
 {
-	void	*__iomem base = c->pController->pCoreBase;
+	void *__iomem base = c->pController->pCoreBase;
 
 	MGC_SelectEnd(base, c->chNo + 1);
 
-	DBG(level, "RX DMA%d%s: %d left, csr %04x, "
-			"%08x H%08x S%08x C%08x, "
-			"B%08x L%08x %08x .. %08x"
-			"\n",
-		c->chNo, tag,
-		musb_readl(base - DAVINCI_BASE_OFFSET,
-			DAVINCI_RXCPPI_BUFCNT0_REG + 4 *c->chNo),
-		MGC_ReadCsr16(base, MGC_O_HDRC_RXCSR, c->chNo + 1),
-
-		musb_readl(c->stateRam, 0 * 4),	/* buf offset */
-		musb_readl(c->stateRam, 1 * 4),	/* head ptr */
-		musb_readl(c->stateRam, 2 * 4),	/* sop bd */
-		musb_readl(c->stateRam, 3 * 4),	/* current bd */
-
-		musb_readl(c->stateRam, 4 * 4),	/* current buf */
-		musb_readl(c->stateRam, 5 * 4),	/* pkt len */
-		musb_readl(c->stateRam, 6 * 4),	/* byte cnt */
-		musb_readl(c->stateRam, 7 * 4)	/* completion */
-		);
+	DBG(level, "RX DMA%d%s: %d left, csr %04x, " "%08x H%08x S%08x C%08x, " "B%08x L%08x %08x .. %08x" "\n", c->chNo, tag, musb_readl(base - DAVINCI_BASE_OFFSET, DAVINCI_RXCPPI_BUFCNT0_REG + 4 * c->chNo), MGC_ReadCsr16(base, MGC_O_HDRC_RXCSR, c->chNo + 1), musb_readl(c->stateRam, 0 * 4),	/* buf offset */
+	    musb_readl(c->stateRam, 1 * 4),	/* head ptr */
+	    musb_readl(c->stateRam, 2 * 4),	/* sop bd */
+	    musb_readl(c->stateRam, 3 * 4),	/* current bd */
+	    musb_readl(c->stateRam, 4 * 4),	/* current buf */
+	    musb_readl(c->stateRam, 5 * 4),	/* pkt len */
+	    musb_readl(c->stateRam, 6 * 4),	/* byte cnt */
+	    musb_readl(c->stateRam, 7 * 4)	/* completion */
+	    );
 }
 
 /* Context: controller irqlocked */
-static void
-cppi_dump_tx(int level, struct cppi_channel *c, const char *tag)
+static void cppi_dump_tx(int level, struct cppi_channel *c, const char *tag)
 {
-	void	*__iomem base = c->pController->pCoreBase;
+	void *__iomem base = c->pController->pCoreBase;
 
 	MGC_SelectEnd(base, c->chNo + 1);
 
-	DBG(level, "TX DMA%d%s: csr %04x, "
-			"H%08x S%08x C%08x %08x, "
-			"F%08x L%08x .. %08x"
-			"\n",
-		c->chNo, tag,
-		MGC_ReadCsr16(base, MGC_O_HDRC_TXCSR, c->chNo + 1),
-
-		musb_readl(c->stateRam, 0 * 4),	/* head ptr */
-		musb_readl(c->stateRam, 1 * 4),	/* sop bd */
-		musb_readl(c->stateRam, 2 * 4),	/* current bd */
-		musb_readl(c->stateRam, 3 * 4),	/* buf offset */
-
-		musb_readl(c->stateRam, 4 * 4),	/* flags */
-		musb_readl(c->stateRam, 5 * 4),	/* len */
-		// dummy/unused word 6
-		musb_readl(c->stateRam, 7 * 4)	/* completion */
-		);
+	DBG(level, "TX DMA%d%s: csr %04x, " "H%08x S%08x C%08x %08x, " "F%08x L%08x .. %08x" "\n", c->chNo, tag, MGC_ReadCsr16(base, MGC_O_HDRC_TXCSR, c->chNo + 1), musb_readl(c->stateRam, 0 * 4),	/* head ptr */
+	    musb_readl(c->stateRam, 1 * 4),	/* sop bd */
+	    musb_readl(c->stateRam, 2 * 4),	/* current bd */
+	    musb_readl(c->stateRam, 3 * 4),	/* buf offset */
+	    musb_readl(c->stateRam, 4 * 4),	/* flags */
+	    musb_readl(c->stateRam, 5 * 4),	/* len */
+	    // dummy/unused word 6
+	    musb_readl(c->stateRam, 7 * 4)	/* completion */
+	    );
 }
 
 /* Context: controller irqlocked */
 static inline void
 cppi_rndis_update(struct cppi_channel *c, int is_rx,
-		void *__iomem tibase, int is_rndis)
+		  void *__iomem tibase, int is_rndis)
 {
 	/* we may need to change the rndis flag for this cppi channel */
 	if (c->bLastModeRndis != is_rndis) {
-		u32	regVal = musb_readl(tibase, DAVINCI_RNDIS_REG);
-		u32	temp = 1 << (c->chNo);
+		u32 regVal = musb_readl(tibase, DAVINCI_RNDIS_REG);
+		u32 temp = 1 << (c->chNo);
 
 		if (is_rx)
 			temp <<= 16;
@@ -391,15 +372,15 @@ cppi_rndis_update(struct cppi_channel *c
 static void cppi_dump_rxbd(const char *tag, struct cppi_descriptor *bd)
 {
 	pr_debug("RXBD/%s %08x: "
-			"nxt %08x buf %08x off.blen %08x opt.plen %08x\n",
-			tag, bd->dma,
-			bd->hNext, bd->buffPtr, bd->bOffBLen, bd->hOptions);
+		 "nxt %08x buf %08x off.blen %08x opt.plen %08x\n",
+		 tag, bd->dma,
+		 bd->hNext, bd->buffPtr, bd->bOffBLen, bd->hOptions);
 }
 
 static void cppi_dump_rxq(int level, const char *tag, struct cppi_channel *rx)
 {
 #if MUSB_DEBUG > 0
-	struct cppi_descriptor	*bd;
+	struct cppi_descriptor *bd;
 
 	if (!_dbg_level(level))
 		return;
@@ -411,59 +392,43 @@ static void cppi_dump_rxq(int level, con
 #endif
 }
 
-
 static inline int cppi_autoreq_update(struct cppi_channel *rx,
-		void *__iomem tibase, int onepacket, unsigned n_bds)
+				      void *__iomem tibase, int shortpkt,
+				      u8 rndis, signed n_bds, u8 startreq,
+				      u8 endreq)
 {
-	u32	tmp, val;
+	u32 tmp, val;
 
 	/* assert(is_host_active(musb)) */
 
 	/* start from "AutoReq never" */
 	tmp = musb_readl(tibase, DAVINCI_AUTOREQ_REG);
 	val = tmp & ~((0x3) << (rx->chNo * 2));
-
 	/* HCD arranged reqpkt for packet #1.  we arrange int
 	 * for all but the last one, maybe in two segments.
 	 */
-	if (!onepacket) {
-#if 0
-		/* use two segments, autoreq "all" then the last "never" */
-		val |= ((0x3) << (rx->chNo * 2));
-		n_bds--;
-#else
-		/* one segment, autoreq "all-but-last" */
-		val |= ((0x2) << (rx->chNo * 2));
-#endif
+
+	if (shortpkt && rndis) {
+		val = (val | ((0x01) << (rx->chNo * 2)));
+		rx->autoReq = 0x01;
+	} else if (shortpkt && !rndis) {
+		rx->autoReq = 0x00;
+	} else if ((!shortpkt) && (n_bds > 2)) {	// there might be shortpacket not request we might convert in to RNDIS mode
+		val = (val | ((0x03) << (rx->chNo * 2)));
+		rx->autoReq = 0x03;
+		if (endreq)
+			n_bds -= 2;
+	} else {
+		rx->autoReq = 0;
 	}
 
 	if (val != tmp) {
-		int n = 100;
-
-		/* make sure that autoreq is updated before continuing */
 		musb_writel(tibase, DAVINCI_AUTOREQ_REG, val);
-		do {
-			tmp = musb_readl(tibase, DAVINCI_AUTOREQ_REG);
-			if (tmp == val)
-				break;
-			cpu_relax();
-		} while (n-- > 0);
 	}
 
-	/* REQPKT is turned off after each segment */
-	if (n_bds && rx->actualLen) {
-		val = MGC_ReadCsr16(tibase + DAVINCI_BASE_OFFSET,
-				MGC_O_HDRC_RXCSR, rx->chNo + 1);
-		if (!(val & MGC_M_RXCSR_H_REQPKT)) {
-			val |= MGC_M_RXCSR_H_REQPKT | MGC_M_RXCSR_H_WZC_BITS;
-			MGC_WriteCsr16(tibase + DAVINCI_BASE_OFFSET,
-					MGC_O_HDRC_RXCSR, rx->chNo + 1, val);
-		}
-	}
 	return n_bds;
 }
 
-
 /* Buffer enqueuing Logic:
  *
  *  - RX builds new queues each time, to help handle routine "early
@@ -499,15 +464,12 @@ static inline int cppi_autoreq_update(st
 static void
 cppi_next_tx_segment(struct musb *musb, struct cppi_channel *tx, int rndis)
 {
-	unsigned		maxpacket = tx->pktSize;
-	dma_addr_t		addr = tx->startAddr + tx->currOffset;
-	size_t			length = tx->transferSize - tx->currOffset;
-	struct cppi_descriptor	*bd;
-//	struct cppi_descriptor	*tail;
-	unsigned		n_bds;
-	unsigned		i;
-	struct cppi_tx_stateram	*txState = tx->stateRam;
-	u32			tmp;
+	unsigned maxpacket = tx->pktSize;
+	size_t length = tx->transferSize - tx->currOffset;
+	struct cppi_descriptor *bd;
+	unsigned n_bds;
+	unsigned i;
+	struct cppi_tx_stateram *txState = tx->stateRam;
 
 	/* TX can use the CPPI "rndis" mode, where we can probably fit this
 	 * transfer in one BD and one IRQ; though some common cases (like
@@ -518,39 +480,35 @@ cppi_next_tx_segment(struct musb *musb, 
 	 * want to use it is to avoid sending spurious zero length packets,
 	 * or when hardware constraints prevent it.
 	 */
+
+#if 0				// Disable RNDIS on both Tx & Rx
 	if (!rndis && (length % maxpacket) != 0)
 		rndis = 1;
-	if (rndis && (length > 0xffff
-			|| (maxpacket & 0x3f) != 0
-			/* "undocumented" rndis mode constraint on txlen */
-			|| (length & 0x3f) != 0))
+	if (rndis && (length > 0xffff || (maxpacket & 0x3f) != 0
+		      /* "undocumented" rndis mode constraint on txlen */
+		      || (length & 0x3f) != 0))
+#endif
 		rndis = 0;
 
-	if (rndis) {
+	if (!length) {
+		rndis = 0;
+		n_bds = 1;
+	} else if (rndis) {
 		maxpacket = length;
 		n_bds = 1;
 	} else {
-		/* Disable endpoint interrupt for peripheral TX DMAReqMode '0' */
-		if (is_peripheral_active(musb) && length >= (maxpacket * 4)) {
-			MGC_SelectEnd(musb->ctrl_base, tx->chNo + 1);
-			tmp = 1 << (tx->chNo + 1 + DAVINCI_USB_TXINT_SHIFT);
-			musb_writel((musb->ctrl_base + DAVINCI_BASE_OFFSET),
-				    DAVINCI_USB_INT_MASK_CLR_REG,
-				    (tmp & DAVINCI_USB_TX_ENDPTS_MASK));
-		}
 		n_bds = length / maxpacket;
 		if (length % maxpacket)
 			n_bds++;
-		n_bds = min(n_bds, (unsigned) NUM_TXCHAN_BD);
+		n_bds = min(n_bds, (unsigned)NUM_TXCHAN_BD);
 		length = min(n_bds * maxpacket, length);
 	}
 
 	DBG(4, "TX DMA%d, pktSz %d %s bds %d dma 0x%x len %u\n",
-			tx->chNo,
-			maxpacket,
-			rndis ? "rndis" : "transparent",
-			n_bds,
-			addr, length);
+	    tx->chNo,
+	    maxpacket,
+	    rndis ? "rndis" : "transparent",
+	    n_bds, tx->startAddr + tx->currOffset, length);
 
 	cppi_rndis_update(tx, 0, musb->ctrl_base, rndis);
 
@@ -564,47 +522,43 @@ cppi_next_tx_segment(struct musb *musb, 
 	tx->activeQueueHead = tx->bdPoolHead;
 	tx->lastHwBDProcessed = NULL;
 
-
 	/* Prepare queue of BDs first, then hand it to hardware.
 	 * All BDs except maybe the last should be of full packet
 	 * size; for RNDIS there _is_ only that last packet.
 	 */
-	for (i = 0; i < n_bds; ) {
+	for (i = 0; i < n_bds;) {
 		if (++i < n_bds && bd->next)
 			bd->hNext = bd->next->dma;
 		else
 			bd->hNext = 0;
 
-		bd->buffPtr = tx->startAddr
-			+ tx->currOffset;
+		bd->buffPtr = tx->startAddr + tx->currOffset;
 
 		/* FIXME set EOP only on the last packet,
 		 * SOP only on the first ... avoid IRQs
 		 */
 		if ((tx->currOffset + maxpacket)
-				<= tx->transferSize) {
+		    <= tx->transferSize) {
 			tx->currOffset += maxpacket;
 			bd->bOffBLen = maxpacket;
 			bd->hOptions = CPPI_SOP_SET | CPPI_EOP_SET
-				| CPPI_OWN_SET | maxpacket;
+			    | CPPI_OWN_SET | maxpacket;
 		} else {
 			/* only this one may be a partial USB Packet */
 			u32 buffSz;
 
-			buffSz = tx->transferSize
-				- tx->currOffset;
+			buffSz = tx->transferSize - tx->currOffset;
 			tx->currOffset = tx->transferSize;
-			bd->bOffBLen = buffSz;
+			bd->bOffBLen = (buffSz) ? buffSz : 1;
 
 			bd->hOptions = CPPI_SOP_SET | CPPI_EOP_SET
-				| CPPI_OWN_SET | buffSz;
+			    | CPPI_OWN_SET | buffSz;
 			if (buffSz == 0)
 				bd->hOptions |= CPPI_ZERO_SET;
 		}
 
 		DBG(5, "TXBD %p: nxt %08x buf %08x len %04x opt %08x\n",
-				bd, bd->hNext, bd->buffPtr,
-				bd->bOffBLen, bd->hOptions);
+		    bd, bd->hNext, bd->buffPtr, bd->bOffBLen, bd->hOptions);
 
 		/* update the last BD enqueued to the list */
 		tx->activeQueueTail = bd;
@@ -615,7 +569,7 @@ cppi_next_tx_segment(struct musb *musb, 
 	cpu_drain_writebuffer();
 
 	/* Write to the HeadPtr in StateRam to trigger */
-	txState->headPtr = (u32)tx->bdPoolHead->dma;
+	txState->headPtr = (u32) tx->bdPoolHead->dma;
 
 	cppi_dump_tx(5, tx, "/S");
 }
@@ -681,12 +635,12 @@ cppi_next_tx_segment(struct musb *musb, 
  * code to recover from corrupted datastreams after each short transfer.
  */
 static void
-cppi_next_rx_segment(struct musb *musb, struct cppi_channel *rx, int onepacket)
+cppi_next_rx_segment(struct musb *musb, struct cppi_channel *rx, int shortpkt)
 {
-	unsigned		maxpacket = rx->pktSize;
-	dma_addr_t		addr = rx->startAddr + rx->currOffset;
-	size_t			length = rx->transferSize - rx->currOffset;
-	struct cppi_descriptor	*bd, *tail;
+	unsigned maxpacket = rx->pktSize;
+	dma_addr_t addr = rx->startAddr + rx->currOffset;
+	size_t length = rx->transferSize - rx->currOffset;
+	struct cppi_descriptor *bd, *tail;
 	/* Description: Change the variables to signed data type
 	 *
 	 * Reason for change:
@@ -694,41 +648,38 @@ cppi_next_rx_segment(struct musb *musb, 
 	 * in a conditional statement was sometimes giving -ve results, but because
 	 * of unsigned variables it resulted in wrong condition evaluation.
 	 *
-	 * Fixed MRs: 
+	 * Fixed MRs:
 	 * None
 	 */
-	signed			n_bds;
-	signed			i;
-	void			*__iomem tibase = musb->ctrl_base;
-	u8			rndis;
+	signed n_bds;
+	signed i;
+	void *__iomem tibase = musb->ctrl_base;
+	u8 rndis = 0;
+	int max_bd = 0;
 
-	/*printk("st=%d off=%d sz=%d len=%d 1=%d",rx->startAddr,rx->currOffset,rx->transferSize,length,onepacket);*/
-
-	if (onepacket) {
-		n_bds = 1;
+	if ((shortpkt && ((maxpacket & 0x3f) == 0)	//REVISIT MAXPACKET CHECK!!!!
+	     && ((length & 0x3f) == 0))) {
+		rndis = 1;
+		max_bd = 65536;	// MAX buffer aize per RNDIS BD is 64 K
 	} else {
-		if (length > 0xffff) {
-			n_bds = 0xffff / maxpacket;
-			length = n_bds * maxpacket;
-		} else {
-			n_bds = length / maxpacket;
-			if (length % maxpacket)
-				n_bds++;
-		}
-		if (n_bds == 1)
-			onepacket = 1;
-		else
-			n_bds = min(n_bds, (signed) NUM_RXCHAN_BD);
+		rndis = 0;
+		max_bd = maxpacket;
 	}
+#ifdef CONFIG_ARCH_DAVINCI
+	/* Do not use RNDIS dma for DaVinci */
+	rndis = 0;
+	max_bd = maxpacket;
+#endif
 
-	if ((onepacket && ((length > 0xffff) || (length <= maxpacket) ||
-			   ((maxpacket & 0x3f) != 0) || ((length & 0x3f) != 0)))
-	    || (onepacket == 0)) {
-		rndis = 0;
-	} else {
-		rndis = 1;
-		maxpacket = length;
+	n_bds = length / max_bd;
+	if (length % max_bd) {
+		n_bds++;
 	}
+
+	n_bds = min(n_bds, (signed)NUM_RXCHAN_BD);
+	if (n_bds == NUM_RXCHAN_BD)
+		length = min(length, (size_t) (n_bds * max_bd));
+
 	cppi_rndis_update(rx, 1, musb->ctrl_base, rndis);
 
 	/* In host mode, autorequest logic can generate some IN tokens; it's
@@ -737,21 +688,19 @@ cppi_next_rx_segment(struct musb *musb, 
 	 * And always at least two IRQs.
 	 */
 	if (is_host_active(musb))
-		n_bds = cppi_autoreq_update(rx, tibase, onepacket, n_bds);
-
-	length = min(n_bds * maxpacket, length);
-
-	/*printk("len=%d bds=%d \n",length,n_bds);*/
+		n_bds = cppi_autoreq_update(rx, tibase, shortpkt, rndis, n_bds,
+					    (u8) ! rx->currOffset,
+					    (u8) (rx->transferSize <=
+						  (rx->currOffset + length)
+					    ));
 
 	DBG(4, "RX DMA%d seg, maxp %d %spacket bds %d (cnt %d) "
-			"dma 0x%x len %u/%u/%u\n",
-			rx->chNo, maxpacket,
-			onepacket ? "one" : "multi",
-			n_bds,
-			musb_readl(tibase,
-				DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
-					& 0xffff,
-			addr, length, rx->actualLen, rx->transferSize);
+	    "dma 0x%x len %u/%u/%u\n",
+	    rx->chNo, max_bd,
+	    shortpkt ? "one" : "multi",
+	    n_bds,
+	    musb_readl(tibase, DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
+	    & 0xffff, addr, length, rx->actualLen, rx->transferSize);
 
 	/* only queue one segment at a time, since the hardware prevents
 	 * correct queue shutdown after unexpected short packets
@@ -761,7 +710,7 @@ cppi_next_rx_segment(struct musb *musb, 
 
 	/* Build BDs for all packets in this segment */
 	for (i = 0, tail = NULL; bd && i < n_bds; i++, tail = bd) {
-		u32	buffSz;
+		u32 buffSz;
 
 		if (i) {
 			bd = cppi_bd_alloc(rx);
@@ -773,8 +722,8 @@ cppi_next_rx_segment(struct musb *musb, 
 		bd->hNext = 0;
 
 		/* all but the last packet will be maxpacket size */
-		if (maxpacket < length)
-			buffSz = maxpacket;
+		if (max_bd < length)
+			buffSz = max_bd;
 		else
 			buffSz = length;
 
@@ -782,7 +731,7 @@ cppi_next_rx_segment(struct musb *musb, 
 		addr += buffSz;
 		rx->currOffset += buffSz;
 
-		bd->bOffBLen = (0 /*offset*/ << 16) + buffSz;
+		bd->bOffBLen = (0 /*offset */  << 16) + buffSz;
 		bd->enqBuffLen = buffSz;
 
 		bd->hOptions = CPPI_OWN_SET | (i == 0 ? length : 0);
@@ -807,23 +756,13 @@ cppi_next_rx_segment(struct musb *musb, 
 	 * one per USB packet, terminating the whole queue at once...
 	 * NOTE that current hardware seems to ignore SOP and EOP.
 	 */
-	bd->hOptions |= CPPI_SOP_SET;
-	tail->hOptions |= CPPI_EOP_SET;
-
 	if (MGC_DebugLevel >= 5) {
-		struct cppi_descriptor	*d;
+		struct cppi_descriptor *d;
 
 		for (d = rx->activeQueueHead; d; d = d->next)
 			cppi_dump_rxbd("S", d);
 	}
-
-	/* in case the preceding transfer left some state... */
-	tail = rx->lastHwBDProcessed;
-	if (tail) {
-		tail->next = bd;
-		tail->hNext = bd->dma;
-	}
-
+	rx->lastHwBDProcessed = NULL;
 	/* BDs live in DMA-coherent memory, but writes might be pending */
 	cpu_drain_writebuffer();
 
@@ -836,9 +775,8 @@ cppi_next_rx_segment(struct musb *musb, 
 	 * unless it underflows below zero, or stops at two, or keeps
 	 * growing ... grr.
 	 */
-	i = musb_readl(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
-			& 0xffff;
+	i = musb_readl(tibase, DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
+	    & 0xffff;
 
 	/* Description: Removed the "write - read back - correct write" logic for
 	 *     the RX CPPI BUFCNT register. Just write it once with correct value.
@@ -847,14 +785,13 @@ cppi_next_rx_segment(struct musb *musb, 
 	 * In Complete Preemption gadget mode, the RX DMA sometimes misbehaves and
 	 * the device gets reset after sometime.
 	 *
-	 * Fixed MRs: 
+	 * Fixed MRs:
 	 * None
 	 */
-	if (n_bds > (i - 2))
-	{
+	if (n_bds > (i - 2)) {
 		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
-			n_bds - i + 2);
+			    DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
+			    n_bds - i + 2);
 	}
 
 	cppi_dump_rx(4, rx, "/S");
@@ -873,32 +810,29 @@ cppi_next_rx_segment(struct musb *musb, 
  * Context: controller irqlocked
  */
 static u8 cppi_channel_program(struct dma_channel *pChannel,
-		u16 wPacketSz, u8 mode,
-		dma_addr_t dma_addr, u32 dwLength)
+			       u16 wPacketSz, u8 mode,
+			       dma_addr_t dma_addr, u32 dwLength)
 {
-	struct cppi_channel	*otgChannel = pChannel->pPrivateData;
-	struct cppi		*pController = otgChannel->pController;
-	struct musb		*musb = pController->musb;
+	struct cppi_channel *otgChannel = pChannel->pPrivateData;
+	struct cppi *pController = otgChannel->pController;
+	struct musb *musb = pController->musb;
 
 	switch (pChannel->bStatus) {
 	case MGC_DMA_STATUS_BUS_ABORT:
 	case MGC_DMA_STATUS_CORE_ABORT:
 		/* fault irq handler should have handled cleanup */
 		WARN("%cX DMA%d not cleaned up after abort!\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
+		     otgChannel->bTransmit ? 'T' : 'R', otgChannel->chNo);
 		//WARN_ON(1);
 		break;
 	case MGC_DMA_STATUS_BUSY:
 		WARN("program active channel?  %cX DMA%d\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
+		     otgChannel->bTransmit ? 'T' : 'R', otgChannel->chNo);
 		//WARN_ON(1);
 		break;
 	case MGC_DMA_STATUS_UNKNOWN:
 		DBG(1, "%cX DMA%d not allocated!\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
+		    otgChannel->bTransmit ? 'T' : 'R', otgChannel->chNo);
 		/* FALLTHROUGH */
 	case MGC_DMA_STATUS_FREE:
 		break;
@@ -912,7 +846,9 @@ static u8 cppi_channel_program(struct dm
 	otgChannel->pktSize = wPacketSz;
 	otgChannel->actualLen = 0;
 	otgChannel->transferSize = dwLength;
-  	otgChannel->rxMode = mode;
+	otgChannel->rxMode = mode;
+	otgChannel->reqcomplete = 0;
+	otgChannel->autoReq = 0;
 
 	/* TX channel? or RX? */
 	if (otgChannel->bTransmit)
@@ -923,132 +859,112 @@ static u8 cppi_channel_program(struct dm
 	return TRUE;
 }
 
-static int cppi_rx_scan(struct cppi *cppi, unsigned ch)
+static int cppi_rx_scan(struct cppi *cppi, unsigned ch, u8 abort)
 {
-	struct cppi_channel		*rx = &cppi->rxCppi[ch];
-	struct cppi_rx_stateram		*state = rx->stateRam;
-	struct cppi_descriptor		*bd;
-	struct cppi_descriptor		*last = rx->lastHwBDProcessed;
-	int				completed = 0, acked = 0;
-	int				i;
-	dma_addr_t			safe2ack;
+	struct cppi_channel *rx = &cppi->rxCppi[ch];
+	struct cppi_rx_stateram *state = rx->stateRam;
+	struct cppi_descriptor *bd;
+	struct cppi_descriptor *last = rx->lastHwBDProcessed;
+	int completed = 0, count = 0;
+	dma_addr_t safe2ack;
+	u32 csr;
 
 	cppi_dump_rx(6, rx, "/K");
 
-	bd = last ? last->next : rx->activeQueueHead;
-	if (!bd)
-		return 0;
-
-	/* run through all completed BDs */
-	for (i = 0, safe2ack = musb_readl(CAST &state->completionPtr, 0);
-			(safe2ack || completed) && bd && i < NUM_RXCHAN_BD;
-			i++, bd = bd->next) {
-		u16	len;
+	if (abort) {
+		last = rx->activeQueueHead;
+		goto free;
+	} else {
+		bd = last ? last->next : rx->activeQueueHead;
+	}
 
-		rmb();
-		if (!completed && (bd->hOptions & CPPI_OWN_SET))
+	do {
+		safe2ack = musb_readl(CAST & state->completionPtr, 0);
+		if (completed)
 			break;
+		do {
+			u16 len;
 
-		DBG(5, "C/RXBD %08x: nxt %08x buf %08x "
-			"off.len %08x opt.len %08x (%d)\n",
-			 bd->dma, bd->hNext, bd->buffPtr,
-			 bd->bOffBLen, bd->hOptions,
-			 rx->actualLen);
+			count++;
+			rmb();
+			DBG(5, "C/RXBD %08x: nxt %08x buf %08x "
+			    "off.len %08x opt.len %08x (%d)\n",
+			    bd->dma, bd->hNext, bd->buffPtr,
+			    bd->bOffBLen, bd->hOptions, rx->actualLen);
 
-		/* actual packet received length */
-		if ((bd->hOptions & CPPI_SOP_SET) && !completed)
+			/* actual packet received length */
 			len = bd->bOffBLen & CPPI_RECV_PKTLEN_MASK;
-		else
-			len = 0;
-
-		if (bd->hOptions & CPPI_EOQ_MASK)
-			completed = 1;
-
-		if (!completed && len < bd->enqBuffLen) {
-			/* NOTE:  when we get a short packet, RXCSR_H_REQPKT
-			 * must have been cleared, and no more DMA packets may
-			 * active be in the queue... TI docs didn't say, but
-			 * CPPI ignores those BDs even though OWN is still set.
-			 */
-			completed = 1;
-			DBG(3, "rx short %d/%d (%d)\n",
-					len, bd->enqBuffLen, rx->actualLen);
-		}
+			if (bd->hOptions & CPPI_ZERO_SET)
+				len = 0;
 
-		/* If we got here, we expect to ack at least one BD; meanwhile
-		 * CPPI may completing other BDs while we scan this list...
-		 *
-		 * RACE: we can notice OWN cleared before CPPI raises the
-		 * matching irq by writing that BD as the completion pointer.
-		 * In such cases, stop scanning and wait for the irq, avoiding
-		 * lost acks and states where BD ownership is unclear.
-		 */
-		if (bd->dma == safe2ack) {
-			musb_writel(CAST &state->completionPtr, 0, safe2ack);
-			safe2ack = musb_readl(CAST &state->completionPtr, 0);
-			acked = 1;
-			if (bd->dma == safe2ack)
-				safe2ack = 0;
-		}
+			if (bd->hNext == 0)
+				completed = 1;
 
-		rx->actualLen += len;
-
-		cppi_bd_free(rx, last);
-		last = bd;
-
-		/* stop scanning on end-of-segment */
-		if (bd->hNext == 0)
-			completed = 1;
-	}
-	rx->lastHwBDProcessed = last;
+			if (len < bd->enqBuffLen) {
+				/* Halt DMA on Receive of Short packets.  To prevent DMa from
+				   receiving packets into wrong BD.
+				 */
+				csr = MGC_ReadCsr16(rx->pController->pCoreBase,
+						    MGC_O_HDRC_RXCSR,
+						    rx->chNo + 1);
+
+				if (is_host_active(rx->pController->musb)) {
+					csr |= MGC_M_RXCSR_H_WZC_BITS;
+					csr &= ~MGC_M_RXCSR_H_REQPKT;
+				} else
+					csr |= MGC_M_RXCSR_P_WZC_BITS;
+
+				/* clear dma enable as this request is completed */
+				csr &= ~(MGC_M_RXCSR_DMAENAB);
+				MGC_WriteCsr16(rx->pController->pCoreBase,
+					       MGC_O_HDRC_RXCSR, rx->chNo + 1,
+					       csr);
+				rx->reqcomplete = 1;
+				completed = 1;
+				DBG(3, "rx short %d/%d (%d)\n",
+				    len, bd->enqBuffLen, rx->actualLen);
+			}
 
-	/* dma abort, lost ack, or ... */
-	if (!acked && last) {
-		int	csr;
-
-		if (safe2ack == 0 || safe2ack == rx->lastHwBDProcessed->dma)
-			musb_writel(CAST &state->completionPtr, 0, safe2ack);
-		if (safe2ack == 0) {
+			rx->actualLen += len;
 			cppi_bd_free(rx, last);
-			rx->lastHwBDProcessed = NULL;
-
-			/* if we land here on the host side, H_REQPKT will
-			 * be clear and we need to restart the queue...
-			 */
-			WARN_ON(rx->activeQueueHead);
-		}
-		MGC_SelectEnd(cppi->pCoreBase, rx->chNo + 1);
-		csr = MGC_ReadCsr16(cppi->pCoreBase,
-				MGC_O_HDRC_RXCSR, rx->chNo + 1);
-		if (csr & MGC_M_RXCSR_DMAENAB) {
-			DBG(4, "list%d %p/%p, last %08x%s, csr %04x\n",
-				rx->chNo,
-				rx->activeQueueHead, rx->activeQueueTail,
-				rx->lastHwBDProcessed
-					? rx->lastHwBDProcessed->dma
-					: 0,
-				completed ? ", completed" : "",
-				csr);
-			cppi_dump_rxq(4, "/what?", rx);
+			last = bd;
+			if (safe2ack == bd->dma) {
+				bd = bd->next;
+				break;
+			}
+			bd = bd->next;
+		} while (!completed);
+	} while (musb_readl(CAST & state->completionPtr, 0) != safe2ack);
+
+	if (is_host_active(rx->pController->musb) && (!completed)
+	    && (last->next->hNext == 0)) {
+		csr = MGC_ReadCsr16(rx->pController->pCoreBase,
+				    MGC_O_HDRC_RXCSR, rx->chNo + 1);
+		if ((rx->autoReq == 0) &&
+		    (!((csr & MGC_M_RXCSR_H_REQPKT) ||
+		       (csr & MGC_M_RXCSR_RXPKTRDY)))) {
+			csr |= MGC_M_RXCSR_H_REQPKT;
+			MGC_WriteCsr16(rx->pController->pCoreBase,
+				       MGC_O_HDRC_RXCSR, rx->chNo + 1, csr);
 		}
 	}
-	if (!completed) {
-		int	csr;
 
-		rx->activeQueueHead = bd;
-
-		/* REVISIT seems like "autoreq all but EOP" doesn't... */
-		csr = MGC_ReadCsr16(cppi->pCoreBase,
-				MGC_O_HDRC_RXCSR, rx->chNo + 1);
-		if (is_host_active(cppi->musb)
-				&& bd
-				&& !(csr & MGC_M_RXCSR_H_REQPKT)) {
-			csr |= MGC_M_RXCSR_H_REQPKT;
-			MGC_WriteCsr16(cppi->pCoreBase,
-					MGC_O_HDRC_RXCSR, rx->chNo + 1,
-					MGC_M_RXCSR_H_WZC_BITS | csr);
+	rx->lastHwBDProcessed = last;
+	musb_writel(CAST & state->completionPtr, 0, safe2ack);
+      free:
+	if (completed || abort) {
+
+		/* Flush BD's not consumed */
+		while (last != NULL) {
+			bd = last;
+			last = last->next;
+			cppi_bd_free(rx, bd);
 		}
-	} else {
+		if (abort && !last) {
+			safe2ack = musb_readl(CAST & state->completionPtr, 0);
+			musb_writel(CAST & state->completionPtr, 0, safe2ack);
+		}
+		rx->lastHwBDProcessed = NULL;
 		rx->activeQueueHead = NULL;
 		rx->activeQueueTail = NULL;
 	}
@@ -1059,24 +975,21 @@ static int cppi_rx_scan(struct cppi *cpp
 
 void cppi_completion(struct musb *pThis, u32 rx, u32 tx)
 {
-	void			*__iomem regBase;
-	int			i, chanNum, numCompleted;
-	u8			bReqComplete;
-	struct cppi		*cppi;
-	struct cppi_descriptor	*bdPtr;
-	struct musb_hw_ep	*pEnd = NULL;
-	u32			tmp;
+	void *__iomem regBase;
+	int i, chanNum;
+	u8 bReqComplete;
+	struct cppi *cppi;
+	struct cppi_descriptor *bdPtr;
 
 	cppi = container_of(pThis->pDmaController, struct cppi, Controller);
-
 	regBase = cppi->pCoreBase - DAVINCI_BASE_OFFSET;
 
-	chanNum = 0;
 	/* process TX channels */
 	for (chanNum = 0; tx; tx = tx >> 1, chanNum++) {
 		if (tx & 1) {
-			struct cppi_channel		*txChannel;
-			struct cppi_tx_stateram		*txState;
+			struct cppi_channel *txChannel;
+			struct cppi_tx_stateram *txState;
+			u32 safe2ack = 0;
 
 			txChannel = cppi->txCppi + chanNum;
 			txState = txChannel->stateRam;
@@ -1084,91 +997,53 @@ void cppi_completion(struct musb *pThis,
 			/* FIXME  need a cppi_tx_scan() routine, which
 			 * can also be called from abort code
 			 */
-
 			cppi_dump_tx(5, txChannel, "/E");
 
 			bdPtr = txChannel->activeQueueHead;
-
-			if (NULL == bdPtr) {
-				DBG(1, "null BD\n");
-				continue;
-			}
-
 			i = 0;
 			bReqComplete = 0;
 
-			numCompleted = 0;
+			do {
+				safe2ack = txState->completionPtr;
+				do {
+					rmb();
+					DBG(5,
+					    "C/TXBD %p n %x b %x off %x opt %x\n",
+					    bdPtr, bdPtr->hNext, bdPtr->buffPtr,
+					    bdPtr->bOffBLen, bdPtr->hOptions);
+
+					txChannel->actualLen +=
+					    (u16) (bdPtr->
+						   bOffBLen &
+						   CPPI_BUFFER_LEN_MASK);
+					if (bdPtr->dma == safe2ack) {
+						if (bdPtr->hNext == 0)
+							bReqComplete = 1;
+						txChannel->lastHwBDProcessed =
+						    bdPtr;
+						bdPtr = bdPtr->next;
+						break;
+					}
+					bdPtr = bdPtr->next;
+				} while (1);
+			} while (txState->completionPtr != safe2ack);
 
-			/* run through all completed BDs */
-			for (i = 0;
-					!bReqComplete
-						&& bdPtr
-						&& i < NUM_TXCHAN_BD;
-					i++, bdPtr = bdPtr->next) {
-				u16	len;
-
-				rmb();
-				if (bdPtr->hOptions & CPPI_OWN_SET)
-					break;
-
-				DBG(5, "C/TXBD %p n %x b %x off %x opt %x\n",
-						bdPtr, bdPtr->hNext,
-						bdPtr->buffPtr,
-						bdPtr->bOffBLen,
-						bdPtr->hOptions);
-
-				len = bdPtr->bOffBLen & CPPI_BUFFER_LEN_MASK;
-				txChannel->actualLen += len;
-
-				numCompleted++;
-				txChannel->lastHwBDProcessed = bdPtr;
-
-				/* write completion register to acknowledge
-				 * processing of completed BDs, and possibly
-				 * release the IRQ; EOQ might not be set ...
-				 *
-				 * REVISIT use the same ack strategy as rx
-				 */
-//				if ((bdPtr->hOptions & CPPI_EOQ_MASK))
-					txState->completionPtr = bdPtr->dma;
-				if (is_peripheral_active(cppi->musb)
-				    && (txChannel->transferSize -
-					txChannel->actualLen)
-				    == (2 * txChannel->pktSize)) {
-					MGC_SelectEnd(regBase +
-						      DAVINCI_BASE_OFFSET,
-						      txChannel->chNo + 1);
-					/* Enable endpoint interrupt */
-					tmp =
-					    1 << (txChannel->chNo + 1 +
-						  DAVINCI_USB_TXINT_SHIFT);
-					musb_writel(regBase,
-						    DAVINCI_USB_INT_MASK_SET_REG,
-						    (tmp &
-						     DAVINCI_USB_TX_ENDPTS_MASK));
-				}
-
-				/* stop scanning on end-of-segment */
-				if (bdPtr->hNext == 0)
-					bReqComplete = 1;
-			}
+			txState->completionPtr = txChannel->lastHwBDProcessed->
+			    dma;
 
 			/* on end of segment, maybe go to next one */
 			if (bReqComplete) {
-				//cppi_dump_tx(4, txChannel, "/complete");
+				cppi_dump_tx(4, txChannel, "/complete");
 
 				/* transfer more, or report completion */
 				if (txChannel->currOffset
-						>= txChannel->transferSize) {
+				    >= txChannel->transferSize) {
 					txChannel->activeQueueHead = NULL;
 					txChannel->activeQueueTail = NULL;
 					txChannel->Channel.bStatus =
-							MGC_DMA_STATUS_FREE;
-
-					pEnd = txChannel->pEndPt;
-
+					    MGC_DMA_STATUS_FREE;
 					txChannel->Channel.dwActualLength =
-						txChannel->actualLen;
+					    txChannel->actualLen;
 
 					/* Peripheral role never repurposes the
 					 * endpoint, so immediate completion is
@@ -1184,20 +1059,21 @@ void cppi_completion(struct musb *pThis,
 					 * Host mode TX DMA does not function, stops with urb_unlink.
 					 *
 					 * Fixed MRs:
-					 * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
+					 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
 					 *    to the Hub fails.
 					 */
 					if (is_peripheral_active(cppi->musb))
 #endif
 						cppi->dma_completed(pThis,
-							      chanNum + 1, 1);
+								    chanNum + 1,
+								    1);
 
 				} else {
 					/* Bigger transfer than we could fit in
 					 * that first batch of descriptors...
 					 */
 					cppi_next_tx_segment(pThis,
-							txChannel, 0);
+							     txChannel, 0);
 				}
 			} else
 				txChannel->activeQueueHead = bdPtr;
@@ -1208,31 +1084,45 @@ void cppi_completion(struct musb *pThis,
 	for (chanNum = 0; rx; rx = rx >> 1, chanNum++) {
 
 		if (rx & 1) {
-			struct cppi_channel		*rxChannel;
+			struct cppi_channel *rxChannel;
 
 			rxChannel = cppi->rxCppi + chanNum;
-			bReqComplete = cppi_rx_scan(cppi, chanNum);
+			/* There is a race condition between abort channel and
+			 * on going traffic.  Ensure that pending interrupts
+			 * (that were raised during clean up but was held due
+			 * to interrupt block) are acknowledged correctly by
+			 * adressing those interrupts as abort (from interrupt
+			 * context, as we already handled the user initiated
+			 * abort which actually lead to this race). This occurs
+			 * possible due to the fact that we do not support
+			 * clean RX teardown at this point (May not require this
+			 * code once RX teardown is correctly supported in
+			 * hardware).
+			 */
+			if (rxChannel->activeQueueHead)
+				bReqComplete = cppi_rx_scan(cppi, chanNum, 0);
+			else {
+				cppi_rx_scan(cppi, chanNum, 1);
+				continue;
+			}
 
 			/* let incomplete dma segments finish */
 			if (!bReqComplete)
 				continue;
 
 			/* start another dma segment if needed */
-			if (rxChannel->actualLen != rxChannel->transferSize
-					&& rxChannel->actualLen
-						== rxChannel->currOffset) {
-				cppi_next_rx_segment(pThis, rxChannel, rxChannel->rxMode);
+			if ((rxChannel->actualLen != rxChannel->transferSize)
+			    && !(rxChannel->reqcomplete)) {
+				cppi_next_rx_segment(pThis, rxChannel,
+						     rxChannel->rxMode);
 				continue;
 			}
 
 			/* all segments completed! */
 			rxChannel->Channel.bStatus = MGC_DMA_STATUS_FREE;
-
-			pEnd = rxChannel->pEndPt;
-
 			rxChannel->Channel.dwActualLength =
-					rxChannel->actualLen;
-			(void) cppi->dma_completed(pThis, chanNum + 1, 0);
+			    rxChannel->actualLen;
+			(void)cppi->dma_completed(pThis, chanNum + 1, 0);
 		}
 	}
 
@@ -1241,12 +1131,12 @@ void cppi_completion(struct musb *pThis,
 }
 
 /* Instantiate a software object representing a DMA controller. */
-static struct dma_controller *
-cppi_controller_new(MGC_pfDmaChannelStatusChanged dma_completed,
-		void *musb, u8 *pCoreBase)
+static struct dma_controller *cppi_controller_new(MGC_pfDmaChannelStatusChanged
+						  dma_completed, void *musb,
+						  u8 * pCoreBase)
 {
-	struct dma_controller	*pResult = NULL;
-	struct cppi		*pController;
+	struct dma_controller *pResult = NULL;
+	struct cppi *pController;
 
 	pController = kzalloc(sizeof *pController, GFP_KERNEL);
 	if (!pController)
@@ -1272,9 +1162,9 @@ cppi_controller_new(MGC_pfDmaChannelStat
 
 	/* setup BufferPool */
 	pController->pool = dma_pool_create("cppi",
-			pController->musb->controller,
-			sizeof(struct cppi_descriptor),
-			CPPI_DESCRIPTOR_ALIGN, 0);
+					    pController->musb->controller,
+					    sizeof(struct cppi_descriptor),
+					    CPPI_DESCRIPTOR_ALIGN, 0);
 	if (!pController->pool) {
 		kfree(pController);
 		pResult = NULL;
@@ -1288,7 +1178,7 @@ cppi_controller_new(MGC_pfDmaChannelStat
  */
 static void cppi_controller_destroy(struct dma_controller *pController)
 {
-	struct cppi	*cpController = pController->pPrivateData;
+	struct cppi *cpController = pController->pPrivateData;
 
 	/* assert:  caller stopped the controller first */
 	dma_pool_destroy(cpController->pool);
@@ -1305,13 +1195,13 @@ static void cppi_controller_destroy(stru
  */
 static int cppi_channel_abort(struct dma_channel *pChannel)
 {
-	struct cppi_channel	*otgCh = pChannel->pPrivateData;
-	struct cppi		*pController = otgCh->pController;
-	int			chNum = otgCh->chNo;
-	void			*__iomem mbase;
-	void			*__iomem regBase;
-	u32			regVal;
-	struct cppi_descriptor	*queue;
+	struct cppi_channel *otgCh = pChannel->pPrivateData;
+	struct cppi *pController = otgCh->pController;
+	int chNum = otgCh->chNo;
+	void *__iomem mbase;
+	void *__iomem regBase;
+	u32 regVal;
+	struct cppi_descriptor *queue;
 
 	switch (pChannel->bStatus) {
 	case MGC_DMA_STATUS_BUS_ABORT:
@@ -1322,8 +1212,7 @@ static int cppi_channel_abort(struct dma
 		break;
 	case MGC_DMA_STATUS_UNKNOWN:
 		DBG(8, "%cX DMA%d not allocated\n",
-				otgCh->bTransmit ? 'T' : 'R',
-				otgCh->chNo);
+		    otgCh->bTransmit ? 'T' : 'R', otgCh->chNo);
 		/* FALLTHROUGH */
 	case MGC_DMA_STATUS_FREE:
 		return 0;
@@ -1349,15 +1238,15 @@ static int cppi_channel_abort(struct dma
 	MGC_SelectEnd(mbase, chNum + 1);
 
 	if (otgCh->bTransmit) {
-		struct cppi_tx_stateram	*__iomem txState;
-		int			enabled;
+		struct cppi_tx_stateram *__iomem txState;
+		int enabled;
 
 		/* mask interrupts raised to signal teardown complete.  */
 		enabled = musb_readl(regBase, DAVINCI_TXCPPI_INTENAB_REG)
-				& (1 << otgCh->chNo);
+		    & (1 << otgCh->chNo);
 		if (enabled)
 			musb_writel(regBase, DAVINCI_TXCPPI_INTCLR_REG,
-					(1 << otgCh->chNo));
+				    (1 << otgCh->chNo));
 
 		// REVISIT put timeouts on these controller handshakes
 
@@ -1413,7 +1302,7 @@ static int cppi_channel_abort(struct dma
 		/* re-enable interrupt */
 		if (enabled)
 			musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
-					(1 << otgCh->chNo));
+				    (1 << otgCh->chNo));
 
 		cppi_dump_tx(5, otgCh, " (done teardown)");
 
@@ -1421,8 +1310,9 @@ static int cppi_channel_abort(struct dma
 		 * as the RX side ... this does no cleanup at all!
 		 */
 
-	} else /* RX */ {
-		u16			csr;
+	} else {		/* RX */
+
+		u16 csr;
 
 		/* NOTE: docs don't guarantee any of this works ...  we
 		 * expect that if the usb core stops telling the cppi core
@@ -1437,7 +1327,7 @@ static int cppi_channel_abort(struct dma
 			musb_writel(regBase, DAVINCI_AUTOREQ_REG, regVal);
 		}
 
-		csr = MGC_ReadCsr16(mbase, MGC_O_HDRC_RXCSR, otgCh->chNo +1);
+		csr = MGC_ReadCsr16(mbase, MGC_O_HDRC_RXCSR, otgCh->chNo + 1);
 
 		/* for host, clear (just) ReqPkt at end of current packet(s) */
 		if (is_host_active(otgCh->pController->musb)) {
@@ -1461,7 +1351,7 @@ static int cppi_channel_abort(struct dma
 		/* scan the current list, reporting any data that was
 		 * transferred and acking any IRQ
 		 */
-		cppi_rx_scan(pController, chNum);
+		cppi_rx_scan(pController, chNum, 1);
 
 		/* clobber the existing state once it's idle
 		 *
@@ -1490,7 +1380,7 @@ static int cppi_channel_abort(struct dma
 			queue = otgCh->activeQueueHead;
 
 		while (queue) {
-			struct cppi_descriptor	*tmp = queue->next;
+			struct cppi_descriptor *tmp = queue->next;
 			cppi_bd_free(otgCh, queue);
 			queue = tmp;
 		}
@@ -1501,6 +1391,7 @@ static int cppi_channel_abort(struct dma
 	otgCh->currOffset = 0;
 	otgCh->transferSize = 0;
 	otgCh->pktSize = 0;
+
 	return 0;
 }
 
Index: linux-2.6.10/drivers/usb/musb/cppi_dma.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/cppi_dma.h
+++ linux-2.6.10/drivers/usb/musb/cppi_dma.h
@@ -13,7 +13,6 @@
 #include "musbdefs.h"
 #include "davinci.h"
 
-
 /* hOptions bit masks for CPPI BDs */
 #define CPPI_SOP_SET	((u32)(1 << 31))
 #define CPPI_EOP_SET	((u32)(1 << 30))
@@ -52,7 +51,6 @@ struct cppi_descriptor {
 	u32 enqBuffLen;
 } __attribute__ ((aligned(CPPI_DESCRIPTOR_ALIGN)));
 
-
 /* forward declaration for CppiDmaController structure */
 struct cppi;
 
@@ -69,38 +67,38 @@ struct cppi_channel {
 	struct dma_channel Channel;
 
 	/* back pointer to the Dma Controller structure */
-	struct cppi		*pController;
+	struct cppi *pController;
 
 	/* which direction of which endpoint? */
-	struct musb_hw_ep	*pEndPt;
-	u8			bTransmit;
-	u8			chNo;
+	struct musb_hw_ep *pEndPt;
+	u8 bTransmit;
+	u8 chNo;
 
 	/* DMA modes:  RNDIS or "transparent" */
-	u8			bLastModeRndis;
-
+	u8 bLastModeRndis;
+	u8 autoReq;		//For now keep this remove this one RNDIS + length <64 segmenstation will done
 	/* Rx Requested mode */
-	u8 			rxMode;
-
+	u8 rxMode;
+	u8 reqcomplete;		// zero packet handling
 	/* book keeping for current transfer request */
-	dma_addr_t		startAddr;
-	u32			transferSize;
-	u32			pktSize;
-	u32			currOffset;	/* requested segments */
-	u32			actualLen;	/* completed (Channel.actual) */
+	dma_addr_t startAddr;
+	u32 transferSize;
+	u32 pktSize;
+	u32 currOffset;		/* requested segments */
+	u32 actualLen;		/* completed (Channel.actual) */
 
-	void __iomem 		*stateRam;	/* CPPI state */
+	void __iomem *stateRam;	/* CPPI state */
 
 	/* BD management fields */
-	struct cppi_descriptor	*bdPoolHead;		/* Free BD Pool head pointer */
-	struct cppi_descriptor	*activeQueueHead;
-	struct cppi_descriptor	*activeQueueTail;
-	struct cppi_descriptor	*lastHwBDProcessed;
+	struct cppi_descriptor *bdPoolHead;	/* Free BD Pool head pointer */
+	struct cppi_descriptor *activeQueueHead;
+	struct cppi_descriptor *activeQueueTail;
+	struct cppi_descriptor *lastHwBDProcessed;
 
 	/* use tx_complete in host role to track endpoints waiting for
 	 * FIFONOTEMPTY to clear.
 	 */
-	struct list_head	tx_complete;
+	struct list_head tx_complete;
 };
 
 /**
@@ -113,18 +111,18 @@ struct cppi {
 	/* FIXME switchover to container_of() and remove the
 	 * unsafe typecasts...
 	 */
-	struct dma_controller		Controller;
-	struct musb	 		*musb;
-	void __iomem			*pCoreBase;
+	struct dma_controller Controller;
+	struct musb *musb;
+	void __iomem *pCoreBase;
 
-	MGC_pfDmaChannelStatusChanged	dma_completed;
+	MGC_pfDmaChannelStatusChanged dma_completed;
 
-	struct cppi_channel		txCppi[MUSB_C_NUM_EPT - 1];
-	struct cppi_channel		rxCppi[MUSB_C_NUM_EPR - 1];
+	struct cppi_channel txCppi[MUSB_C_NUM_EPT - 1];
+	struct cppi_channel rxCppi[MUSB_C_NUM_EPR - 1];
 
-	struct dma_pool			*pool;
+	struct dma_pool *pool;
 
-	struct list_head		tx_complete;
+	struct list_head tx_complete;
 };
 
 /* irq handling hook */
Index: linux-2.6.10/drivers/usb/musb/davinci.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/davinci.c
+++ linux-2.6.10/drivers/usb/musb/davinci.c
@@ -47,7 +47,6 @@
 #include "musb_host.h"
 // #endif
 
-
 #ifdef CONFIG_ARCH_DAVINCI
 
 #ifdef CONFIG_MACH_DAVINCI_EVM
@@ -60,15 +59,63 @@
 #ifdef CONFIG_USB_TI_CPPI_DMA
 #include "cppi_dma.h"
 #endif
+#if 0
+/*
+ * USB
+ */
+//#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
 
+static struct musb_hdrc_platform_data usb_data = {
+#if     defined(CONFIG_USB_MUSB_OTG)
+	/* OTG requires a Mini-AB connector */
+	.mode = MUSB_OTG,
+#elif   defined(CONFIG_USB_MUSB_PERIPHERAL)
+	.mode = MUSB_PERIPHERAL,
+#elif   defined(CONFIG_USB_MUSB_HOST)
+	.mode = MUSB_HOST,
+#endif
+	/* irlml6401 switches 5V */
+	.power = 255,		/* sustains 3.0+ Amps (!) */
+	.potpgt = 4,		/* ~8 msec */
+
+	/* REVISIT multipoint is a _chip_ capability; not board specific */
+	.multipoint = 1,
+};
+
+static struct resource usb_resources[] = { {
+					    /* physical address */
+					    .start = DAVINCI_USB_OTG_BASE,
+					    .end = DAVINCI_USB_OTG_BASE + 0x5ff,
+					    .flags = IORESOURCE_MEM,
+					    }, {
+						.start = IRQ_USBINT,
+						.flags = IORESOURCE_IRQ,
+						},
+};
+
+static u64 usb_dmamask = DMA_32BIT_MASK;
+
+struct platform_device usb_dev = {
+	.name = "musb_hdrc",
+	.id = -1,
+	.dev = {
+		.platform_data = &usb_data,
+		.dma_mask = &usb_dmamask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+		},
+	.resource = usb_resources,
+	.num_resources = ARRAY_SIZE(usb_resources),
+};
+
+#endif
 static inline void phy_on(void)
 {
 	/* start the on-chip PHY and its PLL */
-	__raw_writel(USBPHY_SESNDEN |USBPHY_VBDTCTEN | USBPHY_PHYPLLON,
-			IO_ADDRESS(USBPHY_CTL_PADDR));
+	__raw_writel(USBPHY_SESNDEN | USBPHY_VBDTCTEN | USBPHY_PHYPLLON,
+		     IO_ADDRESS(USBPHY_CTL_PADDR));
 
 	while ((__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR))
-			& USBPHY_PHYCLKGD) == 0)
+		& USBPHY_PHYCLKGD) == 0)
 		cpu_relax();
 }
 
@@ -76,21 +123,20 @@ static inline void phy_off(void)
 {
 	/* powerdown the on-chip PHY and its oscillator */
 	__raw_writel(USBPHY_OSCPDWN | USBPHY_PHYSPDWN,
-			IO_ADDRESS(USBPHY_CTL_PADDR));
+		     IO_ADDRESS(USBPHY_CTL_PADDR));
 }
 
-
 void musb_platform_enable(struct musb *musb)
 {
-	u32	tmp, old, val;
+	u32 tmp, old, val;
 
 	/* workaround:  setup irqs through both register sets */
 	tmp = (musb->wEndMask & DAVINCI_USB_TX_ENDPTS_MASK)
-			<< DAVINCI_USB_TXINT_SHIFT;
+	    << DAVINCI_USB_TXINT_SHIFT;
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 	old = tmp;
 	tmp = (musb->wEndMask & (0xfffe & DAVINCI_USB_RX_ENDPTS_MASK))
-			<< DAVINCI_USB_RXINT_SHIFT;
+	    << DAVINCI_USB_RXINT_SHIFT;
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 	tmp |= old;
 
@@ -110,31 +156,29 @@ void musb_platform_disable(struct musb *
 	 *  - use INTSETR/INTCLRR instead
 	 */
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_CLR_REG,
-			  DAVINCI_USB_USBINT_MASK
-			| DAVINCI_USB_TXINT_MASK
-			| DAVINCI_USB_RXINT_MASK);
+		    DAVINCI_USB_USBINT_MASK
+		    | DAVINCI_USB_TXINT_MASK | DAVINCI_USB_RXINT_MASK);
 	musb_writeb(musb->pRegs, MGC_O_HDRC_DEVCTL, 0);
 	musb_writel(musb->ctrl_base, DAVINCI_USB_EOI_REG, 0);
 }
 
-
 /* REVISIT this file shouldn't modify the OTG state machine ...
  *
  * The OTG infrastructure needs updating, to include things like
  * offchip DRVVBUS support and replacing MGC_OtgMachineInputs with
  * musb struct members (so e.g. vbus_state vanishes).
  */
-static int vbus_state 	= -1;
-static int vBus_on	= -1;
+static int vbus_state = -1;
+static int host_session = 0;
 static void session(struct musb *musb, int is_on)
 {
-	void	*__iomem mregs = musb->pRegs;
-	u8	devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
+	void *__iomem mregs = musb->pRegs;
+	u8 devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
 
 	/* NOTE: after drvvbus off the state _could_ be A_IDLE;
 	 * but the silicon seems to couple vbus to "ID grounded".
 	 */
-	if(is_on)
+	if (is_on)
 		devctl |= MGC_M_DEVCTL_SESSION;
 	else
 		devctl &= ~MGC_M_DEVCTL_SESSION;
@@ -150,15 +194,14 @@ static void session(struct musb *musb, i
  */
 static void evm_deferred_drvvbus(void *_musb)
 {
-	struct musb	*musb = _musb;
-	int		is_on = 0 ;
-#ifdef CONFIG_USB_MUSB_OTG
-	is_on = vBus_on;
-#endif
+	struct musb *musb = _musb;
+	int is_on = vbus_state;
+
 	davinci_i2c_expander_op(0x3a, USB_DRVVBUS, !is_on);
 	vbus_state = is_on;
-	session(musb, is_on);
+	session(musb, host_session);
 }
+
 DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus, 0);
 
 #endif
@@ -166,20 +209,18 @@ DECLARE_WORK(evm_vbus_work, evm_deferred
 /* VBUS SWITCHING IS BOARD-SPECIFIC */
 void davinci_vbus_power(struct musb *musb, int is_on, int sleeping)
 {
-	/*u8  devctl = 0;*/
-
 	if (is_on)
 		is_on = 1;
-	
-	DBG(1,"vbus_state=is_on\t vbus->%d\n",vbus_state);
-#ifndef CONFIG_USB_MUSB_OTG
-	if (vbus_state == is_on){
+
+	DBG(1, "vbus_state=is_on\t vbus->%d\n", vbus_state);
+#if 0
+	if (vbus_state == is_on) {
 		return;
 	}
 #endif
 	if (is_on) {
 		MUSB_HST_MODE(musb);
-	}else {
+	} else {
 		MUSB_DEV_MODE(musb);
 	}
 
@@ -190,56 +231,41 @@ void davinci_vbus_power(struct musb *mus
 		/* modified EVM board switching VBUS with GPIO(6) not I2C
 		 * NOTE:  PINMUX0.RGB888 (bit23) must be clear
 		 */
-		if (!is_on){
-			printk("Off VBus ===>\n");
+		if (!is_on) {
 			REG_DVEVM_GPIO45_SET |= DAVINCI_VBUS_OFF;
-			/*do
-                        {
-                        	devctl = musb_readb (
-                               			musb->pRegs,
-                                                MGC_O_HDRC_DEVCTL);
-                                printk ("DeVctl Value %x\n", devctl);
-                                        mdelay(5);
-                        } while ((devctl & 0x18) != 0);*/
-		}else{
-			printk("On Vbus ===>\n");
+		} else {
 			REG_DVEVM_GPIO45_CLR |= DAVINCI_VBUS_ON;
 		}
 #else
 		/* Do not turn off the USB bus.  This results in the IDE HDD
 		 * getting reset.
 		 */
-		if (sleeping){
+		if (0) {
 			davinci_i2c_expander_op(0x3a, USB_DRVVBUS, !is_on);
-		}
-		else{
-			vBus_on= is_on;
+		} else {
+			vbus_state = is_on;
+			host_session = sleeping;
 			schedule_work(&evm_vbus_work);
+			return;
 		}
 #endif
 	}
 #endif
-#ifndef CONFIG_USB_MUSB_OTG
-	if (sleeping){
-		vbus_state = is_on;
-#else
-		vbus_state = is_on;
-#endif
-		session(musb, sleeping);
-#ifndef CONFIG_USB_MUSB_OTG
-	}
-#endif
+	vbus_state = is_on;
+	//if (sleeping){
+	session(musb, sleeping);
+	//}
 	DBG(2, "VBUS power %s, %s\n", is_on ? "on" : "off",
-		sleeping ? "immediate" : "deferred");
+	    sleeping ? "immediate" : "deferred");
 }
 
 static irqreturn_t davinci_interrupt(int irq, void *__hci, struct pt_regs *r)
 {
-	unsigned long	flags;
-	irqreturn_t	retval = IRQ_NONE;
-	struct musb	*musb = __hci;
-	void		*__iomem tibase = musb->ctrl_base;
-	u32		tmp;
+	unsigned long flags;
+	irqreturn_t retval = IRQ_NONE;
+	struct musb *musb = __hci;
+	void *__iomem tibase = musb->ctrl_base;
+	u32 tmp;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
@@ -268,19 +294,26 @@ static irqreturn_t davinci_interrupt(int
 	musb_writel(tibase, DAVINCI_USB_INT_SRC_CLR_REG, tmp);
 
 	musb->int_rx = (tmp & DAVINCI_USB_RXINT_MASK)
-			>> DAVINCI_USB_RXINT_SHIFT;
+	    >> DAVINCI_USB_RXINT_SHIFT;
 	musb->int_tx = (tmp & DAVINCI_USB_TXINT_MASK)
-			>> DAVINCI_USB_TXINT_SHIFT;
+	    >> DAVINCI_USB_TXINT_SHIFT;
 	musb->int_usb = (tmp & DAVINCI_USB_USBINT_MASK)
-			>> DAVINCI_USB_USBINT_SHIFT;
+	    >> DAVINCI_USB_USBINT_SHIFT;
 	musb->int_regs = r;
 
 	if (tmp & (1 << (8 + DAVINCI_USB_USBINT_SHIFT))) {
-		int	drvvbus = musb_readl(tibase, DAVINCI_USB_STAT_REG);
+		int drvvbus = musb_readl(tibase, DAVINCI_USB_STAT_REG);
 
 		/* NOTE:  this must complete poweron within 100 msec */
-		DBG(1,"drvvbus Interrupt\n");
+		DBG(1, "drvvbus Interrupt\n");
+#ifdef CONFIG_USB_MUSB_OTG
 		davinci_vbus_power(musb, drvvbus, drvvbus);
+#elif defined(CONFIG_USB_MUSB_HDRC_HCD)
+		/* In host mode manipulate vbus based on core request but
+		 * keep the session on.
+		 */
+		davinci_vbus_power(musb, drvvbus, 1);
+#endif
 		retval = IRQ_HANDLED;
 	}
 
@@ -302,9 +335,9 @@ static irqreturn_t davinci_interrupt(int
 
 int __init musb_platform_init(struct musb *musb)
 {
-	void	*__iomem tibase = musb->ctrl_base;
-	u32	revision;
-	
+	void *__iomem tibase = musb->ctrl_base;
+	u32 revision;
+
 	musb->pRegs += DAVINCI_BASE_OFFSET;
 #if 0
 	/* REVISIT there's something odd about clocking, this
@@ -319,25 +352,26 @@ int __init musb_platform_init(struct mus
 		return -ENODEV;
 #endif
 
-	 /* returns zero if e.g. not clocked */
-	 revision = musb_readl(tibase, DAVINCI_USB_VERSION_REG);
-	 if (revision == 0)
-	 	return -ENODEV;
+	/* returns zero if e.g. not clocked */
+	revision = musb_readl(tibase, DAVINCI_USB_VERSION_REG);
+	if (revision == 0)
+		return -ENODEV;
 
 	/* note that transceiver issues make us want to charge
 	 * VBUS only when the PHY PLL is not active.
 	 */
 #ifdef CONFIG_MACH_DAVINCI_EVM
 #ifdef CONFIG_USB_MUSB_OTG
-	/* clear EMACEN to enble OTG GPIO 16 for VBus power control */	
+	/* clear EMACEN to enble OTG GPIO 16 for VBus power control */
 	/* Set GPIO Direction */
 	REG_DVEVM_GPIO45_DIR &= ~(DVEVM_GPIO45_DIR_OUT);
 	DAVINCI_PINMUX0 &= ~(0x80000000);
 #endif
 	evm_vbus_work.data = musb;
 #endif
-	/* HBG 22 SEPT 2006 OTG controller with non-OTG devices*/
- 	davinci_vbus_power(musb, musb->board_mode == MUSB_HOST , musb->board_mode != MUSB_OTG);
+	/* HBG 22 SEPT 2006 OTG controller with non-OTG devices */
+	davinci_vbus_power(musb, musb->board_mode == MUSB_HOST,
+			   musb->board_mode != MUSB_OTG);
 
 	/* reset the controller */
 	musb_writel(tibase, DAVINCI_USB_CTRL_REG, 0x1);
@@ -350,8 +384,7 @@ int __init musb_platform_init(struct mus
 	/* NOTE:  irqs are in mixed mode, not bypass to pure-musb */
 	pr_debug("DaVinci OTG revision %08x phy %03x control %02x\n",
 		 revision,
-		 musb_readl((void *__iomem) IO_ADDRESS(
-				 USBPHY_CTL_PADDR), 0x00),
+		 musb_readl((void *__iomem)IO_ADDRESS(USBPHY_CTL_PADDR), 0x00),
 		 musb_readb(tibase, DAVINCI_USB_CTRL_REG));
 
 	musb->isr = davinci_interrupt;
@@ -363,12 +396,12 @@ int musb_platform_exit(struct musb *musb
 	phy_off();
 #ifdef CONFIG_MACH_DAVINCI_EVM
 #ifdef CONFIG_USB_MUSB_OTG
-	/* Set EMACEN to enable OTG GPIO 16 for Emac control */	
+	/* Set EMACEN to enable OTG GPIO 16 for Emac control */
 	/* Set GPIO Direction */
 	DAVINCI_PINMUX0 |= (0x80000000);
 #endif
 #endif
 
-	davinci_vbus_power(musb, 0 /*off*/, 1);
+	davinci_vbus_power(musb, 0 /*off */ , 1);
 	return 0;
 }
Index: linux-2.6.10/drivers/usb/musb/davinci.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/davinci.h
+++ linux-2.6.10/drivers/usb/musb/davinci.h
@@ -112,8 +112,8 @@ struct cppi_rx_stateram {
 	volatile u32 completionPtr;
 };
 
-#define DAVINCI_USB_TX_ENDPTS_MASK	0x1f		/* ep0 + 4 tx */
-#define DAVINCI_USB_RX_ENDPTS_MASK	0x1e		/* 4 rx */
+#define DAVINCI_USB_TX_ENDPTS_MASK	0x1f	/* ep0 + 4 tx */
+#define DAVINCI_USB_RX_ENDPTS_MASK	0x1e	/* 4 rx */
 
 #define DAVINCI_USB_USBINT_SHIFT	16
 #define DAVINCI_USB_TXINT_SHIFT		0
@@ -127,4 +127,4 @@ struct cppi_rx_stateram {
 
 #define DAVINCI_BASE_OFFSET		0x400
 
-#endif	/* __MUSB_HDRDF_H__ */
+#endif				/* __MUSB_HDRDF_H__ */
Index: linux-2.6.10/drivers/usb/musb/dma.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/dma.h
+++ linux-2.6.10/drivers/usb/musb/dma.h
@@ -82,15 +82,15 @@
  * status changes, and protected by the overall controller spinlock.
  */
 enum dma_channel_status {
-    /** A channel's status is unknown */
+		/** A channel's status is unknown */
 	MGC_DMA_STATUS_UNKNOWN,
-    /** A channel is available (not busy and no errors) */
+		/** A channel is available (not busy and no errors) */
 	MGC_DMA_STATUS_FREE,
-    /** A channel is busy (not finished attempting its transactions) */
+		/** A channel is busy (not finished attempting its transactions) */
 	MGC_DMA_STATUS_BUSY,
-    /** A channel aborted its transactions due to a local bus error */
+		/** A channel aborted its transactions due to a local bus error */
 	MGC_DMA_STATUS_BUS_ABORT,
-    /** A channel aborted its transactions due to a core error or USB fault */
+		/** A channel aborted its transactions due to a core error or USB fault */
 	MGC_DMA_STATUS_CORE_ABORT
 };
 
@@ -106,11 +106,11 @@ enum dma_channel_status {
  * @field bDesiredMode TRUE if mode 1 is desired; FALSE if mode 0 is desired
  */
 struct dma_channel {
-	void			*pPrivateData;
-	size_t			dwMaxLength;
-	size_t			dwActualLength;
-	enum dma_channel_status	bStatus;
-	u8			bDesiredMode;
+	void *pPrivateData;
+	size_t dwMaxLength;
+	size_t dwActualLength;
+	enum dma_channel_status bStatus;
+	u8 bDesiredMode;
 };
 
 /**
@@ -142,9 +142,10 @@ typedef u8(*MGC_pfDmaStopController) (vo
  * @return NULL on failure (no channel available)
  */
 typedef struct dma_channel *(*MGC_pfDmaAllocateChannel) (void *pPrivateData,
-						     u8 bLocalEnd, u8 bTransmit,
-						     u8 bProtocol,
-						     u16 wMaxPacketSize);
+							 u8 bLocalEnd,
+							 u8 bTransmit,
+							 u8 bProtocol,
+							 u16 wMaxPacketSize);
 
 /**
  * Release a DMA channel.
@@ -153,7 +154,7 @@ typedef struct dma_channel *(*MGC_pfDmaA
  * @param pChannel pointer to a channel obtained by
  * a successful call to pController->pfDmaAllocateChannel
  */
-typedef void (*MGC_pfDmaReleaseChannel) (struct dma_channel *pChannel);
+typedef void (*MGC_pfDmaReleaseChannel) (struct dma_channel * pChannel);
 
 /**
  * Program a DMA channel.
@@ -170,7 +171,7 @@ typedef void (*MGC_pfDmaReleaseChannel) 
  * @return TRUE on success
  * @return FALSE on error
  */
-typedef u8(*MGC_pfDmaProgramChannel) (struct dma_channel *pChannel,
+typedef u8(*MGC_pfDmaProgramChannel) (struct dma_channel * pChannel,
 				      u16 wPacketSize, u8 bMode,
 				      // const u8* pBuffer,
 				      dma_addr_t dma_addr, u32 dwLength);
@@ -183,8 +184,7 @@ typedef u8(*MGC_pfDmaProgramChannel) (st
  * then it's possible that the hardware has completed (or aborted) a transfer,
  * so the driver needs to update that status.
  */
-static inline enum dma_channel_status
-dma_channel_status(struct dma_channel *c)
+static inline enum dma_channel_status dma_channel_status(struct dma_channel *c)
 {
 	return (is_dma_capable() && c) ? c->bStatus : MGC_DMA_STATUS_UNKNOWN;
 }
@@ -229,7 +229,7 @@ struct dma_controller {
 	MGC_pfDmaAllocateChannel pfDmaAllocateChannel;
 	MGC_pfDmaReleaseChannel pfDmaReleaseChannel;
 	MGC_pfDmaProgramChannel pfDmaProgramChannel;
-	int (*pfDmaAbortChannel)(struct dma_channel *);
+	int (*pfDmaAbortChannel) (struct dma_channel *);
 	MGC_pfDmaControllerIsr pfDmaControllerIsr;
 };
 
@@ -244,8 +244,8 @@ struct dma_controller {
  * @param bTransmit TRUE for transmit; FALSE for receive
  * @return zero for success, else a negative errno fault code
  */
-typedef int (*MGC_pfDmaChannelStatusChanged)(void *pPrivateData,
-		u8 bLocalEnd, u8 bTransmit);
+typedef int (*MGC_pfDmaChannelStatusChanged) (void *pPrivateData,
+					      u8 bLocalEnd, u8 bTransmit);
 
 /**
  * Instantiate a DMA controller.
@@ -262,15 +262,16 @@ typedef int (*MGC_pfDmaChannelStatusChan
  * a fixed number of controllers)
  */
 typedef struct dma_controller
-    *(*MGC_pfNewDmaController) (MGC_pfDmaChannelStatusChanged
-				pfDmaChannelStatusChanged, void *pDmaPrivate,
-				u8 *pCoreBase);
+*(*MGC_pfNewDmaController) (MGC_pfDmaChannelStatusChanged
+			    pfDmaChannelStatusChanged, void *pDmaPrivate,
+			    u8 * pCoreBase);
 
 /**
  * Destroy DMA controller.
  * Destroy a previously-instantiated DMA controller.
  */
-typedef void (*MGC_pfDestroyDmaController) (struct dma_controller *pController);
+typedef void (*MGC_pfDestroyDmaController) (struct dma_controller *
+					    pController);
 
 /**
  * struct dma_controller_factory: DMA controller factory
@@ -289,4 +290,4 @@ struct dma_controller_factory {
 
 extern struct dma_controller_factory dma_controller_factory;
 
-#endif	/* __MUSB_DMA_H__ */
+#endif				/* __MUSB_DMA_H__ */
Index: linux-2.6.10/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.10/drivers/usb/musb/g_ep0.c
@@ -54,31 +54,35 @@
  * the gadget driver, or adjusting endpoint halt status.
  */
 
-
 #ifdef	DEBUG
 static char *decode_ep0stage(u8 stage)
 {
-	switch(stage) {
-	case MGC_END0_STAGE_SETUP:	return "idle";
-	case MGC_END0_STAGE_TX:		return "in";
-	case MGC_END0_STAGE_RX:		return "out";
-	case MGC_END0_STAGE_ACKWAIT:	return "wait";
-	case MGC_END0_STAGE_STATUSIN:	return "in/status";
-	case MGC_END0_STAGE_STATUSOUT:	return "out/status";
-	default:			return "?";
+	switch (stage) {
+	case MGC_END0_STAGE_SETUP:
+		return "idle";
+	case MGC_END0_STAGE_TX:
+		return "in";
+	case MGC_END0_STAGE_RX:
+		return "out";
+	case MGC_END0_STAGE_ACKWAIT:
+		return "wait";
+	case MGC_END0_STAGE_STATUSIN:
+		return "in/status";
+	case MGC_END0_STAGE_STATUSOUT:
+		return "out/status";
+	default:
+		return "?";
 	}
 }
 #endif
 
-
 /* handle a standard GET_STATUS request
  * Context:  caller holds controller lock
  */
-static int service_tx_status_request(
-	struct musb *pThis,
-	const struct usb_ctrlrequest *pControlRequest)
+static int service_tx_status_request(struct musb *pThis, const struct usb_ctrlrequest
+				     *pControlRequest)
 {
-	void __iomem	*pBase = pThis->pRegs;
+	void __iomem *pBase = pThis->pRegs;
 	int handled = 1;
 	u8 bResult[2], bEnd = 0;
 	const u8 bRecip = pControlRequest->bRequestType & USB_RECIP_MASK;
@@ -105,41 +109,44 @@ static int service_tx_status_request(
 		bResult[0] = 0;
 		break;
 
-	case USB_RECIP_ENDPOINT: {
-		int		is_in;
-		struct musb_ep	*ep;
-		u16		tmp;
-
-		bEnd = (u8) pControlRequest->wIndex;
-		if (!bEnd) {
-			bResult[0] = 0;
-			break;
-		}
+	case USB_RECIP_ENDPOINT:{
+			int is_in;
+			struct musb_ep *ep;
+			u16 tmp;
+
+			bEnd = (u8) le16_to_cpu(pControlRequest->wIndex);
+			if (!bEnd) {
+				bResult[0] = 0;
+				break;
+			}
 
-		is_in = bEnd & USB_DIR_IN;
-		if (is_in) {
-			bEnd &= 0x0f;
-			ep = &pThis->aLocalEnd[bEnd].ep_in;
-		} else {
-			ep = &pThis->aLocalEnd[bEnd].ep_out;
-		}
+			is_in = bEnd & USB_DIR_IN;
+			if (is_in) {
+				bEnd &= 0x0f;
+				ep = &pThis->aLocalEnd[bEnd].ep_in;
+			} else {
+				ep = &pThis->aLocalEnd[bEnd].ep_out;
+			}
 
-		if (bEnd >= MUSB_C_NUM_EPS || !ep->desc) {
-			handled = -EINVAL;
-			break;
-		}
+			if (bEnd >= MUSB_C_NUM_EPS || !ep->desc) {
+				handled = -EINVAL;
+				break;
+			}
 
-		MGC_SelectEnd(pBase, bEnd);
+			MGC_SelectEnd(pBase, bEnd);
 
-		if (is_in)
-			tmp = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd)
-						& MGC_M_TXCSR_P_SENDSTALL;
-		else
-			tmp = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd)
-						& MGC_M_RXCSR_P_SENDSTALL;
+			if (is_in)
+				tmp =
+				    MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd)
+				    & MGC_M_TXCSR_P_SENDSTALL;
+			else
+				tmp =
+				    MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd)
+				    & MGC_M_RXCSR_P_SENDSTALL;
 
-		bResult[0] = tmp ? 1 : 0;
-		} break;
+			bResult[0] = tmp ? 1 : 0;
+		}
+		break;
 
 	default:
 		/* class, vendor, etc ... delegate */
@@ -149,7 +156,7 @@ static int service_tx_status_request(
 
 	/* fill up the fifo; caller updates csr0 */
 	if (handled > 0) {
-		u16	len = le16_to_cpu(pControlRequest->wLength);
+		u16 len = le16_to_cpu(pControlRequest->wLength);
 
 		if (len > 2)
 			len = 2;
@@ -177,14 +184,14 @@ service_in_request(struct musb *pThis,
 	int handled = 0;	/* not handled */
 
 	if ((pControlRequest->bRequestType & USB_TYPE_MASK)
-			== USB_TYPE_STANDARD) {
+	    == USB_TYPE_STANDARD) {
 		switch (pControlRequest->bRequest) {
 		case USB_REQ_GET_STATUS:
 			handled = service_tx_status_request(pThis,
-					pControlRequest);
+							    pControlRequest);
 			break;
 
-		/* case USB_REQ_SYNC_FRAME: */
+			/* case USB_REQ_SYNC_FRAME: */
 
 		default:
 			break;
@@ -202,7 +209,6 @@ static void musb_g_ep0_giveback(struct m
 	musb_g_giveback(&pThis->aLocalEnd[0].ep_in, req, 0);
 }
 
-
 /* for high speed test mode; see USB 2.0 spec */
 static const u8 musb_test_packet[53] = {
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -226,9 +232,8 @@ static const u8 musb_test_packet[53] = {
  */
 static int
 service_zero_data_request(struct musb *pThis,
-		struct usb_ctrlrequest *pControlRequest)
-__releases(pThis->Lock)
-__acquires(pThis->Lock)
+			  struct usb_ctrlrequest *pControlRequest)
+__releases(pThis->Lock) __acquires(pThis->Lock)
 {
 	int handled = -EINVAL;
 	void __iomem *pBase = pThis->pRegs;
@@ -236,20 +241,21 @@ __acquires(pThis->Lock)
 
 	/* the gadget driver handles everything except what we MUST handle */
 	if ((pControlRequest->bRequestType & USB_TYPE_MASK)
-			== USB_TYPE_STANDARD) {
+	    == USB_TYPE_STANDARD) {
 		switch (pControlRequest->bRequest) {
 		case USB_REQ_SET_ADDRESS:
 			/* change it after the status stage */
 			pThis->bSetAddress = TRUE;
-			pThis->bAddress = (u8) (pControlRequest->wValue & 0x7f);
+			pThis->bAddress =
+			    (u8) (le16_to_cpu(pControlRequest->wValue) & 0x7f);
 			handled = 1;
 			break;
 
 		case USB_REQ_CLEAR_FEATURE:
 			switch (bRecip) {
 			case USB_RECIP_DEVICE:
-				if (pControlRequest->wValue
-						!= USB_DEVICE_REMOTE_WAKEUP)
+				if (le16_to_cpu(pControlRequest->wValue)
+				    != USB_DEVICE_REMOTE_WAKEUP)
 					break;
 				pThis->bMayWakeup = 0;
 				handled = 1;
@@ -257,31 +263,41 @@ __acquires(pThis->Lock)
 			case USB_RECIP_INTERFACE:
 				break;
 			case USB_RECIP_ENDPOINT:{
-				const u8 bEnd = pControlRequest->wIndex & 0x0f;
-				struct musb_ep *pEnd;
-
-				if (bEnd == 0
-						|| bEnd >= MUSB_C_NUM_EPS
-						|| pControlRequest->wValue
-							!= USB_ENDPOINT_HALT)
-					break;
-
-				if (pControlRequest->wIndex & USB_DIR_IN)
-					pEnd = &pThis->aLocalEnd[bEnd].ep_in;
-				else
-					pEnd = &pThis->aLocalEnd[bEnd].ep_out;
-				if (!pEnd->desc)
-					break;
+					const u8 bEnd =
+					    le16_to_cpu(pControlRequest->
+							wIndex) & 0x0f;
+					struct musb_ep *pEnd;
+
+					if (bEnd == 0
+					    || bEnd >= MUSB_C_NUM_EPS
+					    || le16_to_cpu(pControlRequest->
+							   wValue)
+					    != USB_ENDPOINT_HALT)
+						break;
 
-				/* REVISIT do it directly, no locking games */
-				spin_unlock(&pThis->Lock);
-				musb_gadget_set_halt(&pEnd->end_point, 0);
-				spin_lock(&pThis->Lock);
+					if (le16_to_cpu(pControlRequest->wIndex)
+					    & USB_DIR_IN)
+						pEnd =
+						    &pThis->aLocalEnd[bEnd].
+						    ep_in;
+					else
+						pEnd =
+						    &pThis->aLocalEnd[bEnd].
+						    ep_out;
+					if (!pEnd->desc)
+						break;
 
-				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
-				handled = 1;
-				} break;
+					/* REVISIT do it directly, no locking games */
+					spin_unlock(&pThis->Lock);
+					musb_gadget_set_halt(&pEnd->end_point,
+							     0);
+					spin_lock(&pThis->Lock);
+
+					/* select ep0 again */
+					MGC_SelectEnd(pBase, 0);
+					handled = 1;
+				}
+				break;
 			default:
 				/* class, vendor, etc ... delegate */
 				handled = 0;
@@ -293,40 +309,43 @@ __acquires(pThis->Lock)
 			switch (bRecip) {
 			case USB_RECIP_DEVICE:
 				handled = 1;
-				switch (pControlRequest->wValue) {
+				switch (le16_to_cpu(pControlRequest->wValue)) {
 				case USB_DEVICE_REMOTE_WAKEUP:
 					pThis->bMayWakeup = 1;
 					break;
 				case USB_DEVICE_TEST_MODE:
 					if (pThis->g.speed != USB_SPEED_HIGH)
 						goto stall;
-					if (pControlRequest->wIndex & 0xff)
+					if (le16_to_cpu(pControlRequest->wIndex)
+					    & 0xff)
 						goto stall;
 
-					switch (pControlRequest->wIndex >> 8) {
+					switch (le16_to_cpu
+						(pControlRequest->
+						 wIndex) >> 8) {
 					case 1:
 						pr_debug("TEST_J\n");
 						/* TEST_J */
 						pThis->bTestModeValue =
-							MGC_M_TEST_J;
+						    MGC_M_TEST_J;
 						break;
 					case 2:
 						/* TEST_K */
 						pr_debug("TEST_K\n");
 						pThis->bTestModeValue =
-							MGC_M_TEST_K;
+						    MGC_M_TEST_K;
 						break;
 					case 3:
 						/* TEST_SE0_NAK */
 						pr_debug("TEST_SE0_NAK\n");
 						pThis->bTestModeValue =
-							MGC_M_TEST_SE0_NAK;
+						    MGC_M_TEST_SE0_NAK;
 						break;
 					case 4:
 						/* TEST_PACKET */
 						pr_debug("TEST_PACKET\n");
 						pThis->bTestModeValue =
-							MGC_M_TEST_PACKET;
+						    MGC_M_TEST_PACKET;
 						break;
 					default:
 						goto stall;
@@ -340,16 +359,19 @@ __acquires(pThis->Lock)
 				case USB_DEVICE_B_HNP_ENABLE:
 					if (!pThis->g.is_otg)
 						goto stall;
-					{ u8 devctl;
-					pThis->g.b_hnp_enable = 1;
+					{
+						u8 devctl;
+						pThis->g.b_hnp_enable = 1;
 #if 1
-					devctl = musb_readb(pBase,
-							MGC_O_HDRC_DEVCTL);
-					/* REVISIT after roleswitch, HR will
-					 * have been cleared ... reset it
-					 */
-					musb_writeb(pBase, MGC_O_HDRC_DEVCTL,
-						devctl | MGC_M_DEVCTL_HR);
+						devctl = musb_readb(pBase,
+								    MGC_O_HDRC_DEVCTL);
+						/* REVISIT after roleswitch, HR will
+						 * have been cleared ... reset it
+						 */
+						musb_writeb(pBase,
+							    MGC_O_HDRC_DEVCTL,
+							    devctl |
+							    MGC_M_DEVCTL_HR);
 #endif
 					}
 					break;
@@ -364,7 +386,7 @@ __acquires(pThis->Lock)
 					pThis->g.a_alt_hnp_support = 1;
 					break;
 #endif
-stall:
+				      stall:
 				default:
 					handled = -EINVAL;
 					break;
@@ -375,31 +397,41 @@ stall:
 				break;
 
 			case USB_RECIP_ENDPOINT:{
-				const u8 bEnd = (u8)pControlRequest->wIndex & 0x0f;
-				struct musb_ep *pEnd;
-				
-				if (bEnd == 0
-						|| bEnd >= MUSB_C_NUM_EPS
-						|| pControlRequest->wValue
-							!= USB_ENDPOINT_HALT)
-					break;
-
-				if (pControlRequest->wIndex & USB_DIR_IN)
-					pEnd = &pThis->aLocalEnd[bEnd].ep_in;
-				else
-					pEnd = &pThis->aLocalEnd[bEnd].ep_out;
-				if (!pEnd->desc)
-					break;
+					const u8 bEnd =
+					    (u8) le16_to_cpu(pControlRequest->
+							     wIndex) & 0x0f;
+					struct musb_ep *pEnd;
+
+					if (bEnd == 0
+					    || bEnd >= MUSB_C_NUM_EPS
+					    || le16_to_cpu(pControlRequest->
+							   wValue)
+					    != USB_ENDPOINT_HALT)
+						break;
 
-				/* REVISIT do it directly, no locking games */
-				spin_unlock(&pThis->Lock);
-				musb_gadget_set_halt(&pEnd->end_point, 1);
-				spin_lock(&pThis->Lock);
+					if (le16_to_cpu(pControlRequest->wIndex)
+					    & USB_DIR_IN)
+						pEnd =
+						    &pThis->aLocalEnd[bEnd].
+						    ep_in;
+					else
+						pEnd =
+						    &pThis->aLocalEnd[bEnd].
+						    ep_out;
+					if (!pEnd->desc)
+						break;
 
-				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
-				handled = 1;
-				} break;
+					/* REVISIT do it directly, no locking games */
+					spin_unlock(&pThis->Lock);
+					musb_gadget_set_halt(&pEnd->end_point,
+							     1);
+					spin_lock(&pThis->Lock);
+
+					/* select ep0 again */
+					MGC_SelectEnd(pBase, 0);
+					handled = 1;
+				}
+				break;
 			default:
 				/* class, vendor, etc ... delegate */
 				handled = 0;
@@ -420,9 +452,9 @@ stall:
  */
 static void ep0_rxstate(struct musb *this)
 {
-	void __iomem		*pBase = this->pRegs;
-	struct usb_request	*req;
-	u16			tmp;
+	void __iomem *pBase = this->pRegs;
+	struct usb_request *req;
+	u16 tmp;
 
 	req = next_ep0_request(this);
 
@@ -430,8 +462,8 @@ static void ep0_rxstate(struct musb *thi
 	 * should have provided the rx buffer before setup() returned.
 	 */
 	if (req) {
-		void		*buf = req->buf + req->actual;
-		unsigned	len = req->length - req->actual;
+		void *buf = req->buf + req->actual;
+		unsigned len = req->length - req->actual;
 
 		/* read the buffer */
 		tmp = MGC_ReadCsr8(pBase, MGC_O_HDRC_COUNT0, 0);
@@ -451,7 +483,6 @@ static void ep0_rxstate(struct musb *thi
 		tmp = MGC_M_CSR0_P_SVDRXPKTRDY | MGC_M_CSR0_P_SENDSTALL;
 	MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0, tmp);
 
-
 	/* NOTE:  we "should" hold off reporting DATAEND and going to
 	 * STATUSIN until after the completion handler decides whether
 	 * to issue a stall instead, since this hardware can do that.
@@ -468,28 +499,29 @@ static void ep0_rxstate(struct musb *thi
  */
 static void ep0_txstate(struct musb *pThis)
 {
-	void __iomem		*pBase = pThis->pRegs;
-	struct usb_request	*pRequest = next_ep0_request(pThis);
-	u16			wCsrVal = MGC_M_CSR0_TXPKTRDY;
-	u8			*pFifoSource;
-	u8			wFifoCount;
+	void __iomem *pBase = pThis->pRegs;
+	struct usb_request *pRequest = next_ep0_request(pThis);
+	u16 wCsrVal = MGC_M_CSR0_TXPKTRDY;
+	u8 *pFifoSource;
+	u8 wFifoCount;
 
 	if (!pRequest) {
 		// WARN_ON(1);
-		DBG(2, "odd, csr %04x\n", MGC_ReadCsr16(pBase, MGC_O_HDRC_CSR0, 0));
+		DBG(2, "odd, csr %04x\n", MGC_ReadCsr16(pBase, MGC_O_HDRC_CSR0,
+							0));
 		return;
 	}
 
 	/* load the data */
 	pFifoSource = (u8 *) pRequest->buf + pRequest->actual;
-	wFifoCount = min((unsigned) MGC_END0_FIFOSIZE,
-		pRequest->length - pRequest->actual);
+	wFifoCount = min((unsigned)MGC_END0_FIFOSIZE,
+			 pRequest->length - pRequest->actual);
 	musb_write_fifo(&pThis->aLocalEnd[0], wFifoCount, pFifoSource);
 	pRequest->actual += wFifoCount;
 
 	/* update the flags */
 	if (wFifoCount < MUSB_MAX_END0_PACKET
-			|| pRequest->actual == pRequest->length) {
+	    || pRequest->actual == pRequest->length) {
 		pThis->ep0_state = MGC_END0_STAGE_STATUSOUT;
 		wCsrVal |= MGC_M_CSR0_P_DATAEND;
 	} else
@@ -513,14 +545,23 @@ static void ep0_txstate(struct musb *pTh
  *
  * Context:  caller holds controller lock.
  */
-static void
-musb_read_setup(struct musb *pThis, struct usb_ctrlrequest *req)
+static void musb_read_setup(struct musb *pThis, struct usb_ctrlrequest *req)
 {
-	void __iomem		*pBase = pThis->pRegs;
-	struct usb_request	*r;
+	void __iomem *pBase = pThis->pRegs;
+	struct usb_request *r;
 
-	musb_read_fifo(&pThis->aLocalEnd[0], sizeof *req, (u8 *)req);
+	musb_read_fifo(&pThis->aLocalEnd[0], sizeof *req, (u8 *) req);
 
+	/* NOTE:  earlier 2.6 versions changed setup packets to host
+	 * order, but now USB packets always stay in USB byte order.
+	 */
+/*	printk("SETUP req%02x.%02x v%04x i%04x l%04x\n",
+		 req->bRequestType,
+		 req->bRequest,
+		 req->wValue,
+		 req->wIndex,
+		 req->wLength);
+*/
 	/* clean up any leftover transfers */
 	r = next_ep0_request(pThis);
 	if (r)
@@ -544,22 +585,20 @@ musb_read_setup(struct musb *pThis, stru
 	 * device-to-host, the TXPKTRDY bit needs to be set in TXCSR otherwise
 	 * the STATUS stage of control transfer will never complete.
 	 *
-	 * Fixed MRs: 
+	 * Fixed MRs:
 	 * None
 	 */
-	if(req->wLength == 0 && (req->bRequestType & USB_DIR_IN))
-	{
+	if (req->wLength == 0 && (req->bRequestType & USB_DIR_IN)) {
 		pThis->ackpend |= MGC_M_CSR0_TXPKTRDY;
 		pThis->ep0_state = MGC_END0_STAGE_ACKWAIT;
-	}
-	else if (req->wLength == 0)
+	} else if (req->wLength == 0)
 		pThis->ep0_state = MGC_END0_STAGE_ACKWAIT;
 	else if (req->bRequestType & USB_DIR_IN) {
 		pThis->ep0_state = MGC_END0_STAGE_TX;
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
-				MGC_M_CSR0_P_SVDRXPKTRDY);
+			       MGC_M_CSR0_P_SVDRXPKTRDY);
 		while ((MGC_ReadCsr16(pBase, MGC_O_HDRC_CSR0, 0)
-				& MGC_M_CSR0_RXPKTRDY) != 0)
+			& MGC_M_CSR0_RXPKTRDY) != 0)
 			cpu_relax();
 		pThis->ackpend = 0;
 	} else
@@ -569,8 +608,7 @@ musb_read_setup(struct musb *pThis, stru
 static int
 forward_to_driver(struct musb *musb,
 		  const struct usb_ctrlrequest *pControlRequest)
-__releases(musb->Lock)
-__acquires(musb->Lock)
+__releases(musb->Lock) __acquires(musb->Lock)
 {
 	int retval;
 	if (!musb->pGadgetDriver)
@@ -587,21 +625,21 @@ __acquires(musb->Lock)
  *
  * Context: irq handler; we won't re-enter the driver that way.
  */
-irqreturn_t musb_g_ep0_irq(struct musb *pThis)
+irqreturn_t musb_g_ep0_irq(struct musb * pThis)
 {
-	u16		wCsrVal;
-	u16		wCount;
-	void __iomem	*pBase = pThis->pRegs;
-	irqreturn_t	retval = IRQ_NONE;
+	u16 wCsrVal;
+	u16 wCount;
+	void __iomem *pBase = pThis->pRegs;
+	irqreturn_t retval = IRQ_NONE;
 
 	MGC_SelectEnd(pBase, 0);	/* select ep0 */
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_CSR0, 0);
 	wCount = MGC_ReadCsr8(pBase, MGC_O_HDRC_COUNT0, 0);
 
 	DBG(4, "csr %04x, count %d, myaddr %d, ep0stage %s\n",
-			wCsrVal, wCount,
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
-			decode_ep0stage(pThis->ep0_state));
+	    wCsrVal, wCount,
+	    musb_readb(pBase, MGC_O_HDRC_FADDR),
+	    decode_ep0stage(pThis->ep0_state));
 
 	/* I sent a stall.. need to acknowledge it now.. */
 	if (wCsrVal & MGC_M_CSR0_P_SENTSTALL) {
@@ -661,21 +699,21 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 			if (MGC_M_TEST_PACKET == pThis->bTestModeValue) {
 				musb_write_fifo(&pThis->aLocalEnd[0],
-						 sizeof(musb_test_packet),
-						 musb_test_packet);
+						sizeof(musb_test_packet),
+						musb_test_packet);
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
 					       wCsrVal | MGC_M_CSR0_TXPKTRDY);
 			}
 
 			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
-				   pThis->bTestModeValue);
+				    pThis->bTestModeValue);
 		}
 		/* FALLTHROUGH */
 
 	case MGC_END0_STAGE_STATUSOUT:
 		/* end of sequence #1: write to host (TX state) */
 		{
-			struct usb_request	*req;
+			struct usb_request *req;
 
 			req = next_ep0_request(pThis);
 			if (req)
@@ -687,8 +725,8 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 	case MGC_END0_STAGE_SETUP:
 		if (wCsrVal & MGC_M_CSR0_RXPKTRDY) {
-			struct usb_ctrlrequest	setup;
-			int			handled = 0;
+			struct usb_ctrlrequest setup;
+			int handled = 0;
 
 			if (wCount != 8) {
 				ERR("SETUP packet len %d != 8 ?\n", wCount);
@@ -699,11 +737,10 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 			/* sometimes the RESET won't be reported */
 			if (unlikely(pThis->g.speed == USB_SPEED_UNKNOWN)) {
-				u8	power;
+				u8 power;
 
 				printk(KERN_NOTICE "%s: peripheral reset "
-						"irq lost!\n",
-						musb_driver_name);
+				       "irq lost!\n", musb_driver_name);
 				power = musb_readb(pBase, MGC_O_HDRC_POWER);
 				pThis->g.speed = (power & MGC_M_POWER_HSMODE)
 				    ? USB_SPEED_HIGH : USB_SPEED_FULL;
@@ -712,45 +749,45 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 			switch (pThis->ep0_state) {
 
-			/* sequence #3 (no data stage), includes requests
-			 * we can't forward (notably SET_ADDRESS and the
-			 * device/endpoint feature set/clear operations)
-			 * plus SET_CONFIGURATION and others we must
-			 */
+				/* sequence #3 (no data stage), includes requests
+				 * we can't forward (notably SET_ADDRESS and the
+				 * device/endpoint feature set/clear operations)
+				 * plus SET_CONFIGURATION and others we must
+				 */
 			case MGC_END0_STAGE_ACKWAIT:
-				handled = service_zero_data_request(
-						pThis, &setup);
+				handled =
+				    service_zero_data_request(pThis, &setup);
 
 				/* status stage might be immediate */
 				if (handled > 0) {
 					pThis->ackpend |= MGC_M_CSR0_P_DATAEND;
 					pThis->ep0_state =
-						MGC_END0_STAGE_STATUSIN;
+					    MGC_END0_STAGE_STATUSIN;
 				}
 				break;
 
-			/* sequence #1 (IN to host), includes GET_STATUS
-			 * requests that we can't forward, GET_DESCRIPTOR
-			 * and others that we must
-			 */
+				/* sequence #1 (IN to host), includes GET_STATUS
+				 * requests that we can't forward, GET_DESCRIPTOR
+				 * and others that we must
+				 */
 			case MGC_END0_STAGE_TX:
 				handled = service_in_request(pThis, &setup);
 				if (handled > 0) {
 					pThis->ackpend = MGC_M_CSR0_TXPKTRDY
-						| MGC_M_CSR0_P_DATAEND;
+					    | MGC_M_CSR0_P_DATAEND;
 					pThis->ep0_state =
-						MGC_END0_STAGE_STATUSOUT;
+					    MGC_END0_STAGE_STATUSOUT;
 				}
 				break;
 
-			/* sequence #2 (OUT from host), always forward */
-			default:		/* MGC_END0_STAGE_RX */
+				/* sequence #2 (OUT from host), always forward */
+			default:	/* MGC_END0_STAGE_RX */
 				break;
 			}
 
 			DBG(3, "handled %d, csr %04x, ep0stage %s\n",
-				handled, wCsrVal,
-				decode_ep0stage(pThis->ep0_state));
+			    handled, wCsrVal,
+			    decode_ep0stage(pThis->ep0_state));
 
 			/* unless we need to delegate this to the gadget
 			 * driver, we know how to wrap this up:  csr0 has
@@ -764,12 +801,12 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 			handled = forward_to_driver(pThis, &setup);
 			if (handled < 0) {
 				MGC_SelectEnd(pBase, 0);
-stall:
+			      stall:
 				DBG(3, "stall (%d)\n", handled);
 				pThis->ackpend |= MGC_M_CSR0_P_SENDSTALL;
-finish:
+			      finish:
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
-						pThis->ackpend);
+					       pThis->ackpend);
 				pThis->ackpend = 0;
 			}
 		}
@@ -779,7 +816,7 @@ finish:
 		/* "can't happen" */
 		WARN_ON(1);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
-				MGC_M_CSR0_P_SENDSTALL);
+			       MGC_M_CSR0_P_SENDSTALL);
 		pThis->ep0_state = MGC_END0_STAGE_SETUP;
 		break;
 	}
@@ -787,7 +824,6 @@ finish:
 	return retval;
 }
 
-
 static int
 musb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)
 {
@@ -802,14 +838,14 @@ static int musb_g_ep0_disable(struct usb
 }
 
 static void *musb_g_ep0_alloc_buffer(struct usb_ep *ep, unsigned bytes,
-			    dma_addr_t * dma, gfp_t gfp_flags)
+				     dma_addr_t * dma, gfp_t gfp_flags)
 {
 	*dma = DMA_ADDR_INVALID;
 	return kmalloc(bytes, gfp_flags);
 }
 
-static void musb_g_ep0_free_buffer(struct usb_ep *ep, void *address, dma_addr_t dma,
-			  unsigned bytes)
+static void musb_g_ep0_free_buffer(struct usb_ep *ep, void *address,
+				   dma_addr_t dma, unsigned bytes)
 {
 	kfree(address);
 }
@@ -817,11 +853,11 @@ static void musb_g_ep0_free_buffer(struc
 static int
 musb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)
 {
-	struct musb_ep		*ep;
-	struct musb_request	*req;
-	struct musb		*musb;
-	int			status;
-	unsigned long		lockflags;
+	struct musb_ep *ep;
+	struct musb_request *req;
+	struct musb *musb;
+	int status;
+	unsigned long lockflags;
 
 	if (!e || !r)
 		return -EINVAL;
@@ -843,14 +879,13 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 	}
 
 	switch (musb->ep0_state) {
-	case MGC_END0_STAGE_RX:		/* control-OUT data */
-	case MGC_END0_STAGE_TX:		/* control-IN data */
+	case MGC_END0_STAGE_RX:	/* control-OUT data */
+	case MGC_END0_STAGE_TX:	/* control-IN data */
 	case MGC_END0_STAGE_ACKWAIT:	/* zero-length data */
 		status = 0;
 		break;
 	default:
-		DBG(1, "ep0 request queued in state %d\n",
-				musb->ep0_state);
+		DBG(1, "ep0 request queued in state %d\n", musb->ep0_state);
 		status = -EINVAL;
 		goto cleanup;
 	}
@@ -859,8 +894,7 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 	list_add_tail(&(req->request.list), &(ep->req_list));
 
 	DBG(3, "queue to %s (%s), length=%d\n",
-			ep->name, ep->is_in ? "IN/TX" : "OUT/RX",
-			req->request.length);
+	    ep->name, ep->is_in ? "IN/TX" : "OUT/RX", req->request.length);
 
 	MGC_SelectEnd(musb->pRegs, 0);
 
@@ -880,23 +914,21 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 			musb_g_ep0_giveback(ep->pThis, r);
 		}
 
-	/* else for sequence #2 (OUT), caller provides a buffer
-	 * before the next packet arrives.  deferred responses
-	 * (after SETUP is acked) are racey.
-	 */
+		/* else for sequence #2 (OUT), caller provides a buffer
+		 * before the next packet arrives.  deferred responses
+		 * (after SETUP is acked) are racey.
+		 */
 	} else if (musb->ackpend) {
-		MGC_WriteCsr16(musb->pRegs, MGC_O_HDRC_CSR0, 0,
-			       musb->ackpend);
+		MGC_WriteCsr16(musb->pRegs, MGC_O_HDRC_CSR0, 0, musb->ackpend);
 		musb->ackpend = 0;
 	}
 
-cleanup:
+      cleanup:
 	spin_unlock_irqrestore(&musb->Lock, lockflags);
 	return status;
 }
 
-static int
-musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
+static int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
 	/* we just won't support this */
 	return -EINVAL;
@@ -904,12 +936,12 @@ musb_g_ep0_dequeue(struct usb_ep *ep, st
 
 static int musb_g_ep0_halt(struct usb_ep *e, int value)
 {
-	struct musb_ep		*ep;
-	struct musb		*musb;
-	void __iomem		*base;
-	unsigned long		flags;
-	int			status;
-	u16			csr;
+	struct musb_ep *ep;
+	struct musb *musb;
+	void __iomem *base;
+	unsigned long flags;
+	int status;
+	u16 csr;
 
 	if (!e || !value)
 		return -EINVAL;
@@ -926,9 +958,9 @@ static int musb_g_ep0_halt(struct usb_ep
 	}
 
 	switch (musb->ep0_state) {
-	case MGC_END0_STAGE_TX:		/* control-IN data */
+	case MGC_END0_STAGE_TX:	/* control-IN data */
 	case MGC_END0_STAGE_ACKWAIT:	/* STALL for zero-length data */
-	case MGC_END0_STAGE_RX:		/* control-OUT data */
+	case MGC_END0_STAGE_RX:	/* control-OUT data */
 		status = 0;
 
 		MGC_SelectEnd(base, 0);
@@ -942,21 +974,21 @@ static int musb_g_ep0_halt(struct usb_ep
 		status = -EINVAL;
 	}
 
-cleanup:
+      cleanup:
 	spin_unlock_irqrestore(&musb->Lock, flags);
 	return status;
 }
 
 struct usb_ep_ops musb_g_ep0_ops = {
-	.enable		= musb_g_ep0_enable,
-	.disable	= musb_g_ep0_disable,
-	.alloc_request	= musb_alloc_request,
-	.free_request	= musb_free_request,
-	.alloc_buffer	= musb_g_ep0_alloc_buffer,
-	.free_buffer	= musb_g_ep0_free_buffer,
-	.queue		= musb_g_ep0_queue,
-	.dequeue	= musb_g_ep0_dequeue,
-	.set_halt	= musb_g_ep0_halt,
-	.fifo_status	= NULL,
-	.fifo_flush	= NULL,
+	.enable = musb_g_ep0_enable,
+	.disable = musb_g_ep0_disable,
+	.alloc_request = musb_alloc_request,
+	.free_request = musb_free_request,
+	.alloc_buffer = musb_g_ep0_alloc_buffer,
+	.free_buffer = musb_g_ep0_free_buffer,
+	.queue = musb_g_ep0_queue,
+	.dequeue = musb_g_ep0_dequeue,
+	.set_halt = musb_g_ep0_halt,
+	.fifo_status = NULL,
+	.fifo_flush = NULL,
 };
Index: linux-2.6.10/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.10/drivers/usb/musb/musb_gadget.c
@@ -49,6 +49,7 @@
 #include "otg.h"
 #endif
 
+static void musb_gadget_fifo_flush(struct usb_ep *ep);
 /* MUSB PERIPHERAL status 3-mar:
  *
  * - EP0 seems solid.  It passes both USBCV and usbtest control cases.
@@ -83,7 +84,7 @@
  *   (Workaround:  they can turn it off later.)
  */
 
-// #define	DISABLE_RXDMA
+// #define  DISABLE_RXDMA
 
 /**************************************************************************
 Handling completion
@@ -96,15 +97,13 @@ Handling completion
  * @param status the status to complete the request with
  * Context: controller locked, IRQs blocked.
  */
-void musb_g_giveback(
-	struct musb_ep		*ep,
-	struct usb_request	*pRequest,
-	int status)
-__releases(ep->musb->Lock)
-__acquires(ep->musb->Lock)
+void musb_g_giveback(struct musb_ep *ep,
+		     struct usb_request *pRequest,
+		     int status)
+__releases(ep->musb->Lock) __acquires(ep->musb->Lock)
 {
-	struct musb_request	*req;
-	struct musb		*musb;
+	struct musb_request *req;
+	struct musb *musb;
 
 	req = to_musb_request(pRequest);
 
@@ -116,26 +115,24 @@ __acquires(ep->musb->Lock)
 	spin_unlock(&musb->Lock);
 	if (is_dma_capable() && req->mapped) {
 		dma_unmap_single(musb->controller,
-				req->request.dma,
-				req->request.length,
-				req->bTx
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
+				 req->request.dma,
+				 req->request.length,
+				 req->bTx ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 		req->request.dma = DMA_ADDR_INVALID;
 		req->mapped = 0;
 	}
 	if (pRequest->status == 0)
 		DBG(5, "%s done request %p,  %d/%d\n",
-				ep->end_point.name, pRequest,
-				req->request.actual, req->request.length);
+		    ep->end_point.name, pRequest,
+		    req->request.actual, req->request.length);
 	else
 		DBG(2, "%s request %p, %d/%d fault %d\n",
-				ep->end_point.name, pRequest,
-				req->request.actual, req->request.length,
-				pRequest->status);
+		    ep->end_point.name, pRequest,
+		    req->request.actual, req->request.length, pRequest->status);
+	ep->fifo_flush_check = 0;
 	req->request.complete(&req->ep->end_point, &req->request);
-	spin_lock(&musb->Lock);
 	ep->busy = 0;
+	spin_lock(&musb->Lock);
 }
 
 /* ----------------------------------------------------------------------- */
@@ -146,12 +143,12 @@ __acquires(ep->musb->Lock)
  */
 static void nuke(struct musb_ep *ep, const int status)
 {
-	struct musb_request	*req = NULL;
+	struct musb_request *req = NULL;
 
 	ep->busy = 1;
 
 	if (is_dma_capable() && ep->dma) {
-		struct dma_controller	*c = ep->pThis->pDmaController;
+		struct dma_controller *c = ep->pThis->pDmaController;
 		int value;
 
 		value = c->pfDmaAbortChannel(ep->dma);
@@ -162,10 +159,11 @@ static void nuke(struct musb_ep *ep, con
 
 	while (!list_empty(&(ep->req_list))) {
 		req = container_of(ep->req_list.next, struct musb_request,
-				request.list);
+				   request.list);
 		musb_g_giveback(ep, &req->request, status);
 		ep->busy = 1;
 	}
+	ep->busy = 0;
 }
 
 /**************************************************************************
@@ -179,7 +177,7 @@ static void nuke(struct musb_ep *ep, con
 
 static inline int max_ep_writesize(struct musb *pThis, struct musb_ep *ep)
 {
-#ifdef	C_MP_TX
+#ifdef  C_MP_TX
 	if ((USB_ENDPOINT_XFER_BULK == ep->type) && pThis->bBulkSplit)
 		return pThis->aLocalEnd[bEnd].wMaxPacketSizeTx;
 	else
@@ -196,12 +194,12 @@ static inline int max_ep_writesize(struc
  */
 static void txstate(struct musb *pThis, struct musb_request *req)
 {
-	u8			bEnd;
-	struct musb_ep		*pEnd;
-	struct usb_request	*pRequest;
-	void __iomem		*pBase = pThis->pRegs;
-	u16			wFifoCount = 0, wCsrVal;
-	int			use_dma = 0;
+	u8 bEnd;
+	struct musb_ep *pEnd;
+	struct usb_request *pRequest;
+	void __iomem *pBase = pThis->pRegs;
+	u16 wFifoCount = 0, wCsrVal;
+	int use_dma = 0;
 
 	bEnd = req->bEnd;
 	pEnd = req->ep;
@@ -221,13 +219,12 @@ static void txstate(struct musb *pThis, 
 
 	if (wCsrVal & MGC_M_TXCSR_TXPKTRDY) {
 		DBG(5, "%s old packet still ready , txcsr %03x\n",
-				pEnd->end_point.name, wCsrVal);
+		    pEnd->end_point.name, wCsrVal);
 		return;
 	}
 
 	DBG(4, "hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x\n",
-			bEnd, pEnd->wPacketSize, wFifoCount,
-			wCsrVal);
+	    bEnd, pEnd->wPacketSize, wFifoCount, wCsrVal);
 
 	/* stalled?? */
 	if (wCsrVal & MGC_M_TXCSR_P_SENTSTALL) {
@@ -238,8 +235,8 @@ static void txstate(struct musb *pThis, 
 	/* update the endpoint busy/free status */
 	pEnd->busy = 1;
 
-	if (is_dma_capable() && pEnd->dma) {
-		struct dma_controller	*c;
+	if (req->dma) {
+		struct dma_controller *c;
 
 		c = pThis->pDmaController;
 		use_dma = (pRequest->dma != DMA_ADDR_INVALID);
@@ -249,63 +246,63 @@ static void txstate(struct musb *pThis, 
 #ifdef CONFIG_USB_INVENTRA_DMA
 		/* setup DMA, then program endpoint CSR */
 		dma->dwActualLength = 0L;
-		pEnd->dwRequestSize = min(pRequest->length,
-					  dma->dwMaxLength);
-		use_dma = use_dma && c->pfDmaProgramChannel(
-				pEnd->dma, pEnd->wPacketSize,
-				pDmaChannel->bDesiredMode,
-				pRequest->dma, pEnd->dwRequestSize);
+		pEnd->dwRequestSize = min(pRequest->length, dma->dwMaxLength);
+		use_dma = use_dma
+		    && c->pfDmaProgramChannel(pEnd->dma, pEnd->wPacketSize,
+					      pDmaChannel->bDesiredMode,
+					      pRequest->dma,
+					      pEnd->dwRequestSize);
 		if (use_dma) {
-			wCsrVal |= MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAENAB
-				| (pDmaChannel->bDesiredMode
-				    ? MGC_M_TXCSR_DMAMODE : 0);
+			wCsrVal |= MGC_M_TXCSR_AUTOSET | MGC_M_TXCSR_DMAENAB
+			    | (pDmaChannel->bDesiredMode
+			       ? MGC_M_TXCSR_DMAMODE : 0);
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, wCsrVal);
 		}
-
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
-		/* program endpoint CSR first, then setup DMA */
-		wCsrVal &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_TXPKTRDY);
-		wCsrVal |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_DMAENAB;
-		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
-				MGC_M_TXCSR_P_WZC_BITS | wCsrVal);
 
 // REVISIT host side sets DMAENAB later than this ...
 
 		/* prefer 'rndis' mode whenever the last
 		 * tx packet will be short
 		 */
-		use_dma = use_dma && c->pfDmaProgramChannel(
-				pEnd->dma, pEnd->wPacketSize,
-				pRequest->zero,
-				pRequest->dma,
-				pRequest->length);
+		use_dma = use_dma
+		    && c->pfDmaProgramChannel(pEnd->dma, pEnd->wPacketSize,
+					      pRequest->zero, pRequest->dma,
+					      pRequest->length);
 		if (!use_dma) {
 			c->pfDmaReleaseChannel(pEnd->dma);
 			pEnd->dma = NULL;
 			wCsrVal &= ~(MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_MODE);
 			/* invariant: prequest->buf is non-null */
+		} else {
+			wCsrVal &= ~(MGC_M_TXCSR_AUTOSET
+				     | MGC_M_TXCSR_DMAMODE
+				     | MGC_M_TXCSR_TXPKTRDY);
+			wCsrVal |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_DMAENAB |
+			    MGC_M_TXCSR_DMAMODE;
+			MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
+				       MGC_M_TXCSR_P_WZC_BITS | wCsrVal);
 		}
 #endif
 	}
 
 	if (!use_dma) {
-		musb_write_fifo(pEnd->hw_ep, wFifoCount,
-				 (u8 *) (pRequest->buf + pRequest->actual));
-		pRequest->actual += wFifoCount;
-		wCsrVal |= MGC_M_TXCSR_TXPKTRDY;
+		if (pRequest->length != 0) {
+			musb_write_fifo(pEnd->hw_ep, wFifoCount,
+					(u8 *) (pRequest->buf +
+						pRequest->actual));
+			pRequest->actual += wFifoCount;
+		}
+		wCsrVal |= (MGC_M_TXCSR_TXPKTRDY | MGC_M_TXCSR_MODE);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, wCsrVal);
 	}
 
 	/* host may already have the data when this message shows... */
 	DBG(3, "%s TX/IN %s len %d/%d, txcsr %04x, fifo %d/%d\n",
-			pEnd->end_point.name, use_dma ? "dma" : "pio",
-			pRequest->actual, pRequest->length,
-			MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd),
-			wFifoCount,
-			MGC_ReadCsr16(pBase, MGC_O_HDRC_TXMAXP, bEnd));
+	    pEnd->end_point.name, use_dma ? "dma" : "pio",
+	    pRequest->actual, pRequest->length,
+	    MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd),
+	    wFifoCount, MGC_ReadCsr16(pBase, MGC_O_HDRC_TXMAXP, bEnd));
 }
 
 /*
@@ -314,11 +311,11 @@ static void txstate(struct musb *pThis, 
  */
 void musb_g_tx(struct musb *pThis, u8 bEnd, u8 is_ep_intr)
 {
-	u16			wCsrVal;
-	struct usb_request	*pRequest;
-	u8 __iomem		*pBase = pThis->pRegs;
-	struct musb_ep		*pEnd;
-	struct dma_channel	*dma;
+	u16 wCsrVal;
+	struct usb_request *pRequest;
+	u8 __iomem *pBase = pThis->pRegs;
+	struct musb_ep *pEnd;
+	struct dma_channel *dma;
 
 	MGC_SelectEnd(pBase, bEnd);
 	pEnd = &pThis->aLocalEnd[bEnd].ep_in;
@@ -327,7 +324,7 @@ void musb_g_tx(struct musb *pThis, u8 bE
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 	DBG(4, "<== %s, txcsr %04x\n", pEnd->end_point.name, wCsrVal);
 
-	dma = is_dma_capable() ? pEnd->dma : NULL;
+	dma = is_dma_capable()? pEnd->dma : NULL;
 	do {
 		/* REVISIT for high bandwidth, MGC_M_TXCSR_P_INCOMPTX
 		 * probably rates reporting as a host error
@@ -340,16 +337,17 @@ void musb_g_tx(struct musb *pThis, u8 bE
 				pThis->pDmaController->pfDmaAbortChannel(dma);
 			}
 
-			if (pRequest)
+			if ((pRequest) && (pEnd->busy)) {
 				musb_g_giveback(pEnd, pRequest, -EPIPE);
 
+			}
 			break;
 		}
 
 		if (wCsrVal & MGC_M_TXCSR_P_UNDERRUN) {
 			/* we NAKed, no big deal ... little reason to care */
 			wCsrVal &= ~(MGC_M_TXCSR_P_UNDERRUN
-					| MGC_M_TXCSR_TXPKTRDY);
+				     | MGC_M_TXCSR_TXPKTRDY);
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, wCsrVal);
 			DBG(7, "underrun on ep%d, req %p\n", bEnd, pRequest);
 		}
@@ -361,45 +359,70 @@ void musb_g_tx(struct musb *pThis, u8 bE
 		}
 
 		if (pRequest) {
-			u8	is_dma = 0;
+			u8 is_dma = 0;
 
-			if (dma && (wCsrVal & MGC_M_TXCSR_DMAENAB)) {
+			if (dma && to_musb_request(pRequest)->dma &&
+			    !is_ep_intr) {
 				is_dma = 1;
-				wCsrVal &= ~(MGC_M_TXCSR_DMAENAB
-						| MGC_M_TXCSR_TXPKTRDY);
-				MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
-					MGC_M_TXCSR_P_WZC_BITS | wCsrVal);
-				DBG(4, "TXCSR%d %04x, dma off, %04x, "
-						"len %Zd, req %p\n",
-					bEnd, wCsrVal,
-					MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR,
-						bEnd),
-					pEnd->dma->dwActualLength,
-					pRequest);
+				if (wCsrVal & MGC_M_TXCSR_DMAENAB) {
+					wCsrVal &= ~(MGC_M_TXCSR_DMAENAB
+						     | MGC_M_TXCSR_TXPKTRDY);
+					MGC_WriteCsr16(pBase,
+						       MGC_O_HDRC_TXCSR, bEnd,
+						       MGC_M_TXCSR_P_WZC_BITS |
+						       wCsrVal);
+				}
+
+				DBG(4,
+				    "TXCSR%d %04x, dma off, %04x, "
+				    "len %Zd, req %p\n", bEnd, wCsrVal,
+				    MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR,
+						  bEnd),
+				    pEnd->dma->dwActualLength, pRequest);
 				pRequest->actual += pEnd->dma->dwActualLength;
+				wCsrVal = MGC_ReadCsr16(pBase,
+							MGC_O_HDRC_TXCSR, bEnd);
+				/*if (wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY)
+				   break; */
 			}
 
 			if (is_dma || pRequest->actual == pRequest->length) {
-
 				/* first, maybe a terminating short packet */
-				if (pRequest->zero
-						&& pRequest->length
-						&& (pRequest->length
-							% pEnd->wPacketSize)
-							== 0) {
-					const u16 wCsrVal = MGC_M_TXCSR_MODE
-							| MGC_M_TXCSR_TXPKTRDY;
-
-					/* REVISIT cppi dma would do this for
-					 * us. for pio, don't loop...
-					 */
-					DBG(3, "sending zero pkt\n");
+				if (pRequest->zero && pRequest->length
+				    && (pRequest->length % pEnd->wPacketSize)
+				    == 0) {
+					u16 count = 300;
+
+					/* Ensure that FIFO is Empty here */
+					while (count--) {
+						wCsrVal = MGC_ReadCsr16(pBase,
+									MGC_O_HDRC_TXCSR,
+									bEnd);
+						if ((wCsrVal &
+						     MGC_M_TXCSR_FIFONOTEMPTY)
+						    == 0)
+							break;
+					}
 
-					MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR,
-						       bEnd, wCsrVal);
-					break;
+					wCsrVal |=
+					    (MGC_M_TXCSR_MODE |
+					     MGC_M_TXCSR_TXPKTRDY);
+
+					if (pRequest->zero != 2) {
+						/* REVISIT cppi dma would do this for
+						 * us. for pio, don't loop...
+						 */
+						DBG(3, "sending zero pkt\n");
+
+						MGC_WriteCsr16(pBase,
+							       MGC_O_HDRC_TXCSR,
+							       bEnd, wCsrVal);
+						pRequest->zero++;
+						return;
+					} else {
+						pRequest->zero = 1;
+					}
 				}
-
 				/* kickstart next transfer if appropriate;
 				 * the packet that just completed might not
 				 * be transmitted for hours or days.
@@ -408,16 +431,14 @@ void musb_g_tx(struct musb *pThis, u8 bE
 				 */
 				MGC_SelectEnd(pBase, bEnd);
 				wCsrVal = MGC_ReadCsr16(pBase,
-						MGC_O_HDRC_TXCSR, bEnd);
-				if (is_ep_intr
-				    || ((wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY) ==
-					0))
+							MGC_O_HDRC_TXCSR, bEnd);
+				if (is_ep_intr ||
+				    ((wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY) == 0))
 					musb_g_giveback(pEnd, pRequest, 0);
 				else
 					break;
-				pRequest = pEnd->desc
-						? next_request(pEnd)
-						: NULL;
+				pRequest = pEnd->desc ? next_request(pEnd)
+				    : NULL;
 				if (!pRequest) {
 					DBG(4, "bEnd=0x%x idle now\n", bEnd);
 					break;
@@ -437,23 +458,23 @@ void musb_g_tx(struct musb *pThis, u8 bE
  */
 static void rxstate(struct musb *pThis, struct musb_request *req)
 {
-	u16			wCsrVal = 0;
-	const u8		bEnd = req->bEnd;
-	struct usb_request	*pRequest = &req->request;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_ep		*pEnd = &pThis->aLocalEnd[bEnd].ep_out;
-	u16			wFifoCount = 0;
-	u16			wCount = pEnd->wPacketSize;
+	u16 wCsrVal = 0;
+	const u8 bEnd = req->bEnd;
+	struct usb_request *pRequest = &req->request;
+	void __iomem *pBase = pThis->pRegs;
+	struct musb_ep *pEnd = &pThis->aLocalEnd[bEnd].ep_out;
+	u16 wFifoCount = 0;
+	u16 wCount = pEnd->wPacketSize;
 
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd);
 
 	/* update the endpoint busy/free status */
 	pEnd->busy = 1;
 
-#ifdef	CONFIG_USB_TI_CPPI_DMA
-	if (is_dma_capable() && pEnd->dma) {
-		struct dma_controller	*c = pThis->pDmaController;
-		struct dma_channel	*channel = pEnd->dma;
+#ifdef  CONFIG_USB_TI_CPPI_DMA
+	if (req->dma) {
+		struct dma_controller *c = pThis->pDmaController;
+		struct dma_channel *channel = pEnd->dma;
 
 		/* NOTE:  CPPI won't actually stop advancing the DMA
 		 * queue after short packet transfers, so this is almost
@@ -461,16 +482,18 @@ static void rxstate(struct musb *pThis, 
 		 * faults will be handled correctly.
 		 */
 		if (c->pfDmaProgramChannel(channel,
-				pEnd->wPacketSize,
-				!pRequest->short_not_ok,
-				pRequest->dma + pRequest->actual,
-				pRequest->length - pRequest->actual)) {
+					   pEnd->wPacketSize,
+					   !pRequest->short_not_ok,
+					   pRequest->dma + pRequest->actual,
+					   pRequest->length -
+					   pRequest->actual)) {
 
 			/* make sure that if an rxpkt arrived after the irq,
 			 * the cppi engine will be ready to take it as soon
 			 * as DMA is enabled
 			 */
-			wCsrVal &= ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);
+			wCsrVal &=
+			    ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);
 			wCsrVal |= MGC_M_RXCSR_DMAENAB | MGC_M_RXCSR_P_WZC_BITS;
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wCsrVal);
 			return;
@@ -483,9 +506,9 @@ static void rxstate(struct musb *pThis, 
 		if (pRequest->actual < pRequest->length) {
 #ifdef CONFIG_USB_INVENTRA_DMA
 			if (is_dma_capable() && pEnd->dma) {
-				struct dma_controller	*c;
-				struct dma_channel	*channel;
-				int			use_dma = 0;
+				struct dma_controller *c;
+				struct dma_channel *channel;
+				int use_dma = 0;
 
 				c = pThis->pDmaController;
 				channel = pEnd->dma;
@@ -494,15 +517,12 @@ static void rxstate(struct musb *pThis, 
 				case MGC_DMA_STATUS_FREE:
 					pRequest->actual =
 					    channel->dwActualLength;
-					if (pRequest->actual
-							< pRequest->length) {
+					if (pRequest->actual < pRequest->length) {
 						channel->dwActualLength = 0L;
 						pEnd->dwRequestSize =
 						    min(pRequest->length,
-							channel->
-							dwMaxLength);
-						use_dma =
-						    c->pfDmaProgramChannel
+							channel->dwMaxLength);
+						use_dma = c->pfDmaProgramChannel
 						    (channel,
 						     pEnd->wPacketSize,
 						     channel->bDesiredMode,
@@ -519,8 +539,8 @@ static void rxstate(struct musb *pThis, 
 				}
 				if (use_dma && !pRequest->actual) {
 					wCsrVal |= MGC_M_RXCSR_AUTOCLEAR
-						| MGC_M_RXCSR_DMAENAB
-						| MGC_M_RXCSR_P_WZC_BITS;
+					    | MGC_M_RXCSR_DMAENAB
+					    | MGC_M_RXCSR_P_WZC_BITS;
 
 					/* this special sequence is required to
 					 * get DMAReq to activate
@@ -539,14 +559,13 @@ static void rxstate(struct musb *pThis, 
 
 			wFifoCount = pRequest->length - pRequest->actual;
 			DBG(3, "%s OUT/RX pio fifo %d/%d, maxpacket %d\n",
-					pEnd->end_point.name,
-					wCount, wFifoCount,
-					pEnd->wPacketSize);
+			    pEnd->end_point.name,
+			    wCount, wFifoCount, pEnd->wPacketSize);
 
 			wFifoCount = min(wCount, wFifoCount);
 			musb_read_fifo(pEnd->hw_ep, wFifoCount,
-				   (u8 *) (pRequest->buf +
-					   pRequest->actual));
+				       (u8 *) (pRequest->buf +
+					       pRequest->actual));
 			pRequest->actual += wFifoCount;
 
 			/* REVISIT if we left anything in the fifo, flush
@@ -572,26 +591,29 @@ static void rxstate(struct musb *pThis, 
  */
 void musb_g_rx(struct musb *pThis, u8 bEnd)
 {
-	u16			wCsrVal;
-	struct usb_request	*pRequest;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_ep		*pEnd;
-	struct dma_channel	*dma;
+	u16 wCsrVal;
+	struct usb_request *pRequest;
+	void __iomem *pBase = pThis->pRegs;
+	struct musb_ep *pEnd;
+	struct dma_channel *dma;
 
 	MGC_SelectEnd(pBase, bEnd);
 
 	pEnd = &pThis->aLocalEnd[bEnd].ep_out;
 	pRequest = next_request(pEnd);
+	if (pRequest == NULL) {
+		return;
+	}
 
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd);
 	DBG(4, "<== %s, rxcsr %04x\n", pEnd->end_point.name, wCsrVal);
 
-	dma = is_dma_capable() ? pEnd->dma : NULL;
+	dma = is_dma_capable()? pEnd->dma : NULL;
 
 	if (wCsrVal & MGC_M_RXCSR_P_SENTSTALL) {
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->pfDmaAbortChannel(dma);
+			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 			pRequest->actual += pEnd->dma->dwActualLength;
 		}
 
@@ -599,7 +621,7 @@ void musb_g_rx(struct musb *pThis, u8 bE
 		wCsrVal &= ~MGC_M_RXCSR_P_SENTSTALL;
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wCsrVal);
 
-		if (pRequest)
+		if ((pRequest) && (pEnd->busy))
 			musb_g_giveback(pEnd, pRequest, -EPIPE);
 		goto done;
 	}
@@ -624,15 +646,17 @@ void musb_g_rx(struct musb *pThis, u8 bE
 		goto done;
 	}
 
-	if (dma && (wCsrVal & MGC_M_RXCSR_DMAENAB)) {
-		wCsrVal &= ~MGC_M_RXCSR_DMAENAB;
-		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-			MGC_M_RXCSR_P_WZC_BITS | wCsrVal);
+	if (dma && to_musb_request(pRequest)->dma) {
+		if (wCsrVal & MGC_M_RXCSR_DMAENAB) {
+			wCsrVal &= ~MGC_M_RXCSR_DMAENAB;
+			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
+				       MGC_M_RXCSR_P_WZC_BITS | wCsrVal);
+		}
 
 		DBG(4, "RXCSR%d %04x, dma off, %04x, len %Zd, req %p\n",
-			bEnd, wCsrVal,
-			MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd),
-			pEnd->dma->dwActualLength, pRequest);
+		    bEnd, wCsrVal,
+		    MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd),
+		    pEnd->dma->dwActualLength, pRequest);
 		pRequest->actual += pEnd->dma->dwActualLength;
 		musb_g_giveback(pEnd, pRequest, 0);
 
@@ -647,32 +671,30 @@ void musb_g_rx(struct musb *pThis, u8 bE
 			goto done;
 	}
 
-
 	/* analyze request if the ep is hot */
 	if (pRequest)
 		rxstate(pThis, to_musb_request(pRequest));
 	else
 		DBG(3, "Rx: bytes waiting on %sep=0x%x\n",
-				pEnd->desc ? "" : "inactive ",
-				bEnd);
+		    pEnd->desc ? "" : "inactive ", bEnd);
 
-done:
+      done:
 	return;
 }
 
 /* ------------------------------------------------------------ */
 
 static int musb_gadget_enable(struct usb_ep *ep,
-			       const struct usb_endpoint_descriptor *desc)
+			      const struct usb_endpoint_descriptor *desc)
 {
 	unsigned long flags;
-	struct musb_ep	*pEnd;
-	struct musb	*pThis;
-	void __iomem	*pBase;
-	u8		bEnd;
-	u16		csr;
-	unsigned	tmp;
-	int		status = -EINVAL;
+	struct musb_ep *pEnd;
+	struct musb *pThis;
+	void __iomem *pBase;
+	u8 bEnd;
+	u16 csr;
+	unsigned tmp;
+	int status = -EINVAL;
 
 	if (!ep || !desc)
 		return -EINVAL;
@@ -716,21 +738,17 @@ static int musb_gadget_enable(struct usb
 
 		wIntrTxE |= (1 << bEnd);
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
-
+		csr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 		/* REVISIT if pThis->bBulkSplit, use by updating "tmp";
 		 * likewise high bandwidth periodic tx
 		 */
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXMAXP, bEnd, tmp);
-
-		csr = MGC_M_TXCSR_MODE | MGC_M_TXCSR_CLRDATATOG
-				| MGC_M_TXCSR_FLUSHFIFO;
 		if (pEnd->type == USB_ENDPOINT_XFER_ISOC)
 			csr |= MGC_M_TXCSR_ISO;
 
 		/* set twice in case of double buffering */
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, csr);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, csr);
-
 	} else {
 		u16 wIntrRxE = musb_readw(pBase, MGC_O_HDRC_INTRRXE);
 
@@ -756,7 +774,7 @@ static int musb_gadget_enable(struct usb
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, csr);
 		}
 
-		csr = MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_CLRDATATOG;
+		csr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 		if (pEnd->type == USB_ENDPOINT_XFER_ISOC)
 			csr |= MGC_M_RXCSR_P_ISO;
 		else if (pEnd->type == USB_ENDPOINT_XFER_INT)
@@ -771,15 +789,20 @@ static int musb_gadget_enable(struct usb
 	 * for some reason you run out of channels here.
 	 */
 	if (is_dma_capable() && pThis->pDmaController) {
-		struct dma_controller	*c = pThis->pDmaController;
+		struct dma_controller *c = pThis->pDmaController;
 
-#ifdef	DISABLE_RXDMA
-if (desc->bEndpointAddress & USB_DIR_IN) pEnd->dma = NULL; else
+#ifdef  DISABLE_RXDMA
+		if (desc->bEndpointAddress & USB_DIR_IN)
+			pEnd->dma = NULL;
+		else
 #endif
-		pEnd->dma = c->pfDmaAllocateChannel(
-				c->pPrivateData,
-				bEnd, (desc->bEndpointAddress & USB_DIR_IN),
-				pEnd->type, pEnd->wPacketSize);
+			pEnd->dma = c->pfDmaAllocateChannel(c->pPrivateData,
+							    bEnd,
+							    (desc->
+							     bEndpointAddress &
+							     USB_DIR_IN),
+							    pEnd->type,
+							    pEnd->wPacketSize);
 	} else
 		pEnd->dma = NULL;
 
@@ -788,17 +811,19 @@ if (desc->bEndpointAddress & USB_DIR_IN)
 	status = 0;
 
 	pr_debug("%s periph: enabled %s for %s %s, %smaxpacket %d\n",
-			musb_driver_name, pEnd->end_point.name,
-			({ char *s; switch (pEnd->type) {
-			 case USB_ENDPOINT_XFER_BULK:	s = "bulk"; break;
-			 case USB_ENDPOINT_XFER_INT:	s = "int"; break;
-			 default:			s = "iso"; break;
-			 }; s; }),
-			 pEnd->is_in ? "IN" : "OUT",
-			 pEnd->dma ? "dma, " : "",
-			 pEnd->wPacketSize);
+		 musb_driver_name, pEnd->end_point.name, ( {
+							  char *s;
+							  switch (pEnd->type) {
+case USB_ENDPOINT_XFER_BULK:
+s = "bulk"; break; case USB_ENDPOINT_XFER_INT:
+s = "int"; break; default:
+							  s = "iso"; break;};
+							  s;}
+		 ),
+		 pEnd->is_in ? "IN" : "OUT",
+		 pEnd->dma ? "dma, " : "", pEnd->wPacketSize) ;
 
-fail:
+      fail:
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 	return status;
 }
@@ -808,11 +833,12 @@ fail:
  */
 static int musb_gadget_disable(struct usb_ep *ep)
 {
-	unsigned long	flags;
-	struct musb	*pThis;
-	u8		bEnd;
-	struct musb_ep	*pEnd;
-	int		status = 0;
+	unsigned long flags;
+	struct musb *pThis;
+	u8 bEnd;
+	struct musb_ep *pEnd;
+	int status = 0;
+	u16 wCsr;
 
 	pEnd = to_musb_ep(ep);
 	pThis = pEnd->pThis;
@@ -827,17 +853,27 @@ static int musb_gadget_disable(struct us
 		wIntrTxE &= ~(1 << bEnd);
 		musb_writew(pThis->pRegs, MGC_O_HDRC_INTRTXE, wIntrTxE);
 		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_TXMAXP, bEnd, 0);
+		wCsr = MGC_ReadCsr16(pThis->pRegs, MGC_O_HDRC_TXCSR, bEnd);
+		wCsr |= MGC_M_TXCSR_CLRDATATOG;
+		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_TXCSR, bEnd, wCsr);
+		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_TXCSR, bEnd, wCsr);
 	} else {
 		u16 wIntrRxE = musb_readw(pThis->pRegs, MGC_O_HDRC_INTRRXE);
 		wIntrRxE &= ~(1 << bEnd);
 		musb_writew(pThis->pRegs, MGC_O_HDRC_INTRRXE, wIntrRxE);
 		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_RXMAXP, bEnd, 0);
+		wCsr = MGC_ReadCsr16(pThis->pRegs, MGC_O_HDRC_RXCSR, bEnd);
+		wCsr |= MGC_M_RXCSR_CLRDATATOG;
+		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_RXCSR, bEnd, wCsr);
+		MGC_WriteCsr16(pThis->pRegs, MGC_O_HDRC_RXCSR, bEnd, wCsr);
 	}
 
 	pEnd->desc = NULL;
+	pEnd->fifo_flush_check = 0;
 
 	/* abort all pending DMA and requests */
 	nuke(pEnd, -ESHUTDOWN);
+	musb_gadget_fifo_flush(ep);
 
 	spin_unlock_irqrestore(&(pThis->Lock), flags);
 
@@ -852,8 +888,8 @@ static int musb_gadget_disable(struct us
  */
 struct usb_request *musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)
 {
-	struct musb_ep		*musb_ep = to_musb_ep(ep);
-	struct musb_request	*pRequest = NULL;
+	struct musb_ep *musb_ep = to_musb_ep(ep);
+	struct musb_request *pRequest = NULL;
 
 	pRequest = kzalloc(sizeof *pRequest, gfp_flags);
 	if (pRequest) {
@@ -879,7 +915,7 @@ void musb_free_request(struct usb_ep *ep
  * dma-coherent memory allocation (for dma-capable endpoints)
  */
 static void *musb_gadget_alloc_buffer(struct usb_ep *ep, unsigned bytes,
-			    dma_addr_t * dma, gfp_t gfp_flags)
+				      dma_addr_t * dma, gfp_t gfp_flags)
 {
 	struct musb_ep *musb_ep = to_musb_ep(ep);
 
@@ -887,7 +923,8 @@ static void *musb_gadget_alloc_buffer(st
 }
 
 static void musb_gadget_free_buffer(struct usb_ep *ep,
-		void *address, dma_addr_t dma, unsigned bytes)
+				    void *address, dma_addr_t dma,
+				    unsigned bytes)
 {
 	struct musb_ep *musb_ep = to_musb_ep(ep);
 
@@ -900,8 +937,7 @@ static void musb_gadget_free_buffer(stru
 static void musb_ep_restart(struct musb *pThis, struct musb_request *req)
 {
 	DBG(3, "<== %s request %p on hw_ep%d\n",
-		req->bTx ? "TX/IN" : "RX/OUT",
-		&req->request, req->bEnd);
+	    req->bTx ? "TX/IN" : "RX/OUT", &req->request, req->bEnd);
 
 	MGC_SelectEnd(pThis->pRegs, req->bEnd);
 	if (req->bTx) {
@@ -912,13 +948,15 @@ static void musb_ep_restart(struct musb 
 }
 
 static int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,
-			   gfp_t gfp_flags)
+			     gfp_t gfp_flags)
 {
-	struct musb_ep		*pEnd;
-	struct musb_request	*pRequest;
-	struct musb		*pThis;
-	int			status = 0;
-	unsigned long		lockflags;
+	struct musb_ep *pEnd;
+	struct musb_request *pRequest;
+	struct musb *pThis;
+	int status = 0;
+	unsigned long lockflags;
+	u16 csr;
+	u8 stall = 0;
 
 	if (!ep || !req)
 		return -EINVAL;
@@ -939,18 +977,22 @@ static int musb_gadget_queue(struct usb_
 	pRequest->request.status = -EINPROGRESS;
 	pRequest->bEnd = pEnd->bEndNumber;
 	pRequest->bTx = pEnd->is_in;
+	pRequest->dma = 0;
+
+	if (is_dma_capable() && pEnd->dma
+	    && pRequest->request.length >= MIN_DMA_REQUEST) {
+		if (pRequest->request.dma == DMA_ADDR_INVALID) {
+			pRequest->request.dma =
+			    dma_map_single(pThis->controller,
+					   pRequest->request.buf,
+					   pRequest->request.length,
+					   pRequest->bTx
+					   ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+			pRequest->mapped = 1;
+		} else
+			pRequest->mapped = 0;
 
-	if (is_dma_capable()
-			&& pRequest->request.dma == DMA_ADDR_INVALID
-			&& pRequest->request.length >= MIN_DMA_REQUEST
-			&& pEnd->dma) {
-		pRequest->request.dma = dma_map_single(pThis->controller,
-				pRequest->request.buf,
-				pRequest->request.length,
-				pRequest->bTx
-					? DMA_TO_DEVICE
-					: DMA_FROM_DEVICE);
-		pRequest->mapped = 1;
+		pRequest->dma = 1;
 	} else if (!req->buf) {
 		return -ENODATA;
 	} else
@@ -961,7 +1003,7 @@ static int musb_gadget_queue(struct usb_
 	/* don't queue if the ep is down */
 	if (!pEnd->desc) {
 		DBG(4, "req %p queued to %s while ep %s\n",
-				req, ep->name, "disabled");
+		    req, ep->name, "disabled");
 		status = -ESHUTDOWN;
 		goto cleanup;
 	}
@@ -970,20 +1012,35 @@ static int musb_gadget_queue(struct usb_
 	list_add_tail(&(pRequest->request.list), &(pEnd->req_list));
 
 	/* it this is the head of the queue, start i/o ... */
-	if (!pEnd->busy && &pRequest->request.list == pEnd->req_list.next)
-		musb_ep_restart(pThis, pRequest);
+	if (!pEnd->busy && &pRequest->request.list == pEnd->req_list.next) {
+		if (pEnd->is_in) {
+			csr = MGC_ReadCsr16(pThis->pRegs,
+					    MGC_O_HDRC_TXCSR, pEnd->bEndNumber);
+			stall = csr & MGC_M_TXCSR_P_SENDSTALL ? 1 : 0;
+		} else {
+			csr = MGC_ReadCsr16(pThis->pRegs,
+					    MGC_O_HDRC_RXCSR, pEnd->bEndNumber);
+			stall = csr & MGC_M_RXCSR_P_SENDSTALL ? 1 : 0;
+		}
 
-cleanup:
+		/* Endpoint Stalled do not start a new request until the STALL
+		 * is cleared
+		 */
+		if (!stall)
+			musb_ep_restart(pThis, pRequest);
+	}
+
+      cleanup:
 	spin_unlock_irqrestore(&pThis->Lock, lockflags);
 	return status;
 }
 
 static int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *pRequest)
 {
-	struct musb_ep		*pEnd = to_musb_ep(ep);
-	struct usb_request	*r;
-	unsigned long		flags;
-	int			status = 0;
+	struct musb_ep *pEnd = to_musb_ep(ep);
+	struct usb_request *r;
+	unsigned long flags;
+	int status = 0;
 
 	if (!ep || !pRequest || to_musb_request(pRequest)->ep != pEnd)
 		return -EINVAL;
@@ -1001,28 +1058,31 @@ static int musb_gadget_dequeue(struct us
 	}
 
 	/* if the hardware doesn't have the request, easy ... */
-	if (pEnd->req_list.next != &pRequest->list || pEnd->busy)
+	if (pEnd->req_list.next != &pRequest->list)
 		musb_g_giveback(pEnd, pRequest, -ECONNRESET);
 
 	/* ... else abort the dma transfer ... */
-	else if (is_dma_capable() && pEnd->dma) {
-		struct dma_controller	*c = pEnd->pThis->pDmaController;
+	else if (is_dma_capable() && pEnd->dma
+		 && to_musb_request(pRequest)->dma) {
+		struct dma_controller *c = pEnd->pThis->pDmaController;
 
 		MGC_SelectEnd(pEnd->pThis->pRegs, pEnd->bEndNumber);
 		if (c->pfDmaAbortChannel)
 			status = c->pfDmaAbortChannel(pEnd->dma);
 		else
 			status = -EBUSY;
+		pEnd->fifo_flush_check = 0;
 		if (status == 0)
 			musb_g_giveback(pEnd, pRequest, -ECONNRESET);
 	} else {
 		/* NOTE: by sticking to easily tested hardware/driver states,
 		 * we leave counting of in-flight packets imprecise.
 		 */
+		pEnd->fifo_flush_check = 0;
 		musb_g_giveback(pEnd, pRequest, -ECONNRESET);
 	}
 
-done:
+      done:
 	spin_unlock_irqrestore(&pEnd->pThis->Lock, flags);
 	return status;
 }
@@ -1035,14 +1095,14 @@ done:
  */
 int musb_gadget_set_halt(struct usb_ep *ep, int value)
 {
-	struct musb_ep		*pEnd;
-	u8			bEnd;
-	struct musb		*pThis;
-	void __iomem		*pBase;
-	unsigned long		flags;
-	u16			wCsr;
-	struct musb_request	*pRequest = NULL;
-	int			status = 0;
+	struct musb_ep *pEnd;
+	u8 bEnd;
+	struct musb *pThis;
+	void __iomem *pBase;
+	unsigned long flags;
+	u16 wCsr;
+	struct musb_request *pRequest = NULL;
+	int status = 0;
 
 	if (!ep)
 		return -EINVAL;
@@ -1063,6 +1123,7 @@ int musb_gadget_set_halt(struct usb_ep *
 
 	/* cannot portably stall with non-empty FIFO */
 	pRequest = to_musb_request(next_request(pEnd));
+#if 0
 	if (value && pEnd->is_in) {
 		wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY) {
@@ -1070,9 +1131,8 @@ int musb_gadget_set_halt(struct usb_ep *
 			spin_unlock_irqrestore(&pThis->Lock, flags);
 			return -EAGAIN;
 		}
-
 	}
-
+#endif
 	/* set/clear the stall bit */
 	DBG(2, "%s: %s stall\n", ep->name, value ? "set" : "clear");
 	if (pEnd->is_in) {
@@ -1080,7 +1140,9 @@ int musb_gadget_set_halt(struct usb_ep *
 		if (value) {
 			wCsr |= MGC_M_TXCSR_P_SENDSTALL;
 		} else {
-			wCsr &= ~(MGC_M_TXCSR_P_SENDSTALL);// | MGC_M_TXCSR_P_SENTSTALL); /* 10OCT06, PRP Debug */
+			wCsr &=
+			    ~(MGC_M_TXCSR_P_SENDSTALL | MGC_M_TXCSR_P_UNDERRUN);
+			wCsr |= MGC_M_TXCSR_CLRDATATOG;
 		}
 		wCsr &= ~MGC_M_TXCSR_TXPKTRDY;
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, wCsr);
@@ -1089,13 +1151,14 @@ int musb_gadget_set_halt(struct usb_ep *
 		if (value) {
 			wCsr |= MGC_M_RXCSR_P_SENDSTALL;
 		} else {
-			wCsr &= ~(MGC_M_RXCSR_P_SENDSTALL);// | MGC_M_TXCSR_P_SENTSTALL); /* 10OCT06, PRP Debug */
+			wCsr &= ~MGC_M_RXCSR_P_SENDSTALL;
+			wCsr |= MGC_M_RXCSR_CLRDATATOG;
 		}
 
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wCsr);
 	}
 
-done:
+      done:
 
 	/* maybe start the first request in the queue */
 	if (!pEnd->busy && !value && pRequest) {
@@ -1109,14 +1172,14 @@ done:
 
 static int musb_gadget_fifo_status(struct usb_ep *ep)
 {
-	struct musb_ep		*musb_ep = to_musb_ep(ep);
-	int			retval = -EINVAL;
+	struct musb_ep *musb_ep = to_musb_ep(ep);
+	int retval = -EINVAL;
 
 	if (musb_ep->desc && !musb_ep->is_in) {
-		struct musb		*musb = musb_ep->pThis;
-		int			bEnd = musb_ep->bEndNumber;
-		void __iomem		*mbase = musb->pRegs;
-		unsigned long		flags;
+		struct musb *musb = musb_ep->pThis;
+		int bEnd = musb_ep->bEndNumber;
+		void __iomem *mbase = musb->pRegs;
+		unsigned long flags;
 
 		spin_lock_irqsave(&musb->Lock, flags);
 
@@ -1131,12 +1194,12 @@ static int musb_gadget_fifo_status(struc
 
 static void musb_gadget_fifo_flush(struct usb_ep *ep)
 {
-	struct musb_ep	*musb_ep = to_musb_ep(ep);
-	struct musb	*musb;
-	void __iomem	*mbase;
-	u8		nEnd;
-	unsigned long	flags;
-	u16		wCsr, wIntrTxE;
+	struct musb_ep *musb_ep = to_musb_ep(ep);
+	struct musb *musb;
+	void __iomem *mbase;
+	u8 nEnd;
+	unsigned long flags;
+	u16 wCsr, wIntrTxE;
 
 	musb = musb_ep->pThis;
 	mbase = musb->pRegs;
@@ -1167,34 +1230,34 @@ static void musb_gadget_fifo_flush(struc
 }
 
 static struct usb_ep_ops musb_ep_ops = {
-	.enable		= musb_gadget_enable,
-	.disable	= musb_gadget_disable,
-	.alloc_request	= musb_alloc_request,
-	.free_request	= musb_free_request,
-	.alloc_buffer	= musb_gadget_alloc_buffer,
-	.free_buffer	= musb_gadget_free_buffer,
-	.queue		= musb_gadget_queue,
-	.dequeue	= musb_gadget_dequeue,
-	.set_halt	= musb_gadget_set_halt,
-	.fifo_status	= musb_gadget_fifo_status,
-	.fifo_flush	= musb_gadget_fifo_flush
+	.enable = musb_gadget_enable,
+	.disable = musb_gadget_disable,
+	.alloc_request = musb_alloc_request,
+	.free_request = musb_free_request,
+	.alloc_buffer = musb_gadget_alloc_buffer,
+	.free_buffer = musb_gadget_free_buffer,
+	.queue = musb_gadget_queue,
+	.dequeue = musb_gadget_dequeue,
+	.set_halt = musb_gadget_set_halt,
+	.fifo_status = musb_gadget_fifo_status,
+	.fifo_flush = musb_gadget_fifo_flush
 };
 
 /***********************************************************************/
 
 static int musb_gadget_get_frame(struct usb_gadget *gadget)
 {
-	struct musb	*pThis = gadget_to_musb(gadget);
+	struct musb *pThis = gadget_to_musb(gadget);
 
 	return (int)musb_readw(pThis->pRegs, MGC_O_HDRC_FRAME);
 }
 
 static int musb_gadget_wakeup(struct usb_gadget *gadget)
 {
-	struct musb	*musb = gadget_to_musb(gadget);
-	unsigned long	flags;
-	int		status = 0;
-	u8		power;
+	struct musb *musb = gadget_to_musb(gadget);
+	unsigned long flags;
+	int status = 0;
+	u8 power;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
@@ -1202,13 +1265,12 @@ static int musb_gadget_wakeup(struct usb
 	switch (musb->OtgMachine.xceiv.state) {
 	case OTG_STATE_B_PERIPHERAL:
 		/* FIXME if not suspended, fail */
-		if (musb->bMayWakeup){
+		if (musb->bMayWakeup) {
 			power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
 			power |= MGC_M_POWER_RESUME;
 			musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
 
-			mod_timer(&musb->Timer, jiffies +
-					msecs_to_jiffies(10));
+			mod_timer(&musb->Timer, jiffies + msecs_to_jiffies(10));
 			break;
 		}
 		goto fail;
@@ -1218,12 +1280,12 @@ static int musb_gadget_wakeup(struct usb
 		 */
 		if (is_otg_enabled(musb)) {
 			musb->OtgMachine.bRequest = MGC_OTG_REQUEST_START_BUS;
-			otg_input_changed_X(musb,FALSE,FALSE);
+			otg_input_changed_X(musb, FALSE, FALSE);
 			break;
 		}
 		/* FALLTHROUGH */
 	default:
-fail:
+	      fail:
 		status = -EINVAL;
 		goto done;
 	}
@@ -1232,17 +1294,19 @@ fail:
 	power |= MGC_M_POWER_RESUME;
 	musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	mod_timer(&musb->Timer, jiffies +
-					msecs_to_jiffies(10));
+	mod_timer(&musb->Timer, jiffies + msecs_to_jiffies(10));
 #else
 	mdelay(10);
+
 	power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
-        power &= ~MGC_M_POWER_RESUME;
-        musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
+	power &= ~MGC_M_POWER_RESUME;
+	musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
 #endif
 
 #endif
-done:
+#ifdef CONFIG_USB_MUSB_OTG
+      done:
+#endif
 	spin_unlock_irqrestore(&musb->Lock, flags);
 	return status;
 }
@@ -1250,7 +1314,7 @@ done:
 static int
 musb_gadget_set_self_powered(struct usb_gadget *gadget, int is_selfpowered)
 {
-	struct musb	*pThis = gadget_to_musb(gadget);
+	struct musb *pThis = gadget_to_musb(gadget);
 
 	pThis->bIsSelfPowered = !!is_selfpowered;
 	return 0;
@@ -1295,8 +1359,8 @@ static int musb_gadget_vbus_draw(struct 
 
 static int musb_gadget_pullup(struct usb_gadget *gadget, int is_on)
 {
-	struct musb	*musb = gadget_to_musb(gadget);
-	unsigned long	flags;
+	struct musb *musb = gadget_to_musb(gadget);
+	unsigned long flags;
 
 	is_on = !!is_on;
 
@@ -1313,12 +1377,12 @@ static int musb_gadget_pullup(struct usb
 }
 
 static struct usb_gadget_ops musb_gadget_operations = {
-	.get_frame		= musb_gadget_get_frame,
-	.wakeup			= musb_gadget_wakeup,
-	.set_selfpowered	= musb_gadget_set_self_powered,
-	//.vbus_session		= musb_gadget_vbus_session,
-	//.vbus_draw		= musb_gadget_vbus_draw,
-	.pullup			= musb_gadget_pullup,
+	.get_frame = musb_gadget_get_frame,
+	.wakeup = musb_gadget_wakeup,
+	.set_selfpowered = musb_gadget_set_self_powered,
+	//.vbus_session     = musb_gadget_vbus_session,
+	//.vbus_draw        = musb_gadget_vbus_draw,
+	.pullup = musb_gadget_pullup,
 };
 
 /****************************************************************
@@ -1337,11 +1401,10 @@ static void musb_gadget_release(struct d
 	dev_dbg(dev, "%s\n", __FUNCTION__);
 }
 
-
 static void __init
 init_peripheral_ep(struct musb *musb, struct musb_ep *ep, u8 bEnd, int is_in)
 {
-	struct musb_hw_ep	*hw_ep = musb->aLocalEnd + bEnd;
+	struct musb_hw_ep *hw_ep = musb->aLocalEnd + bEnd;
 
 	memset(ep, 0, sizeof *ep);
 
@@ -1353,8 +1416,7 @@ init_peripheral_ep(struct musb *musb, st
 	INIT_LIST_HEAD(&ep->req_list);
 
 	sprintf(ep->name, "ep%d%s", bEnd,
-			(!bEnd || hw_ep->bIsSharedFifo) ? "" : (
-				is_in ? "in" : "out"));
+		(!bEnd || hw_ep->bIsSharedFifo) ? "" : (is_in ? "in" : "out"));
 	ep->end_point.name = ep->name;
 	INIT_LIST_HEAD(&ep->end_point.ep_list);
 	if (!bEnd) {
@@ -1370,7 +1432,7 @@ init_peripheral_ep(struct musb *musb, st
 		list_add_tail(&ep->end_point.ep_list, &musb->g.ep_list);
 	}
 	DBG(4, "periph: %s, maxpacket %d\n", ep->end_point.name,
-			ep->end_point.maxpacket);
+	    ep->end_point.maxpacket);
 }
 
 /*
@@ -1379,32 +1441,33 @@ init_peripheral_ep(struct musb *musb, st
  */
 static inline void __init musb_g_init_endpoints(struct musb *pThis)
 {
-	u8			bEnd;
-	struct musb_hw_ep	*hw_ep;
-	unsigned		count = 0;
+	u8 bEnd;
+	struct musb_hw_ep *hw_ep;
+	unsigned count = 0;
 
 	/* intialize endpoint list just once */
 	INIT_LIST_HEAD(&(pThis->g.ep_list));
 
-	for (bEnd = 0, hw_ep = pThis->aLocalEnd;
-			bEnd < pThis->bEndCount;
-			bEnd++, hw_ep++) {
-		if (hw_ep->bIsSharedFifo /* || !bEnd */) {
+	for (bEnd = 0, hw_ep = pThis->aLocalEnd; bEnd < pThis->bEndCount;
+	     bEnd++, hw_ep++) {
+		if (hw_ep->bIsSharedFifo /* || !bEnd */ ) {
 			init_peripheral_ep(pThis, &hw_ep->ep_in, bEnd, 0);
 			count++;
 		} else {
 			if (hw_ep->wMaxPacketSizeTx) {
-				init_peripheral_ep(pThis, &hw_ep->ep_in, bEnd, 1);
+				init_peripheral_ep(pThis, &hw_ep->ep_in, bEnd,
+						   1);
 				count++;
 			}
 			if (hw_ep->wMaxPacketSizeRx) {
-				init_peripheral_ep(pThis, &hw_ep->ep_out, bEnd, 0);
+				init_peripheral_ep(pThis, &hw_ep->ep_out, bEnd,
+						   0);
 				count++;
 			}
 		}
 	}
 	DBG(2, "initialized %d (max %d) endpoints\n", count,
-			pThis->bEndCount * 2 - 1);
+	    pThis->bEndCount * 2 - 1);
 }
 
 /* called once during driver setup to initialize and link into
@@ -1442,6 +1505,7 @@ int __init musb_gadget_setup(struct musb
 	status = device_register(&pThis->g.dev);
 	if (status != 0)
 		the_gadget = NULL;
+
 	return status;
 }
 
@@ -1471,17 +1535,14 @@ int usb_gadget_register_driver(struct us
 	unsigned long flags;
 	struct musb *pThis = the_gadget;
 
-	if (!driver
-			|| driver->speed != USB_SPEED_HIGH
-	    		|| !driver->bind
-			|| !driver->unbind
-			|| !driver->setup)
+	if (!driver || driver->speed != USB_SPEED_HIGH || !driver->bind
+	    || !driver->unbind || !driver->setup)
 		return -EINVAL;
 
 	/* driver must be initialized to support peripheral mode */
 	if (!pThis || !(pThis->board_mode == MUSB_OTG
-				|| pThis->board_mode != MUSB_OTG)) {
-		DBG(1,"%s, no dev??\n", __FUNCTION__);
+			|| pThis->board_mode != MUSB_OTG)) {
+		DBG(1, "%s, no dev??\n", __FUNCTION__);
 		return -ENODEV;
 	}
 
@@ -1490,8 +1551,7 @@ int usb_gadget_register_driver(struct us
 
 	if (pThis->pGadgetDriver) {
 		DBG(1, "%s is already bound to %s\n",
-				musb_driver_name,
-				pThis->pGadgetDriver->driver.name);
+		    musb_driver_name, pThis->pGadgetDriver->driver.name);
 		retval = -EBUSY;
 	} else {
 		pThis->pGadgetDriver = driver;
@@ -1521,15 +1581,8 @@ int usb_gadget_register_driver(struct us
 		 */
 		/* HBG 21SEPT2006 OTG implementation */
 #ifdef CONFIG_USB_MUSB_OTG
-		otg_set_peripheral(&(pThis->OtgMachine.xceiv),&(pThis->g));
+		otg_set_peripheral(&(pThis->OtgMachine.xceiv), &(pThis->g));
 #endif
-		/* HBG 21SEPT2006 Removed as part of OTG enhancement */
-		//=====================================================
-#if 0
-				pThis->xceiv.gadget = &pThis->g;
-				pThis->xceiv.state = OTG_STATE_B_IDLE;
-#endif
-		//=====================================================
 		/* FIXME this ignores the softconnect flag.  Drivers are
 		 * allowed hold the peripheral inactive until for example
 		 * userspace hooks up printer hardware or DSP codecs, so
@@ -1538,111 +1591,85 @@ int usb_gadget_register_driver(struct us
 
 		musb_start(pThis);
 		spin_unlock_irqrestore(&pThis->Lock, flags);
-
-#if 0
-//#ifdef CONFIG_USB_MUSB_OTG
-		if (pThis->board_mode == MUSB_OTG) {
-			DBG(3, "OTG startup...\n");
-
-			/* REVISIT:  funcall to other code, which also
-			 * handles power budgeting ... this way also
-			 * ensures HdrcStart is indirectly called.
-			 */
-			retval = usb_register_root_hub(
-					pThis->RootHub.pDevice,
-					pThis->g.dev.parent);
-			if (retval < 0) {
-				spin_lock_irqsave(&pThis->Lock, flags);
-				/* HBG 21SEPT2006 OTG implementation */
-				otg_set_peripheral(&(pThis->OtgMachine.xceiv),NULL);
-				/* HBG 21SEPT2006 Removed as part of OTG enhancement */
-				//===================================================
-#if 0
-				pThis->xceiv.gadget = NULL;
-				pThis->xceiv.state = OTG_STATE_UNDEFINED;
-#endif
-				//===================================================
-				pThis->pGadgetDriver = NULL;
-				pThis->g.dev.driver = NULL;
-				spin_unlock_irqrestore(&pThis->Lock, flags);
-			}
-			/* HBG 21SEPT2006 OTG implementation */
-#ifdef CONFIG_USB_MUSB_OTG
-			otg_set_host(&(pThis->OtgMachine.xceiv), pThis->pBus);
-#endif
-		}
-#endif
 	}
 
 	return retval;
 }
+
 EXPORT_SYMBOL(usb_gadget_register_driver);
 
 static void
-stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
+stop_activity(struct musb *musb, struct usb_gadget_driver *driver,
+	      u8 fifo_flush)
 {
-	int			i;
-	struct musb_hw_ep	*hw_ep;
+	int i;
+	struct musb_hw_ep *hw_ep;
 
-	/* don't disconnect if it's not connected */
-	if (musb->g.speed == USB_SPEED_UNKNOWN)
-		driver = NULL;
-	else
-		musb->g.speed = USB_SPEED_UNKNOWN;
+	if (driver && (fifo_flush == 0)) {
+		/* don't disconnect if it's not connected */
+		if (musb->g.speed == USB_SPEED_UNKNOWN)
+			driver = NULL;
+		else
+			musb->g.speed = USB_SPEED_UNKNOWN;
 
-	/* deactivate the hardware */
-	if (musb->softconnect) {
-		musb->softconnect = 0;
-		musb_pullup(musb, 0);
-	}
-	musb_stop(musb);
+		/* deactivate the hardware */
+		if (musb->softconnect) {
+			musb->softconnect = 0;
+			musb_pullup(musb, 0);
+		}
 
+		musb_stop(musb);
+	}
 	/* killing any outstanding requests will quiesce the driver;
 	 * then report disconnect
 	 */
-	if (driver) {
+	{
 		for (i = 0, hw_ep = musb->aLocalEnd;
-				i < musb->bEndCount;
-				i++, hw_ep++) {
+		     i < musb->bEndCount; i++, hw_ep++) {
 			MGC_SelectEnd(musb->pRegs, i);
-			if (hw_ep->bIsSharedFifo /* || !bEnd */) {
+			if (hw_ep->bIsSharedFifo /* || !bEnd */ ) {
 				/* Description: Added lock / unlock calls and replaced nuke() by
- 				 *     musb_gadget_disable() call for IN endpoint
- 				 *
- 				 * Reason for change:
- 				 * Resolves the Complete preemption "rmmod" issue
- 				 *
- 				 * Fixed MRs:
- 				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
- 				 */
+				 *     musb_gadget_disable() call for IN endpoint
+				 *
+				 * Reason for change:
+				 * Resolves the Complete preemption "rmmod" issue
+				 *
+				 * Fixed MRs:
+				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
+				 */
 				spin_unlock(&musb->Lock);
-                               musb_gadget_disable(&hw_ep->ep_in.end_point);
-                               spin_lock(&musb->Lock);
+				musb_gadget_disable(&hw_ep->ep_in.end_point);
+				spin_lock(&musb->Lock);
 			} else {
 				/* Description: Added lock / unlock calls and replaced nuke() by
- 				 *     musb_gadget_disable() call for IN & OUT endpoints
- 				 *
- 				 * Reason for change:
- 				 * Resolves the Complete preemption "rmmod" issue
- 				 *
- 				 * Fixed MRs:
- 				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
- 				 */
-				if (hw_ep->wMaxPacketSizeTx){
+				 *     musb_gadget_disable() call for IN & OUT endpoints
+				 *
+				 * Reason for change:
+				 * Resolves the Complete preemption "rmmod" issue
+				 *
+				 * Fixed MRs:
+				 * 3014: <USB_Slave> DUT hangs when "rmmod" command is issued in Complete Pre-emption mode.
+				 */
+				if (hw_ep->wMaxPacketSizeTx) {
 					spin_unlock(&musb->Lock);
-					musb_gadget_disable(&hw_ep->ep_in.end_point);
-                                       spin_lock(&musb->Lock);
+					musb_gadget_disable(&hw_ep->ep_in.
+							    end_point);
+					spin_lock(&musb->Lock);
 				}
-				if (hw_ep->wMaxPacketSizeRx){
+				if (hw_ep->wMaxPacketSizeRx) {
 					spin_unlock(&musb->Lock);
-                                       musb_gadget_disable(&hw_ep->ep_out.end_point);
-                                       spin_lock(&musb->Lock);
+					musb_gadget_disable(&hw_ep->ep_out.
+							    end_point);
+					spin_lock(&musb->Lock);
 				}
 			}
 		}
 
 		spin_unlock(&musb->Lock);
-		driver->disconnect (&musb->g);
+
+		if (driver && (fifo_flush == 0))
+			driver->disconnect(&musb->g);
+
 		spin_lock(&musb->Lock);
 	}
 }
@@ -1655,9 +1682,9 @@ stop_activity(struct musb *musb, struct 
  */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 {
-	unsigned long	flags;
-	int		retval = 0;
-	struct musb	*pThis = the_gadget;
+	unsigned long flags;
+	int retval = 0;
+	struct musb *pThis = the_gadget;
 
 	if (!driver || !pThis)
 		return -EINVAL;
@@ -1668,7 +1695,7 @@ int usb_gadget_unregister_driver(struct 
 
 	spin_lock_irqsave(&pThis->Lock, flags);
 	if (pThis->pGadgetDriver == driver) {
-		stop_activity(pThis, driver);
+		stop_activity(pThis, driver, 0);
 
 		DBG(3, "unregistering driver %s\n", driver->function);
 		spin_unlock_irqrestore(&pThis->Lock, flags);
@@ -1683,8 +1710,8 @@ int usb_gadget_unregister_driver(struct 
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 	return retval;
 }
-EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
 /***********************************************************************/
 
@@ -1703,40 +1730,16 @@ void musb_g_resume(struct musb *pThis)
 /* called when SOF packets stop for 3+ msec */
 void musb_g_suspend(struct musb *pThis)
 {
-	u8	devctl;
+	u8 devctl;
 
 	devctl = musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL);
 	DBG(3, "devctl %02x\n", devctl);
 
-	/* HBG 21SEPT2006 Removed as part of OTG enhancement */
-	//=====================================================
-#if 0
-	switch (pThis->xceiv.state) {
-		case OTG_STATE_B_IDLE:
-			if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
-				pThis->xceiv.state = OTG_STATE_B_PERIPHERAL;
-			break;
-		case OTG_STATE_B_PERIPHERAL:
-			if (pThis->pGadgetDriver && pThis->pGadgetDriver->suspend) {
-				spin_unlock(&pThis->Lock);
-				pThis->pGadgetDriver->suspend(&pThis->g);
-				spin_lock(&pThis->Lock);
-			}
-			break;
-		default:
-			/* REVISIT if B_HOST, clear DEVCTL.HOSTREQ;
-			 * A_PERIPHERAL may need care too
-			 */
-			WARN("unhandled SUSPEND transition (%d)\n", pThis->xceiv.state);
-#endif
-	//======================================================
-
-	/*HBG 21SEPT2006 OTG Enhancement*/
 	if (pThis->pGadgetDriver && pThis->pGadgetDriver->suspend) {
 		spin_unlock(&pThis->Lock);
 		pThis->pGadgetDriver->suspend(&pThis->g);
 		spin_lock(&pThis->Lock);
-		}
+	}
 }
 
 /* called when VBUS drops below session threshold, and in other cases */
@@ -1745,48 +1748,25 @@ void musb_g_disconnect(struct musb *pThi
 	DBG(3, "devctl %02x\n", musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
 
 	pThis->g.speed = USB_SPEED_UNKNOWN;
+	stop_activity(pThis, NULL, 1);
 	if (pThis->pGadgetDriver && pThis->pGadgetDriver->disconnect) {
 		spin_unlock(&pThis->Lock);
 		pThis->pGadgetDriver->disconnect(&pThis->g);
 		spin_lock(&pThis->Lock);
 	}
-/* HBG 21SEPT2006 Removed as part of OTG enhancement*/
-//====================================================
-#if 0
-	switch (pThis->xceiv.state) {
-	default:
-#ifdef	CONFIG_USB_MUSB_OTG
-		pThis->xceiv.state = OTG_STATE_A_IDLE;
-		break;
-	case OTG_STATE_B_WAIT_ACON:
-	case OTG_STATE_B_HOST:
-#endif
-	case OTG_STATE_B_PERIPHERAL:
-		pThis->xceiv.state = OTG_STATE_B_IDLE;
-		break;
-	case OTG_STATE_B_SRP_INIT:
-		break;
-	}
-#endif
-//====================================================
 }
 
 void musb_g_reset(struct musb *pThis)
-__releases(pThis->Lock)
-__acquires(pThis->Lock)
+__releases(pThis->Lock) __acquires(pThis->Lock)
 {
-	void __iomem	*pBase = pThis->pRegs;
-	u8		devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-	u8		power;
-
-	DBG(3, "<== %s addr=%x driver '%s'\n",
-			(devctl & MGC_M_DEVCTL_BDEVICE)
-				? "B-Device" : "A-Device",
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
-			pThis->pGadgetDriver
-				? pThis->pGadgetDriver->driver.name
-				: NULL
-			);
+	void __iomem *pBase = pThis->pRegs;
+	u8 devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	u8 power;
+
+	DBG(3, "<== %s addr=%x driver '%s'\n", (devctl & MGC_M_DEVCTL_BDEVICE)
+	    ? "B-Device" : "A-Device",
+	    musb_readb(pBase, MGC_O_HDRC_FADDR),
+	    pThis->pGadgetDriver ? pThis->pGadgetDriver->driver.name : NULL);
 
 	/* HR does NOT clear itself */
 	if (devctl & MGC_M_DEVCTL_HR)
@@ -1794,12 +1774,12 @@ __acquires(pThis->Lock)
 
 	/* report disconnect, if we didn't already (flushing EP state) */
 	if (pThis->g.speed != USB_SPEED_UNKNOWN)
-		 musb_g_disconnect(pThis);
+		musb_g_disconnect(pThis);
 
 	/* what speed did we negotiate? */
 	power = musb_readb(pBase, MGC_O_HDRC_POWER);
 	pThis->g.speed = (power & MGC_M_POWER_HSMODE)
-			? USB_SPEED_HIGH : USB_SPEED_FULL;
+	    ? USB_SPEED_HIGH : USB_SPEED_FULL;
 
 	/* start in USB_STATE_DEFAULT */
 	MUSB_DEV_MODE(pThis);
@@ -1811,22 +1791,4 @@ __acquires(pThis->Lock)
 	pThis->g.a_alt_hnp_support = 0;
 	pThis->g.a_hnp_support = 0;
 
-	/* Normal reset, as B-Device;
-	 * or else after HNP, as A-Device
-	 */
-/* HBG 21SEPT2006 Removed as part of OTG enhancement
- *  Add this action as part of OTG controller driver implemntation in otg.c
- */
-//=====================================================
-#if 0
-	if (devctl & MGC_M_DEVCTL_BDEVICE) {
-		pThis->xceiv.state = OTG_STATE_B_PERIPHERAL;
-		pThis->g.is_a_peripheral = 0;
-	} else if (is_otg_enabled(pThis) && pThis->board_mode == MUSB_OTG) {
-		pThis->xceiv.state = OTG_STATE_A_PERIPHERAL;
-		pThis->g.is_a_peripheral = 1;
-	} else
-		WARN_ON(1);
-#endif
-//=====================================================
 }
Index: linux-2.6.10/drivers/usb/musb/musb_gadget.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_gadget.h
+++ linux-2.6.10/drivers/usb/musb/musb_gadget.h
@@ -35,12 +35,13 @@
 #define __MUSB_GADGET_H
 
 struct musb_request {
-	struct usb_request	request;
-	struct musb_ep		*ep;
-	struct musb		*musb;
+	struct usb_request request;
+	struct musb_ep *ep;
+	struct musb *musb;
 	u8 bTx;			/* endpoint direction */
 	u8 bEnd;
-	u8 mapped;
+	u8 mapped;		/* Request mapped with dma_map_single */
+	u8 dma;			/* Request handled with DMA */
 };
 
 static inline struct musb_request *to_musb_request(struct usb_request *req)
@@ -48,33 +49,33 @@ static inline struct musb_request *to_mu
 	return req ? container_of(req, struct musb_request, request) : NULL;
 }
 
-extern struct usb_request *
-musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);
+extern struct usb_request *musb_alloc_request(struct usb_ep *ep,
+					      gfp_t gfp_flags);
 extern void musb_free_request(struct usb_ep *ep, struct usb_request *req);
 
-
 /*
  * struct musb_ep - peripheral side view of endpoint rx or tx side
  */
 struct musb_ep {
 	/* stuff towards the head is basically write-once. */
-	struct usb_ep			end_point;
-	char				name[12];
-	struct musb_hw_ep		*hw_ep;
-	struct musb			*pThis;
-	u8				bEndNumber;
+	struct usb_ep end_point;
+	char name[12];
+	struct musb_hw_ep *hw_ep;
+	struct musb *pThis;
+	u8 bEndNumber;
 
 	/* ... when enabled/disabled ... */
-	u8				type;
-	u8				is_in;
-	u16				wPacketSize;
-	const struct usb_endpoint_descriptor	*desc;
-	struct dma_channel		*dma;
+	u8 type;
+	u8 is_in;
+	u16 wPacketSize;
+	const struct usb_endpoint_descriptor *desc;
+	struct dma_channel *dma;
 
 	/* later things are modified based on usage */
-	struct list_head		req_list;
+	struct list_head req_list;
 
-	u8				busy;
+	u8 busy;
+	u8 fifo_flush_check;
 };
 
 static inline struct musb_ep *to_musb_ep(struct usb_ep *ep)
@@ -84,7 +85,7 @@ static inline struct musb_ep *to_musb_ep
 
 static inline struct usb_request *next_request(struct musb_ep *ep)
 {
-	struct list_head	*queue = &ep->req_list;
+	struct list_head *queue = &ep->req_list;
 
 	if (list_empty(queue))
 		return NULL;
@@ -103,4 +104,4 @@ extern void musb_g_giveback(struct musb_
 
 extern int musb_gadget_set_halt(struct usb_ep *ep, int value);
 
-#endif		/* __MUSB_GADGET_H */
+#endif				/* __MUSB_GADGET_H */
Index: linux-2.6.10/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.10/drivers/usb/musb/musb_host.c
@@ -47,70 +47,23 @@
 
 #include "musbdefs.h"
 #include "musb_host.h"
+static void
+musb_advance_urb_queue(struct musb *pThis, struct urb *urb,
+		       struct musb_hw_ep *pEnd, int is_in);
 
 #ifdef HOST_TX_DMA_SOLUTION
-/* Description: Added defines and globals used by Host TX DMA
- *    completion solution.
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
- *    to the Hub fails.
- */
-
-struct host_tx_completion_req
-{
-	struct list_head  node;	  /* Completion request list node for kernel thread */
-
-	struct urb        *pUrb;  /* URB for completion */
-	struct musb_hw_ep *pEnd;  /* Endpoint */
-	int				  status; /* Status at time of completion */
-	int				  isBusy; /* Completion request list node status: 
-									1 => in use / busy
-									0 => not in use / available
-							   */
-};
-
 /* Globals and function prototypes */
 
-/* Static pool of tx completion request structures */
-#define HOST_TX_REQ_POOL_SIZE	64
-static struct host_tx_completion_req 
-					host_tx_req_pool[HOST_TX_REQ_POOL_SIZE];
-struct list_head	tx_completion_list;	/* host tx completion list head */
-
-#ifndef CONFIG_PREEMPT_RT
-static spinlock_t		txReqListLock;	/* lock for global host tx completion request list */
-#else
-struct semaphore		txReqListLock;
-#endif
-
-#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
-
-DECLARE_MUTEX_LOCKED(semTxListEmpty);	/* semaphore for pending thread on empty request list */
-struct completion	hostTxThreadNotify;	/* kernel thread start notification */
-
-/* Host TX DMA Completion kernel thread routine */
-static int musb_host_tx_completion_thread(void *);
-
-#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
-
-static int reSchedCount = 0;				/* Tasklet reschedule count */
 #define	MAX_TASKLET_REG_POLL_COUNT	32767	/* Maximum count for TXCSR polling in tasklet */
-#define MAX_TASKLET_RESCHED_COUNT	256		/* Maximum tasklet reschedule count */
+#define MAX_TASKLET_RESCHED_COUNT	256	/* Maximum tasklet reschedule count */
 
 /* Host TX DMA Completion kernel thread routine */
 static void musb_host_tx_completion_tasklet(unsigned long);
 
 /* Declare and initialize the tasklet */
-static DECLARE_TASKLET(host_tx_completion_tasklet, musb_host_tx_completion_tasklet, 0);
-#endif
-
-static struct host_tx_completion_req *get_free_tx_req_pool_entry(void);
-
-#endif /* HOST_TX_DMA_SOLUTION */
+static DECLARE_TASKLET(host_tx_completion_tasklet,
+		       musb_host_tx_completion_tasklet, 0);
+#endif				/* HOST_TX_DMA_SOLUTION */
 
 /* MUSB HOST status 9-mar-2006
  *
@@ -133,7 +86,6 @@ static struct host_tx_completion_req *ge
  * - Host side doesn't understand that endpoint hardware has two directions.
  */
 
-
 /*
  * NOTE on endpoint usage:
  *
@@ -150,12 +102,11 @@ static struct host_tx_completion_req *ge
  * of transfers between endpoints, or anything clever.
  */
 
-
 /*************************** Forwards ***************************/
 
 static void musb_ep_program(struct musb *pThis, u8 bEnd,
-			       struct urb *pUrb, unsigned int nOut,
-			       u8 * pBuffer, u32 dwLength);
+			    struct urb *pUrb, unsigned int nOut,
+			    u8 * pBuffer, u32 dwLength);
 
 /*
  * Start transmit. Caller is responsible for locking shared resources.
@@ -205,7 +156,7 @@ void MGC_HdrcEnableTXDMA(struct musb *pT
 	 * Host mode TX DMA does not function, stops with urb_unlink.
 	 *
 	 * Fixed MRs:
-	 * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
+	 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
 	 *    to the Hub fails.
 	 */
 	txCsr |= MGC_M_TXCSR_DMAMODE;
@@ -223,17 +174,17 @@ void MGC_HdrcEnableTXDMA(struct musb *pT
  */
 static void musb_start_urb(struct musb *pThis, struct musb_hw_ep *pEnd)
 {
-	u16			wFrame;
-	u32			dwLength;
-	void			*pBuffer;
-	void __iomem		*pBase =  pThis->pRegs;
-	struct urb		*pUrb = MGC_GetCurrentUrb(pEnd);
-	unsigned 		nPipe = pUrb->pipe;
-	unsigned 		is_out = usb_pipeout(nPipe);
-	u8			bAddress = usb_pipedevice(nPipe);
-	u8			bRemoteEnd = usb_pipeendpoint(nPipe);
-	u16			wPacketSize;
-	int			bEnd = pEnd->bLocalEnd;
+	u16 wFrame;
+	u32 dwLength;
+	void *pBuffer;
+	void __iomem *pBase = pThis->pRegs;
+	struct urb *pUrb = MGC_GetCurrentUrb(pEnd);
+	unsigned nPipe = pUrb->pipe;
+	unsigned is_out = usb_pipeout(nPipe);
+	u8 bAddress = usb_pipedevice(nPipe);
+	u8 bRemoteEnd = usb_pipeendpoint(nPipe);
+	u16 wPacketSize;
+	int bEnd = pEnd->bLocalEnd;
 
 	wPacketSize = usb_maxpacket(pUrb->dev, nPipe, is_out);
 
@@ -249,6 +200,11 @@ static void musb_start_urb(struct musb *
 	pEnd->bEnd = bRemoteEnd;
 	pEnd->bTrafficType = (u8) usb_pipetype(nPipe);
 
+	if (is_out)
+		pEnd->out_busy = 1;
+	else
+		pEnd->in_busy = 1;
+
 	/* end must be claimed from my caller */
 
 	if (usb_pipecontrol(nPipe)) {
@@ -272,9 +228,8 @@ static void musb_start_urb(struct musb *
 	}
 
 	DBG(4, "urb %p: ep%d%s, type %d, max %d, addr %d, buffer %p len %u\n",
-			pUrb, bRemoteEnd, (is_out) ? "out" : "in",
-			usb_pipetype(nPipe), wPacketSize, bAddress,
-			pBuffer, dwLength);
+	    pUrb, bRemoteEnd, (is_out) ? "out" : "in",
+	    usb_pipetype(nPipe), wPacketSize, bAddress, pBuffer, dwLength);
 
 	/* Configure endpoint */
 	musb_ep_program(pThis, bEnd, pUrb, is_out, pBuffer, dwLength);
@@ -306,14 +261,13 @@ static void musb_start_urb(struct musb *
 		 * or handle framecounter wrapping
 		 */
 		if ((pUrb->transfer_flags & URB_ISO_ASAP)
-				|| (wFrame >= pUrb->start_frame)) {
+		    || (wFrame >= pUrb->start_frame)) {
 			/* REVISIT the SOF irq handler shouldn't duplicate
 			 * this code... or the branch below...
 			 */
 			pEnd->dwWaitFrame = 0;
 			printk("Start --> periodic TX%s on %d\n",
-				pEnd->pDmaChannel ? " DMA" : "",
-				bEnd);
+			       pEnd->pDmaChannel ? " DMA" : "", bEnd);
 			if (!pEnd->pDmaChannel)
 				MGC_HdrcStartTx(pThis, bEnd);
 			else
@@ -321,14 +275,14 @@ static void musb_start_urb(struct musb *
 		} else {
 			pEnd->dwWaitFrame = pUrb->start_frame;
 			/* enable SOF interrupt so we can count down */
-DBG(1,"SOF for %d\n", bEnd);
-#if 1 // ifndef	CONFIG_ARCH_DAVINCI
+			DBG(1, "SOF for %d\n", bEnd);
+#if 1				// ifndef CONFIG_ARCH_DAVINCI
 			musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0xff);
 #endif
 		}
 	} else {
 		DBG(4, "Start TX%d %s\n", bEnd,
-			pEnd->pDmaChannel ? "dma" : "pio");
+		    pEnd->pDmaChannel ? "dma" : "pio");
 
 		if (!pEnd->pDmaChannel)
 			MGC_HdrcStartTx(pThis, bEnd);
@@ -338,15 +292,13 @@ DBG(1,"SOF for %d\n", bEnd);
 }
 
 /* caller owns no controller locks, irqs are blocked */
-static inline void
-__musb_giveback(struct urb *urb, int status)
+static inline void __musb_giveback(struct urb *urb, int status)
 {
-	const struct musb_hw_ep		*hw_ep = urb->hcpriv;
+	const struct musb_hw_ep *hw_ep = urb->hcpriv;
 
 	if ((urb->transfer_flags & URB_SHORT_NOT_OK)
-			&& (urb->actual_length < urb->transfer_buffer_length)
-			&& status == 0
-			&& usb_pipein(urb->pipe))
+	    && (urb->actual_length < urb->transfer_buffer_length)
+	    && status == 0 && usb_pipein(urb->pipe))
 		status = -EREMOTEIO;
 
 	spin_lock(&urb->lock);
@@ -357,38 +309,33 @@ __musb_giveback(struct urb *urb, int sta
 		urb->status = status;
 	spin_unlock(&urb->lock);
 
-	DBG(({ int level; switch (urb->status) {
-				case 0:
-					level = 4;
-					break;
-				/* common/boring faults */
-				case -EREMOTEIO:
-				case -ESHUTDOWN:
-				case -EPIPE:
-					level = 3;
-					break;
-				default:
-					level = 2;
-					break;
-				}; level; }),
-			"complete %p (%d), dev%d ep%d%s, %d/%d\n",
-			urb, urb->status,
-			usb_pipedevice(urb->pipe),
-			usb_pipeendpoint(urb->pipe),
-			usb_pipein(urb->pipe) ? "in" : "out",
-			urb->actual_length, urb->transfer_buffer_length
-			);
+	DBG(( {
+	     int level; switch (urb->status) {
+case 0:
+	     level = 4; break;
+	     /* common/boring faults */
+case -EREMOTEIO:
+case -ESHUTDOWN:
+case -EPIPE:
+level = 3; break; default:
+	     level = 2; break;}; level;}
+	    ),
+	    "complete %p (%d), dev%d ep%d%s, %d/%d\n",
+	    urb, urb->status,
+	    usb_pipedevice(urb->pipe),
+	    usb_pipeendpoint(urb->pipe),
+	    usb_pipein(urb->pipe) ? "in" : "out",
+	    urb->actual_length, urb->transfer_buffer_length) ;
 
 	/* teardown DMA mapping, if needed (does dcache sync) */
 	if (is_dma_capable()
-			&& hw_ep->musb->controller->dma_mask
-			&& urb->transfer_buffer_length != 0
-			&& !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)) {
+	    && hw_ep->musb->controller->dma_mask
+	    && urb->transfer_buffer_length != 0
+	    && !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)) {
 		dma_unmap_single(hw_ep->musb->controller, urb->transfer_dma,
-				urb->transfer_buffer_length,
-				usb_pipein(urb->pipe)
-					? DMA_FROM_DEVICE
-					: DMA_TO_DEVICE);
+				 urb->transfer_buffer_length,
+				 usb_pipein(urb->pipe)
+				 ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 		/* REVISIT record whether we mapped it;
 		 * and if we did, on pio fallback paths
 		 * it might be good to unmap it EARLY
@@ -402,13 +349,13 @@ __musb_giveback(struct urb *urb, int sta
 	 * FIXME: make this use hcd framework giveback, so we don't use
 	 * the usbcore-internal wakeup queue...
 	 */
-	if(urb->dev) {
-	usb_put_dev(urb->dev);
-	urb->complete(urb, hw_ep->musb->int_regs);
-	atomic_dec(&urb->use_count);
-	if (urb->reject)
-		wake_up(&usb_kill_urb_queue);
-	usb_put_urb(urb);
+	if (urb->dev) {
+		usb_put_dev(urb->dev);
+		urb->complete(urb, hw_ep->musb->int_regs);
+		atomic_dec(&urb->use_count);
+		if (urb->reject)
+			wake_up(&usb_kill_urb_queue);
+		usb_put_urb(urb);
 	} else {
 		DBG(4, "NULL device pointer\n");
 	}
@@ -417,433 +364,109 @@ __musb_giveback(struct urb *urb, int sta
 /* for non-iso endpoints only */
 static inline void musb_save_toggle(struct musb_hw_ep *ep, struct urb *urb)
 {
-	struct usb_device	*udev = urb->dev;
-	u16			csr;
-	void __iomem		*hw = ep->musb->pRegs;
+	struct usb_device *udev = urb->dev;
+	u16 csr;
+	void __iomem *hw = ep->musb->pRegs;
 
 	ep->bIsReady = FALSE;
-	if (!udev) return;
+	if (!udev)
+		return;
 	if (usb_pipeout(urb->pipe)) {
-		csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR,
-				ep->bLocalEnd);
+		csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR, ep->bLocalEnd);
 		usb_settoggle(udev, ep->bEnd, 1,
-			(csr & MGC_M_TXCSR_H_DATATOGGLE)
-				? 1 : 0);
+			      (csr & MGC_M_TXCSR_H_DATATOGGLE)
+			      ? 1 : 0);
 	} else {
-		csr = MGC_ReadCsr16(hw, MGC_O_HDRC_RXCSR,
-				ep->bLocalEnd);
+		csr = MGC_ReadCsr16(hw, MGC_O_HDRC_RXCSR, ep->bLocalEnd);
 		usb_settoggle(udev, ep->bEnd, 0,
-			(csr & MGC_M_RXCSR_H_DATATOGGLE)
-				? 1 : 0);
+			      (csr & MGC_M_RXCSR_H_DATATOGGLE)
+			      ? 1 : 0);
 	}
 }
 
 #ifdef HOST_TX_DMA_SOLUTION
-/* Description: Added functions (thread/tasklet) used by Host TX DMA
- *    completion solution.
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
- *    to the Hub fails.
- */
-
-/* get the free entry from static pool of host tx completion request */
-static struct host_tx_completion_req *get_free_tx_req_pool_entry(void)
-{
-	/* NOTE: This function assumes caller owns the global host tx completion
-			request list lock.
-	*/
-	struct host_tx_completion_req *pHostTxReqEntry = NULL;
-	int idx;
-
-	pHostTxReqEntry = &host_tx_req_pool[0];
-	for(idx = 0; idx < HOST_TX_REQ_POOL_SIZE; idx++)
-	{
-		pHostTxReqEntry = &host_tx_req_pool[idx];
-		if(pHostTxReqEntry->isBusy == 0)
-			break;
-	}
-	if(idx < HOST_TX_REQ_POOL_SIZE)
-	{
-		pHostTxReqEntry->isBusy = 1;
-	}
-	else
-		pHostTxReqEntry = NULL;
-
-	return pHostTxReqEntry;
-}
-
-#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
-
-int musb_host_tx_completion_thread(void *pVoid)
-{
-	struct host_tx_thread_req *pHostTxReq = NULL;
-
-	struct musb *pThis      = NULL;
-	struct urb  *pUrb       = NULL;
-	struct musb_hw_ep *pEnd = NULL;
-
-	int status;
-	u8  busy;
-	u8  type;
-
-	u16 csr;
-	void __iomem *hw;
-
-	unsigned long flags;
-
-	/* wait for thread startup notification */
-	wait_for_completion(&hostTxThreadNotify);
-	init_completion(&hostTxThreadNotify);
-
-	/* TODO: Need to implement thread exit condition */
-	while(1)
-	{
-		ACQUIRE_TX_REQ_LIST_LOCK();	
-		if(list_empty(&tx_completion_list))
-		{
-			RELEASE_TX_REQ_LIST_LOCK();	
-
-			if(down_interruptible(&semTxListEmpty))
-			{
-				/* TODO: Handle empty list wait INTERRUPTED */
-				break;
-			}
-			ACQUIRE_TX_REQ_LIST_LOCK();	
-		}
-
-		/* get the request list head entry */
-		pHostTxReq = list_entry(tx_completion_list.next, 
-								struct host_tx_thread_req, node);
-		if(pHostTxReq == NULL || &pHostTxReq->node == &tx_completion_list)
-		{
-			/* The list is actually empty, observed this condition for 
-			 * thread based solution.
-			 */
-			RELEASE_TX_REQ_LIST_LOCK();	
-			cpu_relax();
-			continue;
-		}
-
-		pUrb   = pHostTxReq->pUrb;
-		pEnd   = pHostTxReq->pEnd;
-		status = pHostTxReq->status;
-
-		/* update the static tx request pool entry status to free */
-		pHostTxReq->isBusy = 0;
-
-		list_del_init(&pHostTxReq->node); /* delete request entry from list */
-
-		RELEASE_TX_REQ_LIST_LOCK();	
-
-		pThis  = pEnd->musb;
-		hw     = pThis->pRegs;
-		pHostTxReq = NULL;
-
-		/* NOTE: copied the code segment from musb_giveback() */
-		spin_lock_irqsave(&pThis->Lock, flags);
-		type = pEnd->out_traffic_type;
-		/* save toggle eagerly, for paranoia */
-		switch (type)
-		{
-		case PIPE_BULK:
-		case PIPE_INTERRUPT:
-			/* Poll FIFONOTEMPTY & TXPKTRDY before saving DATATOGGLE status */
-			do
-			{
-				csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR, pEnd->bLocalEnd);
-			} while((csr & MGC_M_TXCSR_FIFONOTEMPTY) 
-					|| (csr & MGC_M_TXCSR_TXPKTRDY));
-			/* save the data toggle status */
-			musb_save_toggle(pEnd, pUrb);
-		}
-
-		busy = pEnd->out_busy;
-		pEnd->out_busy = 1;
-
-		spin_unlock_irqrestore(&pThis->Lock, flags);
-
-		__musb_giveback(pUrb, status);
-
-		spin_lock_irqsave(&pThis->Lock, flags);
-
-		pEnd->out_busy = busy;
-
-		/* reclaim resources (and bandwidth) ASAP */
-		if (list_empty(&pEnd->urb_list))
-		{
-			switch (type)
-			{
-			case PIPE_ISOCHRONOUS:
-			case PIPE_INTERRUPT:
-				/* this is where periodic bandwidth should be
-				 * de-allocated if its tracked and allocated.
-				 */
-				pEnd->bIsClaimed = FALSE;
-				pEnd->bIsReady = FALSE;
-				break;
-			}
-		}
-		else
-		{
-			/* NOTE: This is from musb_advance_urb_queue() */
-			musb_start_urb(pThis, pEnd);
-		}
-		spin_unlock_irqrestore(&pThis->Lock, flags);
-	}
-
-	/* exit thread with notification */
-	complete_and_exit(&hostTxThreadNotify, 0);
-}
-
-#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
-
 /* Tasklet routine to handle the host tx completion request list.
  * Before the scheduled tasklet comes in execution if we see another
  * interrupt, there could be more than one completion requests pending.
- * TODO: The pending requests may be maximum 2, but need to make 
+ * TODO: The pending requests may be maximum 2, but need to make
  * sure this.
  */
-void musb_host_tx_completion_tasklet(unsigned long unused)
+void musb_host_tx_completion_tasklet(unsigned long data)
 {
-	struct host_tx_completion_req *pHostTxReq = NULL;
-
-	struct musb *pThis      = NULL;
-	struct urb  *pUrb       = NULL;
+	struct musb *pThis = (struct musb *)data;
+	u8 epnum = 1, sch_tsklt = 0;
 	struct musb_hw_ep *pEnd = NULL;
-
-	int status;
-	u8  busy;
-	u8  type;
-
+	struct urb *pUrb = NULL;
 	unsigned long flags;
+	u16 cnt = 0, csr;
 
-	u16 pollCount;
-	u16 csr;
-	void __iomem *hw;
-
-	ACQUIRE_TX_REQ_LIST_LOCK();
-	while(!list_empty(&tx_completion_list))
-	{
-		/* get the request list head entry */
-		pHostTxReq = list_entry(tx_completion_list.next, 
-								struct host_tx_completion_req, node);
-		if(pHostTxReq == NULL || &pHostTxReq->node == &tx_completion_list)
-		{
-			/* The list is actually empty, observed this condition for 
-			 * thread based solution.
-			 */
-			break;
-		}
-
-		pUrb   = pHostTxReq->pUrb;
-		spin_lock(&pUrb->lock);
-		status = pUrb->status;
-		spin_unlock(&pUrb->lock);
-		if (status != -EINPROGRESS && status != 0) {
-			pHostTxReq->isBusy = 0;
-			list_del_init(&pHostTxReq->node);
-			DBG(1, "URB %p -> status %d changed after queued to tasklet\n", pUrb, status);
-			continue;
-		}
-
-		pEnd   = pHostTxReq->pEnd;
-		status = pHostTxReq->status;
-
-		pThis  = pEnd->musb;
-		hw     = pThis->pRegs;
-
-		/* NOTE: copied the code segment from musb_giveback() */
-		spin_lock_irqsave(&pThis->Lock, flags);
-		type = pEnd->out_traffic_type;
-		/* save toggle eagerly, for paranoia */
-		switch (type)
-		{
-		case PIPE_BULK:
-		case PIPE_INTERRUPT:
-			/* Poll FIFONOTEMPTY & TXPKTRDY before saving DATATOGGLE status */
-			csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR, pEnd->bLocalEnd);
-			for (pollCount = 0; pollCount < MAX_TASKLET_REG_POLL_COUNT 
-								&& ((csr & MGC_M_TXCSR_FIFONOTEMPTY) 
-									|| (csr & MGC_M_TXCSR_TXPKTRDY)); 
-								pollCount++) {
- 				csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR, pEnd->bLocalEnd);
-			}
-			if (pollCount == MAX_TASKLET_REG_POLL_COUNT) {
-				if(reSchedCount >= MAX_TASKLET_RESCHED_COUNT) {
-					status = -ETIMEDOUT;
-					WARN("Tasklet reSchedCount = %d for urb %p\n", reSchedCount, pUrb);
+	do {
+		pEnd = &(pThis->aLocalEnd[epnum]);
+		if (pEnd->fifo_flush_check) {
+			do {
+				csr =
+				    MGC_ReadCsr16(pThis->pRegs,
+						  MGC_O_HDRC_TXCSR,
+						  pEnd->bLocalEnd);
+				if (!((csr & MGC_M_TXCSR_FIFONOTEMPTY) ||
+				      (csr & MGC_M_TXCSR_TXPKTRDY)))
 					break;
-				}
+			} while (cnt++ < MAX_TASKLET_REG_POLL_COUNT);
 
+			if ((csr & MGC_M_TXCSR_FIFONOTEMPTY) ||
+			    (csr & MGC_M_TXCSR_TXPKTRDY))
+				sch_tsklt = 1;
+			else {
+				spin_lock_irqsave(&pThis->Lock, flags);
+				pEnd->fifo_flush_check = 0;
+				pUrb = next_out_urb(pEnd);
+				musb_advance_urb_queue(pThis, pUrb, pEnd,
+						       USB_DIR_OUT);
 				spin_unlock_irqrestore(&pThis->Lock, flags);
-				RELEASE_TX_REQ_LIST_LOCK();	
-
-				reSchedCount++;
-
-				/* re-schedule the tasklet */
-				tasklet_schedule(&host_tx_completion_tasklet);
-				return;
 			}
-			/* save the data toggle status */
-			musb_save_toggle(pEnd, pUrb);
 		}
-		/* update the static tx request pool entry status to free */
-		pHostTxReq->isBusy = 0;
-		list_del_init(&pHostTxReq->node); /* delete request entry from list */
-		pHostTxReq = NULL;
-
-		RELEASE_TX_REQ_LIST_LOCK();	
-
-		reSchedCount = 0;
 
-		busy = pEnd->out_busy;
-		pEnd->out_busy = 1;
-
-		spin_unlock_irqrestore(&pThis->Lock, flags);
-
-		__musb_giveback(pUrb, status);
-
-		spin_lock_irqsave(&pThis->Lock, flags);
+		epnum += 2;
+	} while (epnum < MUSB_C_NUM_EPS);
 
-		pEnd->out_busy = busy;
+	if (sch_tsklt)
+		tasklet_schedule(&host_tx_completion_tasklet);
+}
 
-		/* reclaim resources (and bandwidth) ASAP */
-		if (list_empty(&pEnd->urb_list))
-		{
-			switch (type)
-			{
-			case PIPE_ISOCHRONOUS:
-			case PIPE_INTERRUPT:
-				/* this is where periodic bandwidth should be
-				 * de-allocated if its tracked and allocated.
-				 */
-				pEnd->bIsClaimed = FALSE;
-				pEnd->bIsReady = FALSE;
-				break;
-			}
-		}
-		else
-		{
-			/* NOTE: This is from musb_advance_urb_queue() */
-			musb_start_urb(pThis, pEnd);
-		}
-		spin_unlock_irqrestore(&pThis->Lock, flags);
+/*
+ *	Invoke tasklet and update the EP with information for tasklet to
+ *	probe for fifo flush.
+ */
+void musb_tx_tasklet_invoke(struct musb *pThis, struct musb_hw_ep *pEnd)
+{
+	u16 csr;
 
-		ACQUIRE_TX_REQ_LIST_LOCK();	
+	csr = MGC_ReadCsr16(pThis->pRegs, MGC_O_HDRC_TXCSR, pEnd->bLocalEnd);
+	if ((csr & MGC_M_TXCSR_FIFONOTEMPTY) || (csr & MGC_M_TXCSR_TXPKTRDY)) {
+		pEnd->fifo_flush_check = 1;
+		host_tx_completion_tasklet.data = (unsigned long)pThis;
+		tasklet_schedule(&host_tx_completion_tasklet);
+	} else {
+		pEnd->fifo_flush_check = 0;
+		musb_advance_urb_queue(pThis, next_out_urb(pEnd), pEnd,
+				       USB_DIR_OUT);
 	}
-	RELEASE_TX_REQ_LIST_LOCK();	
 }
-#endif
-
-#endif /* HOST_TX_DMA_SOLUTION */
-
-// REVISIT need to handle both rx and tx paths for each hw_ep...
+#endif				/* HOST_TX_DMA_SOLUTION */
 
 /* caller owns controller lock, irqs are blocked */
 static void musb_giveback(struct musb_hw_ep *ep, struct urb *urb, int status)
-__releases(ep->musb->Lock)
-__acquires(ep->musb->Lock)
+__releases(ep->musb->Lock) __acquires(ep->musb->Lock)
 {
-	int			is_in;
-	u8			busy;
-	u8			type;
-#ifdef HOST_TX_DMA_SOLUTION
-#if HOST_TX_DMA_SOLUTION == 1
-	u8 			listEmpty = 0;
-#elif HOST_TX_DMA_SOLUTION == 2
-	int			urbStatus = 0;
-#endif
-	struct host_tx_completion_req *pHostTxReq = NULL;
-#endif
+	int is_in;
+	u8 type;
+
 	if (ep->bIsSharedFifo)
 		is_in = 1;
 	else
 		is_in = usb_pipein(urb->pipe);
 	type = is_in ? ep->in_traffic_type : ep->out_traffic_type;
 
-#ifdef HOST_TX_DMA_SOLUTION
-/* Description: Forward the completion request to the Host TX DMA
- *    completion solution (thread/tasklet).
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
- *    to the Hub fails.
- */
-
-	/* TODO: How do we handle already pending TX completion events when we get
-	 * TX completion for same end point with any error code in 'status'?
-	 */
-#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
-	if(!is_in && status == 0)
-	{
-		ACQUIRE_TX_REQ_LIST_LOCK();	
-
-		pHostTxReq = get_free_tx_req_pool_entry();
-		if(pHostTxReq == NULL)
-		{
-			/* NOTE: SHOULD NEVER COME HERE */
-			WARN("ERR: get_free_tx_req_pool_entry() - no free entries available\n");
-		}
-
-		pHostTxReq->pUrb	= urb;
-		pHostTxReq->pEnd	= ep;
-		pHostTxReq->status = status;
-
-		if(list_empty(&tx_completion_list))	/* check if list is empty */
-			listEmpty = 1;
-
-		/* add the request in list at the end */
-		list_add_tail(&pHostTxReq->node, &tx_completion_list);
-
-		RELEASE_TX_REQ_LIST_LOCK();	
-
-		/* notify the thread if the entry was added in empty list */
-		if(listEmpty)
-			up(&semTxListEmpty);
-		return;
-	}
-
-#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
-	spin_lock(&urb->lock);
-	urbStatus = urb->status;
-	spin_unlock(&urb->lock);
-
-	if(!is_in && status == 0 && ep->bLocalEnd && (urbStatus == -EINPROGRESS || urbStatus == 0))
-	{
-		ACQUIRE_TX_REQ_LIST_LOCK();	
-
-		pHostTxReq = get_free_tx_req_pool_entry();
-		if(pHostTxReq == NULL)
-		{
-			/* NOTE: SHOULD NEVER COME HERE */
-			WARN("ERR: get_free_tx_req_pool_entry() - no free entries available\n");
-		}
-
-		pHostTxReq->pUrb	= urb;
-		pHostTxReq->pEnd	= ep;
-		pHostTxReq->status = status;
-
-		/* add the request in list at the end */
-		list_add_tail(&pHostTxReq->node, &tx_completion_list);
-
-		/* schedule the tasklet */
-		tasklet_schedule(&host_tx_completion_tasklet);
-
-		RELEASE_TX_REQ_LIST_LOCK();	
-
-		return;
-	}
-#endif
-
-#endif /* HOST_TX_DMA_SOLUTION */
-
 	/* save toggle eagerly, for paranoia */
 	switch (type) {
 	case PIPE_BULK:
@@ -851,22 +474,15 @@ __acquires(ep->musb->Lock)
 		musb_save_toggle(ep, urb);
 	}
 
-	if (is_in) {
-		busy = ep->in_busy;
-		ep->in_busy = 1;
-	} else {
-		busy = ep->out_busy;
-		ep->out_busy = 1;
-	}
 	spin_unlock(&ep->musb->Lock);
 
 	__musb_giveback(urb, status);
 
 	spin_lock(&ep->musb->Lock);
 	if (is_in)
-		ep->in_busy = busy;
+		ep->in_busy = 0;
 	else
-		ep->out_busy = busy;
+		ep->out_busy = 0;
 
 	/* reclaim resources (and bandwidth) ASAP */
 	if (list_empty(&ep->urb_list)) {
@@ -879,6 +495,8 @@ __acquires(ep->musb->Lock)
 			ep->bIsClaimed = FALSE;
 			ep->bIsReady = FALSE;
 			break;
+		default:
+			ep->bIsClaimed = 0;
 		}
 	}
 }
@@ -893,64 +511,42 @@ __acquires(ep->musb->Lock)
  */
 static void
 musb_advance_urb_queue(struct musb *pThis, struct urb *urb,
-		struct musb_hw_ep *pEnd, int is_in)
+		       struct musb_hw_ep *pEnd, int is_in)
 {
-#if HOST_TX_DMA_SOLUTION == 2
-	int urbStatus = 0;
-#endif
 	if (urb)
-	{
 		musb_giveback(pEnd, urb, 0);
-#ifdef HOST_TX_DMA_SOLUTION
-/* Description: Return for TX end points as the Host TX DMA completion
- *    solution (thread/tasklet) will take care of further action.
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
- *    to the Hub fails.
- */
-		spin_lock(&urb->lock);
-		urbStatus = urb->status;
-		spin_unlock(&urb->lock);
-		if(!is_in && pEnd->bLocalEnd && (urbStatus == -EINPROGRESS || urbStatus == 0)) return;
-#endif /* HOST_TX_DMA_SOLUTION */
-	}
-	if (!list_empty(&pEnd->urb_list)) {
+	if ((!list_empty(&pEnd->urb_list)) && (!pEnd->busy)) {
 		DBG(4, "... next ep%d %cX urb %p\n",
-				pEnd->bLocalEnd, is_in ? 'R' : 'T',
-				// next_in_urb() or next_out_urb()
-				MGC_GetCurrentUrb(pEnd));
+		    pEnd->bLocalEnd, is_in ? 'R' : 'T',
+		    // next_in_urb() or next_out_urb()
+		    MGC_GetCurrentUrb(pEnd));
 		musb_start_urb(pThis, pEnd);
 	}
 }
 
-
 /*
  * Receive a packet (or part of it).
  * @requires pThis->Lock locked
  * @return TRUE if URB is complete
  */
 static u8 musb_host_packet_rx(struct musb *pThis, struct urb *pUrb,
-		u8 bEnd, u8 bIsochError)
+			      u8 bEnd, u8 bIsochError)
 {
 	u16 wRxCount;
 	u16 wLength;
 	u8 *pBuffer;
 	u16 wCsr;
 	u8 bDone = FALSE;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = &(pThis->aLocalEnd[bEnd]);
-	int			nPipe = pUrb->pipe;
-	void			*buffer = pUrb->transfer_buffer;
+	void __iomem *pBase = pThis->pRegs;
+	struct musb_hw_ep *pEnd = &(pThis->aLocalEnd[bEnd * 2]);
+	int nPipe = pUrb->pipe;
+	void *buffer = pUrb->transfer_buffer;
 
 	// MGC_SelectEnd(pBase, bEnd);
 	wRxCount = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCOUNT, bEnd);
 	DBG(3, "RX%d count %d, buffer %p len %d/%d\n", bEnd, wRxCount,
-			pUrb->transfer_buffer, pEnd->dwOffset,
-			pUrb->transfer_buffer_length);
+	    pUrb->transfer_buffer, pEnd->dwOffset,
+	    pUrb->transfer_buffer_length);
 
 	/* unload FIFO */
 	if (usb_pipeisoc(nPipe)) {
@@ -998,7 +594,6 @@ static u8 musb_host_packet_rx(struct mus
 	return bDone;
 }
 
-
 /*
  * Program an HDRC endpoint as per the given URB
  * @pThis: instance pointer
@@ -1010,8 +605,8 @@ static u8 musb_host_packet_rx(struct mus
  * Context: irqs blocked, controller lock held
  */
 static void musb_ep_program(struct musb *pThis, u8 bEnd,
-			       struct urb *pUrb, unsigned int is_out,
-			       u8 * pBuffer, u32 dwLength)
+			    struct urb *pUrb, unsigned int is_out,
+			    u8 * pBuffer, u32 dwLength)
 {
 	u16 wCsr, wLoadCount;
 #ifndef HOST_TX_DMA_SOLUTION
@@ -1020,7 +615,7 @@ static void musb_ep_program(struct musb 
 	struct usb_device *pParent;
 #ifndef	CONFIG_USB_INVENTRA_FIFO
 	struct dma_controller *pDmaController;
-	struct dma_channel *pDmaChannel;
+	struct dma_channel *pDmaChannel = NULL;
 	u8 bDmaOk;
 #endif
 	void __iomem *pBase = pThis->pRegs;
@@ -1031,7 +626,9 @@ static void musb_ep_program(struct musb 
 	u8 bRemoteEnd = (u8) usb_pipeendpoint(nPipe);
 	u8 bSpeed = (u8) pUrb->dev->speed;
 	u8 bInterval = (u8) pUrb->interval;
-	struct musb_hw_ep *pEnd = &(pThis->aLocalEnd[bEnd]);
+	struct musb_hw_ep *pEnd =
+	    &(pThis->
+	      aLocalEnd[(bEnd) ? (is_out) ? bEnd * 2 - 1 : bEnd * 2 : 0]);
 	u8 bStdType = 0;
 	u8 bHubAddr = 0;
 	u8 bHubPort = 0;
@@ -1044,18 +641,17 @@ static void musb_ep_program(struct musb 
 
 	/* set up tt info if needed */
 	if (pUrb->dev->tt) {
+		bHubAddr = (u8) pUrb->dev->tt->hub->devnum;
 		bHubPort = (u8) pUrb->dev->ttport;
 		bIsMulti = (u8) pUrb->dev->tt->multi;
 	}
 
 	DBG(3, "%s hw%d, urb %p, spd%d dev%d ep%d%s, "
-				"hub%d port%d%s, bytes %d\n",
-			is_out ? "-->" : "<--",
-			bEnd, pUrb, pUrb->dev->speed,
-			bAddress, bRemoteEnd, is_out ? "out" : "in",
-	    		bHubAddr, bHubPort + 1,
-			bIsMulti ? " multi" : "",
-			dwLength);
+	    "hub%d port%d%s, bytes %d\n",
+	    is_out ? "-->" : "<--",
+	    bEnd, pUrb, pUrb->dev->speed,
+	    bAddress, bRemoteEnd, is_out ? "out" : "in",
+	    bHubAddr, bHubPort + 1, bIsMulti ? " multi" : "", dwLength);
 
 	/* prepare endpoint registers according to flags */
 	if (usb_pipeisoc(nPipe)) {
@@ -1128,16 +724,15 @@ static void musb_ep_program(struct musb 
 
 	/* candidate for DMA */
 	if (is_dma_capable()
-			&& !usb_pipecontrol(nPipe)
-			&& pDmaController
-			) {
+	    && !usb_pipecontrol(nPipe)
+	    && pDmaController && pUrb->transfer_dma) {
 		bDmaOk = 1;
 		if (bDmaOk && !pDmaChannel)
 			pDmaChannel = pEnd->pDmaChannel =
-				pDmaController->pfDmaAllocateChannel(
-					    pDmaController->pPrivateData,
-					    bEnd, is_out ? TRUE : FALSE,
-					    bStdType, wPacketSize);
+			    pDmaController->
+			    pfDmaAllocateChannel(pDmaController->pPrivateData,
+						 bEnd, is_out ? TRUE : FALSE,
+						 bStdType, wPacketSize);
 
 		/* CPPI configures DMA later, and has no channel shortage */
 
@@ -1145,27 +740,36 @@ static void musb_ep_program(struct musb 
 		if (bDmaOk && pDmaChannel) {
 			pDmaChannel->dwActualLength = 0L;
 			pEnd->dwRequestSize = min(dwLength,
-					pDmaChannel->dwMaxLength);
-			bDmaOk = pDmaController->pfDmaProgramChannel(
-					pDmaChannel, wPacketSize,
-					pDmaChannel->bDesiredMode,
-					pUrb->transfer_dma,
-					pEnd->dwRequestSize);
+						  pDmaChannel->dwMaxLength);
+			bDmaOk =
+			    pDmaController->pfDmaProgramChannel(pDmaChannel,
+								wPacketSize,
+								pDmaChannel->
+								bDesiredMode,
+								pUrb->
+								transfer_dma,
+								pEnd->
+								dwRequestSize);
 			if (bDmaOk) {
 				wLoadCount = 0;
 			} else {
-				pDmaController->pfDmaReleaseChannel(
-						pDmaChannel);
+				pDmaController->
+				    pfDmaReleaseChannel(pDmaChannel);
 				pDmaChannel = pEnd->pDmaChannel = NULL;
 			}
 		}
 #endif
-	} else
+	} else {
+		pEnd->pDmaChannel = pDmaChannel = NULL;
 		bDmaOk = 0;
-#endif	/* PIO isn't the only option */
+	}
+#endif				/* PIO isn't the only option */
 
 	/* even RX side may need TXCSR, for MGC_M_TXCSR_MODE */
-	wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
+	if (bEnd)
+		wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
+	else
+		wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_CSR0, bEnd);
 
 	/* make sure we clear DMAEnab, autoSet bits from previous run */
 
@@ -1180,7 +784,7 @@ static void musb_ep_program(struct musb 
 		 * Host mode TX DMA does not function, stops with urb_unlink.
 		 *
 		 * Fixed MRs:
-		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
+		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
 		 *    to the Hub fails.
 		 */
 		/* disable interrupt in case we flush */
@@ -1193,39 +797,44 @@ static void musb_ep_program(struct musb 
 
 			/* general endpoint setup */
 			if (!pEnd->bIsReady) {
-				u16	csr = wCsr;
+				u16 csr = wCsr;
 
 				pEnd->bIsReady = TRUE;
 
 				/* flush all old state, set default */
 				csr &= ~(MGC_M_TXCSR_H_NAKTIMEOUT
-				  		| MGC_M_TXCSR_DMAMODE
-						| MGC_M_TXCSR_FRCDATATOG
-						| MGC_M_TXCSR_ISO
-						| MGC_M_TXCSR_H_RXSTALL
-						| MGC_M_TXCSR_H_ERROR
-						| MGC_M_TXCSR_FIFONOTEMPTY
-						| MGC_M_TXCSR_TXPKTRDY
-						);
-				csr |= MGC_M_TXCSR_FLUSHFIFO
-						| MGC_M_TXCSR_MODE;
+					 | MGC_M_TXCSR_DMAMODE
+					 | MGC_M_TXCSR_FRCDATATOG
+					 | MGC_M_TXCSR_ISO
+					 | MGC_M_TXCSR_H_RXSTALL
+					 | MGC_M_TXCSR_H_ERROR
+					 | MGC_M_TXCSR_FIFONOTEMPTY
+					 | MGC_M_TXCSR_TXPKTRDY);
+				if ((wCsr & MGC_M_TXCSR_TXPKTRDY) &&
+				    (wCsr & MGC_M_TXCSR_FIFONOTEMPTY)) {
+					WARN("tx%d, fifo full %x ?\n", bEnd,
+					     wCsr);
+					csr |= MGC_M_TXCSR_FLUSHFIFO;
+				}
+
+				csr |= MGC_M_TXCSR_MODE;
 
 				if (pEnd->out_traffic_type == PIPE_ISOCHRONOUS)
 					csr |= MGC_M_TXCSR_ISO;
 				else if (usb_gettoggle(pUrb->dev,
-						pEnd->bEnd, 1))
+						       pEnd->bEnd, 1))
 					csr |= MGC_M_TXCSR_H_WR_DATATOGGLE
-						| MGC_M_TXCSR_H_DATATOGGLE;
+					    | MGC_M_TXCSR_H_DATATOGGLE;
 				else
 					csr |= MGC_M_TXCSR_CLRDATATOG;
 
 				/* twice in case of double packet buffering */
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
-						csr);
+					       csr);
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
-						csr);
+					       csr);
 				wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR,
-						bEnd);
+						     bEnd);
 			}
 		} else {
 			/* endpoint 0: just flush */
@@ -1239,17 +848,17 @@ static void musb_ep_program(struct musb 
 		if (pThis->bIsMultipoint) {
 			/* target addr & hub addr/port */
 			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_TXFUNCADDR),
-				   bAddress);
+				    MGC_BUSCTL_OFFSET(bEnd,
+						      MGC_O_HDRC_TXFUNCADDR),
+				    bAddress);
 			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_TXHUBADDR),
-				   bIsMulti ? 0x80 | bHubAddr : bHubAddr);
+				    MGC_BUSCTL_OFFSET(bEnd,
+						      MGC_O_HDRC_TXHUBADDR),
+				    bIsMulti ? 0x80 | bHubAddr : bHubAddr);
 			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_TXHUBPORT),
-				   bHubPort);
+				    MGC_BUSCTL_OFFSET(bEnd,
+						      MGC_O_HDRC_TXHUBPORT),
+				    bHubPort);
 		} else {
 			/* non-multipoint core */
 			musb_writeb(pBase, MGC_O_HDRC_FADDR, bAddress);
@@ -1294,6 +903,7 @@ static void musb_ep_program(struct musb 
 
 		/* candidate for DMA */
 		if (bDmaOk && pDmaChannel) {
+			pEnd->fifo_flush_check = 0;
 
 			/* program endpoint CSRs first, then setup DMA.
 			 * assume CPPI setup succeeds.
@@ -1301,8 +911,7 @@ static void musb_ep_program(struct musb 
 			 */
 			wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 			wCsr &= ~(MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAMODE
-					| MGC_M_TXCSR_DMAENAB);
+				  | MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_DMAENAB);
 			wCsr |= MGC_M_TXCSR_MODE;
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
 				       wCsr | MGC_M_TXCSR_MODE);
@@ -1313,18 +922,24 @@ static void musb_ep_program(struct musb 
 			/* TX uses "rndis" mode automatically, but needs help
 			 * to identify the zero-length-final-packet case.
 			 */
-			bDmaOk = pDmaController->pfDmaProgramChannel(
-					pDmaChannel, wPacketSize,
-					(pUrb->transfer_flags
-							& URB_ZERO_PACKET)
-						== URB_ZERO_PACKET,
-					pUrb->transfer_dma,
-					pEnd->dwRequestSize);
+			bDmaOk =
+			    pDmaController->pfDmaProgramChannel(pDmaChannel,
+								wPacketSize,
+								(pUrb->
+								 transfer_flags
+								 &
+								 URB_ZERO_PACKET)
+								==
+								URB_ZERO_PACKET,
+								pUrb->
+								transfer_dma,
+								pEnd->
+								dwRequestSize);
 			if (bDmaOk) {
 				wLoadCount = 0;
 			} else {
-				pDmaController->pfDmaReleaseChannel(
-						pDmaChannel);
+				pDmaController->
+				    pfDmaReleaseChannel(pDmaChannel);
 				pDmaChannel = pEnd->pDmaChannel = NULL;
 
 				/* REVISIT there's an error path here that
@@ -1337,12 +952,10 @@ static void musb_ep_program(struct musb 
 		if (wLoadCount) {
 			/* PIO to load FIFO */
 			pEnd->dwRequestSize = wLoadCount;
-			musb_write_fifo(pEnd, wLoadCount,
-					 pBuffer);
+			musb_write_fifo(pEnd, wLoadCount, pBuffer);
 			wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
-			wCsr &=
-			    ~(MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_DMAMODE |
-			      MGC_M_TXCSR_AUTOSET);
+			wCsr &= ~(MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_DMAMODE |
+				  MGC_M_TXCSR_AUTOSET);
 			/* write CSR */
 			wCsr |= MGC_M_TXCSR_MODE;
 
@@ -1351,7 +964,6 @@ static void musb_ep_program(struct musb 
 					       wCsr);
 
 		}
-
 #ifndef HOST_TX_DMA_SOLUTION
 		/* Description: Do not disable endpoint interrupt because Host TX DMA
 		 *    uses DMAMODE = '1'.
@@ -1360,14 +972,14 @@ static void musb_ep_program(struct musb 
 		 * Host mode TX DMA does not function, stops with urb_unlink.
 		 *
 		 * Fixed MRs:
-		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
+		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
 		 *    to the Hub fails.
 		 */
 		/* re-enable interrupt */
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
 #endif
 
-	/* IN/receive */
+		/* IN/receive */
 	} else {
 		/* First retarget this EP hardware to the correct peripheral
 		 * endpoint.  Then activate the transfer (plus maybe dma).
@@ -1398,18 +1010,15 @@ static void musb_ep_program(struct musb 
 		/* address */
 		if (pThis->bIsMultipoint) {
 			/* target addr & hub addr/port */
-			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_RXFUNCADDR),
-				   bAddress);
-			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_RXHUBADDR),
-				   bIsMulti ? 0x80 | bHubAddr : bHubAddr);
-			musb_writeb(pBase,
-				   MGC_BUSCTL_OFFSET(bEnd,
-						     MGC_O_HDRC_RXHUBPORT),
-				   bHubPort);
+			musb_writeb(pBase, MGC_BUSCTL_OFFSET(bEnd,
+							     MGC_O_HDRC_RXFUNCADDR),
+				    bAddress);
+			musb_writeb(pBase, MGC_BUSCTL_OFFSET(bEnd,
+							     MGC_O_HDRC_RXHUBADDR),
+				    bIsMulti ? 0x80 | bHubAddr : bHubAddr);
+			musb_writeb(pBase, MGC_BUSCTL_OFFSET(bEnd,
+							     MGC_O_HDRC_RXHUBPORT),
+				    bHubPort);
 		} else {
 			/* non-multipoint core */
 			musb_writeb(pBase, MGC_O_HDRC_FADDR, bAddress);
@@ -1419,15 +1028,16 @@ static void musb_ep_program(struct musb 
 		if (bEnd) {
 			MGC_WriteCsr8(pBase, MGC_O_HDRC_RXTYPE, bEnd, reg);
 #if 0
-//#ifdef	C_MP_RX
+//#ifdef        C_MP_RX
 			/* doesn't work reliably */
 			if (bIsBulk && pThis->bBulkCombine) {
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_RXMAXP, bEnd,
-					       wPacketSize |
-					       ((min
-						 (pEnd->wMaxPacketSizeRx,
-						  dwLength) / wPacketSize) -
-						1) << 11);
+					       wPacketSize | ((min
+							       (pEnd->
+								wMaxPacketSizeRx,
+								dwLength) /
+							       wPacketSize) -
+							      1) << 11);
 			} else
 #endif
 			{
@@ -1448,36 +1058,36 @@ static void musb_ep_program(struct musb 
 		wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd);
 		if (wCsr & MGC_M_RXCSR_RXPKTRDY)
 			WARN("rx%d, packet/%d ready?\n", bEnd,
-				MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCOUNT, bEnd));
+			     MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCOUNT, bEnd));
 
 // SCRUB (RX)
 		/* twice in case of double packet buffering */
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-			       MGC_M_RXCSR_FLUSHFIFO |
-			       MGC_M_RXCSR_CLRDATATOG);
+			       MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_CLRDATATOG |
+			       MGC_M_RXCSR_RXPKTRDY);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-			       MGC_M_RXCSR_FLUSHFIFO |
-			       MGC_M_RXCSR_CLRDATATOG);
+			       MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_CLRDATATOG
+			       | MGC_M_RXCSR_RXPKTRDY);
 
 		if (usb_gettoggle(pUrb->dev, pEnd->bEnd, 0))
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-					MGC_M_RXCSR_H_WR_DATATOGGLE
-					| MGC_M_RXCSR_H_DATATOGGLE);
+				       MGC_M_RXCSR_H_WR_DATATOGGLE
+				       | MGC_M_RXCSR_H_DATATOGGLE |
+				       MGC_M_RXCSR_RXPKTRDY);
 
 		/* kick things off */
 		if (bEnd) {
-			int	 newcsr;
+			int newcsr;
 
 			newcsr = wCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR,
-					  bEnd);
+						      bEnd);
 			newcsr |= MGC_M_RXCSR_H_REQPKT;
 
 			/* scrub any stale state */
 			newcsr &= ~(MGC_M_CSR0_H_ERROR
-					| MGC_M_CSR0_H_RXSTALL
-					| MGC_M_CSR0_H_NAKTIMEOUT
-					| MGC_M_RXCSR_RXPKTRDY
-					);
+				    | MGC_M_CSR0_H_RXSTALL
+				    | MGC_M_CSR0_H_NAKTIMEOUT
+				    | MGC_M_RXCSR_RXPKTRDY);
 
 			if (usb_pipeint(nPipe))
 				newcsr |= MGC_M_RXCSR_DISNYET;
@@ -1486,11 +1096,11 @@ static void musb_ep_program(struct musb 
 			if (bDmaOk) {
 				newcsr &= ~MGC_M_RXCSR_H_REQPKT;
 				newcsr |= MGC_M_RXCSR_H_AUTOREQ;
-				newcsr |=
-				    (MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAENAB
-				     | (pDmaChannel->
-					bDesiredMode ? MGC_M_RXCSR_DMAMODE :
-					0));
+				newcsr |= (MGC_M_RXCSR_AUTOCLEAR |
+					   MGC_M_RXCSR_DMAENAB
+					   | (pDmaChannel->
+					      bDesiredMode ? MGC_M_RXCSR_DMAMODE
+					      : 0));
 			}
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 			/* candidate for DMA */
@@ -1500,42 +1110,47 @@ static void musb_ep_program(struct musb 
 
 				/* AUTOREQ is in a DMA register */
 				newcsr &= ~(MGC_M_RXCSR_AUTOCLEAR
-						| MGC_M_RXCSR_DMAMODE
-						| MGC_M_RXCSR_H_REQPKT
-						| MGC_M_RXCSR_H_AUTOREQ);
+					    | MGC_M_RXCSR_DMAMODE
+					    | MGC_M_RXCSR_H_REQPKT
+					    | MGC_M_RXCSR_H_AUTOREQ);
 				if (newcsr != wCsr) {
 					DBG(7, "RXCSR%d %04x\n", bEnd, newcsr);
 					MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR,
-							bEnd, newcsr);
+						       bEnd,
+						       newcsr |
+						       MGC_M_RXCSR_RXPKTRDY);
 				}
 
 				/* unless caller treats short rx transfers as
 				 * errors, we dare not queue multiple transfers.
 				 */
-				bDmaOk = pDmaController->pfDmaProgramChannel(
-						pDmaChannel, wPacketSize,
-						!(pUrb->transfer_flags
-							& URB_SHORT_NOT_OK),
-						pUrb->transfer_dma,
-						pEnd->dwRequestSize);
+				bDmaOk =
+				    pDmaController->
+				    pfDmaProgramChannel(pDmaChannel,
+							wPacketSize,
+							!(pUrb->
+							  transfer_flags &
+							  URB_SHORT_NOT_OK),
+							pUrb->transfer_dma,
+							pEnd->dwRequestSize);
 				if (!bDmaOk) {
-					pDmaController->pfDmaReleaseChannel(
-							pDmaChannel);
+					pDmaController->
+					    pfDmaReleaseChannel(pDmaChannel);
 					pDmaChannel = pEnd->pDmaChannel = NULL;
 					newcsr &= ~MGC_M_RXCSR_DMAENAB;
 					wCsr = MGC_ReadCsr16(pBase,
-							MGC_O_HDRC_RXCSR,
-							bEnd);
+							     MGC_O_HDRC_RXCSR,
+							     bEnd);
 				} else
 					newcsr |= MGC_M_RXCSR_DMAENAB
-						| MGC_M_RXCSR_H_REQPKT;
+					    | MGC_M_RXCSR_H_REQPKT;
 			}
 #endif
 			if (newcsr != wCsr) {
 				DBG(7, "RXCSR%d := %04x\n", bEnd, newcsr);
 				MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR,
-					bEnd,
-					MGC_M_RXCSR_H_WZC_BITS | newcsr);
+					       bEnd,
+					       MGC_M_RXCSR_H_WZC_BITS | newcsr);
 			}
 		}
 	}
@@ -1552,7 +1167,7 @@ void MGC_HdrcStopEnd(struct musb *pThis,
 	u16 wCsr;
 	void __iomem *pBase = pThis->pRegs;
 	const u8 reg = (bEnd) ? MGC_O_HDRC_RXCSR : MGC_O_HDRC_CSR0;
-	struct musb_hw_ep *hw_ep = pThis->aLocalEnd + bEnd;
+	struct musb_hw_ep *hw_ep = pThis->aLocalEnd + bEnd * 2;
 
 // REVISIT probably worth calling this in other places, once the
 // urb abort stuff is removed ...
@@ -1563,7 +1178,9 @@ void MGC_HdrcStopEnd(struct musb *pThis,
 	/* clear the pending request */
 	MGC_SelectEnd(pBase, bEnd);
 	wCsr = MGC_ReadCsr16(pBase, reg, bEnd);
-	wCsr &= (bEnd) ? ~MGC_M_RXCSR_H_REQPKT : ~MGC_M_CSR0_H_REQPKT;
+	wCsr &=
+	    (bEnd) ? (~MGC_M_RXCSR_H_REQPKT) | MGC_M_RXCSR_RXPKTRDY :
+	    ~MGC_M_CSR0_H_REQPKT;
 	MGC_WriteCsr16(pBase, reg, bEnd, wCsr);
 
 	while (!list_empty(&hw_ep->urb_list)) {
@@ -1588,8 +1205,7 @@ void MGC_HdrcStopEnd(struct musb *pThis,
  * @param pUrb URB pointer for EP0
  * @return TRUE if more packets are required for this transaction
  */
-static u8 musb_h_ep0_continue(struct musb *pThis,
-				     u16 wCount, struct urb *pUrb)
+static u8 musb_h_ep0_continue(struct musb *pThis, u16 wCount, struct urb *pUrb)
 {
 	u8 bMore = FALSE;
 	u8 *pFifoDest = NULL;
@@ -1602,11 +1218,13 @@ static u8 musb_h_ep0_continue(struct mus
 		/* we are receiving from peripheral */
 		pFifoDest = pUrb->transfer_buffer + pUrb->actual_length;
 		wFifoCount = min(wCount, ((u16)
-			 (pUrb->transfer_buffer_length - pUrb->actual_length)));
+					  (pUrb->transfer_buffer_length -
+					   pUrb->actual_length)));
 		if (wFifoCount < wCount)
 			pUrb->status = -EOVERFLOW;
 
-		musb_read_fifo(pEnd, wFifoCount, pFifoDest);
+		if (wFifoCount)
+			musb_read_fifo(pEnd, wFifoCount, pFifoDest);
 
 		pUrb->actual_length += wCount;
 		if (wCount < pEnd->wPacketSize) {
@@ -1614,11 +1232,10 @@ static u8 musb_h_ep0_continue(struct mus
 			 * rarely reported as an error.
 			 */
 			if ((pUrb->transfer_flags & URB_SHORT_NOT_OK)
-					&& (pUrb->actual_length <
-						pUrb->transfer_buffer_length))
+			    && (pUrb->actual_length <
+				pUrb->transfer_buffer_length))
 				pUrb->status = -EREMOTEIO;
-		} else if (pUrb->actual_length <
-				pUrb->transfer_buffer_length)
+		} else if (pUrb->actual_length < pUrb->transfer_buffer_length)
 			bMore = TRUE;
 	} else {
 		/* we are sending to peripheral */
@@ -1630,24 +1247,27 @@ static u8 musb_h_ep0_continue(struct mus
 			bMore = TRUE;
 
 		} else if (pRequest->wLength
-			   && (MGC_END0_START == pThis->bEnd0Stage)) {
+			   && ((MGC_END0_START == pThis->bEnd0Stage)
+			       || (pThis->bEnd0Stage == MGC_END0_OUT))
+			   && (pUrb->actual_length <
+			       pUrb->transfer_buffer_length)
+		    ) {
 			pThis->bEnd0Stage = MGC_END0_OUT;
 			pFifoDest = (u8 *) (pUrb->transfer_buffer +
-				    pUrb->actual_length);
-			wFifoCount =
-			    min(pEnd->wPacketSize,
-				((u16)
-				 (pUrb->transfer_buffer_length -
-				  pUrb->actual_length)));
+					    pUrb->actual_length);
+			wFifoCount = min(pEnd->wPacketSize, ((u16)
+							     (pUrb->
+							      transfer_buffer_length
+							      -
+							      pUrb->
+							      actual_length)));
 			DBG(3, "Sending %d bytes to %p\n", wFifoCount,
 			    pFifoDest);
 			musb_write_fifo(pEnd, wFifoCount, pFifoDest);
 
 			pEnd->dwRequestSize = wFifoCount;
 			pUrb->actual_length += wFifoCount;
-			if (pUrb->actual_length < pUrb->transfer_buffer_length) {
-				bMore = TRUE;
-			}
+			bMore = TRUE;
 		}
 	}
 
@@ -1660,15 +1280,16 @@ static u8 musb_h_ep0_continue(struct mus
  *
  * called with controller irqlocked
  */
-irqreturn_t musb_h_ep0_irq(struct musb *pThis)
+irqreturn_t musb_h_ep0_irq(struct musb * pThis)
 {
-	struct urb		*pUrb;
-	u16			wCsrVal, wCount;
-	int			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = &pThis->aLocalEnd[0];
-	u8			bComplete = FALSE;
-	irqreturn_t		retval = IRQ_NONE;
+	struct urb *pUrb;
+	u16 wCsrVal, wCount;
+	int status = 0;
+	void __iomem *pBase = pThis->pRegs;
+	struct musb_hw_ep *pEnd = &pThis->aLocalEnd[0];
+	u8 bComplete = FALSE;
+	irqreturn_t retval = IRQ_NONE;
+	u8 bInterval = 8;
 
 	/* ep0 only has one queue, "in" */
 	pUrb = next_in_urb(pEnd);
@@ -1741,9 +1362,9 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0, MGC_M_CSR0_FLUSHFIFO);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0, 0);
 
-		/* start next URB that might be queued for it */
-		musb_advance_urb_queue(pThis, pUrb, pEnd,
-				USB_DIR_IN);
+		/* start next URB that might be queued for it
+		   musb_advance_urb_queue(pThis, pUrb, pEnd,
+		   USB_DIR_IN); */
 		goto done;
 	}
 
@@ -1757,10 +1378,13 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		} else {
 			/* data transfer complete; perform status phase */
 			wCsrVal = MGC_M_CSR0_H_STATUSPKT |
-			    (usb_pipeout(pUrb->pipe) ? MGC_M_CSR0_H_REQPKT :
+			    ((usb_pipeout(pUrb->pipe)) ? MGC_M_CSR0_H_REQPKT :
 			     MGC_M_CSR0_TXPKTRDY);
 			/* flag status stage */
 			pThis->bEnd0Stage = MGC_END0_STATUS;
+			if (wCsrVal & MGC_M_CSR0_TXPKTRDY)
+				MGC_WriteCsr8(pBase, MGC_O_HDRC_NAKLIMIT0, 0,
+					      bInterval);
 
 			DBG(5, "ep0 STATUS, csr %04x\n", wCsrVal);
 
@@ -1772,25 +1396,24 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	/* call completion handler if done */
 	if (bComplete)
 		musb_advance_urb_queue(pThis, pUrb, pEnd,
-				usb_pipein(pUrb->pipe));
-done:
+				       usb_pipein(pUrb->pipe));
+      done:
 	return retval;
 }
 
-
 /* Service a Tx-Available or dma completion irq for the endpoint */
 void musb_host_tx(struct musb *pThis, u8 bEnd)
 {
-	int			nPipe;
-	u8			bDone = FALSE;
-	u16			wTxCsrVal;
-	size_t			wLength = 0;
-	u8			*pBuffer = NULL;
-	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
-	u32			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
-	struct dma_channel	*dma;
+	int nPipe;
+	u8 bDone = FALSE;
+	u16 wTxCsrVal;
+	size_t wLength = 0;
+	u8 *pBuffer = NULL;
+	struct urb *pUrb;
+	struct musb_hw_ep *pEnd = pThis->aLocalEnd + bEnd * 2 - 1;
+	u32 status = 0;
+	void __iomem *pBase = pThis->pRegs;
+	struct dma_channel *dma;
 
 	pUrb = next_out_urb(pEnd);
 
@@ -1801,29 +1424,32 @@ void musb_host_tx(struct musb *pThis, u8
 	// ... usually right after a cppi completion irq, dma enabled
 	// ... ideally, it's when the fifo empties after dma ...
 	if (!pUrb) {
-		DBG(4, "null urb, TXCSR%d = %04x\n", bEnd, wTxCsrVal);
+		DBG(1, "null urb, TXCSR%d = %04x\n", bEnd, wTxCsrVal);
 		goto finish;
 	}
 
 	nPipe = pUrb->pipe;
-	dma = is_dma_capable() ? pEnd->pDmaChannel : NULL;
-	DBG(4, "OUT/TX%d end, csr %04x%s\n", bEnd, wTxCsrVal,
-			dma ? ", dma" : "");
+	dma = is_dma_capable()? pEnd->pDmaChannel : NULL;
+	if (!pUrb->transfer_dma)
+		dma = 0;
+	if (pUrb->status == 0)
+		DBG(1, "OUT/TX%d end, csr %04x%s\n", bEnd, wTxCsrVal,
+		    dma ? ", dma" : "");
 
 	/* check for errors */
 	if (wTxCsrVal & MGC_M_TXCSR_H_RXSTALL) {
-		DBG(3, "TX end %d stall\n", bEnd);
+		DBG(1, "TX end %d stall\n", bEnd);
 
 		/* stall; record URB status */
 		status = -EPIPE;
 
 	} else if (wTxCsrVal & MGC_M_TXCSR_H_ERROR) {
-		DBG(3, "TX data error on ep=%d\n", bEnd);
+		DBG(1, "TX data error on ep=%d\n", bEnd);
 
 		status = -ETIMEDOUT;
 
 	} else if (wTxCsrVal & MGC_M_TXCSR_H_NAKTIMEOUT) {
-		DBG(6, "TX end=%d device not responding\n", bEnd);
+		DBG(1, "TX end=%d device not responding\n", bEnd);
 
 		/* NOTE:  this code path would be a good place to PAUSE a
 		 * transfer, if there's some other (nonperiodic) tx urb
@@ -1831,15 +1457,14 @@ void musb_host_tx(struct musb *pThis, u8
 		 */
 		MGC_SelectEnd(pBase, bEnd);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
-				MGC_M_TXCSR_H_WZC_BITS
-				| MGC_M_TXCSR_TXPKTRDY);
+			       MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
 		goto finish;
 	}
 
 	if (status) {
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->pfDmaAbortChannel(dma);
+			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 		}
 
 		/* do the proper sequence to abort the transfer in the
@@ -1847,11 +1472,10 @@ void musb_host_tx(struct musb *pThis, u8
 		 */
 // SCRUB (TX)
 		wTxCsrVal &= ~(MGC_M_TXCSR_FIFONOTEMPTY
-				| MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_H_ERROR
-				| MGC_M_TXCSR_H_RXSTALL
-				| MGC_M_TXCSR_H_NAKTIMEOUT
-				);
+			       | MGC_M_TXCSR_AUTOSET
+			       | MGC_M_TXCSR_H_ERROR
+			       | MGC_M_TXCSR_H_RXSTALL
+			       | MGC_M_TXCSR_H_NAKTIMEOUT);
 		wTxCsrVal |= MGC_M_TXCSR_FLUSHFIFO;
 
 		MGC_SelectEnd(pBase, bEnd);
@@ -1879,7 +1503,7 @@ void musb_host_tx(struct musb *pThis, u8
 		pEnd->dwOffset += wLength;
 
 		if (usb_pipeisoc(nPipe)) {
-			struct usb_iso_packet_descriptor	*d;
+			struct usb_iso_packet_descriptor *d;
 
 			d = pUrb->iso_frame_desc + pEnd->dwIsoPacket;
 			d->actual_length = pEnd->dwRequestSize;
@@ -1897,14 +1521,13 @@ void musb_host_tx(struct musb *pThis, u8
 			if (pEnd->dwRequestSize < pEnd->wPacketSize)
 				bDone = TRUE;
 			else if (pEnd->dwOffset == pUrb->transfer_buffer_length
-					&& !(pUrb-> transfer_flags
-							& URB_ZERO_PACKET))
+				 && !(pUrb->transfer_flags & URB_ZERO_PACKET))
 				bDone = TRUE;
 			if (!bDone) {
 				pBuffer = pUrb->transfer_buffer
-						+ pEnd->dwOffset;
+				    + pEnd->dwOffset;
 				wLength = pUrb->transfer_buffer_length
-						- pEnd->dwOffset;
+				    - pEnd->dwOffset;
 			}
 		}
 	}
@@ -1914,17 +1537,20 @@ void musb_host_tx(struct musb *pThis, u8
 	 */
 	if (pUrb->status != -EINPROGRESS) {
 		bDone = TRUE;
-		if (status == 0)
+		if (status == 0) {
 			status = pUrb->status;
+		}
 	}
 
 	if (bDone) {
 		/* set status */
 		pUrb->status = status;
 		pUrb->actual_length = pEnd->dwOffset;
-
+#ifdef HOST_TX_DMA_SOLUTION
+		musb_tx_tasklet_invoke(pThis, pEnd);
+#else
 		musb_advance_urb_queue(pThis, pUrb, pEnd, USB_DIR_OUT);
-
+#endif
 	} else if (!(wTxCsrVal & MGC_M_TXCSR_DMAENAB)) {
 		// WARN_ON(!pBuffer);
 
@@ -1935,11 +1561,11 @@ void musb_host_tx(struct musb *pThis, u8
 
 		MGC_SelectEnd(pBase, bEnd);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd,
-				MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
+			       MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
 	} else
 		DBG(1, "not complete, but dma enabled?\n");
 
-finish:
+      finish:
 	return;
 }
 
@@ -1952,21 +1578,21 @@ finish:
  */
 void musb_host_rx(struct musb *pThis, u8 bEnd)
 {
-	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = &(pThis->aLocalEnd[bEnd]);
-	size_t			xfer_len;
-	void __iomem		*pBase = pThis->pRegs;
-	int			nPipe;
-	u16			wRxCsrVal, wVal;
-	u8			bIsochError = FALSE;
-	u8			bDone = FALSE;
-	u32			status;
-	struct dma_channel	*dma;
+	struct urb *pUrb;
+	struct musb_hw_ep *pEnd = &(pThis->aLocalEnd[bEnd * 2]);
+	size_t xfer_len;
+	void __iomem *pBase = pThis->pRegs;
+	int nPipe;
+	u16 wRxCsrVal, wVal;
+	u8 bIsochError = FALSE;
+	u8 bDone = FALSE;
+	u32 status;
+	struct dma_channel *dma;
 
 	MGC_SelectEnd(pBase, bEnd);
 
 	pUrb = next_in_urb(pEnd);
-	dma = is_dma_capable() ? pEnd->pDmaChannel : NULL;
+	dma = is_dma_capable()? pEnd->pDmaChannel : NULL;
 	status = 0;
 	xfer_len = 0;
 
@@ -1981,8 +1607,7 @@ void musb_host_rx(struct musb *pThis, u8
 	nPipe = pUrb->pipe;
 
 	DBG(5, "<== hw %d rxcsr %04x, urb actual %d (+dma %d)\n", bEnd,
-	    wRxCsrVal, pUrb->actual_length,
-	    dma ? dma->dwActualLength : 0);
+	    wRxCsrVal, pUrb->actual_length, dma ? dma->dwActualLength : 0);
 
 	/* check for errors, concurrent stall & unlink is not really
 	 * handled yet! */
@@ -2008,8 +1633,8 @@ void musb_host_rx(struct musb *pThis, u8
 			DBG(6, "RX end=%d device not responding\n", bEnd);
 			MGC_SelectEnd(pBase, bEnd);
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-					MGC_M_RXCSR_H_WZC_BITS
-					| MGC_M_RXCSR_H_REQPKT);
+				       MGC_M_RXCSR_H_WZC_BITS
+				       | MGC_M_RXCSR_H_REQPKT);
 
 			goto finish;
 		} else {
@@ -2023,20 +1648,19 @@ void musb_host_rx(struct musb *pThis, u8
 		/* clean up dma and collect transfer count */
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->pfDmaAbortChannel(dma);
+			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 			xfer_len = dma->dwActualLength;
 		}
 	}
 
 	if (status) {
 		wVal &= ~(MGC_M_RXCSR_H_ERROR
-			| MGC_M_RXCSR_DATAERROR
-			| MGC_M_RXCSR_H_RXSTALL
-			| MGC_M_RXCSR_RXPKTRDY
-			| MGC_M_RXCSR_H_REQPKT
-			);
+			  | MGC_M_RXCSR_DATAERROR
+			  | MGC_M_RXCSR_H_RXSTALL
+			  | MGC_M_RXCSR_RXPKTRDY | MGC_M_RXCSR_H_REQPKT);
 		MGC_SelectEnd(pBase, bEnd);
-		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
+		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
+			       wVal | MGC_M_RXCSR_RXPKTRDY);
 		MGC_WriteCsr8(pBase, MGC_O_HDRC_RXINTERVAL, bEnd, 0);
 
 		bDone = TRUE;
@@ -2048,41 +1672,40 @@ void musb_host_rx(struct musb *pThis, u8
 		goto finish;
 	}
 
-
 	/* thorough shutdown for now ... given more precise fault handling
 	 * and better queueing support, we might keep a DMA pipeline going
 	 * while processing this irq for earlier completions.
 	 */
 
-	if (wRxCsrVal & MGC_M_RXCSR_H_REQPKT)  {
+	if (wRxCsrVal & MGC_M_RXCSR_H_REQPKT) {
 		/* REVISIT this happened for a while on some short reads...
 		 * the cleanup still needs investigation... looks bad...
 		 * and also duplicates dma cleanup code above ...
 		 */
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->pfDmaAbortChannel(dma);
+			(void)pThis->pDmaController->pfDmaAbortChannel(dma);
 			xfer_len = dma->dwActualLength;
 		}
 
 		DBG(3, "RXCSR%d %04x, reqpkt, len %d%s\n", bEnd, wRxCsrVal,
-				xfer_len, dma ? ", dma" : "");
+		    xfer_len, dma ? ", dma" : "");
 		wRxCsrVal &= ~MGC_M_RXCSR_H_REQPKT;
 
 		MGC_SelectEnd(pBase, bEnd);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
+			       MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
 	}
 
 	if (dma && (wRxCsrVal & MGC_M_RXCSR_DMAENAB)) {
 #if 0
 		wRxCsrVal &= ~MGC_M_RXCSR_DMAENAB;
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
+			       MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
-				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
+			       MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
 		DBG(4, "RXCSR%d %04x, dma off, %04x\n", bEnd, wRxCsrVal,
-				MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd));
+		    MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd));
 #endif
 		bDone = TRUE;
 		xfer_len = dma->dwActualLength;
@@ -2092,7 +1715,7 @@ void musb_host_rx(struct musb *pThis, u8
 		/* if no errors, be sure a packet is ready for unloading */
 		if (!(wRxCsrVal & MGC_M_RXCSR_RXPKTRDY)) {
 			status = -EPROTO;
-DBG(1, "Rx interrupt with no errors or packet!\n");
+			DBG(1, "Rx interrupt with no errors or packet!\n");
 
 			// FIXME this is another "SHOULD NEVER HAPPEN"
 			// like the "no URB" case below
@@ -2101,14 +1724,15 @@ DBG(1, "Rx interrupt with no errors or p
 			/* do the proper sequence to abort the transfer */
 			MGC_SelectEnd(pBase, bEnd);
 			wVal &= ~MGC_M_RXCSR_H_REQPKT;
-			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
+			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
+				       wVal | MGC_M_RXCSR_RXPKTRDY);
 		}
 
 		/* we are expecting IN packets */
 		if (pUrb) {
 			if (!bDone) {
 				bDone = musb_host_packet_rx(pThis, pUrb,
-						bEnd, bIsochError);
+							    bEnd, bIsochError);
 				DBG(6, "read %spacket\n", bDone ? "last " : "");
 			}
 		} else {
@@ -2120,8 +1744,10 @@ DBG(1, "Rx interrupt with no errors or p
 			MGC_SelectEnd(pBase, bEnd);
 			wVal |= MGC_M_RXCSR_FLUSHFIFO;
 			wVal &= ~MGC_M_RXCSR_H_REQPKT;
-			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
-			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
+			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
+				       wVal | MGC_M_RXCSR_RXPKTRDY);
+			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd,
+				       wVal | MGC_M_RXCSR_RXPKTRDY);
 
 			wVal &= ~(MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_RXPKTRDY);
 			MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
@@ -2147,10 +1773,10 @@ DBG(1, "Rx interrupt with no errors or p
 		MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd, wVal);
 	}
 
-finish:
+      finish:
 	return;
 
-advance:
+      advance:
 	musb_advance_urb_queue(pThis, pUrb, pEnd, USB_DIR_IN);
 	return;
 }
@@ -2160,17 +1786,17 @@ advance:
  */
 static struct musb_hw_ep *musb_find_ep(struct musb *pThis, struct urb *pUrb)
 {
-	unsigned int	pipe = pUrb->pipe;
-	unsigned int	nOut;
+	unsigned int pipe = pUrb->pipe;
+	unsigned int nOut;
 	struct musb_hw_ep *pEnd;
-	unsigned long	flags;
-	int		nEnd;
-	s32		dwDiff;
-	u16		wBestDiff;
-	int		nBestEnd;
-	u16		wPacketSize;
-	u8		bEnd;
-	u8		bAddress;
+	unsigned long flags;
+	int nEnd;
+	s32 dwDiff;
+	u16 wBestDiff;
+	int nBestEnd;
+	u16 wPacketSize;
+	u8 bEnd;
+	u8 bAddress;
 
 	/* control is always EP0 */
 	if (usb_pipecontrol(pipe))
@@ -2178,14 +1804,6 @@ static struct musb_hw_ep *musb_find_ep(s
 
 	nOut = usb_pipeout(pipe);
 
-	/* bulk uses reserved endpoints too (policy choice) */
-	if (usb_pipebulk(pipe)) {
-		if (nOut)
-			return pThis->bulk_tx_end;
-		else
-			return pThis->bulk_rx_end;
-	}
-
 	wBestDiff = 0xffff;
 	nBestEnd = -1;
 	wPacketSize = usb_maxpacket(pUrb->dev, pipe, nOut);
@@ -2199,32 +1817,35 @@ static struct musb_hw_ep *musb_find_ep(s
 
 	/* for periodic, use exact match or something ok but unclaimed */
 	spin_lock_irqsave(&pThis->Lock, flags);
-	for (nEnd = 1; nEnd < pThis->bEndCount; nEnd++) {
-		u8	type;
+	for (nEnd = (nOut) ? 1 : 2; nEnd < pThis->bEndCount; nEnd += 2) {
+		u8 type;
 
 		pEnd = &pThis->aLocalEnd[nEnd];
 		if (nOut) {
-			if (pEnd == pThis->bulk_tx_end)
+			if ((pEnd == pThis->bulk_tx_end) &&
+			    (!usb_pipebulk(pipe)))
 				continue;
+
 			if (pEnd->wMaxPacketSizeTx < wPacketSize)
 				continue;
 			dwDiff = pEnd->wMaxPacketSizeTx - wPacketSize;
 		} else {
-			if (pEnd == pThis->bulk_rx_end)
+			if ((pEnd == pThis->bulk_rx_end) &&
+			    (!usb_pipebulk(pipe)))
 				continue;
+
 			if (pEnd->wMaxPacketSizeRx < wPacketSize)
 				continue;
 			dwDiff = pEnd->wMaxPacketSizeRx - wPacketSize;
 		}
 
 		type = usb_pipein(pipe)
-				? pEnd->in_traffic_type
-				: pEnd->out_traffic_type;
+		    ? pEnd->in_traffic_type : pEnd->out_traffic_type;
 
 		/* exact match */
 		if ((usb_pipetype(pipe) == type)
-				&& (pEnd->bEnd == bEnd)
-				&& (pEnd->bAddress == bAddress)) {
+		    && (pEnd->bEnd == bEnd)
+		    && (pEnd->bAddress == bAddress)) {
 			nBestEnd = nEnd;
 			break;
 		}
@@ -2239,11 +1860,31 @@ static struct musb_hw_ep *musb_find_ep(s
 
 	DBG(4, "(out=%d, size=%d, proto=%d, addr=%d, end=%d, urb=%lx) = %d\n",
 	    nOut, wPacketSize, usb_pipetype(pipe),
-	    bAddress, bEnd, (unsigned long)pUrb,
-	    nBestEnd);
+	    bAddress, bEnd, (unsigned long)pUrb, nBestEnd);
+
+	if (nBestEnd >= 0) {
+		pEnd = pThis->aLocalEnd + nBestEnd;
+		if ((pEnd != pThis->bulk_tx_end)
+		    && (pEnd != pThis->bulk_rx_end)) {
+			if (nOut)
+				pEnd->out_traffic_type = usb_pipetype(pipe);
+			else
+				pEnd->in_traffic_type = usb_pipetype(pipe);
+		} else {
+			if (!usb_pipebulk(pipe))
+				return NULL;
+		}
 
-	if (nBestEnd >= 0)
 		return pThis->aLocalEnd + nBestEnd;
+	} else {
+		if (usb_pipebulk(pipe)) {
+			if (nOut)
+				return pThis->bulk_tx_end;
+			else
+				return pThis->bulk_rx_end;
+		}
+	}
+
 	return NULL;
 }
 
@@ -2259,13 +1900,13 @@ static struct musb_hw_ep *musb_find_ep(s
  */
 static int musb_submit_urb(struct urb *pUrb, gfp_t iMemFlags)
 {
-	unsigned long		flags;
-	unsigned int		pipe = pUrb->pipe;
-	struct musb_hw_ep	*pEnd;
-	struct musb		*pThis;
-	int			nEnd, idle = 0;
-	int			status;
-	enum dma_data_direction	maptype = DMA_NONE;
+	unsigned long flags;
+	unsigned int pipe = pUrb->pipe;
+	struct musb_hw_ep *pEnd;
+	struct musb *pThis;
+	int nEnd, idle = 0;
+	int status;
+	enum dma_data_direction maptype = DMA_NONE;
 
 	pThis = pUrb->dev->bus->hcpriv;
 
@@ -2286,26 +1927,28 @@ static int musb_submit_urb(struct urb *p
 	nEnd = pEnd->bLocalEnd;
 
 	DBG(6, "pUrb=%p, end=%d, bufsize=%d\n",
-			pUrb, nEnd, pUrb->transfer_buffer_length);
+	    pUrb, nEnd, pUrb->transfer_buffer_length);
 
 	/* setup DMA mapping, if needed (does dcache sync)
 	 * insist on either a PIO or DMA buffer
 	 */
 	if (is_dma_capable()
-			&& nEnd
-			&& pThis->controller->dma_mask
-			&& pUrb->transfer_buffer_length >= MIN_DMA_REQUEST) {
+	    && nEnd && pThis->controller->dma_mask
+	    /*&& pUrb->transfer_buffer_length >= MIN_DMA_REQUEST) { */
+	    /* To be removed later on completion of restructuring */
+	    && pUrb->transfer_buffer_length >= 1) {
 		if (!(pUrb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)) {
 			maptype = usb_pipein(pipe)
-						? DMA_FROM_DEVICE
-						: DMA_TO_DEVICE;
+			    ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
 			pUrb->transfer_dma = dma_map_single(pThis->controller,
-					pUrb->transfer_buffer,
-					pUrb-> transfer_buffer_length,
-					maptype);
+							    pUrb->
+							    transfer_buffer,
+							    pUrb->
+							    transfer_buffer_length,
+							    maptype);
 		}
 	} else if (pUrb->transfer_buffer == NULL
-			&& pUrb->transfer_buffer_length != 0) {
+		   && pUrb->transfer_buffer_length != 0) {
 		/* FIXME release pEnd claim, for periodic endpoint */
 		return -EINVAL;
 	} else
@@ -2325,7 +1968,7 @@ static int musb_submit_urb(struct urb *p
 	 */
 	if (usb_pipeisoc(pipe) || usb_pipeint(pipe)) {
 		pUrb->start_frame = musb_readw(pThis->pRegs, MGC_O_HDRC_FRAME)
-				+ pUrb->interval;
+		    + pUrb->interval;
 	}
 
 	/* FIXME for reserved bulk endpoints, stick it in the relevant
@@ -2335,7 +1978,7 @@ static int musb_submit_urb(struct urb *p
 	DBG(6, "end %d claimed for type=%d, addr=%d, end=%d\n", nEnd,
 	    usb_pipetype(pipe), usb_pipedevice(pipe), usb_pipeendpoint(pipe));
 
-	pEnd = &(pThis->aLocalEnd[nEnd]);
+	/*pEnd = &(pThis->aLocalEnd[nEnd]); */
 
 	/* increment reference counts, neither urb nor device may vanish yet */
 	pUrb = usb_get_urb(pUrb);
@@ -2370,47 +2013,43 @@ static int musb_submit_urb(struct urb *p
 	}
 
 	DBG(4, "submit %p hw%d, dev%d ep%d%s, len %d\n",
-			pUrb, nEnd,
-			usb_pipedevice(pipe),
-			usb_pipeendpoint(pipe),
-			usb_pipein(pipe) ? "in" : "out",
-			pUrb->transfer_buffer_length
-			);
-
+	    pUrb, nEnd,
+	    usb_pipedevice(pipe),
+	    usb_pipeendpoint(pipe),
+	    usb_pipein(pipe) ? "in" : "out", pUrb->transfer_buffer_length);
 
 	if (idle)
 		musb_start_urb(pThis, pEnd);
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 
 	return status;
-unmap:
+      unmap:
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 	if (is_dma_capable() && maptype != DMA_NONE)
 		dma_unmap_single(pThis->controller, pUrb->transfer_dma,
-				pUrb->transfer_buffer_length,
-				maptype);
+				 pUrb->transfer_buffer_length, maptype);
 	return status;
 }
 
-
 /*
  * abort a transfer that's at the head of a hardware queue.
  * called with controller locked, irqs blocked
  */
 static int musb_cleanup_urb(struct urb *urb, struct musb_hw_ep *ep, int is_in)
 {
-	unsigned	hw_end = ep->bLocalEnd;
-	void __iomem	*regs = ep->musb->pRegs;
-	u16		csr;
-	int		status = 0;
+	unsigned hw_end = ep->bLocalEnd;
+	void __iomem *regs = ep->musb->pRegs;
+	u16 csr;
+	int status = 0;
 
 	MGC_SelectEnd(ep->musb->pRegs, hw_end);
 
 	if (is_dma_capable() && ep->pDmaChannel) {
-		status = ep->musb->pDmaController->pfDmaAbortChannel(
-				ep->pDmaChannel);
+		status =
+		    ep->musb->pDmaController->pfDmaAbortChannel(ep->
+								pDmaChannel);
 		DBG(status ? 1 : 3, "abort %cX%d DMA for urb %p --> %d\n",
-			is_in ? 'R' : 'T', ep->bLocalEnd, urb, status);
+		    is_in ? 'R' : 'T', ep->bLocalEnd, urb, status);
 	}
 
 	/* turn off DMA requests, discard state, stop polling ... */
@@ -2418,30 +2057,27 @@ static int musb_cleanup_urb(struct urb *
 
 // SCRUB (RX)
 		csr = MGC_ReadCsr16(regs, MGC_O_HDRC_RXCSR, hw_end);
-		csr &= ~( MGC_M_RXCSR_AUTOCLEAR
-			| MGC_M_RXCSR_H_AUTOREQ
-			| MGC_M_RXCSR_H_REQPKT
-			| MGC_M_RXCSR_H_RXSTALL
-			| MGC_M_RXCSR_DATAERROR
-			| MGC_M_RXCSR_H_ERROR
-			| MGC_M_RXCSR_RXPKTRDY
-			);
+		csr &= ~(MGC_M_RXCSR_AUTOCLEAR
+			 | MGC_M_RXCSR_H_AUTOREQ
+			 | MGC_M_RXCSR_H_REQPKT
+			 | MGC_M_RXCSR_H_RXSTALL
+			 | MGC_M_RXCSR_DATAERROR
+			 | MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_RXPKTRDY);
 		csr |= MGC_M_RXCSR_FLUSHFIFO;
 		MGC_WriteCsr16(regs, MGC_O_HDRC_RXCSR, 0, csr);
 		MGC_WriteCsr16(regs, MGC_O_HDRC_RXCSR, 0, csr);
 	} else {
 // SCRUB (TX)
 		csr = MGC_ReadCsr16(regs, MGC_O_HDRC_TXCSR, hw_end);
-		csr &= ~( MGC_M_TXCSR_AUTOSET
-			| MGC_M_TXCSR_H_RXSTALL
-			| MGC_M_TXCSR_H_NAKTIMEOUT
-			| MGC_M_TXCSR_H_ERROR
-			| MGC_M_TXCSR_FIFONOTEMPTY
-			| MGC_M_TXCSR_TXPKTRDY
-			);
+		csr &= ~(MGC_M_TXCSR_AUTOSET
+			 | MGC_M_TXCSR_H_RXSTALL
+			 | MGC_M_TXCSR_H_NAKTIMEOUT
+			 | MGC_M_TXCSR_H_ERROR
+			 | MGC_M_TXCSR_FIFONOTEMPTY | MGC_M_TXCSR_TXPKTRDY);
 		csr |= MGC_M_TXCSR_FLUSHFIFO;
 		MGC_WriteCsr16(regs, MGC_O_HDRC_TXCSR, 0, csr);
 		MGC_WriteCsr16(regs, MGC_O_HDRC_TXCSR, 0, csr);
+		ep->fifo_flush_check = 0;
 	}
 	if (status == 0)
 		musb_giveback(ep, urb, 0);
@@ -2454,15 +2090,16 @@ static int musb_cleanup_urb(struct urb *
  */
 static int musb_unlink_urb(struct urb *pUrb, int status)
 {
-	struct musb		*musb;
-	struct musb_hw_ep	*ep;
-	unsigned		i;
-	unsigned long		flags;
+	struct musb *musb;
+	struct musb_hw_ep *ep;
+	unsigned i;
+	unsigned long flags;
+	u8 busy = 0, is_in = pUrb->pipe & USB_DIR_IN;
 
 	DBG(4, "urb=%p, dev%d ep%d%s\n", pUrb,
-			usb_pipedevice(pUrb->pipe),
-			usb_pipeendpoint(pUrb->pipe),
-			usb_pipein(pUrb->pipe) ? "in" : "out");
+	    usb_pipedevice(pUrb->pipe),
+	    usb_pipeendpoint(pUrb->pipe),
+	    usb_pipein(pUrb->pipe) ? "in" : "out");
 
 	/* sanity */
 	if (!pUrb || !pUrb->hcpriv)
@@ -2475,8 +2112,8 @@ static int musb_unlink_urb(struct urb *p
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
-	for (i = 0, ep = musb->aLocalEnd; i < MUSB_C_NUM_EPS; i++, ep++)  {
-		struct urb		*urb;
+	for (i = 0, ep = musb->aLocalEnd; i < MUSB_C_NUM_EPS; i++, ep++) {
+		struct urb *urb;
 
 		list_for_each_entry(urb, &ep->urb_list, urb_list) {
 			if (urb == pUrb)
@@ -2486,7 +2123,7 @@ static int musb_unlink_urb(struct urb *p
 	status = -ENOENT;
 	goto done;
 
-found:
+      found:
 	spin_lock(&pUrb->lock);
 	if (pUrb->hcpriv != ep)
 		status = -ENOENT;
@@ -2501,6 +2138,9 @@ found:
 	if (status)
 		goto done;
 
+	busy = (is_in) ? ep->in_busy : ep->out_busy;
+	busy = (busy) ? ((is_in) ? (pUrb == next_in_urb(ep)) :
+			 (pUrb == next_out_urb(ep))) : 0;
 	/* if it is a request to the root hub, delegate */
 	if (pUrb->dev == musb->RootHub.pDevice) {
 		spin_unlock_irqrestore(&musb->Lock, flags);
@@ -2511,17 +2151,17 @@ found:
 	/* anything not at the head of the queue can just be given back,
 	 * else cleanup pending dma etc
 	 */
-	if (pUrb->urb_list.prev != &ep->urb_list) {
+	if (busy) {
+		status = musb_cleanup_urb(pUrb, ep, pUrb->pipe & USB_DIR_IN);
+		if (!list_empty(&ep->urb_list)) {
+			musb_start_urb(musb, ep);
+		}
+	} else {
 		musb_giveback(ep, pUrb, 0);
 		status = 0;
-	} else {
-		status = musb_cleanup_urb(pUrb, ep, pUrb->pipe & USB_DIR_IN);
-		/* FIXME still needs to restart this queue... it
-		 * may have pending transfers for other endpoints
-		 */
 	}
 
-done:
+      done:
 	spin_unlock_irqrestore(&musb->Lock, flags);
 	return status;
 }
@@ -2532,13 +2172,13 @@ done:
 /* disable an endpoint */
 static void musb_h_disable(struct usb_device *udev, int epnum)
 {
-	unsigned long		flags;
-	struct musb		*musb = udev->bus->hcpriv;
-	struct musb_hw_ep	*ep;
-	unsigned		i;
-	unsigned		do_wait = 0;
-	u8			is_in = epnum & USB_DIR_IN;
-	u8			epn = epnum & 0x0f;
+	unsigned long flags;
+	struct musb *musb = udev->bus->hcpriv;
+	struct musb_hw_ep *ep;
+	unsigned i;
+	unsigned do_wait = 0;
+	u8 is_in = epnum & USB_DIR_IN;
+	u8 epn = epnum & 0x0f;
 
 	/* FIXME 2.6.current passes "struct usb_host_endpoint *hep" as the
 	 * parameter, not "epnum" ... and the endpoint's URBs are provided
@@ -2549,18 +2189,17 @@ static void musb_h_disable(struct usb_de
 	spin_lock_irqsave(&musb->Lock, flags);
 
 	/* more current 2.6 kernels make this much simpler! */
-	for (i = 0, ep = musb->aLocalEnd; i < MUSB_C_NUM_EPS; i++, ep++)  {
-		struct urb		*urb;
-		unsigned		pipe;
+	for (i = 0, ep = musb->aLocalEnd; i < MUSB_C_NUM_EPS; i++, ep++) {
+		struct urb *urb;
+		unsigned pipe;
 
-rescan:
+	      rescan:
 		list_for_each_entry(urb, &ep->urb_list, urb_list) {
 #if 0
-dev_dbg(&udev->dev,
-	"disable epnum %02x ... hw%d urb %p head %p (n%p p%p) ?\n",
-	epnum, i, urb, &ep->urb_list,
-	urb->urb_list.next, urb->urb_list.prev
-	);
+			dev_dbg(&udev->dev,
+				"disable epnum %02x ... hw%d urb %p head %p (n%p p%p) ?\n",
+				epnum, i, urb, &ep->urb_list,
+				urb->urb_list.next, urb->urb_list.prev);
 #endif
 			if (urb->dev != udev)
 				continue;
@@ -2618,14 +2257,13 @@ dev_dbg(&udev->dev,
 }
 
 static void *musb_host_alloc_buffer(struct usb_bus *pBus, size_t nSize,
-				  gfp_t iMemFlags, dma_addr_t * pDmaAddress)
+				    gfp_t iMemFlags, dma_addr_t * pDmaAddress)
 {
-	return musb_alloc_buffer(pBus->hcpriv, nSize,
-			iMemFlags, pDmaAddress);
+	return musb_alloc_buffer(pBus->hcpriv, nSize, iMemFlags, pDmaAddress);
 }
 
 static void musb_host_free_buffer(struct usb_bus *pBus, size_t nSize,
-				void *address, dma_addr_t dma)
+				  void *address, dma_addr_t dma)
 {
 	musb_free_buffer(pBus->hcpriv, nSize, address, dma);
 }
@@ -2637,7 +2275,7 @@ static void musb_host_free_buffer(struct
  */
 static int musb_h_get_frame_number(struct usb_device *pDevice)
 {
-	struct musb	*pThis = pDevice->bus->hcpriv;
+	struct musb *pThis = pDevice->bus->hcpriv;
 
 	return musb_readw(pThis->pRegs, MGC_O_HDRC_FRAME);
 }
@@ -2651,10 +2289,10 @@ static int musb_h_get_frame_number(struc
  * handle around; "struct hcd_dev" is gone.
  */
 struct usb_operations musb_host_bus_ops = {
-	.get_frame_number	= musb_h_get_frame_number,
-	.submit_urb		= musb_submit_urb,
-	.unlink_urb		= musb_unlink_urb,
-	.buffer_alloc		= musb_host_alloc_buffer,
-	.buffer_free		= musb_host_free_buffer,
-	.disable		= musb_h_disable,
+	.get_frame_number = musb_h_get_frame_number,
+	.submit_urb = musb_submit_urb,
+	.unlink_urb = musb_unlink_urb,
+	.buffer_alloc = musb_host_alloc_buffer,
+	.buffer_free = musb_host_free_buffer,
+	.disable = musb_h_disable,
 };
Index: linux-2.6.10/drivers/usb/musb/musb_host.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.h
+++ linux-2.6.10/drivers/usb/musb/musb_host.h
@@ -38,46 +38,45 @@
  * during transfers to the peripheral endpoint addressed by urb->pipe.
  */
 struct musb_host_ep {
-	unsigned		tx:1;
+	unsigned tx:1;
 
-	unsigned		claimed:1;	/* unavailable for binding? */
-	unsigned		busy:1;		/* unsafe to touch hw? */
-	unsigned		ready:1;
+	unsigned claimed:1;	/* unavailable for binding? */
+	unsigned busy:1;	/* unsafe to touch hw? */
+	unsigned ready:1;
 
 	/* address and type of current peripheral endpoint */
-	u8			remote_addr;
-	u8			remote_end;
+	u8 remote_addr;
+	u8 remote_end;
 
-	u8			type;
-	u16			max_packet;
+	u8 type;
+	u16 max_packet;
 
 	/* transfer state */
-	u16			wait_frame;
+	u16 wait_frame;
 
-	unsigned int		offset;
-	unsigned int		request_size;
-	unsigned int		iso_packet;	/* index into urb */
+	unsigned int offset;
+	unsigned int request_size;
+	unsigned int iso_packet;	/* index into urb */
 
 	/* FIXME just hook into a separate schedule data structure.
 	 * When scheduling is this closely coupled to hardware, we
 	 * waste resources in ways that are surprising to users.
 	 */
-	struct urb		*urb;
-	struct list_head	urb_list;
-	// struct musb_sched_node	*next;
+	struct urb *urb;
+	struct list_head urb_list;
+	// struct musb_sched_node       *next;
 };
 
-
 /* in newer 2.6 kernels, something like this should be the schedule data
  * structure stored in "usb_host_endpoint.hcpriv"; store it there when
  * queueing the first URB, remove when usb_host_endpoint.urb_list empties.
  */
 struct musb_sched_node {
 	struct usb_host_endpoint *host_ep;	/* usbcore info */
-	struct usb_device	*dev;
-	struct musb_host_ep	*ep;		/* current binding */
-	struct list_head	ring;		/* of host_ep */
-	struct musb_sched_node	*next;		/* for periodic tree */
+	struct usb_device *dev;
+	struct musb_host_ep *ep;	/* current binding */
+	struct list_head ring;	/* of host_ep */
+	struct musb_sched_node *next;	/* for periodic tree */
 };
 
 #if defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA)
@@ -88,49 +87,49 @@ struct musb_sched_node {
  * Host mode TX DMA does not function, stops with urb_unlink.
  *
  * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected 
+ * 2530: <USB Host> File IO operation among 2 USB flash drives connected
  *    to the Hub fails.
  */
 #define	HOST_TX_DMA_SOLUTION 2	/* Host TX DMA completion solution: tasklet */
 
-extern struct list_head 	tx_completion_list;
+extern struct list_head tx_completion_list;
 
 #if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
 
 #ifndef CONFIG_PREEMPT_RT
-extern spinlock_t			txReqListLock;
+extern spinlock_t txReqListLock;
 
 #define	ACQUIRE_TX_REQ_LIST_LOCK()	spin_lock(&txReqListLock)
 #define	RELEASE_TX_REQ_LIST_LOCK()	spin_unlock(&txReqListLock)
 
 #else
-extern struct semaphore		txReqListLock;
+extern struct semaphore txReqListLock;
 
 #define	ACQUIRE_TX_REQ_LIST_LOCK()	down(&txReqListLock)
 #define	RELEASE_TX_REQ_LIST_LOCK()	up(&txReqListLock)
 
-#endif /* CONFIG_PREEMPT_RT */
+#endif				/* CONFIG_PREEMPT_RT */
 
-extern struct completion	hostTxThreadNotify;
+extern struct completion hostTxThreadNotify;
 
 #elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
 
 #ifndef CONFIG_PREEMPT_RT
-extern spinlock_t			txReqListLock;
+extern spinlock_t txReqListLock;
 
 #define	ACQUIRE_TX_REQ_LIST_LOCK()	spin_lock_irq(&txReqListLock)
 #define	RELEASE_TX_REQ_LIST_LOCK()	spin_unlock_irq(&txReqListLock)
 
 #else
-extern struct semaphore		txReqListLock;
+extern struct semaphore txReqListLock;
 
 #define	ACQUIRE_TX_REQ_LIST_LOCK()	down(&txReqListLock)
 #define	RELEASE_TX_REQ_LIST_LOCK()	up(&txReqListLock)
 
-#endif /* CONFIG_PREEMPT_RT */
+#endif				/* CONFIG_PREEMPT_RT */
 
 #endif
-#endif /* defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA) */
+#endif				/* defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA) */
 
 extern void MGC_HdrcStartTx(struct musb *, u8 bEnd);
 
@@ -153,7 +152,7 @@ extern struct usb_operations musb_host_b
 static inline struct urb *next_in_urb(struct musb_hw_ep *hw_ep)
 {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	struct list_head	*queue = &hw_ep->in_urb_list;
+	struct list_head *queue = &hw_ep->in_urb_list;
 
 	if (list_empty(queue))
 		return NULL;
@@ -166,7 +165,7 @@ static inline struct urb *next_in_urb(st
 static inline struct urb *next_out_urb(struct musb_hw_ep *hw_ep)
 {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	struct list_head	*queue = &hw_ep->out_urb_list;
+	struct list_head *queue = &hw_ep->out_urb_list;
 
 	if (list_empty(queue))
 		return NULL;
Index: linux-2.6.10/drivers/usb/musb/musb_procfs.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_procfs.c
+++ linux-2.6.10/drivers/usb/musb/musb_procfs.c
@@ -45,29 +45,43 @@
 #include <asm/uaccess.h>	/* FIXME remove procfs writes */
 
 #include "musbdefs.h"
-
+#ifdef CONFIG_ARCH_DAVINCI
 #include "davinci.h"
-
+#endif
 
 #ifdef CONFIG_USB_MUSB_OTG
 
 static const char *state_string(enum usb_otg_state state)
 {
 	switch (state) {
-	case OTG_STATE_A_IDLE:		return "a_idle";
-	case OTG_STATE_A_WAIT_VRISE:	return "a_wait_vrise";
-	case OTG_STATE_A_WAIT_BCON:	return "a_wait_bcon";
-	case OTG_STATE_A_HOST:		return "a_host";
-	case OTG_STATE_A_SUSPEND:	return "a_suspend";
-	case OTG_STATE_A_PERIPHERAL:	return "a_peripheral";
-	case OTG_STATE_A_WAIT_VFALL:	return "a_wait_vfall";
-	case OTG_STATE_A_VBUS_ERR:	return "a_vbus_err";
-	case OTG_STATE_B_IDLE:		return "b_idle";
-	case OTG_STATE_B_SRP_INIT:	return "b_srp_init";
-	case OTG_STATE_B_PERIPHERAL:	return "b_peripheral";
-	case OTG_STATE_B_WAIT_ACON:	return "b_wait_acon";
-	case OTG_STATE_B_HOST:		return "b_host";
-	default:			return "UNDEFINED";
+	case OTG_STATE_A_IDLE:
+		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:
+		return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:
+		return "a_wait_bcon";
+	case OTG_STATE_A_HOST:
+		return "a_host";
+	case OTG_STATE_A_SUSPEND:
+		return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:
+		return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:
+		return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:
+		return "a_vbus_err";
+	case OTG_STATE_B_IDLE:
+		return "b_idle";
+	case OTG_STATE_B_SRP_INIT:
+		return "b_srp_init";
+	case OTG_STATE_B_PERIPHERAL:
+		return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:
+		return "b_wait_acon";
+	case OTG_STATE_B_HOST:
+		return "b_host";
+	default:
+		return "UNDEFINED";
 	}
 }
 
@@ -76,30 +90,35 @@ static const char *state_string(enum usb
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 static int dump_urbs(struct list_head *list, char *buf, unsigned max)
 {
-	int		count = 0;
-	int		tmp;
-	struct urb	*urb;
+	int count = 0;
+	int tmp;
+	struct urb *urb;
 
 	if (list_empty(list))
 		return snprintf(buf, max, "\t(queue empty)\n");
 
 	list_for_each_entry(urb, list, urb_list) {
-		const unsigned 	pipe = urb->pipe;
+		const unsigned pipe = urb->pipe;
 
 		/* for non-multipoint, urb->dev never changes */
 		tmp = snprintf(buf, max,
-				"\turb %p dev%d ep%d%s-%s %d/%d\n",
-				urb, urb->dev->devnum,
-				usb_pipeendpoint(pipe),
-				usb_pipein(pipe) ? "in" : "out",
-				({ char *s; switch(usb_pipetype(pipe)){
-				 case PIPE_BULK:	s = "bulk"; break;
-				 case PIPE_INTERRUPT:	s = "int"; break;
-				 case PIPE_CONTROL:	s = "control"; break;
-				 default:		s = "iso"; break;
-				 }; s; }),
-				urb->actual_length,
-				urb->transfer_buffer_length);
+			       "\turb %p dev%d ep%d%s-%s %d/%d\n",
+			       urb, urb->dev->devnum,
+			       usb_pipeendpoint(pipe),
+			       usb_pipein(pipe) ? "in" : "out", ( {
+								 char *s;
+								 switch
+								 (usb_pipetype
+								  (pipe)) {
+case PIPE_BULK:
+s = "bulk"; break; case PIPE_INTERRUPT:
+s = "int"; break; case PIPE_CONTROL:
+s = "control"; break; default:
+								 s = "iso";
+								 break;}; s;}
+			       ),
+			       urb->actual_length,
+			       urb->transfer_buffer_length) ;
 		if (tmp < 0)
 			break;
 		tmp = min(tmp, (int)max);
@@ -114,41 +133,41 @@ static int dump_urbs(struct list_head *l
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 static int dump_ep(struct musb_ep *ep, char *buffer, unsigned max)
 {
-	char		*buf = buffer;
-	int		code = 0;
-	void __iomem	*regs = ep->pThis->pRegs;
+	char *buf = buffer;
+	int code = 0;
+	void __iomem *regs = ep->pThis->pRegs;
 
 	do {
-		struct usb_request	*req;
+		struct usb_request *req;
 
 		code = snprintf(buf, max,
 				"\n%s (hw%d): %scsr %04x maxp %04x\n",
 				ep->name, ep->bEndNumber,
 				ep->dma ? "dma, " : "",
 				MGC_ReadCsr16(regs,
-					(ep->is_in || !ep->bEndNumber)
-						? MGC_O_HDRC_TXCSR
-						: MGC_O_HDRC_RXCSR,
-					ep->bEndNumber),
+					      (ep->is_in || !ep->bEndNumber)
+					      ? MGC_O_HDRC_TXCSR
+					      : MGC_O_HDRC_RXCSR,
+					      ep->bEndNumber),
 				MGC_ReadCsr16(regs,
-					ep->is_in
-						? MGC_O_HDRC_TXMAXP
-						: MGC_O_HDRC_RXMAXP,
-					ep->bEndNumber)
-				);
+					      ep->is_in
+					      ? MGC_O_HDRC_TXMAXP
+					      : MGC_O_HDRC_RXMAXP,
+					      ep->bEndNumber)
+		    );
 		if (code < 0)
 			break;
-		code = min(code, (int) max);
+		code = min(code, (int)max);
 		buf += code;
 		max -= code;
 
 #ifdef	CONFIG_USB_TI_CPPI_DMA
 		if (ep->bEndNumber) {
-			unsigned	cppi = ep->bEndNumber - 1;
-			void __iomem	*base = ep->pThis->ctrl_base;
-			unsigned	off1 = cppi << 2;
-			void __iomem	*ram = base;
-			char		tmp[16];
+			unsigned cppi = ep->bEndNumber - 1;
+			void __iomem *base = ep->pThis->ctrl_base;
+			unsigned off1 = cppi << 2;
+			void __iomem *ram = base;
+			char tmp[16];
 
 			if (ep->is_in) {
 				ram += DAVINCI_TXCPPI_STATERAM_OFFSET(cppi);
@@ -156,26 +175,27 @@ static int dump_ep(struct musb_ep *ep, c
 			} else {
 				ram += DAVINCI_RXCPPI_STATERAM_OFFSET(cppi);
 				snprintf(tmp, sizeof tmp, "%d left, ",
-					musb_readl(base,
-					DAVINCI_RXCPPI_BUFCNT0_REG + off1));
+					 musb_readl(base,
+						    DAVINCI_RXCPPI_BUFCNT0_REG +
+						    off1));
 			}
 
 			code = snprintf(buf, max, "%cX DMA%d: %s"
 					"%08x %08x, %08x %08x; "
 					"%08x %08x %08x .. %08x\n",
-				ep->is_in ? 'T' : 'R',
-				ep->bEndNumber - 1, tmp,
-				musb_readl(ram, 0 * 4),
-				musb_readl(ram, 1 * 4),
-				musb_readl(ram, 2 * 4),
-				musb_readl(ram, 3 * 4),
-				musb_readl(ram, 4 * 4),
-				musb_readl(ram, 5 * 4),
-				musb_readl(ram, 6 * 4),
-				musb_readl(ram, 7 * 4));
+					ep->is_in ? 'T' : 'R',
+					ep->bEndNumber - 1, tmp,
+					musb_readl(ram, 0 * 4),
+					musb_readl(ram, 1 * 4),
+					musb_readl(ram, 2 * 4),
+					musb_readl(ram, 3 * 4),
+					musb_readl(ram, 4 * 4),
+					musb_readl(ram, 5 * 4),
+					musb_readl(ram, 6 * 4),
+					musb_readl(ram, 7 * 4));
 			if (code < 0)
 				break;
-			code = min(code, (int) max);
+			code = min(code, (int)max);
 			buf += code;
 			max -= code;
 		}
@@ -185,12 +205,12 @@ static int dump_ep(struct musb_ep *ep, c
 			code = snprintf(buf, max, "\t(queue empty)\n");
 			if (code < 0)
 				break;
-			code = min(code, (int) max);
+			code = min(code, (int)max);
 			buf += code;
 			max -= code;
 			break;
 		}
-		list_for_each_entry (req, &ep->req_list, list) {
+		list_for_each_entry(req, &ep->req_list, list) {
 			code = snprintf(buf, max, "\treq %p, %s%s%d/%d\n",
 					req,
 					req->zero ? "zero, " : "",
@@ -198,11 +218,11 @@ static int dump_ep(struct musb_ep *ep, c
 					req->actual, req->length);
 			if (code < 0)
 				break;
-			code = min(code, (int) max);
+			code = min(code, (int)max);
 			buf += code;
 			max -= code;
 		}
-	} while(0);
+	} while (0);
 	return (buf > buffer) ? (buf - buffer) : code;
 }
 #endif
@@ -214,6 +234,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 	char *buf = aBuffer;
 	struct musb_hw_ep *pEnd = &pThis->aLocalEnd[bEnd];
 
+	bEnd = pEnd->bLocalEnd;
 	do {
 		MGC_SelectEnd(pThis->pRegs, bEnd);
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
@@ -254,150 +275,159 @@ dump_end_info(struct musb *pThis, u8 bEn
 			}
 			/* END TEMPORARY */
 
-
 			/* FIXME for rx and tx dump hardware fifo and
 			 * double-buffer flags ... and make register and stat
 			 * dumps (mostly) usable on the peripheral side too
 			 */
 			if (dump_rx) {
 				code = snprintf(buf, max,
-					"\nEnd-%d:  rxcsr %04x interval %02x "
-					"max %04x type %02x; "
-					"dev %d hub %d port %d"
-					"\n",
-					bEnd,
-					MGC_ReadCsr16(pThis->pRegs,
-						MGC_O_HDRC_RXCSR,
-						bEnd),
-					MGC_ReadCsr8(pThis->pRegs,
-						MGC_O_HDRC_RXINTERVAL,
-						bEnd),
-					MGC_ReadCsr16(pThis->pRegs,
-						MGC_O_HDRC_RXMAXP,
-						bEnd),
-					MGC_ReadCsr8(pThis->pRegs,
-						MGC_O_HDRC_RXTYPE,
-						bEnd),
-					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXFUNCADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXHUBADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXHUBPORT))
-					);
+						"\nEnd-%d:  rxcsr %04x interval %02x "
+						"max %04x type %02x; "
+						"dev %d hub %d port %d"
+						"\n",
+						bEnd,
+						MGC_ReadCsr16(pThis->pRegs,
+							      MGC_O_HDRC_RXCSR,
+							      bEnd),
+						MGC_ReadCsr8(pThis->pRegs,
+							     MGC_O_HDRC_RXINTERVAL,
+							     bEnd),
+						MGC_ReadCsr16(pThis->pRegs,
+							      MGC_O_HDRC_RXMAXP,
+							      bEnd),
+						MGC_ReadCsr8(pThis->pRegs,
+							     MGC_O_HDRC_RXTYPE,
+							     bEnd),
+						/* FIXME:  assumes multipoint */
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_RXFUNCADDR)),
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_RXHUBADDR)),
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_RXHUBPORT))
+				    );
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 
 #ifdef	CONFIG_USB_TI_CPPI_DMA
 				if (bEnd && pEnd->pDmaChannel) {
-					unsigned	cppi = bEnd - 1;
-					unsigned	off1 = cppi << 2;
-					void __iomem	*base;
-					void __iomem	*ram;
-					char		tmp[16];
+					unsigned cppi = bEnd - 1;
+					unsigned off1 = cppi << 2;
+					void __iomem *base;
+					void __iomem *ram;
+					char tmp[16];
 
 					base = pThis->ctrl_base;
-					ram = base + DAVINCI_RXCPPI_STATERAM_OFFSET(cppi);
+					ram = base +
+					    DAVINCI_RXCPPI_STATERAM_OFFSET
+					    (cppi);
 					snprintf(tmp, sizeof tmp, "%d left, ",
-						musb_readl(base,
-						DAVINCI_RXCPPI_BUFCNT0_REG
-								+ off1));
+						 musb_readl(base,
+							    DAVINCI_RXCPPI_BUFCNT0_REG
+							    + off1));
 
 					code = snprintf(buf, max,
-						"    rx dma%d: %s"
-						"%08x %08x, %08x %08x; "
-						"%08x %08x %08x .. %08x\n",
-						cppi, tmp,
-						musb_readl(ram, 0 * 4),
-						musb_readl(ram, 1 * 4),
-						musb_readl(ram, 2 * 4),
-						musb_readl(ram, 3 * 4),
-						musb_readl(ram, 4 * 4),
-						musb_readl(ram, 5 * 4),
-						musb_readl(ram, 6 * 4),
-						musb_readl(ram, 7 * 4));
+							"    rx dma%d: %s"
+							"%08x %08x, %08x %08x; "
+							"%08x %08x %08x .. %08x\n",
+							cppi, tmp,
+							musb_readl(ram, 0 * 4),
+							musb_readl(ram, 1 * 4),
+							musb_readl(ram, 2 * 4),
+							musb_readl(ram, 3 * 4),
+							musb_readl(ram, 4 * 4),
+							musb_readl(ram, 5 * 4),
+							musb_readl(ram, 6 * 4),
+							musb_readl(ram, 7 * 4));
 					if (code < 0)
 						break;
-					code = min(code, (int) max);
+					code = min(code, (int)max);
 					buf += code;
 					max -= code;
 				}
 #endif
-				code = dump_urbs(&pEnd->urb_list,
-						buf, max);
+				code = dump_urbs(&pEnd->urb_list, buf, max);
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 			}
 
 			if (dump_tx) {
 				code = snprintf(buf, max,
-					"End-%d:  txcsr %04x interval %02x "
-					"max %04x type %02x; "
-					"dev %d hub %d port %d"
-					"\n",
-					bEnd,
-					MGC_ReadCsr16(pThis->pRegs,
-						MGC_O_HDRC_TXCSR,
-						bEnd),
-					MGC_ReadCsr8(pThis->pRegs,
-						MGC_O_HDRC_TXINTERVAL,
-						bEnd),
-					MGC_ReadCsr16(pThis->pRegs,
-						MGC_O_HDRC_TXMAXP,
-						bEnd),
-					MGC_ReadCsr8(pThis->pRegs,
-						MGC_O_HDRC_TXTYPE,
-						bEnd),
-					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXFUNCADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXHUBADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXHUBPORT))
-					);
+						"End-%d:  txcsr %04x interval %02x "
+						"max %04x type %02x; "
+						"dev %d hub %d port %d"
+						"\n",
+						bEnd,
+						MGC_ReadCsr16(pThis->pRegs,
+							      MGC_O_HDRC_TXCSR,
+							      bEnd),
+						MGC_ReadCsr8(pThis->pRegs,
+							     MGC_O_HDRC_TXINTERVAL,
+							     bEnd),
+						MGC_ReadCsr16(pThis->pRegs,
+							      MGC_O_HDRC_TXMAXP,
+							      bEnd),
+						MGC_ReadCsr8(pThis->pRegs,
+							     MGC_O_HDRC_TXTYPE,
+							     bEnd),
+						/* FIXME:  assumes multipoint */
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_TXFUNCADDR)),
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_TXHUBADDR)),
+						musb_readb(pThis->pRegs,
+							   MGC_BUSCTL_OFFSET
+							   (bEnd,
+							    MGC_O_HDRC_TXHUBPORT))
+				    );
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 #ifdef	CONFIG_USB_TI_CPPI_DMA
 				if (bEnd && pEnd->pDmaChannel) {
-					unsigned	cppi = bEnd - 1;
-					void __iomem	*base;
-					void __iomem	*ram;
+					unsigned cppi = bEnd - 1;
+					void __iomem *base;
+					void __iomem *ram;
 
 					base = pThis->ctrl_base;
-					ram = base + DAVINCI_TXCPPI_STATERAM_OFFSET(cppi);
-					code = snprintf(buf, max,
-						"    tx dma%d: "
-						"%08x %08x, %08x %08x; "
-						"%08x %08x %08x .. %08x\n",
-						cppi,
-						musb_readl(ram, 0 * 4),
-						musb_readl(ram, 1 * 4),
-						musb_readl(ram, 2 * 4),
-						musb_readl(ram, 3 * 4),
-						musb_readl(ram, 4 * 4),
-						musb_readl(ram, 5 * 4),
-						musb_readl(ram, 6 * 4),
-						musb_readl(ram, 7 * 4));
+					ram = base +
+					    DAVINCI_TXCPPI_STATERAM_OFFSET
+					    (cppi);
+					code =
+					    snprintf(buf, max,
+						     "    tx dma%d: "
+						     "%08x %08x, %08x %08x; "
+						     "%08x %08x %08x .. %08x\n",
+						     cppi, musb_readl(ram,
+								      0 * 4),
+						     musb_readl(ram, 1 * 4),
+						     musb_readl(ram, 2 * 4),
+						     musb_readl(ram, 3 * 4),
+						     musb_readl(ram, 4 * 4),
+						     musb_readl(ram, 5 * 4),
+						     musb_readl(ram, 6 * 4),
+						     musb_readl(ram, 7 * 4));
 					if (code < 0)
 						break;
-					code = min(code, (int) max);
+					code = min(code, (int)max);
 					buf += code;
 					max -= code;
 				}
@@ -405,7 +435,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 				code = dump_urbs(&pEnd->urb_list, buf, max);
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 			}
@@ -419,7 +449,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 				code = dump_ep(&pEnd->ep_in, buf, max);
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 			}
@@ -427,7 +457,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 				code = dump_ep(&pEnd->ep_out, buf, max);
 				if (code < 0)
 					break;
-				code = min(code, (int) max);
+				code = min(code, (int)max);
 				buf += code;
 				max -= code;
 			}
@@ -450,96 +480,96 @@ static int dump_header_stats(struct musb
 
 	*buffer = 0;
 	count = sprintf(buffer, "Status: %sHDRC, Mode=%s "
-				"(Power=%02x, DevCtl=%02x)\tPDR interupt Mask=%x\t PDR Interrypt Source=%x\n",
+			"(Power=%02x, DevCtl=%02x)\tPDR interupt Mask=%x\t PDR Interrypt Source=%x\n",
 			(pThis->bIsMultipoint ? "M" : ""), MUSB_MODE(pThis),
 			musb_readb(pBase, MGC_O_HDRC_POWER),
 			musb_readb(pBase, MGC_O_HDRC_DEVCTL),
-			musb_readl(pThis->ctrl_base,DAVINCI_USB_INT_MASK_SET_REG),
-			musb_readl(pThis->ctrl_base,DAVINCI_USB_INT_SET_REG));
+			musb_readl(pThis->ctrl_base,
+				   DAVINCI_USB_INT_MASK_SET_REG),
+			musb_readl(pThis->ctrl_base, DAVINCI_USB_INT_SET_REG));
 	if (count < 0)
 		return count;
 	buffer += count;
 
 #ifdef CONFIG_USB_MUSB_OTG
 	code = sprintf(buffer, "OTG state: %s \n",
-		state_string(pThis->OtgMachine.xceiv.state));
+		       state_string(pThis->OtgMachine.xceiv.state));
 	if (code < 0)
 		return code;
 	buffer += code;
 	count += code;
 #endif
 
-	code = sprintf(buffer,
-			"Options: "
+	code = sprintf(buffer, "Options: "
 #ifdef CONFIG_USB_INVENTRA_FIFO
-			"[pio]"
+		       "[pio]"
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
-			"[cppi-dma]"
+		       "[cppi-dma]"
 #elif defined(CONFIG_USB_INVENTRA_DMA)
-			"[musb-dma]"
+		       "[musb-dma]"
 #else
-			"[?]"
+		       "[?]"
 #endif
-			" "
+		       " "
 #ifdef CONFIG_USB_MUSB_OTG
-			"[otg: peripheral+host]"
+		       "[otg: peripheral+host]"
 #elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
-			"[peripheral]"
+		       "[peripheral]"
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
-			"[host]"
+		       "[host]"
 #endif
-			" [debug=%d] [eps=%d]\n",
-		MGC_GetDebugLevel(), pThis->bEndCount);
+		       " [debug=%d] [eps=%d]\n",
+		       MGC_GetDebugLevel(), pThis->bEndCount);
 	if (code < 0)
 		return code;
 	count += code;
 	buffer += code;
 
-#ifdef	CONFIG_ARCH_DAVINCI
+#if	defined (CONFIG_ARCH_DAVINCI)
 	code = sprintf(buffer,
-			"DaVinci: ctrl=%02x stat=%1x phy=%03x\n"
-			"\trndis=%05x auto=%04x intsrc=%08x intmsk=%08x"
-			"\n",
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_CTRL_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_STAT_REG),
-			__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR)),
-			musb_readl(pThis->ctrl_base, DAVINCI_RNDIS_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_AUTOREQ_REG),
-			musb_readl(pThis->ctrl_base,
-					DAVINCI_USB_INT_SOURCE_REG),
-			musb_readl(pThis->ctrl_base,
-					DAVINCI_USB_INT_MASK_REG));
+		       "DaVinci: ctrl=%02x stat=%1x phy=%03x\n"
+		       "\trndis=%05x auto=%04x intsrc=%08x intmsk=%08x"
+		       "\n",
+		       musb_readl(pThis->ctrl_base, DAVINCI_USB_CTRL_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_USB_STAT_REG),
+#ifdef CONFIG_ARCH_DAVINCI
+		       __raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR)),
+#endif
+		       musb_readl(pThis->ctrl_base, DAVINCI_RNDIS_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_AUTOREQ_REG),
+		       musb_readl(pThis->ctrl_base,
+				  DAVINCI_USB_INT_SOURCE_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_USB_INT_MASK_REG));
 	if (code < 0)
 		return count;
 	count += code;
 	buffer += code;
-#endif	/* DAVINCI */
+#endif				/* DAVINCI */
 
 #ifdef	CONFIG_USB_TI_CPPI_DMA
 	code = sprintf(buffer,
-			"CPPI: txcr=%d txsrc=%01x txena=%01x; "
-			"rxcr=%d rxsrc=%01x rxena=%01x "
-			"\n",
-			musb_readl(pThis->ctrl_base, DAVINCI_TXCPPI_CTRL_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_TXCPPI_RAW_REG),
-			musb_readl(pThis->ctrl_base,
-				DAVINCI_TXCPPI_INTENAB_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_RXCPPI_CTRL_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_RXCPPI_RAW_REG),
-			musb_readl(pThis->ctrl_base,
-				DAVINCI_RXCPPI_INTENAB_REG));
+		       "CPPI: txcr=%d txsrc=%01x txena=%01x; "
+		       "rxcr=%d rxsrc=%01x rxena=%01x "
+		       "\n",
+		       musb_readl(pThis->ctrl_base, DAVINCI_TXCPPI_CTRL_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_TXCPPI_RAW_REG),
+		       musb_readl(pThis->ctrl_base,
+				  DAVINCI_TXCPPI_INTENAB_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_RXCPPI_CTRL_REG),
+		       musb_readl(pThis->ctrl_base, DAVINCI_RXCPPI_RAW_REG),
+		       musb_readl(pThis->ctrl_base,
+				  DAVINCI_RXCPPI_INTENAB_REG));
 	if (code < 0)
 		return count;
 	count += code;
 	buffer += code;
-#endif	/* CPPI */
+#endif				/* CPPI */
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	if (is_peripheral_enabled(pThis)) {
 		code = sprintf(buffer, "Gadget driver: %s\n",
-				pThis->pGadgetDriver
-					? pThis->pGadgetDriver->driver.name
-					: "(none)");
+			       pThis->pGadgetDriver
+			       ? pThis->pGadgetDriver->driver.name : "(none)");
 		if (code < 0)
 			return code;
 		count += code;
@@ -563,12 +593,12 @@ static int dump_header_stats(struct musb
  * h cancel host request
  * D<num> set/query the debug level
  */
-static int musb_proc_write(struct file *file, const char __user *buffer,
-			 unsigned long count, void *data)
+static int musb_proc_write(struct file *file, const char __user * buffer,
+			   unsigned long count, void *data)
 {
 	char cmd;
 	u8 bReg;
-	void __iomem *pBase = ((struct musb *) data)->pRegs;
+	void __iomem *pBase = ((struct musb *)data)->pRegs;
 
 	/* MOD_INC_USE_COUNT; */
 
@@ -576,36 +606,32 @@ static int musb_proc_write(struct file *
 	switch (cmd) {
 	case 'C':
 		if (pBase) {
-			bReg =
-			    musb_readb(pBase,
-				      MGC_O_HDRC_POWER) | MGC_M_POWER_SOFTCONN;
+			bReg = musb_readb(pBase, MGC_O_HDRC_POWER) |
+			    MGC_M_POWER_SOFTCONN;
 			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'c':
 		if (pBase) {
-			bReg =
-			    musb_readb(pBase,
-				      MGC_O_HDRC_POWER) & ~MGC_M_POWER_SOFTCONN;
+			bReg = musb_readb(pBase, MGC_O_HDRC_POWER) &
+			    ~MGC_M_POWER_SOFTCONN;
 			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'I':
 		if (pBase) {
-			bReg =
-			    musb_readb(pBase,
-				      MGC_O_HDRC_POWER) | MGC_M_POWER_HSENAB;
+			bReg = musb_readb(pBase, MGC_O_HDRC_POWER) |
+			    MGC_M_POWER_HSENAB;
 			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'i':
 		if (pBase) {
-			bReg =
-			    musb_readb(pBase,
-				      MGC_O_HDRC_POWER) & ~MGC_M_POWER_HSENAB;
+			bReg = musb_readb(pBase, MGC_O_HDRC_POWER) &
+			    ~MGC_M_POWER_HSENAB;
 			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
@@ -664,7 +690,6 @@ static int musb_proc_write(struct file *
 		}
 		break;
 
-
 	case '?':
 		INFO("?: you are seeing it\n");
 		INFO("C/c: soft connect enable/disable\n");
@@ -684,13 +709,13 @@ static int musb_proc_write(struct file *
 }
 
 static int musb_proc_read(char *page, char **start,
-			off_t off, int count, int *eof, void *data)
+			  off_t off, int count, int *eof, void *data)
 {
 	char *buffer = page;
 	int code = 0;
-	unsigned long	flags;
-	struct musb	*pThis = data;
-	unsigned	bEnd;
+	unsigned long flags;
+	struct musb *pThis = data;
+	unsigned bEnd;
 
 	count -= off;
 	count -= 1;		/* for NUL at end */
@@ -707,8 +732,7 @@ static int musb_proc_read(char *page, ch
 
 	/* generate the report for the end points */
 	// REVISIT ... not unless something's connected!
-	for (bEnd = 0; count >= 0 && bEnd < pThis->bEndCount;
-			bEnd++) {
+	for (bEnd = 0; count >= 0 && bEnd < pThis->bEndCount; bEnd++) {
 		code = dump_end_info(pThis, bEnd, buffer, count);
 		if (code > 0) {
 			buffer += code;
@@ -727,10 +751,9 @@ void __exit musb_debug_delete(char *name
 		remove_proc_entry(name, NULL);
 }
 
-struct proc_dir_entry *__init
-musb_debug_create(char *name, struct musb *data)
+struct proc_dir_entry *__init musb_debug_create(char *name, struct musb *data)
 {
-	struct proc_dir_entry	*pde;
+	struct proc_dir_entry *pde;
 
 	/* FIXME convert everything to seq_file; then later, debugfs */
 
@@ -738,7 +761,8 @@ musb_debug_create(char *name, struct mus
 		return NULL;
 
 	data->pProcEntry = pde = create_proc_entry(name,
-					     S_IFREG | S_IRUGO | S_IWUSR, NULL);
+						   S_IFREG | S_IRUGO | S_IWUSR,
+						   NULL);
 	if (pde) {
 		pde->data = data;
 		// pde->owner = THIS_MODULE;
Index: linux-2.6.10/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.10/drivers/usb/musb/musbdefs.h
@@ -61,7 +61,6 @@ struct musb;
 /* REVISIT tune this */
 #define	MIN_DMA_REQUEST		1	/* use PIO below this xfer size */
 
-
 #ifdef CONFIG_USB_MUSB_OTG
 #include "otg.h"
 
@@ -91,6 +90,8 @@ struct musb;
 #endif
 
 /****************************** PERIPHERAL ROLE ********************************/
+#define MUSB_C_NUM_EPT		5
+#define MUSB_C_NUM_EPR		5
 
 struct musb_ep;
 
@@ -113,13 +114,28 @@ extern void musb_g_disconnect(struct mus
 
 #define	is_peripheral_capable()	(0)
 
-static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_g_tx(struct musb *m, u8 e, u8 i) {}
-static inline void musb_g_rx(struct musb *m, u8 e) {}
-static inline void musb_g_reset(struct musb *m) {}
-static inline void musb_g_suspend(struct musb *m) {}
-static inline void musb_g_resume(struct musb *m) {}
-static inline void musb_g_disconnect(struct musb *m) {}
+static inline irqreturn_t musb_g_ep0_irq(struct musb *m)
+{
+	return IRQ_NONE;
+}
+static inline void musb_g_tx(struct musb *m, u8 e, u8 i)
+{
+}
+static inline void musb_g_rx(struct musb *m, u8 e)
+{
+}
+static inline void musb_g_reset(struct musb *m)
+{
+}
+static inline void musb_g_suspend(struct musb *m)
+{
+}
+static inline void musb_g_resume(struct musb *m)
+{
+}
+static inline void musb_g_disconnect(struct musb *m)
+{
+}
 
 #endif
 
@@ -143,9 +159,16 @@ extern void musb_host_rx(struct musb *, 
 
 #define	is_host_capable()	(0)
 
-static inline irqreturn_t musb_h_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_host_tx(struct musb *m, u8 e) {}
-static inline void musb_host_rx(struct musb *m, u8 e) {}
+static inline irqreturn_t musb_h_ep0_irq(struct musb *m)
+{
+	return IRQ_NONE;
+}
+static inline void musb_host_tx(struct musb *m, u8 e)
+{
+}
+static inline void musb_host_rx(struct musb *m, u8 e)
+{
+}
 
 #endif
 
@@ -153,17 +176,16 @@ static inline void musb_host_rx(struct m
 
 #if CONFIG_USB_MUSB_OTG
 
-extern void otg_input_changed(struct musb * pThis, u8 devctl, u8 reset,u8 connection,
-							 u8 suspend);
+extern void otg_input_changed(struct musb *pThis, u8 devctl, u8 reset,
+			      u8 connection, u8 suspend);
 extern void otg_input_changed_X(struct musb *pThis, u8 bVbusError, u8 bConnect);
 
 extern int musb_start_hnp(struct otg_transceiver *otg);
 extern int musb_start_srp(struct otg_transceiver *otg);
-extern int musb_set_host(struct otg_transceiver *otg,
-				struct usb_bus *host);
+extern int musb_set_host(struct otg_transceiver *otg, struct usb_bus *host);
 
 extern int musb_set_peripheral(struct otg_transceiver *otg,
-													struct usb_gadget *gadget);
+			       struct usb_gadget *gadget);
 #endif
 
 /****************************** CONSTANTS ********************************/
@@ -191,12 +213,12 @@ extern int musb_set_peripheral(struct ot
 
 /* peripheral side ep0 states */
 enum musb_g_ep0_state {
-	MGC_END0_STAGE_SETUP,		/* idle, waiting for setup */
-	MGC_END0_STAGE_TX,		/* IN data */
-	MGC_END0_STAGE_RX,		/* OUT data */
+	MGC_END0_STAGE_SETUP,	/* idle, waiting for setup */
+	MGC_END0_STAGE_TX,	/* IN data */
+	MGC_END0_STAGE_RX,	/* OUT data */
 	MGC_END0_STAGE_STATUSIN,	/* (after OUT data) */
 	MGC_END0_STAGE_STATUSOUT,	/* (after IN data) */
-	MGC_END0_STAGE_ACKWAIT,		/* after zlp, before statusin */
+	MGC_END0_STAGE_ACKWAIT,	/* after zlp, before statusin */
 } __attribute__ ((packed));
 
 /* failure codes */
@@ -218,7 +240,7 @@ enum musb_g_ep0_state {
  * directly with the "flat" model, or after setting up an index register.
  */
 
-#ifdef CONFIG_ARCH_DAVINCI
+#if defined(CONFIG_ARCH_DAVINCI)
 /* REVISIT "flat" takes about 1% more object code space and can't be very
  * noticeable for speed differences.  But for now indexed access seems to
  * misbehave at least for peripheral IN ...
@@ -313,45 +335,44 @@ struct MUSB_EpFifoDescriptor {
  * each with separate host and peripheral side state structures
  */
 struct musb_hw_ep {
-	struct musb		*musb;
-	void __iomem		*fifo;
-	void __iomem		*regs;
+	struct musb *musb;
+	void __iomem *fifo;
+	void __iomem *regs;
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* host side */
 
 #if 1
-
 #define in_urb_list		urb_list
 #define out_urb_list		urb_list
-	struct list_head	urb_list;
+	struct list_head urb_list;
 
 #define in_traffic_type		bTrafficType
 #define out_traffic_type	bTrafficType
-	u8			bTrafficType;
+	u8 bTrafficType;
 
 #define in_busy			busy
 #define out_busy		busy
-	u8			busy;
+	u8 busy;
 
 	/* FIXME not all host side endpoint structures reflect the fact
 	 * that each of these endpoints could go in either direction,
 	 * unless it's using a shared fifo ...
 	 */
-	u8			bIsClaimed;
+	u8 bIsClaimed;
 	u8 bAddress;
 	u8 bEnd;
 	u8 bIsReady;
 	u16 wPacketSize;
-	u16			dwWaitFrame;
+	u16 dwWaitFrame;
 
 	unsigned int dwOffset;
 	unsigned int dwRequestSize;
 	unsigned int dwIsoPacket;
-
+	u8 fifo_flush_check;
 #else
-	struct musb_host_ep	in;
-	struct musb_host_ep	out;
+	struct musb_host_ep in;
+	struct musb_host_ep out;
 
 #define in_urb_list		in.urb_list
 #define out_urb_list		out.urb_list
@@ -362,30 +383,30 @@ struct musb_hw_ep {
 
 #endif
 
-#endif	/* CONFIG_USB_MUSB_HDRC_HCD */
+#endif				/* CONFIG_USB_MUSB_HDRC_HCD */
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	/* peripheral side */
-	struct musb_ep		ep_in;			/* TX */
-	struct musb_ep		ep_out;			/* RX */
+	struct musb_ep ep_in;	/* TX */
+	struct musb_ep ep_out;	/* RX */
 #endif
 
 	/* FIXME each direction should have its own channel... */
 #define	tx_channel	pDmaChannel
 #define	rx_channel	pDmaChannel
-	struct dma_channel	*pDmaChannel;
-	//struct dma_channel	*tx_channel;
-	//struct dma_channel	*rx_channel;
+	struct dma_channel *pDmaChannel;
+	//struct dma_channel    *tx_channel;
+	//struct dma_channel    *rx_channel;
 
 	/* hardware configuration, possibly dynamic */
-	u16			wMaxPacketSizeTx;
-	u16			wMaxPacketSizeRx;
-	u8			tx_double_buffered;
-	u8			rx_double_buffered;
-	u8			bIsSharedFifo;
+	u16 wMaxPacketSizeTx;
+	u16 wMaxPacketSizeRx;
+	u8 tx_double_buffered;
+	u8 rx_double_buffered;
+	u8 bIsSharedFifo;
 
 	/* index in musb->aLocalEnd[]  */
-	u8			bLocalEnd;
+	u8 bLocalEnd;
 };
 
 static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
@@ -410,15 +431,15 @@ static inline struct usb_request *next_o
  * struct musb - Driver instance data.
  */
 struct musb {
-	spinlock_t		Lock;
-	struct usb_bus		*pBus;
-	struct clk		*clock;
-	irqreturn_t		(*isr)(int, void *, struct pt_regs *);
+	spinlock_t Lock;
+	struct usb_bus *pBus;
+	struct clk *clock;
+	 irqreturn_t(*isr) (int, void *, struct pt_regs *);
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	struct virtual_root	RootHub;
-	struct usb_device	*pRootDevice;
-	struct timer_list	Timer;
+	struct virtual_root RootHub;
+	struct usb_device *pRootDevice;
+	struct timer_list Timer;
 
 	u8 bEnd0Stage;		/* end0 stage while in host */
 
@@ -428,36 +449,36 @@ struct musb {
 	 * queue until it completes or NAKs too much; then we try the next
 	 * endpoint.
 	 */
-	struct musb_hw_ep	*bulk_tx_end;
-	struct musb_hw_ep	*bulk_rx_end;
+	struct musb_hw_ep *bulk_tx_end;
+	struct musb_hw_ep *bulk_rx_end;
 
 #ifdef	SCHEDULER
 	/* REVISIT implement a schedule, something like this. */
-	struct list_head	tx_bulk;	/* of musb_sched_node */
-	struct list_head	rx_bulk;	/* of musb_sched_node */
+	struct list_head tx_bulk;	/* of musb_sched_node */
+	struct list_head rx_bulk;	/* of musb_sched_node */
 	struct musb_sched_node *periodic[32];	/* tree of interrupt+iso */
-#endif	/* SCHEDULER */
+#endif				/* SCHEDULER */
 
 #endif
 
-	struct dma_controller	*pDmaController;
-	u64			*old_dma_mask; /* added for use_dma module param */
+	struct dma_controller *pDmaController;
+	u64 *old_dma_mask;	/* added for use_dma module param */
 
-	struct device		*controller;
-	void __iomem		*ctrl_base;
-	void __iomem		*pRegs;
+	struct device *controller;
+	void __iomem *ctrl_base;
+	void __iomem *pRegs;
 
 	/* passed down from chip/board specific irq handlers */
-	u8			int_usb;
-	u16			int_rx;
-	u16			int_tx;
-	struct pt_regs		*int_regs;
+	u8 int_usb;
+	u16 int_rx;
+	u16 int_tx;
+	struct pt_regs *int_regs;
 	/* HBG 21 SEPT 2006 moved it to otg_machine strucure */
-	/* struct otg_transceiver	xceiv;*/
+	/* struct otg_transceiver       xceiv; */
 
 	int nIrq;
 
-	struct musb_hw_ep	 aLocalEnd[MUSB_C_NUM_EPS];
+	struct musb_hw_ep aLocalEnd[MUSB_C_NUM_EPS];
 
 	u16 wEndMask;
 	u8 bEndCount;
@@ -480,19 +501,18 @@ struct musb {
 	unsigned bTestMode:1;
 	unsigned softconnect:1;
 
-	enum musb_g_ep0_state	ep0_state;
-	u8			bAddress;
-	u8			bTestModeValue;
-	u16			ackpend;		/* ep0 */
-	struct usb_gadget	g;			/* the gadget */
+	enum musb_g_ep0_state ep0_state;
+	u8 bAddress;
+	u8 bTestModeValue;
+	u16 ackpend;		/* ep0 */
+	struct usb_gadget g;	/* the gadget */
 	struct usb_gadget_driver *pGadgetDriver;	/* its driver */
 #endif
 
 #ifdef CONFIG_USB_MUSB_OTG
-	struct otg_machine	OtgMachine;
+	struct otg_machine OtgMachine;
 	u8 bDelayPortPowerOff;
 #endif
-
 #ifdef MUSB_CONFIG_PROC_FS
 	struct proc_dir_entry *pProcEntry;
 #endif
@@ -505,23 +525,21 @@ static inline struct musb *gadget_to_mus
 }
 #endif
 
-
 /***************************** Glue it together *****************************/
 
 extern const char musb_driver_name[];
 
 void *musb_alloc_buffer(struct musb *pThis, size_t bytes, gfp_t gfp_flags,
-			    dma_addr_t * dma);
+			dma_addr_t * dma);
 void musb_free_buffer(struct musb *pThis, size_t bytes, void *address,
-			  dma_addr_t dma);
+		      dma_addr_t dma);
 
 extern void musb_start(struct musb *pThis);
 extern void musb_stop(struct musb *pThis);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep,
-			     u16 wCount, const u8 * pSource);
-extern void musb_read_fifo(struct musb_hw_ep *ep,
-			       u16 wCount, u8 * pDest);
+			    u16 wCount, const u8 * pSource);
+extern void musb_read_fifo(struct musb_hw_ep *ep, u16 wCount, u8 * pDest);
 
 extern irqreturn_t musb_interrupt(struct musb *);
 
@@ -530,7 +548,7 @@ extern void musb_platform_disable(struct
 /* HBG 25 SEPT 2006 */
 //-------------------------
 extern void musb_pullup(struct musb *musb, int is_on);
-extern u8 is_otg_b_device ( struct musb * pThis);
+extern u8 is_otg_b_device(struct musb *pThis);
 //-------------------------
 extern void davinci_vbus_power(struct musb *musb, int is_on, int sleeping);
 
@@ -542,13 +560,12 @@ extern int musb_platform_exit(struct mus
 struct proc_dir_entry;
 
 #if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
-extern struct proc_dir_entry *musb_debug_create(char *name,
-						    struct musb *data);
+extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
 extern void musb_debug_delete(char *name, struct musb *data);
 
 #else
 static inline struct proc_dir_entry *musb_debug_create(char *name,
-							   struct musb *data)
+						       struct musb *data)
 {
 	return NULL;
 }
@@ -557,4 +574,4 @@ static inline void musb_debug_delete(cha
 }
 #endif
 
-#endif	/* __MUSB_MUSBDEFS_H__ */
+#endif				/* __MUSB_MUSBDEFS_H__ */
Index: linux-2.6.10/drivers/usb/musb/musbhdrc.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musbhdrc.h
+++ linux-2.6.10/drivers/usb/musb/musbhdrc.h
@@ -202,7 +202,6 @@
 	( MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_RXSTALL \
 	| MGC_M_CSR0_RXPKTRDY )
 
-
 /* TxType/RxType */
 #define MGC_M_TYPE_SPEED	0xc0
 #define MGC_S_TYPE_SPEED	6
@@ -260,7 +259,6 @@
 	( MGC_M_TXCSR_H_NAKTIMEOUT | MGC_M_TXCSR_H_RXSTALL \
 	| MGC_M_TXCSR_H_ERROR | MGC_M_TXCSR_FIFONOTEMPTY )
 
-
 /* RXCSR in Peripheral and Host mode */
 
 #define MGC_M_RXCSR_AUTOCLEAR     0x8000
@@ -298,9 +296,7 @@
 	( MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_H_ERROR \
 	| MGC_M_RXCSR_DATAERROR | MGC_M_RXCSR_RXPKTRDY )
 
-
 /* HUBADDR */
 #define MGC_M_HUBADDR_MULTI_TT		0x80
 
-
-#endif	/* __MUSB_HDRC_DEFS_H__ */
+#endif				/* __MUSB_HDRC_DEFS_H__ */
Index: linux-2.6.10/drivers/usb/musb/musbhsdma.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musbhsdma.c
+++ linux-2.6.10/drivers/usb/musb/musbhsdma.c
@@ -100,9 +100,9 @@ static u8 MGC_HsDmaStartController(void 
 static u8 MGC_HsDmaStopController(void *pPrivateData);
 
 static struct dma_channel *MGC_HsDmaAllocateChannel(void *pPrivateData,
-						u8 bLocalEnd, u8 bTransmit,
-						u8 bProtocol,
-						u16 wMaxPacketSize);
+						    u8 bLocalEnd, u8 bTransmit,
+						    u8 bProtocol,
+						    u16 wMaxPacketSize);
 
 static void MGC_HsDmaReleaseChannel(struct dma_channel *pChannel);
 
@@ -112,18 +112,18 @@ static u8 MGC_HsDmaProgramChannel(struct
 
 static u8 MGC_HsDmaControllerIsr(void *pPrivateData);
 
-static struct dma_controller *MGC_HsNewDmaController(MGC_pfDmaChannelStatusChanged
-						 pfDmaChannelStatusChanged,
-						 void *pDmaPrivate,
-						 u8 * pCoreBase);
+static struct dma_controller
+    *MGC_HsNewDmaController(MGC_pfDmaChannelStatusChanged
+			    pfDmaChannelStatusChanged, void *pDmaPrivate,
+			    u8 * pCoreBase);
 
 static void MGC_HsDestroyDmaController(struct dma_controller *pController);
 
 /******************************* GLOBALS *********************************/
 
 struct dma_controller_factory dma_controller_factory = {
-	.pfNewDmaController =		MGC_HsNewDmaController,
-	.pfDestroyDmaController =	MGC_HsDestroyDmaController,
+	.pfNewDmaController = MGC_HsNewDmaController,
+	.pfDestroyDmaController = MGC_HsDestroyDmaController,
 };
 
 /****************************** FUNCTIONS ********************************/
@@ -143,9 +143,9 @@ static u8 MGC_HsDmaStopController(void *
 }
 
 static struct dma_channel *MGC_HsDmaAllocateChannel(void *pPrivateData,
-						u8 bLocalEnd, u8 bTransmit,
-						u8 bProtocol,
-						u16 wMaxPacketSize)
+						    u8 bLocalEnd, u8 bTransmit,
+						    u8 bProtocol,
+						    u16 wMaxPacketSize)
 {
 	u8 bBit;
 	struct dma_channel *pChannel = NULL;
@@ -238,7 +238,8 @@ static u8 MGC_HsDmaProgramChannel(struct
 }
 
 /* FIXME just update the status when it changes ... */
-static enum dma_channel_status MGC_HsDmaGetChannelStatus(struct dma_channel *pChannel)
+static enum dma_channel_status MGC_HsDmaGetChannelStatus(struct dma_channel
+							 *pChannel)
 {
 	u32 dwAddress;
 	MGC_HsDmaChannel *pImplChannel =
@@ -313,10 +314,10 @@ static u8 MGC_HsDmaControllerIsr(void *p
 
 #endif				/* MUSB_HSDMA */
 
-static struct dma_controller *MGC_HsNewDmaController(MGC_pfDmaChannelStatusChanged
-						 pfDmaChannelStatusChanged,
-						 void *pDmaPrivate,
-						 u8 * pCoreBase)
+static struct dma_controller
+    *MGC_HsNewDmaController(MGC_pfDmaChannelStatusChanged
+			    pfDmaChannelStatusChanged, void *pDmaPrivate,
+			    u8 * pCoreBase)
 {
 	struct dma_controller *pResult = NULL;
 #ifdef MUSB_HSDMA
Index: linux-2.6.10/drivers/usb/musb/otg.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/otg.c
+++ linux-2.6.10/drivers/usb/musb/otg.c
@@ -69,7 +69,7 @@
 
 #include "../core/hcd.h"
 
-static void otg_set_session(struct musb *musb, u8 bSession, u8 bADevice )
+static void otg_set_session(struct musb *musb, u8 bSession, u8 bADevice)
 {
 	/* REVISIT unclear what this should do, but this looks
 	 * like the wrong thing ... the OTG machine should never
@@ -77,20 +77,20 @@ static void otg_set_session(struct musb 
 	 * are active.
 	 */
 	if (bSession && bADevice) {
-		davinci_vbus_power(musb,1,1);
-	} else if( bSession){
-		davinci_vbus_power(musb,0,1);
-	}else{
-		davinci_vbus_power(musb,0,0);	
+		davinci_vbus_power(musb, 1, 1);
+	} else if (bSession) {
+		davinci_vbus_power(musb, 0, 1);
+	} else {
+		davinci_vbus_power(musb, 0, 0);
 	}
-		
+
 }
 
 /* caller has irqlocked musb */
 static void otg_state_changed(struct musb *musb, enum usb_otg_state state)
 {
 	/* caller should pass the timeout here */
-	unsigned long	timer = 0;
+	unsigned long timer = 0;
 
 	if (state == musb->OtgMachine.xceiv.state)
 		return;
@@ -132,22 +132,20 @@ static void otg_state_changed(struct mus
 	 * xceiv.state, then remove OtgMachine.bState and MUSB_MODE...
 	 */
 	DBG(2, "==> OTG state %d(%d), mode %s\n",
-			state, musb->OtgMachine.xceiv.state,
-			MUSB_MODE(musb));
+	    state, musb->OtgMachine.xceiv.state, MUSB_MODE(musb));
 }
 
-
 /**
  * Timer expiration function to complete the interrupt URB on changes
  * @param ptr standard expiration param (hub pointer)
  */
 static void otg_timeout(unsigned long ptr)
 {
-	struct otg_machine	*pMachine = (void *) ptr;
-	void __iomem	*mregs;
-	u8		devctl;
-	struct musb	*musb = pMachine->musb;
-	unsigned long	flags;
+	struct otg_machine *pMachine = (void *)ptr;
+	void __iomem *mregs;
+	u8 devctl;
+	struct musb *musb = pMachine->musb;
+	unsigned long flags;
 
 	/* REVISIT:  a few of these cases _require_ (per the OTG spec)
 	 * some sort of user notification, such as turning on an LED
@@ -161,9 +159,9 @@ static void otg_timeout(unsigned long pt
 	case OTG_STATE_B_IDLE:
 	case OTG_STATE_B_SRP_INIT:
 		INFO("SRP failed\n");
-		otg_set_session(pMachine->musb, FALSE,FALSE);
+		otg_set_session(pMachine->musb, FALSE, FALSE);
 		otg_state_changed(pMachine->musb, OTG_STATE_UNDEFINED);
-		DBG(1,"OTG_STATE_B_SRP_INIT->OTG_STATE_UNDEFINED\n");
+		DBG(1, "OTG_STATE_B_SRP_INIT->OTG_STATE_UNDEFINED\n");
 		break;
 
 	case OTG_STATE_B_WAIT_ACON:
@@ -171,28 +169,28 @@ static void otg_timeout(unsigned long pt
 		mregs = pMachine->musb->pRegs;
 		devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
 		musb_writeb(mregs, MGC_O_HDRC_DEVCTL,
-				devctl & ~MGC_M_DEVCTL_HR);
-		otg_set_session(pMachine->musb, TRUE,FALSE);
+			    devctl & ~MGC_M_DEVCTL_HR);
+		otg_set_session(pMachine->musb, TRUE, FALSE);
 		otg_state_changed(pMachine->musb, OTG_STATE_B_IDLE);
-		DBG(1,"OTG_STATE_B_WAIT_ACON->OTG_STATE_B_IDLE\n");
+		DBG(1, "OTG_STATE_B_WAIT_ACON->OTG_STATE_B_IDLE\n");
 		break;
 
 	case OTG_STATE_A_WAIT_BCON:
 		/* REVISIT we'd like to force the VBUS-off path here... */
 		INFO("No response from B-device\n");
-		otg_set_session(pMachine->musb, FALSE,FALSE);
+		otg_set_session(pMachine->musb, FALSE, FALSE);
 		/* transition via OTG_STATE_A_WAIT_VFALL */
 		otg_state_changed(pMachine->musb, OTG_STATE_A_IDLE);
-		DBG(1,"OTG_STATE_A_WAIT_BCON->OTG_STATE_A_IDLE\n");
+		DBG(1, "OTG_STATE_A_WAIT_BCON->OTG_STATE_A_IDLE\n");
 		break;
 
 	case OTG_STATE_A_SUSPEND:
 		/* FIXME b-dev HNP is _optional_ so this is no error */
 		INFO("No B-device HNP response\n");
-		otg_set_session(pMachine->musb, FALSE,FALSE);
+		otg_set_session(pMachine->musb, FALSE, FALSE);
 		/* transition via OTG_STATE_A_WAIT_VFALL */
 		otg_state_changed(pMachine->musb, OTG_STATE_A_IDLE);
-		DBG(1,"OTG_STATE_A_SUSPEND->OTG_STATE_A_IDLE\n");
+		DBG(1, "OTG_STATE_A_SUSPEND->OTG_STATE_A_IDLE\n");
 		break;
 	default:
 		WARN("timeout in state %d, now what?\n", pMachine->xceiv.state);
@@ -210,7 +208,7 @@ void MGC_OtgMachineInit(struct otg_machi
 	pMachine->Timer.function = otg_timeout;
 	pMachine->Timer.data = (unsigned long)pMachine;
 	/* HBG 21 SEPT 2006 OTG */
-	pMachine->xceiv.state =  OTG_STATE_UNDEFINED;
+	pMachine->xceiv.state = OTG_STATE_UNDEFINED;
 
 /* HBG 21SEPT2006 Added as part of OTG implementation*/
 //====================================================
@@ -233,84 +231,84 @@ void MGC_OtgMachineInputsChanged(struct 
 				 const MGC_OtgMachineInputs * pInputs)
 {
 
-	
-	u8 devctl = musb_readb(pMachine->musb->pRegs,MGC_O_HDRC_DEVCTL);
-	u8 power = musb_readb(pMachine->musb->pRegs,MGC_O_HDRC_POWER);
-	u8 b_device;
-	DBG(1,"Devctl => %02x\t Power =>%02x\n",devctl,power); 
-	DBG(2,"<== bState %d%s%s%s%s%s%s\n",
-			pMachine->xceiv.state,
-			pInputs->bSession ? ", sess" : "",
-			pInputs->bSuspend ? ", susp" : "",
-			pInputs->bConnection ? ", bcon" : "",
-			pInputs->bReset ? ", reset" : "",
-			pInputs->bConnectorId ? ", B-Dev" : ", A-Dev",
-			pInputs->bVbusError ? ", vbus_error" : "");
+	u8 devctl = musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL);
+	u8 power = musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_POWER);
+	DBG(1, "Devctl => %02x\t Power =>%02x\n", devctl, power);
+	DBG(2, "<== bState %d%s%s%s%s%s%s\n",
+	    pMachine->xceiv.state,
+	    pInputs->bSession ? ", sess" : "",
+	    pInputs->bSuspend ? ", susp" : "",
+	    pInputs->bConnection ? ", bcon" : "",
+	    pInputs->bReset ? ", reset" : "",
+	    pInputs->bConnectorId ? ", B-Dev" : ", A-Dev",
+	    pInputs->bVbusError ? ", vbus_error" : "");
 
-	
-	
 	switch (pMachine->xceiv.state) {
-	
+
 	case OTG_STATE_UNDEFINED:
 	case OTG_STATE_A_IDLE:
 	case OTG_STATE_B_IDLE:
-		if(pInputs->bReset && 
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
-			otg_state_changed(pMachine->musb,
-				OTG_STATE_B_PERIPHERAL);
-			DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_B_PERIPHERAL\n");
-		}else if(pInputs->bConnection && 
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		if (pInputs->bReset &&
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb,
-				OTG_STATE_A_HOST);
-			DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_A_HOST\n");
-		}else if (pInputs->bSession &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
-			if(pInputs->bSuspend){
+					  OTG_STATE_B_PERIPHERAL);
+			DBG(1, "OTG_STATE_UNDEFINED->OTG_STATE_B_PERIPHERAL\n");
+		} else if (pInputs->bConnection &&
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
+			otg_state_changed(pMachine->musb, OTG_STATE_A_HOST);
+			DBG(1, "OTG_STATE_UNDEFINED->OTG_STATE_A_HOST\n");
+		} else if (pInputs->bSession &&
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
+			if (pInputs->bSuspend) {
 				break;
-			}else{
-				otg_state_changed(pMachine->musb,OTG_STATE_A_WAIT_BCON);
-				DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_A_WAIT_BCON\n");
-				otg_set_session(pMachine->musb,TRUE,TRUE);
-				
-				/* REVISIT This can cause problem to meet OPT compliance 
+			} else {
+				otg_state_changed(pMachine->musb,
+						  OTG_STATE_A_WAIT_BCON);
+				DBG(1,
+				    "OTG_STATE_UNDEFINED->OTG_STATE_A_WAIT_BCON\n");
+				otg_set_session(pMachine->musb, TRUE, TRUE);
+
+				/* REVISIT This can cause problem to meet OPT compliance
 				 * but we need to wait for becoming session to stable
 				 */
 				mdelay(36);
-				
+
 				mod_timer(&pMachine->Timer, jiffies
-					+ msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
+					  +
+					  msecs_to_jiffies
+					  (MGC_OTG_T_A_WAIT_BCON));
 			}
-		}else if(pMachine->bRequest==MGC_OTG_REQUEST_START_BUS){
-			pMachine->bRequest=0; 
-			otg_set_session(pMachine->musb,TRUE,FALSE);
+		} else if (pMachine->bRequest == MGC_OTG_REQUEST_START_BUS) {
+			pMachine->bRequest = 0;
+			otg_set_session(pMachine->musb, TRUE, FALSE);
 			/*mdelay(36);
-			b_device = is_otg_b_device(pMachine->musb);
-			if(b_device){
-				otg_state_changed(pMachine->musb,
-					OTG_STATE_B_SRP_INIT);
-				otg_set_session(pMachine->musb,TRUE,FALSE);*/
-				mod_timer(&pMachine->Timer, jiffies
-					+ msecs_to_jiffies(MGC_OTG_T_B_SRP_FAIL));	
-				DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_B_SRP_INIT\n");	
+			   b_device = is_otg_b_device(pMachine->musb);
+			   if(b_device){
+			   otg_state_changed(pMachine->musb,
+			   OTG_STATE_B_SRP_INIT);
+			   otg_set_session(pMachine->musb,TRUE,FALSE); */
+			mod_timer(&pMachine->Timer, jiffies
+				  + msecs_to_jiffies(MGC_OTG_T_B_SRP_FAIL));
+			DBG(1, "OTG_STATE_UNDEFINED->OTG_STATE_B_SRP_INIT\n");
 			/*}else{
-				otg_state_changed(pMachine->musb,
-				OTG_STATE_A_WAIT_BCON);
-				DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_A_WAIT_BCON\n");	
-				
-				mod_timer(&pMachine->Timer, jiffies
-					+ msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
-			}*/
+			   otg_state_changed(pMachine->musb,
+			   OTG_STATE_A_WAIT_BCON);
+			   DBG(1,"OTG_STATE_UNDEFINED->OTG_STATE_A_WAIT_BCON\n");
+
+			   mod_timer(&pMachine->Timer, jiffies
+			   + msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
+			   } */
 		}
 		break;
 
 	case OTG_STATE_B_SRP_INIT:
 		if (pInputs->bReset &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_B_PERIPHERAL);
-			DBG(1,"OTG_STATE_B_SRP_INIT->OTG_STATE_B_PERIPHERAL\n");
-			
+					  OTG_STATE_B_PERIPHERAL);
+			DBG(1,
+			    "OTG_STATE_B_SRP_INIT->OTG_STATE_B_PERIPHERAL\n");
+
 			/* SRP is detected by A-Device and B-gets reset
 			 * Event is compeleted and no more need of MGC_OTG_T_B_SRP_FAIL
 			 * timer
@@ -320,57 +318,62 @@ void MGC_OtgMachineInputsChanged(struct 
 		break;
 
 	case OTG_STATE_B_PERIPHERAL:
-		if (!pInputs->bSession){
+		if (!pInputs->bSession) {
 			/* We got a condition were we coule have
 			   requested for a HNP session from application
-			   but user disconnected the cable. 
+			   but user disconnected the cable.
 			   Ensure that we reset the current request.
-			*/
-			pMachine->bRequest=0;
+			 */
+			pMachine->bRequest = 0;
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL,
-				devctl & ~MGC_M_DEVCTL_HR);
+				    devctl & ~MGC_M_DEVCTL_HR);
 			otg_state_changed(pMachine->musb, OTG_STATE_B_IDLE);
-			DBG(1,"OTG_STATE_B_PERIPEHRL->OTG_STATE_B_IDLE\n1");
-		} else if (pMachine->musb->g.b_hnp_enable && pInputs->bSuspend){ 
-			pMachine->bRequest=0;
+			DBG(1, "OTG_STATE_B_PERIPEHRL->OTG_STATE_B_IDLE\n1");
+		} else if (pMachine->musb->pBus->b_hnp_enable
+			   && pInputs->bSuspend) {
+			pMachine->bRequest = 0;
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_B_WAIT_ACON);
-			DBG(1,"OTG_STATE_B_PERIPHERAL->OTG_STATE_B_WAIT_ACON\n");
-			mod_timer(&pMachine->Timer, jiffies
-				+ msecs_to_jiffies(MGC_OTG_T_B_ASE0_BRST));
+					  OTG_STATE_B_WAIT_ACON);
+			DBG(1,
+			    "OTG_STATE_B_PERIPHERAL->OTG_STATE_B_WAIT_ACON\n");
+			mod_timer(&pMachine->Timer,
+				  jiffies +
+				  msecs_to_jiffies(MGC_OTG_T_B_ASE0_BRST));
 		}
 		break;
 
 	case OTG_STATE_B_WAIT_ACON:
 		if (pInputs->bConnection &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb, OTG_STATE_B_HOST);
-			DBG(1,"OTG_STATE_B_WAIT_ACON->OTG_STATE_B_HOST\n");
-			/*Enumeration must start here*/
+			DBG(1, "OTG_STATE_B_WAIT_ACON->OTG_STATE_B_HOST\n");
+			/*Enumeration must start here */
 		} else if (!pInputs->bSession &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb, OTG_STATE_B_IDLE);
-			DBG(1,"OTG_STATE_B_WAIT_ACON->OTG_STATE_B_IDLE\n");
+			DBG(1, "OTG_STATE_B_WAIT_ACON->OTG_STATE_B_IDLE\n");
 		} else if (!pInputs->bSuspend &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_B_PERIPHERAL);
-			DBG(1,"OTG_STATE_B_WAIT_ACON->OTG_STATE_B_PERIPHERAL\n");
+					  OTG_STATE_B_PERIPHERAL);
+			DBG(1,
+			    "OTG_STATE_B_WAIT_ACON->OTG_STATE_B_PERIPHERAL\n");
 		}
 		break;
 
 	case OTG_STATE_B_HOST:
-		if(pMachine->bRequest==MGC_OTG_REQUEST_SUSPEND_BUS){
-			u8 power = musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_POWER);
+		if (pMachine->bRequest == MGC_OTG_REQUEST_SUSPEND_BUS) {
+			u8 power =
+			    musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_POWER);
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_SUSPENDM);
+				    power | MGC_M_POWER_SUSPENDM);
 			mdelay(10);
 			pMachine->bRequest = 0;
-			DBG(1,"Suspended bus in B_Host mode\n");
-			
-		}else if (!pInputs->bConnection &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
-			DBG(1,"OTG_STATE_B_HOST->OTG_STATE_B_IDLE\n");
+			DBG(1, "Suspended bus in B_Host mode\n");
+
+		} else if (!pInputs->bConnection &&
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
+			DBG(1, "OTG_STATE_B_HOST->OTG_STATE_B_IDLE\n");
 			otg_state_changed(pMachine->musb, OTG_STATE_B_IDLE);
 		} else if (pInputs->bConnection && !pInputs->bReset) {
 			/* REVISIT seems incomplete */
@@ -379,41 +382,44 @@ void MGC_OtgMachineInputsChanged(struct 
 
 	case OTG_STATE_A_WAIT_BCON:
 		if (pInputs->bConnection &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb, OTG_STATE_A_HOST);
-			DBG(1,"OTG_STATE_A_WAIT_BCON->OTG_STATE_A_HOST\n");
-			
+			DBG(1, "OTG_STATE_A_WAIT_BCON->OTG_STATE_A_HOST\n");
+
 			/* Delete OTG_STATE_A_WAIT_BCON Timer as Connection is received */
 			del_timer(&pMachine->Timer);
-			
+
 		} else if (pInputs->bReset &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			/* FIXME there is no such transition */
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_A_PERIPHERAL);
-			DBG(1,"OTG_STATE_A_WAIT_BCON->OTG_STATE_A_PERIPHERAL\n");
+					  OTG_STATE_A_PERIPHERAL);
+			DBG(1,
+			    "OTG_STATE_A_WAIT_BCON->OTG_STATE_A_PERIPHERAL\n");
 		}
 		break;
 
 	case OTG_STATE_A_HOST:
-		if(pMachine->bRequest==MGC_OTG_REQUEST_SUSPEND_BUS || pInputs->bSuspend){
-			u8 power = musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_POWER);
-			pMachine->bRequest=0;
+		if (pMachine->bRequest == MGC_OTG_REQUEST_SUSPEND_BUS ||
+		    pInputs->bSuspend) {
+			u8 power = musb_readb(pMachine->musb->pRegs,
+					      MGC_O_HDRC_POWER);
+			pMachine->bRequest = 0;
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_SUSPENDM);
-			DBG(1,"OTG_STATE_A_HOST->OTG_STATE_A_SUSPEND\n");
+				    power | MGC_M_POWER_SUSPENDM);
+			DBG(1, "OTG_STATE_A_HOST->OTG_STATE_A_SUSPEND\n");
 			otg_state_changed(pMachine->musb, OTG_STATE_A_SUSPEND);
 			mod_timer(&pMachine->Timer, jiffies
-					+ msecs_to_jiffies(MGC_OTG_T_AIDL_BDIS));
-		}else if ((!pInputs->bConnection &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN))
- 			|| pMachine->bRequest==MGC_OTG_REQUEST_DROP_BUS) {
-			pMachine->bRequest=0;
+				  + msecs_to_jiffies(MGC_OTG_T_AIDL_BDIS));
+		} else if ((!pInputs->bConnection &&
+			    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN))
+			   || pMachine->bRequest == MGC_OTG_REQUEST_DROP_BUS) {
+			pMachine->bRequest = 0;
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_A_WAIT_BCON);
-			DBG(1,"OTG_STATE_A_HOST->OTG_STATE_A_WAIT_BCON\n");
+					  OTG_STATE_A_WAIT_BCON);
+			DBG(1, "OTG_STATE_A_HOST->OTG_STATE_A_WAIT_BCON\n");
 			mod_timer(&pMachine->Timer, jiffies
-				+ msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
+				  + msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
 		} else if (pInputs->bConnection && !pInputs->bReset) {
 			/* REVISIT seems incomplete */
 		}
@@ -421,47 +427,53 @@ void MGC_OtgMachineInputsChanged(struct 
 
 	case OTG_STATE_A_SUSPEND:
 		if (!pInputs->bConnection &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
-			
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
+
 			/* Remove MGC_OTG_T_AIDL_BDIS Timer Disconnect event occur as part of
-			 * HNP initialization after suspending the USB BUS */ 
+			 * HNP initialization after suspending the USB BUS */
 			del_timer(&pMachine->Timer);
-			
+
 			if (pMachine->musb->pBus->b_hnp_enable) {
-				DBG(1,"OTG_STATE_A_SUSPEND->OTG_STATE_A_PERIPHERAL\n");
+				DBG(1,
+				    "OTG_STATE_A_SUSPEND->OTG_STATE_A_PERIPHERAL\n");
 				otg_state_changed(pMachine->musb,
-						OTG_STATE_A_PERIPHERAL);
+						  OTG_STATE_A_PERIPHERAL);
 			} else {
 				otg_state_changed(pMachine->musb,
-						OTG_STATE_A_WAIT_BCON);
-				DBG(1,"OTG_STATE_A_SUSPEND->OTG_STATE_A_WAIT_BCON\n");
-				mod_timer(&pMachine->Timer, jiffies
-					+ msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
+						  OTG_STATE_A_WAIT_BCON);
+				DBG(1,
+				    "OTG_STATE_A_SUSPEND->OTG_STATE_A_WAIT_BCON\n");
+				mod_timer(&pMachine->Timer,
+					  jiffies +
+					  msecs_to_jiffies
+					  (MGC_OTG_T_A_WAIT_BCON));
 			}
-		}else if (!pInputs->bSuspend &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		} else if (!pInputs->bSuspend &&
+			   (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			otg_state_changed(pMachine->musb, OTG_STATE_A_HOST);
-			DBG(1,"OTG_STATE_A_SUSPEND->OTG_STATE_A_HOST\n");
+			DBG(1, "OTG_STATE_A_SUSPEND->OTG_STATE_A_HOST\n");
 		}
 		break;
 
 	case OTG_STATE_A_PERIPHERAL:
 		if (!pInputs->bSession &&
-			(pMachine->bRequest== MGC_OTG_REQUEST_UNKNOWN)){
+		    (pMachine->bRequest == MGC_OTG_REQUEST_UNKNOWN)) {
 			/* transition via OTG_STATE_A_WAIT_VFALL */
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL,
-				devctl & ~MGC_M_DEVCTL_HR);
+				    devctl & ~MGC_M_DEVCTL_HR);
 			otg_state_changed(pMachine->musb, OTG_STATE_A_IDLE);
-			DBG(1,"OTG_STATE_A_PERIPHERAL->OTG_STATE_A_IDLE\n");
+			DBG(1, "OTG_STATE_A_PERIPHERAL->OTG_STATE_A_IDLE\n");
 		} else if (pInputs->bSuspend) {
 			pMachine->bRequest = 0;
 			musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL,
-				devctl & ~MGC_M_DEVCTL_HR);
+				    devctl & ~MGC_M_DEVCTL_HR);
 			otg_state_changed(pMachine->musb,
-					OTG_STATE_A_WAIT_BCON);
-			DBG(1,"OTG_STATE_A_PERIPHERAL->OTG_STATE_A_WAIT_BCON\n");
-			mod_timer(&pMachine->Timer, jiffies
-				+ msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
+					  OTG_STATE_A_WAIT_BCON);
+			DBG(1,
+			    "OTG_STATE_A_PERIPHERAL->OTG_STATE_A_WAIT_BCON\n");
+			mod_timer(&pMachine->Timer,
+				  jiffies +
+				  msecs_to_jiffies(MGC_OTG_T_A_WAIT_BCON));
 		}
 		break;
 
@@ -469,31 +481,3 @@ void MGC_OtgMachineInputsChanged(struct 
 		WARN("event in state %d, now what?\n", pMachine->xceiv.state);
 	}
 }
-/* 21SEPT2006 HBG OTG state transaction trigger API exported to USB controller */
-//===============================================================================
-#if 0
-void otg_input_changed(struct musb * pThis,u8 bIntrUSB,
-				    u8 devctl, u8 power)
-{
-#ifdef CONFIG_USB_MUSB_OTG
-	struct otg_machine  *otgm	=	&pThis->OtgMachine;
-	MGC_OtgMachineInputs Inputs;
-
-	/* reading suspend state from Power register does NOT work */
-	memset(&Inputs, 0, sizeof(Inputs));
-
-	//Inputs.bSessReq		=(bIntrUSB 	& MGC_M_INTR_SESSREQ	) ? TRUE : FALSE;
-	Inputs.bVbusError	=(bIntrUSB 	& MGC_M_INTR_VBUSERROR	) ? TRUE : FALSE;
-	//Inputs.bResume		=(bIntrUSB 	& MGC_M_INTR_RESUME	) ? TRUE : FALSE;
-	Inputs.bSession 	=(devctl 	& MGC_M_DEVCTL_SESSION	) ? TRUE : FALSE;
-	Inputs.bSuspend 	=(bIntrUSB 	& MGC_M_INTR_SUSPEND	) ? TRUE : FALSE;
-	Inputs.bConnection 	=(bIntrUSB 	& MGC_M_INTR_CONNECT	) ? TRUE : FALSE;
-	//Inputs.bDisConn		=(bIntrUSB 	& MGC_M_INTR_DISCONNECT	) ? TRUE : FALSE;
-	Inputs.bReset 		=(bIntrUSB 	& MGC_M_INTR_RESET	) ? TRUE : FALSE;
-	Inputs.bConnectorId 	=(devctl 	& MGC_M_DEVCTL_BDEVICE	) ? TRUE : FALSE;
-
-	MGC_OtgMachineInputsChanged(otgm, &Inputs);
-#endif
-}
-#endif
-//===============================================================================
Index: linux-2.6.10/drivers/usb/musb/otg.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/otg.h
+++ linux-2.6.10/drivers/usb/musb/otg.h
@@ -92,17 +92,16 @@
  */
 typedef enum {
 	MGC_OTG_REQUEST_UNKNOWN,
-    /** Request the bus */
+		/** Request the bus */
 	MGC_OTG_REQUEST_START_BUS,
-    /** Drop the bus */
+		/** Drop the bus */
 	MGC_OTG_REQUEST_DROP_BUS,
-    /** Suspend the bus */
+		/** Suspend the bus */
 	MGC_OTG_REQUEST_SUSPEND_BUS,
-    /** Reset the state machine */
+		/** Reset the state machine */
 	MGC_OTG_REQUEST_RESET
 } MGC_OtgRequest;
 
-
 /******************************** TYPES **********************************/
 
 /*
@@ -136,13 +135,13 @@ typedef struct {
  */
 struct otg_machine {
 	spinlock_t Lock;
-	struct musb		*musb;
+	struct musb *musb;
 	/* HBG 21SEPT2006 moved following structure integrate OTG implementation
 	 * to linux USB OTG mainstream
 	 */
-	struct otg_transceiver	xceiv;
+	struct otg_transceiver xceiv;
 	struct timer_list Timer;
-	MGC_OtgRequest bRequest;	
+	MGC_OtgRequest bRequest;
 	/* FIXME standard Linux-USB host and peripheral code includes
 	 * OTG support ... most of this "otg machine" must vanish
 	 */
@@ -154,15 +153,14 @@ struct otg_machine {
 /*
  * Initialize an OTG state machine.
  */
-extern void MGC_OtgMachineInit(struct otg_machine * pMachine,
-			     struct musb *musb);
+extern void MGC_OtgMachineInit(struct otg_machine *pMachine, struct musb *musb);
 
 /*
  * Destroy an OTG state machine
  * @param pMachine machine pointer
  * @see #MGC_OtgMachineInit
  */
-extern void MGC_OtgMachineDestroy(struct otg_machine * pMachine);
+extern void MGC_OtgMachineDestroy(struct otg_machine *pMachine);
 
 /*
  * OTG inputs have changed.
@@ -184,9 +182,8 @@ extern void MGC_OtgMachineDestroy(struct
  * @param pInputs current inputs
  * @see #MGC_OtgMachineInit
  */
-extern void MGC_OtgMachineInputsChanged(struct otg_machine * pMachine,
-                                        const MGC_OtgMachineInputs * pInputs);
-
+extern void MGC_OtgMachineInputsChanged(struct otg_machine *pMachine,
+					const MGC_OtgMachineInputs * pInputs);
 
 //extern void otg_input_changed(struct musb * pThis,u8 bIntrUSB,
 //                                    u8 devctl, u8 power);
Index: linux-2.6.10/drivers/usb/musb/plat_arc.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/plat_arc.h
+++ linux-2.6.10/drivers/usb/musb/plat_arc.h
@@ -42,26 +42,32 @@
 
 /* NOTE:  these offsets are all in bytes */
 
-static inline u16 musb_readw(const void __iomem *addr, unsigned offset)
-	{ return __raw_readw(addr + offset); }
-
-static inline u32 musb_readl(const void __iomem *addr, unsigned offset)
-	{ return __raw_readl(addr + offset); }
-
+static inline u16 musb_readw(const void __iomem * addr, unsigned offset)
+{
+	return __raw_readw((void *__iomem)(addr + offset));
+}
 
-static inline void musb_writew(void __iomem *addr, unsigned offset, u16 data)
-	{ __raw_writew(data, addr + offset); }
+static inline u32 musb_readl(const void __iomem * addr, unsigned offset)
+{
+	return __raw_readl((void *__iomem)(addr + offset));
+}
 
-static inline void musb_writel(void __iomem *addr, unsigned offset, u32 data)
-	{ __raw_writel(data, addr + offset); }
+static inline void musb_writew(void __iomem * addr, unsigned offset, u16 data)
+{
+	__raw_writew(data, (void *__iomem)(addr + offset));
+}
 
+static inline void musb_writel(void __iomem * addr, unsigned offset, u32 data)
+{
+	__raw_writel(data, (void *__iomem)(addr + offset));
+}
 
 #ifdef CONFIG_USB_TUSB_6010
 
 /*
  * TUSB6010 doesn't allow 8-bit access; 16-bit access is the minimum.
  */
-static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
+static inline u8 musb_readb(const void __iomem * addr, unsigned offset)
 {
 	u16 tmp;
 	u8 val;
@@ -75,7 +81,7 @@ static inline u8 musb_readb(const void _
 	return val;
 }
 
-static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
+static inline void musb_writeb(void __iomem * addr, unsigned offset, u8 data)
 {
 	u16 tmp;
 
@@ -90,12 +96,16 @@ static inline void musb_writeb(void __io
 
 #else
 
-static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
-	{ return __raw_readb(addr + offset); }
+static inline u8 musb_readb(const void __iomem * addr, unsigned offset)
+{
+	return __raw_readb((void *__iomem)(addr + offset));
+}
 
-static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
-	{ __raw_writeb(data, addr + offset); }
+static inline void musb_writeb(void __iomem * addr, unsigned offset, u8 data)
+{
+	__raw_writeb(data, addr + offset);
+}
 
-#endif	/* CONFIG_USB_TUSB_6010 */
+#endif				/* CONFIG_USB_TUSB_6010 */
 
 #endif
Index: linux-2.6.10/drivers/usb/musb/plat_cnf.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/plat_cnf.h
+++ linux-2.6.10/drivers/usb/musb/plat_cnf.h
@@ -46,8 +46,9 @@
  * arch-specific files.  Discrete chips will need a build tweak.
  * So will using AHB IDs from silicon that provides them.
  */
+#ifdef CONFIG_ARCH_DAVINCI
 #include <asm/arch/hdrc_cnf.h>
-
+#endif
 /*
  * Handle dynamic FIFO sizing in a way that doesn't create more code
  * (but could make your brain hurt)
@@ -186,4 +187,4 @@
 
 #endif				/* MUSB_C_DYNFIFO_DEF */
 
-#endif	/* __MUSB_LINUX_CONFIG_H__ */
+#endif				/* __MUSB_LINUX_CONFIG_H__ */
Index: linux-2.6.10/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.10/drivers/usb/musb/plat_uds.c
@@ -118,11 +118,12 @@
 #include <linux/list.h>
 // #include <linux/platform_device.h>
 // #include <linux/clk.h>
+#ifdef CONFIG_ARCH_DAVINCI
 #include <asm/hardware/clock.h>
-
-#include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/memory.h>
+#endif
+#include <asm/io.h>
 
 #ifdef	CONFIG_ARM
 #include <asm/mach-types.h>
@@ -133,8 +134,6 @@
 #include "../core/hcd.h"
 // #endif
 
-
-
 /* HBG 21 SEPT2006 added below to be otg comply */
 //----------------------------------------------
 #ifdef CONFIG_USB_MUSB_OTG
@@ -153,14 +152,12 @@ unsigned MGC_DebugLevel = MUSB_DEBUG;
 #include "musb_host.h"
 // #endif
 
-
 #ifdef CONFIG_ARCH_DAVINCI
 #include "davinci.h"
 #endif
 
 #include "tusb_6010.h"
 
-
 /***************************** CONSTANTS ********************************/
 
 #define DRIVER_AUTHOR "Mentor Graphics Corp. and Texas Instruments"
@@ -189,32 +186,33 @@ MODULE_LICENSE("GPL");
 /* how many babbles to allow before giving up */
 #define MUSB_MAX_BABBLE_COUNT    10
 
-extern void MGC_HdrcEnableTXDMA(struct musb * pThis, u8 bEnd);
-/*HBG 22SEPT2006 */
+extern void MGC_HdrcEnableTXDMA(struct musb *pThis, u8 bEnd);
 #ifdef CONFIG_USB_MUSB_OTG
-static int musb_app_inputs(struct file *file, const char __user *buffer,
-			 unsigned long count, void *data);
-#endif
+/*HBG 22SEPT2006 */
+static int musb_app_inputs(struct file *file, const char __user * buffer,
+			   unsigned long count, void *data);
 /*************************************************************************
  * HDRC functions
 **************************************************************************/
 /* HBG 21 SEPT removed from here now OTG will export this interface*/
 //==========================================================================
-#if CONFIG_USB_MUSB_OTG
 
 /* Called with controller locked and IRQ locked */
 int musb_start_hnp(struct otg_transceiver *otg)
 {
-	if(!otg)
+	if (!otg)
 		return 0;
-	else{	
-		struct otg_machine * pMachine = container_of(otg,struct otg_machine,xceiv);
-		u8 devctl = musb_readb(pMachine->musb->pRegs,MGC_O_HDRC_DEVCTL);
+	else {
+		struct otg_machine *pMachine = container_of(otg,
+							    struct otg_machine,
+							    xceiv);
+		u8 devctl =
+		    musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL);
 		musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL,
-						devctl | MGC_M_DEVCTL_HR);	
+			    devctl | MGC_M_DEVCTL_HR);
 		return 1;
 	}
-	
+
 }
 
 /* Called with controller locked and IRQ locked */
@@ -222,9 +220,12 @@ int musb_start_srp(struct otg_transceive
 {
 	if (!otg)
 		return 0;
-	else{
-		struct otg_machine * pMachine = container_of(otg,struct otg_machine,xceiv);
-		u8	devctl = musb_readb(pMachine->musb->pRegs,MGC_O_HDRC_DEVCTL);
+	else {
+		struct otg_machine *pMachine = container_of(otg,
+							    struct otg_machine,
+							    xceiv);
+		u8 devctl =
+		    musb_readb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL);
 		devctl |= MGC_M_DEVCTL_SESSION;
 		musb_writeb(pMachine->musb->pRegs, MGC_O_HDRC_DEVCTL, devctl);
 		return 1;
@@ -232,33 +233,31 @@ int musb_start_srp(struct otg_transceive
 }
 
 /* Called with controller locked and IRQ locked */
-int musb_set_host(struct otg_transceiver *otg,
-				struct usb_bus *host)
+int musb_set_host(struct otg_transceiver *otg, struct usb_bus *host)
 {
 
-	if(host)
+	if (host)
 		otg->host = host;
 	else
 		otg->host = NULL;
-		
+
 	return 1;
 }
 
 /* Called with controller locked and IRQ locked */
-int musb_set_peripheral(struct otg_transceiver *otg,
-				struct usb_gadget *gadget)
+int musb_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *gadget)
 {
-	if(gadget)
+	if (gadget)
 		otg->gadget = gadget;
 	else
 		otg->gadget = NULL;
-		
+
 	return 1;
 }
-void otg_input_changed(struct musb * pThis, u8 devctl, u8 reset,
-			 u8 connection, u8 suspend)
+void otg_input_changed(struct musb *pThis, u8 devctl, u8 reset,
+		       u8 connection, u8 suspend)
 {
-	struct otg_machine	*otgm = &pThis->OtgMachine;
+	struct otg_machine *otgm = &pThis->OtgMachine;
 	MGC_OtgMachineInputs Inputs;
 
 	/* reading suspend state from Power register does NOT work */
@@ -272,7 +271,7 @@ void otg_input_changed(struct musb * pTh
 	MGC_OtgMachineInputsChanged(otgm, &Inputs);
 }
 
-void otg_input_changed_X(struct musb * pThis, u8 bVbusError, u8 bConnect)
+void otg_input_changed_X(struct musb *pThis, u8 bVbusError, u8 bConnect)
 {
 	MGC_OtgMachineInputs Inputs;
 	void __iomem *pBase = pThis->pRegs;
@@ -280,20 +279,19 @@ void otg_input_changed_X(struct musb * p
 	u8 power = musb_readb(pBase, MGC_O_HDRC_POWER);
 
 	DBG(2, "<== power %02x, devctl %02x%s%s\n", power, devctl,
-			bConnect ? ", bcon" : "",
-			bVbusError ? ", vbus_error" : "");
+	    bConnect ? ", bcon" : "", bVbusError ? ", vbus_error" : "");
 
 	/* speculative */
 	memset(&Inputs, 0, sizeof(Inputs));
-	Inputs.bSession		= (devctl & MGC_M_DEVCTL_SESSION) ? TRUE : FALSE;
-	Inputs.bConnectorId	= (devctl & MGC_M_DEVCTL_BDEVICE) ? TRUE : FALSE;
-	Inputs.bReset		= (power & MGC_M_POWER_RESET) ? TRUE : FALSE;
-	Inputs.bConnection	= bConnect;
-	Inputs.bVbusError	= bVbusError;
-	Inputs.bSuspend		= (power & MGC_M_POWER_SUSPENDM) ? TRUE : FALSE;
+	Inputs.bSession = (devctl & MGC_M_DEVCTL_SESSION) ? TRUE : FALSE;
+	Inputs.bConnectorId = (devctl & MGC_M_DEVCTL_BDEVICE) ? TRUE : FALSE;
+	Inputs.bReset = (power & MGC_M_POWER_RESET) ? TRUE : FALSE;
+	Inputs.bConnection = bConnect;
+	Inputs.bVbusError = bVbusError;
+	Inputs.bSuspend = (power & MGC_M_POWER_SUSPENDM) ? TRUE : FALSE;
 	MGC_OtgMachineInputsChanged(&(pThis->OtgMachine), &Inputs);
 }
-#endif // CONFIG_USB_MUSB_OTG
+#endif				// CONFIG_USB_MUSB_OTG
 //==========================================================================
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 /*
@@ -301,9 +299,9 @@ void otg_input_changed_X(struct musb * p
  */
 static void musb_timer_done(unsigned long pParam)
 {
-	struct musb 	*pThis	= (void *) pParam;
-	void __iomem 	*pBase	= pThis->pRegs;
-	unsigned long	flags;
+	struct musb *pThis = (void *)pParam;
+	void __iomem *pBase = pThis->pRegs;
+	unsigned long flags;
 	u8 power;
 	spin_lock_irqsave(&pThis->Lock, flags);
 #ifdef  CONFIG_USB_MUSB_OTG
@@ -314,7 +312,7 @@ static void musb_timer_done(unsigned lon
 		DBG(2, "finish RESUME signaling\n");
 		power = musb_readb(pBase, MGC_O_HDRC_POWER);
 		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power & ~MGC_M_POWER_RESUME);
+			    power & ~MGC_M_POWER_RESUME);
 		MGC_VirtualHubPortResumed(&pThis->RootHub, 0);
 
 		otg_input_changed_X(pThis, FALSE, FALSE);
@@ -322,7 +320,7 @@ static void musb_timer_done(unsigned lon
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
 		DBG(2, "restart (?)\n");
-		musb_start((struct musb *) pParam);
+		musb_start((struct musb *)pParam);
 		break;
 	default:
 		DBG(1, "<== in state %d\n", pThis->OtgMachine.xceiv.state);
@@ -331,10 +329,9 @@ static void musb_timer_done(unsigned lon
 #else
 	DBG(2, "finish RESUME signaling\n");
 	power = musb_readb(pBase, MGC_O_HDRC_POWER);
-	musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power & ~MGC_M_POWER_RESUME);
+	musb_writeb(pBase, MGC_O_HDRC_POWER, power & ~MGC_M_POWER_RESUME);
 	MGC_VirtualHubPortResumed(&pThis->RootHub, 0);
-#endif	
+#endif
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 }
 #endif
@@ -343,27 +340,142 @@ static void musb_timer_done(unsigned lon
 /*
  * Load an endpoint's FIFO
  */
-void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 wCount, const u8 *pSource)
+#if 1
+
+static void musb_fifo_io(u8 * fifo, u8 * buf, u16 len, char is_read)
+{
+	u16 index = 0;
+	char size = ((unsigned long)buf & 0x04) ? 4 :
+	    ((unsigned long)buf & 0x02) ? 2 : 1;
+#ifndef CONFIG_CPU_LITTLE_ENDIAN
+	u32 *pTemp = (u32 *) buf;
+	u16 *pTmp16 = (u16 *) buf;
+#endif
+	size = (len >= size) ? size : (len >= (size >> 1)) ? (size >> 1) : 1;
+	if (size == 1) {
+		if (is_read)
+			readsb(fifo, (void *__iomem)buf, len);
+		else
+			writesb(fifo, (void *__iomem)buf, len);
+		return;
+	}
+#ifndef CONFIG_CPU_LITTLE_ENDIAN
+	while (len >= size) {
+		switch (size) {
+		case 4:
+			if (is_read)
+				*pTemp = cpu_to_le32(*(u32 *) fifo);
+			else
+				*(u32 *) fifo = cpu_to_le32(*pTemp);
+			pTemp++;
+			break;
+		case 2:
+			if (is_read)
+				*pTmp16 = cpu_to_le16(*(u16 *) fifo);
+			else
+				*(u16 *) fifo = cpu_to_le16(*pTmp16);
+			pTmp16++;
+			break;
+		}
+		len -= size;
+		index += size;
+	}
+#else
+	switch (size) {
+	case 4:
+		if (is_read)
+			readsl(fifo, buf, len >> 2);
+		else
+			writesl(fifo, (void *__iomem)(buf), len >> 2);
+		index += len & ~0x03;
+		break;
+	case 2:
+		if (is_read)
+			readsw(fifo, buf, len >> 1);
+		else
+			writesw(fifo, (void *__iomem)(buf), len >> 1);
+		index += len & ~0x01;
+		break;
+	}
+#endif
+	if (len & 0x02) {
+		if (is_read)
+			*(u16 *) & buf[index] =
+			    cpu_to_le16(musb_readw(fifo, 0));
+		else
+			musb_writew(fifo, 0,
+				    cpu_to_le16(*(u16 *) & buf[index]));
+		index += 2;
+	}
+	if (len & 0x01) {
+		if (is_read)
+			buf[index] = musb_readb(fifo, 0);
+		else
+			musb_writeb(fifo, 0, buf[index]);
+	}
+}
+
+void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 wCount, const u8 * pSource)
 {
 	void __iomem *fifo = hw_ep->fifo;
+	prefetch((u8 *) pSource);
+	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
+	    'T', hw_ep->bLocalEnd, fifo, wCount, pSource);
 
-	prefetch((u8 *)pSource);
+	/* we can't assume unaligned reads work */
+	if (likely((0x01 & (unsigned long)pSource) == 0)) {
+		/* best case is 32bit-aligned source address */
+		if ((0x02 & (unsigned long)pSource) == 0) {
+			musb_fifo_io(fifo, (u8 *) pSource, wCount, 0);
+		} else {
+			musb_fifo_io(fifo, (u8 *) pSource, wCount, 0);
+		}
+	} else {
+		musb_fifo_io(fifo, (u8 *) pSource, wCount, 0);
+	}
+}
 
+void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 wCount, u8 * pDest)
+{
+	void __iomem *fifo = hw_ep->fifo;
 	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
-			'T', hw_ep->bLocalEnd, fifo, wCount, pSource);
+	    'R', hw_ep->bLocalEnd, fifo, wCount, pDest);
+
+	/* we can't assume unaligned writes work */
+	if (likely((0x01 & (unsigned long)pDest) == 0)) {
+		/* best case is 32bit-aligned destination address */
+		if ((0x02 & (unsigned long)pDest) == 0) {
+			musb_fifo_io(fifo, pDest, wCount, 1);
+		} else {
+			musb_fifo_io(fifo, pDest, wCount, 1);
+		}
+	} else {
+		musb_fifo_io(fifo, pDest, wCount, 1);
+	}
+}
+
+#else
+void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 wCount, const u8 * pSource)
+{
+	void __iomem *fifo = hw_ep->fifo;
+
+	prefetch((u8 *) pSource);
+
+	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
+	    'T', hw_ep->bLocalEnd, fifo, wCount, pSource);
 
 	/* we can't assume unaligned reads work */
-	if (likely((0x01 & (unsigned long) pSource) == 0)) {
-		u16	index = 0;
+	if (likely((0x01 & (unsigned long)pSource) == 0)) {
+		u16 index = 0;
 
 		/* best case is 32bit-aligned source address */
-		if ((0x02 & (unsigned long) pSource) == 0) {
+		if ((0x02 & (unsigned long)pSource) == 0) {
 			if (wCount >= 4) {
 				writesl(fifo, pSource + index, wCount >> 2);
 				index += wCount & ~0x03;
 			}
 			if (wCount & 0x02) {
-				musb_writew(fifo, 0, *(u16*)&pSource[index]);
+				musb_writew(fifo, 0, *(u16 *) & pSource[index]);
 				index += 2;
 			}
 		} else {
@@ -374,7 +486,7 @@ void musb_write_fifo(struct musb_hw_ep *
 		}
 		if (wCount & 0x01)
 			musb_writeb(fifo, 0, pSource[index]);
-	} else  {
+	} else {
 		/* byte aligned */
 		writesb(fifo, pSource, wCount);
 	}
@@ -383,25 +495,25 @@ void musb_write_fifo(struct musb_hw_ep *
 /*
  * Unload an endpoint's FIFO
  */
-void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 wCount, u8 *pDest)
+void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 wCount, u8 * pDest)
 {
 	void __iomem *fifo = hw_ep->fifo;
 
 	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
-			'R', hw_ep->bLocalEnd, fifo, wCount, pDest);
+	    'R', hw_ep->bLocalEnd, fifo, wCount, pDest);
 
 	/* we can't assume unaligned writes work */
-	if (likely((0x01 & (unsigned long) pDest) == 0)) {
-		u16	index = 0;
+	if (likely((0x01 & (unsigned long)pDest) == 0)) {
+		u16 index = 0;
 
 		/* best case is 32bit-aligned destination address */
-		if ((0x02 & (unsigned long) pDest) == 0) {
+		if ((0x02 & (unsigned long)pDest) == 0) {
 			if (wCount >= 4) {
 				readsl(fifo, pDest, wCount >> 2);
 				index = wCount & ~0x03;
 			}
 			if (wCount & 0x02) {
-				*(u16*)&pDest[index] = musb_readw(fifo, 0);
+				*(u16 *) & pDest[index] = musb_readw(fifo, 0);
 				index += 2;
 			}
 		} else {
@@ -412,14 +524,13 @@ void musb_read_fifo(struct musb_hw_ep *h
 		}
 		if (wCount & 0x01)
 			pDest[index] = musb_readb(fifo, 0);
-	} else  {
+	} else {
 		/* byte aligned */
 		readsb(fifo, pDest, wCount);
 	}
 }
-
-#endif	/* normal PIO */
-
+#endif
+#endif				/* normal PIO */
 
 /*
  * Interrupt Service Routine to record USB "global" interrupts.
@@ -432,8 +543,8 @@ void musb_read_fifo(struct musb_hw_ep *h
  * @param devctl
  * @param power
  */
-static irqreturn_t musb_stage0_irq(struct musb * pThis, u8 bIntrUSB,
-				    u8 devctl, u8 power)
+static irqreturn_t musb_stage0_irq(struct musb *pThis, u8 bIntrUSB,
+				   u8 devctl, u8 power)
 {
 	irqreturn_t handled = IRQ_NONE;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
@@ -457,12 +568,12 @@ static irqreturn_t musb_stage0_irq(struc
 			MUSB_HST_MODE(pThis);	/* unnecessary */
 			power &= ~MGC_M_POWER_SUSPENDM;
 			musb_writeb(pBase, MGC_O_HDRC_POWER,
-				   power | MGC_M_POWER_RESUME);
+				    power | MGC_M_POWER_RESUME);
 #ifdef CONFIG_USB_MUSB_OTG
-			otg_input_changed(pThis,devctl,FALSE,FALSE,FALSE);
+			otg_input_changed(pThis, devctl, FALSE, FALSE, FALSE);
 #endif
 			mod_timer(&pThis->Timer, jiffies +
-					msecs_to_jiffies(10));
+				  msecs_to_jiffies(10));
 #endif
 		} else {
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -471,7 +582,6 @@ static irqreturn_t musb_stage0_irq(struc
 			musb_g_resume(pThis);
 		}
 	}
-
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* see manual for the order of the tests */
 	if (bIntrUSB & MGC_M_INTR_SESSREQ) {
@@ -489,7 +599,7 @@ static irqreturn_t musb_stage0_irq(struc
 
 /* HBG 21SEPT2006 removed as part of OTG improvements */
 //-----------------------------------------------------
-//		pThis->xceiv.state = OTG_STATE_A_IDLE;
+//              pThis->xceiv.state = OTG_STATE_A_IDLE;
 //-----------------------------------------------------
 		MUSB_HST_MODE(pThis);
 
@@ -499,27 +609,28 @@ static irqreturn_t musb_stage0_irq(struc
 //-----------------------------------------------------
 
 #ifdef CONFIG_USB_MUSB_OTG
-	{
-		MGC_OtgMachineInputs Inputs;
-		memset(&Inputs, 0, sizeof(Inputs));
-		Inputs.bSession = TRUE;
-		Inputs.bConnectorId = FALSE;
-		Inputs.bReset = FALSE;
-		Inputs.bConnection = FALSE;
-		Inputs.bSuspend = FALSE;
-		MGC_OtgMachineInputsChanged(&(pThis->OtgMachine), &Inputs);
-	}
+		{
+			MGC_OtgMachineInputs Inputs;
+			memset(&Inputs, 0, sizeof(Inputs));
+			Inputs.bSession = TRUE;
+			Inputs.bConnectorId = FALSE;
+			Inputs.bReset = FALSE;
+			Inputs.bConnection = FALSE;
+			Inputs.bSuspend = FALSE;
+			MGC_OtgMachineInputsChanged(&(pThis->OtgMachine),
+						    &Inputs);
+		}
 #endif
 
 //-----------------------------------------------------
 /* HBG 21SEPT2006 OTG implementation */
 #ifdef CONFIG_USB_MUSB_OTG
-//		otg_input_changed(pThis,bIntrUSB,devctl,power);
+//              otg_input_changed(pThis,bIntrUSB,devctl,power);
 #endif
 	}
 
 	if (bIntrUSB & MGC_M_INTR_VBUSERROR) {
-printk ("VBUS_ERR\n\n");
+		printk("VBUS_ERR\n\n");
 		// MGC_OtgMachineInputsChanged(otgm, &Inputs);
 		// ... may need to abort otg timer ...
 
@@ -527,12 +638,12 @@ printk ("VBUS_ERR\n\n");
 
 /* HBG 21SEPT2006 removed as part of OTG improvements */
 //-----------------------------------------------------
-//		pThis->xceiv.state = OTG_STATE_A_IDLE;
+//              pThis->xceiv.state = OTG_STATE_A_IDLE;
 //-----------------------------------------------------
 
 		/* HBG 13SEPT2006 OTG implementation */
 #ifdef CONFIG_USB_MUSB_OTG
-				otg_input_changed_X(pThis,TRUE,FALSE);
+		otg_input_changed_X(pThis, TRUE, FALSE);
 #endif
 
 		//musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
@@ -540,8 +651,8 @@ printk ("VBUS_ERR\n\n");
 	}
 
 	if (bIntrUSB & MGC_M_INTR_CONNECT) {
-		u8	speed = USB_SPEED_FULL;
-		DBG(1,"CONNECT\n");
+		u8 speed = USB_SPEED_FULL;
+		DBG(1, "CONNECT\n");
 		handled = IRQ_HANDLED;
 
 		pThis->bEnd0Stage = MGC_END0_START;
@@ -566,30 +677,30 @@ printk ("VBUS_ERR\n\n");
 /* HBG 21SEPT2006 removed as part of OTG improvements */
 //-----------------------------------------------------
 		/*
-		switch (pThis->xceiv.state) {
-		case OTG_STATE_B_WAIT_ACON:
-			pThis->xceiv.state = OTG_STATE_B_HOST;
-			break;
-		default:
-			DBG(2, "connect in state %d\n", pThis->xceiv.state);
-
-		case OTG_STATE_A_WAIT_BCON:
-		case OTG_STATE_A_WAIT_VRISE:
-			pThis->xceiv.state = OTG_STATE_A_HOST;
-			break;
-		}
-		DBG(1, "CONNECT (host state %d)\n", pThis->xceiv.state);
-		otg_input_changed(pThis, devctl, FALSE, TRUE, FALSE);
-		*/
+		   switch (pThis->xceiv.state) {
+		   case OTG_STATE_B_WAIT_ACON:
+		   pThis->xceiv.state = OTG_STATE_B_HOST;
+		   break;
+		   default:
+		   DBG(2, "connect in state %d\n", pThis->xceiv.state);
+
+		   case OTG_STATE_A_WAIT_BCON:
+		   case OTG_STATE_A_WAIT_VRISE:
+		   pThis->xceiv.state = OTG_STATE_A_HOST;
+		   break;
+		   }
+		   DBG(1, "CONNECT (host state %d)\n", pThis->xceiv.state);
+		   otg_input_changed(pThis, devctl, FALSE, TRUE, FALSE);
+		 */
 //-----------------------------------------------------
 #ifdef CONFIG_USB_MUSB_OTG
 		otg_input_changed(pThis, devctl, FALSE, TRUE, FALSE);
-//		otg_input_changed(pThis,bIntrUSB,devctl,power);
+//              otg_input_changed(pThis,bIntrUSB,devctl,power);
 #endif
 
 		MGC_VirtualHubPortConnected(&pThis->RootHub, 0, speed);
 	}
-#endif	/* CONFIG_USB_MUSB_HDRC_HCD */
+#endif				/* CONFIG_USB_MUSB_HDRC_HCD */
 
 	/* saved one bit: bus reset and babble share the same bit;
 	 * If I am host is a babble! i must be the only one allowed
@@ -615,11 +726,11 @@ printk ("VBUS_ERR\n\n");
 			/* HBG 13SEPT2006 removed as part of OTG improvements */
 			//-----------------------------------------------------
 			//reading state from Power register doesn't works
-			
-				otg_input_changed(pThis, devctl, TRUE, FALSE,
-						 (power & MGC_M_POWER_SUSPENDM)
-						 ? TRUE : FALSE);
-			
+
+			otg_input_changed(pThis, devctl, TRUE, FALSE,
+					  (power & MGC_M_POWER_SUSPENDM)
+					  ? TRUE : FALSE);
+
 			//-----------------------------------------------------
 
 			/* HBG 13SEPT2006 OTG implementation */
@@ -645,8 +756,8 @@ printk ("VBUS_ERR\n\n");
  * @param devctl
  * @param power
  */
-static irqreturn_t musb_stage2_irq(struct musb * pThis, u8 bIntrUSB,
-				    u8 devctl, u8 power)
+static irqreturn_t musb_stage2_irq(struct musb *pThis, u8 bIntrUSB,
+				   u8 devctl, u8 power)
 {
 	irqreturn_t handled = IRQ_NONE;
 
@@ -658,7 +769,7 @@ static irqreturn_t musb_stage2_irq(struc
 	void __iomem *pBase = pThis->pRegs;
 
 	if (bIntrUSB & MGC_M_INTR_SOF) {
-		struct musb_hw_ep	*ep;
+		struct musb_hw_ep *ep;
 
 		DBG(6, "START_OF_FRAME\n");
 		handled = IRQ_HANDLED;
@@ -667,15 +778,13 @@ static irqreturn_t musb_stage2_irq(struc
 		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
 		ep = pThis->aLocalEnd;
 		for (bEnd = 1; (bEnd < pThis->bEndCount)
-					&& (pThis->wEndMask >= (1 << bEnd));
-				bEnd++, ep++) {
+		     && (pThis->wEndMask >= (1 << bEnd)); bEnd++, ep++) {
 			// FIXME handle framecounter wraps (12 bits)
 			// eliminate duplicated StartUrb logic
 			if (ep->dwWaitFrame >= wFrame) {
 				ep->dwWaitFrame = 0;
 				printk("SOF --> periodic TX%s on %d\n",
-					ep->pDmaChannel ? " DMA" : "",
-					bEnd);
+				       ep->pDmaChannel ? " DMA" : "", bEnd);
 				if (!ep->pDmaChannel)
 					MGC_HdrcStartTx(pThis, bEnd);
 				else
@@ -687,7 +796,7 @@ static irqreturn_t musb_stage2_irq(struc
 
 	if ((bIntrUSB & MGC_M_INTR_DISCONNECT) && !pThis->bIgnoreDisconnect) {
 		DBG(1, "DISCONNECT as %s, devctl %02x\n",
-				MUSB_MODE(pThis), devctl);
+		    MUSB_MODE(pThis), devctl);
 		handled = IRQ_HANDLED;
 
 		/* need to check it against pThis, because devctl is going
@@ -702,7 +811,7 @@ static irqreturn_t musb_stage2_irq(struc
 		//-----------------------------------------------------
 		// REVISIT all OTG state machine transitions
 		otg_input_changed_X(pThis, FALSE, FALSE);
-		
+
 		//-----------------------------------------------------
 		/* HBG 21SEPT2006 OTG implementation */
 
@@ -736,7 +845,7 @@ static irqreturn_t musb_stage2_irq(struc
 /*
 * Program the HDRC to start (enable interrupts, etc.).
 */
-void musb_start(struct musb * pThis)
+void musb_start(struct musb *pThis)
 {
 	void __iomem *pBase = pThis->pRegs;
 	u8 state;
@@ -757,7 +866,8 @@ void musb_start(struct musb * pThis)
 	/* enable high-speed/low-power and start session */
 	/* also set MGC_M_POWER_ENSUSPEND, fix the USB attach issue */
 	musb_writeb(pBase, MGC_O_HDRC_POWER,
-		   MGC_M_POWER_SOFTCONN | MGC_M_POWER_HSENAB | MGC_M_POWER_ENSUSPEND);
+		    MGC_M_POWER_SOFTCONN | MGC_M_POWER_HSENAB |
+		    MGC_M_POWER_ENSUSPEND);
 
 	switch (pThis->board_mode) {
 	case MUSB_HOST:
@@ -768,7 +878,7 @@ void musb_start(struct musb * pThis)
 	case MUSB_PERIPHERAL:
 		state = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
 		musb_writeb(pBase, MGC_O_HDRC_DEVCTL,
-				state & ~MGC_M_DEVCTL_SESSION);
+			    state & ~MGC_M_DEVCTL_SESSION);
 		break;
 	}
 
@@ -776,11 +886,10 @@ void musb_start(struct musb * pThis)
 		tusb_enable(pThis);
 }
 
-
 static void musb_generic_disable(struct musb *pThis)
 {
-	void	*__iomem pBase = pThis->pRegs;
-	u16	temp;
+	void *__iomem pBase = pThis->pRegs;
+	u16 temp;
 
 	/* disable interrupts */
 	musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0);
@@ -802,7 +911,7 @@ static void musb_generic_disable(struct 
  * called with controller locked, irqs blocked
  * acts as a NOP unless some role activated the hardware
  */
-void musb_stop(struct musb * pThis)
+void musb_stop(struct musb *pThis)
 {
 	/* stop IRQs, timers, ... */
 	musb_platform_disable(pThis);
@@ -834,7 +943,8 @@ void musb_stop(struct musb * pThis)
 		// ... that will handle the OTG "rmmod gadget_driver"
 		// case more correctly, making the root hub vanish from
 		// userspace visibility ... may be awkward ...
-		for (bEnd = 0; bEnd < min(16, (int)pThis->bEndCount); bEnd++) {
+		for (bEnd = 0; bEnd < min(16, (int)pThis->bEndCount / 2);
+		     bEnd++) {
 			MGC_HdrcStopEnd(pThis, bEnd);
 		}
 	}
@@ -843,8 +953,8 @@ void musb_stop(struct musb * pThis)
 
 static void musb_shutdown(struct device *dev)
 {
-	struct musb	*musb = dev_get_drvdata(dev);
-	unsigned long	flags;
+	struct musb *musb = dev_get_drvdata(dev);
+	unsigned long flags;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 	musb_stop(musb);
@@ -852,30 +962,28 @@ static void musb_shutdown(struct device 
 	spin_unlock_irqrestore(&musb->Lock, flags);
 }
 
-
 #ifdef MUSB_C_DYNFIFO_DEF
 
 /*
  * We don't currently use dynamic fifo setup capability to do anything
  * more than selecting one of a bunch of predefined configurations.
  */
-static ushort __initdata fifo_mode = 1/*2*/;
+static ushort __initdata fifo_mode = 4 /*2 */ ;
 
 /* "modprobe ... fifo_mode=1" etc */
-module_param (fifo_mode, ushort, 0);
+module_param(fifo_mode, ushort, 0);
 MODULE_PARM_DESC(fifo_mode, "initial endpoint configuration");
 
-
 #define DYN_FIFO_SIZE (1<<(MUSB_C_RAM_BITS+2))
 
 enum fifo_style { FIFO_RXTX, FIFO_TX, FIFO_RX } __attribute__ ((packed));
 enum buf_mode { BUF_SINGLE, BUF_DOUBLE } __attribute__ ((packed));
 
 struct fifo_cfg {
-	u8		hw_ep_num;
-	enum fifo_style	style;
-	enum buf_mode	mode;
-	u16		maxpacket;
+	u8 hw_ep_num;
+	enum fifo_style style;
+	enum buf_mode mode;
+	u16 maxpacket;
 };
 
 /*
@@ -884,40 +992,55 @@ struct fifo_cfg {
 
 /* mode 0 - fits in 2KB */
 static struct fifo_cfg __initdata mode_0_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+	{.hw_ep_num = 1,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 3,.style = FIFO_RXTX,.maxpacket = 256,},
+	{.hw_ep_num = 4,.style = FIFO_RXTX,.maxpacket = 256,},
 };
 
 /* mode 1 - fits in 4KB */
 static struct fifo_cfg __initdata mode_1_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+/*{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },*/
+	{.hw_ep_num = 1,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 3,.style = FIFO_RXTX,.maxpacket = 256,},
+	{.hw_ep_num = 4,.style = FIFO_RXTX,.maxpacket = 256,},
 };
 
 /* mode 2 - fits in 4KB */
 static struct fifo_cfg __initdata mode_2_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+	{.hw_ep_num = 1,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 1,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 3,.style = FIFO_RXTX,.maxpacket = 256,},
+	{.hw_ep_num = 4,.style = FIFO_RXTX,.maxpacket = 256,},
 };
 
 /* mode 3 - fits in 4KB */
 static struct fifo_cfg __initdata mode_3_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+	{.hw_ep_num = 1,.style = FIFO_TX,.maxpacket = 512,.mode = BUF_DOUBLE,},
+	{.hw_ep_num = 1,.style = FIFO_RX,.maxpacket = 512,.mode = BUF_DOUBLE,},
+	{.hw_ep_num = 2,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 3,.style = FIFO_RXTX,.maxpacket = 256,},
+	{.hw_ep_num = 4,.style = FIFO_RXTX,.maxpacket = 256,},
 };
 
+/* mode 4 - fits in 4KB */
+static struct fifo_cfg __initdata mode_4_cfg[] = {
+/*{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },*/
+	{.hw_ep_num = 1,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 2,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 3,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 4,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 5,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 6,.style = FIFO_RX,.maxpacket = 512,},
+	{.hw_ep_num = 7,.style = FIFO_TX,.maxpacket = 512,},
+	{.hw_ep_num = 8,.style = FIFO_RX,.maxpacket = 256,},
+};
 
 /*
  * configure a fifo; for non-shared endpoints, this may be called
@@ -926,14 +1049,14 @@ static struct fifo_cfg __initdata mode_3
  * returns negative errno or offset for next fifo.
  */
 static int __init
-fifo_setup(struct musb *musb, struct musb_hw_ep  *hw_ep,
-		const struct fifo_cfg *cfg, u16 offset)
+fifo_setup(struct musb *musb, struct musb_hw_ep *hw_ep,
+	   const struct fifo_cfg *cfg, u16 offset)
 {
-	void	*__iomem mbase = musb->pRegs;
-	int	size = 0;
-	u16	maxpacket = cfg->maxpacket;
-	u16	c_off = offset >> 3;
-	u8	c_size;
+	void *__iomem mbase = musb->pRegs;
+	int size = 0;
+	u16 maxpacket = cfg->maxpacket;
+	u16 c_off = offset >> 3;
+	u8 c_size;
 
 	/* expect hw_ep has already been zero-initialized */
 
@@ -962,11 +1085,10 @@ fifo_setup(struct musb *musb, struct mus
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 		/* reserve some OUT endpoint for bulk */
 		if (!musb->bulk_tx_end
-				&& hw_ep != musb->bulk_rx_end
-				&& maxpacket >= 512) {
+		    && hw_ep != musb->bulk_rx_end && maxpacket >= 512) {
 			musb->bulk_tx_end = hw_ep;
-			hw_ep->out_traffic_type = PIPE_BULK;;
-			hw_ep->bIsClaimed = 1;
+			hw_ep->out_traffic_type = PIPE_BULK;
+//                      hw_ep->bIsClaimed = 1;
 		}
 #endif
 		break;
@@ -978,11 +1100,10 @@ fifo_setup(struct musb *musb, struct mus
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 		/* reserve some IN endpoint for bulk */
 		if (!musb->bulk_rx_end
-				&& hw_ep != musb->bulk_tx_end
-				&& maxpacket >= 512) {
+		    && hw_ep != musb->bulk_tx_end && maxpacket >= 512) {
 			musb->bulk_rx_end = hw_ep;
-			hw_ep->in_traffic_type = PIPE_BULK;;
-			hw_ep->bIsClaimed = 1;
+			hw_ep->in_traffic_type = PIPE_BULK;
+//                      hw_ep->bIsClaimed = 1;
 		}
 #endif
 		break;
@@ -1018,15 +1139,15 @@ fifo_setup(struct musb *musb, struct mus
 }
 
 static struct fifo_cfg __initdata ep0_cfg = {
-	.style = FIFO_RXTX, .maxpacket = 64,
+	.style = FIFO_RXTX,.maxpacket = 64,
 };
 
 static int __init ep_config_from_table(struct musb *musb)
 {
-	const struct fifo_cfg	*cfg;
-	unsigned		n;
-	int			offset;
-	struct musb_hw_ep	*hw_ep = musb->aLocalEnd;
+	const struct fifo_cfg *cfg;
+	unsigned n;
+	int offset;
+	struct musb_hw_ep *hw_ep = musb->aLocalEnd;
 
 	switch (fifo_mode) {
 	default:
@@ -1048,27 +1169,29 @@ static int __init ep_config_from_table(s
 		cfg = mode_3_cfg;
 		n = ARRAY_SIZE(mode_3_cfg);
 		break;
+	case 4:
+		cfg = mode_4_cfg;
+		n = ARRAY_SIZE(mode_4_cfg);
+		break;
 	}
 
 	printk(KERN_DEBUG "%s: setup fifo_mode %d\n",
-			musb_driver_name, fifo_mode);
-
+	       musb_driver_name, fifo_mode);
 
 	offset = fifo_setup(musb, hw_ep, &ep0_cfg, 0);
 	// assert(offset > 0)
 
 	while (n--) {
-		u8	epn = cfg->hw_ep_num;
+		u8 epn = cfg->hw_ep_num;
 
 		if (epn >= MUSB_C_NUM_EPS) {
-			pr_debug( "%s: invalid ep %d\n",
-					musb_driver_name, epn);
+			pr_debug("%s: invalid ep %d\n", musb_driver_name, epn);
 			return -EINVAL;
 		}
 		offset = fifo_setup(musb, hw_ep + epn, cfg++, offset);
 		if (offset < 0) {
-			pr_debug( "%s: mem overrun, ep %d\n",
-					musb_driver_name, epn);
+			pr_debug("%s: mem overrun, ep %d\n",
+				 musb_driver_name, epn);
 			return -EINVAL;
 		}
 		epn++;
@@ -1077,8 +1200,8 @@ static int __init ep_config_from_table(s
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* for now, bulk uses two reserved endpoints */
-	if (!musb->bulk_rx_end ||!musb->bulk_tx_end) {
-		pr_debug( "%s: missing bulk TX or RX\n", musb_driver_name);
+	if (!musb->bulk_rx_end || !musb->bulk_tx_end) {
+		pr_debug("%s: missing bulk TX or RX\n", musb_driver_name);
 		return -EINVAL;
 	}
 #endif
@@ -1215,9 +1338,9 @@ static int __init musb_core_init(u16 wTy
 	char *type;
 	u16 wRelease, wRelMajor, wRelMinor;
 	char aInfo[78], aRevision[32], aDate[12];
-	void __iomem	*pBase = pThis->pRegs;
-	int		status = 0;
-	int		i;
+	void __iomem *pBase = pThis->pRegs;
+	int status = 0;
+	int i;
 
 	/* log core options */
 	MGC_SelectEnd(pBase, 0);
@@ -1252,7 +1375,7 @@ static int __init musb_core_init(u16 wTy
 	}
 
 	printk(KERN_DEBUG "%s: ConfigData=0x%02x (%s)\n",
-			musb_driver_name, reg, aInfo);
+	       musb_driver_name, reg, aInfo);
 
 #ifdef MUSB_AHB_ID
 	dwData = musb_readl(pBase, 0x404);
@@ -1283,7 +1406,7 @@ static int __init musb_core_init(u16 wTy
 	snprintf(aRevision, 32, "%d.%d%s", wRelMajor,
 		 wRelMinor, (wRelease & 0x8000) ? "RC" : "");
 	printk(KERN_DEBUG "%s: %sHDRC RTL version %s %s\n",
-			musb_driver_name, type, aRevision, aDate);
+	       musb_driver_name, type, aRevision, aDate);
 
 	/* configure ep0 */
 	pThis->aLocalEnd[0].wMaxPacketSizeTx = MGC_END0_FIFOSIZE;
@@ -1312,31 +1435,31 @@ static int __init musb_core_init(u16 wTy
 
 	/* finish init, and print endpoint config */
 	for (i = 0; i < pThis->bEndCount; i++) {
-		struct musb_hw_ep	*hw_ep = pThis->aLocalEnd + i;
+		struct musb_hw_ep *hw_ep = pThis->aLocalEnd + i;
 
-		hw_ep->fifo = MGC_FIFO_OFFSET(i) + pBase;
-		hw_ep->regs = MGC_END_OFFSET(i, 0) + pBase;
+		hw_ep->fifo = MGC_FIFO_OFFSET(hw_ep->bLocalEnd) + pBase;
+		hw_ep->regs = MGC_END_OFFSET(hw_ep->bLocalEnd, 0) + pBase;
 
 		if (hw_ep->wMaxPacketSizeTx) {
 			printk(KERN_DEBUG
-				"%s: hw_ep %d%s, %smax %d\n",
-				musb_driver_name, i,
-				hw_ep->bIsSharedFifo ? "shared" : "tx",
-				hw_ep->tx_double_buffered
-					? "doublebuffer, " : "",
-				hw_ep->wMaxPacketSizeTx);
+			       "%s: hw_ep %d%s, %smax %d\n",
+			       musb_driver_name, hw_ep->bLocalEnd,
+			       hw_ep->bIsSharedFifo ? "shared" : "tx",
+			       hw_ep->tx_double_buffered
+			       ? "doublebuffer, " : "",
+			       hw_ep->wMaxPacketSizeTx);
 		}
 		if (hw_ep->wMaxPacketSizeRx && !hw_ep->bIsSharedFifo) {
 			printk(KERN_DEBUG
-				"%s: hw_ep %d%s, %smax %d\n",
-				musb_driver_name, i,
-				"rx",
-				hw_ep->rx_double_buffered
-					? "doublebuffer, " : "",
-				hw_ep->wMaxPacketSizeRx);
+			       "%s: hw_ep %d%s, %smax %d\n",
+			       musb_driver_name, hw_ep->bLocalEnd,
+			       "rx",
+			       hw_ep->rx_double_buffered
+			       ? "doublebuffer, " : "",
+			       hw_ep->wMaxPacketSizeRx);
 		}
 		if (!(hw_ep->wMaxPacketSizeTx || hw_ep->wMaxPacketSizeRx))
-			DBG(1, "hw_ep %d not configured\n", i);
+			DBG(1, "hw_ep %d not configured\n", hw_ep->bLocalEnd);
 	}
 
 	return 0;
@@ -1370,9 +1493,9 @@ static int __init musb_core_init(u16 wTy
 
 /* Allocate a dma-coherent buffer */
 void *musb_alloc_buffer(struct musb *musb,
-			    size_t bytes, gfp_t gfp_flags, dma_addr_t * dma)
+			size_t bytes, gfp_t gfp_flags, dma_addr_t * dma)
 {
-	void *addr;
+	void *addr = NULL;
 
 	if (USE_KMALLOC) {
 		addr = kmalloc(bytes, gfp_flags);
@@ -1393,8 +1516,9 @@ void *musb_alloc_buffer(struct musb *mus
 		 */
 #endif
 		addr = dma_alloc_coherent(musb->controller,
-				(bytes < PAGE_SIZE) ? PAGE_SIZE : bytes,
-				dma, gfp_flags);
+					  (bytes <
+					   PAGE_SIZE) ? PAGE_SIZE : bytes, dma,
+					  gfp_flags);
 	}
 	if (!addr)
 		*dma = DMA_ADDR_INVALID;
@@ -1403,12 +1527,12 @@ void *musb_alloc_buffer(struct musb *mus
 
 /* Free memory previously allocated with AllocBufferMemory */
 void musb_free_buffer(struct musb *musb,
-			  size_t bytes, void *address, dma_addr_t dma)
+		      size_t bytes, void *address, dma_addr_t dma)
 {
 	if (!USE_KMALLOC)
 		dma_free_coherent(musb->controller,
-				(bytes < PAGE_SIZE) ? PAGE_SIZE : bytes,
-				address, dma);
+				  (bytes < PAGE_SIZE) ? PAGE_SIZE : bytes,
+				  address, dma);
 	else
 		kfree(address);
 }
@@ -1421,9 +1545,9 @@ void musb_free_buffer(struct musb *musb,
 
 static irqreturn_t generic_interrupt(int irq, void *__hci, struct pt_regs *r)
 {
-	unsigned long	flags;
-	irqreturn_t	retval = IRQ_NONE;
-	struct musb	*musb = __hci;
+	unsigned long flags;
+	irqreturn_t retval = IRQ_NONE;
+	struct musb *musb = __hci;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
@@ -1449,19 +1573,19 @@ static irqreturn_t generic_interrupt(int
  *
  * called in irq context with spinlock held, irqs blocked
  */
-irqreturn_t musb_interrupt(struct musb *musb)
+irqreturn_t musb_interrupt(struct musb * musb)
 {
-	irqreturn_t	retval = IRQ_NONE;
-	u8		devctl, power;
-	int		ep_num;
-	u32		reg;
+	irqreturn_t retval = IRQ_NONE;
+	u8 devctl, power;
+	int ep_num;
+	u32 reg;
 
 	devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
 	power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
 
 	DBG(3, "<== IRQ %s usb%04x tx%04x rx%04x\n",
-		(devctl & MGC_M_DEVCTL_HM) ? "host" : "peripheral",
-		musb->int_usb, musb->int_tx, musb->int_rx);
+	    (devctl & MGC_M_DEVCTL_HM) ? "host" : "peripheral",
+	    musb->int_usb, musb->int_tx, musb->int_rx);
 	/* ignore requests when in error */
 	if (MUSB_IS_ERR(musb)) {
 		WARN("irq in error\n");
@@ -1473,8 +1597,7 @@ irqreturn_t musb_interrupt(struct musb *
 	 * a generic interrupt flowchart to follow
 	 */
 	if (musb->int_usb)
-		retval |= musb_stage0_irq(musb, musb->int_usb,
-				devctl, power);
+		retval |= musb_stage0_irq(musb, musb->int_usb, devctl, power);
 
 	/* "stage 1" is handling endpoint irqs */
 
@@ -1521,13 +1644,11 @@ irqreturn_t musb_interrupt(struct musb *
 
 	/* finish handling "global" interrupts after handling fifos */
 	if (musb->int_usb)
-		retval |= musb_stage2_irq(musb,
-				musb->int_usb, devctl, power);
+		retval |= musb_stage2_irq(musb, musb->int_usb, devctl, power);
 
 	return retval;
 }
 
-
 #ifndef CONFIG_USB_INVENTRA_FIFO
 static int __initdata use_dma = is_dma_capable();
 
@@ -1539,12 +1660,11 @@ MODULE_PARM_DESC(use_dma, "enable/disabl
  * DMA support
  */
 
-static int musb_dma_completion(void *pPrivateData,
-		u8 bLocalEnd, u8 bTransmit)
+static int musb_dma_completion(void *pPrivateData, u8 bLocalEnd, u8 bTransmit)
 {
-	struct musb	*pThis = pPrivateData;
-	const void	__iomem *pBase = pThis->pRegs;
-	u8		devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	struct musb *pThis = pPrivateData;
+	const void __iomem *pBase = pThis->pRegs;
+	u8 devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
 
 	/* called with controller lock already held */
 
@@ -1584,11 +1704,11 @@ static int musb_dma_completion(void *pPr
  * Init support
  */
 
-static struct musb *__init allocate_instance(void __iomem *mbase)
+static struct musb *__init allocate_instance(void __iomem * mbase)
 {
-	struct musb		*pThis;
-	struct musb_hw_ep	*ep;
-	int			epnum;
+	struct musb *pThis;
+	struct musb_hw_ep *ep;
+	int epnum, tmp = 0;
 
 	/* allocate */
 	pThis = kzalloc(sizeof *pThis, GFP_KERNEL);
@@ -1599,11 +1719,10 @@ static struct musb *__init allocate_inst
 	pThis->ctrl_base = mbase;
 	pThis->nIrq = -ENODEV;
 	for (epnum = 0, ep = pThis->aLocalEnd;
-			epnum < MUSB_C_NUM_EPS;
-			epnum++, ep++) {
+	     epnum < MUSB_C_NUM_EPS; epnum++, ep++) {
 
 		ep->musb = pThis;
-		ep->bLocalEnd = epnum;
+		ep->bLocalEnd = (epnum % 2) ? ++tmp : tmp;
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 		/* busctl regs too? */
@@ -1623,7 +1742,7 @@ static void musb_free(struct musb *musb)
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	if (musb->pBus) {
-		struct usb_bus	*bus = musb->pBus;
+		struct usb_bus *bus = musb->pBus;
 
 		MGC_VirtualHubStop(&musb->RootHub);
 		if (bus->root_hub) {
@@ -1640,17 +1759,18 @@ static void musb_free(struct musb *musb)
 	if (musb->nIrq >= 0)
 		free_irq(musb->nIrq, musb);
 	if (is_dma_capable() && musb->pDmaController) {
-		musb->pDmaController->pfDmaStopController(
-					musb->pDmaController->pPrivateData);
-		dma_controller_factory.pfDestroyDmaController(
-					musb->pDmaController);
+		musb->pDmaController->pfDmaStopController(musb->pDmaController->
+							  pPrivateData);
+		dma_controller_factory.pfDestroyDmaController(musb->
+							      pDmaController);
 	}
 	musb_platform_exit(musb);
+#ifdef CONFIG_ARCH_DAVINCI
 	if (musb->clock) {
 		clk_disable(musb->clock);
 		clk_put(musb->clock);
 	}
-
+#endif
 	/* FIXME make sure all the different faces of this driver
 	 * coordinate their refcounting, so the same release() is
 	 * called when the host or gadget (or whatever) is the last
@@ -1668,16 +1788,16 @@ static void musb_free(struct musb *musb)
  * 	not yet corrected for platform-specific offsets
  */
 static int __init
-musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
+musb_init_controller(struct device *dev, int nIrq, void __iomem * ctrl)
 {
-	int			status;
-	struct musb		*pThis;
+	int status;
+	struct musb *pThis;
 	struct musb_hdrc_platform_data *plat = dev->platform_data;
 
 	/* The driver might handle more features than the board; OK.
 	 * Fail when the board needs a feature that's not enabled.
 	 */
-	
+
 	if (!plat) {
 		dev_dbg(dev, "no platform_data?\n");
 		return -ENODEV;
@@ -1698,9 +1818,8 @@ musb_init_controller(struct device *dev,
 	case MUSB_OTG:
 #ifdef CONFIG_USB_MUSB_OTG
 		break;
-#else
-	bad_config:
 #endif
+	      bad_config:
 	default:
 		dev_dbg(dev, "incompatible Kconfig role setting\n");
 		return -EINVAL;
@@ -1728,15 +1847,15 @@ musb_init_controller(struct device *dev,
 
 	if (use_dma && dev->dma_mask) {
 		pThis->pDmaController =
-			dma_controller_factory.pfNewDmaController(
-					musb_dma_completion,
-					pThis, pThis->pRegs);
+		    dma_controller_factory.
+		    pfNewDmaController(musb_dma_completion, pThis,
+				       pThis->pRegs);
 		if (pThis->pDmaController)
-			pThis->pDmaController->pfDmaStartController(
-					pThis->pDmaController->pPrivateData);
+			pThis->pDmaController->pfDmaStartController(pThis->
+								    pDmaController->
+								    pPrivateData);
 	}
 
-
 	/* Hack for now and save the value here
 	   so that we can use the use_dma module param */
 	pThis->old_dma_mask = dev->dma_mask;
@@ -1750,31 +1869,30 @@ musb_init_controller(struct device *dev,
 
 	/* setup musb parts of the core (especially endpoints) */
 	status = musb_core_init(plat->multipoint
-			   ? MUSB_CONTROLLER_MHDRC
-			   : MUSB_CONTROLLER_HDRC, pThis);
+				? MUSB_CONTROLLER_MHDRC
+				: MUSB_CONTROLLER_HDRC, pThis);
 	if (status < 0)
 		goto fail;
 
 	/* attach to the IRQ */
-	if (request_irq (nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
+	if (request_irq(nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
 		dev_err(dev, "request_irq %d failed!\n", nIrq);
 		status = -ENODEV;
 		goto fail;
 	}
+
 	pThis->nIrq = nIrq;
 
 	pr_info("%s: USB %s mode controller at %p using %s, IRQ %d\n",
-			musb_driver_name,
-			({char *s;
-			switch (pThis->board_mode) {
-			case MUSB_HOST:		s = "Host"; break;
-			case MUSB_PERIPHERAL:	s = "Peripheral"; break;
-			default:		s = "OTG"; break;
-			}; s; }),
-			ctrl,
-			(is_dma_capable() && pThis->pDmaController)
-				? "DMA" : "PIO",
-			pThis->nIrq);
+		musb_driver_name, ( {
+				   char *s;
+				   switch (pThis->board_mode) {
+case MUSB_HOST:
+s = "Host"; break; case MUSB_PERIPHERAL:
+s = "Peripheral"; break; default:
+				   s = "OTG"; break;}; s;}
+		), ctrl, (is_dma_capable() && pThis->pDmaController)
+		? "DMA" : "PIO", pThis->nIrq) ;
 
 // FIXME:
 //  - convert to the HCD framework
@@ -1784,16 +1902,15 @@ musb_init_controller(struct device *dev,
 /* HBG 21SEPT2006 modified for OTG modifications */
 //===================================================
 #ifdef CONFIG_USB_MUSB_OTG
+	{
+		struct proc_dir_entry *pde;
+		pde = create_proc_entry("driver/otg", 0, NULL);
+		if (pde) {
+			pde->write_proc = musb_app_inputs;
+			pde->data = pThis;
+		}
 
-{
-	struct proc_dir_entry	*pde;
-	pde = create_proc_entry("otg", 0, NULL);
-	if(pde){
-		pde->write_proc = musb_app_inputs;
-		pde->data = pThis; 
 	}
-
-}
 	MGC_OtgMachineInit(&pThis->OtgMachine, pThis);
 #endif
 //===================================================
@@ -1801,7 +1918,7 @@ musb_init_controller(struct device *dev,
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* host side needs more setup, except for no-host modes */
 	if (pThis->board_mode != MUSB_PERIPHERAL) {
-		struct usb_bus	*bus;
+		struct usb_bus *bus;
 
 		/* allocate and register bus */
 		bus = usb_alloc_bus(&musb_host_bus_ops);
@@ -1810,11 +1927,12 @@ musb_init_controller(struct device *dev,
 			status = -ENOMEM;
 			goto fail;
 		}
+
 		pThis->pBus = bus;
 
 		init_timer(&pThis->Timer);
 		pThis->Timer.function = musb_timer_done;
-		pThis->Timer.data = (unsigned long) pThis;
+		pThis->Timer.data = (unsigned long)pThis;
 
 		/* register the bus */
 		bus->controller = dev;
@@ -1843,8 +1961,7 @@ musb_init_controller(struct device *dev,
 		}
 
 		/* init virtual root hub */
-		if (!MGC_VirtualHubInit(&pThis->RootHub, pThis->pBus,
-					 pThis)) {
+		if (!MGC_VirtualHubInit(&pThis->RootHub, pThis->pBus, pThis)) {
 			dev_dbg(dev, "Virtual Hub init failed\n");
 			status = -ENODEV;
 			goto fail;
@@ -1875,7 +1992,6 @@ musb_init_controller(struct device *dev,
 		//pThis->xceiv.state = OTG_STATE_A_IDLE;
 		//-----------------------------------------------------
 		status = usb_register_root_hub(pThis->RootHub.pDevice, dev);
-
 #if 0
 		/* FIXME 2.6.10 doesn't budget root hub power correctly, AND
 		 * can only modify budgets after hub driver binds
@@ -1886,23 +2002,10 @@ musb_init_controller(struct device *dev,
 #endif
 
 		DBG(1, "%s mode, status %d, devctl %02x %c\n",
-			"HOST", status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
-			(musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
-					& MGC_M_DEVCTL_BDEVICE
-				? 'B' : 'A'));
-#if HOST_TX_DMA_SOLUTION == 1
-		/* Description: Notify the thread handling the Host TX DMA completion.
-		 *
-		 * Reason for change:
-		 * Host mode TX DMA does not function, stops with urb_unlink.
-		 *
-		 * Fixed MRs:
-		 * 2530: <USB Host> File IO operation among 2 USB flash drives connected
-		 *    to the Hub fails.
-		 */
-		complete(&hostTxThreadNotify);
-#endif
+		    "HOST", status,
+		    musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
+		    (musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
+		     & MGC_M_DEVCTL_BDEVICE ? 'B' : 'A'));
 
 #ifndef CONFIG_USB_MUSB_OTG
 		break;
@@ -1914,31 +2017,20 @@ musb_init_controller(struct device *dev,
 		status = musb_gadget_setup(pThis);
 
 		DBG(1, "%s mode, status %d, dev%02x\n",
-			"PERIPHERAL", status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
+		    "PERIPHERAL", status,
+		    musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
 #ifndef CONFIG_USB_MUSB_OTG
 		break;
 #endif
 #endif
-#if 0 /* Swami Modified this */
-#ifdef CONFIG_USB_MUSB_OTG
-	case MUSB_OTG:
-		MUSB_OTG_MODE(pThis);
-		status = musb_gadget_setup(pThis);
-
-		DBG(1, "%s mode, status %d, dev%02x\n",
-			"OTG", status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
-		break;
-#endif
-#endif
 	default:
 		break;
 	}
+
 	if (status == 0)
 		musb_debug_create("driver/musb_hdrc", pThis);
 	else {
-fail:
+	      fail:
 		musb_free(pThis);
 	}
 	return status;
@@ -1959,19 +2051,21 @@ static int __init musb_probe(struct devi
 	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!iomem || irq == 0)
 		return -ENODEV;
-
+#ifdef CONFIG_ARCH_DAVINCI
 	base = ioremap(iomem->start, iomem->end - iomem->start + 1);
 	if (!base) {
 		dev_err(dev, "ioremap failed\n");
 		return -ENOMEM;
 	}
-
+#else
+	base = (void *__iomem)iomem->start;
+#endif
 	return musb_init_controller(dev, irq, base);
 }
 
 static int __exit musb_remove(struct device *dev)
 {
-	struct musb	*musb = dev_get_drvdata(dev);
+	struct musb *musb = dev_get_drvdata(dev);
 
 	/* this gets called on rmmod.
 	 *  - Host mode: host may still be hactive
@@ -1998,8 +2092,8 @@ static int __exit musb_remove(struct dev
 
 static int musb_suspend(struct device *dev, u32 state, u32 level)
 {
-	struct musb	*musb = dev_get_drvdata(dev);
-	unsigned long	flags;
+	struct musb *musb = dev_get_drvdata(dev);
+	unsigned long flags;
 
 	if (level != SUSPEND_POWER_DOWN || !musb->clock)
 		return 0;
@@ -2015,22 +2109,25 @@ static int musb_suspend(struct device *d
 		 * they will even be wakeup-enabled
 		 */
 	}
-
+#ifdef CONFIG_ARCH_DAVINCI
 	clk_disable(musb->clock);
+#endif
 	spin_unlock_irqrestore(&musb->Lock, flags);
 	return 0;
 }
 
 static int musb_resume(struct device *dev, u32 level)
 {
-	struct musb	*musb = dev_get_drvdata(dev);
-	unsigned long	flags;
+	struct musb *musb = dev_get_drvdata(dev);
+	unsigned long flags;
 
 	if (level != RESUME_POWER_ON || !musb->clock)
 		return 0;
 
 	spin_lock_irqsave(&musb->Lock, flags);
+#ifdef CONFIG_ARCH_DAVINCI
 	clk_enable(musb->clock);
+#endif
 	/* for static cmos like DaVinci, register values were preserved
 	 * unless for some reason the whole soc powered down and we're
 	 * not treating that as a whole-system restart (e.g. swsusp)
@@ -2045,14 +2142,14 @@ static int musb_resume(struct device *de
 #endif
 
 static struct device_driver musb_driver = {
-	.name		= (char *)musb_driver_name,
-	.bus		= &platform_bus_type,
-	.owner		= THIS_MODULE,
-	.probe		= musb_probe,
-	.remove		= __exit_p(musb_remove),
-	.shutdown	= musb_shutdown,
-	.suspend	= musb_suspend,
-	.resume		= musb_resume,
+	.name = (char *)musb_driver_name,
+	.bus = &platform_bus_type,
+	.owner = THIS_MODULE,
+	.probe = musb_probe,
+	.remove = __exit_p(musb_remove),
+	.shutdown = musb_shutdown,
+	.suspend = musb_suspend,
+	.resume = musb_resume,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -2066,15 +2163,15 @@ static int __init musb_init(void)
 
 	pr_info("%s: version " MUSB_VERSION " "
 #ifdef CONFIG_USB_INVENTRA_FIFO
-	       "[pio]"
+		"[pio]"
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
-	       "[cppi-dma]"
+		"[cppi-dma]"
 #elif defined(CONFIG_USB_INVENTRA_DMA)
-	       "[musb-dma]"
+		"[musb-dma]"
 #else
-	       "[?]"
+		"[?]"
 #endif
-	       " "
+		" "
 #ifdef CONFIG_USB_MUSB_OTG
 		"[otg: peripheral+host]"
 #elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
@@ -2082,108 +2179,77 @@ static int __init musb_init(void)
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
 		"[host]"
 #endif
-	       " [debug=%d]\n",
-	       musb_driver_name, MGC_GetDebugLevel());
-
-#ifdef HOST_TX_DMA_SOLUTION
-/* Description: Initialize the globals for the Host TX DMA
- *    completion solution (thread/tasklet).
- *
- * Reason for change:
- * Host mode TX DMA does not function, stops with urb_unlink.
- *
- * Fixed MRs:
- * 2530: <USB Host> File IO operation among 2 USB flash drives connected
- *    to the Hub fails.
- */
-
-	/* Initialize the host tx completion list head */
-	INIT_LIST_HEAD(&tx_completion_list);
-#ifdef CONFIG_PREEMPT_RT
-	sema_init(&txReqListLock, 1); /* semaphore is available initially */
-#endif
-
-#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
-
-	init_completion(&hostTxThreadNotify);
-
-	/* start the kernel thread to process host tx completion */
-	if (kernel_thread(musb_host_tx_completion_thread, NULL, CLONE_KERNEL) < 0)
-		return 0;
-
-#endif
-
-#endif
+		" [debug=%d]\n", musb_driver_name, MGC_GetDebugLevel());
 
 	return driver_register(&musb_driver);
 }
 
 /* make us init after usbcore and before usb
  * gadget and host-side drivers start to register
-
-subsys_initcall(musb_init); */
-device_initcall(musb_init);
+ */
+subsys_initcall(musb_init);
+//device_initcall(musb_init);
 
 static void __exit musb_cleanup(void)
 {
-#ifdef CONFIG_USB_MUSB_OTG	
-	remove_proc_entry("otg", NULL);
+#ifdef CONFIG_USB_MUSB_OTG
+	remove_proc_entry("driver/otg", NULL);
 #endif
 	driver_unregister(&musb_driver);
 }
+
 module_exit(musb_cleanup);
+#ifdef CONFIG_USB_MUSB_OTG
 /* HBG Testing 15SEPT2006 */
 
-#ifdef CONFIG_USB_MUSB_OTG
-static int musb_app_inputs(struct file *file, const char __user *buffer,
-			 unsigned long count, void *data)
+static int musb_app_inputs(struct file *file, const char __user * buffer,
+			   unsigned long count, void *data)
 {
-		u8 busReq;
-		struct musb *pThis = data;
-		unsigned long	flags;
-		copy_from_user(&busReq,buffer,1);
-		switch(busReq){
-		case 'i':
-			busReq=MGC_OTG_REQUEST_START_BUS;
-			break;
-		case 's':
-			busReq=MGC_OTG_REQUEST_SUSPEND_BUS;
-			break;
-		case 'e':
-			busReq=MGC_OTG_REQUEST_DROP_BUS;
-            		break;
+	u8 busReq;
+	struct musb *pThis = data;
+	copy_from_user(&busReq, buffer, 1);
+	switch (busReq) {
+	case 'i':
+		busReq = MGC_OTG_REQUEST_START_BUS;
+		break;
+	case 's':
+		busReq = MGC_OTG_REQUEST_SUSPEND_BUS;
+		break;
+	case 'e':
+		busReq = MGC_OTG_REQUEST_DROP_BUS;
+		break;
 		/*case 'b':
-			busReq=MGC_OTG_REQUEST_START_BUS;
-			pThis->OtgMachine.bRequest = busReq;
-			return 1;
-			break;
-		case 'H':
-		case 'h':
-			BusReq=3;
-			printk("Start HNP\n");
-			break;
-		case 'S':
-			BusReq=4;
-			printk("Suspend the Bus\n");
-			break;*/
-		default:
-			return 1;
-			break;
-		}
-		pThis->OtgMachine.bRequest = busReq;
-		/* This is user initiated change so consider that
-		   the connection is active by default
-		 */
-		otg_input_changed_X(pThis,FALSE,TRUE);
+		   busReq=MGC_OTG_REQUEST_START_BUS;
+		   pThis->OtgMachine.bRequest = busReq;
+		   return 1;
+		   break;
+		   case 'H':
+		   case 'h':
+		   BusReq=3;
+		   printk("Start HNP\n");
+		   break;
+		   case 'S':
+		   BusReq=4;
+		   printk("Suspend the Bus\n");
+		   break; */
+	default:
 		return 1;
+		break;
+	}
+	pThis->OtgMachine.bRequest = busReq;
+	/* This is user initiated change so consider that
+	   the connection is active by default
+	 */
+	otg_input_changed_X(pThis, FALSE, TRUE);
+	return 1;
 }
 #endif
 
 /* HBG 22SEPT 2006 */
 /* ID pin sensing support to OTG.c */
-u8 is_otg_b_device ( struct musb * pThis)
+u8 is_otg_b_device(struct musb * pThis)
 {
 	u8 Devctl;
 	Devctl = musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL);
-	return ((Devctl & MGC_M_DEVCTL_BDEVICE) !=0);
+	return ((Devctl & MGC_M_DEVCTL_BDEVICE) != 0);
 }
Index: linux-2.6.10/drivers/usb/musb/tusb_6010.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/tusb_6010.c
+++ linux-2.6.10/drivers/usb/musb/tusb_6010.c
@@ -26,13 +26,12 @@
 #include "musbdefs.h"
 #include "tusb_6010.h"
 
-
 /*
  * TUSB 6010 may use a parallel bus that doesn't support byte ops;
  * so both loading and unloading FIFOs need explicit byte counts.
  */
 
-void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf)
+void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 * buf)
 {
 	void __iomem *ep_conf = hw_ep->regs;
 	void __iomem *fifo = hw_ep->fifo;
@@ -56,8 +55,8 @@ void musb_write_fifo(struct musb_hw_ep *
 			    TUSB_EP0_CONFIG_XFR_SIZE(len));
 
 	/* Write full 32-bit blocks from buffer to FIFO */
-	for (i = 0; i < (len / 4); i++ ) {
-		val = *(u32 *)bufp;
+	for (i = 0; i < (len / 4); i++) {
+		val = *(u32 *) bufp;
 		musb_writel(fifo, 0, val);
 		bufp += 4;
 	}
@@ -70,7 +69,7 @@ void musb_write_fifo(struct musb_hw_ep *
 	}
 }
 
-void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *buf)
+void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 * buf)
 {
 	void __iomem *ep_conf = hw_ep->regs;
 	void __iomem *fifo = hw_ep->fifo;
@@ -90,15 +89,14 @@ void musb_read_fifo(struct musb_hw_ep *h
 			    TUSB_EP0_CONFIG_XFR_SIZE(len));
 
 	/* Read full 32-bit blocks from FIFO to buffer */
-	for (i = 0; i < (len / 4); i++ ) {
+	for (i = 0; i < (len / 4); i++) {
 		u32 val = musb_readl(fifo, 0);
-		*(u32 *)buf = val;
+		*(u32 *) buf = val;
 
 		/* REVISIT: Remove this once things work reliably */
-		if (unlikely((u16)val == 0xdead)) {
+		if (unlikely((u16) val == 0xdead)) {
 			printk(KERN_ERR "tusb: FIFO dead: "
-					  "ep%d count %d buf %p\n",
-						epnum, len, buf);
+			       "ep%d count %d buf %p\n", epnum, len, buf);
 		}
 
 		buf += 4;
@@ -114,11 +112,11 @@ void musb_read_fifo(struct musb_hw_ep *h
 
 irqreturn_t tusb_interrupt(int irq, void *__hci, struct pt_regs *r)
 {
-	struct musb	* musb = __hci;
-	void __iomem	* base = musb->ctrl_base;
-	void		__iomem *musb_base = musb->pRegs;
-	unsigned long	flags;
-	u32		dma_src, int_src, otg_stat, musb_src = 0;
+	struct musb *musb = __hci;
+	void __iomem *base = musb->ctrl_base;
+	void __iomem *musb_base = musb->pRegs;
+	unsigned long flags;
+	u32 dma_src, int_src, otg_stat, musb_src = 0;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
@@ -145,15 +143,13 @@ irqreturn_t tusb_interrupt(int irq, void
 	/* Connect and disconnect */
 	if (int_src & TUSB_INT_SRC_USB_IP_CONN) {
 		DBG(3, "tusb: Connected\n");
-	}
-	else if (int_src & TUSB_INT_SRC_USB_IP_DISCON) {
+	} else if (int_src & TUSB_INT_SRC_USB_IP_DISCON) {
 		DBG(3, "tusb: Disconnected\n");
 	}
 
 	/* VBUS state change */
 	if ((int_src & TUSB_INT_SRC_VBUS_SENSE_CHNG) ||
-	    (int_src & TUSB_INT_SRC_USB_IP_VBUS_ERR))
-	{
+	    (int_src & TUSB_INT_SRC_USB_IP_VBUS_ERR)) {
 		DBG(3, "tusb: VBUS changed. VBUS state %d\n",
 		    (otg_stat & TUSB_DEV_OTG_STAT_VBUS_SENSE) ? 1 : 0);
 		if (!(otg_stat & TUSB_DEV_OTG_STAT_VBUS_SENSE) &&
@@ -162,7 +158,7 @@ irqreturn_t tusb_interrupt(int irq, void
 			DBG(3, "tusb: No VBUS, starting session\n");
 			/* Start session again, VBUS will be enabled */
 			musb_writeb(musb_base, MGC_O_HDRC_DEVCTL,
-				MGC_M_DEVCTL_SESSION);
+				    MGC_M_DEVCTL_SESSION);
 		}
 	}
 
@@ -203,22 +199,21 @@ irqreturn_t tusb_interrupt(int irq, void
 	return IRQ_HANDLED;
 }
 
-
 /*
  * Enables TUSB6010. Caller must take care of locking.
  * REVISIT:
  * - Check what is unnecessary in MGC_HdrcStart()
  * - Interrupt should really be IRQT_FALLING level sensitive
  */
-void tusb_enable(struct musb * musb)
+void tusb_enable(struct musb *musb)
 {
-	void __iomem * base = musb->ctrl_base;
+	void __iomem *base = musb->ctrl_base;
 
 	/* Setup TUSB6010 main interrupt mask. Enable all interrupts except
 	 * reserved ones and VLYNQ invalid access */
 	musb_writel(base, TUSB_INT_MASK,
-		TUSB_INT_SRC_RESERVED_MASK |
-		TUSB_INT_SRC_INVALID_ACCESS_MASK(0xf));
+		    TUSB_INT_SRC_RESERVED_MASK |
+		    TUSB_INT_SRC_INVALID_ACCESS_MASK(0xf));
 
 	/* Setup subsystem interrupt masks */
 	musb_writel(base, TUSB_USBIP_INT_MASK, 0);
@@ -231,20 +226,18 @@ void tusb_enable(struct musb * musb)
 	musb_writel(base, TUSB_GPIO_INT_CLEAR, 0x1ff);
 
 	/* Acknowledge pending interrupt(s) */
-	musb_writel(base, TUSB_INT_SRC_CLEAR,
-		    ~TUSB_INT_SRC_RESERVED_MASK);
+	musb_writel(base, TUSB_INT_SRC_CLEAR, ~TUSB_INT_SRC_RESERVED_MASK);
 
 #if 0
 	/* Set OTG timer for about one second */
 	musb_writel(base, TUSB_DEV_OTG_TIMER,
-		TUSB_DEV_OTG_TIMER_ENABLE |
-		TUSB_DEV_OTG_TIMER_VAL(0x3c00000));
+		    TUSB_DEV_OTG_TIMER_ENABLE |
+		    TUSB_DEV_OTG_TIMER_VAL(0x3c00000));
 #endif
 
 	/* Only 0 clock cycles for minimum interrupt de-assertion time and
 	 * interrupt polarity active low seems to work reliably here */
-	musb_writel(base, TUSB_INT_CTRL_CONF,
-		    TUSB_INT_CTRL_CONF_INT_RELCYC(0));
+	musb_writel(base, TUSB_INT_CTRL_CONF, TUSB_INT_CTRL_CONF_INT_RELCYC(0));
 
 	set_irq_type(musb->nIrq, __IRQT_LOWLVL);
 }
@@ -256,7 +249,7 @@ void tusb_enable(struct musb * musb)
  * - Really disable the interrupts we want to disable
  * - Deal with wake-up and gpio interrupts
  */
-static void tusb_disable(struct musb * musb)
+static void tusb_disable(struct musb *musb)
 {
 	set_irq_type(musb->nIrq, IRQT_NOEDGE);
 }
@@ -265,9 +258,9 @@ static void tusb_disable(struct musb * m
  * Sets up TUSB6010 CPU interface specific signals and registers
  * Note: Settings optimized for OMAP24xx
  */
-static void tusb_setup_cpu_interface(struct musb * musb)
+static void tusb_setup_cpu_interface(struct musb *musb)
 {
-	void __iomem * base = musb->ctrl_base;
+	void __iomem *base = musb->ctrl_base;
 
 	/* Disable GPIO[7:0] pullups (used as output DMA requests) */
 	musb_writel(base, TUSB_PULLUP_1_CTRL, 0x000000FF);
@@ -280,9 +273,9 @@ static void tusb_setup_cpu_interface(str
 	/* Burst size 16x16 bits, all six DMA requests enabled, DMA request
 	 * de-assertion time 2 system clocks */
 	musb_writel(base, TUSB_DMA_REQ_CONF,
-		TUSB_DMA_REQ_CONF_BURST_SIZE(2) |
-		TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x2f) |
-		TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));
+		    TUSB_DMA_REQ_CONF_BURST_SIZE(2) |
+		    TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x2f) |
+		    TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));
 
 	/* Set 0 wait count for synchronous burst access */
 	musb_writel(base, TUSB_WAIT_COUNT, 0);
@@ -291,9 +284,9 @@ static void tusb_setup_cpu_interface(str
 #define TUSB_REV_MAJOR(reg_val)		((reg_val >> 4) & 0xf)
 #define TUSB_REV_MINOR(reg_val)		(reg_val & 0xf)
 
-static void tusb_print_revision(struct musb * musb)
+static void tusb_print_revision(struct musb *musb)
 {
-	void __iomem * base = musb->ctrl_base;
+	void __iomem *base = musb->ctrl_base;
 
 	pr_info("tusb: Revisions: %s%i.%i %s%i.%i %s%i.%i %s%i.%i\n",
 		"prcm",
@@ -310,9 +303,9 @@ static void tusb_print_revision(struct m
 		TUSB_REV_MINOR(musb_readl(base, TUSB_DMA_CTRL_REV)));
 }
 
-static int tusb_start(struct musb * musb)
+static int tusb_start(struct musb *musb)
 {
-	void __iomem * base = musb->ctrl_base;
+	void __iomem *base = musb->ctrl_base;
 	int ret;
 	unsigned long flags;
 
@@ -324,8 +317,7 @@ static int tusb_start(struct musb * musb
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
-	if (musb_readl(base, TUSB_PROD_TEST_RESET) !=
-		TUSB_PROD_TEST_RESET_VAL) {
+	if (musb_readl(base, TUSB_PROD_TEST_RESET) != TUSB_PROD_TEST_RESET_VAL) {
 		printk(KERN_ERR "tusb: Unable to detect TUSB6010\n");
 		goto err;
 	}
@@ -343,29 +335,29 @@ static int tusb_start(struct musb * musb
 	 * power saving, enable VBus detect and session end comparators,
 	 * enable IDpullup */
 	musb_writel(base, TUSB_PRCM_MNGMT,
-		TUSB_PRCM_MNGMT_VBUS_VALID_TIMER(0xa) |
-		TUSB_PRCM_MNGMT_VBUS_VALID_FLT_EN |
-		TUSB_PRCM_MNGMT_DFT_CLK_DIS |
-		TUSB_PRCM_MNGMT_VLYNQ_CLK_DIS |
-		TUSB_PRCM_MNGMT_OTG_SESS_END_EN |
-		TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN |
-		TUSB_PRCM_MNGMT_OTG_ID_PULLUP);
+		    TUSB_PRCM_MNGMT_VBUS_VALID_TIMER(0xa) |
+		    TUSB_PRCM_MNGMT_VBUS_VALID_FLT_EN |
+		    TUSB_PRCM_MNGMT_DFT_CLK_DIS |
+		    TUSB_PRCM_MNGMT_VLYNQ_CLK_DIS |
+		    TUSB_PRCM_MNGMT_OTG_SESS_END_EN |
+		    TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN |
+		    TUSB_PRCM_MNGMT_OTG_ID_PULLUP);
 
 	/* Workaround for enabling IDpullup, VBus detect and session end
 	 * comparators in case of silicon bug (which is to be fixed) where they
 	 * cannot be enabled in Device PRCM Management Register */
 	musb_writel(base, TUSB_PHY_OTG_CTRL_ENABLE,
-		musb_readl(base, TUSB_PHY_OTG_CTRL_ENABLE) |
-		TUSB_PHY_OTG_CTRL_WRPROTECT |
-		TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP |
-		TUSB_PHY_OTG_CTRL_OTG_VBUS_DET_EN |
-		TUSB_PHY_OTG_CTRL_OTG_SESS_END_EN);
+		    musb_readl(base, TUSB_PHY_OTG_CTRL_ENABLE) |
+		    TUSB_PHY_OTG_CTRL_WRPROTECT |
+		    TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP |
+		    TUSB_PHY_OTG_CTRL_OTG_VBUS_DET_EN |
+		    TUSB_PHY_OTG_CTRL_OTG_SESS_END_EN);
 	musb_writel(base, TUSB_PHY_OTG_CTRL,
-		musb_readl(base, TUSB_PHY_OTG_CTRL) |
-		TUSB_PHY_OTG_CTRL_WRPROTECT |
-		TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP |
-		TUSB_PHY_OTG_CTRL_OTG_VBUS_DET_EN |
-		TUSB_PHY_OTG_CTRL_OTG_SESS_END_EN);
+		    musb_readl(base, TUSB_PHY_OTG_CTRL) |
+		    TUSB_PHY_OTG_CTRL_WRPROTECT |
+		    TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP |
+		    TUSB_PHY_OTG_CTRL_OTG_VBUS_DET_EN |
+		    TUSB_PHY_OTG_CTRL_OTG_SESS_END_EN);
 
 	tusb_setup_cpu_interface(musb);
 
@@ -373,12 +365,12 @@ static int tusb_start(struct musb * musb
 
 	return 0;
 
-err:
+      err:
 	tusb_power(0);
 	return -ENODEV;
 }
 
-void tusb_stop(struct musb * musb)
+void tusb_stop(struct musb *musb)
 {
 	tusb_power(0);
 }
@@ -391,11 +383,9 @@ void musb_platform_disable(struct musb *
 {
 }
 
-
 int __init musb_platform_init(struct musb *musb)
 {
-	int		ret;
-
+	int ret;
 
 	/* Offsets from base: VLYNQ at 0x000, MUSB regs at 0x400,
 	 * FIFOs at 0x600, TUSB at 0x800
@@ -404,11 +394,9 @@ int __init musb_platform_init(struct mus
 
 	ret = tusb_start(musb);
 	if (ret) {
-		printk(KERN_ERR "Could not start tusb6010 (%d)\n",
-				ret);
+		printk(KERN_ERR "Could not start tusb6010 (%d)\n", ret);
 		return -ENODEV;
 	}
 	musb->isr = tusb_interrupt;
 	return ret;
 }
-
Index: linux-2.6.10/drivers/usb/musb/tusb_6010.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/tusb_6010.h
+++ linux-2.6.10/drivers/usb/musb/tusb_6010.h
@@ -17,10 +17,10 @@
 #define musb_in_tusb()			1
 struct musb;
 extern int tusb_power(int state);
-extern int tusb_start(struct musb * musb);
-extern void tusb_stop(struct musb * musb);
-extern void tusb_enable(struct musb * musb);
-extern void tusb_disable(struct musb * musb);
+extern int tusb_start(struct musb *musb);
+extern void tusb_stop(struct musb *musb);
+extern void tusb_enable(struct musb *musb);
+extern void tusb_disable(struct musb *musb);
 extern irqreturn_t tusb_interrupt(int irq, void *ctx, struct pt_regs *r);
 
 #else
@@ -347,6 +347,6 @@ extern irqreturn_t tusb_interrupt(int ir
  */
 #define MUSB_C_RAM_BITS 10
 
-#endif /* CONFIG_USB_TUSB_6010 */
+#endif				/* CONFIG_USB_TUSB_6010 */
 
-#endif /* __TUSB_6010_H__ */
+#endif				/* __TUSB_6010_H__ */
Index: linux-2.6.10/drivers/usb/musb/virthub.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/virthub.c
+++ linux-2.6.10/drivers/usb/musb/virthub.c
@@ -110,7 +110,7 @@ static const u8 rh_config_desc[] = {
  * assumes pHub to be locked!
  */
 static void MGC_VirtualHubCheckIrq(struct virtual_root *pHub, struct urb *pUrb,
-				      int status)
+				   int status)
 {
 	int nLength, nPort;
 	u8 bData, bBit;
@@ -118,7 +118,7 @@ static void MGC_VirtualHubCheckIrq(struc
 
 	/* how many bits are needed/possible */
 	nLength = min(pUrb->transfer_buffer_length * 8, 1 +
-			min((u8)MGC_VIRTUALHUB_MAX_PORTS, pHub->bPortCount));
+		      min((u8) MGC_VIRTUALHUB_MAX_PORTS, pHub->bPortCount));
 	bData = 0;
 	bBit = 1;
 	pData = (u8 *) pUrb->transfer_buffer;
@@ -163,9 +163,9 @@ static void MGC_VirtualHubCheckIrq(struc
  */
 static void rh_timer(unsigned long ptr)
 {
-	struct virtual_root	*pHub = (struct virtual_root *) ptr;
-	struct urb		*pUrb;
-	unsigned long		flags;
+	struct virtual_root *pHub = (struct virtual_root *)ptr;
+	struct urb *pUrb;
+	unsigned long flags;
 
 	spin_lock_irqsave(&pHub->Lock, flags);
 	pUrb = pHub->pUrb;
@@ -184,10 +184,10 @@ static void rh_timer(unsigned long ptr)
 		 * pUrb->hcpriv is set to NULL on port disconnect
 		 */
 		mod_timer(&pHub->Timer, jiffies
-				+ msecs_to_jiffies(pHub->wInterval));
+			  + msecs_to_jiffies(pHub->wInterval));
 	} else {
 		DBG(3, "pUrb=%p, for me =%d\n", pUrb,
-			(pUrb) ? ((pUrb->hcpriv) ? 1 : 0) : -1);
+		    (pUrb) ? ((pUrb->hcpriv) ? 1 : 0) : -1);
 	}
 
 	spin_unlock_irqrestore(&pHub->Lock, flags);
@@ -244,7 +244,7 @@ static inline void set_active(struct mus
 
 static void musb_port_suspend(struct musb *pThis, u8 bSuspend)
 {
-	u8 power,devctl;
+	u8 power, devctl;
 	unsigned long flags;
 	void __iomem *pBase = pThis->pRegs;
 
@@ -255,34 +255,32 @@ static void musb_port_suspend(struct mus
 		goto done;
 
 	power = musb_readb(pBase, MGC_O_HDRC_POWER);
-	devctl= musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
 	if (bSuspend) {
 		DBG(3, "Root port suspended\n");
 		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_SUSPENDM);
-				
+			    power | MGC_M_POWER_SUSPENDM);
+
 #ifdef CONFIG_USB_MUSB_OTG
-		
-		otg_input_changed(pThis,devctl,FALSE,FALSE,TRUE);
+
+		otg_input_changed(pThis, devctl, FALSE, FALSE, TRUE);
 #endif
-		
+
 	} else if (power & MGC_M_POWER_SUSPENDM) {
 		DBG(3, "Root port resumed\n");
 		power &= ~(MGC_M_POWER_SUSPENDM | MGC_M_POWER_RESUME);
 		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_RESUME);
-				
-#ifdef CONFIG_USB_MUSB_OTG				
-		otg_input_changed(pThis,devctl,FALSE,FALSE,FALSE);
+			    power | MGC_M_POWER_RESUME);
+
+#ifdef CONFIG_USB_MUSB_OTG
+		otg_input_changed(pThis, devctl, FALSE, FALSE, FALSE);
 #endif
-		mod_timer(&pThis->Timer, jiffies +
-					msecs_to_jiffies(10));
+		mod_timer(&pThis->Timer, jiffies + msecs_to_jiffies(10));
 	}
-done:
+      done:
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 }
 
-
 static void musb_port_reset(struct musb *pThis, u8 bReset)
 {
 	u8 power;
@@ -293,7 +291,7 @@ static void musb_port_reset(struct musb 
 	/* REVISIT this looks wrong for HNP */
 	u8 devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
 	if (pThis->bDelayPortPowerOff || !(devctl & MGC_M_DEVCTL_HM)) {
-//		return;
+//              return;
 		DBG(1, "what?\n");
 	}
 #endif
@@ -308,13 +306,12 @@ static void musb_port_reset(struct musb 
 	power = musb_readb(pBase, MGC_O_HDRC_POWER);
 	if (bReset) {
 		pThis->bIgnoreDisconnect = TRUE;
-		power &= 0xf1; /* Have the ENSUSPEND bit set */
-		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_RESET);
+		power &= 0xf1;	/* Have the ENSUSPEND bit set */
+		musb_writeb(pBase, MGC_O_HDRC_POWER, power | MGC_M_POWER_RESET);
 	} else {
 		DBG(3, "root port reset stopped\n");
 		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power & ~MGC_M_POWER_RESET);
+			    power & ~MGC_M_POWER_RESET);
 
 		pThis->bIgnoreDisconnect = FALSE;
 
@@ -328,11 +325,10 @@ static void musb_port_reset(struct musb 
 		musb_port_reset_done(&(pThis->RootHub), pThis->bRootSpeed);
 	}
 
-done:
+      done:
 	spin_unlock_irqrestore(&pThis->Lock, flags);
 }
 
-
 int MGC_VirtualHubSubmitUrb(struct virtual_root *pHub, struct urb *pUrb)
 {
 	u8 bRecip;		/* from standard request */
@@ -346,7 +342,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 	u16 wSize = 0xffff;
 	u8 *pData = (u8 *) pUrb->transfer_buffer;
 	unsigned int pipe = pUrb->pipe;
-	unsigned long	flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&pHub->Lock, flags);
 	usb_get_urb(pUrb);
@@ -358,7 +354,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 
 		/* this is the one for periodic status/change events */
 		pHub->pUrb = pUrb;
-		pHub->wInterval = HZ/4;
+		pHub->wInterval = HZ / 4;
 		spin_unlock_irqrestore(&pHub->Lock, flags);
 		return 0;
 	}
@@ -377,15 +373,15 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 	wLength = le16_to_cpu(pRequest->wLength);
 
 	DBG(4, "ROOT SETUP req%02x.%02x v%04x i%04x l%d\n",
-		 pRequest->bRequestType, pRequest->bRequest,
-		 wValue, wIndex, wLength);
+	    pRequest->bRequestType, pRequest->bRequest,
+	    wValue, wIndex, wLength);
 
 	/* otg hosts mustn't change any root hub status until entering
 	 * OTG_STATE_A_IDLE or OTG_STATE_B_HOST.  strictly speaking we should
 	 * return errors for such requests, but let's avoid trouble...
 	 */
 	if (!is_host_active(pHub->musb)
-			&& !(pRequest->bRequestType & USB_DIR_IN)) {
+	    && !(pRequest->bRequestType & USB_DIR_IN)) {
 		wSize = 0;
 		goto fakeit;
 	}
@@ -393,7 +389,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 	switch (pRequest->bRequest) {
 	case USB_REQ_GET_STATUS:
 		DBG(5, "GET_STATUS(), bType=%02x, bRecip=%02x, wIndex=%04x\n",
-			bReqType, bRecip, wIndex);
+		    bReqType, bRecip, wIndex);
 
 		if (USB_TYPE_STANDARD == bReqType) {
 			/* self-powered */
@@ -402,8 +398,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 			wSize = 2;
 		} else if (USB_TYPE_CLASS == bReqType) {
 			if ((USB_RECIP_OTHER == bRecip)
-					&& wIndex
-					&& (wIndex <= pHub->bPortCount)) {
+			    && wIndex && (wIndex <= pHub->bPortCount)) {
 				MGC_HubPortStatusChange *p;
 
 				p = pHub->aPortStatusChange + (wIndex - 1);
@@ -421,8 +416,8 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 				/* REVISIT assumes 2-byte alignment */
 
 				/* port status/change report */
-				*(u16*)(pData + 0) = cpu_to_le16(p->wStatus);
-				*(u16*)(pData + 2) = cpu_to_le16(p->wChange);
+				*(u16 *) (pData + 0) = cpu_to_le16(p->wStatus);
+				*(u16 *) (pData + 2) = cpu_to_le16(p->wChange);
 
 				/* reset change (TODO: lock) */
 				pHub->aPortStatusChange[wIndex - 1].wChange = 0;
@@ -434,15 +429,15 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 			}
 
 			DBG(5, "status %04x change %04x\n",
-					pHub->aPortStatusChange[0].wStatus,
-					pHub->aPortStatusChange[0].wChange);
+			    pHub->aPortStatusChange[0].wStatus,
+			    pHub->aPortStatusChange[0].wChange);
 		}
 		break;
 
 	case USB_REQ_CLEAR_FEATURE:
 		bPort = (u8) (wIndex & 0xff) - 1;
 		if ((USB_TYPE_STANDARD == bReqType)
-			&& (USB_RECIP_ENDPOINT == bRecip)) {
+		    && (USB_RECIP_ENDPOINT == bRecip)) {
 			wSize = 0;
 			DBG(5, "clear END POINT feature!\n");
 		} else if (USB_TYPE_CLASS == bReqType) {
@@ -455,7 +450,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 				case USB_PORT_FEAT_POWER:
 				case USB_PORT_FEAT_INDICATOR:
 					DBG(5, "clear feat 0x%02x port %d\n",
-						wValue, bPort);
+					    wValue, bPort);
 					wSize = 0;
 					break;
 				case USB_PORT_FEAT_ENABLE:
@@ -476,48 +471,47 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 					/* acknowledge changes: */
 				case USB_PORT_FEAT_C_CONNECTION:
 					DBG(5, "ack connect chg port %d\n",
-						bPort);
+					    bPort);
 					pHub->aPortStatusChange[bPort].wChange
-						&= ~USB_PORT_STAT_C_CONNECTION;
+					    &= ~USB_PORT_STAT_C_CONNECTION;
 					wSize = 0;
 					break;
 				case USB_PORT_FEAT_C_ENABLE:
 					DBG(5, "ack enable chg %d\n", bPort);
 					pHub->aPortStatusChange[bPort].wChange
-						&= ~USB_PORT_STAT_C_ENABLE;
+					    &= ~USB_PORT_STAT_C_ENABLE;
 					wSize = 0;
 					break;
 				case USB_PORT_FEAT_C_SUSPEND:
 					DBG(5, "ack suspend chg %d\n", bPort);
 					pHub->aPortStatusChange[bPort].wChange
-						&= ~USB_PORT_STAT_C_SUSPEND;
+					    &= ~USB_PORT_STAT_C_SUSPEND;
 					wSize = 0;
 					break;
 				case USB_PORT_FEAT_C_RESET:
 					DBG(5, "ack reset chg %d\n", bPort);
 					pHub->aPortStatusChange[bPort].wChange
-						&= ~USB_PORT_STAT_C_RESET;
+					    &= ~USB_PORT_STAT_C_RESET;
 					wSize = 0;
 					break;
 				case USB_PORT_FEAT_C_OVER_CURRENT:
 					DBG(5, "ack overcurrent chg port %d\n",
-						bPort);
+					    bPort);
 					/*
-					pHub->aPortStatusChange[bPort].wChange
-						&= ~USB_PORT_STAT_C_OVERCURRENT;
-					*/
+					   pHub->aPortStatusChange[bPort].wChange
+					   &= ~USB_PORT_STAT_C_OVERCURRENT;
+					 */
 					wSize = 0;
 					break;
 
 				default:
 					DBG(1, "clear feature 0x%02x on "
-							"port=%d unknown\n",
-							wValue, bPort);
+					    "port=%d unknown\n", wValue, bPort);
 					break;
 				}
 			} else {
 				DBG(5, "clear wValue=%d on port=%d\n", wValue,
-					bPort);
+				    bPort);
 				switch (wValue) {
 				case C_HUB_LOCAL_POWER:
 				case C_HUB_OVER_CURRENT:
@@ -527,33 +521,33 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 			}
 		} else {
 			DBG(1, "CLR_FEAT type=0x%x, wValue=0x%x, wIndex=0x%x\n",
-				bReqType, wValue, (wIndex & 0xff));
+			    bReqType, wValue, (wIndex & 0xff));
 		}
 		break;
 
 	case USB_REQ_SET_FEATURE:
 		if ((USB_TYPE_CLASS == bReqType)
-				&& (USB_RECIP_OTHER == bRecip)) {
+		    && (USB_RECIP_OTHER == bRecip)) {
 			bPort = (u8) (wIndex & 0xff) - 1;
 			DBG(5, "SET_PORT_FEATURE(0x%02x), port %d\n", wValue,
-				bPort);
+			    bPort);
 			switch (wValue) {
 			case USB_PORT_FEAT_SUSPEND:
 				DBG(5, "suspend port %d\n", bPort);
 				musb_port_suspend(pHub->musb, TRUE);
 				pHub->aPortStatusChange[bPort].wStatus |=
-					USB_PORT_STAT_SUSPEND;
+				    USB_PORT_STAT_SUSPEND;
 				wSize = 0;
 				break;
 
 			case USB_PORT_FEAT_RESET:
 				DBG(5, "reset port %d\n", bPort);
 				pHub->aPortStatusChange[bPort].wStatus |=
-					USB_PORT_STAT_RESET;
+				    USB_PORT_STAT_RESET;
 				pHub->aPortStatusChange[bPort].wStatus |=
-					USB_PORT_STAT_ENABLE;
+				    USB_PORT_STAT_ENABLE;
 				pHub->aPortStatusChange[bPort].wChange |=
-					USB_PORT_STAT_C_RESET;
+				    USB_PORT_STAT_C_RESET;
 				musb_port_reset(pHub->musb, TRUE);
 				wSize = 0;
 				break;
@@ -566,20 +560,20 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 				 */
 				set_active(pHub->musb);
 				pHub->aPortStatusChange[bPort].wStatus |=
-					USB_PORT_STAT_POWER;
+				    USB_PORT_STAT_POWER;
 				wSize = 0;
 				break;
 
 			case USB_PORT_FEAT_ENABLE:
 				DBG(5, "enable port %d\n", bPort);
 				pHub->aPortStatusChange[bPort].wStatus |=
-					USB_PORT_STAT_ENABLE;
+				    USB_PORT_STAT_ENABLE;
 				wSize = 0;
 				break;
 			}
 		} else {
 			DBG(1, "SET_FEATURE(%04x), but feature unknown\n",
-				wValue);
+			    wValue);
 		}
 		break;
 
@@ -640,7 +634,7 @@ int MGC_VirtualHubSubmitUrb(struct virtu
 
 	}			/* END: switch on request type */
 
-fakeit:
+      fakeit:
 	if (0xffff == wSize) {
 		pUrb->status = -EPIPE;
 	} else {
@@ -651,8 +645,7 @@ fakeit:
 	spin_unlock_irqrestore(&pHub->Lock, flags);
 
 	DBG((pUrb->status < 0) ? 3 : 4,
-			"URB status %d, len %d\n",
-			pUrb->status, pUrb->actual_length);
+	    "URB status %d, len %d\n", pUrb->status, pUrb->actual_length);
 	pUrb->hcpriv = NULL;
 	pUrb->complete(pUrb, NULL);
 	usb_put_urb(pUrb);
@@ -663,7 +656,7 @@ fakeit:
 /* Implementation */
 int MGC_VirtualHubUnlinkUrb(struct virtual_root *pHub, struct urb *pUrb)
 {
-	//unsigned long	flags;
+	//unsigned long flags;
 
 	/* Description: Commented lock / unlock calls
 	 *
@@ -682,7 +675,6 @@ int MGC_VirtualHubUnlinkUrb(struct virtu
 		pUrb->complete(pUrb, NULL);
 		usb_put_urb(pUrb);
 	}
-
 	//spin_unlock_irqrestore(&pHub->Lock, flags);
 	return 0;
 }
@@ -705,25 +697,23 @@ static inline void musb_port_speed(struc
 	}
 
 	pHub->aPortStatusChange[0].wStatus &=
-		~(USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
+	    ~(USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
 	pHub->aPortStatusChange[0].wStatus |= wSpeedMask;
 }
 
 static void musb_port_reset_done(struct virtual_root *pHub, u8 bHubSpeed)
 {
-	//unsigned long	flags;
+	//unsigned long flags;
 
 	//spin_lock_irqsave(&pHub->Lock, flags);
 
 	DBG(4, "port %d reset complete\n", 0);
 	musb_port_speed(pHub, bHubSpeed);
 
-	pHub->aPortStatusChange[0].wStatus &=
-		~USB_PORT_STAT_RESET;
-	pHub->aPortStatusChange[0].wStatus |=
-		USB_PORT_STAT_ENABLE;
+	pHub->aPortStatusChange[0].wStatus &= ~USB_PORT_STAT_RESET;
+	pHub->aPortStatusChange[0].wStatus |= USB_PORT_STAT_ENABLE;
 	pHub->aPortStatusChange[0].wChange =
-		USB_PORT_STAT_C_RESET | USB_PORT_STAT_C_ENABLE;
+	    USB_PORT_STAT_C_RESET | USB_PORT_STAT_C_ENABLE;
 
 	//spin_unlock_irqrestore(&pHub->Lock, flags);
 }
@@ -741,19 +731,19 @@ void MGC_VirtualHubPortConnected(struct 
 	struct urb *pUrb;
 
 	DBG(2, "<== port %d connected, core reports speed=%d\n", bPortIndex,
-		bSpeed);
+	    bSpeed);
 
 	if (bPortIndex < MGC_VIRTUALHUB_MAX_PORTS) {
-		unsigned long	flags;
+		unsigned long flags;
 
 		spin_lock_irqsave(&pHub->Lock, flags);
 
 		pUrb = pHub->pUrb;
 		musb_port_speed(pHub, bSpeed);
 		pHub->aPortStatusChange[bPortIndex].wStatus |=
-			USB_PORT_STAT_CONNECTION;
+		    USB_PORT_STAT_CONNECTION;
 		pHub->aPortStatusChange[bPortIndex].wChange |=
-			USB_PORT_STAT_C_CONNECTION;
+		    USB_PORT_STAT_C_CONNECTION;
 
 		if (pUrb && ((!pUrb->hcpriv) || (pUrb->hcpriv == pHub))) {
 			pUrb->hcpriv = pHub;
@@ -767,18 +757,16 @@ void MGC_VirtualHubPortConnected(struct 
 /* caller irqlocked musb */
 void musb_root_disconnect(struct musb *musb)
 {
-	unsigned long	flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&musb->RootHub.Lock, flags);
 	musb->RootHub.aPortStatusChange[0].wStatus &=
-		~(USB_PORT_STAT_CONNECTION
-		| USB_PORT_STAT_ENABLE
-		| USB_PORT_STAT_LOW_SPEED
-		| USB_PORT_STAT_HIGH_SPEED
-		| USB_PORT_STAT_TEST
-		 );
+	    ~(USB_PORT_STAT_CONNECTION
+	      | USB_PORT_STAT_ENABLE
+	      | USB_PORT_STAT_LOW_SPEED
+	      | USB_PORT_STAT_HIGH_SPEED | USB_PORT_STAT_TEST);
 	musb->RootHub.aPortStatusChange[0].wChange |=
-		USB_PORT_STAT_C_CONNECTION;
+	    USB_PORT_STAT_C_CONNECTION;
 	mod_timer(&musb->RootHub.Timer, jiffies);
 	spin_unlock_irqrestore(&musb->RootHub.Lock, flags);
 
@@ -798,29 +786,25 @@ void musb_root_disconnect(struct musb *m
 #endif
 	//====================================================
 	if (musb->pRootDevice)
-		usb_set_device_state(musb->pRootDevice,
-				USB_STATE_NOTATTACHED);
+		usb_set_device_state(musb->pRootDevice, USB_STATE_NOTATTACHED);
 	else
 		DBG(1, "disconnect with NO DEVICE CONNECTED?\n");
 	usb_put_dev(musb->pRootDevice);
 	musb->pRootDevice = NULL;
 }
 
-
 /* caller irqlocked musb */
 void MGC_VirtualHubPortResumed(struct virtual_root *pHub, u8 bPortIndex)
 {
-	unsigned long	flags;
+	unsigned long flags;
 
 	DBG(3, "Resume port %d\n", bPortIndex);
 	if (bPortIndex >= MGC_VIRTUALHUB_MAX_PORTS) {
 		return;
 	}
 	spin_lock_irqsave(&pHub->Lock, flags);
-	pHub->aPortStatusChange[bPortIndex].wStatus &=
-		~USB_PORT_STAT_SUSPEND;
-	pHub->aPortStatusChange[bPortIndex].wChange |=
-		USB_PORT_STAT_C_SUSPEND;
+	pHub->aPortStatusChange[bPortIndex].wStatus &= ~USB_PORT_STAT_SUSPEND;
+	pHub->aPortStatusChange[bPortIndex].wChange |= USB_PORT_STAT_C_SUSPEND;
 	spin_unlock_irqrestore(&pHub->Lock, flags);
 	return;
 }
Index: linux-2.6.10/drivers/usb/musb/virthub.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/virthub.h
+++ linux-2.6.10/drivers/usb/musb/virthub.h
@@ -40,11 +40,9 @@
 struct urb;
 struct usb_bus;
 
-
 /** Maximum number of ports to accomodate */
 #define MGC_VIRTUALHUB_MAX_PORTS	1
 
-
 /**
  * MGC_HubPortStatusChange.
  * @field wStatus status
@@ -60,14 +58,13 @@ struct virtual_root {
 	struct usb_bus *pBus;
 	struct usb_device *pDevice;
 	void *pUrb;
-	struct musb	*musb;
+	struct musb *musb;
 	struct timer_list Timer;
 	MGC_HubPortStatusChange aPortStatusChange[MGC_VIRTUALHUB_MAX_PORTS];
 	u8 bPortCount;
 	u16 wInterval;
 };
 
-
 /****************************** FUNCTIONS ********************************/
 
 /**
@@ -77,14 +74,13 @@ struct virtual_root {
  * @return TRUE on success
  * @return FALSE on failure
  */
-extern u8 MGC_VirtualHubInit(struct virtual_root * pHub,
-			     struct usb_bus *pBus,
-			     struct musb *musb);
+extern u8 MGC_VirtualHubInit(struct virtual_root *pHub,
+			     struct usb_bus *pBus, struct musb *musb);
 
 /**
  * Stop a virtual hub
  */
-extern void MGC_VirtualHubStop(struct virtual_root * pHub);
+extern void MGC_VirtualHubStop(struct virtual_root *pHub);
 
 /**
  * Submit an URB to a virtual hub.
@@ -93,7 +89,7 @@ extern void MGC_VirtualHubStop(struct vi
  * @return Linux status code
  * @see #MGC_VirtualHubInit
  */
-extern int MGC_VirtualHubSubmitUrb(struct virtual_root * pHub, struct urb *pUrb);
+extern int MGC_VirtualHubSubmitUrb(struct virtual_root *pHub, struct urb *pUrb);
 
 /**
  * Unlink an URB from a virtual hub.
@@ -102,7 +98,7 @@ extern int MGC_VirtualHubSubmitUrb(struc
  * @return Linux status code
  * @see #MGC_VirtualHubInit
  */
-extern int MGC_VirtualHubUnlinkUrb(struct virtual_root * pHub, struct urb *pUrb);
+extern int MGC_VirtualHubUnlinkUrb(struct virtual_root *pHub, struct urb *pUrb);
 
 /**
  * A device has effectively been connected to a virtual hub port
@@ -111,7 +107,7 @@ extern int MGC_VirtualHubUnlinkUrb(struc
  * @param bSpeed device speed (0=>low, 1=>full, 2=>high)
  * @see #MGC_VirtualHubInit
  */
-extern void MGC_VirtualHubPortConnected(struct virtual_root * pHub,
+extern void MGC_VirtualHubPortConnected(struct virtual_root *pHub,
 					u8 bPortIndex, u8 bSpeed);
 
 /**
@@ -120,7 +116,6 @@ extern void MGC_VirtualHubPortConnected(
  * @param bPortIndex 0-based index of port of resume
  * @see #MGC_VirtualHubInit
  */
-extern void MGC_VirtualHubPortResumed(struct virtual_root * pHub, u8 bPortIndex);
-
+extern void MGC_VirtualHubPortResumed(struct virtual_root *pHub, u8 bPortIndex);
 
 #endif				/* multiple inclusion protection */
Index: linux-2.6.10/include/asm-arm/arch-davinci/hdrc_cnf.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/hdrc_cnf.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/hdrc_cnf.h
@@ -151,7 +151,7 @@
  * Legal values are 2 - 16
  * This must be equal to the larger of C_NUM_EPT, C_NUM_EPR
  */
-#define MUSB_C_NUM_EPS 5
+#define MUSB_C_NUM_EPS 9
 
 /* C_EPMAX_BITS is equal to the largest endpoint FIFO word address bits */
 #define MUSB_C_EPMAX_BITS 11
Index: linux-2.6.10/mvl_patches/pro-1655.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1655.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1655);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

