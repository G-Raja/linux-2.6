#! /usr/bin/env bash
# Patch: -pro_ppc_xilinx_gpio_dual_channel
# Date: Thu Jun 22 21:14:23 2006
# Source: MontaVista Software, Inc. Sergey Podstavin <spodstavin@ru.mvista.com>
# MR: 18391 
# Type: Defect Fix
# Disposition: needs submitting to community
# Signed-off-by: Sergey podstavin <spodstavin@ru.mvista.com>
# Description:
# The current driver uses v1.00a level 1 EDK driver which is to be obsoleted soon.
# Xilinx requested to move to the most recent v2.01a level 1 driver and to add
# support for dual GPIOs (the dual ones are used in ML403 referense design).
# 	Andrey Konovalov has done this work.
# 

PATCHNUM=644
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. Sergey Podstavin <spodstavin@ru.mvista.com>
MR: 18391 
Type: Defect Fix
Disposition: needs submitting to community
Signed-off-by: Sergey podstavin <spodstavin@ru.mvista.com>
Description:
The current driver uses v1.00a level 1 EDK driver which is to be obsoleted soon.
Xilinx requested to move to the most recent v2.01a level 1 driver and to add
support for dual GPIOs (the dual ones are used in ML403 referense design).
	Andrey Konovalov has done this work.

Index: linux-2.6.10/drivers/char/xilinx_gpio/adapter.c
===================================================================
--- linux-2.6.10.orig/drivers/char/xilinx_gpio/adapter.c
+++ linux-2.6.10/drivers/char/xilinx_gpio/adapter.c
@@ -6,7 +6,7 @@
  * Author: MontaVista Software, Inc.
  *         source@mvista.com
  *
- * 2002-2005 (c)MontaVista Software, Inc. This file is licensed under
+ * 2002-2006 (c)MontaVista Software, Inc. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -42,6 +42,7 @@
 struct xgpio_instance {
 	struct list_head link;
 	unsigned long base_phys;	/* GPIO base address - physical */
+	unsigned long remap_size;
 	u32 device_id;
 	/*
 	 * The underlying OS independent code needs space as well.  A
@@ -67,11 +68,12 @@ struct xgpio_instance {
 * None
 *
 *****************************************************************************/
-u32 XGpio_GetDataDirection(XGpio * InstancePtr)
+u32 XGpio_GetDataDirection(XGpio * InstancePtr, unsigned Channel)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	return XGpio_mReadReg(InstancePtr->BaseAddress, XGPIO_TRI_OFFSET);
+	return XGpio_mReadReg(InstancePtr->BaseAddress,
+			(Channel - 1) * XGPIO_CHAN_OFFSET + XGPIO_TRI_OFFSET);
 }
 
 inline int XGpio_IsReady(XGpio * InstancePtr)
@@ -82,37 +84,6 @@ inline int XGpio_IsReady(XGpio * Instanc
 static LIST_HEAD(inst_list);
 static DECLARE_RWSEM(inst_list_sem);
 
-/*******************************************************************************
- * This configuration stuff should become unnecessary after EDK version 8.x is
- * released.
- ******************************************************************************/
-
-static DECLARE_MUTEX(cfg_sem);
-static XGpio_Config * p_xgpio_cfg;
-
-/*
- * Lookup the device configuration based on the unique device ID.
- * Prototyped in xgpio.h.
- * We rely on that p_xgpio_cfg is set properly right before XGpio_Initialize()
- * calls XGpio_LookupConfig().
- */
-XGpio_Config * XGpio_LookupConfig(u16 DeviceId)
-{
-	return p_xgpio_cfg;
-}
-
-static XStatus XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * CfgPtr)
-{
-	XStatus retval;
-
-	down(&cfg_sem);
-	p_xgpio_cfg = CfgPtr;
-	retval = XGpio_Initialize(InstancePtr, 0);
-	up(&cfg_sem);
-
-	return retval;
-}
-
 /*******************
  * The misc device *
  *******************/
@@ -127,25 +98,37 @@ static int xgpio_release(struct inode *i
 	return 0;
 }
 
+/*
+ * To access the 1st channel of GPIO with id = N set ioctl_data->device to 2*N.
+ * ioctl_data->device of 2*N+1 accesses the 2nd channel (for DUAL GPIO IPs).
+ * ioctl_setup returns the channel number to work with (0 or 1) or error code
+ * (negative).
+ */
 static int ioctl_setup(unsigned long arg,
 		       struct xgpio_ioctl_data *ioctl_data,
 		       struct xgpio_instance **match)
 {
 	struct list_head *entry;
 	struct xgpio_instance *inst;
+	int dev_id, chan;
 
 	if (copy_from_user(ioctl_data, (void *) arg, sizeof (*ioctl_data)))
 		return -EFAULT;
 
+	dev_id = ioctl_data->device / 2;
+	chan = ioctl_data->device % 2;
+
 	down_read(&inst_list_sem);
 
 	list_for_each(entry, &inst_list) {
 		inst = list_entry(entry, struct xgpio_instance, link);
-		if (ioctl_data->device == inst->device_id) {
+		if (dev_id == inst->device_id) {
 			up_read(&inst_list_sem);
-			if (XGpio_IsReady(&inst->gpio)) {
+			if (!inst->gpio.IsDual && chan) {
+				return -ENODEV;
+			} else if (XGpio_IsReady(&inst->gpio)) {
 				*match = inst;
-				return 0;
+				return chan;
 			} else {
 				return -EAGAIN;
 			}
@@ -176,10 +159,10 @@ static int xgpio_ioctl(struct inode *ino
 		 * Tristate (direction) Register to make the corresponding
 		 * GPIOs to be inputs.
 		 */
-		r = XGpio_GetDataDirection(&inst->gpio);
-		XGpio_SetDataDirection(&inst->gpio, r | ioctl_data.mask);
+		r = XGpio_GetDataDirection(&inst->gpio, status);
+		XGpio_SetDataDirection(&inst->gpio, status, r | ioctl_data.mask);
 
-		ioctl_data.data = (XGpio_DiscreteRead(&inst->gpio)
+		ioctl_data.data = (XGpio_DiscreteRead(&inst->gpio, status)
 				   & ioctl_data.mask);
 		if (copy_to_user((struct xgpio_ioctl_data *) arg,
 				 &ioctl_data, sizeof (ioctl_data))) {
@@ -193,13 +176,13 @@ static int xgpio_ioctl(struct inode *ino
 			return status;
 
 		/* Get the prior value. */
-		r = XGpio_DiscreteRead(&inst->gpio);
+		r = XGpio_DiscreteRead(&inst->gpio, status);
 		/* Clear the bits that we're going to put in. */
 		r &= ~ioctl_data.mask;
 		/* Set the bits that were provided. */
 		r |= (ioctl_data.mask & ioctl_data.data);
 
-		XGpio_DiscreteWrite(&inst->gpio, r);
+		XGpio_DiscreteWrite(&inst->gpio, status, r);
 
 		/*
 		 * Ensure that the GPIO bits in the mask are not tristated.
@@ -207,8 +190,9 @@ static int xgpio_ioctl(struct inode *ino
 		 * Tristate (direction) Register to make the corresponding
 		 * GPIOs to be outputs.
 		 */
-		r = XGpio_GetDataDirection(&inst->gpio);
-		XGpio_SetDataDirection(&inst->gpio, r & ~ioctl_data.mask);
+		r = XGpio_GetDataDirection(&inst->gpio, status);
+		XGpio_SetDataDirection(&inst->gpio, status,
+				       r & ~ioctl_data.mask);
 
 		break;
 
@@ -218,7 +202,7 @@ static int xgpio_ioctl(struct inode *ino
 			return status;
 
 		/* Get the prior value. */
-		r = XGpio_GetDataDirection(&inst->gpio);
+		r = XGpio_GetDataDirection(&inst->gpio, status);
 		/* Clear the bits that we're going to put in. */
 		r &= ~ioctl_data.mask;
 		/*
@@ -230,7 +214,7 @@ static int xgpio_ioctl(struct inode *ino
 		 */
 		r |= (ioctl_data.mask & ~ioctl_data.data);
 
-		XGpio_SetDataDirection(&inst->gpio, r);
+		XGpio_SetDataDirection(&inst->gpio, status, r);
 		break;
 
 	case XGPIO_OPEN_DRAIN:
@@ -275,11 +259,13 @@ static int xgpio_probe(struct device *de
 	struct xgpio_instance *xgpio_inst;
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *regs_res;
+	void *v_addr;
 	int retval;
 
 	if (!dev)
 		return -EINVAL;
 
+	memset(&xgpio_config, 0, sizeof(XGpio_Config));
 	xgpio_inst = kzalloc(sizeof(struct xgpio_instance), GFP_KERNEL);
 	if (!xgpio_inst) {
 		printk(KERN_ERR
@@ -297,20 +283,32 @@ static int xgpio_probe(struct device *de
 		goto failed1;
 	}
 
-	if (!request_mem_region(regs_res->start, 8, DRIVER_NAME)) {
+	xgpio_inst->remap_size = regs_res->end - regs_res->start + 1;
+	if (!request_mem_region(regs_res->start, xgpio_inst->remap_size,
+				DRIVER_NAME)) {
 		printk(KERN_ERR "Couldn't lock memory region at 0x%08lX\n",
 			regs_res->start);
 		retval = -EBUSY;
 		goto failed2;
 	}
+	
+	v_addr = ioremap(regs_res->start, xgpio_inst->remap_size);
+	if (!v_addr) {
+		printk(KERN_ERR "Couldn't ioremap memory at 0x%08lX\n",
+		       regs_res->start);
+		retval = -EFAULT;
+		goto failed3;
+	}
 
 	xgpio_inst->base_phys = regs_res->start;
+	/* The 1st GPIO channel uses */
 	xgpio_inst->device_id = pdev->id;
 	xgpio_config.DeviceId = pdev->id;
-	xgpio_config.BaseAddress = (u32) ioremap(regs_res->start, 8);
+	xgpio_config.IsDual = ((unsigned)(dev->platform_data) & XGPIO_IS_DUAL) ? 1 : 0;
 
 	/* Tell the Xilinx code to bring this GPIO interface up. */
-	if (XGpio_CfgInitialize(&xgpio_inst->gpio, &xgpio_config) != XST_SUCCESS) {
+	if (XGpio_CfgInitialize(&xgpio_inst->gpio, &xgpio_config,
+			        (u32) v_addr) != XST_SUCCESS) {
 		printk(KERN_ERR "%s #%d: Could not initialize instance.\n",
 		       miscdev.name, pdev->id);
 		retval = -ENODEV;
@@ -341,7 +339,7 @@ failed3:
 	iounmap((void *) (xgpio_config.BaseAddress));
 
 failed2:
-	release_mem_region(regs_res->start, 8);
+	release_mem_region(regs_res->start, xgpio_inst->remap_size);
 
 failed1:
 	kfree(xgpio_inst);
@@ -384,7 +382,7 @@ static int xgpio_remove(struct device *d
 
 	iounmap((void *) (xgpio_inst->gpio.BaseAddress));
 
-	release_mem_region(xgpio_inst->base_phys, 8);
+	release_mem_region(xgpio_inst->base_phys, xgpio_inst->remap_size);
 
 	kfree(xgpio_inst);
 
Index: linux-2.6.10/arch/ppc/platforms/4xx/virtex.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/4xx/virtex.c
+++ linux-2.6.10/arch/ppc/platforms/4xx/virtex.c
@@ -298,7 +298,8 @@ static struct platform_device xilinx_iic
 
 static struct platform_device xilinx_gpio_0_device = {
 	.name = "xilinx_gpio",
-	.id = 0,
+	.id = XPAR_GPIO_0_DEVICE_ID,
+	.dev.platform_data = (XPAR_GPIO_0_IS_DUAL ? XGPIO_IS_DUAL : 0),
 	.num_resources = 1,
 	.resource = (struct resource[]) {
 		{
@@ -315,7 +316,8 @@ static struct platform_device xilinx_gpi
 
 static struct platform_device xilinx_gpio_1_device = {
 	.name = "xilinx_gpio",
-	.id = 1,
+	.id = XPAR_GPIO_1_DEVICE_ID,
+	.dev.platform_data = (XPAR_GPIO_1_IS_DUAL ? XGPIO_IS_DUAL : 0),
 	.num_resources = 1,
 	.resource = (struct resource[]) {
 		{
@@ -332,7 +334,8 @@ static struct platform_device xilinx_gpi
 
 static struct platform_device xilinx_gpio_2_device = {
 	.name = "xilinx_gpio",
-	.id = 2,
+	.id = XPAR_GPIO_2_DEVICE_ID,
+	.dev.platform_data = (XPAR_GPIO_2_IS_DUAL ? XGPIO_IS_DUAL : 0),
 	.num_resources = 1,
 	.resource = (struct resource[]) {
 		{
@@ -349,7 +352,8 @@ static struct platform_device xilinx_gpi
 
 static struct platform_device xilinx_gpio_3_device = {
 	.name = "xilinx_gpio",
-	.id = 3,
+	.id = XPAR_GPIO_3_DEVICE_ID,
+	.dev.platform_data = (XPAR_GPIO_3_IS_DUAL ? XGPIO_IS_DUAL : 0),
 	.num_resources = 1,
 	.resource = (struct resource[]) {
 		{
@@ -362,23 +366,6 @@ static struct platform_device xilinx_gpi
 
 #endif /* XPAR_GPIO_3_BASEADDR */
 
-#ifdef XPAR_GPIO_4_BASEADDR
-
-static struct platform_device xilinx_gpio_4_device = {
-	.name = "xilinx_gpio",
-	.id = 4,
-	.num_resources = 1,
-	.resource = (struct resource[]) {
-		{
-			.start	= XPAR_GPIO_4_BASEADDR,
-			.end	= XPAR_GPIO_4_HIGHADDR,
-			.flags	= IORESOURCE_MEM
-		}
-	}
-};
-
-#endif /* XPAR_GPIO_4_BASEADDR */
-
 #ifdef XPAR_OPB_LCD_INTERFACE_0_BASEADDR
 
 static struct platform_device xilinx_char_lcd_device = {
Index: linux-2.6.10/drivers/char/xilinx_gpio/xgpio.c
===================================================================
--- linux-2.6.10.orig/drivers/char/xilinx_gpio/xgpio.c
+++ linux-2.6.10/drivers/char/xilinx_gpio/xgpio.c
@@ -27,7 +27,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002 Xilinx Inc.
+*     (c) Copyright 2002 - 2005 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -46,9 +46,27 @@
 *
 * None
 *
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a rmm  02/04/02 First release
+* 2.00a jhl  12/16/02 Update for dual channel and interrupt support
+* 2.01a jvb  12/13/05 I changed Initialize() into CfgInitialize(), and made
+*                     CfgInitialize() take a pointer to a config structure
+*                     instead of a device id. I moved Initialize() into
+*                     xgpio_sinit.c, and had Initialize() call CfgInitialize()
+*                     after it retrieved the config structure using the device
+*                     id. I removed include of xparameters.h along with any
+*                     dependencies on xparameters.h and the _g.c config table.
+*
+* </pre>
+*
 *****************************************************************************/
 
 /***************************** Include Files ********************************/
+
 #include "xgpio.h"
 #include "xstatus.h"
 
@@ -65,7 +83,7 @@
 /****************************************************************************/
 /**
 * Initialize the XGpio instance provided by the caller based on the
-* given DeviceID.
+* given configuration data.
 *
 * Nothing is done except to initialize the InstancePtr.
 *
@@ -74,45 +92,43 @@
 *        manipulate the component through the XGpio API must be made with this
 *        pointer.
 *
-* @param DeviceId is the unique id of the device controlled by this XGpio
-*        component.  Passing in a device id associates the generic XGpio
-*        instance to a specific device, as chosen by the caller or application
-*        developer.
+* @param Config is a reference to a structure containing information about
+*        a specific GPIO device. This function initializes an InstancePtr object
+*        for a specific device specified by the contents of Config. This
+*        function can initialize multiple instance objects with the use of
+*        multiple calls giving different Config information on each call.
+*
+* @param EffectiveAddr is the device base address in the virtual memory address
+*        space. The caller is responsible for keeping the address mapping
+*        from EffectiveAddr to the device physical base address unchanged
+*        once this function is invoked. Unexpected errors may occur if the
+*        address mapping changes after this function is called. If address
+*        translation is not used, use Config->BaseAddress for this parameters,
+*        passing the physical address instead.
 *
 * @return
 *
 * - XST_SUCCESS           Initialization was successfull.
-* - XST_DEVICE_NOT_FOUND  Device configuration data was not found for a device
-*                         with the supplied device ID.
 *
-* NOTES:
+* @note
 *
-* None
+* None.
 *
 *****************************************************************************/
-XStatus XGpio_Initialize(XGpio * InstancePtr, u16 DeviceId)
+XStatus XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * Config,
+			    u32 EffectiveAddr)
 {
-	XGpio_Config *ConfigPtr;
-
 	/*
 	 * Assert arguments
 	 */
 	XASSERT_NONVOID(InstancePtr != NULL);
 
 	/*
-	 * Lookup configuration data in the device configuration table.
-	 * Use this configuration info down below when initializing this component.
-	 */
-	ConfigPtr = XGpio_LookupConfig(DeviceId);
-	if (ConfigPtr == (XGpio_Config *) NULL) {
-		InstancePtr->IsReady = 0;
-		return (XST_DEVICE_NOT_FOUND);
-	}
-
-	/*
 	 * Set some default values.
 	 */
-	InstancePtr->BaseAddress = ConfigPtr->BaseAddress;
+	InstancePtr->BaseAddress = EffectiveAddr;
+	InstancePtr->InterruptPresent = Config->InterruptPresent;
+	InstancePtr->IsDual = Config->IsDual;
 
 	/*
 	 * Indicate the instance is now ready to use, initialized without error
@@ -123,60 +139,91 @@ XStatus XGpio_Initialize(XGpio * Instanc
 
 /****************************************************************************/
 /**
-* Set the input/output direction of all discrete signals.
+* Set the input/output direction of all discrete signals for the specified
+* GPIO channel.
 *
 * @param InstancePtr is a pointer to an XGpio instance to be worked on.
+* @param Channel contains the channel of the GPIO (1 or 2) to operate on.
 * @param DirectionMask is a bitmask specifying which discretes are input and
 *        which are output. Bits set to 0 are output and bits set to 1 are input.
 *
+* @return
+*
+* None.
+*
 * @note
 *
-* None
+* The hardware must be built for dual channels if this function is used
+* with any channel other than 1.  If it is not, this function will assert.
 *
 *****************************************************************************/
-void XGpio_SetDataDirection(XGpio * InstancePtr, u32 DirectionMask)
+void XGpio_SetDataDirection(XGpio * InstancePtr, unsigned Channel,
+			    u32 DirectionMask)
 {
 	XASSERT_VOID(InstancePtr != NULL);
 	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XGpio_mWriteReg(InstancePtr->BaseAddress, XGPIO_TRI_OFFSET,
+	XASSERT_VOID((Channel == 1) ||
+		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));
+
+	XGpio_mWriteReg(InstancePtr->BaseAddress,
+			((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_TRI_OFFSET,
 			DirectionMask);
 }
 
 /****************************************************************************/
 /**
-* Read state of discretes.
+* Read state of discretes for the specified GPIO channnel.
 *
 * @param InstancePtr is a pointer to an XGpio instance to be worked on.
+* @param Channel contains the channel of the GPIO (1 or 2) to operate on.
 *
 * @return Current copy of the discretes register.
 *
 * @note
 *
-* None
+* The hardware must be built for dual channels if this function is used
+* with any channel other than 1.  If it is not, this function will assert.
 *
 *****************************************************************************/
-u32 XGpio_DiscreteRead(XGpio * InstancePtr)
+u32 XGpio_DiscreteRead(XGpio * InstancePtr, unsigned Channel)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	return (XGpio_mReadReg(InstancePtr->BaseAddress, XGPIO_DATA_OFFSET));
+	XASSERT_NONVOID((Channel == 1) ||
+			((Channel == 2) && (InstancePtr->IsDual == TRUE)));
+
+	return XGpio_mReadReg(InstancePtr->BaseAddress,
+			      ((Channel - 1) * XGPIO_CHAN_OFFSET) +
+			      XGPIO_DATA_OFFSET);
 }
 
 /****************************************************************************/
 /**
-* Write to discretes register
+* Write to discretes register for the specified GPIO channel.
 *
 * @param InstancePtr is a pointer to an XGpio instance to be worked on.
+* @param Channel contains the channel of the GPIO (1 or 2) to operate on.
 * @param Data is the value to be written to the discretes register.
 *
+* @return
+*
+* None.
+*
 * @note
 *
+* The hardware must be built for dual channels if this function is used
+* with any channel other than 1.  If it is not, this function will assert.
 * See also XGpio_DiscreteSet() and XGpio_DiscreteClear().
 *
 *****************************************************************************/
-void XGpio_DiscreteWrite(XGpio * InstancePtr, u32 Data)
+void XGpio_DiscreteWrite(XGpio * InstancePtr, unsigned Channel, u32 Data)
 {
 	XASSERT_VOID(InstancePtr != NULL);
 	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XGpio_mWriteReg(InstancePtr->BaseAddress, XGPIO_DATA_OFFSET, Data);
+	XASSERT_VOID((Channel == 1) ||
+		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));
+
+	XGpio_mWriteReg(InstancePtr->BaseAddress,
+			((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET,
+			Data);
 }
Index: linux-2.6.10/drivers/char/xilinx_gpio/xgpio.h
===================================================================
--- linux-2.6.10.orig/drivers/char/xilinx_gpio/xgpio.h
+++ linux-2.6.10/drivers/char/xilinx_gpio/xgpio.h
@@ -27,7 +27,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002-2005 Xilinx Inc.
+*     (c) Copyright 2002 - 2005 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -41,37 +41,67 @@
 * @file xgpio.h
 *
 * This file contains the software API definition of the Xilinx General Purpose
-* I/O (XGpio) component.
+* I/O (XGpio) device driver component.
 *
-* The Xilinx GPIO controller is a soft IP core designed for  Xilinx FPGAs and
-* contains the following general features:
-*   - Support for 8, 16, or 32 I/O discretes
+* The Xilinx GPIO controller is a soft IP core designed for Xilinx FPGAs on
+* the OPB or PLB bus and contains the following general features:
+*   - Support for up to 32 I/O discretes for each channel (64 bits total).
 *   - Each of the discretes can be configured for input or output.
+*   - Configurable support for dual channels and interrupt generation.
+*
+* The driver provides interrupt management functions. Implementation of
+* interrupt handlers is left to the user. Refer to the provided interrupt
+* example in the examples directory for details.
+*
+* This driver is intended to be RTOS and processor independent. Any needs for
+* dynamic memory management, threads or thread mutual exclusion, virtual
+* memory, or cache control must be satisfied by the layer above this driver.
+*
+* <b>Initialization & Configuration</b>
+*
+* The XGpio_Config structure is used by the driver to configure itself. This
+* configuration structure is typically created by the tool-chain based on HW
+* build properties.
+*
+* To support multiple runtime loading and initialization strategies employed
+* by various operating systems, the driver instance can be initialized in one
+* of the following ways:
+*
+*   - XGpio_Initialize(InstancePtr, DeviceId) - The driver looks up its own
+*     configuration structure created by the tool-chain based on an ID provided
+*     by the tool-chain.
+*
+*   - XGpio_CfgInitialize(InstancePtr, CfgPtr, EffectiveAddr) - Uses a
+*     configuration structure provided by the caller. If running in a system
+*     with address translation, the provided virtual memory base address
+*     replaces the physical address present in the configuration structure.
 *
 * @note
 *
-* This driver does not support the second channel of the dual channel gpio
-* cores, nor does it support interrupts for those gpio cores that include
-* interrupts.
-*
-* This API utilizes 32 bit I/O to the GPIO registers. With 16 and 8 bit GPIO
-* components, the unused bits from registers are read as zero and written as
-* don't cares.
+* This API utilizes 32 bit I/O to the GPIO registers. With less than 32 bits,
+* the unused bits from registers are read as zero and written as don't cares.
 *
 * <pre>
 * MODIFICATION HISTORY:
 *
 * Ver   Who  Date     Changes
-* ----- ---- -------- --------------------------------------------------------
+* ----- ---- -------- -----------------------------------------------
 * 1.00a rmm  03/13/02 First release
-* 1.00a rpm  02/24/04 Added notes indicating lack of interrupt and dual channel
-*			 		  support.
+* 2.00a jhl  11/26/03 Added support for dual channels and interrupts
+* 2.01a jvb  12/14/05 I separated dependency on the static config table and
+*                     xparameters.h from the driver initialization by moving
+*                     _Initialize and _LookupConfig to _sinit.c. I also added
+*                     the new _CfgInitialize routine.
 * </pre>
 *****************************************************************************/
 
 #ifndef XGPIO_H			/* prevent circular inclusions */
 #define XGPIO_H			/* by using protection macros */
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /***************************** Include Files ********************************/
 
 #include "xbasic_types.h"
@@ -82,46 +112,73 @@
 
 /**************************** Type Definitions ******************************/
 
-/*
+/**
  * This typedef contains configuration information for the device.
  */
-typedef struct {
-	u16 DeviceId;		/* Unique ID  of device */
-	u32 BaseAddress;	/* Device base address */
-} XGpio_Config;
+	typedef struct {
+		u16 DeviceId;	/* Unique ID  of device */
+		u32 BaseAddress;	/* Device base address */
+		u32 InterruptPresent;	/* Are interrupts supported in h/w */
+		u32 IsDual;	/* Are 2 channels supported in h/w */
+	} XGpio_Config;
 
 /**
  * The XGpio driver instance data. The user is required to allocate a
  * variable of this type for every GPIO device in the system. A pointer
  * to a variable of this type is then passed to the driver API functions.
  */
-typedef struct {
-	u32 BaseAddress;	/* Device base address */
-	u32 IsReady;		/* Device is initialized and ready */
-} XGpio;
+	typedef struct {
+		u32 BaseAddress;	/* Device base address */
+		u32 IsReady;	/* Device is initialized and ready */
+		u32 InterruptPresent;	/* Are interrupts supported in h/w */
+		u32 IsDual;	/* Are 2 channels supported in h/w */
+	} XGpio;
 
 /***************** Macros (Inline Functions) Definitions ********************/
 
 /************************** Function Prototypes *****************************/
 
 /*
- * API Basic functions implemented in xgpio.c
+ * Initialization functions in xgpio_sinit.c
  */
-XStatus XGpio_Initialize(XGpio * InstancePtr, u16 DeviceId);
-void XGpio_SetDataDirection(XGpio * InstancePtr, u32 DirectionMask);
-u32 XGpio_DiscreteRead(XGpio * InstancePtr);
-void XGpio_DiscreteWrite(XGpio * InstancePtr, u32 Mask);
+	XStatus XGpio_Initialize(XGpio * InstancePtr, u16 DeviceId);
+	XGpio_Config *XGpio_LookupConfig(u16 DeviceId);
 
-XGpio_Config *XGpio_LookupConfig(u16 DeviceId);
+/*
+ * API Basic functions implemented in xgpio.c
+ */
+	XStatus XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * Config,
+				    u32 EffectiveAddr);
+	void XGpio_SetDataDirection(XGpio * InstancePtr, unsigned Channel,
+				    u32 DirectionMask);
+	u32 XGpio_DiscreteRead(XGpio * InstancePtr, unsigned Channel);
+	void XGpio_DiscreteWrite(XGpio * InstancePtr, unsigned Channel,
+				 u32 Mask);
 
 /*
  * API Functions implemented in xgpio_extra.c
  */
-void XGpio_DiscreteSet(XGpio * InstancePtr, u32 Mask);
-void XGpio_DiscreteClear(XGpio * InstancePtr, u32 Mask);
+	void XGpio_DiscreteSet(XGpio * InstancePtr, unsigned Channel, u32 Mask);
+	void XGpio_DiscreteClear(XGpio * InstancePtr, unsigned Channel,
+				 u32 Mask);
 
 /*
  * API Functions implemented in xgpio_selftest.c
  */
-XStatus XGpio_SelfTest(XGpio * InstancePtr);
+	XStatus XGpio_SelfTest(XGpio * InstancePtr);
+
+/*
+ * API Functions implemented in xgpio_intr.c
+ */
+	void XGpio_InterruptGlobalEnable(XGpio * InstancePtr);
+	void XGpio_InterruptGlobalDisable(XGpio * InstancePtr);
+	void XGpio_InterruptEnable(XGpio * InstancePtr, u32 Mask);
+	void XGpio_InterruptDisable(XGpio * InstancePtr, u32 Mask);
+	void XGpio_InterruptClear(XGpio * InstancePtr, u32 Mask);
+	u32 XGpio_InterruptGetEnabled(XGpio * InstancePtr);
+	u32 XGpio_InterruptGetStatus(XGpio * InstancePtr);
+
+#ifdef __cplusplus
+}
+#endif
 #endif				/* end of protection macro */
Index: linux-2.6.10/drivers/char/xilinx_gpio/xgpio_l.h
===================================================================
--- linux-2.6.10.orig/drivers/char/xilinx_gpio/xgpio_l.h
+++ linux-2.6.10/drivers/char/xilinx_gpio/xgpio_l.h
@@ -27,7 +27,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002-2004 Xilinx Inc.
+*     (c) Copyright 2002 - 2004 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -46,20 +46,26 @@
 * hardware device specification for more details of the device operation.
 * High-level driver functions are defined in xgpio.h.
 *
-* @note
-*
-* This driver does not support the second channel of the dual channel gpio
-* cores, nor does it support interrupts for those gpio cores that include
-* interrupts.
+* The macros that are available in this file use a multiply to calculate the
+* addresses of registers. The user can control whether that multiply is done
+* at run time or at compile time. A constant passed as the channel parameter
+* will cause the multiply to be done at compile time. A variable passed as the
+* channel parameter will cause it to occur at run time.
 *
 * <pre>
 * MODIFICATION HISTORY:
 *
 * Ver   Who  Date     Changes
 * ----- ---- -------- -----------------------------------------------
-* 1.00a jhl  04/24/02 First release
-* 1.00a rpm  02/24/04 Added notes indicating lack of interrupt and dual channel
-*			 		  support.
+* 1.00a jhl  04/24/02 First release of low level driver
+* 2.00a jhl  11/26/03 Added support for dual channels and interrupts. This
+*                     change required the functions to be changed such that
+*                     the interface is not compatible with previous versions.
+*                     See the examples in the example directory for macros
+*                     to help compile an application that was designed for
+*                     previous versions of the driver. The interrupt registers
+*                     are accessible using the ReadReg and WriteReg macros and
+*                     a channel parameter was added to the other macros.
 * </pre>
 *
 ******************************************************************************/
@@ -67,6 +73,10 @@
 #ifndef XGPIO_L_H		/* prevent circular inclusions */
 #define XGPIO_L_H		/* by using protection macros */
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /***************************** Include Files *********************************/
 
 #include "xbasic_types.h"
@@ -76,81 +86,93 @@
 
 /** @name Registers
  *
- * Register offsets for this device. This device does not utilize IPIF registers.
+ * Register offsets for this device. This device utilizes IPIF interrupt
+ * registers.
  * @{
  */
-/**
- * - XGPIO_DATA_OFFSET    Data register
- * - XGPIO_TRI_OFFSET     Three state register (sets input/output direction)
- *                        0 configures pin for output and 1 for input.
- */
-#define XGPIO_DATA_OFFSET  0x00000000
-#define XGPIO_TRI_OFFSET   0x00000004
+#define XGPIO_DATA_OFFSET  0x0	/**< Data register for 1st channel */
+#define XGPIO_TRI_OFFSET   0x4	/**< I/O direction register for 1st channel */
+#define XGPIO_DATA2_OFFSET 0x8	/**< Data register for 2nd channel */
+#define XGPIO_TRI2_OFFSET  0xC	/**< I/O direction register for 2nd channel */
+
+#define XGPIO_GIER_OFFSET  0x11C /**< Glogal interrupt enable register */
+#define XGPIO_ISR_OFFSET   0x120 /**< Interrupt status register */
+#define XGPIO_IER_OFFSET   0x128 /**< Interrupt enable register */
+
 /* @} */
 
+/* The following constant describes the offset of each channels data and
+ * tristate register from the base address.
+ */
+#define XGPIO_CHAN_OFFSET  8
+
+/** @name Interrupt Status and Enable Register bitmaps and masks
+ *
+ * Bit definitions for the interrupt status register and interrupt enable
+ * registers.
+ * @{
+ */
+#define XGPIO_IR_MASK        0x3 /**< Mask of all bits */
+#define XGPIO_IR_CH1_MASK    0x1 /**< Mask for the 1st channel */
+#define XGPIO_IR_CH2_MASK    0x2 /**< Mask for the 2nd channel */
+/*@}*/
+
 /**************************** Type Definitions *******************************/
 
 /***************** Macros (Inline Functions) Definitions *********************/
 
-/*****************************************************************************
+/****************************************************************************/
+/**
 *
-* Low-level driver macros.  The list below provides signatures to help the
-* user use the macros.
+* Write a value to a GPIO register. A 32 bit write is performed. If the
+* GPIO component is implemented in a smaller width, only the least
+* significant data is written.
 *
-* u32 XGpio_mReadReg(u32 BaseAddress, int RegOffset, u32 Data)
-* void XGpio_mWriteReg(u32 BaseAddress, int RegOffset, u32 Data)
+* @param   BaseAddress is the base address of the GPIO device.
+* @param   RegOffset is the register offset from the base to write to.
+* @param   Data is the data written to the register.
 *
-* void XGpio_mSetDataDirection(u32 BaseAddress, u32 DirectionMask)
+* @return  None.
 *
-* u32 XGpio_mGetDataReg(u32 BaseAddress)
-* void XGpio_mSetDataReg(u32 BaseAddress, u32 Mask)
+* @note    None.
 *
-*****************************************************************************/
-
-/****************************************************************************/
-/**
- *
- * Write a value to a GPIO register. A 32 bit write is performed. If the
- * GPIO component is implemented in a smaller width, only the least
- * significant data is written.
- *
- * @param   BaseAddress is the base address of the GPIO device.
- * @param   RegOffset is the register offset from the base to write to.
- * @param   Data is the data written to the register.
- *
- * @return  None.
- *
- * @note    None.
- *
- ****************************************************************************/
+* C-style signature:
+*    void XGpio_mWriteReg(u32 BaseAddress, unsigned RegOffset,
+*                         u32 Data)
+*
+****************************************************************************/
 #define XGpio_mWriteReg(BaseAddress, RegOffset, Data) \
-    (XIo_Out32((BaseAddress) + (RegOffset), (u32)(Data)))
+    XIo_Out32((BaseAddress) + (RegOffset), (u32)(Data))
 
 /****************************************************************************/
 /**
- *
- * Read a value from a GPIO register. A 32 bit read is performed. If the
- * GPIO component is implemented in a smaller width, only the least
- * significant data is read from the register. The most significant data
- * will be read as 0.
- *
- * @param   BaseAddress is the base address of the GPIO device.
- * @param   Register is the register offset from the base to write to.
- * @param   Data is the data written to the register.
- *
- * @return  None.
- *
- * @note    None.
- *
- ****************************************************************************/
+*
+* Read a value from a GPIO register. A 32 bit read is performed. If the
+* GPIO component is implemented in a smaller width, only the least
+* significant data is read from the register. The most significant data
+* will be read as 0.
+*
+* @param   BaseAddress is the base address of the GPIO device.
+* @param   Register is the register offset from the base to read from.
+* @param   Data is the data from the register.
+*
+* @return  None.
+*
+* @note    None.
+*
+* C-style signature:
+*    u32 XGpio_mReadReg(u32 BaseAddress, unsigned RegOffset)
+*
+****************************************************************************/
 #define XGpio_mReadReg(BaseAddress, RegOffset) \
-    (XIo_In32((BaseAddress) + (RegOffset)))
+    XIo_In32((BaseAddress) + (RegOffset))
 
 /*****************************************************************************
 *
-* Set the input/output direction of all signals.
+* Set the input/output direction of the signals of the specified GPIO channel.
 *
 * @param    BaseAddress contains the base address of the GPIO device.
+* @param    Channel contains the channel (1 or 2) to operate on.
 * @param    DirectionMask is a bitmask specifying which discretes are input and
 *           which are output. Bits set to 0 are output and bits set to 1 are
 *           input.
@@ -159,41 +181,62 @@
 *
 * @note     None.
 *
+* C-style signature:
+*    void XGpio_mSetDataDirection(u32 BaseAddress, unsigned Channel,
+*                                 u32 DirectionMask)
+*
 ******************************************************************************/
-#define XGpio_mSetDataDirection(BaseAddress, DirectionMask) \
-    XGpio_mWriteReg((BaseAddress), XGPIO_TRI_OFFSET, (DirectionMask))
+#define XGpio_mSetDataDirection(BaseAddress, Channel, DirectionMask) \
+    XGpio_mWriteReg((BaseAddress), \
+                    (((Channel) - 1) * XGPIO_CHAN_OFFSET) + XGPIO_TRI_OFFSET, \
+                    (DirectionMask))
 
 /****************************************************************************/
 /**
-* Get the data register.
+* Get the data register of the specified GPIO channel.
 *
 * @param    BaseAddress contains the base address of the GPIO device.
+* @param    Channel contains the channel (1 or 2) to operate on.
 *
 * @return   The contents of the data register.
 *
 * @note     None.
 *
+* C-style signature:
+*    u32 XGpio_mGetDataReg(u32 BaseAddress, unsigned Channel)
+*
 *****************************************************************************/
-#define XGpio_mGetDataReg(BaseAddress) \
-    XGpio_mReadReg(BaseAddress, XGPIO_DATA_OFFSET)
+#define XGpio_mGetDataReg(BaseAddress, Channel) \
+    XGpio_mReadReg((BaseAddress), \
+                   (((Channel) - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET)
 
 /****************************************************************************/
 /**
-* Set the data register.
+* Set the data register of the specified GPIO channel.
 *
 * @param    BaseAddress contains the base address of the GPIO device.
+* @param    Channel contains the channel (1 or 2) to operate on.
 * @param    Data is the value to be written to the data register.
 *
 * @return   None.
 *
 * @note     None.
 *
+* C-style signature:
+*    void XGpio_mSetDataReg(u32 BaseAddress, unsigned Channel,
+*                           u32 Data)
+*
 *****************************************************************************/
-#define XGpio_mSetDataReg(BaseAddress, Data) \
-    XGpio_mWriteReg((BaseAddress), XGPIO_DATA_OFFSET, (Data))
+#define XGpio_mSetDataReg(BaseAddress, Channel, Data) \
+    XGpio_mWriteReg((BaseAddress), \
+                    (((Channel) - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET,\
+                    (Data))
 
 /************************** Function Prototypes ******************************/
 
 /************************** Variable Definitions *****************************/
 
+#ifdef __cplusplus
+}
+#endif
 #endif				/* end of protection macro */
Index: linux-2.6.10/include/linux/xilinx_devices.h
===================================================================
--- linux-2.6.10.orig/include/linux/xilinx_devices.h
+++ linux-2.6.10/include/linux/xilinx_devices.h
@@ -73,5 +73,10 @@ struct xspi_platform_data {
 #define XSPI_HAS_FIFOS		0x00000001
 #define XSPI_SLAVE_ONLY		0x00000002
 
+/*- GPIO -*/
+
+/* Flags related to XGPIO device features */
+#define XGPIO_IS_DUAL		0x00000001
+
 #endif /* _XILINX_DEVICE_H_ */
 #endif /* __KERNEL__ */
Index: linux-2.6.10/arch/ppc/platforms/4xx/xparameters/xparameters_ml40x.h
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/4xx/xparameters/xparameters_ml40x.h
+++ linux-2.6.10/arch/ppc/platforms/4xx/xparameters/xparameters_ml40x.h
@@ -190,20 +190,17 @@
 /******************************************************************/
 
 #define XPAR_GPIO_0_BASEADDR XPAR_OPB_GPIO_0_BASEADDR
-#define XPAR_GPIO_0_HIGHADDR (XPAR_OPB_GPIO_0_BASEADDR + 7)
-#define XPAR_GPIO_0_DEVICE_ID 0
-#define XPAR_GPIO_1_BASEADDR (XPAR_OPB_GPIO_0_BASEADDR + 8)
-#define XPAR_GPIO_1_HIGHADDR (XPAR_OPB_GPIO_0_BASEADDR + 15)
-#define XPAR_GPIO_1_DEVICE_ID 1
-#define XPAR_GPIO_2_BASEADDR XPAR_OPB_GPIO_EXP_HDR_0_BASEADDR
-#define XPAR_GPIO_2_HIGHADDR (XPAR_OPB_GPIO_EXP_HDR_0_BASEADDR + 7)
-#define XPAR_GPIO_2_DEVICE_ID 2
-#define XPAR_GPIO_3_BASEADDR (XPAR_OPB_GPIO_EXP_HDR_0_BASEADDR + 8)
-#define XPAR_GPIO_3_HIGHADDR (XPAR_OPB_GPIO_EXP_HDR_0_BASEADDR + 15)
-#define XPAR_GPIO_3_DEVICE_ID 3
-#define XPAR_GPIO_4_BASEADDR XPAR_OPB_GPIO_CHAR_LCD_0_BASEADDR
-#define XPAR_GPIO_4_HIGHADDR XPAR_OPB_GPIO_CHAR_LCD_0_HIGHADDR
-#define XPAR_GPIO_4_DEVICE_ID 4
+#define XPAR_GPIO_0_HIGHADDR XPAR_OPB_GPIO_0_HIGHADDR
+#define XPAR_GPIO_0_DEVICE_ID XPAR_OPB_GPIO_0_DEVICE_ID
+#define XPAR_GPIO_0_IS_DUAL XPAR_OPB_GPIO_0_IS_DUAL
+#define XPAR_GPIO_1_BASEADDR XPAR_OPB_GPIO_EXP_HDR_0_BASEADDR
+#define XPAR_GPIO_1_HIGHADDR XPAR_OPB_GPIO_EXP_HDR_0_HIGHADDR
+#define XPAR_GPIO_1_DEVICE_ID XPAR_OPB_GPIO_EXP_HDR_0_DEVICE_ID
+#define XPAR_GPIO_1_IS_DUAL XPAR_OPB_GPIO_EXP_HDR_0_IS_DUAL
+#define XPAR_GPIO_2_BASEADDR XPAR_OPB_GPIO_CHAR_LCD_0_BASEADDR
+#define XPAR_GPIO_2_HIGHADDR XPAR_OPB_GPIO_CHAR_LCD_0_HIGHADDR
+#define XPAR_GPIO_2_DEVICE_ID XPAR_OPB_GPIO_CHAR_LCD_0_DEVICE_ID
+#define XPAR_GPIO_2_IS_DUAL XPAR_OPB_GPIO_CHAR_LCD_0_IS_DUAL
 
 /******************************************************************/
 
Index: linux-2.6.10/mvl_patches/pro-0644.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0644.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(644);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

