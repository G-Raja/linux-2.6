#! /usr/bin/env bash
# Patch: -ppc_xilinx_edk_temac
# Date: Mon Mar  6 15:03:21 2006
# Source: Xilinx, Inc., www.xilinx.com
# MR: 15265
# Type: Integration
# Disposition: needs submitting to linuxppc-embedded
# Signed-off-by: Andrei Konovalov <akonovalov@ru.mvista.com>
# Description:
#     EDK level 1 driver code for TEMAC IP.
#     Taken from EDK 7.1i SP2.
# 

PATCHNUM=346
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Xilinx, Inc., www.xilinx.com
MR: 15265
Type: Integration
Disposition: needs submitting to linuxppc-embedded
Signed-off-by: Andrei Konovalov <akonovalov@ru.mvista.com>
Description:
    EDK level 1 driver code for TEMAC IP.
    Taken from EDK 7.1i SP2.

 drivers/net/xilinx_temac/xtemac.c            |  575 +++++++++++
 drivers/net/xilinx_temac/xtemac.h            | 1346 +++++++++++++++++++++++++++
 drivers/net/xilinx_temac/xtemac_control.c    | 1091 +++++++++++++++++++++
 drivers/net/xilinx_temac/xtemac_fifo.c       | 1308 ++++++++++++++++++++++++++
 drivers/net/xilinx_temac/xtemac_i.h          |  112 ++
 drivers/net/xilinx_temac/xtemac_intr.c       |  170 +++
 drivers/net/xilinx_temac/xtemac_intr_fifo.c  |  498 +++++++++
 drivers/net/xilinx_temac/xtemac_intr_sgdma.c |  468 +++++++++
 drivers/net/xilinx_temac/xtemac_l.c          |  255 +++++
 drivers/net/xilinx_temac/xtemac_l.h          |  628 ++++++++++++
 drivers/net/xilinx_temac/xtemac_sgdma.c      |  657 +++++++++++++
 mvl_patches/pro-0346.c                       |   16 
 12 files changed, 7124 insertions(+)

Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac.c
@@ -0,0 +1,575 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac.c
+*
+* The XTemac driver. Functions in this file are the minimum required functions
+* for this driver. See xtemac.h for a detailed description of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+void XTemac_StubHandler(void);	/* Default handler routine */
+static void InitHw(XTemac * InstancePtr);	/* HW reset */
+static XStatus Initialize(XTemac * InstancePtr);
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+* Initialize a specific XTemac instance/driver for systems that use address
+* translation. This function performs the same initialization steps as does
+* XTemac_Initialize() except for how the base address of the device derived.
+* Instead of using the physical address found in the configuration table for
+* the given device ID, the supplied virtual address is used.
+*
+* For systems that do not use address translation, use XTemac_Initialize()
+* instead of this one to initialize a device instance.
+*
+* See XTemac_Initialize() for further information on what is done during
+* initialization.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param DeviceId is the unique id of the device controlled by this XTemac
+*        instance.  Passing in a device id associates the generic XTemac
+*        instance to a specific device, as chosen by the caller or application
+*        developer.
+* @param VirtualAddress is the virtual base address of the device if address
+*        translation is being utilized. This address must translate to the
+*        physical address as defined in the XTemac_ConfigTable array for the
+*        given DeviceId. The translation must be setup by the user prior to
+*        calling this function.
+*
+* @return
+* - XST_SUCCESS if initialization was successful
+* - XST_DEVICE_NOT_FOUND if device configuration information was not found for
+*   a device with the supplied device ID.
+* - XST_FAILURE if initialization of packet FIFOs or DMA channels failed.
+*
+******************************************************************************/
+XStatus XTemac_VmInitialize(XTemac * InstancePtr, u16 DeviceId,
+			    u32 VirtualAddress)
+{
+	/* Verify arguments */
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* Clear instance memory */
+	memset(InstancePtr, 0, sizeof(XTemac));
+
+	/* Lookup the configuration information for this device */
+	InstancePtr->Config = XTemac_LookupConfig(DeviceId);
+	if (InstancePtr->Config == NULL) {
+		return (XST_DEVICE_NOT_FOUND);
+	}
+
+	/* Setup the device's base address */
+	InstancePtr->BaseAddress = VirtualAddress;
+
+	/* Call local function to perform rest of init */
+	return (Initialize(InstancePtr));
+}
+
+/*****************************************************************************/
+/**
+* Initialize a specific XTemac instance/driver. The initialization entails:
+* - Initialize fields of the XTemac structure
+* - Initialize the IPIF component with its register base address
+* - Configure the FIFO components with their register base addresses.
+* - If the device is configured with DMA, configure the DMA channel components
+*   with their register base addresses. At some later time, memory pools for
+*   the scatter-gather descriptor lists may be passed to the driver.
+* - Reset the MAC hardware
+*
+* The PHY is setup independently from the TEMAC. Use the MII or whatever other
+* interface may be present for setup.
+*
+* For systems that do use address translation, use XTemac_VmInitialize()
+* instead of this one to initialize a device instance.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param DeviceId is the unique id of the device controlled by this XTemac
+*        instance.  Passing in a device id associates the generic XTemac
+*        instance to a specific device, as chosen by the caller or application
+*        developer.
+*
+* @return
+* - XST_SUCCESS if initialization was successful
+* - XST_DEVICE_NOT_FOUND if device configuration information was not found for
+*   a device with the supplied device ID.
+* - XST_FAILURE if initialization of packet FIFOs or DMA channels failed.
+*
+******************************************************************************/
+XStatus XTemac_Initialize(XTemac * InstancePtr, u16 DeviceId)
+{
+	/* Verify arguments */
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* Clear instance memory */
+	memset(InstancePtr, 0, sizeof(XTemac));
+
+	/* Lookup the device configuration */
+	InstancePtr->Config = XTemac_LookupConfig(DeviceId);
+	if (InstancePtr->Config == NULL) {
+		return (XST_DEVICE_NOT_FOUND);
+	}
+
+	/* Initialize the device register base addresses */
+	InstancePtr->BaseAddress = InstancePtr->Config->BaseAddress;
+
+	/* Call local function to perform rest of init */
+	return (Initialize(InstancePtr));
+}
+
+/*****************************************************************************/
+/**
+* Start the Ethernet controller as follows:
+*   - Enable transmitter if XTE_TRANSMIT_ENABLE_OPTION is set
+*   - Enable receiver if XTE_RECEIVER_ENABLE_OPTION is set
+*   - If not polled mode, then start the SG DMA send and receive channels (if
+*     configured) and enable the global device interrupt.
+*
+* If starting for the first time after calling XTemac_Initialize() or
+* XTemac_Reset(), interrupts will not be generated until one or more of
+* XTemac_IntrFifoEnable(), XTemac_IntrFifoDmaEnable(), or
+* XTemac_IntrSgEnable() are called. Otherwise, interrupt settings made by
+* these functions will be restored.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @return
+* - XST_SUCCESS if the device was started successfully
+* - XST_DMA_SG_NO_LIST if configured for scatter-gather DMA and a descriptor
+*   list has not yet been created for the send or receive channel
+* - XST_DMA_SG_LIST_EMPTY if configured for scatter-gather DMA but no
+*   receive buffer descriptors have been initialized.
+*
+* @note
+* The driver tries to match the hardware configuration. So if the hardware
+* is configured with scatter-gather DMA, the driver expects to start the
+* scatter-gather channels and expects that the user has previously set up
+* the buffer descriptor lists.
+*
+* This function makes use of internal resources that are shared between the
+* Start, Stop, and Set/ClearOptions functions. So if one task might be setting
+* device options while another is trying to start the device, the user is
+* required to provide protection of this shared data (typically using a
+* semaphore).
+*
+* This function must not be preempted by an interrupt that may service the
+* device.
+*
+******************************************************************************/
+XStatus XTemac_Start(XTemac * InstancePtr)
+{
+	u32 Reg;
+	XStatus Result;
+
+	/* Assert bad arguments and conditions */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* If already started, then there is nothing to do */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_SUCCESS);
+	}
+
+	/* Start SG DMA (only if not in polled mode) */
+	if (XTemac_mIsSgDma(InstancePtr) &&
+	    ((InstancePtr->Options & XTE_POLLED_OPTION) == 0)) {
+		/* When starting the DMA channels, both transmit and receive sides
+		 * need an initialized BD list.
+		 */
+		Result = XDmaV2_SgStart(&InstancePtr->RecvDma);
+		if (Result == XST_DMA_SG_NO_LIST) {
+			return (Result);
+		}
+
+		Result = XDmaV2_SgStart(&InstancePtr->SendDma);
+		if (Result == XST_DMA_SG_NO_LIST) {
+			return (Result);
+		}
+	}
+
+	/* Enable transmitter if not already enabled */
+	if (InstancePtr->Options & XTE_TRANSMITTER_ENABLE_OPTION) {
+		Reg = XTemac_mGetHostReg(XTE_ETXC_OFFSET);
+		if (!(Reg & XTE_ETXC_TXEN_MASK)) {
+			XTemac_mSetHostReg(XTE_ETXC_OFFSET,
+					   Reg | XTE_ETXC_TXEN_MASK);
+		}
+	}
+
+	/* Enable receiver? */
+	if (InstancePtr->Options & XTE_RECEIVER_ENABLE_OPTION) {
+		Reg =
+		    XTemac_mGetHostReg(XTE_ERXC1_OFFSET) | XTE_ERXC1_RXEN_MASK;
+		XTemac_mSetHostReg(XTE_ERXC1_OFFSET, Reg);
+	}
+
+	/* Mark as started */
+	InstancePtr->IsStarted = XCOMPONENT_IS_STARTED;
+
+	/* Allow interrupts (if not in polled mode) and exit */
+	if ((InstancePtr->Options & XTE_POLLED_OPTION) == 0) {
+		XTemac_mSetIpifReg(XTE_DGIE_OFFSET, XTE_DGIE_ENABLE_MASK);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* Gracefully stop the Ethernet MAC as follows:
+*   - Disable all interrupts from this device
+*   - Stop DMA channels (if configured)
+*   - Disable the receiver
+*
+* Device options currently in effect are not changed.
+*
+* This function will disable all interrupts by clearing the global interrupt
+* enable bit. Any interrupts settings that had been enabled through
+* XTemac_IntrFifoEnable(), XTemac_IntrFifoDmaEnable(), or
+* XTemac_IntrSgEnable() will be restored when XTemac_Start() is called.
+*
+* Since the transmitter is not disabled, frames currently in the packet FIFO
+* or in process by the SGDMA engine are allowed to be transmitted. XTemac API
+* functions that place new data in the packet FIFOs will not be allowed to do
+* so until XTemac_Start() is called.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @note
+* This function makes use of internal resources that are shared between the
+* Start, Stop, SetOptions, and ClearOptions functions. So if one task might be
+* setting device options while another is trying to start the device, the user
+* is required to provide protection of this shared data (typically using a
+* semaphore).
+*
+* Stopping the DMA channels may cause this function to block until the DMA
+* operation is complete. This function will not block waiting for frame data to
+* to exit the packet FIFO to the transmitter.
+*
+******************************************************************************/
+void XTemac_Stop(XTemac * InstancePtr)
+{
+	volatile u32 Reg;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* If already stopped, then there is nothing to do */
+	if (InstancePtr->IsStarted == 0) {
+		return;
+	}
+
+	/* Disable interrupts */
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
+
+	/* Stop Simple/SG DMA (unless in polled mode) */
+	if (!(InstancePtr->Options & XTE_POLLED_OPTION)) {
+		/* For simple DMA, wait for the DMA channel's BUSY bit to clear */
+		if (XTemac_mIsSimpleDma(InstancePtr)) {
+			do {
+				Reg = XDmaV2_mGetStatus(&InstancePtr->SendDma);
+			} while (Reg & XDMAV2_DMASR_DMABSY_MASK);
+
+			do {
+				Reg = XDmaV2_mGetStatus(&InstancePtr->RecvDma);
+			} while (Reg & XDMAV2_DMASR_DMABSY_MASK);
+
+		}
+
+		/* For SGDMA, use the DMA driver function to stop the channels */
+		else if (XTemac_mIsSgDma(InstancePtr)) {
+			(void)XDmaV2_SgStop(&InstancePtr->SendDma);
+			(void)XDmaV2_SgStop(&InstancePtr->RecvDma);
+		}
+	}
+
+	/* Disable the receiver */
+	Reg = XTemac_mGetHostReg(XTE_ERXC1_OFFSET);
+	Reg &= ~XTE_ERXC1_RXEN_MASK;
+	XTemac_mSetHostReg(XTE_ERXC1_OFFSET, Reg);
+
+	/* Stopping the receiver in mid-packet causes a dropped packet indication
+	 * from HW. Clear it.
+	 */
+	Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+	if (Reg & XTE_IPXR_RECV_REJECT_MASK) {
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_RECV_REJECT_MASK);
+	}
+
+	/* Mark as stopped */
+	InstancePtr->IsStarted = 0;
+}
+
+/*****************************************************************************/
+/**
+* Perform a graceful reset of the Ethernet MAC. Resets the DMA channels, the
+* FIFOs, the transmitter, and the receiver.
+*
+* All options are placed in their default state. Any frames in the scatter-
+* gather descriptor lists will remain in the lists. The side effect of doing
+* this is that after a reset and following a restart of the device, frames that
+* were in the list before the reset may be transmitted or received.
+*
+* The upper layer software is responsible for re-configuring (if necessary)
+* and restarting the MAC after the reset. Note also that driver statistics
+* are not cleared on reset. It is up to the upper layer software to clear the
+* statistics if needed.
+*
+* When a reset is required due to an internal error, the driver notifies the
+* upper layer software of this need through the ErrorHandler callback and
+* specific status codes.  The upper layer software is responsible for calling
+* this Reset function and then re-configuring the device.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @internal
+*
+* The reset is accomplished by setting the IPIF reset register.  This takes
+* care of resetting all hardware blocks, including the MAC.
+*
+******************************************************************************/
+void XTemac_Reset(XTemac * InstancePtr)
+{
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Stop the device and reset HW */
+	XTemac_Stop(InstancePtr);
+	InitHw(InstancePtr);
+
+	/* Set default options */
+	InstancePtr->Options = XTE_DEFAULT_OPTIONS;
+	XTemac_SetOptions(InstancePtr, InstancePtr->Options);
+	XTemac_ClearOptions(InstancePtr, ~InstancePtr->Options);
+}
+
+/*****************************************************************************/
+/**
+* Lookup the device configuration based on the unique device ID.  The table
+* contains the configuration info for each device in the system.
+*
+* @param DeviceId is the unique device ID of the device being looked up.
+*
+* @return
+* A pointer to the configuration table entry corresponding to the given
+* device ID, or NULL if no match is found.
+*
+******************************************************************************/
+XTemac_Config *XTemac_LookupConfig(u16 DeviceId)
+{
+	extern XTemac_Config XTemac_ConfigTable[];
+	XTemac_Config *CfgPtr = NULL;
+	int i;
+
+	for (i = 0; i < XPAR_XTEMAC_NUM_INSTANCES; i++) {
+		if (XTemac_ConfigTable[i].DeviceId == DeviceId) {
+			CfgPtr = &XTemac_ConfigTable[i];
+			break;
+		}
+	}
+
+	return (CfgPtr);
+}
+
+/*****************************************************************************
+* Finish off instance initialization started by XTemac_Initialize or
+* XTemac_VmInitialize().
+*
+* The two functions mentioned should have setup the following instance data
+* InstancePtr->Config and InstancePtr->BaseAddress.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @return
+* - XST_SUCCESS if initialization was successful
+* - XST_FAILURE if initialization of packet FIFOs or DMA channels failed.
+*
+******************************************************************************/
+static XStatus Initialize(XTemac * InstancePtr)
+{
+	XStatus Result;
+
+	/* Set callbacks to an initial stub routine */
+	InstancePtr->FifoRecvHandler =
+	    (XTemac_FifoRecvHandler) XTemac_StubHandler;
+	InstancePtr->FifoSendHandler =
+	    (XTemac_FifoSendHandler) XTemac_StubHandler;
+	InstancePtr->ErrorHandler = (XTemac_ErrorHandler) XTemac_StubHandler;
+
+	InstancePtr->FifoDmaReadHandler =
+	    (XTemac_FifoDmaReadHandler) XTemac_StubHandler;
+	InstancePtr->FifoDmaWriteHandler =
+	    (XTemac_FifoDmaWriteHandler) XTemac_StubHandler;
+
+	InstancePtr->SgRecvHandler = (XTemac_SgHandler) XTemac_StubHandler;
+	InstancePtr->SgSendHandler = (XTemac_SgHandler) XTemac_StubHandler;
+
+	/* Setup and select best processor based transfer method to/from FIFOs */
+	Result = XTemac_ConfigureFifoAccess(InstancePtr);
+	if (Result != XST_SUCCESS) {
+		return (XST_FAILURE);
+	}
+
+	/* Setup DMA channels */
+	if (XTemac_mIsDma(InstancePtr)) {
+		Result = XDmaV2_Initialize(&InstancePtr->RecvDma,
+					   InstancePtr->BaseAddress +
+					   XTE_DMA_RECV_OFFSET);
+		if (Result != XST_SUCCESS) {
+			return (XST_FAILURE);
+		}
+
+		Result = XDmaV2_Initialize(&InstancePtr->SendDma,
+					   InstancePtr->BaseAddress +
+					   XTE_DMA_SEND_OFFSET);
+		if (Result != XST_SUCCESS) {
+			return (XST_FAILURE);
+		}
+	}
+
+	/* Reset the hardware and set default options */
+	InstancePtr->IsReady = XCOMPONENT_IS_READY;
+	InstancePtr->Options = XTE_DEFAULT_OPTIONS;
+	InitHw(InstancePtr);
+
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************
+ * Perform one-time setup of HW. The setups performed here only need to occur
+ * once after any reset.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ ******************************************************************************/
+static void InitHw(XTemac * InstancePtr)
+{
+	u32 RegDXR;
+	u32 RegETXC;
+
+	/* Reset HW */
+	XTemac_mSetIpifReg(XTE_DSR_OFFSET, XTE_DSR_RESET_MASK);
+
+	/* Default IPIF interrupt block enable mask */
+	RegDXR = XTE_DXR_CORE_MASK |
+	    XTE_DXR_RECV_FIFO_MASK |
+	    XTE_DXR_SEND_FIFO_MASK | XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK;
+
+	/* Add to default IPIF interrupt block enable mask if DMA is present */
+	if (XTemac_mIsDma(InstancePtr)) {
+		RegDXR |= (XTE_DXR_RECV_DMA_MASK | XTE_DXR_SEND_DMA_MASK);
+	}
+
+	XTemac_mSetIpifReg(XTE_DIER_OFFSET, RegDXR);
+
+	/* Setup SGDMA interupt coalescing defaults */
+	if (XTemac_mIsSgDma(InstancePtr)) {
+		(void)XTemac_IntrSgCoalSet(InstancePtr, XTE_SEND,
+					   XTE_SGDMA_DFT_THRESHOLD,
+					   XTE_SGDMA_DFT_WAITBOUND);
+		(void)XTemac_IntrSgCoalSet(InstancePtr, XTE_RECV,
+					   XTE_SGDMA_DFT_THRESHOLD,
+					   XTE_SGDMA_DFT_WAITBOUND);
+	}
+
+	/* Interframe gap: The HW has an enable bit to change the IFG through the
+	 * XTE_IFGP_OFFSET register. Rather than make the user set this bit then
+	 * change the register, simplifiy the process by always setting the
+	 * enable bit. All the user needs to do is use XTemac_SetIfg() thereafter.
+	 */
+
+	/* The default IFG is 96 bit times. Whatever is in the register adds to that.
+	 * By default leave this register at 0 so we have 96 bit times.
+	 */
+	XTemac_mSetIpifReg(XTE_IFGP_OFFSET, 0);
+
+	/* Now set IFG adjust enable */
+	RegETXC = XTemac_mGetHostReg(XTE_ETXC_OFFSET) | XTE_ETXC_TXIFG_MASK;
+	XTemac_mSetHostReg(XTE_ETXC_OFFSET, RegETXC);
+
+	/* Set default MDIO divisor */
+	XTemac_PhySetMdioDivisor(InstancePtr, XTE_MDIO_DIV_DFT);
+
+	/* Sync default options with HW but leave receiver and transmitter
+	 * disabled. They get enabled with XTemac_Start() if XTE_TRANSMITTER_ENABLE-
+	 * _OPTION and XTE_RECEIVER_ENABLE_OPTION are set
+	 */
+	XTemac_SetOptions(InstancePtr, InstancePtr->Options &
+			  ~(XTE_TRANSMITTER_ENABLE_OPTION |
+			    XTE_RECEIVER_ENABLE_OPTION));
+
+	XTemac_ClearOptions(InstancePtr, ~InstancePtr->Options);
+}
+
+/******************************************************************************/
+/**
+ * This is a stub for the asynchronous callbacks. The stub is here in case the
+ * upper layer forgot to set the handler(s). On initialization, all handlers are
+ * set to this callback. It is considered an error for this handler to be
+ * invoked.
+ *
+ ******************************************************************************/
+void XTemac_StubHandler(void)
+{
+	XASSERT_VOID_ALWAYS();
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac.h
@@ -0,0 +1,1346 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file xtemac.h
+ *
+ * The Xilinx Tri-Mode Ethernet driver component. This driver supports the
+ * Virtex-4(TM) 10/100/1000 MAC (TEMAC).
+ *
+ * For a full description of TEMAC features, please see the HW spec. This driver
+ * supports the following features:
+ *   - Memory mapped access to host interface registers
+ *   - API for polled frame transfers (FIFO direct polled mode)
+ *   - API for interrupt driven frame transfers with or without simple DMA
+ *     channels (FIFO direct mode)
+ *   - API for interrupt driven frame transfers with scatter-gather DMA (SGDMA
+ *     mode)
+ *   - Virtual memory support
+ *   - Unicast receive address filtering
+ *   - Broadcast receive address filtering
+ *   - Full duplex operation
+ *   - Automatic source address insertion or overwrite (programmable)
+ *   - Automatic PAD & FCS insertion and stripping (programmable)
+ *   - Pause frame (flow control) detection in full-duplex mode
+ *   - Programmable interframe gap
+ *   - VLAN frame support
+ *   - Pause frame support
+ *   - Jumbo frame support
+ *   - Data Realignment Engine (DRE)
+ *
+ * <b>Driver Description</b>
+ *
+ * The device driver enables higher layer software (e.g., an application) to
+ * communicate to the TEMAC. The driver handles transmission and reception of
+ * Ethernet frames, as well as configuration and control. No pre or post
+ * processing of frame data is performed. The driver does not validate the
+ * contents of an incoming frame in addition to what has already occurred in HW.
+ * A single device driver can support multiple devices even when those devices
+ * have significantly different configurations.
+ *
+ * <b>Device Configuration</b>
+ *
+ * The device can be configured in various ways during the FPGA implementation
+ * process. Configuration parameters are stored in xtemac_g.c. A table is
+ * defined that contains configuration information for each TEMAC in the system.
+ * This information includes such things as the base address of the memory-
+ * mapped device and whether the device has DMA, counter registers, multicast
+ * support, MII support, etc.
+ *
+ * The driver tries to use the features built into the device. So if the hardware
+ * is configured with SG DMA, the driver expects to start the scatter-gather
+ * channels and expects that the user has set up the buffer descriptor lists.
+ *
+ * If the user expects to use the driver in a mode different than how the
+ * hardware is configured, the user should modify the configuration table to
+ * reflect the mode to be used prior to device initialization. Care must be taken
+ * when modifying the table. Adding a feature that is not present in HW will
+ * cause system instability.
+ *
+ * The following example changes a device to FIFO direct mode:
+ * <pre>
+ *        XTemac_Config *ConfigPtr;
+ *
+ *        ConfigPtr = XTemac_LookupConfig(DeviceId);
+ *        ConfigPtr->IpIfDmaConfig = XEM_CFG_NO_DMA;
+ * </pre>
+ *
+ * <b>Asynchronous Callbacks</b>
+ *
+ * The driver services interrupts and passes Ethernet frames to the higher layer
+ * software through asynchronous callback functions. When using the driver
+ * directly (i.e., not with the RTOS protocol stack), the higher layer
+ * software must register its callback functions during initialization. The
+ * driver requires callback functions for received frames, for confirmation of
+ * transmitted frames, and for asynchronous errors.
+ *
+ * <b>Interrupts</b>
+ *
+ * The driver has no dependencies on the interrupt controller. The driver
+ * provides two interrupt handlers. XTemac_IntrFifoHandler() handles
+ * interrupts when the MAC is configured for FIFO direct and simple DMA frame
+ * transfer mode. XTemac_IntrSgHandler() handles interrupts when the MAC is
+ * configured for SG DMA mode. Either one of these routines can be connected to
+ * the system interrupt controller by BSP/OS specific means.
+ *
+ * SGDMA implements interrupt coalescing features that reduce the number of
+ * interrupts the processor must service. A more complete discussion of this
+ * feature occurs in the API section below.
+ *
+ * <b>Device Reset</b>
+ *
+ * Some errors that can occur in the device require a device reset. These errors
+ * are listed in the XTemac_ErrorHandler() function typedef header. The user's
+ * error handler is responsible for resetting and re-configuring the device.
+ *
+ * <b>Virtual Memory</b>
+ *
+ * This driver has limited support for systems that use virtual memory. For
+ * these types of systems, XTemac_VmInitialize() should be used instead of
+ * XTemac_Initialize() to setup a device instance.
+ *
+ * All virtual to physical memory mappings must occur prior to accessing the
+ * driver API. The driver does not support multiple virtual memory translations
+ * that map to the same physical address.
+ *
+ * For DMA transactions, user buffers supplied to the driver must be in terms
+ * of their physical address.
+ *
+ * <b>Frame Transfer APIs</b>
+ *
+ * The next 4 sections discuss the APIs available to transfer frames between user
+ * buffers and the Ethernet. These APIs vary considerably in performance and
+ * depend on specific HW configuration.
+ *
+ * Except for SGDMA, these APIs allow the user independent access to the packet
+ * FIFOs and the length/status FIFOs. The packet FIFOs contain the frame data
+ * while the length/status FIFOs contain receive lengths, transmit lengths,
+ * and transmit statuses. It is very important to keep these two sets of
+ * FIFOs in sync with each other. When they are out of sync, then user data
+ * will become corrupted.
+ *
+ * On the transmit side, the transmit packet FIFO may contain more than one
+ * Ethernet packet. The number of packets it may contain depends on its depth
+ * which is controlled at HW build time. For each packet in the FIFO, the user
+ * must initiate a transmit by writing into the transmit length FIFO (see
+ * XTemac_FifoSend()). The number of bytes specified to transmit must match
+ * exactly the lengths of packets in the packet FIFO. For example, if a 76 byte
+ * packet was written followed by a 124 byte packet, then the transmit length
+ * FIFO must be written with 76 followed by 124. At the completion of the
+ * transmission, the transmit status FIFO must be read to obtain the outcome
+ * of the operation. The first status will be for the 76 byte packet followed
+ * by the 124 byte packet.
+ *
+ * On the receive side, it is a little easier to keep things in sync because
+ * the HW writes to the receive packet FIFO. Just like the transmit packet FIFO,
+ * the receive packet FIFO can contain more than one received Ethernet frame.
+ * Each time a length is extracted from the receive length FIFO (see
+ * XTemac_FifoRecv()), then that many bytes must be read from the receive
+ * packet FIFO.
+ *
+ * The easiest way to keep these FIFOs in sync is to process a single frame at
+ * a time. But when performance is an issue, it may be desirable to process
+ * multiple or even partial frames from non-contiguous memory regions with the
+ * API functions. The examples that accompany this driver illustrate how these
+ * advanced frame processing methods can be implemented.
+ *
+ * <b>API for FIFO Direct Polled Mode</b>
+ *
+ * This mode is available for all HW configurations. It uses the processor to
+ * transfer data between user buffers and the packet FIFOs. This mode may be used
+ * when the XTE_POLLED_OPTION has been set (see XTemac_SetOptions()).
+ *
+ * Relevant functions for this mode are:
+ *   - XTemac_FifoGetFreeBytes()
+ *   - XTemac_FifoWrite()
+ *   - XTemac_FifoSend()
+ *   - XTemac_FifoQuerySendStatus()
+ *   - XTemac_FifoQueryRecvStatus()
+ *   - XTemac_FifoRecv()
+ *   - XTemac_FifoRead()
+ *
+ * To send frames in this mode:
+ *   - Call XTemac_FifoGetFreeBytes() to make sure there is room in the transmit
+ *     packet FIFO for the frame(s) to be sent.
+ *   - Write frame data into the FIFO using XTemac_FifoWrite().
+ *   - Initiate transmit by calling XTemac_FifoSend() for each frame to send.
+ *   - For each time XTemac_FifoSend() has been called, continue to invoke
+ *     XTemac_FifoQuerySendStatus() until it reports that a frame has been sent
+ *     or an error occurred.
+ *
+ * To receive frames in this mode:
+ *   - Call XTemac_FifoQueryRecvStatus() until it reports that a frame has been
+ *     received.
+ *   - Call XTemac_FifoRecv() to get the length of the next pending frame.
+ *   - Call XTemac_FifoRead() to read the data into your buffer.
+ *
+ * <b>API for FIFO Direct Interrupt Driven Mode</b>
+ *
+ * This mode is available for all HW configurations. It uses the processor to
+ * transfer data between user buffers and the packet FIFOs. Interrupts are
+ * utilized to notify the user whether frames have arrived, have been sent,
+ * or an error has occurred.
+ *
+ * Relevant functions and callbacks for this mode are:
+ *   - XTemac_FifoGetFreeBytes()
+ *   - XTemac_FifoWrite()
+ *   - XTemac_FifoSend()
+ *   - XTemac_FifoRecv()
+ *   - XTemac_FifoRead()
+ *   - XTemac_IntrFifoEnable()
+ *   - XTemac_IntrFifoDisable()
+ *   - XTE_HANDLER_FIFOSEND callback
+ *   - XTE_HANDLER_FIFORECV callback
+ *   - XTE_HANDLER_ERROR callback
+ *
+ * To send frames in this mode:
+ *   - Enable transmit interrupts with XTemac_IntrFifoEnable().
+ *   - Call XTemac_FifoGetFreeBytes() to make sure there is room in the transmit
+ *     packet FIFO for the frame(s) to be sent.
+ *   - Write frame data into the FIFO using XTemac_FifoWrite().
+ *   - Initiate transmit by calling XTemac_FifoSend() for each frame to send.
+ *   - For each frame successfully transmitted, the FifoSend callback is invoked.
+ *   - The user's FifoSend callback should handle post frame transmission
+ *     application level work.
+ *
+ * To receive frames in this mode:
+ *   - Enable receive interrupts with XTemac_IntrFifoEnable().
+ *   - Upon arrival of a frame, the user's FifoRecv callback is invoked.
+ *   - The user's FifoRecv callback must call XTemac_FifoRecv() to get the
+ *     length of the waiting frame and then call XTemac_FifoRead() to copy
+ *     the frame to a user buffer.
+ *   - Alternatively, the user's FifoRecv callback may defer reception of the
+ *     frame by disabling receive interrupts with XTemac_IntrFifoDisable().
+ *     This can improve interrupt latency for other system devices by moving
+ *     the processor intensive XTemac_FifoRead() function out of interrupt
+ *     context.
+ *
+ * <b>API for FIFO Direct with Simple DMA Interrupt Driven Mode</b>
+ *
+ * This transfer mode utilizes simple DMA channels to move data between user
+ * buffers and the FIFOs. This mode is similar to FIFO direct transfer mode
+ * except that XTemac_FifoDmaRead() can be used instead of XTemac_FifoRead(),
+ * and XTemac_FifoDmaWrite() instead of XTemac_FifoWrite().
+ *
+ * Relevant functions and callbacks for this mode are:
+ *   - XTemac_FifoWrite()
+ *   - XTemac_FifoSend()
+ *   - XTemac_FifoRecv()
+ *   - XTemac_FifoRead()
+ *   - XTemac_IntrFifoEnable()
+ *   - XTemac_IntrFifoDisable()
+ *   - XTE_HANDLER_FIFOSEND callback
+ *   - XTE_HANDLER_FIFORECV callback
+ *   - XTE_HANDLER_ERROR callback
+ *   - XTemac_FifoDmaWrite()
+ *   - XTemac_FifoDmaRead()
+ *   - XTemac_IntrFifoDmaEnable()
+ *   - XTemac_IntrFifoDmaDisable()
+ *   - XTE_HANDLER_FIFODMAWRITE callback
+ *   - XTE_HANDLER_FIFODMAREAD callback
+ *
+ * To send frames in this mode:
+ *   - Enable transmit interrupts with XTemac_IntrFifoEnable().
+ *   - Enable send channel DMA interrupts with XTemac_IntrFifoDmaEnable().
+ *   - Call XTemac_FifoGetFreeBytes() to make sure there is room in the transmit
+ *     packet FIFO for the frame to be sent.
+ *   - Initiate transfer of data from user buffer to FIFO by calling
+ *     XTemac_FifoDmaWrite().
+ *   - When DMA operation completes, the FifoDmaWrite callback is invoked at
+ *     which point XTemac_FifoSend() should be called to begin transmission.
+ *   - For each frame successfully transmitted, the FifoSend callback is invoked.
+ *   - The user's FifoSend callback should handle post frame transmission
+ *     application level work.
+ *
+ * To receive frames in this mode:
+ *   - Enable receive interrupts with XTemac_IntrFifoEnable().
+ *   - Enable packet FIFO to buffer DMA interrupts with
+ *     XTemac_IntrFifoDmaEnable().
+ *   - Upon arrival of a frame, the user's FifoRecv callback is invoked.
+ *   - The user's FifoRecv callback must call XTemac_FifoRecv() to get the
+ *     length of the waiting frame and then call XTemac_FifoDmaRead() to
+ *     initiate a DMA transfer from the FIFO to a user buffer.
+ *   - When the DMA operation completes, the FifoDmaRead callback is invoked, at
+ *     which point application level work is performed to handle the new frame.
+ *
+ * In some situations, a DMA operation may not be desirable. The extra overhead
+ * of DMA interrupts may decrease throughput of small packets. In this case,
+ * the user may elect to use XTemac_FifoRead() or XTemac_FifoWrite() instead of
+ * starting a DMA transaction with XTemac_FifoDmaRead() or XTemac_FifoDmaWrite().
+ * These two sets of functions can be used interchangeably.
+ *
+ * <b>API for SG DMA Frame Transfer Mode</b>
+ *
+ * This API utilizes scatter-gather DMA (SGDMA) channels to transfer frame data
+ * between user buffers and the packet FIFOs.
+ *
+ * The SGDMA engine uses buffer descriptors (BDs) to describe Ethernet frames.
+ * These BDs are typically chained together into a list the HW follows when
+ * transferring data in and out of the packet FIFOs. Each BD describes a memory
+ * region containing either a full or partial Ethernet packet.
+ *
+ * The frequency of interrupts can be controlled with the interrupt coalescing
+ * features of the SG DMA engine. These features can be used to optimize
+ * interrupt latency and throughput for the user's network traffic conditions.
+ * The packet threshold count will delay processor interrupts until a
+ * programmable number of packets have arrived or have been transmitted. The
+ * packet wait bound timer can be used to cause a processor interrupt even though
+ * the packet threshold has not been reached. The timer begins counting after the
+ * last packet is processed. If no other packet is processed as the timer
+ * expires, then an interrupt will be generated.
+ *
+ * Another form of interrupt control is provided with the XTE_SGEND_INT_OPTION
+ * option. When enabled, an interrupt will occur when SGDMA engine completes the
+ * last BD to be processed and transitions to an idle state. This feature may be
+ * useful when a set of BDs have been queued up and the user only wants to be
+ * notified when they have all been processed by the HW. To use this feature
+ * effectively, interrupt coalescing should be disabled (packet threshold = 0,
+ * wait bound timer = 0), or the packet threshold should be set to a number
+ * larger than the number of packets queued up.
+ *
+ * By default, the driver will set the packet threshold = 1, wait bound timer =
+ * 0, and disable the XTE_SGEND_INT_OPTION. These settings will cause one
+ * interrupt per packet.
+ *
+ * Relevant functions and callbacks for this mode are:
+ *   - XTemac_mSgRecvBdNext()
+ *   - XTemac_mSgSendBdNext()
+ *   - XTemac_SgAlloc()
+ *   - XTemac_SgCommit()
+ *   - XTemac_SgGetProcessed()
+ *   - XTemac_SgFree()
+ *   - XTemac_SgSetSpace()
+ *   - XTemac_IntrSgEnable()
+ *   - XTemac_IntrSgDisable()
+ *   - XTemac_IntrSgCoalSet()
+ *   - XTemac_IntrSgCoalGet()
+ *   - XTE_HANDLER_SGSEND callback
+ *   - XTE_HANDLER_SGRECV callback
+ *   - XTE_HANDLER_ERROR callback
+ *
+ * This API requires the user to understand the how the SGDMA driver operates.
+ * The following paragraphs provide some explanation, but the user is encouraged
+ * to read documentation in xdmav2.h and xdmabdv2.h as well as study example code
+ * that accompanies this driver.
+ *
+ * The API is designed to get BDs to and from the SGDMA engine in the most
+ * efficient means possible. The first step is to establish a  memory region to
+ * contain all BDs for a specific channel. This is done with XTemac_SgSetSpace()
+ * and assumes the memory region is non-cached. This function sets up a BD ring
+ * that HW will follow as BDs are processed. The ring will consist of a user
+ * defined number of BDs which will all be partially initialized. For example on
+ * the transmit channel, the driver will initialize all BDs' destination address
+ * word with the address of the packet FIFO. The more fields that can be
+ * permanently setup at initialization, then the fewer accesses will be needed
+ * to each BD while the SGDMA engine is in operation resulting in better
+ * throughput and CPU utilization. The best case initialization would require
+ * the user to set only a frame buffer address and length prior to submitting
+ * the BD to the engine.
+ *
+ * BDs move through the engine with the help of functions XTemac_SgAlloc(),
+ * XTemac_SgCommit(), XTemac_SgGetProcessed(), and XTemac_SgFree(). All these
+ * functions handle BDs that are in place. That is, there are no copies of BDs
+ * kept anywhere and any BD the user interacts with is an actual BD from the
+ * same ring HW accesses. Changing fields within BDs is done through an API
+ * defined in xdmabdv2.h.
+ *
+ * BDs in the ring go through a series of states as follows:
+ *   1. Idle. The driver controls BDs in this state.
+ *   2. The user has data to transfer. XTemac_SgAlloc() is called to reserve
+ *      BD(s). Once allocated, the user may setup the BD(s) with frame buffer
+ *      address and length attributes. The user controls BDs in this state.
+ *   3. The user submits BDs to the SGDMA engine with XTemac_SgCommit. BDs in
+ *      this state are either waiting to be processed by HW, are in process, or
+ *      have been processed. The SGDMA engine controls BDs in this state.
+ *   4. Processed BDs are retrieved with XTemac_SgGetProcessed() by the
+ *      user. Once retrieved, the user can examine each BD for the outcome of
+ *      the DMA transfer. The user controls BDs in this state. After examining
+ *      the BDs the user calls XTemac_SgFree() which places the BDs back into
+ *      state 1.
+ *
+ * Each of the four BD accessor functions operate on a set of BDs. A set is
+ * defined as a segment of the BD ring consisting of one or more BDs.  The user
+ * views the set as a pointer to the first BD along with the number of BDs for
+ * that set. The set can be navigated by using macros XTemac_mSgRecvBdNext() or
+ * XTemac_mSgSendBdNext(). The user must exercise extreme caution when changing
+ * BDs in a set as there is nothing to prevent doing a mSgRecvBdNext past the
+ * end of the set and modifying a BD out of bounds.
+ *
+ * XTemac_SgAlloc() + XTemac_SgCommit(), as well as XTemac_SgGetProcessed() +
+ * XTemac_SgFree() are designed to be used in tandem. The same BD set retrieved
+ * with SgAlloc should be the same one provided to HW with SgCommit. Same goes
+ * with SgGetProcessed and SgFree.
+ *
+ * To transmit frames in this mode:
+ *   - Setup BD space for the transmit channel with XTemac_SgSetSpace().
+ *   - Enable transmit interrupts with XTemac_IntrSgEnable().
+ *   - Allocate a set of transmit channel BDs with XTemac_SgAlloc().
+ *   - Attach frame data to the BD set.
+ *   - Submit BD set to HW with XTemac_SgCommit().
+ *   - When the transmit channel completes and interrupt coalescing conditions
+ *     are met, the user's SgSend callback is invoked.
+ *   - The user's SgSend callback should handle or schedule a time to service
+ *     processed BDs as follows:
+ *       * Get a processed BD set with XTemac_SgGetProcessed()
+ *       * Examine BDs for transmit outcomes
+ *       * Free BD set back to the transmit channel with XTemac_SgFree().
+ *
+ * To receive frames in this mode:
+ *   - Setup BD space for the receive channel with XTemac_SgSetSpace().
+ *   - Allocate a set of receive channel BDs with XTemac_SgAlloc().
+ *   - Attach frame buffers to the BD set.
+ *   - Submit BD set to HW with XTemac_SgCommit().
+ *   - Enable receive interrupts with XTemac_IntrSgEnable().
+ *   - When frames are received and interrupt coalescing conditions
+ *     are met, the user's SgRecv callback is invoked.
+ *   - The user's SgRecv callback should handle or schedule a time to service
+ *     processed BDs as follows:
+ *       * Get a processed BD set with XTemac_SgGetProcessed().
+ *       * Detach frame buffer from BDs and pass buffer up the communication
+ *         stack
+ *       * Free BD set back to the receive channel with XTemac_SgFree().
+ *
+ * <b>SG DMA Troubleshooting</b>
+ *
+ * The SG DMA design used here is less forgiving than previous ones used in
+ * older versions of MAC cores that use version 1.00 of the DMA driver. Since
+ * BDs are pre-initialized by this driver to increase performance, there are
+ * some operations the user should avoid. For example, setting the destination
+ * address for a transmit BD will override the packet FIFO address preset by
+ * the XTemac driver. Operations such as this may cause the DMA channel to
+ * fail to transfer user data, lockup, or destabilize the system.
+ *
+ * To verify internal structures of BDs and the BD ring, the function
+ * XTemac_SgCheck() is provided. This function should be used as a debugging
+ * or diagnostic tool. If it returns a failure, the user should perform more
+ * in depth debugging to find the root cause.
+ *
+ * To avoid problems, do not use the following BD macros for transmit channel
+ * BDs (XTE_SEND):
+ *
+ *   - XDmaBdV2_mClear()
+ *   - XDmaBdV2_mSetDestBufIncrement()
+ *   - XDmaBdV2_mSetDestBufNoIncrement()
+ *   - XDmaBdV2_mSetRxDir()
+ *   - XDmaBdV2_mSetDestAddr()
+ *
+ * and for receive channel BDs (XTE_RECV):
+ *
+ *   - XDmaBdV2_mClear()
+ *   - XDmaBdV2_mSetSrcBufIncrement()
+ *   - XDmaBdV2_mSetSrcBufNoIncrement()
+ *   - XDmaBdV2_mSetTxDir()
+ *   - XDmaBdV2_mSetSrcAddr()
+ *
+ * <b>Alignment Restrictions</b>
+ *
+ * When HW is configured to use the Data Realignment Engine (DRE), alignment
+ * restrictions are as follows:
+ *   - XTemac_FifoDmaRead() & XTemac_FifoDmaWrite(): Transmit and receive buffers
+ *     must be aligned on a 8 byte boundary.
+ *   - SGDMA buffer descriptors must be aligned on a 8-byte boundary.
+ *   - SGDMA transmit buffers can be aligned on any boundary, but receive buffers
+ *     must be aligned on a 8-byte boundary.
+ *
+ * Without DRE, buffer alignment restrictions are as follows:
+ *   - XTemac_FifoDmaRead() & XTemac_FifoDmaWrite(): Transmit and receive buffers
+ *     must be aligned on a 8-byte boundary.
+ *   - SGDMA buffer descriptors must be aligned on a 8-byte boundary.
+ *   - SGDMA transmit and receive buffers must be aligned on a 8-byte boundary
+ *
+ * There are no alignment restrictions when using XTemac_FifoRead() and
+ * XTemac_FifoWrite().
+ *
+ * <b>Buffer Copying</b>
+ *
+ * The driver is designed for a zero-copy buffer scheme. That is, the driver will
+ * not copy buffers. This avoids potential throughput bottlenecks within the
+ * driver.
+ *
+ * The only exception to this is when buffers are passed to XTemac_FifoRead() and
+ * XTemac_FifoWrite() on 1, 2, or 3 byte alignments. These buffers will be byte
+ * copied into a small holding area on their way to or from the packet FIFOs.
+ * For PLB TEMAC this holding area is 8 bytes each way. If byte copying is
+ * required, then the transfer will take longer to complete.
+ *
+ * <b>PHY Communication</b>
+ *
+ * Prior to PHY access, the MDIO clock must be setup. This driver will set a
+ * safe default that should work with PLB bus speeds of up to 150 MHz and keep
+ * the MDIO clock below 2.5 MHz. If the user wishes faster access to the PHY
+ * then the clock divisor can be set to a different value (see
+ * XTemac_PhySetMdioDivisor()).
+ *
+ * MII register access is performed through the functions XTemac_PhyRead() and
+ * XTemac_PhyWrite().
+ *
+ * <b>Link Sync</b>
+ *
+ * When the device is used with MII or GMII, the link speed must be explicitly
+ * set using XTemac_SetMiiLinkSpeed() and must match the speed the PHY has
+ * negotiated. If the speeds are mismatched, then the MAC will not pass traffic.
+ *
+ * The default duplex is full. On half duplex links, the XTE_HALF_DUPLEX_OPTION
+ * must be set.
+ *
+ * <b>Asserts</b>
+ *
+ * Asserts are used within all Xilinx drivers to enforce constraints on argument
+ * values. Asserts can be turned off on a system-wide basis by defining, at
+ * compile time, the NDEBUG identifier. By default, asserts are turned on and it
+ * is recommended that users leave asserts on during development.
+ *
+ * <b>Driver Errata</b>
+ *
+ * The following features did not make this release due to absense of or
+ * problems with HW:
+ *   - DCR based access to host interface registers.
+ *   - Retrieval of hard statistics counters.
+ *   - Multicast receive address filtering.
+ *   - Mii access to PHY. API functions always return XST_NO_FEATURE.
+ *
+ * Other issues:
+ *   - Setting XTE_FCS_STRIP_OPTION will cause data corruption due to HW
+ *     bugs. By default, this driver will disable the option. Future versions
+ *     with operational HW will enable this option by default.
+ *   - A dropped receive frame indication may be reported by the driver after
+ *     calling XTemac_Stop() followed by XTemac_Start(). This can occur if a
+ *     frame is arriving when stop is called.
+ *
+ * @note
+ *
+ * Xilinx drivers are typically composed of two components, one is the driver
+ * and the other is the adapter.  The driver is independent of OS and processor
+ * and is intended to be highly portable.  The adapter is OS-specific and
+ * facilitates communication between the driver and an OS.
+ * <br><br>
+ * This driver is intended to be RTOS and processor independent. Any needs for
+ * dynamic memory management, threads or thread mutual exclusion, or cache
+ * control must be satisfied by the layer above this driver.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a rmm  06/01/05 First release
+ * </pre>
+ *
+ *****************************************************************************/
+
+#ifndef XTEMAC_H		/* prevent circular inclusions */
+#define XTEMAC_H		/* by using protection macros */
+
+/***************************** Include Files *********************************/
+
+#include <asm/delay.h>
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xparameters.h"
+#include "xipif_v1_23_b.h"
+#include "xpacket_fifo_v2_00_a.h"
+#include "xdmav2.h"
+#include "xtemac_l.h"
+
+/************************** Constant Definitions *****************************/
+
+/*
+ * Device information
+ */
+#define XTE_DEVICE_NAME     "xtemac"
+#define XTE_DEVICE_DESC     "Xilinx Tri-speed 10/100/1000 MAC"
+
+/** @name Configuration options
+ *
+ * Device configuration options. See the XTemac_SetOptions(),
+ * XTemac_ClearOptions() and XTemac_GetOptions() for information on how to use
+ * options.
+ *
+ * The default state of the options are noted and are what the device and driver
+ * will be set to after calling XTemac_Reset() or XTemac_Initialize().
+ *
+ * @{
+ */
+
+#define XTE_PROMISC_OPTION               0x00000001
+/**< Accept all incoming packets.
+ *   This option defaults to disabled (cleared) */
+
+#define XTE_JUMBO_OPTION                 0x00000002
+/**< Jumbo frame support for Tx & Rx.
+ *   This option defaults to disabled (cleared) */
+
+#define XTE_VLAN_OPTION                  0x00000004
+/**< VLAN Rx & Tx frame support.
+ *   This option defaults to disabled (cleared) */
+
+#define XTE_HALF_DUPLEX_OPTION           0x00000008
+/**< Half duplex mode for Tx & Rx.
+ *   This option defaults to full duplex (cleared) */
+
+#define XTE_FLOW_CONTROL_OPTION          0x00000010
+/**< Enable recognition of flow control frames on Rx
+ *   This option defaults to enabled (set) */
+
+#define XTE_FCS_STRIP_OPTION             0x00000020
+/**< Strip FCS and PAD from incoming frames. Note: PAD from VLAN frames is not
+ *   stripped.
+ *   This option defaults to disabled (clear) */
+
+#define XTE_FCS_INSERT_OPTION            0x00000040
+/**< Generate FCS field and add PAD automatically for outgoing frames.
+ *   This option defaults to enabled (set) */
+
+#define XTE_LENTYPE_ERR_OPTION           0x00000080
+/**< Enable Length/Type error checking for incoming frames. When this option is
+ *   set, the MAC will filter frames that have a mismatched type/length field
+ *   and if XTE_REPORT_RXERR_OPTION is set, the user is notified when these
+ *   types of frames are encountered. When this option is cleared, the MAC will
+ *   allow these types of frames to be received.
+ *
+ *   This option defaults to enabled (set) */
+
+#define XTE_SGEND_INT_OPTION             0x00000100
+/**< Enable the SGEND interrupt with SG DMA. When enabled, an interrupt will
+ *   be triggered when the end of the buffer descriptor list is reached. The
+ *   interrupt will occur despite interrupt coalescing settings.
+ *   This option defaults to disabled (cleared) */
+
+#define XTE_POLLED_OPTION                0x00000200
+/**< Polled mode communications. Enables use of XTemac_FifoQuerySendStatus()
+ *   and XTemac_FifoQueryRecvStatus(). Users may enter/exit polled mode
+ *   from any interrupt driven mode.
+ *   This option defaults to disabled (cleared) */
+
+#define XTE_REPORT_RXERR_OPTION          0x00000400
+/**< Enable reporting of dropped receive packets due to errors
+ *   This option defaults to enabled (set) */
+
+#define XTE_TRANSMITTER_ENABLE_OPTION    0x00000800
+/**< Enable the transmitter.
+ *   This option defaults to enabled (set) */
+
+#define XTE_RECEIVER_ENABLE_OPTION       0x00001000
+/**< Enable the receiver
+ *   This option defaults to enabled (set) */
+
+#define XTE_BROADCAST_OPTION             0x00002000
+/**< Allow reception of the broadcast address
+ *   This option defaults to enabled (set) */
+
+#define XTE_MULTICAST_CAM_OPTION         0x00004000
+/**< Allows reception of multicast addresses programmed into CAM
+ *   This option defaults to disabled (clear)
+ *   Note: this option has no HW support in this release
+ */
+
+#define XTE_REPORT_TXSTATUS_OVERRUN_OPTION 0x00008000
+/**< Enable reporting the overrun of the Transmit status FIFO. This type of
+ *   error is latched by HW and can be cleared only by a reset. SGDMA systems,
+ *   this option should be enabled since the DMA engine is responsible for
+ *   keeping this from occurring. For simple DMA, or FIFO direct systems,
+ *   this error may be a nuisance because a SW system may be able to transmit
+ *   frames faster than the interrupt handler can handle retrieving statuses.
+ *   This option defaults to enabled (set) */
+
+#define XTE_DEFAULT_OPTIONS                     \
+    (XTE_FLOW_CONTROL_OPTION |                  \
+     XTE_BROADCAST_OPTION |                     \
+     XTE_FCS_INSERT_OPTION |                    \
+     XTE_LENTYPE_ERR_OPTION |                   \
+     XTE_TRANSMITTER_ENABLE_OPTION |            \
+     XTE_REPORT_RXERR_OPTION |                  \
+     XTE_REPORT_TXSTATUS_OVERRUN_OPTION |       \
+     XTE_RECEIVER_ENABLE_OPTION)
+/**< Default options set when device is initialized or reset */
+
+/*@}*/
+
+/** @name Direction identifiers
+ *
+ *  These are used by several functions and callbacks that need
+ *  to specify whether an operation specifies a send or receive channel.
+ * @{
+ */
+#define XTE_SEND    1
+#define XTE_RECV    2
+/*@}*/
+
+/** @name XTemac_FifoWrite/Read() function arguments
+ *
+ *  These are used by XTemac_FifoWrite/Read() End Of Packet (Eop)
+ *  parameter.
+ * @{
+ */
+#define XTE_END_OF_PACKET   1	/**< The data written is the last for the
+                                  *  current packet */
+#define XTE_PARTIAL_PACKET  0	/**< There is more data to come for the
+                                  *  current packet */
+/*@}*/
+
+/** @name Callback identifiers
+ *
+ * These constants are used as parameters to XTemac_SetHandler()
+ * @{
+ */
+#define XTE_HANDLER_FIFOSEND     1
+#define XTE_HANDLER_FIFORECV     2
+#define XTE_HANDLER_FIFODMAWRITE 3
+#define XTE_HANDLER_FIFODMAREAD  4
+#define XTE_HANDLER_SGSEND       5
+#define XTE_HANDLER_SGRECV       6
+#define XTE_HANDLER_ERROR        7
+/*@}*/
+
+/* Constants to determine the configuration of the hardware device. They are
+ * used to allow the driver to verify it can operate with the hardware.
+ */
+#define XTE_CFG_NO_DMA              1	/* No DMA */
+#define XTE_CFG_SIMPLE_DMA          2	/* Simple DMA */
+#define XTE_CFG_DMA_SG              3	/* DMA scatter gather */
+
+#define XTE_MULTI_CAM_ENTRIES       4	/* Number of storable addresses in
+					   the CAM */
+
+#define XTE_MDIO_DIV_DFT            29	/* Default MDIO clock divisor */
+
+/* Some default values for interrupt coalescing within the scatter-gather
+ * DMA engine.
+ */
+#define XTE_SGDMA_DFT_THRESHOLD     1	/* Default pkt threshold */
+#define XTE_SGDMA_MAX_THRESHOLD     1023	/* Maximum pkt theshold */
+#define XTE_SGDMA_DFT_WAITBOUND     0	/* Default pkt wait bound (msec) */
+#define XTE_SGDMA_MAX_WAITBOUND     1023	/* Maximum pkt wait bound (msec) */
+
+/* The next few constants help upper layers determine the size of memory
+ * pools used for Ethernet buffers and descriptor lists.
+ */
+#define XTE_MAC_ADDR_SIZE   6	/* six-byte MAC address */
+#define XTE_MTU             1500	/* max MTU size of Ethernet frame */
+#define XTE_JUMBO_MTU       8982	/* max MTU size of jumbo Ethernet frame */
+#define XTE_HDR_SIZE        14	/* size of Ethernet header */
+#define XTE_HDR_VLAN_SIZE   18	/* size of Ethernet header with VLAN */
+#define XTE_TRL_SIZE        4	/* size of Ethernet trailer (FCS) */
+#define XTE_MAX_FRAME_SIZE       (XTE_MTU + XTE_HDR_SIZE + XTE_TRL_SIZE)
+#define XTE_MAX_VLAN_FRAME_SIZE  (XTE_MTU + XTE_HDR_VLAN_SIZE + XTE_TRL_SIZE)
+#define XTE_MAX_JUMBO_FRAME_SIZE (XTE_JUMBO_MTU + XTE_HDR_SIZE + XTE_TRL_SIZE)
+
+/* Constant values returned by XTemac_GetMediaInterface() */
+#define XTE_MII_TYPE_MII         0
+#define XTE_MII_TYPE_GMII        1
+#define XTE_MII_TYPE_SGMII       2
+#define XTE_MII_TYPE_RGMII       3
+
+/* Constant values returned by XTemac_GetRgmiiStatus() */
+#define XTE_RGMII_LINK_DOWN      0
+#define XTE_RGMII_LINK_UP        1
+#define XTE_RGMII_DUPLEX_HALF    0
+#define XTE_RGMII_DUPLEX_FULL    1
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * Statistics maintained by the driver
+ */
+typedef struct {
+	u32 TxDmaErrors; /**< Number of Tx DMA errors detected */
+	u32 TxPktFifoErrors;
+			 /**< Number of Tx packet FIFO errors detected */
+	u32 TxStatusErrors;
+			 /**< Number of Tx errors derived from XTE_TSR_OFFSET
+                                  register */
+	u32 RxRejectErrors;
+			 /**< Number of frames discarded due to errors */
+	u32 RxDmaErrors; /**< Number of Rx DMA errors detected */
+	u32 RxPktFifoErrors;
+			 /**< Number of Rx packet FIFO errors detected */
+
+	u32 FifoErrors;	 /**< Number of length/status FIFO errors detected */
+	u32 IpifErrors;	 /**< Number of IPIF transaction and data phase errors
+                                  detected */
+	u32 Interrupts;	 /**< Number of interrupts serviced */
+} XTemac_SoftStats;
+
+/**
+ * This typedef contains configuration information for a device.
+ */
+typedef struct {
+	u16 DeviceId;	/**< Unique ID  of device */
+	u32 BaseAddress;/**< Physical base address of IPIF registers */
+	u32 RxPktFifoDepth;
+			/**< Depth of receive packet FIFO in bits */
+	u32 TxPktFifoDepth;
+			/**< Depth of transmit packet FIFO in bits */
+	u16 MacFifoDepth;
+			/**< Depth of the status/length FIFOs in entries */
+	u8 IpIfDmaConfig;
+			/**< IPIF/DMA hardware configuration */
+	u8 DcrHost;	/**< Does device use DCR bus for host access */
+	u8 Dre;		/**< Has data realignment engine */
+} XTemac_Config;
+
+/* This type encapsulates a packet FIFO channel and support attributes to
+ * allow unaligned data transfers.
+ */
+typedef struct XTemac_PacketFifo {
+	u32 Hold[2];		/* Holding register */
+	unsigned ByteIndex;	/* Holding register index */
+	unsigned Width;		/* Width of packet FIFO's keyhole data port in
+				   bytes */
+	XPacketFifoV200a Fifo;	/* Packet FIFO channel */
+	/* Function used to transfer data between
+	   FIFO and a buffer */
+	 XStatus(*XferFn) (struct XTemac_PacketFifo * Fptr, void *BufPtr,
+			   u32 ByteCount, int Eop);
+} XTemac_PacketFifo;
+
+/** @name Typedefs for callback functions
+ *
+ * These callbacks are invoked in interrupt context.
+ * @{
+ */
+
+/**
+ * Callback invoked when frame(s) have been sent in interrupt driven FIFO
+ * direct or simple DMA mode. To set this callback, invoke XTemac_SetHander()
+ * with XTE_HANDLER_FIFOSEND in the HandlerType parameter.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ * @param StatusCnt is the number of statuses read from the device indicating
+ *        a successful frame transmit.
+ *
+ */
+typedef void (*XTemac_FifoSendHandler) (void *CallBackRef, unsigned StatusCnt);
+
+/**
+ * Callback invoked when frame(s) have been received in interrupt driven FIFO
+ * direct mode. To set this callback, invoke XTemac_SetHander() with
+ * XTE_HANDLER_FIFORECV in the HandlerType parameter.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ *
+ */
+typedef void (*XTemac_FifoRecvHandler) (void *CallBackRef);
+
+/**
+ * Callback invoked when a DMA write operation to the transmit packet FIFO has
+ * completed successfully.
+ *
+ * To set this callback, invoke XTemac_SetHander() with XTE_HANDLER_FIFODMAWRITE
+ * in the HandlerType parameter.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ * @param ByteCount is the number of bytes written as specified in the last call
+ *        to XTemac_FifoDmaWrite()
+ */
+typedef void (*XTemac_FifoDmaWriteHandler) (void *CallBackRef, u32 ByteCount);
+
+/**
+ * Callback invoked when a DMA read operation from the receive packet FIFO has
+ * completed successfully.
+ *
+ * To set this callback, invoke XTemac_SetHander() with
+ * XTE_HANDLER_FIFODMAREAD in the HandlerType parameter.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ * @param ByteCount is the number of bytes read as specified in the last call
+ *        to XTemac_FifoDmaRead()
+ */
+typedef void (*XTemac_FifoDmaReadHandler) (void *CallBackRef, u32 ByteCount);
+
+/**
+ * Callback invoked when frame(s) have been sent or received in interrupt
+ * driven SGDMA mode. To set the send callback, invoke XTemac_SetHandler()
+ * with XTE_HANDLER_SGSEND in the HandlerType parameter. For the receive
+ * callback use XTE_HANDLER_SGRECV.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ */
+typedef void (*XTemac_SgHandler) (void *CallBackRef);
+
+/**
+ * Callback when an asynchronous error occurs. To set this callback, invoke
+ * XTemac_SetHandler() with XTE_HANDLER_ERROR in the HandlerType paramter.
+ *
+ * @param CallBackRef is user data assigned when the callback was set.
+ * @param ErrorClass defines what class of error is being reported
+ * @param ErrorWord1 definition varies with ErrorClass
+ * @param ErrorWord2 definition varies with ErrorClass
+ *
+ * The following information lists what each ErrorClass is, the source of the
+ * ErrorWords, what they mean, and if the device should be reset should it be
+ * reported
+ *
+ * <b>ErrorClass == XST_FIFO_ERROR</b>
+ *
+ * This error class means there was an overrun or underrun associated
+ * with one of the status or length FIFOs. This type of error cannot
+ * be cleared. The user should initiate a device reset.
+ *
+ * ErrorWord1 is defined as a bit mask from XTE_IPXR_FIFO_FATAL_ERROR_MASK
+ * that originates from the device's IPISR register.
+ *
+ * ErrorWord2 is reserved.
+ *
+ *
+ * <b>ErrorClass == XST_PFIFO_DEADLOCK</b>
+ *
+ * This error class indicates that one of the packet FIFOs is reporting a
+ * deadlock condition. This means the FIFO is reporting that it is empty and
+ * full at the same time. This condition will occur when data being written
+ * exceeds the capacity of the packet FIFO. The device should be reset if this
+ * error is reported.
+ *
+ * If ErrorWord1 = XTE_RECV, then the deadlock occurred in the receive channel.
+ * If ErrorWord1 = XTE_SEND, then the deadlock occurred in the send channel.
+ *
+ * ErrorWord2 is reserved.
+ *
+ *
+ * <b>ErrorClass == XST_IPIF_ERROR</b>
+ *
+ * This error means that a register read or write caused a bus error within the
+ * TEMAC's IPIF. This condition is fatal. The user should initiate a device
+ * reset.
+ *
+ * ErrorWord1 is defined as the contents XTE_DISR_OFFSET register where these
+ * errors are reported. Bits XTE_DXR_DPTO_MASK and XTE_DXR_TERR_MASK are
+ * relevent in this context.
+ *
+ * ErrorWord2 is reserved.
+ *
+ *
+ * <b>ErrorClass == XST_DMA_ERROR</b>
+ *
+ * This error class means there was a problem during a DMA tranfer.
+ *
+ * ErrorWord1 defines which channel caused the error XTE_RECV or XTE_SEND.
+ *
+ * ErrorWord2 is set to the DMA status register XDC_DMAS_REG_OFFSET (see
+ * xdma_channel_i.h). The relevent bits to test are XDC_DMASR_BUS_ERROR_MASK
+ * and XDC_DMASR_BUS_TIMEOUT_MASK (see xdma_channel.h). If either of these bits
+ * are set, a reset is recommended.
+ *
+ *
+ * <b>ErrorClass == XST_SEND_ERROR</b>
+ *
+ * This error class means there was an error during packet transmission.
+ *
+ * For SGDMA, this class of error is not reported. The status of a transmit is
+ * stored in the device status field of BDs (which is in itself a copy of the
+ * XTE_TSR_OFFSET register - see ErrorWord1). It is the user's responsibility
+ * to examine this status in their XTE_HANDLER_SGSEND callback.
+ *
+ * ErrorWord1 is set to the transmit status word provided by the hardware
+ * (XTE_TSR_OFFSET). Most of the time, none of the bits set in this word
+ * should be considered a fatal condition requiring reset. Most errors are
+ * due to line conditions, but if XTE_TSR_PFIFOU_MASK is set, then the
+ * packet FIFO ran out of data before the packet could get out. This will
+ * occur if XTemac_FifoSend() specifies more data that is currenly in the
+ * packet FIFO. For SGDMA, this bit being set in the BD's device status field
+ * indicates a HW glitch has occurred. In this case, a reset is recommended.
+ *
+ * ErrorWord2 is reserved.
+ *
+ *
+ * <b>ErrorClass == XST_RECV_ERROR</b>
+ *
+ * This error class means a packet was dropped.
+ *
+ * ErrorWord1 is defined as the contents of the device's XTE_IPISR_OFFSET
+ * relating to receive errors. If any bit is set in the
+ * XTE_IPXR_RECV_DROPPED_MASK then a packet was rejected. Refer to xtemac_l.h
+ * for more information on what each bit in this mask means.
+ *
+ * ErrorWord2 is reserved.
+ *
+ * No action is typically required when this error occurs.
+ *
+ * Reporting of this error class can be disabled by clearing the
+ * XTE_REPORT_RXERR_OPTION.
+ *
+ * @note
+ * See xtemac_l.h for bitmasks definitions and the device hardware spec for
+ * further information on their meaning.
+ *
+ */
+typedef void (*XTemac_ErrorHandler) (void *CallBackRef, XStatus ErrorClass,
+				     u32 ErrorWord1, u32 ErrorWord2);
+/*@}*/
+
+/**
+ * The XTemac driver instance data. The user is required to allocate a
+ * structure of this type for every TEMAC device in the system. A pointer
+ * to a structure of this type is then passed to the driver API functions.
+ */
+typedef struct XTemac {
+	u32 BaseAddress;	/* Base address of IPIF register set */
+	u32 IsStarted;		/* Device is currently started */
+	u32 IsReady;		/* Device is initialized and ready */
+	u32 IsPolled;		/* Device is in polled mode */
+	u32 Options;		/* Current options word */
+	u32 Flags;		/* Internal driver flags */
+	XTemac_Config *Config;	/* Points to configuration entry
+				   in xtemac_g.c */
+
+	/* Packet FIFO channels */
+	XTemac_PacketFifo RecvFifo;	/* Receive channel */
+	XTemac_PacketFifo SendFifo;	/* Transmit channel */
+
+	/* Simple DMA / SG DMA channels */
+	XDmaV2 RecvDma;		/* Receive channel */
+	XDmaV2 SendDma;		/* Transmit channel */
+
+	/* Callbacks for FIFO direct modes */
+	XTemac_FifoRecvHandler FifoRecvHandler;
+	XTemac_FifoSendHandler FifoSendHandler;
+	void *FifoRecvRef;
+	void *FifoSendRef;
+
+	/* Callbacks for simple DMA mode */
+	XTemac_FifoDmaReadHandler FifoDmaReadHandler;
+	XTemac_FifoDmaWriteHandler FifoDmaWriteHandler;
+	void *FifoDmaReadRef;
+	void *FifoDmaWriteRef;
+	u32 DmaReadLengthRef;
+	u32 DmaWriteLengthRef;
+
+	/* Callbacks for SG DMA mode */
+	XTemac_SgHandler SgRecvHandler;
+	XTemac_SgHandler SgSendHandler;
+	void *SgRecvRef;
+	void *SgSendRef;
+
+	/* Error callback */
+	XTemac_ErrorHandler ErrorHandler;
+	void *ErrorRef;
+
+	/* Driver maintained statistics */
+	XTemac_SoftStats Stats;
+
+} XTemac;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device thinks it has received a frame. This
+* function is useful if the device is operating in FIFO direct interrupt driven
+* mode. For polled mode, use XTemac_FifoQueryRecvStatus().
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device interrupt status register reports that a frame
+* status and length is available. FALSE otherwise.
+*
+* @note
+*
+* Signature: u32 XTemac_mIsRecvFrame(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsRecvFrame(InstancePtr)                            \
+    ((XTemac_mReadReg((InstancePtr)->BaseAddress, XTE_IPISR_OFFSET) \
+      & XTE_IPXR_RECV_DONE_MASK) ? TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device thinks it has dropped a receive frame.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device interrupt status register reports that a frame
+* has been dropped. FALSE otherwise.
+*
+* @note
+*
+* Signature: u32 XTemac_mIsRecvFrame(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsRecvFrameDropped(InstancePtr)                     \
+    ((XTemac_mReadReg((InstancePtr)->BaseAddress, XTE_IPISR_OFFSET) \
+      & XTE_IPXR_RECV_REJECT_MASK) ? TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device is currently configured for
+* scatter-gather DMA.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device is configured for scatter-gather DMA, or FALSE
+* if it is not.
+*
+* @note
+*
+* Signature: u32 XTemac_mIsSgDma(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsSgDma(InstancePtr) \
+    (((InstancePtr)->Config->IpIfDmaConfig == XTE_CFG_DMA_SG) ? TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device is currently configured for simple DMA.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device is configured for simple DMA, or FALSE otherwise
+*
+* @note
+*
+* Signature: u32 XTemac_mIsSimpleDma(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsSimpleDma(InstancePtr) \
+    (((InstancePtr)->Config->IpIfDmaConfig == XTE_CFG_SIMPLE_DMA) ? TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device is currently configured with DMA (either
+* simple DMA or scatter-gather DMA)
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device is configured with DMA, or FALSE otherwise
+*
+* @note
+*
+* Signature: u32 XTemac_mIsDma(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsDma(InstancePtr)                              \
+    ((XTemac_mIsSimpleDma(InstancePtr) == TRUE ||              \
+      XTemac_mIsSgDma(InstancePtr) == TRUE) ? TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* This macro determines if the device is configured with the Data Realignment
+* Engine (DRE)
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+*
+* @return
+*
+* Boolean TRUE if the device is configured with DRE, or FALSE otherwise.
+* Note that version 1.00a has no DRE capability so this macro always returns
+* FALSE.
+*
+* @note
+*
+* Signature: u32 XTemac_mIsDre(XTemac *InstancePtr)
+*
+******************************************************************************/
+#define XTemac_mIsDre(InstancePtr) (((InstancePtr)->Config->Dre) ?      \
+                                    TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+*
+* Return the next buffer descriptor in the list on the send channel.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+* @param BdPtr is the source descriptor
+*
+* @return Next descriptor in the SGDMA transmit ring (i.e. BdPtr->Next)
+*
+* @note
+*
+* Signature: XDmaBdV2 XTemac_mSgSendBdNext(XTemac *InstancePtr,
+*                                          XDmaBdV2 *BdPtr)
+*
+******************************************************************************/
+#define XTemac_mSgSendBdNext(InstancePtr, BdPtr)        \
+    XDmaV2_mSgBdNext(&(InstancePtr)->SendDma, BdPtr)
+
+/*****************************************************************************/
+/**
+*
+* Return the next buffer descriptor in the list on the receive channel.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+* @param BdPtr is the source descriptor
+*
+* @return Next descriptor in the SGDMA receive ring (i.e. BdPtr->Next)
+*
+* @note
+*
+* Signature: XDmaBdV2 XTemac_mSgSendBdNext(XTemac *InstancePtr,
+*                                          XDmaBdV2 *BdPtr)
+*
+******************************************************************************/
+#define XTemac_mSgRecvBdNext(InstancePtr, BdPtr)        \
+    XDmaV2_mSgBdNext(&(InstancePtr)->RecvDma, BdPtr)
+
+/************************** Function Prototypes ******************************/
+
+/*
+ * Initialization functions in xtemac.c
+ */
+XStatus XTemac_Initialize(XTemac * InstancePtr, u16 DeviceId);
+XStatus XTemac_VmInitialize(XTemac * InstancePtr, u16 DeviceId,
+			    u32 VirtualAddress);
+XStatus XTemac_Start(XTemac * InstancePtr);
+void XTemac_Stop(XTemac * InstancePtr);
+void XTemac_Reset(XTemac * InstancePtr);
+XTemac_Config *XTemac_LookupConfig(u16 DeviceId);
+
+/*
+ * Fifo direct mode functions implemented in xtemac_fifo.c
+ */
+XStatus XTemac_FifoWrite(XTemac * InstancePtr, void *BufPtr, u32 ByteCount,
+			 int Eop);
+XStatus XTemac_FifoDmaWrite(XTemac * InstancePtr, XDmaBdV2 * BdPtr);
+XStatus XTemac_FifoSend(XTemac * InstancePtr, u32 TxByteCount);
+
+XStatus XTemac_FifoRecv(XTemac * InstancePtr, u32 * ByteCountPtr);
+XStatus XTemac_FifoRead(XTemac * InstancePtr, void *BufPtr, u32 ByteCount,
+			int Eop);
+XStatus XTemac_FifoDmaRead(XTemac * InstancePtr, XDmaBdV2 * BdPtr);
+u32 XTemac_FifoGetFreeBytes(XTemac * InstancePtr, u32 Direction);
+
+XStatus XTemac_FifoQuerySendStatus(XTemac * InstancePtr, u32 * SendStatusPtr);
+XStatus XTemac_FifoQueryRecvStatus(XTemac * InstancePtr);
+
+/*
+ * Interrupt management functions for FIFO direct mode implemented in
+ * xtemac_intr_fifo.c.
+ */
+void XTemac_IntrFifoEnable(XTemac * InstancePtr, u32 Direction);
+void XTemac_IntrFifoDisable(XTemac * InstancePtr, u32 Direction);
+void XTemac_IntrFifoDmaEnable(XTemac * InstancePtr, u32 Direction);
+void XTemac_IntrFifoDmaDisable(XTemac * InstancePtr, u32 Direction);
+extern void XTemac_IntrFifoHandler(void *InstancePtr);
+
+/*
+ * SG DMA mode functions implemented in xtemac_sgdma.c
+ */
+XStatus XTemac_SgAlloc(XTemac * InstancePtr, u32 Direction,
+		       unsigned NumBd, XDmaBdV2 ** BdPtr);
+XStatus XTemac_SgCommit(XTemac * InstancePtr, u32 Direction,
+			unsigned NumBd, XDmaBdV2 * BdPtr);
+unsigned XTemac_SgGetProcessed(XTemac * InstancePtr, u32 Direction,
+			       unsigned NumBd, XDmaBdV2 ** BdPtr);
+XStatus XTemac_SgFree(XTemac * InstancePtr, u32 Direction,
+		      unsigned NumBd, XDmaBdV2 * BdPtr);
+
+XStatus XTemac_SgCheck(XTemac * InstancePtr, u32 Direction);
+
+XStatus XTemac_SgSetSpace(XTemac * InstancePtr, u32 Direction,
+			  u32 PhysicalAddr, u32 VirtualAddr,
+			  u32 Alignment, unsigned BdCount,
+			  XDmaBdV2 * BdTemplate);
+
+/*
+ * Interrupt management functions for SG DMA mode implemented in
+ * xtemac_intr_sgdma.c
+ */
+void XTemac_IntrSgEnable(XTemac * InstancePtr, u32 Direction);
+void XTemac_IntrSgDisable(XTemac * InstancePtr, u32 Direction);
+XStatus XTemac_IntrSgCoalSet(XTemac * InstancePtr, u32 Direction,
+			     u16 Threshold, u16 Timer);
+XStatus XTemac_IntrSgCoalGet(XTemac * InstancePtr, u32 Direction,
+			     u16 * ThresholdPtr, u16 * TimerPtr);
+
+extern void XTemac_IntrSgHandler(void *TemacPtr);
+
+/*
+ * General interrupt-related functions in xtemac_intr.c
+ */
+XStatus XTemac_SetHandler(XTemac * InstancePtr, u32 HandlerType,
+			  void *CallbackFunc, void *CallbackRef);
+
+/*
+ * MAC configuration/control functions in xtemac_control.c
+ */
+XStatus XTemac_SetOptions(XTemac * InstancePtr, u32 Options);
+XStatus XTemac_ClearOptions(XTemac * InstancePtr, u32 Options);
+u32 XTemac_GetOptions(XTemac * InstancePtr);
+
+XStatus XTemac_SetMacAddress(XTemac * InstancePtr, void *AddressPtr);
+void XTemac_GetMacAddress(XTemac * InstancePtr, void *AddressPtr);
+
+XStatus XTemac_SetMacPauseAddress(XTemac * InstancePtr, void *AddressPtr);
+void XTemac_GetMacPauseAddress(XTemac * InstancePtr, void *AddressPtr);
+XStatus XTemac_SendPausePacket(XTemac * InstancePtr, u16 PauseValue);
+
+void XTemac_SetIfg(XTemac * InstancePtr, u8 AdditionalIfg);
+u8 XTemac_GetIfg(XTemac * InstancePtr);
+
+void XTemac_GetPhysicalInterface(XTemac * InstancePtr, u8 * MiiType,
+				 u32 * Is1000BaseX);
+XStatus XTemac_GetRgmiiStatus(XTemac * InstancePtr, u8 * LinkPtr,
+			      u8 * DuplexPtr);
+u16 XTemac_GetLinkSpeed(XTemac * InstancePtr);
+XStatus XTemac_SetMiiLinkSpeed(XTemac * InstancePtr, u16 Speed);
+
+void XTemac_PhySetMdioDivisor(XTemac * InstancePtr, u8 Divisor);
+XStatus XTemac_PhyRead(XTemac * InstancePtr, u32 PhyAddress,
+		       u32 RegisterNum, u16 * PhyDataPtr);
+XStatus XTemac_PhyWrite(XTemac * InstancePtr, u32 PhyAddress,
+			u32 RegisterNum, u16 PhyData);
+
+/*
+ * Statistics in xtemac_stats.c
+ */
+void XTemac_GetSoftStats(XTemac * InstancePtr, XTemac_SoftStats * StatsPtr);
+void XTemac_ClearSoftStats(XTemac * InstancePtr);
+
+/*
+ * Diagnostic functions in xtemac_selftest.c
+ */
+XStatus XTemac_SelfTest(XTemac * InstancePtr);
+
+#endif				/* end of protection macro */
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_control.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_control.c
@@ -0,0 +1,1091 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file xtemac_control.c
+ *
+ * Functions in this file implement general purpose command and control related
+ * functionality. See xtemac.h for a detailed description of the driver.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a rmm  06/01/05 First release
+ * </pre>
+ *****************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+ * Set the MAC address for this driver/device.  The address is a 48-bit value.
+ * The device must be stopped before calling this function.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param AddressPtr is a pointer to a 6-byte MAC address.
+ *
+ * @return
+ * - XST_SUCCESS if the MAC address was set successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ *
+ ******************************************************************************/
+XStatus XTemac_SetMacAddress(XTemac * InstancePtr, void *AddressPtr)
+{
+	u32 MacAddr;
+	u8 *Aptr = AddressPtr;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Be sure device has been stopped */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Set the MAC bits [31:0] in EUAW0 */
+	MacAddr = Aptr[0] & 0x000000FF;
+	MacAddr |= Aptr[1] << 8;
+	MacAddr |= Aptr[2] << 16;
+	MacAddr |= Aptr[3] << 24;
+	XTemac_mSetHostReg(XTE_EUAW0_OFFSET, MacAddr);
+
+	/* There are reserved bits in EUAW1 so don't affect them */
+	MacAddr = XTemac_mGetHostReg(XTE_EUAW1_OFFSET);
+	MacAddr &= ~XTE_EUAW1_MASK;
+
+	/* Set MAC bits [47:32] in EUAW1 */
+	MacAddr |= Aptr[4] & 0x000000FF;
+	MacAddr |= Aptr[5] << 8;
+	XTemac_mSetHostReg(XTE_EUAW1_OFFSET, MacAddr);
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Get the MAC address for this driver/device.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param AddressPtr is an output parameter, and is a pointer to a buffer into
+ *        which the current MAC address will be copied. The buffer must be at
+ *        least 6 bytes in length.
+ *
+ ******************************************************************************/
+void XTemac_GetMacAddress(XTemac * InstancePtr, void *AddressPtr)
+{
+	u32 MacAddr;
+	u8 *Aptr = AddressPtr;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Read MAC bits [31:0] in EUAW0 */
+	MacAddr = XTemac_mGetHostReg(XTE_EUAW0_OFFSET);
+	Aptr[0] = (u8) MacAddr;
+	Aptr[1] = (u8) (MacAddr >> 8);
+	Aptr[2] = (u8) (MacAddr >> 16);
+	Aptr[3] = (u8) (MacAddr >> 24);
+
+	/* Read MAC bits [47:32] in EUAW1 */
+	MacAddr = XTemac_mGetHostReg(XTE_EUAW1_OFFSET);
+	Aptr[4] = (u8) MacAddr;
+	Aptr[5] = (u8) (MacAddr >> 8);
+}
+
+/*****************************************************************************/
+/**
+ * Add an Ethernet address to the list that will be accepted by the receiver.
+ * The address may be any unicast, multicast, or the broadcast address form.
+ * Up to XTE_MULTI_CAM_ENTRIES addresses may be filtered in this way. The
+ * device must be stopped to use this function.
+ *
+ * Once an address is programmed, it will be received by the device. There is
+ * no control bit to disable multicast filtering. The only way to prevent a
+ * CAM address from being received is to clear it with XTemac_MulticastClear().
+ *
+ * @param InstancePtr is a pointer to the XTemac instance to be worked on.
+ * @param AddressPtr is a pointer to a 6-byte Ethernet address. The previous
+ *        address at this entry location (if any) is overwritten with the new
+ *        one.
+ * @param Entry is the storage location the HW uses to program this address.
+ *        It must be between 0..XTE_MULTI_CAM_ENTRIES-1.
+ *
+ * @return
+ *
+ * - XST_SUCCESS if the address was added successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ ******************************************************************************/
+#if 0				/* No HW support */
+XStatus XTemac_MulticastAdd(XTemac * InstancePtr, void *AddressPtr, int Entry)
+{
+	u32 Emaw0Reg;
+	u32 Emaw1Reg;
+	u8 *Aptr = (u8 *) AddressPtr;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(Entry < XTE_MULTI_CAM_ENTRIES);
+
+	/* The device must be stopped before clearing the multicast hash table */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Set MAC bits [31:0] */
+	Emaw0Reg = Aptr[0] & 0x000000FF;
+	Emaw0Reg |= Aptr[1] << 8;
+	Emaw0Reg |= Aptr[2] << 16;
+	Emaw0Reg |= Aptr[3] << 24;
+
+	/* Set MAC bits [47:32] */
+	Emaw1Reg = Aptr[4] & 0x000000FF;
+	Emaw1Reg |= Aptr[5] << 8;
+
+	/* Add in CAM address */
+	Emaw1Reg |= (Entry << XTE_EMAW1_CAMMADDR_SHIFT_MASK);
+
+	/* Program HW */
+	XTemac_mSetHostReg(XTE_EMAW0_OFFSET, Emaw0Reg);
+	XTemac_mSetHostReg(XTE_EMAW1_OFFSET, Emaw1Reg);
+
+	return (XST_SUCCESS);
+}
+#endif
+
+/*****************************************************************************/
+/**
+ * Retrieve an Ethernet address set by XTemac_MulticastAdd().
+ *
+ * @param InstancePtr is a pointer to the XTemac instance to be worked on.
+ * @param AddressPtr is an output parameter, and is a pointer to a buffer into
+ *        which the current MAC address will be copied. The buffer must be at
+ *        least 6 bytes in length.
+ * @param Entry is the storage location in the HW. It must be between
+ *        0..XTE_MULTI_CAM_ENTRIES-1.
+ *
+ * @return
+ *
+ * - XST_SUCCESS if the address was added successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ ******************************************************************************/
+#if 0				/* No HW support */
+void XTemac_MulticastGet(XTemac * InstancePtr, void *AddressPtr, int Entry)
+{
+	u32 Emaw0Reg;
+	u32 Emaw1Reg;
+	u8 *Aptr = AddressPtr;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(Entry < XTE_MULTI_CAM_ENTRIES);
+
+	/* Tell HW to provide address stored in given entry */
+	XTemac_mSetHostReg(XTE_EMAW1_OFFSET, XTE_EMAW1_CAMRNW_MASK |
+			   (Entry << XTE_EMAW1_CAMMADDR_SHIFT_MASK));
+
+	/* The HW should now have provided the CAM entry */
+	Emaw0Reg = XTemac_mGetHostReg(XTE_EMAW0_OFFSET);
+	Emaw1Reg = XTemac_mGetHostReg(XTE_EMAW1_OFFSET);
+
+	/* Copy the address to the user buffer */
+	Aptr[0] = (u8) Emaw0Reg;
+	Aptr[1] = (u8) (Emaw0Reg >> 8);
+	Aptr[2] = (u8) (Emaw0Reg >> 16);
+	Aptr[3] = (u8) (Emaw0Reg >> 24);
+	Aptr[4] = (u8) Emaw1Reg;
+	Aptr[5] = (u8) (Emaw1Reg >> 8);
+}
+#endif
+
+/*****************************************************************************/
+/**
+* Clear an address set by XTemac_MulticastAdd(). The device must be stopped
+* before calling this function.
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+* @param Entry is the HW storage location used when this address was added.
+*        It must be between 0..XTE_MULTI_CAM_ENTRIES-1.
+*
+* @return
+*
+* - XST_SUCCESS if the address was cleared
+* - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+*
+******************************************************************************/
+#if 0				/* No HW support */
+XStatus XTemac_MulticastClear(XTemac * InstancePtr, int Entry)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(Entry < XTE_MULTI_CAM_ENTRIES);
+
+	/* The device must be stopped before clearing the multicast hash table */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Clear the entry by writing 0:0:0:0:0:0 to it */
+	XTemac_mSetHostReg(XTE_EMAW0_OFFSET, 0);
+	XTemac_mSetHostReg(XTE_EMAW1_OFFSET,
+			   Entry << XTE_EMAW1_CAMMADDR_SHIFT_MASK);
+
+	return (XST_SUCCESS);
+}
+#endif
+
+/*****************************************************************************/
+/**
+ * Set the MAC address for pause frames. This is the address the device will
+ * recognize as pause frames. Pause frames transmitted with
+ * XTemac_SendPausePacket() will also use this address.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param AddressPtr is a pointer to a 6-byte MAC address.
+ *
+ * @return
+ * - XST_SUCCESS if the MAC address was set successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ *
+ ******************************************************************************/
+XStatus XTemac_SetMacPauseAddress(XTemac * InstancePtr, void *AddressPtr)
+{
+	u32 MacAddr;
+	u8 *Aptr = AddressPtr;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Be sure device has been stopped */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Set the MAC bits [31:0] in ERXC0 */
+	MacAddr = Aptr[0] & 0x000000FF;
+	MacAddr |= Aptr[1] << 8;
+	MacAddr |= Aptr[2] << 16;
+	MacAddr |= Aptr[3] << 24;
+	XTemac_mSetHostReg(XTE_ERXC0_OFFSET, MacAddr);
+
+	/* ERXC1 contains other info that must be preserved */
+	MacAddr = XTemac_mGetHostReg(XTE_ERXC1_OFFSET);
+	MacAddr &= ~XTE_ERXC1_ERXC1_MASK;;
+
+	/* Set MAC bits [47:32] */
+	MacAddr |= Aptr[4] & 0x000000FF;
+	MacAddr |= Aptr[5] << 8;
+	XTemac_mSetHostReg(XTE_ERXC1_OFFSET, MacAddr);
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Get the MAC address for pause frames for this driver/device.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param AddressPtr is an output parameter, and is a pointer to a buffer into
+ *        which the current MAC address will be copied. The buffer must be at
+ *        least 6 bytes in length.
+ *
+ ******************************************************************************/
+void XTemac_GetMacPauseAddress(XTemac * InstancePtr, void *AddressPtr)
+{
+	u32 MacAddr;
+	u8 *Aptr = AddressPtr;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Read MAC bits [31:0] in ERXC0 */
+	MacAddr = XTemac_mGetHostReg(XTE_ERXC0_OFFSET);
+	Aptr[0] = (u8) MacAddr;
+	Aptr[1] = (u8) (MacAddr >> 8);
+	Aptr[2] = (u8) (MacAddr >> 16);
+	Aptr[3] = (u8) (MacAddr >> 24);
+
+	/* Read MAC bits [47:32] in ERXC1 */
+	MacAddr = XTemac_mGetHostReg(XTE_ERXC1_OFFSET);
+	Aptr[4] = (u8) MacAddr;
+	Aptr[5] = (u8) (MacAddr >> 8);
+}
+
+/*****************************************************************************/
+/**
+ * Set options for the driver/device. The driver should be stopped with
+ * XTemac_Stop() before changing options.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Options are the options to set. Multiple options can be set by OR'ing
+ *        XTE_*_OPTIONS constants together. Options not specified are not
+ *        affected.
+ *
+ * @return
+ * - XST_SUCCESS if the options were set successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ *
+ * @note
+ * See xtemac.h for a description of the available options.
+ *
+ ******************************************************************************/
+XStatus XTemac_SetOptions(XTemac * InstancePtr, u32 Options)
+{
+	u32 Reg;		/* Generic register contents */
+	u32 RegErxc1;		/* Reflects original contents of ERXC1 */
+	u32 RegEtxc;		/* Reflects original contents of ETXC  */
+	u32 RegNewErxc1;	/* Reflects new contents of ERXC1 */
+	u32 RegNewEtxc;		/* Reflects new contents of ETXC  */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Be sure device has been stopped */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Many of these options will change the ERXC1 or ETXC registers.
+	 * To reduce the amount of IO to the device, group these options here
+	 * and change them all at once.
+	 */
+
+	/* Grab current register contents */
+	RegErxc1 = XTemac_mGetHostReg(XTE_ERXC1_OFFSET);
+	RegEtxc = XTemac_mGetHostReg(XTE_ETXC_OFFSET);
+	RegNewErxc1 = RegErxc1;
+	RegNewEtxc = RegEtxc;
+
+	/* Turn on jumbo packet support for both Rx and Tx */
+	if (Options & XTE_JUMBO_OPTION) {
+		RegNewEtxc |= XTE_ETXC_TXJMBO_MASK;
+		RegNewErxc1 |= XTE_ERXC1_RXJMBO_MASK;
+	}
+
+	/* Turn on VLAN packet support for both Rx and Tx */
+	if (Options & XTE_VLAN_OPTION) {
+		RegNewEtxc |= XTE_ETXC_TXVLAN_MASK;
+		RegNewErxc1 |= XTE_ERXC1_RXVLAN_MASK;
+	}
+
+	/* Turn on half duplex connectivity for both Rx and Tx */
+	if (Options & XTE_HALF_DUPLEX_OPTION) {
+		RegNewEtxc |= XTE_ETXC_TXHD_MASK;
+		RegNewErxc1 |= XTE_ERXC1_RXHD_MASK;
+	}
+
+	/* Turn on FCS stripping on receive packets */
+	if (Options & XTE_FCS_STRIP_OPTION) {
+		RegNewErxc1 &= ~XTE_ERXC1_RXFCS_MASK;
+	}
+
+	/* Turn on FCS insertion on transmit packets */
+	if (Options & XTE_FCS_INSERT_OPTION) {
+		RegNewEtxc &= ~XTE_ETXC_TXFCS_MASK;
+	}
+
+	/* Turn on length/type field checking on receive packets */
+	if (Options & XTE_LENTYPE_ERR_OPTION) {
+		RegNewErxc1 &= ~XTE_ERXC1_RXLT_MASK;
+	}
+
+	/* Officially change the ETXC or ERXC1 registers if they need to be
+	 * modified
+	 */
+	if (RegEtxc != RegNewEtxc) {
+		XTemac_mSetHostReg(XTE_ETXC_OFFSET, RegNewEtxc);
+	}
+
+	if (RegErxc1 != RegNewErxc1) {
+		XTemac_mSetHostReg(XTE_ERXC1_OFFSET, RegNewErxc1);
+	}
+
+	/* Rest of options twiddle bits of other registers. Handle them one at
+	 * a time
+	 */
+
+	/* Turn on flow control */
+	if (Options & XTE_FLOW_CONTROL_OPTION) {
+		Reg = XTemac_mGetHostReg(XTE_EFCC_OFFSET);
+		Reg |= XTE_EFCC_RXFLO_MASK;
+		XTemac_mSetHostReg(XTE_EFCC_OFFSET, Reg);
+	}
+
+	/* Turn on promiscuous frame filtering (all frames are received ) */
+	if (Options & XTE_PROMISC_OPTION) {
+		Reg = XTemac_mGetHostReg(XTE_EAFM_OFFSET);
+		Reg |= XTE_EAFM_EPPRM_MASK;
+		XTemac_mSetHostReg(XTE_EAFM_OFFSET, Reg);
+	}
+
+	/* Allow broadcast address filtering */
+	if (Options & XTE_BROADCAST_OPTION) {
+		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
+		Reg &= ~XTE_CR_BCREJ_MASK;
+		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
+	}
+
+	/* Allow multicast address filtering */
+	if (Options & XTE_MULTICAST_CAM_OPTION) {
+		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
+		Reg &= ~XTE_CR_MCREJ_MASK;
+		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
+	}
+
+	/* Enable interrupts related to rejection of bad frames */
+	if (Options & XTE_REPORT_RXERR_OPTION) {
+		/* Clear out any previous error conditions that may have existed
+		 * prior to enabling the reporting of these types of errors
+		 */
+		Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+				   Reg & XTE_IPXR_RECV_DROPPED_MASK);
+
+		/* Whether these are enabled here are based on the last call to
+		 * XTemac_IntrFifoEnable/Disable() and XTemac_IntrSgDmaEnable/Disable()
+		 * for the receive channel.
+		 *
+		 * If receive interrupts are enabled, then enable these interrupts. This
+		 * way, when XTemac_Start() is called, these interrupt enables take
+		 * effect right away.
+		 *
+		 * If receive interrupts are disabled, then don't do anything here. The
+		 * XTemac_IntrFifoEnable() and XTemac_IntrSgDmaEnable() functions when
+		 * called will check this option and enable these interrupts if needed.
+		 */
+		if (InstancePtr->Flags &
+		    (XTE_FLAGS_RECV_FIFO_INT_ENABLE |
+		     XTE_FLAGS_RECV_SGDMA_INT_ENABLE)) {
+			Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+			Reg |= XTE_IPXR_RECV_DROPPED_MASK;
+			XTemac_mSetIpifReg(XTE_IPIER_OFFSET, Reg);
+		}
+	}
+
+	/* The remaining options not handled here are managed elsewhere in the
+	 * driver. No register modifications are needed at this time. Reflecting the
+	 * option in InstancePtr->Options is good enough for now.
+	 */
+
+	/* Set options word to its new value */
+	InstancePtr->Options |= Options;
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Clear options for the driver/device
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Options are the options to clear. Multiple options can be cleared by
+ *        OR'ing XTE_*_OPTIONS constants together. Options not specified are not
+ *        affected.
+ *
+ * @return
+ * - XST_SUCCESS if the options were set successfully
+ * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
+ *
+ * @note
+ * See xtemac.h for a description of the available options.
+ *
+ ******************************************************************************/
+XStatus XTemac_ClearOptions(XTemac * InstancePtr, u32 Options)
+{
+	volatile u32 Reg;	/* Generic */
+	u32 RegErxc1;		/* Reflects original contents of ERXC1 */
+	u32 RegEtxc;		/* Reflects original contents of ETXC  */
+	u32 RegNewErxc1;	/* Reflects new contents of ERXC1 */
+	u32 RegNewEtxc;		/* Reflects new contents of ETXC  */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Be sure device has been stopped */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Many of these options will change the ERXC1 or ETXC registers.
+	 * Group these options here and change them all at once. What we are
+	 * trying to accomplish is to reduce the amount of IO to the device
+	 */
+
+	/* Grab current register contents */
+	RegErxc1 = XTemac_mGetHostReg(XTE_ERXC1_OFFSET);
+	RegEtxc = XTemac_mGetHostReg(XTE_ETXC_OFFSET);
+	RegNewErxc1 = RegErxc1;
+	RegNewEtxc = RegEtxc;
+
+	/* Turn off jumbo packet support for both Rx and Tx */
+	if (Options & XTE_JUMBO_OPTION) {
+		RegNewEtxc &= ~XTE_ETXC_TXJMBO_MASK;
+		RegNewErxc1 &= ~XTE_ERXC1_RXJMBO_MASK;
+	}
+
+	/* Turn off VLAN packet support for both Rx and Tx */
+	if (Options & XTE_VLAN_OPTION) {
+		RegNewEtxc &= ~XTE_ETXC_TXVLAN_MASK;
+		RegNewErxc1 &= ~XTE_ERXC1_RXVLAN_MASK;
+	}
+
+	/* Turn off half duplex connectivity for both Rx and Tx */
+	if (Options & XTE_HALF_DUPLEX_OPTION) {
+		RegNewEtxc &= ~XTE_ETXC_TXHD_MASK;
+		RegNewErxc1 &= ~XTE_ERXC1_RXHD_MASK;
+	}
+
+	/* Turn off FCS stripping on receive packets */
+	if (Options & XTE_FCS_STRIP_OPTION) {
+		RegNewErxc1 |= XTE_ERXC1_RXFCS_MASK;
+	}
+
+	/* Turn off FCS insertion on transmit packets */
+	if (Options & XTE_FCS_INSERT_OPTION) {
+		RegNewEtxc |= XTE_ETXC_TXFCS_MASK;
+	}
+
+	/* Turn off length/type field checking on receive packets */
+	if (Options & XTE_LENTYPE_ERR_OPTION) {
+		RegNewErxc1 |= XTE_ERXC1_RXLT_MASK;
+	}
+
+	/* Disable transmitter */
+	if (Options & XTE_TRANSMITTER_ENABLE_OPTION) {
+		RegNewEtxc &= ~XTE_ETXC_TXEN_MASK;
+	}
+
+	/* Disable receiver */
+	if (Options & XTE_RECEIVER_ENABLE_OPTION) {
+		RegNewErxc1 &= ~XTE_ERXC1_RXEN_MASK;
+	}
+
+	/* Officially change the ETXC or ERXC1 registers if they need to be
+	 * modified
+	 */
+	if (RegEtxc != RegNewEtxc) {
+		XTemac_mSetHostReg(XTE_ETXC_OFFSET, RegNewEtxc);
+	}
+
+	if (RegErxc1 != RegNewErxc1) {
+		XTemac_mSetHostReg(XTE_ERXC1_OFFSET, RegNewErxc1);
+	}
+
+	/* Rest of options twiddle bits of other registers. Handle them one at
+	 * a time
+	 */
+
+	/* Turn off flow control */
+	if (Options & XTE_FLOW_CONTROL_OPTION) {
+		Reg = XTemac_mGetHostReg(XTE_EFCC_OFFSET);
+		Reg &= ~XTE_EFCC_RXFLO_MASK;
+		XTemac_mSetHostReg(XTE_EFCC_OFFSET, Reg);
+	}
+
+	/* Turn off promiscuous frame filtering */
+	if (Options & XTE_PROMISC_OPTION) {
+		Reg = XTemac_mGetHostReg(XTE_EAFM_OFFSET);
+		Reg &= ~XTE_EAFM_EPPRM_MASK;
+		XTemac_mSetHostReg(XTE_EAFM_OFFSET, Reg);
+	}
+
+	/* Disable broadcast address filtering */
+	if (Options & XTE_BROADCAST_OPTION) {
+		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
+		Reg |= XTE_CR_BCREJ_MASK;
+		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
+	}
+
+	/* Disable multicast address filtering */
+	if (Options & XTE_MULTICAST_CAM_OPTION) {
+		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
+		Reg |= XTE_CR_MCREJ_MASK;
+		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
+	}
+
+	/* Disable interrupts related to rejection of bad frames */
+	if (Options & XTE_REPORT_RXERR_OPTION) {
+		Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+		Reg &= ~XTE_IPXR_RECV_DROPPED_MASK;
+		XTemac_mSetIpifReg(XTE_IPIER_OFFSET, Reg);
+	}
+
+	/* The remaining options not handled here are managed elsewhere in the
+	 * driver. No register modifications are needed at this time. Reflecting the
+	 * option in InstancePtr->Options is good enough for now.
+	 */
+
+	/* Set options word to its new value */
+	InstancePtr->Options &= ~Options;
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Get current option settings
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return
+ * A bitmask of XTE_*_OPTION constants. Any bit set to 1 is to be interpreted
+ * as a set opion.
+ *
+ * @note
+ * See xtemac.h for a description of the available options.
+ *
+ ******************************************************************************/
+u32 XTemac_GetOptions(XTemac * InstancePtr)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	return (InstancePtr->Options);
+}
+
+/*****************************************************************************/
+/**
+ * Send a pause packet
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param PauseValue is the pause value in units of 512 bit times.
+ *
+ * @return
+ * - XST_SUCCESS if pause frame transmission was initiated
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ *
+ ******************************************************************************/
+XStatus XTemac_SendPausePacket(XTemac * InstancePtr, u16 PauseValue)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Send flow control frame */
+	XTemac_mSetIpifReg(XTE_TPPR_OFFSET, (u32) PauseValue);
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Adjust the interframe gap. The MAC has a minimum IFG of 96 bit times. Using
+ * this function increases that IFG by the specified amount in the given
+ * parameter.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param AdditionalIfg is the new IFG extension value with a range of 0..255.
+ *        The LSB is 8 bit times. For example, if this parameter is 6, then the
+ *        total IFG will become 96 + (6 * 8) = 144 bit times.
+ *
+ ******************************************************************************/
+void XTemac_SetIfg(XTemac * InstancePtr, u8 AdditionalIfg)
+{
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	XTemac_mSetIpifReg(XTE_IFGP_OFFSET, (u32) AdditionalIfg);
+}
+
+/*****************************************************************************/
+/**
+ * Get the current interframe gap as set by XTemac_SetIfg().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return the current addtional interframe gap.
+ ******************************************************************************/
+u8 XTemac_GetIfg(XTemac * InstancePtr)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	return ((u8) XTemac_mGetIpifReg(XTE_IFGP_OFFSET));
+}
+
+/*****************************************************************************/
+/**
+ * Get information about the physical link interface
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param MiiTypePtr (output) is set to either XTE_MII_TYPE_RGMII for RGMII mode,
+ *        XTE_MII_TYPE_SGMII for SGMII mode, XTE_MII_TYPE_MII for MII or GMII
+ *        modes.
+ * @param Is1000BaseX (output) is set to TRUE when the device is operating in
+ *        1000BaseX mode, FALSE otherwise.
+ *
+ * @note At this time there is no HW interface available to tell whether MII or
+ * GMII is being utilized.
+ *
+ ******************************************************************************/
+void XTemac_GetPhysicalInterface(XTemac * InstancePtr, u8 * MiiTypePtr,
+				 u32 * Is1000BaseX)
+{
+	u32 EcfgReg;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(MiiTypePtr != NULL);
+	XASSERT_VOID(Is1000BaseX != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Get the current contents of the relevant register */
+	EcfgReg = XTemac_mGetHostReg(XTE_ECFG_OFFSET);
+
+	/* Decode the register and return the correct interface types */
+	if (EcfgReg & XTE_ECFG_RGMII_MASK) {
+		*MiiTypePtr = XTE_MII_TYPE_RGMII;
+	} else if (EcfgReg & XTE_ECFG_SGMII_MASK) {
+		*MiiTypePtr = XTE_MII_TYPE_SGMII;
+	} else {
+		*MiiTypePtr = XTE_MII_TYPE_MII;
+	}
+
+	if (EcfgReg & XTE_ECFG_1000BASEX_MASK) {
+		*Is1000BaseX = TRUE;
+	} else {
+		*Is1000BaseX = FALSE;
+	}
+}
+
+/*****************************************************************************/
+/**
+ * Get the current link speed. When configured for SGMII or RGMII this function
+ * returns what the device thinks it is running at. This should be an accurate
+ * value.
+ *
+ * When configured for MII or GMII, this function returns whatever the speed
+ * set by XTemac_SetMiiLinkSpeed() is, or if that function has never been called
+ * then the HW default is returned. The speed returned may not reflect the
+ * actual speed the link is operating at. For better accuracy, the user should
+ * query the PHY.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return Link speed in units of megabits per second
+ *
+ ******************************************************************************/
+u16 XTemac_GetLinkSpeed(XTemac * InstancePtr)
+{
+	u32 EcfgReg;
+	u32 EgmicReg;
+	u16 Speed = 10;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Get the current contents of the relevant registers */
+	EcfgReg = XTemac_mGetHostReg(XTE_ECFG_OFFSET);
+	EgmicReg = XTemac_mGetHostReg(XTE_EGMIC_OFFSET);
+
+	/* Decode registers and return the correct speed */
+	if (EcfgReg & XTE_ECFG_RGMII_MASK) {
+		if (EgmicReg & XTE_EGMIC_RGLINKSPD_1000) {
+			Speed = 1000;
+		} else if (EgmicReg & XTE_EGMIC_RGLINKSPD_100) {
+			Speed = 100;
+		}
+	} else if (EcfgReg & XTE_ECFG_SGMII_MASK) {
+		if (EgmicReg & XTE_EGMIC_SGLINKSPD_1000) {
+			Speed = 1000;
+		} else if (EgmicReg & XTE_EGMIC_SGLINKSPD_100) {
+			Speed = 100;
+		}
+	} else {
+		if (EcfgReg & XTE_ECFG_LINKSPD_1000) {
+			Speed = 1000;
+		} else if (EcfgReg & XTE_ECFG_LINKSPD_100) {
+			Speed = 100;
+		}
+	}
+
+	return (Speed);
+}
+
+/*****************************************************************************/
+/**
+ * Set the speed of the MAC when operating in MII or GMII modes. The speed
+ * must match what the PHY is reporting as the link speed.
+ *
+ * If the device is configured for SGMII or RGMII then the speed is set
+ * implicitly by the device and cannot be changed.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Speed is the speed to set in units of Mbps. Valid values are 10, 100,
+ *        or 1000
+ *
+ * @return
+ *   - XST_SUCCESS if the speed was set.
+ *   - XST_FAULURE if the speed was not set because the device is configured
+ *     for SGMII or RGMII.
+ *
+ ******************************************************************************/
+XStatus XTemac_SetMiiLinkSpeed(XTemac * InstancePtr, u16 Speed)
+{
+	u32 EcfgReg;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID((Speed == 10) || (Speed == 100) || (Speed == 1000));
+
+	/* Get the current contents of the EMAC config register  */
+	EcfgReg = XTemac_mGetHostReg(XTE_ECFG_OFFSET);
+
+	/* RGMII or SGMII? */
+	if (EcfgReg & (XTE_ECFG_RGMII_MASK | XTE_ECFG_SGMII_MASK)) {
+		return (XST_FAILURE);
+	}
+
+	/* Clear out link speed bits (resets speed to 10mbps) */
+	EcfgReg &= ~XTE_ECFG_LINKSPD_MASK;
+
+	switch (Speed) {
+	case 10:
+		break;
+
+	case 100:
+		EcfgReg |= XTE_ECFG_LINKSPD_100;
+		break;
+
+	case 1000:
+		EcfgReg |= XTE_ECFG_LINKSPD_1000;
+		break;
+	}
+
+	/* Set register and return */
+	XTemac_mSetHostReg(XTE_ECFG_OFFSET, EcfgReg);
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+ * Get the current state of the link when media interface is of the RGMII type
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param LinkPtr is a return value set to either XTE_RGMII_LINK_DOWN or
+ *        XTE_RGMII_LINK_UP.
+ * @param DuplexPtr is a returne value set to either XTE_RGMII_DUPLEX_HALF or
+ *        XTE_RGMII_DUPLEX_FULL.
+ *
+ * @return
+ *   - XST_SUCCESS if the RGMII status was read and return values set.
+ *   - XST_FAILURE if the device is not using RGMII.
+ *
+ ******************************************************************************/
+XStatus XTemac_GetRgmiiStatus(XTemac * InstancePtr, u8 * LinkPtr,
+			      u8 * DuplexPtr)
+{
+	u32 EcfgReg;
+	u32 EgmicReg;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(LinkPtr != NULL);
+	XASSERT_NONVOID(DuplexPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Get the current contents of the relevant registers */
+	EcfgReg = XTemac_mGetHostReg(XTE_ECFG_OFFSET);
+	EgmicReg = XTemac_mGetHostReg(XTE_EGMIC_OFFSET);
+
+	/* Decode registers and return the correct link attributes */
+	if (EcfgReg & XTE_ECFG_RGMII_MASK) {
+		if (EgmicReg & XTE_EGMIC_RGSTATUS_MASK) {
+			*LinkPtr = XTE_RGMII_LINK_UP;
+		} else {
+			*LinkPtr = XTE_RGMII_LINK_DOWN;
+		}
+
+		if (EgmicReg & XTE_EGMIC_RGHALFDUPLEX_MASK) {
+			*DuplexPtr = XTE_RGMII_DUPLEX_HALF;
+		} else {
+			*DuplexPtr = XTE_RGMII_DUPLEX_FULL;
+		}
+
+		return (XST_SUCCESS);
+	}
+
+	/* Not RGMII */
+	return (XST_FAILURE);
+}
+
+/*****************************************************************************/
+/**
+ * Set the MDIO clock divisor. This function must be called once after each
+ * reset prior to accessing MII PHY registers.
+ *
+ * Calculating the divisor:
+ *
+ * From the Virtex-4 Embedded Tri-Mode Ethernet MAC User's Guide, the
+ * following equation governs the MDIO clock to the PHY:
+ *
+ * <pre>
+ *              f[HOSTCLK]
+ *   f[MDC] = -----------------
+ *            (1 + Divisor) * 2
+ * </pre>
+ *
+ * where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the
+ * MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not
+ * exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster
+ * access.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Divisor is the divisor to set. Range is 0 to XTE_EMC_CLK_DVD_MAX.
+ *
+ ******************************************************************************/
+void XTemac_PhySetMdioDivisor(XTemac * InstancePtr, u8 Divisor)
+{
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY)
+	    XASSERT_VOID(Divisor <= XTE_EMC_CLK_DVD_MAX);
+
+	XTemac_mSetHostReg(XTE_EMC_OFFSET, (u32) Divisor | XTE_EMC_MDIO_MASK);
+}
+
+/*****************************************************************************/
+/*
+*
+* Read the current value of the PHY register indicated by the PhyAddress and
+* the RegisterNum parameters. The MAC provides the driver with the ability to
+* talk to a PHY that adheres to the Media Independent Interface (MII) as
+* defined in the IEEE 802.3 standard.
+*
+* Prior to PHY access with this function, the user should have setup the MDIO
+* clock with XTemac_PhyEnableAccess().
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+* @param PhyAddress is the address of the PHY to be read (supports multiple
+*        PHYs)
+* @param RegisterNum is the register number, 0-31, of the specific PHY register
+*        to read
+* @param PhyDataPtr is an output parameter, and points to a 16-bit buffer into
+*        which the current value of the register will be copied.
+*
+* @return
+*
+* - XST_SUCCESS if the PHY was read from successfully
+* - XST_NO_FEATURE if the device is not configured with MII support
+* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
+* - XST_EMAC_MII_READ_ERROR if a read error occurred between the MAC and the PHY
+*
+* @note
+*
+* This function is not thread-safe. The user must provide mutually exclusive
+* access to this function if there are to be multiple threads that can call it.
+* <br><br>
+* There is the possibility that this function will not return if the hardware
+* is broken (i.e., it never sets the status bit indicating that the read is
+* done). If this is of concern to the user, the user should provide protection
+* from this problem - perhaps by using a different timer thread to monitor the
+* PhyRead thread.
+*
+******************************************************************************/
+XStatus XTemac_PhyRead(XTemac * InstancePtr, u32 PhyAddress,
+		       u32 RegisterNum, u16 * PhyDataPtr)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* HW doesn't support PHY access yet */
+	return (XST_NO_FEATURE);
+}
+
+/*****************************************************************************/
+/*
+* Write data to the specified PHY register. The Ethernet driver does not
+* require the device to be stopped before writing to the PHY.  Although it is
+* probably a good idea to stop the device, it is the responsibility of the
+* application to deem this necessary. The MAC provides the driver with the
+* ability to talk to a PHY that adheres to the Media Independent Interface
+* (MII) as defined in the IEEE 802.3 standard.
+*
+* Prior to PHY access with this function, the user should have setup the MDIO
+* clock with XTemac_PhyEnableAccess().
+*
+* @param InstancePtr is a pointer to the XTemac instance to be worked on.
+* @param PhyAddress is the address of the PHY to be written (supports multiple
+*        PHYs)
+* @param RegisterNum is the register number, 0-31, of the specific PHY register
+*        to write
+* @param PhyData is the 16-bit value that will be written to the register
+*
+* @return
+*
+* - XST_SUCCESS if the PHY was written to successfully. Since there is no error
+*   status from the MAC on a write, the user should read the PHY to verify the
+*   write was successful.
+* - XST_NO_FEATURE if the device is not configured with MII support
+* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
+*
+* @note
+*
+* This function is not thread-safe. The user must provide mutually exclusive
+* access to this function if there are to be multiple threads that can call it.
+* <br><br>
+* There is the possibility that this function will not return if the hardware
+* is broken (i.e., it never sets the status bit indicating that the write is
+* done). If this is of concern to the user, the user should provide protection
+* from this problem - perhaps by using a different timer thread to monitor the
+* PhyWrite thread.
+*
+******************************************************************************/
+XStatus XTemac_PhyWrite(XTemac * InstancePtr, u32 PhyAddress,
+			u32 RegisterNum, u16 PhyData)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* HW doesn't support PHY access yet */
+	return (XST_NO_FEATURE);
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_fifo.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_fifo.c
@@ -0,0 +1,1308 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_fifo.c
+*
+* Functions in this file implement FIFO direct and Simple DMA frame transfer
+* mode. See xtemac.h for a detailed description of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+#define PFIFO_64BIT_WIDTH_BYTES 8
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*******************************************************************************
+ * Primitives that modify the hold structure for XTemac_PacketFifo. All F
+ * parameters refer to a pointer to XTemac_PacketFifo.
+ *
+ * mHold_GetIndex(F) - Get the ByteIndex of Hold
+ * mHold_SetIndex(F,D) - Set the ByteIndex of Hold to D
+ * mHold_Advance(F,D) - Advance the ByteIndex of Hold by D bytes
+ * mHold_CopyIn(F,I,D) - Set Hold[I] to D
+ * mHold_CopyOut(F,I,D) - Set D to Hold[I]
+ * mHoldS_IsFull(F) - Is a write channel Hold full of data
+ * mHoldS_IsEmpty(F) - Is a write channel Hold empty
+ * mHoldS_SetEmpty(F) - Set a write channel Hold empty
+ * mHoldR_IsFull(F) - Is a read channel Hold full of data
+ * mHoldR_IsEmpty(F) - Is a read channel Hold empty
+ * mHoldR_SetEmpty(F) - Set a read channel Hold empty
+ *
+ * @param F - Address to a XTemac_PacketFifo structure
+ * @param SrcPtr - Source data address aligned on 4 byte boundary
+ *
+ ******************************************************************************/
+#define mHold_GetIndex(F)      ((F)->ByteIndex)
+#define mHold_SetIndex(F, D)   ((F)->ByteIndex = (D))
+#define mHold_Advance(F, D)    ((F)->ByteIndex += (D))
+#define mHold_CopyIn(F, I, D)  (*(u8*)(((u8*)(&(F)->Hold[0])) + (I)) = (D))
+#define mHold_CopyOut(F, I, D) ((D) = (*(u8*)(((u8*)(&(F)->Hold[0])) + (I))))
+
+#define mHoldS_IsFull(F)    ((F)->ByteIndex >= (F)->Width)
+#define mHoldS_IsEmpty(F)   ((F)->ByteIndex == 0)
+#define mHoldS_SetEmpty(F)  ((F)->ByteIndex = 0)
+
+#define mHoldR_IsFull(F)    ((F)->ByteIndex == 0)
+#define mHoldR_IsEmpty(F)   ((F)->ByteIndex >= (F)->Width)
+#define mHoldR_SetEmpty(F)  ((F)->ByteIndex = (F)->Width)
+
+/*******************************************************************************
+ * Primitive write to 64 bit FIFO. Use two 32-bit wide I/O accesses.
+ *
+ * @param F - Address to a XTemac_PacketFifo structure
+ * @param SrcPtr - Source data address aligned on 4 byte boundary
+ *
+ ******************************************************************************/
+#define mWriteFifo64(F, SrcPtr)                                \
+    {                                                          \
+        register u32 Faddr = F->Fifo.DataBaseAddress;      \
+        XIo_Out32(Faddr, (SrcPtr)[0]);                         \
+        XIo_Out32(Faddr + 4, (SrcPtr)[1]);                     \
+    }
+
+/*******************************************************************************
+ * Primitive read from 64 bit FIFO. Use two 32-bit wide I/O accesses.
+ *
+ * @param F - Address to a XTemac_PacketFifo structure
+ * @param DestPtr - Destination data address aligned on 4 byte boundary
+ *
+ ******************************************************************************/
+#define mReadFifo64(F, DestPtr)                                \
+    (DestPtr)[0] = XIo_In32(F->Fifo.DataBaseAddress);          \
+    (DestPtr)[1] = XIo_In32(F->Fifo.DataBaseAddress + 4);
+
+/*******************************************************************************
+ * Primitive to transfer the holding data to the FIFO 64 bits at a time
+ *
+ * @param F - Address to a XTemac_PacketFifo structure
+ *
+ ******************************************************************************/
+#define mPush64(F) mWriteFifo64(F, &F->Hold[0])
+
+/*******************************************************************************
+ * Primitive to tranfer FIFO contents into the holding data 64 bits at a time
+ *
+ * @param F - Address to a XTemac_PacketFifo structure
+ *
+ ******************************************************************************/
+#define mPop64(F) mReadFifo64(F, &F->Hold[0])
+
+/************************** Function Prototypes ******************************/
+
+/* The following functions will be attached to the FifoRead and FifoWrite
+ * attribute of an instance by XTemac_ConfigureFifoAccess
+ */
+static XStatus Write_64(XTemac_PacketFifo * Fptr, void *BufPtr,
+			u32 ByteCount, int Eop);
+static XStatus Read_64(XTemac_PacketFifo * Fptr, void *BufPtr,
+		       u32 ByteCount, int Eop);
+
+/* 64 bit wide FIFO support functions */
+static void Write64_Unaligned(XTemac_PacketFifo * F, void *BufPtr,
+			      u32 ByteCount);
+static void Write64_Aligned(XTemac_PacketFifo * F, u32 * BufPtr, u32 ByteCount);
+static void Read64_Unaligned(XTemac_PacketFifo * F, void *BufPtr,
+			     u32 ByteCount);
+static void Read64_Aligned(XTemac_PacketFifo * F, u32 * BufPtr, u32 ByteCount);
+
+/*******************************************************************************
+ * Select the best method for accessing the read and write FIFOs for FIFO direct
+ * frame transfer mode. On the write (transmit) side, the choices are DRE or via
+ * the holding structure. Both methods allow unaligned transfers. On the read
+ * (receive) side, the only choice is the holding structure.
+ *
+ * This function should be called only from XTemac_Initialize().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return XST_SUCCESS or XST_FAILURE if an error was detected
+ *
+ ******************************************************************************/
+XStatus XTemac_ConfigureFifoAccess(XTemac * InstancePtr)
+{
+	XStatus Result;
+
+	/* Initialize the packet FIFOs */
+	Result = XPacketFifoV200a_Initialize(&InstancePtr->RecvFifo.Fifo,
+					     InstancePtr->BaseAddress +
+					     XTE_PFIFO_RXREG_OFFSET,
+					     InstancePtr->BaseAddress +
+					     XTE_PFIFO_RXDATA_OFFSET);
+	if (Result != XST_SUCCESS) {
+		return (XST_FAILURE);
+	}
+
+	Result = XPacketFifoV200a_Initialize(&InstancePtr->SendFifo.Fifo,
+					     InstancePtr->BaseAddress +
+					     XTE_PFIFO_TXREG_OFFSET,
+					     InstancePtr->BaseAddress +
+					     XTE_PFIFO_TXDATA_OFFSET);
+
+	if (Result != XST_SUCCESS) {
+		return (XST_FAILURE);
+	}
+
+	/* Choose an access algorithm.
+	 * Note: 64-bit wide FIFO is the only width supported at this time
+	 */
+	InstancePtr->RecvFifo.Width = PFIFO_64BIT_WIDTH_BYTES;
+	InstancePtr->RecvFifo.XferFn = Read_64;
+	InstancePtr->SendFifo.Width = PFIFO_64BIT_WIDTH_BYTES;
+	InstancePtr->SendFifo.XferFn = Write_64;
+
+	/* Initialize the holds */
+	mHoldS_SetEmpty(&InstancePtr->SendFifo);
+	mHoldR_SetEmpty(&InstancePtr->RecvFifo);
+
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Copy data from a user buffer to the transmit packet FIFO. The data copied
+ * may comprise of single, multiple, or partial packets. The data is not
+ * transmitted until XTemac_FifoSend() is called.
+ *
+ * If the user buffer contains multiple packets, then extra care must be taken.
+ * In this special situation, the end of one packet and the beginning of a new
+ * packet is specified within the user buffer. The beginning of each NEW packet
+ * must begin on a 4 byte alignment. The user is responsible for adding filler
+ * data between packets to acheive this alignment. The amount of filler data
+ * depends on what byte the end of the previous packet falls on. When calling
+ * XTemac_FifoSend() to transmit the packets, DO NOT specify the filler bytes
+ * in the TxByteCount parameter. For example, if a user buffer contains two
+ * complete packets of 15 bytes each with 1 byte of filler between them, then
+ * XTemac_FifoWrite() is called once to write all 31 bytes to the FIFO.
+ * XTemac_FifoSend() is called twice specifying 15 bytes each time to transmit
+ * the packets (the 1 byte of filler data is ignored by the TEMAC). Of course
+ * you could also just call XTemac_FifoWrite() once for each packet. This way,
+ * the driver will manage the filler data.
+ *
+ * If the user's buffer is not aligned on a 4 byte boundary, then the transfer
+ * may take longer to complete.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param BufPtr is the buffer containing user data that will be transferred
+ *        into the transmit FIFO. The buffer may be on any alignment.
+ * @param ByteCount is the number of bytes to transfer from 1 to the number
+ *        of bytes available in the FIFO at the time of invocation. See usage
+ *        note for situations when a value of 0 is legal.
+ * @param Eop specifies whether the last byte of BufPtr marks the End Of Packet.
+ *        If set to XTE_END_OF_PACKET, then any partial bytes being buffered by
+ *        the driver are flushed into the packet FIFO. If set to
+ *        XTE_PARTIAL_PACKET, then more packet data is expected to be written
+ *        through more calls to this function. Failure to use XTE_END_OF_PACKET
+ *        prior to calling XTemac_FifoSend() may cause a packet FIFO underrun.
+ *
+ * @return
+ * - XST_SUCCESS if the data was transferred to the FIFO.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_PFIFO_ERROR if there was a packet FIFO overflow during the transfer.
+ *   This is a fatal condition. If this value is returned in polled mode, then
+ *   the device must be reset. For interrupt driven modes, an interrupt will be
+ *   asserted resulting in a call to the registered error handler which should
+ *   handle reset of the device.
+ * - XST_IPIF_ERROR if a data or bus error occurred within the TEMAC's IPIF.
+ *   Like the PFIFO error, this is a fatal condition and should be handled
+ *   in the same manner.
+ *
+ * @note
+ * Calling this function with ByteCount = 0 will not result in the transfer of
+ * data from BufPtr to the FIFO. However, if at the same time Eop is set to
+ * XTE_END_OF_PACKET, then all data previously written with this function is
+ * guaranteed to be flushed into the packet FIFO and available for transmission
+ * with XTemac_FifoSend().
+ ******************************************************************************/
+XStatus XTemac_FifoWrite(XTemac * InstancePtr, void *BufPtr, u32 ByteCount,
+			 int Eop)
+{
+	u32 RegDISR;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(!
+			((Eop != XTE_END_OF_PACKET)
+			 && (Eop != XTE_PARTIAL_PACKET)));
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Transfer the data using the best/fastest method */
+	InstancePtr->SendFifo.XferFn(&InstancePtr->SendFifo, BufPtr, ByteCount,
+				     Eop);
+
+	/* Make sure the packet FIFO didn't report an error */
+	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
+	if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
+		/* Only bump stats in polled mode. For interrupt driven mode, this stat
+		 * is bumped in XTemac_IntrFifoHandler()
+		 */
+		if (InstancePtr->Options & XTE_POLLED_OPTION) {
+			XTemac_mBumpStats(TxPktFifoErrors, 1);
+		}
+		return (XST_PFIFO_ERROR);
+	}
+
+	/* Verify no IPIF errors */
+	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
+		/* Only bump stats in polled mode. For interrupt driven mode, this stat
+		 * is bumped in XTemac_IntrFifoHandler()
+		 */
+		if (InstancePtr->Options & XTE_POLLED_OPTION) {
+			XTemac_mBumpStats(IpifErrors, 1);
+		}
+		return (XST_IPIF_ERROR);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Use a simple DMA channel to transfer data from a user buffer to the transmit
+ * packet FIFO. The data is not transmitted until XTemac_FifoSend() is called.
+ *
+ * If simple DMA interrupts are enabled (see XTemac_IntrFifoDmaEnable()), then
+ * upon completion of the transfer, the registered XTemac_FifoDmaWriteHandler()
+ * is invoked. If an error occurs during the transfer, then the registered
+ * XTemac_ErrorHandler() will be invoked.
+ *
+ * The BD parameter supplied to this function can be allocated statically or on
+ * the program stack. When this function returns, the BD can be destroyed. It
+ * should be setup as follows:
+ *   - XDmaBdV2_mClear(UserBdPtr)
+ *   - XDmaBdV2_mSetSrcAddr(UserBdPtr, UserBufAddr)
+ *   - XDmaBdV2_mSetLength(UserBdPtr, UserBufLength)
+ *
+ * No other BD fields are user modifiable. Future versions of the DMA engine
+ * may allow additional modifications for more precise control of the transfer.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param BdPtr is a buffer descriptor that contains the source address
+ *        and number of bytes to transfer. This parameter will be modified
+ *        by this function to set certain control words required for the
+ *        transfer.
+ *
+ * @return
+ * - XST_SUCCESS if transfer was successfully initiated.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_DEVICE_BUSY if another transfer is in progress.
+ *
+ * @note
+ * Be aware of user buffer alignment restrictions for this mode of transfer.
+ * See xtemac.h.
+ *
+ ******************************************************************************/
+XStatus XTemac_FifoDmaWrite(XTemac * InstancePtr, XDmaBdV2 * BdPtr)
+{
+	XStatus Status;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Operation already in progress? */
+	if (InstancePtr->DmaWriteLengthRef != 0) {
+		return (XST_DEVICE_BUSY);
+	}
+
+	/* Save bytecount to pass into the registered handler when the transfer
+	 * completes
+	 */
+	InstancePtr->DmaWriteLengthRef =
+	    XDmaV2_mReadBd(BdPtr, XDMAV2_BD_LENGTH_OFFSET);
+
+	/* Set DMA control for transfer */
+	XDmaV2_mWriteBd(BdPtr, XDMAV2_BD_DMACR_OFFSET,
+			XDMAV2_DMACR_SINC_MASK |
+			XDMAV2_DMACR_DLOCAL_MASK | XDMAV2_DMACR_SGS_MASK);
+
+	/* Set destination address as the write packet FIFO */
+	XDmaV2_mWriteBd(BdPtr, XDMAV2_BD_DA_OFFSET,
+			InstancePtr->Config->BaseAddress +
+			XTE_PFIFO_TXDATA_OFFSET);
+
+	/* Begin DMA transfer. The called function should return either XST_SUCCESS or
+	 * XST_DEVICE_BUSY
+	 */
+	Status = XDmaV2_SimpleTransfer(&InstancePtr->SendDma, BdPtr);
+	return (Status);
+}
+
+/******************************************************************************/
+/**
+ * Initiate a transmit of one packet of data previously written with
+ * XTemac_FifoWrite() or XTemac_FifoDmaWrite(). The given length in bytes is
+ * written to the transmit length FIFO. There should be at least this many
+ * bytes in the packet FIFO ready for transmit.
+ *
+ * If FIFO interrupts are enabled (see XTemac_IntrFifoEnable()), then upon
+ * completion of the transmit, the registered XTemac_FifoSendHandler() is
+ * invoked.
+ *
+ * If more bytes that are in the packet FIFO are specified in the TxByteCount
+ * parameter, then a packet FIFO underrun error will result.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param TxByteCount is the number of bytes to transmit. Range is 1 to the
+ *        total number of bytes available in the packet FIFO to be transmitted.
+ *
+ * @return
+ * - XST_SUCCESS if transmit was initiated.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_FIFO_NO_ROOM if the transmit was not initiated because the transmit
+ *   length FIFO was full. This is not a fatal condition. The user may need to
+ *   wait for other packets to transmit before this condition clears itself.
+ *
+ ******************************************************************************/
+XStatus XTemac_FifoSend(XTemac * InstancePtr, u32 TxByteCount)
+{
+	u32 RegIPISR;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(TxByteCount != 0);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* See if transmit length FIFO is full. If it is, try to clear the
+	 * status. If it the status remains, then return an error
+	 */
+	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+	if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+				   XTE_IPXR_XMIT_LFIFO_FULL_MASK);
+
+		RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+		if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
+			XTemac_mBumpStats(FifoErrors, 1);
+			return (XST_FIFO_NO_ROOM);
+		}
+	}
+
+	/* Start transmit */
+	XTemac_mSetIpifReg(XTE_TPLR_OFFSET, TxByteCount);
+
+	/* Return sucess */
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Return the length of a received packet. If a packet is waiting in the
+ * receive packet FIFO, then it may be copied to a user buffer with
+ * XTemac_FifoRead() or XTemac_FifoDmaRead().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param ByteCountPtr is the length of the next received packet if the return
+ *        status is XST_SUCCESS.
+ *
+ * @return
+ * - XST_SUCCESS if a packet has been received and a value has been written to
+ *   ByteCountPtr.
+ * - XST_DEVICE_IS_STOPPED if the device has been stopped.
+ * - XST_NO_DATA if no packet length is available. ByteCountPtr is not modified.
+ *
+ ******************************************************************************/
+XStatus XTemac_FifoRecv(XTemac * InstancePtr, u32 * ByteCountPtr)
+{
+	u32 RegIPISR;
+	volatile u32 RegRSR;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(ByteCountPtr != NULL);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* If the receive length FIFO is empty, then there's no packet waiting */
+	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+	if (!(RegIPISR & XTE_IPXR_RECV_DONE_MASK)) {
+		return (XST_NO_DATA);
+	}
+
+	/* Get the length */
+	*ByteCountPtr = XTemac_mGetIpifReg(XTE_RPLR_OFFSET);
+
+	/* The IPXR_RECV_DONE_MASK status bit is tied to the RSR register. To clear
+	 * this condition, read from the RSR (which has no information) then write
+	 * to the IPISR register to ack the status.
+	 */
+	RegRSR = XTemac_mGetIpifReg(XTE_RSR_OFFSET);
+	XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_RECV_DONE_MASK);
+
+	/* Return sucess */
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Copy data from the receive packet FIFO into a user buffer. The number of
+ * bytes to copy is derived from XTemac_FifoRecv(). The packet data may be
+ * copied out of the FIFO all at once or with multiple calls to this function.
+ * The latter method supports systems that keep packet data in non-contiguous
+ * memory regions. For example:
+ * <pre>
+ *    if (XTemac_FifoRecv(Tptr, &PacketLength) == XST_SUCCESS)
+ *    {
+ *       if (PacketLength > 14)
+ *       {
+ *          HeaderLength = 14;
+ *          PayloadLength = PacketLength - HeaderLength;
+ *
+ *          Status =  XTemac_FifoRead(Tptr, UserHeaderBuf, HeaderLength,
+ *                                    XTE_PARTIAL_PACKET);
+ *          Status |= XTemac_FifoRead(Tptr, UserPayloadBuf, PayloadLength,
+ *                                    XTE_END_OF_PACKET);
+ *
+ *          if (Status != XST_SUCCESS)
+ *          {
+ *             // handle error
+ *          }
+ *       }
+ *    }
+ * </pre>
+ *
+ * If the user's buffer is not aligned on a 4 byte boundary, then the transfer
+ * may take longer to complete.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param BufPtr is the user buffer that will recieve packet data from the FIFO.
+ *        The buffer may be on any alignment.
+ * @param ByteCount is the number of bytes to transfer
+ * @param Eop specifies whether the last byte read is the last byte of a packet.
+ *        If set to XTE_END_OF_PACKET, then any partial bytes being buffered by
+ *        the driver at the end of the transfer are discarded. These discarded
+ *        bytes are filler provided by the hardware and have no meaning. If set
+ *        to XTE_PARTIAL_PACKET, then more packet data is expected to be read
+ *        through more calls to this function. Failure to use this parameter
+ *        properly will result in undefined filler bytes being copied into
+ *        BufPtr.
+ *
+ * @return
+ * - XST_SUCCESS if the data was transferred to the user buffer
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_NO_DATA if there was not enough data in the packet FIFO to satisfy the
+ *   request.
+ *
+ * @note
+ * Do not attempt to read more than one packets worth of data at a time with
+ * this function.
+ ******************************************************************************/
+XStatus XTemac_FifoRead(XTemac * InstancePtr, void *BufPtr, u32 ByteCount,
+			int Eop)
+{
+	XStatus Status;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(!
+			((Eop != XTE_END_OF_PACKET)
+			 && (Eop != XTE_PARTIAL_PACKET)));
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Transfer the data using the best/fastest method */
+	Status = InstancePtr->RecvFifo.XferFn(&InstancePtr->RecvFifo, BufPtr,
+					      ByteCount, Eop);
+
+	/* Return correct status */
+	if (Status == XST_NO_DATA) {
+		return (XST_NO_DATA);
+	} else {
+		return (XST_SUCCESS);
+	}
+}
+
+/******************************************************************************/
+/**
+ * Use a simple DMA channel to transfer data from the receive packet FIFO to a
+ * user buffer.
+ *
+ * If simple DMA interrupts are enabled (see XTemac_IntrDmaEnable()), then upon
+ * completion of the transfer, the registered XTemac_FifoDmaReadHandler() will
+ * be invoked. If an error occurs during the transfer, then the registered
+ * XTemac_ErrorHandler() will be invoked.
+ *
+ * The BD parameter supplied to this function can be allocated statically or on
+ * the program stack. When this function returns, the BD can be destroyed. It
+ * should be setup as follows:
+ *   - XDmaBdV2_mClear(UserBdPtr)
+ *   - XDmaBdV2_mSetDestAddr(UserBdPtr, UserBufAddr)
+ *   - XDmaBdV2_mSetLength(UserBdPtr, UserBufLength)
+ *
+ * No other BD fields are user modifiable. Future versions of the DMA engine
+ * may allow additional modifications for more precise control of the transfer.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param BdPtr is a buffer descriptor that contains the destination address
+ *        and number of bytes to transfer. This parameter will be modified
+ *        by this function to set certain control words required for the
+ *        transfer.
+ *
+ * @return
+ * - XST_SUCCESS if transfer was successfully initiated.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_DEVICE_BUSY if another transfer is in progress.
+ *
+ * @note
+ * Be aware of user buffer alignment restrictions for this mode of transfer.
+ * See xtemac.h.
+ *
+ ******************************************************************************/
+XStatus XTemac_FifoDmaRead(XTemac * InstancePtr, XDmaBdV2 * BdPtr)
+{
+	XStatus Status;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Operation already in progress? */
+	if (InstancePtr->DmaReadLengthRef != 0) {
+		return (XST_DEVICE_BUSY);
+	}
+
+	/* Save bytecount to pass into the registered handler when the transfer
+	 * completes
+	 */
+	InstancePtr->DmaReadLengthRef =
+	    XDmaV2_mReadBd(BdPtr, XDMAV2_BD_LENGTH_OFFSET);
+
+	/* Set DMA control for transfer */
+	XDmaV2_mWriteBd(BdPtr, XDMAV2_BD_DMACR_OFFSET,
+			XDMAV2_DMACR_DINC_MASK |
+			XDMAV2_DMACR_SLOCAL_MASK | XDMAV2_DMACR_SGS_MASK);
+
+	/* Set source address as the read packet FIFO */
+	XDmaV2_mWriteBd(BdPtr, XDMAV2_BD_SA_OFFSET,
+			InstancePtr->Config->BaseAddress +
+			XTE_PFIFO_RXDATA_OFFSET);
+
+	/* Begin DMA transfer. The called function should return either XST_SUCCESS or
+	 * XST_DEVICE_BUSY
+	 */
+	Status = XDmaV2_SimpleTransfer(&InstancePtr->RecvDma, BdPtr);
+	return (Status);
+}
+
+/******************************************************************************/
+/**
+ * Retrieve the number of free bytes in the packet FIFOs.
+ *
+ * For the transmit packet FIFO, the number returned is the number of bytes
+ * that can be written by XTemac_FifoWrite() or XTemac_FifoDmaWrite(). If a
+ * non-zero number is returned, then at least 1 packet of that size can be
+ * transmitted.
+ *
+ * For the receive packet FIFO, the number returned is the number of bytes that
+ * can arrive from an external Ethernet device. This number does not reflect
+ * the state of the receive length FIFO. If this FIFO is full, then arriving
+ * packets will get dropped by the HW if there is no place to store the length.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction selects which packet FIFO to examine. If XTE_SEND, then
+ *        the transmit packet FIFO is selected. If XTE_RECV, then the receive
+ *        packet FIFO is selected.
+ *
+ * @return
+ * Number of bytes available in the selected packet FIFO.
+ *
+ ******************************************************************************/
+u32 XTemac_FifoGetFreeBytes(XTemac * InstancePtr, u32 Direction)
+{
+	u32 RegIPISR;
+	u32 Count;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	/* For the send direction, even though there may be room in the
+	 * packet FIFO, the length FIFO may be full. When this is the case,
+	 * another packet cannot be transmiited so return 0.
+	 */
+	if (Direction == XTE_SEND) {
+		/* Check length FIFO */
+		RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+		if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
+			return (0);
+		}
+
+		/* Get FIFO entries */
+		Count = XPF_V200A_GET_COUNT(&InstancePtr->SendFifo.Fifo);
+	}
+
+	/* Handle receive direction */
+	else {
+		Count = XPF_V200A_COUNT_MASK -
+		    XPF_V200A_GET_COUNT(&InstancePtr->RecvFifo.Fifo);
+	}
+
+	/* Multiply free entries by the width of the packet FIFO to arrive at
+	 * bytes
+	 */
+	return (Count * InstancePtr->RecvFifo.Width);
+}
+
+/******************************************************************************/
+/**
+ * Query the device for the latest transmit status for FIFO direct frame
+ * transfer mode. This function should be used for polled mode operation only.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param SendStatusPtr is the contents of the XTE_TSR_OFFSET register when the
+ *        return code is XST_FAILURE. Otherwise 0 is returned.
+ *
+ * @return
+ * - XST_NO_DATA if a transmit status is not currently available.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_NOT_POLLED if the device has not been set to polled mode.
+ * - XST_SUCCESS if a transmit status was found and indicates that there was
+ *   no error.
+ * - XST_FAILURE if a transmit status was found which indicated a problem
+ *   occurred during transmit. The status is written to the SendStatusPtr for
+ *   the caller to examine.
+ * - XST_FIFO_ERROR if the transmit length or transmit status FIFOs error has
+ *   been detected. If this error is returned, then the device must be reset
+ *   before this function will return a valid transmit status indication.
+ * - XST_PFIFO_ERROR if the transmit packet FIFO is deadlocked. If this error
+ *   is returned, then the device must be reset before this function will
+ *   return a valid transmit status indication
+ *
+ * @note
+ * When XST_FAILURE is returned with the XTE_TSR_PFIFOU_MASK bit set in the
+ * SendStatusPtr parameter, then an attempt was made to tranmit more data than
+ * was present in the packet FIFO. No reset is required in this situation.
+ *
+ ******************************************************************************/
+XStatus XTemac_FifoQuerySendStatus(XTemac * InstancePtr, u32 * SendStatusPtr)
+{
+	u32 RegDISR;
+	u32 RegIPISR;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(SendStatusPtr != NULL);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Have to be in polled mode to use this function */
+	if (!(InstancePtr->Options & XTE_POLLED_OPTION)) {
+		return (XST_NOT_POLLED);
+	}
+
+	/* Make sure send packet FIFO isn't deadlocked */
+	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
+	if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
+		XTemac_mBumpStats(TxPktFifoErrors, 1);
+		return (XST_PFIFO_ERROR);
+	}
+
+	/* Read the IPISR
+	 * If any errors are detetected, try to clear and return error
+	 */
+	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+	if (RegIPISR & XTE_IPXR_XMIT_ERROR_MASK) {
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+				   RegIPISR & XTE_IPXR_XMIT_ERROR_MASK);
+		XTemac_mBumpStats(FifoErrors, 1);
+		return (XST_FIFO_ERROR);
+	}
+
+	/* No FIFO errors, so see of a transmit has completed */
+	if (!(RegIPISR & XTE_IPXR_XMIT_DONE_MASK)) {
+		return (XST_NO_DATA);
+	}
+
+	/* Transmit has completed, get the status, ack the condition */
+	*SendStatusPtr = XTemac_mGetIpifReg(XTE_TSR_OFFSET);
+	XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_XMIT_DONE_MASK);
+
+	/* check for errors, and return */
+	if (*SendStatusPtr & XTE_TSR_ERROR_MASK) {
+		XTemac_mBumpStats(TxStatusErrors, 1);
+		return (XST_FAILURE);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Query the device for the latest receive status for FIFO direct frame
+ * transfer mode. This function should be used for polled mode operation only.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return
+ * - XST_SUCCESS if a frame has been received and no receive error was detected.
+ * - XST_DEVICE_IS_STOPPED if the device has not been started.
+ * - XST_NO_DATA if no frame has been received and no receive related error has
+ *   been detected.
+ * - XST_NOT_POLLED if the device has not been set to polled mode.
+ * - XST_DATA_LOST if the device reports that it dropped a receive frame. This
+ *   is not a serious problem but may indicate that frames are arriving faster
+ *   than the system can process them.
+ * - XST_FIFO_ERROR if an error was detected with the receive length FIFO. If
+ *   this error is returned, then the device must be reset before any new frame
+ *   can be received.
+ * - XST_PFIFO_ERROR if the receive packet FIFO is deadlocked. If this error is
+ *   returned, then the device must be reset before any new frame can be
+ *   received.
+ *
+ * @note
+ * In situations where simultaneously a frame has been received for which an
+ * XST_SUCCESS can be returned and a dropped frame for which an XST_DATA_LOST
+ * can be returned, then this function will give priority to XST_SUCCESS so the
+ * user can receive the frame.
+ ******************************************************************************/
+XStatus XTemac_FifoQueryRecvStatus(XTemac * InstancePtr)
+{
+	u32 RegDISR;
+	u32 RegIPISR;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STOPPED);
+	}
+
+	/* Have to be in polled mode to use this function */
+	if (!(InstancePtr->Options & XTE_POLLED_OPTION)) {
+		return (XST_NOT_POLLED);
+	}
+
+	/* Make sure recv packet FIFO isn't deadlocked */
+	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
+	if (RegDISR & (XTE_DXR_RECV_FIFO_MASK | XTE_DXR_TERR_MASK)) {
+		XTemac_mBumpStats(RxPktFifoErrors, 1);
+		return (XST_PFIFO_ERROR);
+	}
+
+	/* Read the IPISR */
+	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+
+	/* Check for other recv related FIFO errors */
+	if (RegIPISR & (XTE_IPXR_RECV_ERROR_MASK - XTE_IPXR_RECV_DROPPED_MASK)) {
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+				   RegIPISR & XTE_IPXR_RECV_ERROR_MASK);
+		XTemac_mBumpStats(FifoErrors, 1);
+		return (XST_FIFO_ERROR);
+	}
+
+	/* See if a frame has been received */
+	if (RegIPISR & XTE_IPXR_RECV_DONE_MASK) {
+		return (XST_SUCCESS);
+	}
+
+	/* If option to detect recv reject errors is set, check for rejected
+	 * receive frames. If one is detected, clear it and return error.
+	 */
+	if (InstancePtr->Options & XTE_REPORT_RXERR_OPTION) {
+		if (RegIPISR & XTE_IPXR_RECV_DROPPED_MASK) {
+			XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+					   RegIPISR &
+					   XTE_IPXR_RECV_DROPPED_MASK);
+			return (XST_DATA_LOST);
+		}
+	}
+
+	/* No frame has been received and no errors detected */
+	return (XST_NO_DATA);
+}
+
+/*******************************************************************************
+* Algorithm to write to a 64 bit wide transmit packet FIFO through the holding
+* buffer.
+*
+* @param FPtr is a pointer to a Temac FIFO instance to worked on.
+* @param BufPtr is the source buffer address on any alignment
+* @param ByteCount is the number of bytes to transfer
+* @param Eop specifies whether the last byte written is the last byte of the
+*        packet.
+*
+* @return XST_SUCCESS
+*******************************************************************************/
+static XStatus Write_64(XTemac_PacketFifo * Fptr, void *BufPtr,
+			u32 ByteCount, int Eop)
+{
+	unsigned BufAlignment = (unsigned)BufPtr & 3;
+	unsigned PartialBytes;
+	int HoldAlignment = mHold_GetIndex(Fptr);
+
+	/* Case 1: Buffer aligned on 4-byte boundary and Hold is empty
+	 *
+	 *   1. Write all bytes using the fastest transfer method
+	 */
+	if ((BufAlignment == 0) && (mHoldS_IsEmpty(Fptr))) {
+		Write64_Aligned(Fptr, (u32 *) BufPtr, ByteCount);
+	}
+
+	/* Case 2: Buffer and Hold are byte aligned with each other
+	 *
+	 *   1. Transfer enough bytes from the buffer to the Hold to trigger a flush
+	 *      to the FIFO.
+	 *
+	 *   2. The state of the buffer and Hold are as described by Case 1 so
+	 *      write remaining bytes using the fastest transfer method
+	 */
+	else if (BufAlignment == (HoldAlignment % PFIFO_64BIT_WIDTH_BYTES)) {
+		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
+
+		if (ByteCount < PartialBytes) {
+			PartialBytes = ByteCount;
+		}
+
+		Write64_Unaligned(Fptr, BufPtr, PartialBytes);
+		Write64_Aligned(Fptr, (u32 *) (BufPtr + PartialBytes),
+				ByteCount - PartialBytes);
+	}
+
+	/* Case 3: No alignment to take advantage of
+	 *
+	 *    1. Read FIFOs using the slower method.
+	 */
+	else {
+		Write64_Unaligned(Fptr, BufPtr, ByteCount);
+	}
+
+	/* If TxBytes is non-zero then the caller wants to transmit data from the
+	 * FIFO
+	 */
+	if (Eop == XTE_END_OF_PACKET) {
+		/* Push the hold to the FIFO if data is present */
+		if (!mHoldS_IsEmpty(Fptr)) {
+			mPush64(Fptr);
+			mHoldS_SetEmpty(Fptr);
+		}
+	}
+
+	return (XST_SUCCESS);
+}
+
+/*******************************************************************************
+* Algorithm to read from a 64 bit wide receive packet FIFO with through the
+* holding buffer.
+*
+* @param Fptr is a pointer to a Temac FIFO instance to worked on.
+* @param BufPtr is the destination address on any alignment
+* @param ByteCount is the number of bytes to transfer
+*
+* @return XST_SUCCESS if transfer completed or XST_NO_DATA if the amount of
+*         data being buffered by the driver plus the amount of data in the
+*         packet FIFO is not enough to satisfy the number of bytes requested
+*         by the ByteCount parameter.
+*******************************************************************************/
+static XStatus Read_64(XTemac_PacketFifo * Fptr, void *BufPtr,
+		       u32 ByteCount, int Eop)
+{
+	unsigned BufAlignment = (unsigned)BufPtr & 3;
+	unsigned PartialBytes;
+	unsigned MaxBytes;
+	int HoldAlignment = mHold_GetIndex(Fptr);
+
+	/* Determine how many bytes can be read from the packet FIFO */
+	MaxBytes = XPF_V200A_COUNT_MASK & XPF_V200A_GET_COUNT(&Fptr->Fifo);
+	MaxBytes *= PFIFO_64BIT_WIDTH_BYTES;
+
+	/* Case 1: Buffer aligned on 4-byte boundary and Hold is empty
+	 *
+	 *   1. Read all bytes using the fastest transfer method
+	 */
+	if ((BufAlignment == 0) && (mHoldR_IsEmpty(Fptr))) {
+		/* Enough data in fifo? */
+		if (ByteCount > MaxBytes) {
+			return (XST_NO_DATA);
+		}
+
+		Read64_Aligned(Fptr, (u32 *) BufPtr, ByteCount);
+	}
+
+	/* Case 2: Buffer and Hold are byte aligned with each other
+	 *
+	 *   1. Transfer enough bytes from the Hold to the buffer to trigger a
+	 *      read from the FIFO.
+	 *
+	 *   2. The state of the buffer and Hold are now as described by Case 1 so
+	 *      read remaining bytes using the fastest transfer method
+	 */
+	else if (BufAlignment == (HoldAlignment % PFIFO_64BIT_WIDTH_BYTES)) {
+		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
+
+		if (ByteCount < PartialBytes) {
+			PartialBytes = ByteCount;
+		}
+
+		/* Enough data in fifo? Must account for the number of bytes the driver
+		 * is currently buffering
+		 */
+		if (ByteCount > (MaxBytes + PartialBytes)) {
+			return (XST_NO_DATA);
+		}
+
+		Read64_Unaligned(Fptr, BufPtr, PartialBytes);
+		Read64_Aligned(Fptr, (u32 *) (BufPtr + PartialBytes),
+			       ByteCount - PartialBytes);
+	}
+
+	/* Case 3: No alignment to take advantage of
+	 *
+	 *    1. Read FIFOs using the slower method.
+	 */
+	else {
+		/* Enough data in fifo? Must account for the number of bytes the driver
+		 * is currently buffering
+		 */
+		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
+		if (ByteCount > (MaxBytes + PartialBytes)) {
+			return (XST_NO_DATA);
+		}
+
+		Read64_Unaligned(Fptr, BufPtr, ByteCount);
+	}
+
+	/* If this marks the end of packet, then dump any remaining data in the
+	 * hold. The dumped data in this context is meaningless.
+	 */
+	if (Eop == XTE_END_OF_PACKET) {
+		mHoldR_SetEmpty(Fptr);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/*******************************************************************************
+* Write to the 64 bit holding buffer. Each time it becomes full, then it is
+* pushed to the transmit FIFO.
+*
+* @param F is a pointer to the packet FIFO instance to be worked on.
+* @param BufPtr is the source buffer address on any alignment
+* @param ByteCount is the number of bytes to transfer
+*
+*******************************************************************************/
+static void Write64_Unaligned(XTemac_PacketFifo * F,
+			      void *BufPtr, u32 ByteCount)
+{
+	u8 *SrcPtr = (u8 *) BufPtr;
+	unsigned FifoTransfersLeft;
+	unsigned PartialBytes;
+	unsigned BytesLeft;
+	int i;
+
+	/* Stage 1: The hold may be partially full. Write enough bytes to it to
+	 * cause a push to the FIFO
+	 */
+
+	/* Calculate the number of bytes needed to trigger a push, if not enough
+	 * bytes have been specified to cause a push, then adjust accordingly
+	 */
+	i = mHold_GetIndex(F);
+	PartialBytes = PFIFO_64BIT_WIDTH_BYTES - i;
+	if (PartialBytes > ByteCount) {
+		PartialBytes = ByteCount;
+	}
+
+	/* Calculate the number of bytes remaining after the first push */
+	BytesLeft = ByteCount - PartialBytes;
+
+	/* Write to the hold and advance its index */
+	mHold_Advance(F, PartialBytes);
+
+	while (PartialBytes--) {
+		mHold_CopyIn(F, i, *SrcPtr);
+		SrcPtr++;
+		i++;
+	}
+
+	/* Push to fifo if needed */
+	if (mHoldS_IsFull(F)) {
+		mPush64(F);
+		mHoldS_SetEmpty(F);
+	}
+
+	/* No more data to process */
+	if (!BytesLeft) {
+		return;
+	}
+
+	/* Stage 2: The hold is empty now, if any more bytes are left to process, then
+	 * it will begin with nothing in the hold. Use the hold as a temporary storage
+	 * area to contain the data.
+	 *
+	 * The hold is filled then pushed out to the FIFOs a number of times based on
+	 * how many bytes are left to process.
+	 */
+
+	/* Calculate the number of times a push will need to occur */
+	FifoTransfersLeft = BytesLeft / PFIFO_64BIT_WIDTH_BYTES;
+
+	/* Calculate the number of partial bytes left after this stage */
+	PartialBytes =
+	    BytesLeft - (FifoTransfersLeft * PFIFO_64BIT_WIDTH_BYTES);
+
+	/* Write to the hold and push data to the FIFO */
+	while (FifoTransfersLeft--) {
+		for (i = 0; i < PFIFO_64BIT_WIDTH_BYTES; i++) {
+			mHold_CopyIn(F, i, *SrcPtr);
+			SrcPtr++;
+		}
+		mPush64(F);
+	}
+
+	/* No more data to process
+	 * HoldIndex was left at 0 by stage 1, at this point, that is
+	 * still the correct value.
+	 */
+	if (!PartialBytes) {
+		return;
+	}
+
+	/* Stage 3: All that is left is to fill the hold with the remaining data
+	 * to be processed. There will be no push to the FIFO because there is not
+	 * enough data left to cause one.
+	 */
+
+	/* Write to the hold and push data to the FIFO */
+	for (i = 0; i < PartialBytes; i++) {
+		mHold_CopyIn(F, i, *SrcPtr);
+		SrcPtr++;
+	}
+
+	/* Set the hold's index to its final correct value */
+	mHold_SetIndex(F, PartialBytes);
+}
+
+/*******************************************************************************
+* Write directly to the 64 bit wide transmit FIFO from an aligned source
+* buffer. Leftover bytes are written to the holding buffer.
+*
+* @param F is a pointer to the packet FIFO instance to be worked on.
+* @param BufPtr is the source buffer address on 32-bit alignment
+* @param ByteCount is the number of bytes to transfer
+*
+*******************************************************************************/
+static void Write64_Aligned(XTemac_PacketFifo * F, u32 * BufPtr, u32 ByteCount)
+{
+	unsigned FifoTransfersLeft = ByteCount / PFIFO_64BIT_WIDTH_BYTES;
+	unsigned PartialBytes = ByteCount & (PFIFO_64BIT_WIDTH_BYTES - 1);
+
+	/* Direct transfer */
+	while (FifoTransfersLeft--) {
+		mWriteFifo64(F, BufPtr);
+		BufPtr += 2;
+	}
+
+	/* Leftover bytes are left in the holding area */
+	if (PartialBytes) {
+		Write64_Unaligned(F, BufPtr, PartialBytes);
+	}
+}
+
+/*******************************************************************************
+* Read into the 64 bit holding buffer from the receive packet FIFO.
+* Each time the holding buffer becomes full, then it is flushed to the
+* provided buffer.
+*
+* @param F is a pointer to the packet FIFO instance to be worked on.
+* @param BufPtr is the destination buffer address on any alignment
+* @param ByteCount is the number of bytes to transfer
+*
+*******************************************************************************/
+static void Read64_Unaligned(XTemac_PacketFifo * F, void *BufPtr, u32 ByteCount)
+{
+	u8 *DestPtr = (u8 *) BufPtr;
+	unsigned FifoTransfersLeft;
+	unsigned PartialBytes;
+	unsigned BytesLeft;
+	int i;
+
+	/* Stage 1: The hold may have some residual bytes that must be flushed
+	 * to the buffer before anything is read from the FIFO
+	 */
+
+	/* Calculate the number of bytes to flush to the buffer from the hold.
+	 * If the number of bytes to flush is greater than the "Bytes" requested,
+	 * then adjust accordingly.
+	 */
+	i = mHold_GetIndex(F);
+	PartialBytes = PFIFO_64BIT_WIDTH_BYTES - i;
+
+	if (PartialBytes > ByteCount) {
+		PartialBytes = ByteCount;
+	}
+
+	/* Calculate the number of bytes remaining after flushing to the buffer */
+	BytesLeft = ByteCount - PartialBytes;
+
+	/* Move the hold's index forward */
+	mHold_Advance(F, PartialBytes);
+
+	/* Copy bytes */
+	while (PartialBytes--) {
+		mHold_CopyOut(F, i, *DestPtr);
+		i++;
+		DestPtr++;
+	}
+
+	/* No more data to process */
+	if (!BytesLeft) {
+		return;
+	}
+
+	/* Stage 2: The hold is empty now, if any more bytes are left to process, then
+	 * it will begin with nothing in the hold. Use the hold as a temporary storage
+	 * area to contain the data.
+	 *
+	 * The hold is filled with FIFO data, then that data is written to the buffer.
+	 * Do this FifoTransfersLeft times
+	 */
+
+	/* Calculate the number of times a push will need to occur */
+	FifoTransfersLeft = BytesLeft / PFIFO_64BIT_WIDTH_BYTES;
+
+	/* Calculate the number of partial bytes left after this stage */
+	PartialBytes =
+	    BytesLeft - (FifoTransfersLeft * PFIFO_64BIT_WIDTH_BYTES);
+
+	/* Write to the hold and push data to the FIFO */
+	while (FifoTransfersLeft--) {
+		/* Load the hold with the next data set from the FIFO */
+		mPop64(F);
+
+		/* Write hold to buffer */
+		for (i = 0; i < PFIFO_64BIT_WIDTH_BYTES; i++) {
+			mHold_CopyOut(F, i, *DestPtr);
+			DestPtr++;
+		}
+	}
+
+	/* No more data to process
+	 * After processing full FIFO chunks of data, the hold is empty at this
+	 * point
+	 */
+	if (!PartialBytes) {
+		return;
+	}
+
+	/* Stage 3: All that is left is to fill the hold one more time with FIFO
+	 * data, then write the remaining requested bytes to the buffer
+	 */
+
+	/* Get FIFO data */
+	mPop64(F);
+
+	/* Copy bytes from the hold to the buffer */
+	for (i = 0; i < PartialBytes; i++) {
+		mHold_CopyOut(F, i, *DestPtr);
+		DestPtr++;
+	}
+
+	/* Set the hold's index to its final correct value */
+	mHold_SetIndex(F, PartialBytes);
+}
+
+/*******************************************************************************
+* Read directly from the 64 bit wide receive FIFO into an aligned destination
+* buffer. Leftover bytes are written to the holding buffer.
+*
+* @param F is a pointer to the packet FIFO instance to be worked on.
+* @param BufPtr is the destination buffer address on 32-bit alignment
+* @param ByteCount is the number of bytes to transfer
+*
+*******************************************************************************/
+static void Read64_Aligned(XTemac_PacketFifo * F, u32 * BufPtr, u32 ByteCount)
+{
+	unsigned FifoTransfersLeft = ByteCount / PFIFO_64BIT_WIDTH_BYTES;
+	unsigned PartialBytes = ByteCount & (PFIFO_64BIT_WIDTH_BYTES - 1);
+
+	/* Direct transfer */
+	while (FifoTransfersLeft--) {
+		mReadFifo64(F, BufPtr);
+		BufPtr += 2;
+	}
+
+	/* Leftover bytes are left in the holding area */
+	if (PartialBytes) {
+		Read64_Unaligned(F, BufPtr, PartialBytes);
+	}
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_i.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_i.h
@@ -0,0 +1,112 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_i.h
+*
+* This header file contains internal identifiers, which are those shared
+* between XTemac components. The identifiers in this file are not intended for
+* use external to the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XTEMAC_I_H		/* prevent circular inclusions */
+#define XTEMAC_I_H		/* by using protection macros */
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+
+/************************** Constant Definitions *****************************/
+
+/* Internal flags kept in Instance's Flags attribute */
+#define XTE_FLAGS_RECV_SGDMA_INT_ENABLE   0x0020
+#define XTE_FLAGS_SEND_SGDMA_INT_ENABLE   0x0010
+#define XTE_FLAGS_RECV_DMA_INT_ENABLE     0x0008
+#define XTE_FLAGS_SEND_DMA_INT_ENABLE     0x0004
+#define XTE_FLAGS_RECV_FIFO_INT_ENABLE    0x0002
+#define XTE_FLAGS_SEND_FIFO_INT_ENABLE    0x0001
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************
+* Statistics increment macros
+******************************************************************************/
+#define XTemac_mBumpStats(Counter, Value) \
+    InstancePtr->Stats.Counter += (Value);
+
+/*****************************************************************************
+* Register accessors.
+*
+* The goal of these four functions is to make the code look cleaner. These
+* simply wrap to the level 0 macros defined in xtemac_l.h.
+*
+* The referenced InstancePtr is an implicitly assumed parameter.
+*
+******************************************************************************/
+#define XTemac_mGetHostReg(RegOffset) \
+    XTemac_mReadHostReg(InstancePtr->BaseAddress, RegOffset)
+
+#define XTemac_mSetHostReg(RegOffset, Data) \
+    XTemac_mWriteHostReg(InstancePtr->BaseAddress, RegOffset, Data)
+
+#define XTemac_mGetIpifReg(RegOffset) \
+    XTemac_mReadReg(InstancePtr->BaseAddress, RegOffset)
+
+#define XTemac_mSetIpifReg(RegOffset, Data) \
+    XTemac_mWriteReg(InstancePtr->BaseAddress, RegOffset, Data)
+
+/************************** Function Prototypes ******************************/
+
+XStatus XTemac_ConfigureFifoAccess(XTemac * InstancePtr);
+
+/************************** Variable Definitions *****************************/
+
+#endif				/* end of protection macro */
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr.c
@@ -0,0 +1,170 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_intr.c
+*
+* Functions in this file implement general purpose interrupt processing related
+* functionality. See xtemac.h for a detailed description of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+ * Install an asynchronious handler function for the given HandlerType:
+ *
+ * <pre>
+ * HandlerType               Function Type
+ * ------------------------  ---------------------------
+ * XTE_HANDLER_FIFOSEND      XTemac_FifoSendHandler
+ * XTE_HANDLER_FIFORECV      XTemac_FifoRecvHandler
+ * XTE_HANDLER_FIFODMAWRITE  XTemac_FifoDmaWriteHandler
+ * XTE_HANDLER_FIFODMAREAD   XTemac_FifoDmaReadHandler
+ * XTE_HANDLER_SGSEND        XTemac_SgHandler
+ * XTE_HANDLER_SGRECV        XTemac_SgHandler
+ * XTE_HANDLER_ERROR         XTemac_ErrorHandler
+ *
+ * HandlerType               Invoked by this driver when:
+ * ------------------------  --------------------------------------------------
+ * XTE_HANDLER_FIFOSEND      A packet transmitted by a call to
+ *                           XTemac_FifoSend() has been sent successfully.
+ * XTE_HANDLER_FIFORECV      When a packet has been received and is sitting in
+ *                           the packet FIFO.
+ * XTE_HANDLER_FIFODMAWRITE  A DMA transfer from a user buffer to the packet
+ *                           FIFO has completed. See XTemac_FifoDmaWrite().
+ * XTE_HANDLER_FIFODMAREAD   A DMA transfer from the packet FIFO to a use
+ *                           buffer has completed. See XTemac_FifoDmaRead().
+ * XTE_HANDLER_SGSEND        SG DMA has completed an operation on the transmit
+ *                           side. Transmitted buffer descriptors require post
+ *                           processing.
+ * XTE_HANDLER_SGRECV        SG DMA has completed an operation on the receive
+ *                           side. Buffer descriptors contain received packets.
+ * XTE_HANDLER_ERROR         Any type of error has been detected.
+ * </pre>
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param HandlerType specifies which handler is to be attached.
+ * @param CallbackFunc is the address of the callback function
+ * @param CallbackRef is a user data item that will be passed to the callback
+ *        when it is invoked.
+ *
+ * @return
+ * - XST_SUCCESS when handler is installed.
+ * - XST_INVALID_PARAM when HandlerType is invalid
+ *
+ * @note
+ * Invoking this function for a handler that already has been installed replaces
+ * it with the new handler.
+ *
+ ******************************************************************************/
+XStatus XTemac_SetHandler(XTemac * InstancePtr, u32 HandlerType,
+			  void *CallbackFunc, void *CallbackRef)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_NONVOID(CallbackFunc != NULL);
+
+	switch (HandlerType) {
+	case XTE_HANDLER_FIFOSEND:
+		InstancePtr->FifoSendHandler =
+		    (XTemac_FifoSendHandler) CallbackFunc;
+		InstancePtr->FifoSendRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_FIFORECV:
+		InstancePtr->FifoRecvHandler =
+		    (XTemac_FifoRecvHandler) CallbackFunc;
+		InstancePtr->FifoRecvRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_FIFODMAWRITE:
+		InstancePtr->FifoDmaWriteHandler =
+		    (XTemac_FifoDmaWriteHandler) CallbackFunc;
+		InstancePtr->FifoDmaWriteRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_FIFODMAREAD:
+		InstancePtr->FifoDmaReadHandler =
+		    (XTemac_FifoDmaReadHandler) CallbackFunc;
+		InstancePtr->FifoDmaReadRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_SGSEND:
+		InstancePtr->SgSendHandler = (XTemac_SgHandler) CallbackFunc;
+		InstancePtr->SgSendRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_SGRECV:
+		InstancePtr->SgRecvHandler = (XTemac_SgHandler) CallbackFunc;
+		InstancePtr->SgRecvRef = CallbackRef;
+		break;
+
+	case XTE_HANDLER_ERROR:
+		InstancePtr->ErrorHandler = (XTemac_ErrorHandler) CallbackFunc;
+		InstancePtr->ErrorRef = CallbackRef;
+		break;
+
+	default:
+		return (XST_INVALID_PARAM);
+
+	}
+	return (XST_SUCCESS);
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr_fifo.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr_fifo.c
@@ -0,0 +1,498 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_intr_fifo.c
+*
+* Functions in this file implement interrupt related operations for
+* FIFO direct frame transfer mode. See xtemac.h for a detailed description of
+* the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/* shortcut macros */
+#define ERR_HANDLER(Class, Word1, Word2)  \
+    InstancePtr->ErrorHandler(InstancePtr->ErrorRef, Class, Word1, Word2)
+
+#define FIFOSEND_HANDLER(Cnt)  \
+    InstancePtr->FifoSendHandler(InstancePtr->FifoSendRef, Cnt)
+
+#define FIFORECV_HANDLER()  \
+    InstancePtr->FifoRecvHandler(InstancePtr->FifoRecvRef)
+
+#define DMAWRITE_HANDLER(Bytes)  \
+    InstancePtr->FifoDmaWriteHandler(InstancePtr->FifoDmaWriteRef, Bytes)
+
+#define DMAREAD_HANDLER(Bytes)  \
+    InstancePtr->FifoDmaReadHandler(InstancePtr->FifoDmaReadRef, Bytes)
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+ *
+ * Enable FIFO related interrupts for FIFO direct frame transfer mode. Dma
+ * interrupts are not affected.
+ *
+ * Do not use this function when using SG DMA frame transfer mode.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction specifies whether the transmit related (XTE_SEND) or
+ *        receive related (XTE_RECV) interrupts should be affected, or
+ *        both (XTE_SEND | XTE_RECV).
+ *
+ * @return None
+ *
+ * @note The state of the transmitter and receiver are not modified by this
+ *       function.
+ *
+ * @note If the device is configured for SGDMA, then this function has no
+ *       effect. Use XTemac_IntrSgDmaDisable() instead.
+ *
+ ******************************************************************************/
+void XTemac_IntrFifoEnable(XTemac * InstancePtr, u32 Direction)
+{
+	u32 RegIPIER;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	/* Don't allow if device is configured for SGDMA */
+	if (XTemac_mIsSgDma(InstancePtr)) {
+		return;
+	}
+
+	/* Get contents of IPIER register */
+	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+
+	/* Handle send direction */
+	if (Direction & XTE_SEND) {
+		RegIPIER |=
+		    (XTE_IPXR_XMIT_ERROR_MASK | XTE_IPXR_XMIT_DONE_MASK);
+		InstancePtr->Flags |= XTE_FLAGS_SEND_FIFO_INT_ENABLE;
+
+		/* Don't allow Tx status overrun interrupt if option is cleared */
+		if (!
+		    (InstancePtr->
+		     Options & XTE_REPORT_TXSTATUS_OVERRUN_OPTION)) {
+			RegIPIER &= ~XTE_IPXR_XMIT_SFIFO_OVER_MASK;;
+		}
+	}
+
+	/* Handle receive direction */
+	if (Direction & XTE_RECV) {
+		RegIPIER |=
+		    (XTE_IPXR_RECV_ERROR_MASK | XTE_IPXR_RECV_DONE_MASK);
+		InstancePtr->Flags |= XTE_FLAGS_RECV_FIFO_INT_ENABLE;
+
+		/* Don't enable recv reject errors if option is cleared */
+		if (!(InstancePtr->Options & XTE_REPORT_RXERR_OPTION)) {
+			RegIPIER &= ~XTE_IPXR_RECV_DROPPED_MASK;
+		}
+	}
+
+	/* Update IPIER with new setting */
+	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
+}
+
+/*****************************************************************************/
+/**
+ *
+ * Disable FIFO related interrupts for FIFO direct frame transfer mode. Dma
+ * interrupts are not affected.
+ *
+ * Do not use this function when using SG DMA frame transfer mode.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction specifies whether the transmit related (XTE_SEND) or
+ *        receive related (XTE_RECV) interrupts should be affected, or
+ *        both (XTE_SEND | XTE_RECV).
+ *
+ * @return None
+ *
+ * @note The state of the transmitter and receiver are not modified by this
+ *       function.
+ *
+ * @note If the device is configured for SGDMA, then this function has no
+ *       effect. Use XTemac_IntrSgDmaDisable() instead.
+ *
+ ******************************************************************************/
+void XTemac_IntrFifoDisable(XTemac * InstancePtr, u32 Direction)
+{
+	u32 RegIPIER;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	/* Don't allow if device is configured for SGDMA */
+	if (XTemac_mIsSgDma(InstancePtr)) {
+		return;
+	}
+
+	/* Get contents of IPIER register */
+	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+
+	/* Handle send direction */
+	if (Direction & XTE_SEND) {
+		RegIPIER &=
+		    ~(XTE_IPXR_XMIT_ERROR_MASK | XTE_IPXR_XMIT_DONE_MASK);
+		InstancePtr->Flags &= ~XTE_FLAGS_SEND_FIFO_INT_ENABLE;
+	}
+
+	/* Handle receive direction */
+	if (Direction & XTE_RECV) {
+		RegIPIER &=
+		    ~(XTE_IPXR_RECV_ERROR_MASK | XTE_IPXR_RECV_DONE_MASK);
+		InstancePtr->Flags &= ~XTE_FLAGS_RECV_FIFO_INT_ENABLE;
+	}
+
+	/* Update IPIER with new setting */
+	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
+}
+
+/*****************************************************************************/
+/**
+ *
+ * Enable DMA related interrupts for FIFO direct frame transfer mode. FIFO
+ * interrupts are not affected.
+ *
+ * Do not use this function when using SG DMA frame transfer mode.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction specifies whether interrupts related to the transfer of
+ *        data from a user buffer to the packet FIFO (XTE_SEND), or transfer of
+ *        data from the packet FIFO to a user buffer (XTE_RECV) should be
+ *        affected, or both (XTE_SEND | XTE_RECV).
+ *
+ * @return None
+ *
+ * @note The state of the transmitter and receiver are not modified by this
+ *       function.
+ *
+ ******************************************************************************/
+void XTemac_IntrFifoDmaEnable(XTemac * InstancePtr, u32 Direction)
+{
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	if (Direction & XTE_SEND) {
+		XDmaV2_SetInterruptEnable(&InstancePtr->SendDma,
+					  XDMAV2_IPXR_DD_MASK |
+					  XDMAV2_IPXR_DE_MASK);
+		InstancePtr->Flags |= XTE_FLAGS_SEND_DMA_INT_ENABLE;
+	}
+
+	if (Direction & XTE_RECV) {
+		XDmaV2_SetInterruptEnable(&InstancePtr->RecvDma,
+					  XDMAV2_IPXR_DD_MASK |
+					  XDMAV2_IPXR_DE_MASK);
+		InstancePtr->Flags |= XTE_FLAGS_RECV_DMA_INT_ENABLE;
+	}
+}
+
+/*****************************************************************************/
+/**
+ *
+ * Disable DMA related interrupts for FIFO direct frame transfer mode. FIFO
+ * interrupts are not affected.
+ *
+ * Do not use this function when using the SG DMA frame transfer mode.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction specifies whether interrupts related to the transfer of
+ *        data from a user buffer to the packet FIFO (XTE_SEND), or transfer of
+ *        data from the packet FIFO to a user buffer (XTE_RECV) should be
+ *        affected, or both (XTE_SEND | XTE_RECV).
+ *
+ * @return None
+ *
+ * @note The state of the transmitter and receiver are not modified by this
+ *       function.
+ *
+ ******************************************************************************/
+void XTemac_IntrFifoDmaDisable(XTemac * InstancePtr, u32 Direction)
+{
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	if (Direction & XTE_SEND) {
+		XDmaV2_SetInterruptEnable(&InstancePtr->SendDma, 0);
+		InstancePtr->Flags &= ~XTE_FLAGS_SEND_DMA_INT_ENABLE;
+	}
+
+	if (Direction & XTE_RECV) {
+		XDmaV2_SetInterruptEnable(&InstancePtr->RecvDma, 0);
+		InstancePtr->Flags &= ~XTE_FLAGS_RECV_DMA_INT_ENABLE;
+	}
+}
+
+/*****************************************************************************/
+/**
+ *
+ * Master interrupt handler for FIFO direct frame transfer mode. This routine
+ * will query the status of the device, bump statistics, and invoke user
+ * callbacks in the following priority:
+ *
+ *  - XTE_HANDLER_ERROR for error class XST_PFIFO_DEADLOCK.
+ *  - XTE_HANDLER_ERROR for error class XST_DMA_ERROR for reads.
+ *  - XTE_HANDLER_FIFODMAREAD for successfull DMA reads
+ *  - XTE_HANDLER_ERROR for error class XST_DMA_ERROR for writes.
+ *  - XTE_HANDLER_FIFODMAWRITE for successfull DMA writes
+ *  - XTE_HANDLER_ERROR for error class XST_FIFO_ERROR.
+ *  - XTE_HANDLER_FIFORECV for newly received frames
+ *  - XTE_HANDLER_ERROR for error class XST_SEND_ERROR.
+ *  - XTE_HANDLER_FIFOSEND for completed transmits
+ *  - XTE_HANDLER_ERROR for error class XST_RECV_ERROR.
+ *
+ * This routine must be connected to an interrupt controller using OS/BSP
+ * specific methods.
+ *
+ * @param InstancePtr is a pointer to the TEMAC instance that has caused the
+ *        interrupt.
+ *
+ * @return None
+ *
+ ******************************************************************************/
+void XTemac_IntrFifoHandler(void *TemacPtr)
+{
+	u32 RegDISR;
+	u32 CorePending;
+	u32 RegMisc;
+	u32 Bytes;
+	unsigned Cnt;
+	XTemac *InstancePtr = (XTemac *) TemacPtr;
+
+	XASSERT_VOID(InstancePtr != NULL);
+
+	/* This ISR will try to handle as many interrupts as it can in a single
+	 * call. However, in most of the places where the user's error handler is
+	 * called, this ISR exits because it is expected that the user will reset
+	 * the device most of the time.
+	 */
+
+	/* Log interrupt */
+	XTemac_mBumpStats(Interrupts, 1);
+
+	/* Get top level interrupt status. The status is self clearing when the
+	 * interrupt source is cleared
+	 */
+	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
+
+	/* Handle IPIF and packet FIFO errors */
+	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK |
+		       XTE_DXR_RECV_FIFO_MASK | XTE_DXR_SEND_FIFO_MASK)) {
+		/* IPIF transaction or data phase error */
+		if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
+			XTemac_mBumpStats(IpifErrors, 1);
+			ERR_HANDLER(XST_IPIF_ERROR, RegDISR, 0);
+			return;
+		}
+
+		/* Receive packet FIFO is deadlocked */
+		if (RegDISR & XTE_DXR_RECV_FIFO_MASK) {
+			XTemac_mBumpStats(RxPktFifoErrors, 1);
+			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_RECV, 0);
+			return;
+		}
+
+		/* Transmit packet FIFO is deadlocked */
+		if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
+			XTemac_mBumpStats(TxPktFifoErrors, 1);
+			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_SEND, 0);
+			return;
+		}
+	}
+
+	/* Handle receive side simple DMA channel interrupt. Read and ack the
+	 * DMA's interrupt status. If an error is indicated then call the
+	 * error handler. If a transfer complete is indicated then call the
+	 * DMA read handler
+	 */
+	if (RegDISR & XTE_DXR_RECV_DMA_MASK) {
+		RegMisc = XDmaV2_GetInterruptStatus(&InstancePtr->RecvDma);
+		XDmaV2_SetInterruptStatus(&InstancePtr->RecvDma, RegMisc);
+
+		if (RegMisc & XDMAV2_IPXR_DE_MASK) {
+			XTemac_mBumpStats(RxDmaErrors, 1);
+			ERR_HANDLER(XST_DMA_ERROR, XTE_RECV,
+				    XDmaV2_mGetStatus(&InstancePtr->RecvDma));
+			return;
+		}
+
+		if (RegMisc & XDMAV2_IPXR_DD_MASK) {
+			Bytes = InstancePtr->DmaReadLengthRef;
+			InstancePtr->DmaReadLengthRef = 0;
+			DMAREAD_HANDLER(Bytes);
+		}
+	}
+
+	/* Handle send side simple DMA channel interrupt. Read and ack the
+	 * DMA's interrupt status. If an error is indicated then call the
+	 * error handler. If a transfer complete is indicated then call the
+	 * DMA write handler
+	 */
+	if (RegDISR & XTE_DXR_SEND_DMA_MASK) {
+		RegMisc = XDmaV2_GetInterruptStatus(&InstancePtr->SendDma);
+		XDmaV2_SetInterruptStatus(&InstancePtr->SendDma, RegMisc);
+
+		if (RegMisc & XDMAV2_IPXR_DE_MASK) {
+			XTemac_mBumpStats(TxDmaErrors, 1);
+			ERR_HANDLER(XST_DMA_ERROR, XTE_SEND,
+				    XDmaV2_mGetStatus(&InstancePtr->SendDma));
+			return;
+		}
+
+		if (RegMisc & XDMAV2_IPXR_DD_MASK) {
+			Bytes = InstancePtr->DmaWriteLengthRef;
+			InstancePtr->DmaWriteLengthRef = 0;
+			DMAWRITE_HANDLER(Bytes);
+		}
+	}
+
+	/* Handle core interrupts */
+	if (RegDISR & XTE_DXR_CORE_MASK) {
+		/* Calculate which enabled interrupts have been asserted */
+		CorePending = XTemac_mGetIpifReg(XTE_IPIER_OFFSET) &
+		    XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+
+		/* Check for fatal status/length FIFO errors. These errors can't be
+		 * cleared
+		 */
+		if (CorePending & XTE_IPXR_FIFO_FATAL_ERROR_MASK) {
+			XTemac_mBumpStats(FifoErrors, 1);
+			ERR_HANDLER(XST_FIFO_ERROR, CorePending &
+				    XTE_IPXR_FIFO_FATAL_ERROR_MASK, 0);
+			return;
+		}
+
+		/* A receive packet has arrived. Call the receive handler.
+		 *
+		 * Acking this interrupt is not done here. The handler has a choice:
+		 * 1) Call XTemac_FifoRecv() which will ack this interrupt source, or
+		 * 2) Call XTemac_IntrFifoDisable() and defer XTEmac_FifoRecv() to a
+		 * later time. Failure to do one of these actions will leave this
+		 * interupt still pending resulting in an exception loop.
+		 */
+		if (CorePending & XTE_IPXR_RECV_DONE_MASK) {
+			FIFORECV_HANDLER();
+		}
+
+		/* A transmit has completed. Pull off all statuses that are available.
+		 * For each status that contains a non-fatal error, the error handler
+		 * is invoked. For fatal errors, the error handler is invoked once and
+		 * assumes the callback will reset the device.
+		 *
+		 * Unless there was a fatal error, then call the send handler since
+		 * resources in the packet FIFO, transmit length FIFO, and transmit
+		 * status FIFO have been freed up. This gives the handler a chance
+		 * to enqueue new frame(s).
+		 */
+		if (CorePending & XTE_IPXR_XMIT_DONE_MASK) {
+			Cnt = 0;
+
+			/* While XMIT_DONE persists */
+			do {
+				/* Get TSR, try to clear XMIT_DONE */
+				RegMisc = XTemac_mGetIpifReg(XTE_TSR_OFFSET);
+				XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+						   XTE_IPXR_XMIT_DONE_MASK);
+
+				/* Does TSR indicate error? */
+				if (RegMisc & XTE_TSR_ERROR_MASK) {
+					XTemac_mBumpStats(TxStatusErrors, 1);
+					ERR_HANDLER(XST_SEND_ERROR, RegMisc, 0);
+
+					/* Fatal errors end processing immediately */
+					if (RegMisc & XTE_TSR_PFIFOU_MASK) {
+						return;
+					}
+				}
+
+				Cnt++;
+
+				/* Read IPISR and test XMIT_DONE again */
+				RegMisc = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+			} while (RegMisc & XTE_IPXR_XMIT_DONE_MASK);
+
+			FIFOSEND_HANDLER(Cnt);
+		}
+
+		/* Check for dropped receive frame. Ack the interupt then call the
+		 * error handler
+		 */
+		if (CorePending & XTE_IPXR_RECV_DROPPED_MASK) {
+			XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+					   CorePending &
+					   XTE_IPXR_RECV_DROPPED_MASK);
+
+			XTemac_mBumpStats(RxRejectErrors, 1);
+			ERR_HANDLER(XST_RECV_ERROR,
+				    CorePending & XTE_IPXR_RECV_DROPPED_MASK,
+				    0);
+
+			/* no return here, nonfatal error */
+		}
+	}
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr_sgdma.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_intr_sgdma.c
@@ -0,0 +1,468 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_intr_sgdma.c
+*
+* Functions in this file implement interrupt related operations for
+* scatter gather DMA packet transfer mode. See xtemac.h for a detailed
+* description of the driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/* shortcut macros */
+#define ERR_HANDLER(Class, Word1, Word2)  \
+    InstancePtr->ErrorHandler(InstancePtr->ErrorRef, Class, Word1, Word2)
+
+#define SGSEND_HANDLER() \
+    InstancePtr->SgSendHandler(InstancePtr->SgSendRef)
+
+#define SGRECV_HANDLER() \
+    InstancePtr->SgRecvHandler(InstancePtr->SgRecvRef)
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* Enable DMA related interrupts for SG DMA frame transfer mode.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Direction specifies whether the transmit related (XTE_SEND) or
+*        receive related (XTE_RECV) interrupts should be affected, or
+*        both (XTE_SEND | XTE_RECV).
+*
+* @note
+* The state of the transmitter and receiver are not modified by this function.
+*
+******************************************************************************/
+void XTemac_IntrSgEnable(XTemac * InstancePtr, u32 Direction)
+{
+	u32 RegIPIER;
+	u32 RegDmaIER;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	/* Default DMA mask */
+	RegDmaIER = XDMAV2_IPXR_PCTR_MASK |
+	    XDMAV2_IPXR_PWBR_MASK | XDMAV2_IPXR_DE_MASK;
+
+	/* Add to dma mask if SGEND option is enabled */
+	if (InstancePtr->Options & XTE_SGEND_INT_OPTION) {
+		RegDmaIER |= XDMAV2_IPXR_SGEND_MASK;
+	}
+
+	/* Get current contents of core's IER. Depending on direction(s)
+	 * specified, status/length FIFO error interrupt enables will be enabled
+	 */
+	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+
+	/* Set interrupts for transmit DMA channel */
+	if (Direction & XTE_SEND) {
+		/* DMA interrupt enable */
+		XDmaV2_SetInterruptEnable(&InstancePtr->SendDma, RegDmaIER);
+		InstancePtr->Flags |= XTE_FLAGS_SEND_SGDMA_INT_ENABLE;
+
+		/* Mask in core's transmit interrupt enables */
+		RegIPIER |= XTE_IPXR_XMIT_ERROR_MASK;
+
+		/* Don't allow Tx status overrun interrupt if option is cleared */
+		if (!
+		    (InstancePtr->
+		     Options & XTE_REPORT_TXSTATUS_OVERRUN_OPTION)) {
+			RegIPIER &= ~XTE_IPXR_XMIT_SFIFO_OVER_MASK;;
+		}
+	}
+
+	/* Set interrupts for receive DMA channel */
+	if (Direction & XTE_RECV) {
+		/* DMA interrupt enable */
+		XDmaV2_SetInterruptEnable(&InstancePtr->RecvDma, RegDmaIER);
+		InstancePtr->Flags |= XTE_FLAGS_RECV_SGDMA_INT_ENABLE;
+
+		/* Mask in core's receive interrupt enables */
+		RegIPIER |= XTE_IPXR_RECV_ERROR_MASK;
+
+		/* Don't enable recv reject errors if option is cleared */
+		if (!(InstancePtr->Options & XTE_REPORT_RXERR_OPTION)) {
+			RegIPIER &= ~XTE_IPXR_RECV_DROPPED_MASK;
+		}
+	}
+
+	/* Update core interrupt enables */
+	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
+}
+
+/*****************************************************************************/
+/**
+*
+* Disable DMA related interrupts for SG DMA frame transfer mode.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Direction specifies whether the transmit related (XTE_SEND) or
+*        receive related (XTE_RECV) interrupts should be affected, or
+*        both (XTE_SEND | XTE_RECV).
+*
+* @note
+* The state of the transmitter and receiver are not modified by this function.
+*
+******************************************************************************/
+void XTemac_IntrSgDisable(XTemac * InstancePtr, u32 Direction)
+{
+	u32 RegIPIER;
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
+
+	/* Get contents of IPIER register */
+	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
+
+	if (Direction & XTE_SEND) {
+		/* Disable DMA channel interrupt */
+		XDmaV2_SetInterruptEnable(&InstancePtr->SendDma, 0);
+		InstancePtr->Flags &= ~XTE_FLAGS_SEND_SGDMA_INT_ENABLE;
+
+		/* Mask out length/status FIFO errors on transmit side */
+		RegIPIER &= ~XTE_IPXR_XMIT_ERROR_MASK;
+	}
+
+	if (Direction & XTE_RECV) {
+		/* Disable DMA channel interrupt */
+		XDmaV2_SetInterruptEnable(&InstancePtr->RecvDma, 0);
+		InstancePtr->Flags &= ~XTE_FLAGS_RECV_SGDMA_INT_ENABLE;
+
+		/* Mask out length/status FIFO errors on receive side */
+		RegIPIER &= ~XTE_IPXR_RECV_ERROR_MASK;
+	}
+
+	/* Update IPIER with new setting */
+	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
+}
+
+/*****************************************************************************/
+/**
+*
+* Set the SGDMA interrupt coalescing parameters. The device must be stopped
+* before setting these parameters. See xtemac.h for a complete discussion of
+* the interrupt coalescing features of this device.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Direction indicates the channel, XTE_SEND or XTE_RECV, to set.
+* @param Threshold is the value of the packet threshold count used during
+*        interrupt coalescing. Valid range is 0 - 1023. A value of 0 disables
+*        the use of packet threshold by the hardware.
+* @param Timer is the waitbound timer value in units of approximately
+*        milliseconds. Valid range is 0 - 1023. A value of 0 disables the use
+*        of the waitbound timer by the hardware.
+*
+* @return
+* - XST_SUCCESS if the threshold was successfully set
+* - XST_NO_FEATURE if the MAC is not configured for scatter-gather DMA
+* - XST_DEVICE_IS_STARTED if the device has not been stopped
+* - XST_INVALID_PARAM if Direction does not indicate a valid channel
+*
+******************************************************************************/
+XStatus XTemac_IntrSgCoalSet(XTemac * InstancePtr, u32 Direction,
+			     u16 Threshold, u16 Timer)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Must be SGDMA */
+	if (!XTemac_mIsSgDma(InstancePtr)) {
+		return (XST_NO_FEATURE);
+	}
+
+	/* Device must be stopped before changing these settings */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Set HW */
+	if (Direction == XTE_SEND) {
+		(void)XDmaV2_SgSetPktThreshold(&InstancePtr->SendDma,
+					       Threshold);
+		XDmaV2_SgSetPktWaitbound(&InstancePtr->SendDma, Timer);
+	} else if (Direction == XTE_RECV) {
+		(void)XDmaV2_SgSetPktThreshold(&InstancePtr->RecvDma,
+					       Threshold);
+		XDmaV2_SgSetPktWaitbound(&InstancePtr->RecvDma, Timer);
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+*
+* Get the current interrupt coalescing settings. See xtemac.h for more
+* discussion of interrupt coalescing features.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Direction indicates the channel, XTE_SEND or XTE_RECV, to get.
+* @param ThresholdPtr is a pointer to the word into which the current value of
+*        the packet threshold will be copied.
+* @param TimerPtr is a pointer to the word into which the current value of the
+*        waitbound timer will be copied.
+*
+* @return
+* - XST_SUCCESS if the packet threshold was retrieved successfully
+* - XST_NO_FEATURE if the MAC is not configured for scatter-gather DMA
+* - XST_INVALID_PARAM if Direction does not indicate a valid channel
+*
+******************************************************************************/
+XStatus XTemac_IntrSgCoalGet(XTemac * InstancePtr, u32 Direction,
+			     u16 * ThresholdPtr, u16 * TimerPtr)
+{
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(ThresholdPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Must be SGDMA */
+	if (!XTemac_mIsSgDma(InstancePtr)) {
+		return (XST_NO_FEATURE);
+	}
+
+	/* Get data from HW */
+	if (Direction == XTE_SEND) {
+		*ThresholdPtr = XDmaV2_SgGetPktThreshold(&InstancePtr->SendDma);
+		*TimerPtr = XDmaV2_SgGetPktWaitbound(&InstancePtr->SendDma);
+	} else if (Direction == XTE_RECV) {
+		*ThresholdPtr = XDmaV2_SgGetPktThreshold(&InstancePtr->RecvDma);
+		*TimerPtr = XDmaV2_SgGetPktWaitbound(&InstancePtr->RecvDma);
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	return (XST_SUCCESS);
+}
+
+/*****************************************************************************/
+/**
+* Master interrupt handler for SGDMA frame transfer mode. This routine will
+* query the status of the device, bump statistics, and invoke user callbacks
+* in the following priority:
+*
+*  - XTE_HANDLER_ERROR for error class XST_PFIFO_DEADLOCK.
+*  - XTE_HANDLER_ERROR for error class XST_FIFO_ERROR.
+*  - XTE_HANDLER_ERROR for error class XST_DMA_ERROR for the recv DMA channel
+*  - XTE_HANDLER_SGRECV for newly received frames
+*  - XTE_HANDLER_ERROR for error class XST_DMA_ERROR for the xmit DMA channel
+*  - XTE_HANDLER_SGSEND for completed transmits
+*  - XTE_HANDLER_ERROR for error class XST_RECV_ERROR.
+*
+* This routine must be connected to an interrupt controller using OS/BSP
+* specific methods.
+*
+* @param InstancePtr is a pointer to the TEMAC instance that has caused the
+*        interrupt.
+*
+******************************************************************************/
+void XTemac_IntrSgHandler(void *TemacPtr)
+{
+	u32 RegDISR;
+	u32 CorePending;
+	u32 RegDmaPending;
+	XTemac *InstancePtr = (XTemac *) TemacPtr;
+
+	XASSERT_VOID(InstancePtr != NULL);
+
+	/* This ISR will try to handle as many interrupts as it can in a single
+	 * call. However, in most of the places where the user's error handler is
+	 * called, this ISR exits because it is expected that the user will reset
+	 * the device in nearly all instances.
+	 */
+
+	/* Log interrupt */
+	XTemac_mBumpStats(Interrupts, 1);
+
+	/* Get top level interrupt status */
+	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
+
+	/* Handle IPIF and packet FIFO errors */
+	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK |
+		       XTE_DXR_RECV_FIFO_MASK | XTE_DXR_SEND_FIFO_MASK)) {
+		/* IPIF transaction or data phase error */
+		if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
+			XTemac_mBumpStats(IpifErrors, 1);
+			ERR_HANDLER(XST_IPIF_ERROR, RegDISR, 0);
+			return;
+		}
+
+		/* Receive packet FIFO is deadlocked */
+		if (RegDISR & XTE_DXR_RECV_FIFO_MASK) {
+			XTemac_mBumpStats(RxPktFifoErrors, 1);
+			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_RECV, 0);
+			return;
+		}
+
+		/* Transmit packet FIFO is deadlocked */
+		if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
+			XTemac_mBumpStats(TxPktFifoErrors, 1);
+			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_SEND, 0);
+			return;
+		}
+	}
+
+	/* Get currently pending core interrupts */
+	CorePending = XTemac_mGetIpifReg(XTE_IPIER_OFFSET) &
+	    XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
+
+	/* Check for fatal status/length FIFO errors. These errors can't be
+	 * cleared
+	 */
+	if (CorePending & XTE_IPXR_FIFO_FATAL_ERROR_MASK) {
+		XTemac_mBumpStats(FifoErrors, 1);
+		ERR_HANDLER(XST_FIFO_ERROR,
+			    CorePending & XTE_IPXR_FIFO_FATAL_ERROR_MASK, 0);
+		return;
+	}
+
+	/* Check for SGDMA receive interrupts */
+	if (RegDISR & XTE_DXR_RECV_DMA_MASK) {
+		/* Get interrupts pending */
+		RegDmaPending =
+		    XDmaV2_GetInterruptStatus(&InstancePtr->RecvDma);
+
+		/* Check for errors */
+		if (RegDmaPending & XDMAV2_IPXR_DE_MASK) {
+			XTemac_mBumpStats(RxDmaErrors, 1);
+			ERR_HANDLER(XST_DMA_ERROR, XTE_RECV,
+				    XDmaV2_mGetStatus(&InstancePtr->RecvDma));
+			return;
+		}
+
+		/* Check for packets processed */
+		if (RegDmaPending & (XDMAV2_IPXR_PCTR_MASK |
+				     XDMAV2_IPXR_PWBR_MASK |
+				     XDMAV2_IPXR_SGEND_MASK)) {
+			/* Invoke the user's receive handler. The handler may remove the
+			 * ready BDs from the list right away or defer until later
+			 */
+			SGRECV_HANDLER();
+		}
+
+		/* Ack interrupts. IPXR_PCTR is a special case. If the handler does not
+		 * yank BDs, then the unserviced packet count (UPC) will be unchanged.
+		 * So if UPC stays >= packet threshold, the interrupt remains pending
+		 * even if it is acked here. The ack must occur in XTemac_SgGet-
+		 * Processed() where packets are yanked.
+		 */
+		XDmaV2_SetInterruptStatus(&InstancePtr->RecvDma,
+					  RegDmaPending &
+					  ~XDMAV2_IPXR_PCTR_MASK);
+	}
+
+	/* Check for SGDMA transmit interrupts */
+	if (RegDISR & XTE_DXR_SEND_DMA_MASK) {
+		/* Get interrupts pending */
+		RegDmaPending =
+		    XDmaV2_GetInterruptStatus(&InstancePtr->SendDma);
+
+		/* Check for errors */
+		if (RegDmaPending & XDMAV2_IPXR_DE_MASK) {
+			XTemac_mBumpStats(TxDmaErrors, 1);
+			ERR_HANDLER(XST_DMA_ERROR, XTE_SEND,
+				    XDmaV2_mGetStatus(&InstancePtr->SendDma));
+			return;
+		}
+
+		/* Check for packets processed */
+		if (RegDmaPending & (XDMAV2_IPXR_PCTR_MASK |
+				     XDMAV2_IPXR_PWBR_MASK |
+				     XDMAV2_IPXR_SGEND_MASK)) {
+			/* Invoke the user's send handler. The handler may remove the
+			 * ready BDs from the list right away or defer until later
+			 */
+			SGSEND_HANDLER();
+		}
+
+		/* Ack interrupts. IPXR_PCTR is a special case. If the handler does not
+		 * yank BDs, then the unserviced packet count (UPC) will be unchanged.
+		 * So if UPC stays >= packet threshold, the interrupt remains pending
+		 * even if it is acked here. The ack must occur in XTemac_SgGet-
+		 * Processed() where packets are yanked.
+		 */
+		XDmaV2_SetInterruptStatus(&InstancePtr->SendDma,
+					  RegDmaPending &
+					  ~XDMAV2_IPXR_PCTR_MASK);
+	}
+
+	/* Check for dropped receive frame. Ack the interupt then call the
+	 * error handler
+	 */
+	if (CorePending & XTE_IPXR_RECV_DROPPED_MASK) {
+		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
+				   CorePending & XTE_IPXR_RECV_DROPPED_MASK);
+		XTemac_mBumpStats(RxRejectErrors, 1);
+		ERR_HANDLER(XST_RECV_ERROR,
+			    CorePending & XTE_IPXR_RECV_DROPPED_MASK, 0);
+
+		/* no return here, nonfatal error */
+	}
+
+	/* Ack top level interrupt status */
+	XTemac_mSetIpifReg(XTE_DISR_OFFSET, RegDISR);
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_l.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_l.c
@@ -0,0 +1,255 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_l.c
+*
+* This file contains low-level functions to send and receive Ethernet frames.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- ------------------------------------------------------
+* 1.00a rmm  06/01/05 First release
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac_l.h"
+#include "xpacket_fifo_l_v2_00_a.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+
+/*****************************************************************************/
+/**
+*
+* Reset and enable the transmitter and receiver. The contents of the Rx and Tx
+* control registers are preserved.
+*
+* @param BaseAddress is the base address of the device
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* If hardware is not behaving properly, then this function may never return.
+*
+******************************************************************************/
+void XTemac_Enable(u32 BaseAddress)
+{
+	u32 CR_save0;
+	u32 CR_save1;
+	volatile u32 CR;
+
+	/* Save contents of the Rx control registers, then reset the receiver */
+	CR_save0 = XTemac_mReadHostReg(BaseAddress, XTE_ERXC0_OFFSET);
+	CR_save1 = XTemac_mReadHostReg(BaseAddress, XTE_ERXC1_OFFSET);
+	XTemac_mWriteHostReg(BaseAddress, XTE_ERXC1_OFFSET,
+			     XTE_ERXC1_RXRST_MASK);
+
+	/* Wait for the receiver to finish reset */
+	do {
+		CR = XTemac_mReadHostReg(BaseAddress, XTE_ERXC1_OFFSET);
+	} while (CR & XTE_ERXC1_RXRST_MASK);
+
+	/* Restore contents of Rx control registers, enable receiver */
+	XTemac_mWriteHostReg(BaseAddress, XTE_ERXC0_OFFSET, CR_save0);
+	XTemac_mWriteHostReg(BaseAddress, XTE_ERXC1_OFFSET,
+			     CR_save1 | XTE_ERXC1_RXEN_MASK);
+
+	/* Save contents of the Tx control register, then reset the transmitter */
+	CR_save0 = XTemac_mReadHostReg(BaseAddress, XTE_ETXC_OFFSET);
+	XTemac_mWriteHostReg(BaseAddress, XTE_ETXC_OFFSET, XTE_ETXC_TXRST_MASK);
+
+	/* Wait for the transmitter to finish reset */
+	do {
+		CR = XTemac_mReadHostReg(BaseAddress, XTE_ETXC_OFFSET);
+	} while (CR & XTE_ETXC_TXRST_MASK);
+
+	/* Restore contents of Tx control register, enable transmitter */
+	XTemac_mWriteHostReg(BaseAddress, XTE_ETXC_OFFSET,
+			     CR_save0 | XTE_ETXC_TXEN_MASK);
+}
+
+/*****************************************************************************/
+/**
+*
+* Disable the transmitter and receiver.
+*
+* @param BaseAddress is the base address of the device
+*
+* @return
+*
+* None.
+*
+* @note
+*
+******************************************************************************/
+void XTemac_Disable(u32 BaseAddress)
+{
+	u32 CR;
+
+	/* Disable the receiver */
+	CR = XTemac_mReadHostReg(BaseAddress, XTE_ERXC1_OFFSET);
+	XTemac_mWriteHostReg(BaseAddress, XTE_ERXC1_OFFSET,
+			     CR & ~XTE_ERXC1_RXEN_MASK);
+
+	/* Disable the transmitter */
+	CR = XTemac_mReadHostReg(BaseAddress, XTE_ETXC_OFFSET);
+	XTemac_mWriteHostReg(BaseAddress, XTE_ETXC_OFFSET,
+			     CR & ~XTE_ETXC_TXEN_MASK);
+}
+
+/*****************************************************************************/
+/**
+*
+* Send an Ethernet frame. This size is the total frame size, including header.
+* This function will return immediately upon dispatching of the frame to the
+* transmit FIFO. Upon return, the provided frame buffer can be reused. To
+* monitor the transmit status, use XTemac_mIsTxDone(). If desired, the
+* transmit status register (XTE_TSR_OFFSET) can be read to obtain the outcome
+* of the transaction.
+*
+* @param BaseAddress is the base address of the device
+* @param FramePtr is a pointer to a 32-bit aligned frame
+* @param Size is the size, in bytes, of the frame
+*
+* @return
+*
+* - Size of the frame sent (Size parameter)
+* - 0 if the frame will not fit in the data FIFO.
+*
+* @note
+*
+* A transmit length FIFO overrun (XTE_IPXR_XMIT_LFIFO_OVER_MASK) condition may
+* occur if too many frames are pending transmit. This situation can happen when
+* many small frames are being sent. To prevent this condition, pause sending
+* when transmit length FIFO full (XTE_IPXR_XMIT_LFIFO_FULL_MASK) is indicated in
+* the XTE_XTE_IPISR_OFFSET register.
+*
+******************************************************************************/
+int XTemac_SendFrame(u32 BaseAddress, void *FramePtr, int Size)
+{
+	XStatus Result;
+
+	/* Clear the status so it can be checked by the caller
+	 * Must handle toggle-on-write for status bits...unfortunately
+	 */
+	if (XTemac_mReadReg(BaseAddress, XTE_IPISR_OFFSET) &
+	    XTE_IPXR_XMIT_DONE_MASK) {
+		XTemac_mWriteReg(BaseAddress, XTE_IPISR_OFFSET,
+				 XTE_IPXR_XMIT_DONE_MASK);
+	}
+
+	/* Use the packet fifo driver write the FIFO */
+	Result = XPacketFifoV200a_L0Write(BaseAddress + XTE_PFIFO_TXREG_OFFSET,
+					  BaseAddress + XTE_PFIFO_TXDATA_OFFSET,
+					  (u8 *) FramePtr, Size);
+
+	/* No room in the FIFO */
+	if (Result != XST_SUCCESS) {
+		return (0);
+	}
+
+	/* The frame is in the Fifo, now send it */
+	XIo_Out32(BaseAddress + XTE_TPLR_OFFSET, Size);
+
+	return (Size);
+}
+
+/*****************************************************************************/
+/**
+*
+* Receive a frame
+*
+* @param BaseAddress is the base address of the device
+* @param FramePtr is a pointer to a 32-bit aligned buffer where the frame will
+*        be stored
+*
+* @return
+*
+* The size, in bytes, of the frame received.
+* 0 if no frame has been received.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XTemac_RecvFrame(u32 BaseAddress, void *FramePtr)
+{
+	int Length;
+
+	/* Is there a received frame present */
+	if (XTemac_mIsRxEmpty(BaseAddress)) {
+		return (0);
+	}
+
+	/* Get the length of the frame that arrived */
+	Length = XTemac_mReadReg(BaseAddress, XTE_RPLR_OFFSET);
+
+	/* Clear the status now that the length is read so we're ready again
+	 * next time
+	 */
+	XTemac_mWriteReg(BaseAddress, XTE_IPISR_OFFSET,
+			 XTE_IPXR_RECV_DONE_MASK);
+
+	/* Use the packet fifo driver to read the FIFO. We assume the Length is
+	 * valid and there is enough data in the FIFO - so we ignore the return
+	 * code.
+	 */
+	(void)XPacketFifoV200a_L0Read(BaseAddress + XTE_PFIFO_RXREG_OFFSET,
+				      BaseAddress + XTE_PFIFO_RXDATA_OFFSET,
+				      (u8 *) FramePtr, Length);
+	return (Length);
+}
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_l.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_l.h
@@ -0,0 +1,628 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xtemac_l.h
+*
+* This header file contains identifiers and low-level driver functions (or
+* macros) that can be used to access the Tri-Mode MAC Ethernet (TEMAC) device.
+* High-level driver functions are defined in xtemac.h.
+*
+* @note
+*
+* Some registers in the early access version of the core are not implemented.
+* Refer to the HW specification for more information. This driver is untested.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Who  Date     Changes
+* ---- -------- -----------------------------------------------
+* rmm  05/24/04 First release for early access.
+* rmm  06/01/05 General release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XTEMAC_L_H		/* prevent circular inclusions */
+#define XTEMAC_L_H		/* by using protection macros */
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+#define XTE_PLB_BD_ALIGNMENT  8	     /**< Minimum buffer descriptor alignment
+                                      *   on the PLB bus */
+#define XTE_PLB_BUF_ALIGNMENT 8	     /**< Minimum buffer alignment when using
+                                      *   HW options that impose alignment
+                                      *   restrictions on the buffer data on
+                                      *   the PLB bus */
+
+/* Register offset definitions. Unless otherwise noted, register access is
+ * 32 bit.
+ */
+
+/** @name IPIF interrupt and reset registers
+ *  @{
+ */
+#define XTE_DISR_OFFSET  0x00000000  /**< Device interrupt status */
+#define XTE_DIPR_OFFSET  0x00000004  /**< Device interrupt pending */
+#define XTE_DIER_OFFSET  0x00000008  /**< Device interrupt enable */
+#define XTE_DIIR_OFFSET  0x00000018  /**< Device interrupt ID */
+#define XTE_DGIE_OFFSET  0x0000001C  /**< Device global interrupt enable */
+#define XTE_IPISR_OFFSET 0x00000020  /**< IP interrupt status */
+#define XTE_IPIER_OFFSET 0x00000028  /**< IP interrupt enable */
+#define XTE_DSR_OFFSET   0x00000040  /**< Device software reset (write) */
+/*@}*/
+
+/** @name IPIF transmit and receive packet fifo base offsets
+ *        Individual registers and bit definitions are defined in
+ *        xpacket_fifo_l_v2_00_a.h
+ *  @{
+ */
+#define XTE_PFIFO_TXREG_OFFSET   0x00002000  /**< Packet FIFO Tx channel */
+#define XTE_PFIFO_RXREG_OFFSET   0x00002010  /**< Packet FIFO Rx channel */
+/*@}*/
+
+/** @name IPIF transmit and receive packet fifo data offsets
+ *  @{
+ */
+#define XTE_PFIFO_TXDATA_OFFSET  0x00002100  /**< IPIF Tx packet fifo port */
+#define XTE_PFIFO_RXDATA_OFFSET  0x00002200  /**< IPIF Rx packet fifo port */
+/*@}*/
+
+/** @name IPIF transmit and recieve DMA offsets
+ *        Individual registers are defined in xdma_channel_i.h
+ *        Bitmask definitions are defined in xdma_channel.h
+ *  @{
+ */
+#define XTE_DMA_SEND_OFFSET      0x00002300  /**< DMA Tx channel */
+#define XTE_DMA_RECV_OFFSET      0x00002340  /**< DMA Rx channel */
+/*@}*/
+
+/** @name IPIF IPIC_TO_TEMAC Core Registers
+ *  @{
+ */
+#define XTE_CR_OFFSET           0x00001000  /**< Control */
+#define XTE_TPLR_OFFSET         0x00001004  /**< Tx packet length (FIFO) */
+#define XTE_TSR_OFFSET          0x00001008  /**< Tx status (FIFO) */
+#define XTE_RPLR_OFFSET         0x0000100C  /**< Rx packet length (FIFO) */
+#define XTE_RSR_OFFSET          0x00001010  /**< Receive status */
+#define XTE_IFGP_OFFSET         0x00001014  /**< Interframe gap */
+#define XTE_TPPR_OFFSET         0x00001018  /**< Tx pause packet */
+/*@}*/
+
+/** @name TEMAC Core Registers
+ * These are registers defined within the device's hard core located in the
+ * processor block. They are accessed with the host interface. These registers
+ * are addressed offset by XTE_HOST_IPIF_OFFSET or by the DCR base address
+ * if so configured.
+ *
+ * Access to these registers should go through macros XTemac_mReadHostReg()
+ * and XTemac_mWriteHostReg().
+ * @{
+ */
+#define XTE_HOST_IPIF_OFFSET    0x00003000  /**< Offset of host registers when
+                                                 memory mapped into IPIF */
+#define XTE_ERXC0_OFFSET        0x00000200  /**< Rx configuration word 0 */
+#define XTE_ERXC1_OFFSET        0x00000240  /**< Rx configuration word 1 */
+#define XTE_ETXC_OFFSET         0x00000280  /**< Tx configuration */
+#define XTE_EFCC_OFFSET         0x000002C0  /**< Flow control configuration */
+#define XTE_ECFG_OFFSET         0x00000300  /**< EMAC configuration */
+#define XTE_EGMIC_OFFSET        0x00000320  /**< RGMII/SGMII configuration */
+#define XTE_EMC_OFFSET          0x00000340  /**< Management configuration */
+#define XTE_EUAW0_OFFSET        0x00000380  /**< Unicast address word 0 */
+#define XTE_EUAW1_OFFSET        0x00000384  /**< Unicast address word 1 */
+#define XTE_EMAW0_OFFSET        0x00000388  /**< Multicast address word 0 */
+#define XTE_EMAW1_OFFSET        0x0000038C  /**< Multicast address word 1 */
+#define XTE_EAFM_OFFSET         0x00000390  /**< Promisciuous mode */
+#define XTE_EIRS_OFFSET         0x000003A0  /**< IRstatus */
+#define XTE_EIREN_OFFSET        0x000003A4  /**< IRenable */
+#define XTE_EMIID_OFFSET        0x000003B0  /**< MIIMwrData */
+#define XTE_EMIIC_OFFSET        0x000003B4  /**< MiiMcnt */
+/*@}*/
+
+/* Register masks. The following constants define bit locations of various
+ * control bits in the registers. Constants are not defined for those registers
+ * that have a single bit field representing all 32 bits. For further
+ * information on the meaning of the various bit masks, refer to the HW spec.
+ */
+
+/** @name Interrupt status bits for top level interrupts
+ *  These bits are associated with the XTE_DISR_OFFSET, XTE_DIPR_OFFSET,
+ *  and XTE_DIER_OFFSET registers.
+ * @{
+ */
+#define XTE_DXR_SEND_FIFO_MASK          0x00000040 /**< Send FIFO channel */
+#define XTE_DXR_RECV_FIFO_MASK          0x00000020 /**< Receive FIFO channel */
+#define XTE_DXR_RECV_DMA_MASK           0x00000010 /**< Receive DMA channel */
+#define XTE_DXR_SEND_DMA_MASK           0x00000008 /**< Send DMA channel */
+#define XTE_DXR_CORE_MASK               0x00000004 /**< Core */
+#define XTE_DXR_DPTO_MASK               0x00000002 /**< Data phase timeout */
+#define XTE_DXR_TERR_MASK               0x00000001 /**< Transaction error */
+/*@}*/
+
+/** @name Interrupt status bits for MAC interrupts
+ *  These bits are associated with XTE_IPISR_OFFSET and XTE_IPIER_OFFSET
+ *  registers.
+ *
+ *  @{
+ */
+#define XTE_IPXR_XMIT_DONE_MASK         0x00000001 /**< Tx complete */
+#define XTE_IPXR_RECV_DONE_MASK         0x00000002 /**< Rx complete */
+#define XTE_IPXR_AUTO_NEG_MASK          0x00000004 /**< Auto negotiation complete */
+#define XTE_IPXR_RECV_REJECT_MASK       0x00000008 /**< Rx packet rejected */
+#define XTE_IPXR_XMIT_SFIFO_EMPTY_MASK  0x00000010 /**< Tx status fifo empty */
+#define XTE_IPXR_RECV_LFIFO_EMPTY_MASK  0x00000020 /**< Rx length fifo empty */
+#define XTE_IPXR_XMIT_LFIFO_FULL_MASK   0x00000040 /**< Tx length fifo full */
+#define XTE_IPXR_RECV_LFIFO_OVER_MASK   0x00000080 /**< Rx length fifo overrun
+                                                        Note that this signal is
+                                                        no longer asserted by HW
+                                                        */
+#define XTE_IPXR_RECV_LFIFO_UNDER_MASK  0x00000100 /**< Rx length fifo underrun */
+#define XTE_IPXR_XMIT_SFIFO_OVER_MASK   0x00000200 /**< Tx status fifo overrun */
+#define XTE_IPXR_XMIT_SFIFO_UNDER_MASK  0x00000400 /**< Tx status fifo underrun */
+#define XTE_IPXR_XMIT_LFIFO_OVER_MASK   0x00000800 /**< Tx length fifo overrun */
+#define XTE_IPXR_XMIT_LFIFO_UNDER_MASK  0x00001000 /**< Tx length fifo underrun */
+#define XTE_IPXR_RECV_PFIFO_ABORT_MASK  0x00002000 /**< Rx packet rejected due to
+                                                        full packet FIFO */
+#define XTE_IPXR_RECV_LFIFO_ABORT_MASK  0x00004000 /**< Rx packet rejected due to
+                                                        full length FIFO */
+
+#define XTE_IPXR_RECV_DROPPED_MASK                                      \
+    (XTE_IPXR_RECV_REJECT_MASK |                                        \
+     XTE_IPXR_RECV_PFIFO_ABORT_MASK |                                   \
+     XTE_IPXR_RECV_LFIFO_ABORT_MASK)	/**< IPXR bits that indicate a dropped
+                                             receive frame */
+#define XTE_IPXR_XMIT_ERROR_MASK                                        \
+    (XTE_IPXR_XMIT_SFIFO_OVER_MASK |                                    \
+     XTE_IPXR_XMIT_SFIFO_UNDER_MASK |                                   \
+     XTE_IPXR_XMIT_LFIFO_OVER_MASK |                                    \
+     XTE_IPXR_XMIT_LFIFO_UNDER_MASK)	/**< IPXR bits that indicate transmit
+                                             errors */
+
+#define XTE_IPXR_RECV_ERROR_MASK                                        \
+    (XTE_IPXR_RECV_DROPPED_MASK |                                       \
+     XTE_IPXR_RECV_LFIFO_UNDER_MASK)	/**< IPXR bits that indicate receive
+                                             errors */
+
+#define XTE_IPXR_FIFO_FATAL_ERROR_MASK          \
+    (XTE_IPXR_XMIT_SFIFO_OVER_MASK |            \
+     XTE_IPXR_XMIT_SFIFO_UNDER_MASK |           \
+     XTE_IPXR_XMIT_LFIFO_OVER_MASK |            \
+     XTE_IPXR_XMIT_LFIFO_UNDER_MASK |           \
+     XTE_IPXR_RECV_LFIFO_UNDER_MASK)	/**< IPXR bits that indicate errors with
+                                             one of the length or status FIFOs
+                                             that is fatal in nature. These bits
+                                             can only be cleared by a device
+                                             reset */
+/*@}*/
+
+/** @name Software reset register (DSR)
+ *  @{
+ */
+#define XTE_DSR_RESET_MASK      0x0000000A  /**< Write this value to DSR to
+                                                 reset entire core */
+/*@}*/
+
+/** @name Global interrupt enable register (DGIE)
+ *  @{
+ */
+#define XTE_DGIE_ENABLE_MASK    0x80000000  /**< Write this value to DGIE to
+                                                 enable interrupts from this
+                                                 device */
+/*@}*/
+
+/** @name Control Register (CR)
+ *  @{
+ */
+#define XTE_CR_BCREJ_MASK       0x00000004   /**< Disable broadcast address
+                                                  filtering */
+#define XTE_CR_MCREJ_MASK       0x00000002   /**< Disable multicast address
+                                                  filtering */
+#define XTE_CR_HDUPLEX_MASK     0x00000001   /**< Enable half duplex operation */
+/*@}*/
+
+/** @name Transmit Packet Length Register (TPLR)
+ *  @{
+ */
+#define XTE_TPLR_TXPL_MASK      0x00003FFF   /**< Tx packet length in bytes */
+/*@}*/
+
+/** @name Transmit Status Register (TSR)
+ *  @{
+ */
+#define XTE_TSR_TXED_MASK       0x80000000   /**< Excess deferral error */
+#define XTE_TSR_PFIFOU_MASK     0x40000000   /**< Packet FIFO underrun */
+#define XTE_TSR_TXA_MASK        0x3E000000   /**< Transmission attempts */
+#define XTE_TSR_TXLC_MASK       0x01000000   /**< Late collision error */
+#define XTE_TSR_TPCF_MASK       0x00000001   /**< Transmit packet complete
+                                                  flag */
+
+#define XTE_TSR_ERROR_MASK                 \
+    (XTE_TSR_TXED_MASK |                   \
+     XTE_TSR_PFIFOU_MASK |                 \
+     XTE_TSR_TXLC_MASK)			     /**< TSR bits that indicate an
+                                                  error */
+/*@}*/
+
+/** @name Receive Packet Length Register (RPLR)
+ *  @{
+ */
+#define XTE_RPLR_RXPL_MASK      0x00003FFF   /**< Rx packet length in bytes */
+/*@}*/
+
+/** @name Receive Status Register (RSR)
+ * @{
+ */
+#define XTE_RSR_RPCF_MASK       0x00000001   /**< Receive packet complete
+                                                  flag */
+/*@}*/
+
+/** @name Interframe Gap Register (IFG)
+ *  @{
+ */
+#define XTE_IFG_IFGD_MASK       0x000000FF   /**< IFG delay */
+/*@}*/
+
+/** @name Transmit Pause Packet Register (TPPR)
+ *  @{
+ */
+#define XTE_TPPR_TPPD_MASK      0x0000FFFF   /**< Tx pause packet data */
+/*@}*/
+
+/** @name Receiver Configuration Word 1 (ERXC1)
+ *  @{
+ */
+#define XTE_ERXC1_RXRST_MASK    0x80000000   /**< Receiver reset */
+#define XTE_ERXC1_RXJMBO_MASK   0x40000000   /**< Jumbo frame enable */
+#define XTE_ERXC1_RXFCS_MASK    0x20000000   /**< FCS not stripped */
+#define XTE_ERXC1_RXEN_MASK     0x10000000   /**< Receiver enable */
+#define XTE_ERXC1_RXVLAN_MASK   0x08000000   /**< VLAN enable */
+#define XTE_ERXC1_RXHD_MASK     0x04000000   /**< Half duplex */
+#define XTE_ERXC1_RXLT_MASK     0x02000000   /**< Length/type check disable */
+#define XTE_ERXC1_ERXC1_MASK    0x0000FFFF   /**< Pause frame source address
+                                                  bits [47:32]. Bits [31:0]
+                                                  are stored in register
+                                                  ERXC0 */
+/*@}*/
+
+/** @name Transmitter Configuration (ETXC)
+ *  @{
+ */
+#define XTE_ETXC_TXRST_MASK     0x80000000   /**< Transmitter reset */
+#define XTE_ETXC_TXJMBO_MASK    0x40000000   /**< Jumbo frame enable */
+#define XTE_ETXC_TXFCS_MASK     0x20000000   /**< Generate FCS */
+#define XTE_ETXC_TXEN_MASK      0x10000000   /**< Transmitter enable */
+#define XTE_ETXC_TXVLAN_MASK    0x08000000   /**< VLAN enable */
+#define XTE_ETXC_TXHD_MASK      0x04000000   /**< Half duplex */
+#define XTE_ETXC_TXIFG_MASK     0x02000000   /**< IFG adjust enable */
+/*@}*/
+
+/** @name Flow Control Configuration (EFCC)
+ *  @{
+ */
+#define XTE_EFCC_TXFLO_MASK     0x40000000   /**< Tx flow control enable */
+#define XTE_EFCC_RXFLO_MASK     0x20000000   /**< Rx flow control enable */
+/*@}*/
+
+/** @name EMAC Configuration (ECFG)
+ * @{
+ */
+#define XTE_ECFG_LINKSPD_MASK   0xC0000000   /**< Link speed */
+#define XTE_ECFG_RGMII_MASK     0x20000000   /**< RGMII mode enable */
+#define XTE_ECFG_SGMII_MASK     0x10000000   /**< SGMII mode enable */
+#define XTE_ECFG_1000BASEX_MASK 0x08000000   /**< 1000BaseX mode enable */
+#define XTE_ECFG_HOSTEN_MASK    0x04000000   /**< Host interface enable */
+#define XTE_ECFG_TX16BIT        0x02000000   /**< 16 bit Tx client enable */
+#define XTE_ECFG_RX16BIT        0x01000000   /**< 16 bit Rx client enable */
+
+#define XTE_ECFG_LINKSPD_10     0x00000000   /**< XTE_ECFG_LINKSPD_MASK for
+                                                  10 Mbit */
+#define XTE_ECFG_LINKSPD_100    0x40000000   /**< XTE_ECFG_LINKSPD_MASK for
+                                                  100 Mbit */
+#define XTE_ECFG_LINKSPD_1000   0x80000000   /**< XTE_ECFG_LINKSPD_MASK for
+                                                  1000 Mbit */
+/*@}*/
+
+/** @name EMAC RGMII/SGMII Configuration (EGMIC)
+ * @{
+ */
+#define XTE_EGMIC_RGLINKSPD_MASK    0xC0000000	 /**< RGMII link speed */
+#define XTE_EGMIC_SGLINKSPD_MASK    0x0000000C	 /**< SGMII link speed */
+#define XTE_EGMIC_RGSTATUS_MASK     0x00000002	 /**< RGMII link status */
+#define XTE_EGMIC_RGHALFDUPLEX_MASK 0x00000001	 /**< RGMII half duplex */
+
+#define XTE_EGMIC_RGLINKSPD_10      0x00000000	 /**< XTE_EGMIC_RGLINKSPD_MASK
+                                                      for 10 Mbit */
+#define XTE_EGMIC_RGLINKSPD_100     0x40000000	 /**< XTE_EGMIC_RGLINKSPD_MASK
+                                                      for 100 Mbit */
+#define XTE_EGMIC_RGLINKSPD_1000    0x80000000	 /**< XTE_EGMIC_RGLINKSPD_MASK
+                                                      for 1000 Mbit */
+#define XTE_EGMIC_SGLINKSPD_10      0x00000000	 /**< XTE_SGMIC_RGLINKSPD_MASK
+                                                      for 10 Mbit */
+#define XTE_EGMIC_SGLINKSPD_100     0x00000004	 /**< XTE_SGMIC_RGLINKSPD_MASK
+                                                      for 100 Mbit */
+#define XTE_EGMIC_SGLINKSPD_1000    0x00000008	 /**< XTE_SGMIC_RGLINKSPD_MASK
+                                                      for 1000 Mbit */
+/*@}*/
+
+/** @name EMAC Management Configuration (EMC)
+ * @{
+ */
+#define XTE_EMC_MDIO_MASK       0x00000040   /**< MII management enable */
+#define XTE_EMC_CLK_DVD_MAX     0x3F	     /**< Maximum MDIO divisor */
+/*@}*/
+
+/** @name EMAC Unicast Address Register Word 1 (EUAW1)
+ * @{
+ */
+#define XTE_EUAW1_MASK          0x0000FFFF   /**< Station address bits [47:32]
+                                                  Station address bits [31:0]
+                                                  are stored in register
+                                                  EUAW0 */
+/*@}*/
+
+/** @name EMAC Multicast Address Register Word 1 (EMAW1)
+ * @{
+ */
+#define XTE_EMAW1_CAMRNW_MASK   0x00800000   /**< CAM read/write control */
+#define XTE_EMAW1_CAMADDR_MASK  0x00030000   /**< CAM address mask */
+#define XTE_EUAW1_MASK          0x0000FFFF   /**< Multicast address bits [47:32]
+                                                  Multicast address bits [31:0]
+                                                  are stored in register
+                                                  EMAW0 */
+#define XTE_EMAW1_CAMMADDR_SHIFT_MASK 16     /**< Number of bits to shift right
+                                                  to align with
+                                                  XTE_EMAW1_CAMADDR_MASK */
+/*@}*/
+
+/** @name EMAC Address Filter Mode (EAFM)
+ * @{
+ */
+#define XTE_EAFM_EPPRM_MASK         0x80000000	 /**< Promiscuous mode enable */
+/*@}*/
+
+/** @name EMAC MII Management Write Data (EMIID)
+ * @{
+ */
+#define XTE_EMIID_MIIMWRDATA_MASK   0x0000FFFF	 /**< Data port */
+/*@}*/
+
+/** @name EMAC MII Management Control (EMIIC)
+ * @{
+ */
+#define XTE_EMIID_MIIMDECADDR_MASK  0x0000FFFF	 /**< Address port */
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/****************************************************************************/
+/**
+*
+* Read the given IPIF register.
+*
+* @param    BaseAddress is the IPIF base address of the device
+* @param    RegOffset is the register offset to be read
+*
+* @return   The 32-bit value of the register
+*
+* @note
+* C-style signature:
+*    u32 XTemac_mReadReg(u32 BaseAddress, u32 RegOffset)
+*
+*****************************************************************************/
+#define XTemac_mReadReg(BaseAddress, RegOffset) \
+    XIo_In32((BaseAddress) + (RegOffset))
+
+/****************************************************************************/
+/**
+*
+* Write the given IPIF register.
+*
+* @param    BaseAddress is the IPIF base address of the device
+* @param    RegOffset is the register offset to be written
+* @param    Data is the 32-bit value to write to the register
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    void XTemac_mWriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+*****************************************************************************/
+#define XTemac_mWriteReg(BaseAddress, RegOffset, Data) \
+    XIo_Out32((BaseAddress) + (RegOffset), (Data))
+
+/****************************************************************************/
+/**
+*
+* Convert host register offset to a proper DCR or memory mapped offset (DCR
+* not currently supported).
+*
+* @param    HostRegOffset is the relative regster offset to be converted
+*
+* @return   The correct offset of the register
+*
+* @note
+* C-style signature:
+*    u32 XTemac_mHostOffset(u32 RegOffset)
+*
+*****************************************************************************/
+#define XTemac_mHostOffset(HostRegOffset) \
+    ((u32)(HostRegOffset) + XTE_HOST_IPIF_OFFSET)
+
+/****************************************************************************/
+/**
+*
+* Read the given host register.
+*
+* @param    BaseAddress is the base address of the device
+* @param    HostRegOffset is the register offset to be read
+*
+* @return   The 32-bit value of the register
+*
+* @note
+* C-style signature:
+*    u32 XTemac_mReadHostReg(u32 BaseAddress, u32 HostRegOffset)
+*
+*****************************************************************************/
+#define XTemac_mReadHostReg(BaseAddress, HostRegOffset) \
+    XIo_In32((BaseAddress) + XTemac_mHostOffset(HostRegOffset))
+
+/****************************************************************************/
+/**
+*
+* Write the given host register.
+*
+* @param    BaseAddress is the base address of the device
+* @param    HostRegOffset is the register offset to be written
+* @param    Data is the 32-bit value to write to the register
+*
+* @return   None.
+*
+* C-style signature:
+*    void XTemac_mWriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+*****************************************************************************/
+#define XTemac_mWriteHostReg(BaseAddress, HostRegOffset, Data) \
+    XIo_Out32((BaseAddress) + XTemac_mHostOffset(HostRegOffset), (Data))
+
+/****************************************************************************/
+/**
+*
+* Set the station address.
+*
+* @param    BaseAddress is the base address of the device
+* @param    AddressPtr is a pointer to a 6-byte MAC address
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    u32 XTemac_mSetMacAddress(u32 BaseAddress, u8 *AddressPtr)
+*
+*****************************************************************************/
+#define XTemac_mSetMacAddress(BaseAddress, AddressPtr)              \
+{                                                                   \
+    u32 Reg;                                                    \
+    u8* Aptr = (u8*)(AddressPtr);                           \
+                                                                    \
+    Reg =  Aptr[0] & 0x000000FF;                                    \
+    Reg |= Aptr[1] << 8;                                            \
+    Reg |= Aptr[2] << 16;                                           \
+    Reg |= Aptr[3] << 24;                                           \
+    XTemac_mWriteHostReg((BaseAddress), XTE_EUAW0_OFFSET, Reg);     \
+                                                                    \
+    Reg = XTemac_mReadHostReg((BaseAddress), XTE_EUAW1_OFFSET);     \
+    Reg &= ~XTE_EUAW1_MASK;                                         \
+    Reg |= Aptr[4] & 0x000000FF;                                    \
+    Reg |= Aptr[5] << 8;                                            \
+    XTemac_mWriteHostReg((BaseAddress), XTE_EUAW1_OFFSET, Reg);     \
+}
+
+/****************************************************************************/
+/**
+*
+* Check to see if the transmission is complete.
+*
+* @param    BaseAddress is the base address of the device
+*
+* @return   TRUE if it is done, or FALSE if it is not.
+*
+* @note
+* C-style signature:
+*    XBoolean XTemac_mIsTxDone(u32 BaseAddress)
+*
+*****************************************************************************/
+#define XTemac_mIsTxDone(BaseAddress)                                   \
+    (((XIo_In32((BaseAddress) + XTE_IPISR_OFFSET) & XTE_IPXR_XMIT_DONE_MASK) == \
+      XTE_IPXR_XMIT_DONE_MASK) ? TRUE : FALSE)
+
+/****************************************************************************/
+/**
+*
+* Check to see if the receive FIFO is empty.
+*
+* @param    BaseAddress is the base address of the device
+*
+* @return   TRUE if it is empty, or FALSE if it is not.
+*
+* @note
+* C-style signature:
+*    XBoolean XTemac_mIsRxEmpty(u32 BaseAddress)
+*
+*****************************************************************************/
+#define XTemac_mIsRxEmpty(BaseAddress)                                  \
+    ((XIo_In32((BaseAddress) + XTE_IPISR_OFFSET) & XTE_IPXR_RECV_DONE_MASK) \
+     ? FALSE : TRUE)
+
+/****************************************************************************/
+/**
+*
+* Reset the entire core including any attached PHY. Note that there may be a
+* settling time required after initiating a reset. See the core spec and the
+* PHY datasheet.
+*
+* @param    BaseAddress is the base address of the device
+*
+* @return   Nothing
+*
+* @note
+* C-style signature:
+*    void XTemac_mReset(u32 BaseAddress)
+*
+*****************************************************************************/
+#define XTemac_mReset(BaseAddress)                                      \
+    XIo_Out32((BaseAddress) + XTE_DSR_OFFSET, XTE_DSR_RESET_MASK)
+
+/************************** Function Prototypes ******************************/
+
+void XTemac_Enable(u32 BaseAddress);
+void XTemac_Disable(u32 BaseAddress);
+int XTemac_SendFrame(u32 BaseAddress, void *FramePtr, int Size);
+int XTemac_RecvFrame(u32 BaseAddress, void *FramePtr);
+
+#endif				/* end of protection macro */
Index: linux-2.6.10/drivers/net/xilinx_temac/xtemac_sgdma.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/xilinx_temac/xtemac_sgdma.c
@@ -0,0 +1,657 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2005 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file xtemac_sgdma.c
+ *
+ * Functions in this file implement scatter-gather DMA frame transfer mode.
+ * See xtemac.h for a detailed description of the driver.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a rmm  06/01/05 First release
+ * </pre>
+ *
+ ******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xtemac.h"
+#include "xtemac_i.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Variable Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+
+/*****************************************************************************/
+/**
+ * Allocate a set of BDs from the given SGDMA channel. It is expected the user
+ * will attach buffers and set other DMA transaction parameters to the returned
+ * BDs in preparation to calling XTemac_SgCommit(). The set of BDs returned is
+ * a list starting with the BdPtr and extending for NumBd BDs. The list can be
+ * navigated with macros XTemac_mSgRecvBdNext() for the XTE_RECV channel, and
+ * XTemac_mSgSendBdNext() for the XTE_SEND channel.
+ *
+ * The BDs returned by this function are a segment of the BD ring maintained
+ * by the SGDMA driver. Do not modify BDs past the end of the returned list.
+ * Doing so will cause data corruption and may lead to system instability.
+ *
+ * This function and XTemac_SgCommit() must be called in the correct order. See
+ * xtemac.h for more information on the SGDMA use model.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
+ * @param NumBd is the number of BDs to allocate.
+ * @param BdPtr is an output parameter, it points to the first BD in the
+ *        returned list.
+ *
+ * @return
+ * - XST_SUCCESS if the requested number of BDs was returned.
+ * - XST_INVALID_PARAM if Direction did not specify a valid channel.
+ * - XST_FAILURE if there were not enough free BDs to satisfy the request.
+ *
+ * @note
+ * This function is not thread-safe. The user must provide mutually exclusive
+ * access to this function if there are to be multiple threads that can call it.
+ *
+ ******************************************************************************/
+XStatus XTemac_SgAlloc(XTemac * InstancePtr, u32 Direction,
+		       unsigned NumBd, XDmaBdV2 ** BdPtr)
+{
+	XStatus Status;
+	XDmaV2 *DmaPtr;
+	u32 DgieReg;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BdPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Which channel to address */
+	if (Direction == XTE_RECV) {
+		DmaPtr = &InstancePtr->RecvDma;
+	} else if (Direction == XTE_SEND) {
+		DmaPtr = &InstancePtr->SendDma;
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* XDmaV2_SgBdAlloc() will return either XST_SUCCESS or XST_FAILURE
+	 * This is a critical section, prevent interrupts from the device while
+	 * the BD ring is being modified.
+	 */
+	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
+	Status = XDmaV2_SgBdAlloc(DmaPtr, NumBd, BdPtr);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
+	return (Status);
+}
+
+/*****************************************************************************/
+/**
+ * Commit a set of BDs to the SGDMA engine that had been allocated by
+ * XTemac_SgAlloc() and prepared by the user to describe SGDMA transaction(s).
+ *
+ * This function and XTemac_SgAlloc() must be called in the correct order. See
+ * xtemac.h for more information on the SGDMA use model.
+ *
+ * Upon return, the committed BDs go under hardware control. Do not modify BDs
+ * after they have been committed. Doing so may cause data corruption and system
+ * instability.
+ *
+ * This function may be called if the TEMAC device is started or stopped. If
+ * started (see XTemac_Start()), then the BDs may be processed by HW at any
+ * time.
+ *
+ * This function is non-blocking.  Notification of error or successful
+ * transmission/reception is done asynchronously through callback functions.
+ *
+ * For transmit (XTE_SEND):
+ *
+ * It is assumed that the upper layer software supplies a correctly formatted
+ * Ethernet frame, including the destination and source addresses, the
+ * type/length field, and the data field.
+ *
+ * For receive (XTE_RECV):
+ *
+ * It is assumed that BDs have an appropriately sized frame buffer attached
+ * that corresponds to the network MTU.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
+ * @param NumBd is the number of BDs to commit. This is typically the same
+ *        value used when the BDs were allocated with XTemac_SgAlloc().
+ * @param BdPtr is the first BD in the set to commit and is typically the
+ *        same value returned by XTemac_SgAlloc().
+ *
+ * @return
+ * - XST_SUCCESS if the requested number of BDs was returned.
+ * - XST_INVALID_PARAM if Direction did not specify a valid channel.
+ * - XST_FAILURE if the last BD in the set does not have its "last" bit
+ *   set (see XDmaBdV2_mSetLast()).
+ * - XST_DMA_SG_LIST_ERROR if BdPtr parameter does not reflect the correct
+ *   insertion point within the internally maintained BD ring. This error occurs
+ *   when this function and XTemac_SgAlloc() are called out of order.
+ *
+ * @note
+ * This function is not thread-safe. The user must provide mutually exclusive
+ * access to this function if there are to be multiple threads that can call it.
+ *
+ ******************************************************************************/
+XStatus XTemac_SgCommit(XTemac * InstancePtr, u32 Direction,
+			unsigned NumBd, XDmaBdV2 * BdPtr)
+{
+	XStatus Status;
+	XDmaV2 *DmaPtr;
+	u32 DgieReg;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Which channel to address */
+	if (Direction == XTE_RECV) {
+		DmaPtr = &InstancePtr->RecvDma;
+	} else if (Direction == XTE_SEND) {
+		DmaPtr = &InstancePtr->SendDma;
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* XDmaV2_SgToHw() will return either XST_SUCCESS, XST_FAILURE, or
+	 * XST_DMA_SG_LIST_ERROR
+	 *
+	 * This is a critical section, prevent interrupts from the device while
+	 * the BD ring is being modified.
+	 */
+	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
+	Status = XDmaV2_SgBdToHw(DmaPtr, NumBd, BdPtr);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
+	return (Status);
+}
+
+/*****************************************************************************/
+/**
+ * Retrieve BDs that have been processed by the SGDMA channel. This function is
+ * called typically after the XTE_HANDLER_SGRECV handler has been invoked for
+ * the receive channel or XTE_HANDLER_SGSEND for the transmit channel.
+ *
+ * The set of BDs returned is a list starting with the BdPtr and extending
+ * for 1 or more BDs (the exact number is the return value of this function).
+ * The list can be navigated with macros XTemac_mSgRecvBdNext() for the
+ * XTE_RECV channel, and XTemac_mSgSendBdNext() for the XTE_SEND channel.
+ * Treat the returned BDs as read-only.
+ *
+ * This function and XTemac_SgFree() must be called in the correct order. See
+ * xtemac.h for more information on the SGDMA use model.
+ *
+ * The last BD in the returned list is guaranteed to have the "Last" bit set
+ * (i.e. XDmaBdV2_IsLast evaluates to true).
+ *
+ * The returned BDs can be examined for the outcome of the SGDMA transaction.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
+ * @param BdPtr is an output parameter that points to the 1st BD in the returned
+ *        list. If no BDs were ready, then this parameter is unchanged.
+ * @param NumBd is an upper limit to the number of BDs to retrieve.
+ *
+ * @return
+ * Number of BDs that are ready for post processing. If the direction parameter
+ * is invalid, then 0 is returned.
+ *
+ * @note
+ * This function is not thread-safe. The user must provide mutually exclusive
+ * access to this function if there are to be multiple threads that can call it.
+ *
+ ******************************************************************************/
+unsigned XTemac_SgGetProcessed(XTemac * InstancePtr, u32 Direction,
+			       unsigned NumBd, XDmaBdV2 ** BdPtr)
+{
+	u32 DgieReg;
+	XDmaV2 *DmaPtr;
+	unsigned Rc;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BdPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Which channel to address */
+	if (Direction == XTE_RECV) {
+		DmaPtr = &InstancePtr->RecvDma;
+	} else if (Direction == XTE_SEND) {
+		DmaPtr = &InstancePtr->SendDma;
+	} else {
+		return (0);
+	}
+
+	/* This is a critical section. Prevent interrupts from the device while
+	 * the BD ring is being modified.
+	 */
+	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
+
+	/* Extract ready BDs */
+	Rc = XDmaV2_SgBdFromHw(DmaPtr, NumBd, BdPtr);
+
+	/* This is where we ack IPXR_PCTR interrupt for the dma channel. This
+	 * cannot be done in XTemac_IntrSgDmaHandler() because HW will keep the
+	 * interrupt asserted as long as the DMA channel's PCT > threshold. Calling
+	 * SgBdFromHw above will decrement PCT which should in most cases allow
+	 * the acknowledgement to take effect.
+	 *
+	 * We have to read the status 1st and test it before clearing
+	 * it. Bloody toggle-on-write statuses. Grrrr!
+	 */
+	if (XDmaV2_GetInterruptStatus(DmaPtr) & XDMAV2_IPXR_PCTR_MASK) {
+		XDmaV2_SetInterruptStatus(DmaPtr, XDMAV2_IPXR_PCTR_MASK);
+	}
+
+	/* End critical section */
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
+
+	return (Rc);
+}
+
+/*****************************************************************************/
+/**
+ * Free a set of BDs that had been retrieved by XTemac_SgGetProcessed(). If BDs
+ * are not freed, then eventually the channel will run out of BDs to
+ * XTemac_SgAlloc().
+ *
+ * This function and XTemac_SgGetProcessed() must be called in the correct
+ * order. See xtemac.h for more information on the SGDMA use model.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
+ * @param BdPtr is the first BD in the set to free. This is typically the same
+ *        value returned by XTemac_SgGetProcessed().
+ * @param NumBd is the number of BDs to free. This is typically the same value
+ *        returned by XTemac_SgGetProcessed().
+ *
+ * @return
+ * - XST_SUCCESS if the requested number of BDs was returned.
+ * - XST_INVALID_PARAM if Direction did not specify a valid channel.
+ * - XST_DMA_SG_LIST_ERROR if BdPtr parameter does not reflect the correct
+ *   insertion point within the internally maintained BD ring. This error occurs
+ *   when this function and XTemac_SgGetProcessed() are called out of order.
+ *
+ * @note
+ * This function is not thread-safe. The user must provide mutually exclusive
+ * access to this function if there are to be multiple threads that can call it.
+ *
+ ******************************************************************************/
+XStatus XTemac_SgFree(XTemac * InstancePtr, u32 Direction,
+		      unsigned NumBd, XDmaBdV2 * BdPtr)
+{
+	u32 DgieReg;
+	XDmaV2 *DmaPtr;
+	XStatus Status;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Which channel to address */
+	if (Direction == XTE_RECV) {
+		DmaPtr = &InstancePtr->RecvDma;
+	} else if (Direction == XTE_SEND) {
+		DmaPtr = &InstancePtr->SendDma;
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* This is a critical section. Prevent interrupts from the device while
+	 * the BD ring is being modified.
+	 */
+	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
+	Status = XDmaV2_SgBdFree(DmaPtr, NumBd, BdPtr);
+	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
+
+	return (Status);
+}
+
+/*****************************************************************************/
+/**
+ * Give the driver memory space to be used for the scatter-gather DMA
+ * descriptor list. This function should only be called once for each channel
+ * during initialization. If a list had already been created, then it is
+ * destroyed and replaced with a new one.
+ *
+ * To increase performance, a BdTemplate parameter is provided to allow the
+ * user to permanently set BD fields in all BDs for this SGDMA channel. For
+ * example, if every BD describes a buffer that will contain a full packet (as
+ * it typically does with receive channels), then XDmaBdV2_mSetLast(BdTemplate)
+ * can be performed prior to calling this function and when it returns, all BDs
+ * will have the "last" bit set in it's DMACR word. The user will never have to
+ * explicitly set the "last" bit again.
+ *
+ * The following operations can be replicated for the BdTemplate:
+ *   - XDmaBdV2_mSetId()
+ *   - XDmaBdV2_mSetLast()
+ *   - XDmaBdV2_mClearLast()
+ *
+ * The base address of the memory space must be aligned according to buffer
+ * descriptor requirements (see xtemac.h).
+ *
+ * The size of the memory space is assumed to be big enough to contain BdCount
+ * buffers at the given alignment. If the region is too small, then adjacent
+ * data may be overwritten causing system instability. There are tools in the
+ * DMA driver that help calculate the sizing requirments. See macros
+ * XDmaV2_mSgListCntCalc() and XDmaV2_mSgListMemCalc().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to address.
+ * @param PhysicalAddr is the physical base address of user memory region.
+ * @param VirtualAddr is the virtual base address of the user memory region. If
+ *        address translation is not being utilized, then VirtAddr should be
+ *        equivalent to PhysAddr.
+ * @param Alignment governs the byte alignment of individual BDs. This function
+ *        will enforce a minimum alignment of 8 bytes with no maximum as long as
+ *        it is specified as a power of 2.
+ * @param BdCount is the number of BDs to allocate in the memory region. It is
+ *        assumed the region is large enough to contain all the BDs.
+ * @param BdTemplate is copied to each BD after the list is created. If the user
+ *        does not have a need to replicate any BD fields then this parameter
+ *        should be zeroed (XDmaBdV2_mClear()). This parameter will be modified
+ *        by this function.
+ *
+ * @return
+ * - XST_SUCCESS if the space was initialized successfully
+ * - XST_DEVICE_IS_STARTED if the device has not been stopped.
+ * - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA per
+ *   the configuration information contained in XTemac_Config.
+ * - XST_INVALID_PARAM if: 1) Direction is not either XTE_SEND or XTE_RECV;
+ *   2) PhysicalAddr and/or VirtualAddr are not aligned to the given
+ *   alignment parameter; 3) Alignment parameter does not meet minimum
+ *   requirements of this device; 3) BdCount is 0.
+ * - XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans
+ *   over address 0x00000000 in virtual address space.
+ * - XST_NO_FEATURE if the DMA sub-driver discovers that the HW is not SGDMA
+ *   capable.
+ * - XST_FAILURE for other failures that shouldn't occur. If this is returned,
+ *   then the driver is experiencing a problem that should be reported to
+ *   Xilinx.
+ *
+ * @note
+ * If the device is configured for scatter-gather DMA, this function must be
+ * called AFTER the XTemac_Initialize() function because the DMA channel
+ * components must be initialized before the memory space is set.
+ *
+ ******************************************************************************/
+XStatus XTemac_SgSetSpace(XTemac * InstancePtr, u32 Direction,
+			  u32 PhysicalAddr, u32 VirtualAddr,
+			  u32 Alignment, unsigned BdCount,
+			  XDmaBdV2 * BdTemplate)
+{
+	XStatus Status;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BdTemplate != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* Make sure device is ready for this operation */
+	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Must have sgdma */
+	if (!XTemac_mIsSgDma(InstancePtr)) {
+		return (XST_NOT_SGDMA);
+	}
+
+	/* Check alignment */
+	if (Alignment < XTE_PLB_BD_ALIGNMENT) {
+		return (XST_INVALID_PARAM);
+	}
+
+	if (Direction == XTE_SEND) {
+		/* Setup BD for the transmit direction */
+		XDmaBdV2_mSetTxDir(BdTemplate);
+		XDmaBdV2_mSetDestAddr(BdTemplate,
+				      InstancePtr->Config->BaseAddress +
+				      XTE_PFIFO_TXDATA_OFFSET);
+
+		/* DRE capabilities */
+		if (InstancePtr->Config->Dre) {
+			XDmaBdV2_mSetDre(BdTemplate);
+		}
+
+		/* Create the list. This function will return one of XST_SUCCESS,
+		 * XST_INVALID_PARAM (for alignment violations), or
+		 * XST_DMA_SG_LIST_ERROR (if memory segment spans address 0)
+		 */
+		Status =
+		    XDmaV2_SgListCreate(&InstancePtr->SendDma, PhysicalAddr,
+					VirtualAddr, Alignment, BdCount);
+		if (Status != XST_SUCCESS) {
+			return (Status);
+		}
+
+		/* Clone the template BD. This should always work. If it does not
+		 * then something is seriously wrong
+		 */
+		Status = XDmaV2_SgListClone(&InstancePtr->SendDma, BdTemplate);
+		if (Status != XST_SUCCESS) {
+			return (XST_FAILURE);
+		} else {
+			return (XST_SUCCESS);
+		}
+	} else if (Direction == XTE_RECV) {
+		/* Setup BD for the receive direction */
+		XDmaBdV2_mSetRxDir(BdTemplate);
+		XDmaBdV2_mSetSrcAddr(BdTemplate,
+				     InstancePtr->Config->BaseAddress +
+				     XTE_PFIFO_RXDATA_OFFSET);
+
+		/* Create the list. This function will return one of XST_SUCCESS,
+		 * XST_INVALID_PARAM (for alignment violations), or
+		 * XST_DMA_SG_LIST_ERROR (if memory segment spans address 0)
+		 */
+		Status =
+		    XDmaV2_SgListCreate(&InstancePtr->RecvDma, PhysicalAddr,
+					VirtualAddr, Alignment, BdCount);
+		if (Status != XST_SUCCESS) {
+			return (Status);
+		}
+
+		/* Clone the template BD */
+		Status = XDmaV2_SgListClone(&InstancePtr->RecvDma, BdTemplate);
+		if (Status != XST_SUCCESS) {
+			return (XST_FAILURE);
+		} else {
+			return (XST_SUCCESS);
+		}
+	}
+
+	/* Direction is incorrect */
+	return (XST_INVALID_PARAM);
+}
+
+/*****************************************************************************/
+/**
+ * Verify the consistency of the SGDMA BD ring. While the check occurs, the
+ * device is stopped. If any problems are found the device is left stopped.
+ *
+ * Use this function to troubleshoot SGDMA problems.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Direction is the channel to check (XTE_SEND or XTE_RECV)
+ *
+ * @return
+ * - XST_SUCCESS if no problems are found.
+ * - XST_INVALID_PARAM if Direction is not XTE_SEND or XTE_RECV.
+ * - XST_DMA_SG_NO_LIST if the SG list has not yet been setup.
+ * - XST_DMA_BD_ERROR if a BD has been corrupted.
+ * - XST_DMA_SG_LIST_ERROR if the internal data structures of the BD ring are
+ *   inconsistent.
+ *
+ * @note
+ * This function is not thread-safe. The user must provide mutually exclusive
+ * access to this function if there are to be multiple threads that can call it.
+ *
+ ******************************************************************************/
+XStatus XTemac_SgCheck(XTemac * InstancePtr, u32 Direction)
+{
+	XDmaV2 *DmaPtr;
+	XDmaBdV2 *BdPtr;
+	int i;
+	int Restart = 0;
+	u32 Dmacr;
+	XStatus Rc = XST_SUCCESS;
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* Select channel to check */
+	if (Direction == XTE_SEND) {
+		DmaPtr = &InstancePtr->SendDma;
+	} else if (Direction == XTE_RECV) {
+		DmaPtr = &InstancePtr->RecvDma;
+	} else {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Stop the device if it is running */
+	if (InstancePtr->IsStarted == XST_DEVICE_IS_STARTED) {
+		XTemac_Stop(InstancePtr);
+		Restart = 1;
+	}
+
+	/* Perform check of ring structure using DMA driver routine */
+	Rc = XDmaV2_SgCheck(DmaPtr);
+	if (Rc == XST_SUCCESS) {
+		/* Check the BDs for consistency as used by TEMAC */
+		if (Direction == XTE_SEND) {
+			/* Starting from the beginning of the ring and going to the end:
+			 *   1. Verify the destination address is the packet fifo
+			 *   2. Verify DMACR is setup for the transmit direction
+			 */
+			BdPtr = (XDmaBdV2 *) DmaPtr->BdRing.BaseAddr;
+			for (i = 0; i < DmaPtr->BdRing.AllCnt; i++) {
+				/* Dest address should be address of packet fifo */
+				if (XDmaBdV2_mGetDestAddr(BdPtr) !=
+				    InstancePtr->Config->BaseAddress +
+				    XTE_PFIFO_TXDATA_OFFSET) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				Dmacr =
+				    XDmaV2_mReadBd(BdPtr,
+						   XDMAV2_BD_DMACR_OFFSET);
+
+				/* DMACR field should have these bits set */
+				if (Dmacr !=
+				    (Dmacr &
+				     (XDMAV2_DMACR_DLOCAL_MASK |
+				      XDMAV2_DMACR_SINC_MASK))) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				/* DMACR field should have these bits clear */
+				if (Dmacr &
+				    (XDMAV2_DMACR_SLOCAL_MASK |
+				     XDMAV2_DMACR_DINC_MASK)) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				/* Next BD */
+				BdPtr = XDmaV2_mSgBdNext(DmaPtr, BdPtr);
+			}
+		} else {	/* XTE_RECV */
+
+			/* Starting from the beginning of the ring and going to the end:
+			 *   1. Verify the source address is the packet fifo
+			 *   2. Verify DMACR is setup for the receive direction
+			 */
+			BdPtr = (XDmaBdV2 *) DmaPtr->BdRing.BaseAddr;
+			for (i = 0; i < DmaPtr->BdRing.AllCnt; i++) {
+				/* Src address should be address of packet fifo */
+				if (XDmaBdV2_mGetSrcAddr(BdPtr) !=
+				    InstancePtr->Config->BaseAddress +
+				    XTE_PFIFO_RXDATA_OFFSET) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				Dmacr =
+				    XDmaV2_mReadBd(BdPtr,
+						   XDMAV2_BD_DMACR_OFFSET);
+
+				/* DMACR field should have these bits set */
+				if (Dmacr !=
+				    (Dmacr &
+				     (XDMAV2_DMACR_SLOCAL_MASK |
+				      XDMAV2_DMACR_DINC_MASK))) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				/* DMACR field should have these bits clear */
+				if (Dmacr &
+				    (XDMAV2_DMACR_DLOCAL_MASK |
+				     XDMAV2_DMACR_SINC_MASK)) {
+					Rc = XST_DMA_BD_ERROR;
+					break;
+				}
+
+				/* Next BD */
+				BdPtr = XDmaV2_mSgBdNext(DmaPtr, BdPtr);
+			}
+		}
+	}
+
+	/* Restart the device if it was stopped by this function */
+	if ((Rc == XST_SUCCESS) && Restart) {
+		XTemac_Start(InstancePtr);
+	}
+
+	return (Rc);
+}
Index: linux-2.6.10/mvl_patches/pro-0346.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0346.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(346);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

