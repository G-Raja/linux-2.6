#! /usr/bin/env bash
# Patch: -pro_arm_davinci_dm355_mmc
# Date: Mon Jan 21 23:04:34 2008
# Source: MontaVista Software, Inc.
# MR:  25677
# Type: Defect Fix
# Disposition: local
# Signed-off-by: Jerry Alexander <jalexander@mvista.com>
# Description:
# 
# 		Added code for DM355 MMC implementation.
# 		Initialization code, configuration, and 
# 		dma interface code.
# 
# 

PATCHNUM=1661
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR:  25677
Type: Defect Fix
Disposition: local
Signed-off-by: Jerry Alexander <jalexander@mvista.com>
Description:

		Added code for DM355 MMC implementation.
		Initialization code, configuration, and 
		dma interface code.


Index: linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/board-dm355-evm.c
+++ linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
@@ -28,6 +28,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/serial_8250.h>
+#include <linux/davinci_mmc.h>
 
 #include <asm/setup.h>
 #include <asm/io.h>
@@ -39,6 +40,7 @@
 #include <asm/mach/flash.h>
 #include <asm/arch/irqs.h>
 #include <asm/arch/hardware.h>
+#include <asm/arch/edma.h>
 #include "clock.h"
 
 /**************************************************************************
@@ -270,6 +272,94 @@ static void setup_ethernet(void)
 #define setup_ethernet()
 #endif
 
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+static struct resource mmc0_resources[] = {
+	[0] = {			/* registers */
+		.start	= DM355_MMC0_BASE,
+		.end	= DM355_MMC0_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {			/* interrupt */
+		.start	= IRQ_DM355_MMCINT0,
+		.end	= IRQ_DM355_MMCINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {			/* dma rx */
+		.start	= DM355_DMA_MMC0RXEVT,
+		.end	= DM355_DMA_MMC0RXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {			/* dma tx */
+		.start	= DM355_DMA_MMC0TXEVT,
+		.end	= DM355_DMA_MMC0TXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct davinci_mmc_platform_data mmc0_platform_data = {
+	.mmc_clk = "MMCSDCLK0",
+	.rw_threshold = 32,
+	.use_4bit_mode = 1,
+};
+
+static struct platform_device mmc0_device = {
+	.name = "mmc",
+	.id = 0,
+	.dev = {
+		.platform_data = &mmc0_platform_data,
+		},
+	.num_resources = ARRAY_SIZE(mmc0_resources),
+	.resource = mmc0_resources,
+};
+
+static struct resource mmc1_resources[] = {
+	[0] = {			/* registers */
+		.start	= DM355_MMC1_BASE,
+		.end	= DM355_MMC1_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {			/* interrupt */
+		.start	= IRQ_DM355_MMCINT1,
+		.end	= IRQ_DM355_MMCINT1,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {			/* dma rx */
+		.start	= DM355_DMA_MMC1RXEVT,
+		.end	= DM355_DMA_MMC1RXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {			/* dma tx */
+		.start	= DM355_DMA_MMC1TXEVT,
+		.end	= DM355_DMA_MMC1TXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct davinci_mmc_platform_data mmc1_platform_data = {
+	.mmc_clk = "MMCSDCLK1",
+	.rw_threshold = 32,
+	.use_4bit_mode = 1,
+};
+
+static struct platform_device mmc1_device = {
+	.name = "mmc",
+	.id = 1,
+	.dev = {
+		.platform_data = &mmc1_platform_data,
+		},
+	.num_resources = ARRAY_SIZE(mmc1_resources),
+	.resource = mmc1_resources,
+};
+
+static void setup_mmc(void)
+{
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD0, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD1, 1);
+}
+#else
+#define setup_mmc()
+#endif
+
 static struct platform_device *dm355_evm_devices[] __initdata =
 {
 	&serial_device,
@@ -279,6 +369,10 @@ static struct platform_device *dm355_evm
 #if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
 	&dm9000_device,
 #endif
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+	&mmc0_device,
+	&mmc1_device,
+#endif
 };
 
 static void board_init(void)
@@ -289,7 +383,6 @@ static void board_init(void)
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC0, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC1, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_GPIO, 1);
-	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_McBSP1, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_SPI, 1);
 
@@ -311,6 +404,7 @@ davinci_map_io(void)
 static __init void davinci_init(void)
 {
 	setup_ethernet();
+	setup_mmc();
 
 	platform_add_devices(dm355_evm_devices,
 		ARRAY_SIZE(dm355_evm_devices));
Index: linux-2.6.10/drivers/mmc/davinci_mmc.c
===================================================================
--- linux-2.6.10.orig/drivers/mmc/davinci_mmc.c
+++ linux-2.6.10/drivers/mmc/davinci_mmc.c
@@ -56,71 +56,33 @@
 #include <asm/io.h>
 
 #include "davinci_mmc.h"
+#include <linux/davinci_mmc.h>	/* for platform data */
 #include <asm/arch/edma.h>
 
 extern void davinci_clean_channel(int ch_no);
 
 /* MMCSD Init clock in Hz in opendain mode */
 #define MMCSD_INIT_CLOCK 		200000
-#define DRIVER_NAME 			"mmc0"
-#define MMCINT_INTERRUPT    		IRQ_MMCINT
-#define MMCSD_REGS_BASE_ADDR  		DAVINCI_MMC_SD_BASE
+#define DRIVER_NAME 			"mmc"
 #define TCINTEN 			(0x1<<20)
 
 /* This macro could not be defined to 0 (ZERO) or -ve value.
  * This value is multiplied to "HZ"
  * while requesting for timer interrupt every time for probing card.
  */
-#define MULTIPILER_TO_HZ 1
+#define MULTIPLIER_TO_HZ 1
 
-struct device mmc_dev;
-struct clk *mmc_clkp = NULL;
-mmcsd_config_def mmcsd_cfg = {
-/* read write thresholds (in bytes) can be any power of 2 from 2 to 64 */
-	32,
-/* To use the DMA or not-- 1- Use DMA, 0-Interrupt mode */
-	1,
-/* flag Indicates 1bit/4bit mode */
-	1
-};
-
-volatile mmcsd_regs_base *mmcsd_regs;
-static unsigned int mmc_input_clk = 0;
-
-/* Used to identify whether card being used currently by linux core or not */
-static unsigned int is_card_busy = 0;
-/* used to identify whether card probe(detection) is currently in progress */
-static unsigned int is_card_detect_progress = 0;
-/* used to identify whether core is icurrently initilizing the card or not */
-static unsigned int is_init_progress = 0;
-/* used to identify whether core request has been queue up or
- * not because request has come when card detection/probe was in progress
- */
-static unsigned int is_req_queued_up = 0;
-/* data struture to queue one request */
-static struct mmc_host *que_mmc_host = NULL;
-/* data structure to queue one request */
-static struct mmc_request *que_mmc_request = NULL;
-
-/* tells whether card is initizlzed or not */
-static unsigned int is_card_initialized = 0;
-static unsigned int new_card_state = 0;	/* tells current state of card */
-static unsigned int is_card_removed = 0;
-
-static DEFINE_SPINLOCK(mmc_lock);
-
-#define RSP_TYPE(x)	((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))
 #define MMCST1_BUSY	(1 << 0)
 
-static inline void wait_on_data(void)
+static inline void wait_on_data(struct mmc_davinci_host *host)
 {
 	int cnt = 900000;
-	while (((mmcsd_regs->mmc_st1) & MMCST1_BUSY) && cnt) {
+	while (((mmcsd_regs(host)->mmc_st1) & MMCST1_BUSY) && cnt) {
 		cnt--;
 		udelay(1);
 	}
 	if (!cnt) {
-		dev_warn(&mmc_dev, "ERROR: TOUT waiting for BUSY\n");
+		dev_warn(host->dev, "ERROR: TOUT waiting for BUSY\n");
 	}
 }
 
@@ -133,43 +95,42 @@ static void mmc_davinci_start_command(st
 	unsigned long flags;
 
 #ifdef CONFIG_MMC_DEBUG
-	dev_dbg(&mmc_dev, "\nMMCSD : CMD%d, argument 0x%08x",
-		cmd->opcode, cmd->arg);
-	switch (RSP_TYPE(mmc_resp_type(cmd))) {
-	case RSP_TYPE(MMC_RSP_R1):
-		dev_dbg(&mmc_dev, ", R1/R1b response");
-		break;
-	case RSP_TYPE(MMC_RSP_R2):
-		dev_dbg(&mmc_dev, ", R2 response");
-		break;
-	case RSP_TYPE(MMC_RSP_R3):
-		dev_dbg(&mmc_dev, ", R3 response");
-		break;
-	default:
-		break;
-	}
-	dev_dbg(&mmc_dev, "\n");
+	if (cmd->flags & MMC_RSP_SHORT)
+		dev_dbg(host->dev, ", 32-bit response");
+	if (cmd->flags & MMC_RSP_LONG)
+		dev_dbg(host->dev, ", 128-bit response");
+	if (cmd->flags & MMC_RSP_CRC)
+		dev_dbg(host->dev, ", CRC");
+	if (cmd->flags & MMC_RSP_BUSY)
+		dev_dbg(host->dev, ", busy notification");
+	else
+		dev_dbg(host->dev, ", No busy notification");
+	dev_dbg(host->dev, "\n");
 #endif
 	host->cmd = cmd;
 
 	/* Protocol layer does not provide response type,
 	 * but our hardware needs to know exact type, not just size!
 	 */
-	switch (RSP_TYPE(mmc_resp_type(cmd))) {
+	switch (cmd->flags & MMC_RSP_MASK) {
 	case MMC_RSP_NONE:
 		/* resp 0 */
 		break;
-	case RSP_TYPE(MMC_RSP_R1):
-		resp_type = 1;
+	case MMC_RSP_SHORT:
+		/* resp 1, resp 1b */
+		/* OR resp 3!! (assume this if bus is set opendrain) */
+		if (host->bus_mode == MMC_BUSMODE_OPENDRAIN) {
+			resp_type = 3;
+			if (cmd->opcode == 3)
+				resp_type = 1;
+		} else {
+			resp_type = 1;
+		}
 		break;
-	case RSP_TYPE(MMC_RSP_R2):
+	case MMC_RSP_LONG:
+		/* resp 2 */
 		resp_type = 2;
 		break;
-	case RSP_TYPE(MMC_RSP_R3):
-		resp_type = 3;
-		break;
-	default:
-		break;
 	}
 
 	/* Protocol layer does not provide command type, but our hardware
@@ -186,11 +147,11 @@ static void mmc_davinci_start_command(st
 	 * rest are ac, except if opendrain
 	 */
 
-	if (mmc_cmd_type(cmd) == MMC_CMD_ADTC) {
+	if (host->data_dir) {
 		cmd_type = DAVINCI_MMC_CMDTYPE_ADTC;
-	} else if (mmc_cmd_type(cmd) == MMC_CMD_BC) {
+	} else if (resp_type == 0 && cmd->opcode != 15) {
 		cmd_type = DAVINCI_MMC_CMDTYPE_BC;
-	} else if (mmc_cmd_type(cmd) == MMC_CMD_BCR) {
+	} else if (host->bus_mode == MMC_BUSMODE_OPENDRAIN) {
 		cmd_type = DAVINCI_MMC_CMDTYPE_BCR;
 	} else {
 		cmd_type = DAVINCI_MMC_CMDTYPE_AC;
@@ -245,12 +206,12 @@ static void mmc_davinci_start_command(st
 	}
 
 	/* set Command timeout */
-	mmcsd_regs->mmc_tor = 0xFFFF;
+	mmcsd_regs(host)->mmc_tor = 0xFFFF;
 
 	/* Enable interrupt */
 	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
 		if (host->do_dma != 1) {
-			mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+			mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 					      MMCSD_EVENT_WRITE |
 					      MMCSD_EVENT_ERROR_CMDCRC |
 					      MMCSD_EVENT_ERROR_DATACRC |
@@ -258,7 +219,7 @@ static void mmc_davinci_start_command(st
 					      MMCSD_EVENT_ERROR_DATATIMEOUT |
 					      MMCSD_EVENT_BLOCK_XFERRED);
 		} else {
-			mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+			mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 					      MMCSD_EVENT_ERROR_CMDCRC |
 					      MMCSD_EVENT_ERROR_DATACRC |
 					      MMCSD_EVENT_ERROR_CMDTIMEOUT |
@@ -267,7 +228,7 @@ static void mmc_davinci_start_command(st
 		}
 	} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {
 		if (host->do_dma != 1) {
-			mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+			mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 					      MMCSD_EVENT_READ |
 					      MMCSD_EVENT_ERROR_CMDCRC |
 					      MMCSD_EVENT_ERROR_DATACRC |
@@ -275,7 +236,7 @@ static void mmc_davinci_start_command(st
 					      MMCSD_EVENT_ERROR_DATATIMEOUT |
 					      MMCSD_EVENT_BLOCK_XFERRED);
 		} else {
-			mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+			mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 					      MMCSD_EVENT_ERROR_CMDCRC |
 					      MMCSD_EVENT_ERROR_DATACRC |
 					      MMCSD_EVENT_ERROR_CMDTIMEOUT |
@@ -284,7 +245,7 @@ static void mmc_davinci_start_command(st
 		}
 
 	} else {
-		mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+		mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 				      MMCSD_EVENT_ERROR_CMDCRC |
 				      MMCSD_EVENT_ERROR_DATACRC |
 				      MMCSD_EVENT_ERROR_CMDTIMEOUT |
@@ -303,24 +264,24 @@ static void mmc_davinci_start_command(st
 	}
 
 	if (cmd->opcode == 7) {
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_removed = 0;
-		new_card_state = 1;
-		is_card_initialized = 1;
-		host->old_card_state = new_card_state;
-		is_init_progress = 0;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_removed = 0;
+		host->new_card_state = 1;
+		host->is_card_initialized = 1;
+		host->old_card_state = host->new_card_state;
+		host->is_init_progress = 0;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 	}
 	if (cmd->opcode == 1 || cmd->opcode == 41) {
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_initialized = 0;
-		is_init_progress = 1;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_initialized = 0;
+		host->is_init_progress = 1;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 	}
 
 	host->is_core_command = 1;
-	mmcsd_regs->mmc_arghl = cmd->arg;
-	mmcsd_regs->mmc_cmd = cmd_reg;
+	mmcsd_regs(host)->mmc_arghl = cmd->arg;
+	mmcsd_regs(host)->mmc_cmd = cmd_reg;
 
 }
 
@@ -328,7 +289,7 @@ static void mmc_davinci_dma_cb(int lch, 
 {
 	if (DMA_COMPLETE != ch_status) {
 		struct mmc_davinci_host *host = (struct mmc_davinci_host *)data;
-		dev_warn(&mmc_dev, "[DMA FAILED]");
+		dev_warn(host->dev, "[DMA FAILED]");
 		davinci_abort_dma(host);
 	}
 }
@@ -343,7 +304,7 @@ static void davinci_fifo_data_trans(stru
 		mmc_davinci_sg_to_buf(host);
 	}
 
-	n = mmcsd_cfg.rw_threshold;
+	n = host->rw_threshold;
 	if (n > host->buffer_bytes_left) {
 		n = host->buffer_bytes_left;
 	}
@@ -352,28 +313,24 @@ static void davinci_fifo_data_trans(stru
 
 	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
 		for (i = 0; i < (n / 4); i++) {
-			mmcsd_regs->mmc_dxr = *host->buffer;
+			mmcsd_regs(host)->mmc_dxr = *host->buffer;
 			host->buffer++;
 		}
 	} else {
 		for (i = 0; i < (n / 4); i++) {
-			*host->buffer = mmcsd_regs->mmc_drr;
+			*host->buffer = mmcsd_regs(host)->mmc_drr;
 			host->buffer++;
 		}
 	}
 }
 
-static void davinci_reinit_chan(void)
+static void davinci_reinit_chan(struct mmc_davinci_host *host)
 {
-	int sync_dev;
+	davinci_stop_dma(host->dma_tx_event);
+	davinci_clean_channel(host->dma_tx_event);
 
-	sync_dev = DAVINCI_DMA_MMCTXEVT;
-	davinci_stop_dma(sync_dev);
-	davinci_clean_channel(sync_dev);
-
-	sync_dev = DAVINCI_DMA_MMCRXEVT;
-	davinci_stop_dma(sync_dev);
-	davinci_clean_channel(sync_dev);
+	davinci_stop_dma(host->dma_rx_event);
+	davinci_clean_channel(host->dma_rx_event);
 }
 
 static void davinci_abort_dma(struct mmc_davinci_host *host)
@@ -381,9 +338,9 @@ static void davinci_abort_dma(struct mmc
 	int sync_dev = 0;
 
 	if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {
-		sync_dev = DAVINCI_DMA_MMCTXEVT;
+		sync_dev = host->dma_tx_event;
 	} else {
-		sync_dev = DAVINCI_DMA_MMCRXEVT;
+		sync_dev = host->dma_rx_event;
 	}
 
 	davinci_stop_dma(sync_dev);
@@ -398,7 +355,7 @@ static int mmc_davinci_start_dma_transfe
 	struct mmc_data *data = host->data;
 	int block_size = (1 << data->blksz_bits);
 
-	host->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
+	host->sg_len = dma_map_sg(host->dev, data->sg, host->sg_len,
 				  ((data->
 				    flags & MMC_DATA_WRITE) ? DMA_TO_DEVICE :
 				   DMA_FROM_DEVICE));
@@ -412,7 +369,7 @@ static int mmc_davinci_start_dma_transfe
 	}
 
 	if (!use_dma) {
-		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
+		dma_unmap_sg(host->dev, data->sg, host->sg_len,
 			     (data->
 			      flags & MMC_DATA_WRITE) ? DMA_TO_DEVICE :
 			     DMA_FROM_DEVICE);
@@ -421,8 +378,6 @@ static int mmc_davinci_start_dma_transfe
 
 	host->do_dma = 1;
 
-	host->dma_state = 0;
-
 	mmc_davinci_send_dma_request(host, req);
 
 	return 0;
@@ -431,8 +386,8 @@ static int mmc_davinci_start_dma_transfe
 
 static int davinci_release_dma_channels(struct mmc_davinci_host *host)
 {
-	davinci_free_dma(DAVINCI_DMA_MMCTXEVT);
-	davinci_free_dma(DAVINCI_DMA_MMCRXEVT);
+	davinci_free_dma(host->dma_tx_event);
+	davinci_free_dma(host->dma_rx_event);
 
 	if (host->edma_ch_details.cnt_chanel) {
 		davinci_free_dma(host->edma_ch_details.chanel_num[0]);
@@ -448,19 +403,19 @@ static int davinci_acquire_dma_channels(
 	enum dma_event_q queue_no = EVENTQ_0;
 
 	/* Acquire master DMA write channel */
-	if ((r = davinci_request_dma(DAVINCI_DMA_MMCTXEVT, "MMC_WRITE",
+	if ((r = davinci_request_dma(host->dma_tx_event, "MMC_WRITE",
 				     mmc_davinci_dma_cb, host,
 				     &edma_chan_num, &tcc, queue_no)) != 0) {
-		dev_warn(&mmc_dev,
+		dev_warn(host->dev,
 			 "MMC: davinci_request_dma() failed with %d\n", r);
 		return r;
 	}
 
 	/* Acquire master DMA read channel */
-	if ((r = davinci_request_dma(DAVINCI_DMA_MMCRXEVT, "MMC_READ",
+	if ((r = davinci_request_dma(host->dma_rx_event, "MMC_READ",
 				     mmc_davinci_dma_cb, host,
 				     &edma_chan_num, &tcc, queue_no)) != 0) {
-		dev_warn(&mmc_dev,
+		dev_warn(host->dev,
 			 "MMC: davinci_request_dma() failed with %d\n", r);
 		goto free_master_write;
 	}
@@ -472,11 +427,11 @@ static int davinci_acquire_dma_channels(
 
 	/* Create a DMA slave read channel 
 	 * (assuming max segments handled is 2) */
-	sync_dev = DAVINCI_DMA_MMCRXEVT;
+	sync_dev = host->dma_rx_event;
 	if ((r = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, "LINK",
 				     NULL, NULL, &edma_chan_num,
 				     &sync_dev, queue_no)) != 0) {
-		dev_warn(&mmc_dev,
+		dev_warn(host->dev,
 			 "MMC: davinci_request_dma() failed with %d\n", r);
 		goto free_master_read;
 	}
@@ -487,9 +442,9 @@ static int davinci_acquire_dma_channels(
 	return 0;
 
       free_master_read:
-	davinci_free_dma(DAVINCI_DMA_MMCRXEVT);
+	davinci_free_dma(host->dma_rx_event);
       free_master_write:
-	davinci_free_dma(DAVINCI_DMA_MMCTXEVT);
+	davinci_free_dma(host->dma_tx_event);
 
 	return r;
 }
@@ -545,14 +500,14 @@ static int mmc_davinci_send_dma_request(
 
 	if (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {
 		/*AB Sync Transfer */
-		sync_dev = DAVINCI_DMA_MMCTXEVT;
+		sync_dev = host->dma_tx_event;
 
 		src_port = (unsigned int)sg_dma_address(sg);
 		mode_src = INCR;
 		fifo_width_src = W8BIT;	/* It's not cared as modeDsr is INCR */
 		src_bidx = acnt;
 		src_cidx = acnt * bcnt;
-		dst_port = MMCSD_REGS_BASE_ADDR + 0x2C;
+		dst_port = host->reg_res->start + 0x2C;
 		mode_dst = INCR;
 		fifo_width_dst = W8BIT;	/* It's not cared as modeDsr is INCR */
 		dst_bidx = 0;
@@ -561,9 +516,9 @@ static int mmc_davinci_send_dma_request(
 		sync_mode = ABSYNC;
 
 	} else {
-		sync_dev = DAVINCI_DMA_MMCRXEVT;
+		sync_dev = host->dma_rx_event;
 
-		src_port = MMCSD_REGS_BASE_ADDR + 0x28;
+		src_port = host->reg_res->start + 0x28;
 		mode_src = INCR;
 		fifo_width_src = W8BIT;
 		src_bidx = 0;
@@ -587,7 +542,7 @@ static int mmc_davinci_send_dma_request(
 					sync_mode);
 
 	davinci_get_dma_params(sync_dev, &temp);
-	if (sync_dev == DAVINCI_DMA_MMCTXEVT) {
+	if (sync_dev == host->dma_tx_event) {
 		if (option_write == 0) {
 			option_write = temp.opt;
 		} else {
@@ -595,7 +550,7 @@ static int mmc_davinci_send_dma_request(
 			davinci_set_dma_params(sync_dev, &temp);
 		}
 	}
-	if (sync_dev == DAVINCI_DMA_MMCRXEVT) {
+	if (sync_dev == host->dma_rx_event) {
 		if (option_read == 0) {
 			option_read = temp.opt;
 		} else {
@@ -633,7 +588,7 @@ static int mmc_davinci_send_dma_request(
 
 			ccnt = count / 32;
 
-			if (sync_dev == DAVINCI_DMA_MMCTXEVT) {
+			if (sync_dev == host->dma_tx_event) {
 				temp.src = (unsigned int)sg_dma_address(sg);
 			} else {
 				temp.dst = (unsigned int)sg_dma_address(sg);
@@ -665,14 +620,14 @@ static void mmc_davinci_prepare_data(str
 	host->data = req->data;
 	if (req->data == NULL) {
 		host->data_dir = DAVINCI_MMC_DATADIR_NONE;
-		mmcsd_regs->mmc_blen = 0;
-		mmcsd_regs->mmc_nblk = 0;
+		mmcsd_regs(host)->mmc_blen = 0;
+		mmcsd_regs(host)->mmc_nblk = 0;
 		return;
 	}
 	/* Init idx */
 	host->sg_idx = 0;
 
-	dev_dbg(&mmc_dev,
+	dev_dbg(host->dev,
 		"MMCSD : Data xfer (%s %s), "
 		"DTO %d cycles + %d ns, %d blocks of %d bytes\r\n",
 		(req->data->flags & MMC_DATA_STREAM) ? "stream" : "block",
@@ -688,25 +643,25 @@ static void mmc_davinci_prepare_data(str
 		timeout = 0xffff;
 	}
 
-	mmcsd_regs->mmc_tod = timeout;
-	mmcsd_regs->mmc_nblk = req->data->blocks;
-	mmcsd_regs->mmc_blen = (1 << req->data->blksz_bits);
+	mmcsd_regs(host)->mmc_tod = timeout;
+	mmcsd_regs(host)->mmc_nblk = req->data->blocks;
+	mmcsd_regs(host)->mmc_blen = (1 << req->data->blksz_bits);
 	host->data_dir = (req->data->flags & MMC_DATA_WRITE) ?
 	    DAVINCI_MMC_DATADIR_WRITE : DAVINCI_MMC_DATADIR_READ;
 
 	/* Configure the FIFO */
 	switch (host->data_dir) {
 	case DAVINCI_MMC_DATADIR_WRITE:
-		mmcsd_regs->mmc_fifo_ctl = mmcsd_regs->mmc_fifo_ctl | 0x1;
-		mmcsd_regs->mmc_fifo_ctl = 0x0;
-		mmcsd_regs->mmc_fifo_ctl = mmcsd_regs->mmc_fifo_ctl | (1 << 1);
-		mmcsd_regs->mmc_fifo_ctl = mmcsd_regs->mmc_fifo_ctl | (1 << 2);
+		mmcsd_regs(host)->mmc_fifo_ctl = mmcsd_regs(host)->mmc_fifo_ctl | 0x1;
+		mmcsd_regs(host)->mmc_fifo_ctl = 0x0;
+		mmcsd_regs(host)->mmc_fifo_ctl = mmcsd_regs(host)->mmc_fifo_ctl | (1 << 1);
+		mmcsd_regs(host)->mmc_fifo_ctl = mmcsd_regs(host)->mmc_fifo_ctl | (1 << 2);
 		break;
 
 	case DAVINCI_MMC_DATADIR_READ:
-		mmcsd_regs->mmc_fifo_ctl = mmcsd_regs->mmc_fifo_ctl | 0x1;
-		mmcsd_regs->mmc_fifo_ctl = 0x0;
-		mmcsd_regs->mmc_fifo_ctl = mmcsd_regs->mmc_fifo_ctl | (1 << 2);
+		mmcsd_regs(host)->mmc_fifo_ctl = mmcsd_regs(host)->mmc_fifo_ctl | 0x1;
+		mmcsd_regs(host)->mmc_fifo_ctl = 0x0;
+		mmcsd_regs(host)->mmc_fifo_ctl = mmcsd_regs(host)->mmc_fifo_ctl | (1 << 2);
 		break;
 	default:
 		break;
@@ -747,39 +702,41 @@ static void mmc_davinci_request(struct m
 	struct mmc_davinci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	if (is_card_removed) {
+	if (host->is_card_removed) {
 		if (req->cmd) {
 			req->cmd->error |= MMC_ERR_TIMEOUT;
 			mmc_request_done(mmc, req);
 		}
-		dev_dbg(&mmc_dev,
+		dev_dbg(host->dev,
 			"From code segment excuted when card removed\n");
 		return;
 	}
 
-	wait_on_data();
+	wait_on_data(host);
 
-	if (!is_card_detect_progress) {
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_busy = 1;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+	if (!host->is_card_detect_progress) {
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_busy = 1;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 		host->do_dma = 0;
 		mmc_davinci_prepare_data(host, req);
 		mmc_davinci_start_command(host, req->cmd);
 	} else {
 		/* Queue up the request as card dectection is being excuted */
-		que_mmc_host = mmc;
-		que_mmc_request = req;
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_req_queued_up = 1;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		host->que_mmc_host = mmc;
+		host->que_mmc_request = req;
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_req_queued_up = 1;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 	}
 }
 
-static unsigned int calculate_freq_for_card(unsigned int mmc_req_freq)
+static unsigned int calculate_freq_for_card(struct mmc_davinci_host *host,
+			unsigned int mmc_req_freq)
 {
-	unsigned int mmc_freq = 0, cpu_arm_clk = 0, mmc_push_pull = 0;
-	cpu_arm_clk = mmc_input_clk;
+	unsigned int mmc_freq, cpu_arm_clk, mmc_push_pull;
+
+	cpu_arm_clk = clk_get_rate(host->clk);
 
 	if (cpu_arm_clk > (2 * mmc_req_freq)) {
 		mmc_push_pull =
@@ -800,46 +757,46 @@ static unsigned int calculate_freq_for_c
 static void mmc_davinci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	unsigned short status;
-	unsigned int open_drain_freq = 0, cpu_arm_clk = 0;
-	unsigned int mmc_push_pull_freq = 0;
+	unsigned int open_drain_freq, cpu_arm_clk;
+	unsigned int mmc_push_pull_freq;
 	struct mmc_davinci_host *host = mmc_priv(mmc);
 
-	cpu_arm_clk = mmc_input_clk;
-	dev_dbg(&mmc_dev, "clock %dHz busmode %d powermode %d Vdd %d.%02d\r\n",
+	cpu_arm_clk = clk_get_rate(host->clk);
+	dev_dbg(host->dev, "clock %dHz busmode %d powermode %d Vdd %d.%02d\r\n",
 		ios->clock, ios->bus_mode, ios->power_mode,
 		ios->vdd / 100, ios->vdd % 100);
 	if (ios->bus_width == MMC_BUS_WIDTH_4) {
-		dev_dbg(&mmc_dev, "\nEnabling 4 bit mode\n");
-		mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl | (1 << 2);
+		dev_dbg(host->dev, "\nEnabling 4 bit mode\n");
+		mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl | (1 << 2);
 	} else {
-		dev_dbg(&mmc_dev, "Disabling 4 bit mode\n");
-		mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl & ~(1 << 2);
+		dev_dbg(host->dev, "Disabling 4 bit mode\n");
+		mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl & ~(1 << 2);
 	}
 
 	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN) {
 
 		open_drain_freq =
-		    ((unsigned int)cpu_arm_clk / (2 * MMCSD_INIT_CLOCK)) - 1;
-		mmcsd_regs->mmc_clk =
-		    (mmcsd_regs->mmc_clk & ~(0xFF)) | open_drain_freq;
+		    ((unsigned int)(cpu_arm_clk + 2*MMCSD_INIT_CLOCK - 1)
+			/ (2 * MMCSD_INIT_CLOCK)) - 1;
+		if (open_drain_freq > 0xff)
+			open_drain_freq = 0xff;
+		mmcsd_regs(host)->mmc_clk = open_drain_freq | 0x100;
 
 	} else {
-		mmc_push_pull_freq = calculate_freq_for_card(ios->clock);
-		mmcsd_regs->mmc_clk &= ~(0x100);
+		mmc_push_pull_freq = calculate_freq_for_card(host, ios->clock);
+		mmcsd_regs(host)->mmc_clk &= ~(0x100);
 		udelay(10);
-		mmcsd_regs->mmc_clk =
-		    (mmcsd_regs->mmc_clk & ~(0xFF)) | mmc_push_pull_freq;
-		mmcsd_regs->mmc_clk |= 0x100;
+		mmcsd_regs(host)->mmc_clk = mmc_push_pull_freq | 0x100;
 		udelay(10);
 	}
 	host->bus_mode = ios->bus_mode;
 	if (ios->power_mode == MMC_POWER_UP) {
 		/* Send clock cycles, poll completion */
-		mmcsd_regs->mmc_arghl = 0x0;
-		mmcsd_regs->mmc_cmd = 0x4000;
+		mmcsd_regs(host)->mmc_arghl = 0x0;
+		mmcsd_regs(host)->mmc_cmd = 0x4000;
 		status = 0;
 		while (!(status & (MMCSD_EVENT_EOFCMD))) {
-			status = mmcsd_regs->mmc_st0;
+			status = mmcsd_regs(host)->mmc_st0;
 		}
 	}
 }
@@ -856,25 +813,24 @@ static void mmc_davinci_xfer_done(struct
 	if (host->do_dma) {
 		davinci_abort_dma(host);
 
-		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
+		dma_unmap_sg(host->dev, data->sg, host->sg_len,
 			     (data->
 			      flags & MMC_DATA_WRITE) ? DMA_TO_DEVICE :
 			     DMA_FROM_DEVICE);
 	}
 
 	if (data->error == MMC_ERR_TIMEOUT) {
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_busy = 0;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_busy = 0;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 		mmc_request_done(host->mmc, data->mrq);
 		return;
 	}
 
 	if (!data->stop) {
-		host->req = NULL;
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_busy = 0;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_busy = 0;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 		mmc_request_done(host->mmc, data->mrq);
 		return;
 	}
@@ -888,31 +844,36 @@ static void mmc_davinci_cmd_done(struct 
 	host->cmd = NULL;
 
 	if (!cmd) {
-		dev_warn(&mmc_dev, "%s(): No cmd ptr\n", __FUNCTION__);
+		dev_warn(host->dev, "%s(): No cmd ptr\n", __FUNCTION__);
 		return;
 	}
 
-	if (cmd->flags & MMC_RSP_PRESENT) {
-		if (cmd->flags & MMC_RSP_136) {
-			/* response type 2 */
-			cmd->resp[3] = mmcsd_regs->mmc_rsp01;
-			cmd->resp[2] = mmcsd_regs->mmc_rsp23;
-			cmd->resp[1] = mmcsd_regs->mmc_rsp45;
-			cmd->resp[0] = mmcsd_regs->mmc_rsp67;
-		} else {
-			/* response types 1, 1b, 3, 4, 5, 6 */
-			cmd->resp[0] = mmcsd_regs->mmc_rsp67;
-		}
+	switch (cmd->flags & MMC_RSP_MASK) {
+	case MMC_RSP_NONE:
+		/* resp 0 */
+		break;
+
+	case MMC_RSP_SHORT:
+		/* response types 1, 1b, 3, 4, 5, 6 */
+		cmd->resp[0] = mmcsd_regs(host)->mmc_rsp67;
+		break;
+
+	case MMC_RSP_LONG:
+		/* response type 2 */
+		cmd->resp[3] = mmcsd_regs(host)->mmc_rsp01;
+		cmd->resp[2] = mmcsd_regs(host)->mmc_rsp23;
+		cmd->resp[1] = mmcsd_regs(host)->mmc_rsp45;
+		cmd->resp[0] = mmcsd_regs(host)->mmc_rsp67;
+		break;
 	}
 
 	if (host->data == NULL || cmd->error != MMC_ERR_NONE) {
-		host->req = NULL;
 		if (cmd->error == MMC_ERR_TIMEOUT) {
 			cmd->mrq->cmd->retries = 0;
 		}
-		spin_lock_irqsave(&mmc_lock, flags);
-		is_card_busy = 0;
-		spin_unlock_irqrestore(&mmc_lock, flags);
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		host->is_card_busy = 0;
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
 		mmc_request_done(host->mmc, cmd->mrq);
 	}
 
@@ -928,29 +889,29 @@ static irqreturn_t mmc_davinci_irq(int i
 
 	if (host->is_core_command) {
 		if (host->cmd == NULL && host->data == NULL) {
-			status = mmcsd_regs->mmc_st0;
-			dev_dbg(&mmc_dev, "Spurious interrupt 0x%04x\r\n",
+			status = mmcsd_regs(host)->mmc_st0;
+			dev_dbg(host->dev, "Spurious interrupt 0x%04x\r\n",
 				status);
 			/* Disable the interrupt from mmcsd */
-			mmcsd_regs->mmc_im = 0;
+			mmcsd_regs(host)->mmc_im = 0;
 			return IRQ_HANDLED;
 		}
 	}
 	end_command = 0;
 	end_transfer = 0;
 
-	status = mmcsd_regs->mmc_st0;
+	status = mmcsd_regs(host)->mmc_st0;
 	if (status == 0) {
 		return IRQ_HANDLED;
 	}
 	if (host->is_core_command) {
-		if (is_card_initialized) {
-			if (new_card_state == 0) {
+		if (host->is_card_initialized) {
+			if (host->new_card_state == 0) {
 				if (host->cmd) {
 					host->cmd->error |= MMC_ERR_TIMEOUT;
 					mmc_davinci_cmd_done(host, host->cmd);
 				}
-				dev_dbg(&mmc_dev,
+				dev_dbg(host->dev,
 					"From code segment excuted when card removed\n");
 				return IRQ_HANDLED;
 			}
@@ -990,22 +951,22 @@ static irqreturn_t mmc_davinci_irq(int i
 						end_transfer = 1;
 					}
 				} else {
-					dev_warn(&mmc_dev,
+					dev_warn(host->dev,
 						 "TC:host->data is NULL\n");
 				}
 			}
 
 			if (status & MMCSD_EVENT_ERROR_DATATIMEOUT) {
 				/* Data timeout */
-				if ((host->data) && (new_card_state != 0)) {
+				if ((host->data) && (host->new_card_state != 0)) {
 					host->data->error |= MMC_ERR_TIMEOUT;
-					spin_lock_irqsave(&mmc_lock, flags);
-					is_card_removed = 1;
-					new_card_state = 0;
-					is_card_initialized = 0;
-					spin_unlock_irqrestore(&mmc_lock,
+					spin_lock_irqsave(&host->mmc_lock, flags);
+					host->is_card_removed = 1;
+					host->new_card_state = 0;
+					host->is_card_initialized = 0;
+					spin_unlock_irqrestore(&host->mmc_lock,
 							       flags);
-					dev_dbg(&mmc_dev,
+					dev_dbg(host->dev,
 						"MMCSD: Data timeout, CMD%d and status is %x\r\n",
 						host->cmd->opcode, status);
 
@@ -1019,21 +980,21 @@ static irqreturn_t mmc_davinci_irq(int i
 
 			if (status & MMCSD_EVENT_ERROR_DATACRC) {
 				/* DAT line portion is diabled and in reset state */
-				mmcsd_regs->mmc_ctl =
-				    mmcsd_regs->mmc_ctl | (1 << 1);
+				mmcsd_regs(host)->mmc_ctl =
+				    mmcsd_regs(host)->mmc_ctl | (1 << 1);
 				udelay(10);
-				mmcsd_regs->mmc_ctl =
-				    mmcsd_regs->mmc_ctl & ~(1 << 1);
+				mmcsd_regs(host)->mmc_ctl =
+				    mmcsd_regs(host)->mmc_ctl & ~(1 << 1);
 
 				/* Data CRC error */
 				if (host->data) {
 					host->data->error |= MMC_ERR_BADCRC;
-					dev_dbg(&mmc_dev,
+					dev_dbg(host->dev,
 						"MMCSD: Data CRC error, bytes left %d\r\n",
 						host->bytes_left);
 					end_transfer = 1;
 				} else {
-					dev_dbg(&mmc_dev,
+					dev_dbg(host->dev,
 						"MMCSD: Data CRC error\r\n");
 				}
 			}
@@ -1051,16 +1012,16 @@ static irqreturn_t mmc_davinci_irq(int i
 					 */
 					if (host->cmd->opcode !=
 					    MMC_ALL_SEND_CID) {
-						dev_dbg(&mmc_dev,
+						dev_dbg(host->dev,
 							"MMCSD: Command timeout, CMD%d and status is %x\r\n",
 							host->cmd->opcode,
 							status);
-						spin_lock_irqsave(&mmc_lock,
+						spin_lock_irqsave(&host->mmc_lock,
 								  flags);
-						new_card_state = 0;
-						is_card_initialized = 0;
+						host->new_card_state = 0;
+						host->is_card_initialized = 0;
 						spin_unlock_irqrestore
-						    (&mmc_lock, flags);
+						    (&host->mmc_lock, flags);
 					}
 					host->cmd->error |= MMC_ERR_TIMEOUT;
 					end_command = 1;
@@ -1070,7 +1031,7 @@ static irqreturn_t mmc_davinci_irq(int i
 
 			if (status & MMCSD_EVENT_ERROR_CMDCRC) {
 				/* Command CRC error */
-				dev_dbg(&mmc_dev, "Command CRC error\r\n");
+				dev_dbg(host->dev, "Command CRC error\r\n");
 				if (host->cmd) {
 					/* Ignore CMD CRC errors during high speed operation */
 					if (host->mmc->ios.clock <= 25000000) {
@@ -1087,16 +1048,16 @@ static irqreturn_t mmc_davinci_irq(int i
 			}
 
 			if (host->data == NULL) {
-				status = mmcsd_regs->mmc_st0;
+				status = mmcsd_regs(host)->mmc_st0;
 				if (status != 0) {
-					dev_dbg(&mmc_dev,
+					dev_dbg(host->dev,
 						"Status is %x at end of ISR when host->data is NULL",
 						status);
 					status = 0;
 
 				}
 			} else {
-				status = mmcsd_regs->mmc_st0;
+				status = mmcsd_regs(host)->mmc_st0;
 			}
 		}
 
@@ -1110,58 +1071,58 @@ static irqreturn_t mmc_davinci_irq(int i
 	} else {
 		if (host->cmd_code == 13) {
 			if (status & MMCSD_EVENT_EOFCMD) {
-				spin_lock_irqsave(&mmc_lock, flags);
-				new_card_state = 1;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->new_card_state = 1;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 
 			} else {
-				spin_lock_irqsave(&mmc_lock, flags);
-				is_card_removed = 1;
-				new_card_state = 0;
-				is_card_initialized = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->is_card_removed = 1;
+				host->new_card_state = 0;
+				host->is_card_initialized = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			}
 
-			spin_lock_irqsave(&mmc_lock, flags);
-			is_card_detect_progress = 0;
-			spin_unlock_irqrestore(&mmc_lock, flags);
-
-			if (is_req_queued_up) {
-				mmc_davinci_request(que_mmc_host,
-						    que_mmc_request);
-				spin_lock_irqsave(&mmc_lock, flags);
-				is_req_queued_up = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+			spin_lock_irqsave(&host->mmc_lock, flags);
+			host->is_card_detect_progress = 0;
+			spin_unlock_irqrestore(&host->mmc_lock, flags);
+
+			if (host->is_req_queued_up) {
+				mmc_davinci_request(host->que_mmc_host,
+						    host->que_mmc_request);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->is_req_queued_up = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			}
 
 		}
 
 		if (host->cmd_code == 1 || host->cmd_code == 55) {
 			if (status & MMCSD_EVENT_EOFCMD) {
-				spin_lock_irqsave(&mmc_lock, flags);
-				is_card_removed = 0;
-				new_card_state = 1;
-				is_card_initialized = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->is_card_removed = 0;
+				host->new_card_state = 1;
+				host->is_card_initialized = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			} else {
 
-				spin_lock_irqsave(&mmc_lock, flags);
-				is_card_removed = 1;
-				new_card_state = 0;
-				is_card_initialized = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->is_card_removed = 1;
+				host->new_card_state = 0;
+				host->is_card_initialized = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			}
 
-			spin_lock_irqsave(&mmc_lock, flags);
-			is_card_detect_progress = 0;
-			spin_unlock_irqrestore(&mmc_lock, flags);
-
-			if (is_req_queued_up) {
-				mmc_davinci_request(que_mmc_host,
-						    que_mmc_request);
-				spin_lock_irqsave(&mmc_lock, flags);
-				is_req_queued_up = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+			spin_lock_irqsave(&host->mmc_lock, flags);
+			host->is_card_detect_progress = 0;
+			spin_unlock_irqrestore(&host->mmc_lock, flags);
+
+			if (host->is_req_queued_up) {
+				mmc_davinci_request(host->que_mmc_host,
+						    host->que_mmc_request);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->is_req_queued_up = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			}
 		}
 
@@ -1174,26 +1135,26 @@ static irqreturn_t mmc_davinci_irq(int i
 					flag_sd_mmc = 0;
 					host->cmd_code = 1;
 					/* Issue cmd1 */
-					mmcsd_regs->mmc_arghl = 0x80300000;
-					mmcsd_regs->mmc_cmd = 0x00000601;
+					mmcsd_regs(host)->mmc_arghl = 0x80300000;
+					mmcsd_regs(host)->mmc_cmd = 0x00000601;
 				} else {
 					flag_sd_mmc = 1;
 					host->cmd_code = 55;
 					/* Issue cmd55 */
-					mmcsd_regs->mmc_arghl = 0x0;
-					mmcsd_regs->mmc_cmd =
+					mmcsd_regs(host)->mmc_arghl = 0x0;
+					mmcsd_regs(host)->mmc_cmd =
 					    ((0x0 | (1 << 9) | 55));
 				}
 
-				dev_dbg(&mmc_dev,
+				dev_dbg(host->dev,
 					"MMC-Probing mmc with cmd%d\n",
 					host->cmd_code);
 			} else {
-				spin_lock_irqsave(&mmc_lock, flags);
-				new_card_state = 0;
-				is_card_initialized = 0;
-				is_card_detect_progress = 0;
-				spin_unlock_irqrestore(&mmc_lock, flags);
+				spin_lock_irqsave(&host->mmc_lock, flags);
+				host->new_card_state = 0;
+				host->is_card_initialized = 0;
+				host->is_card_detect_progress = 0;
+				spin_unlock_irqrestore(&host->mmc_lock, flags);
 			}
 		}
 
@@ -1222,30 +1183,30 @@ void mmc_check_card(unsigned long data)
 		card = host->mmc->card_selected;
 	}
 
-	if ((!is_card_detect_progress) || (!is_init_progress)) {
-		if (is_card_initialized) {
+	if ((!host->is_card_detect_progress) || (!host->is_init_progress)) {
+		if (host->is_card_initialized) {
 			host->is_core_command = 0;
 			host->cmd_code = 13;
-			spin_lock_irqsave(&mmc_lock, flags);
-			is_card_detect_progress = 1;
-			spin_unlock_irqrestore(&mmc_lock, flags);
+			spin_lock_irqsave(&host->mmc_lock, flags);
+			host->is_card_detect_progress = 1;
+			spin_unlock_irqrestore(&host->mmc_lock, flags);
 			/* Issue cmd13 */
-			mmcsd_regs->mmc_arghl = (card
+			mmcsd_regs(host)->mmc_arghl = (card
 						 && (card->
 						     state & MMC_STATE_SDCARD))
 			    ? (card->rca << 16) : 0x10000;
-			mmcsd_regs->mmc_cmd = 0x0000028D;
+			mmcsd_regs(host)->mmc_cmd = 0x0000028D;
 		} else {
 			host->is_core_command = 0;
 			host->cmd_code = 0;
-			spin_lock_irqsave(&mmc_lock, flags);
-			is_card_detect_progress = 1;
-			spin_unlock_irqrestore(&mmc_lock, flags);
+			spin_lock_irqsave(&host->mmc_lock, flags);
+			host->is_card_detect_progress = 1;
+			spin_unlock_irqrestore(&host->mmc_lock, flags);
 			/* Issue cmd0 */
-			mmcsd_regs->mmc_arghl = 0;
-			mmcsd_regs->mmc_cmd = 0x4000;
+			mmcsd_regs(host)->mmc_arghl = 0;
+			mmcsd_regs(host)->mmc_cmd = 0x4000;
 		}
-		mmcsd_regs->mmc_im = (MMCSD_EVENT_EOFCMD |
+		mmcsd_regs(host)->mmc_im = (MMCSD_EVENT_EOFCMD |
 				      MMCSD_EVENT_ERROR_CMDCRC |
 				      MMCSD_EVENT_ERROR_DATACRC |
 				      MMCSD_EVENT_ERROR_CMDTIMEOUT |
@@ -1257,45 +1218,50 @@ static void davinci_mmc_check_status(uns
 {
 	unsigned long flags;
 	struct mmc_davinci_host *host = (struct mmc_davinci_host *)data;
-	if (!is_card_busy) {
-		if (host->old_card_state ^ new_card_state) {
-			davinci_reinit_chan();
-			init_mmcsd_host();
+	if (!host->is_card_busy) {
+		if (host->old_card_state ^ host->new_card_state) {
+			davinci_reinit_chan(host);
+			init_mmcsd_host(host);
 			mmc_detect_change(host->mmc, 0);
-			spin_lock_irqsave(&mmc_lock, flags);
-			host->old_card_state = new_card_state;
-			spin_unlock_irqrestore(&mmc_lock, flags);
+			spin_lock_irqsave(&host->mmc_lock, flags);
+			host->old_card_state = host->new_card_state;
+			spin_unlock_irqrestore(&host->mmc_lock, flags);
 		} else {
 			mmc_check_card(data);
 		}
 
 	}
-	mod_timer(&host->timer, jiffies + MULTIPILER_TO_HZ * HZ);
+	mod_timer(&host->timer, jiffies + MULTIPLIER_TO_HZ * HZ);
 }
 
-static void init_mmcsd_host(void)
+static void init_mmcsd_host(struct mmc_davinci_host *host)
 {
-	/* CMD line portion is diabled and in reset state */
-	mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl | 0x1;
-	/* DAT line portion is diabled and in reset state */
-	mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl | (1 << 1);
+	/* CMD line portion is disabled and in reset state */
+	mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl | 0x1;
+	/* DAT line portion is disabled and in reset state */
+	mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl | (1 << 1);
 	udelay(10);
 
-	mmcsd_regs->mmc_clk = 0x0;
-	mmcsd_regs->mmc_clk = mmcsd_regs->mmc_clk | (1 << 8);
+	mmcsd_regs(host)->mmc_clk = 0x0;
+	mmcsd_regs(host)->mmc_clk = mmcsd_regs(host)->mmc_clk | (1 << 8);
 
-	mmcsd_regs->mmc_tor = 0xFFFF;
-	mmcsd_regs->mmc_tod = 0xFFFF;
+	mmcsd_regs(host)->mmc_tor = 0xFFFF;
+	mmcsd_regs(host)->mmc_tod = 0xFFFF;
 
-	mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl & ~(0x1);
-	mmcsd_regs->mmc_ctl = mmcsd_regs->mmc_ctl & ~(1 << 1);
+	mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl & ~(0x1);
+	mmcsd_regs(host)->mmc_ctl = mmcsd_regs(host)->mmc_ctl & ~(1 << 1);
 	udelay(10);
 }
 
+#define res_size(_r) (((_r)->end - (_r)->start) + 1)
+
 static int davinci_mmcsd_probe(struct device *dev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
+	struct davinci_mmc_platform_data *pdata = pdev->dev.platform_data;
 	struct mmc_davinci_host *host;
 	struct mmc_host *mmc;
+	struct resource *res;
 	int ret = 0;
 
 	mmc = mmc_alloc_host(sizeof(struct mmc_davinci_host), dev);
@@ -1303,19 +1269,60 @@ static int davinci_mmcsd_probe(struct de
 		ret = -ENOMEM;
 		goto out;
 	}
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
 
-	mmcsd_regs =
-	    (volatile mmcsd_regs_base *)IO_ADDRESS(MMCSD_REGS_BASE_ADDR);
+	spin_lock_init(&host->mmc_lock);
 
-	init_mmcsd_host();
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res || (res_size(res) < sizeof(mmcsd_regs_base))
+		|| !platform_get_resource(pdev, IORESOURCE_IRQ, 0))
+	{
+		dev_err(dev, "insufficient resources\n");
+		ret = -ENOENT;
+		goto free_host;
+	}
+	host->irq = platform_get_irq(pdev, 0);
+
+	host->reg_res = request_mem_region(res->start, res_size(res),
+				pdev->name);
+	if (!host->reg_res) {
+		dev_err(dev, "cannot claim register memory region\n");
+		ret = -EIO;
+		goto free_host;
+	}
+	mmcsd_regs(host) = (volatile mmcsd_regs_base *) IO_ADDRESS(res->start);
+
+	host->use_dma = 0;
+	if (platform_get_resource(pdev, IORESOURCE_DMA, 0)
+		&& platform_get_resource(pdev, IORESOURCE_DMA, 1))
+	{
+		res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+		host->dma_rx_event = res->start;
+		res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+		host->dma_tx_event = res->start;
+		host->use_dma = 1;
+	}
 
-	if (mmcsd_cfg.use_4bit_mode) {
-		dev_warn(&mmc_dev, "Supporting 4-bit mode\n");
+	host->clk = clk_get(dev, pdata->mmc_clk);
+	if (!host->clk) {
+		ret = -ENODEV;
+		goto release_regs;
+	}
+	clk_use(host->clk);
+	clk_enable(host->clk);
+
+	init_mmcsd_host(host);
+
+	if (pdata->use_4bit_mode) {
+		dev_info(dev, "Supporting 4-bit mode\n");
 		mmc->caps |= MMC_CAP_4_BIT_DATA;
 	} else {
-		dev_warn(&mmc_dev, "Not Supporting 4-bit mode\n");
+		dev_info(dev, "Not Supporting 4-bit mode\n");
 	}
 
+	host->rw_threshold = pdata->rw_threshold;
+
 	mmc->ops = &mmc_davinci_ops;
 	mmc->f_min = 312500;
 #ifdef CONFIG_MMC_HIGHSPEED
@@ -1332,32 +1339,25 @@ static int davinci_mmcsd_probe(struct de
 	/* Restrict the max size of seg we can handle */
 	mmc->max_seg_size = mmc->max_sectors * 512;
 
-	dev_dbg(&mmc_dev, "max_phys_segs=%d\n", mmc->max_phys_segs);
-	dev_dbg(&mmc_dev, "max_hw_segs=%d\n", mmc->max_hw_segs);
-	dev_dbg(&mmc_dev, "max_sect=%d\n", mmc->max_sectors);
-	dev_dbg(&mmc_dev, "max_seg_size=%d\n", mmc->max_seg_size);
+	dev_dbg(dev, "max_phys_segs=%d\n", mmc->max_phys_segs);
+	dev_dbg(dev, "max_hw_segs=%d\n", mmc->max_hw_segs);
+	dev_dbg(dev, "max_sect=%d\n", mmc->max_sectors);
+	dev_dbg(dev, "max_seg_size=%d\n", mmc->max_seg_size);
 
-	host = mmc_priv(mmc);
-	host->mmc = mmc;	/* Important */
-
-	if (mmcsd_cfg.use_dma) {
-		dev_dbg(&mmc_dev, "Using DMA mode\n");
+	if (host->use_dma) {
+		dev_info(dev, "Using DMA mode\n");
 		if (davinci_acquire_dma_channels(host) != 0) {
-			goto out;
+			goto release_clk;
 		}
 	} else {
-		dev_dbg(&mmc_dev, "Not Using DMA mode\n");
+		dev_info(dev, "Not Using DMA mode\n");
 	}
 
-	host->use_dma = mmcsd_cfg.use_dma;
-	host->irq = MMCINT_INTERRUPT;
 	host->sd_support = 1;
-	ret =
-	    request_irq(MMCINT_INTERRUPT, mmc_davinci_irq, 0, DRIVER_NAME,
-			host);
+	ret = request_irq(host->irq, mmc_davinci_irq, 0, DRIVER_NAME, host);
 
 	if (ret)
-		goto out;
+		goto release_dma;
 
 	dev_set_drvdata(dev, host);
 	mmc_add_host(mmc);
@@ -1365,14 +1365,22 @@ static int davinci_mmcsd_probe(struct de
 	init_timer(&host->timer);
 	host->timer.data = (unsigned long)host;
 	host->timer.function = davinci_mmc_check_status;
-	host->timer.expires = jiffies + MULTIPILER_TO_HZ * HZ;
+	host->timer.expires = jiffies + MULTIPLIER_TO_HZ * HZ;
 	add_timer(&host->timer);
 
 	return 0;
 
-      out:
-	/* TBD: Free other resources too. */
-
+  release_dma:
+	davinci_release_dma_channels(host);
+  release_clk:
+	clk_unuse(host->clk);
+	clk_disable(host->clk);
+  release_regs:
+	release_resource(host->reg_res);
+	kfree(host->reg_res);
+  free_host:
+	mmc_free_host(mmc);
+  out:
 	return ret;
 }
 
@@ -1381,19 +1389,23 @@ static int davinci_mmcsd_remove(struct d
 	struct mmc_davinci_host *host = dev_get_drvdata(dev);
 	unsigned long flags;
 
-	spin_lock_irqsave(&mmc_lock, flags);
-	del_timer(&host->timer);
-	spin_unlock_irqrestore(&mmc_lock, flags);
-
-	dev_set_drvdata(dev, NULL);
 	if (host) {
+		spin_lock_irqsave(&host->mmc_lock, flags);
+		del_timer(&host->timer);
+		spin_unlock_irqrestore(&host->mmc_lock, flags);
+
 		mmc_remove_host(host->mmc);
+		dev_set_drvdata(dev, NULL);
 		free_irq(host->irq, host);
 		davinci_release_dma_channels(host);
+		clk_unuse(host->clk);
+		clk_disable(host->clk);
+		release_resource(host->reg_res);
+		kfree(host->reg_res);
+		mmc_free_host(host->mmc);
 	}
 
 	return 0;
-
 }
 
 #ifdef CONFIG_PM
@@ -1435,73 +1447,15 @@ static struct device_driver davinci_mmcs
 	.resume = davinci_mmcsd_resume,
 };
 
-static void mmc_release(struct device *dev)
-{
-	/* Nothing to release? */
-}
-
-static u64 mmc_dma_mask = 0xffffffff;
-
-static struct resource mmc_resources[] = {
-	{
-	 .start = IO_ADDRESS(MMCSD_REGS_BASE_ADDR),
-	 .end = IO_ADDRESS((MMCSD_REGS_BASE_ADDR) + 0x74),
-	 .flags = IORESOURCE_MEM,
-	 },
-	{
-	 .start = MMCINT_INTERRUPT,
-	 .flags = IORESOURCE_IRQ,
-	 },
-};
-
-static struct platform_device mmc_davinci_device = {
-	.name = DRIVER_NAME,
-	.id = 1,
-	.dev = {
-		.release = mmc_release,
-		.dma_mask = &mmc_dma_mask,
-		},
-	.num_resources = ARRAY_SIZE(&mmc_resources),
-	.resource = mmc_resources,
-};
 
 static int davinci_mmcsd_init(void)
 {
-	int ret = 0;
-	struct clk *clkp = NULL;
-
-	clkp = clk_get(NULL, "MMCSDCLK");
-	if (clkp != NULL) {
-
-		ret = platform_device_register(&mmc_davinci_device);
-		if (ret != 0)
-			goto free1;
-
-		mmc_clkp = clkp;
-		clk_use(mmc_clkp);
-		clk_enable(mmc_clkp);
-		mmc_input_clk = clk_get_rate(mmc_clkp);
-
-		ret = driver_register(&davinci_mmcsd_driver);
-		mmc_davinci_device.dev.driver = &davinci_mmcsd_driver;
-		mmc_dev = mmc_davinci_device.dev;
-		if (ret == 0)
-			return 0;
-
-		platform_device_unregister(&mmc_davinci_device);
-	}
-
-      free1:
-	return -ENODEV;
+	return driver_register(&davinci_mmcsd_driver);
 }
 
 static void __exit davinci_mmcsd_exit(void)
 {
-
 	driver_unregister(&davinci_mmcsd_driver);
-	platform_device_unregister(&mmc_davinci_device);
-	clk_unuse(mmc_clkp);
-	clk_disable(mmc_clkp);
 }
 
 module_init(davinci_mmcsd_init);
Index: linux-2.6.10/drivers/mmc/davinci_mmc.h
===================================================================
--- linux-2.6.10.orig/drivers/mmc/davinci_mmc.h
+++ linux-2.6.10/drivers/mmc/davinci_mmc.h
@@ -94,6 +94,8 @@ typedef struct {
 	unsigned short mmc_fifo_ctl;
 } mmcsd_regs_base;
 
+#define mmcsd_regs(host) ((host)->base)
+
 /*
  * Command types
  */
@@ -109,17 +111,23 @@ typedef struct {
 } edma_ch_mmcsd;
 
 struct mmc_davinci_host {
-
-	int initialized;
-	int suspended;
-	struct mmc_request *req;
+	struct resource *reg_res;
+	spinlock_t mmc_lock;
+	int is_card_busy;
+	int is_card_detect_progress;
+	int is_card_initialized;
+	int is_card_removed;
+	int is_init_progress;
+	int is_req_queued_up;
+	struct mmc_host *que_mmc_host;
+	struct mmc_request *que_mmc_request;
 	struct mmc_command *cmd;
 	struct mmc_data *data;
 	struct mmc_host *mmc;
 	struct device *dev;
-	unsigned char id;
 	struct clk *clk;
-	u32 base;
+	volatile mmcsd_regs_base *base;
+	unsigned int rw_threshold;
 	int irq;
 	unsigned char bus_mode;
 
@@ -129,16 +137,17 @@ struct mmc_davinci_host {
 	unsigned char data_dir;
 	u32 *buffer;
 	u32 bytes_left;
-	int power_pin;
 
 	int use_dma;
 	int do_dma;
-	struct completion dma_completion;
+	unsigned int dma_rx_event;
+	unsigned int dma_tx_event;
 
 	struct timer_list timer;
 	unsigned int is_core_command;
 	unsigned int cmd_code;
 	unsigned int old_card_state;
+	unsigned int new_card_state;
 
 	unsigned char sd_support;
 
@@ -147,14 +156,7 @@ struct mmc_davinci_host {
 	unsigned int sg_len;
 	int sg_idx;
 	unsigned int buffer_bytes_left;
-	unsigned int dma_len;
-	int dma_state;
 };
-typedef struct {
-	unsigned short rw_threshold;
-	unsigned short use_dma;
-	unsigned short use_4bit_mode;
-} mmcsd_config_def;
 
 typedef enum {
 	MMCSD_EVENT_EOFCMD = (1 << 2),
@@ -175,7 +177,7 @@ typedef enum {
 #define MMCSD_EVENT_ERROR \
  (MMCSD_EVENT_TIMEOUT_ERROR | MMCSD_EVENT_CRC_ERROR)
 
-static void init_mmcsd_host(void);
+static void init_mmcsd_host(struct mmc_davinci_host *host);
 
 static void davinci_fifo_data_trans(struct mmc_davinci_host *host);
 
Index: linux-2.6.10/include/linux/davinci_mmc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/davinci_mmc.h
@@ -0,0 +1,19 @@
+/*
+ * Header file for DaVinci MMC platform data.
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef DAVINCI_MMC_PLAT_H
+#define DAVINCI_MMC_PLAT_H
+
+struct davinci_mmc_platform_data {
+	const char *mmc_clk;	/* MMC clock name for clk_get() */
+	unsigned int rw_threshold;
+	unsigned int use_4bit_mode;
+};
+
+#endif	/* ifndef DAVINCI_MMC_PLAT_H */
Index: linux-2.6.10/mvl_patches/pro-1661.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1661.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1661);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

