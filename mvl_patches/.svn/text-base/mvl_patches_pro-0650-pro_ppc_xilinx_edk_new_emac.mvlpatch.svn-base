#! /usr/bin/env bash
# Patch: -pro_ppc_xilinx_edk_new_emac
# Date: Thu Jun 22 21:14:59 2006
# Source: MontaVista Software, Inc. Sergey Podstavin <spodstavin@ru.mvista.com>
# MR: 19052
# Type: Integration
# Disposition: needs submitting to community
# Signed-off-by: Sergey podstavin <spodstavin@ru.mvista.com>
# Description:
#     Xilinx EDK drivers for EMAC - The newer Xilinx drivers for 
#     ML40x board with the CfgInitialize() routine. Xilinx re-newed 
#     their drivers quite recently, so it's going as a different patch.
# 

PATCHNUM=650
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. Sergey Podstavin <spodstavin@ru.mvista.com>
MR: 19052
Type: Integration
Disposition: needs submitting to community
Signed-off-by: Sergey podstavin <spodstavin@ru.mvista.com>
Description:
    Xilinx EDK drivers for EMAC - The newer Xilinx drivers for 
    ML40x board with the CfgInitialize() routine. Xilinx re-newed 
    their drivers quite recently, so it's going as a different patch.

Index: linux-2.6.10/drivers/xilinx_common/xdma_channel_sg.c
===================================================================
--- linux-2.6.10.orig/drivers/xilinx_common/xdma_channel_sg.c
+++ linux-2.6.10/drivers/xilinx_common/xdma_channel_sg.c
@@ -1,14 +1,14 @@
 /******************************************************************************
 *
 *     Author: Xilinx, Inc.
-*
-*
+*     
+*     
 *     This program is free software; you can redistribute it and/or modify it
 *     under the terms of the GNU General Public License as published by the
 *     Free Software Foundation; either version 2 of the License, or (at your
 *     option) any later version.
-*
-*
+*     
+*     
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 *     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 *     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
@@ -20,33 +20,31 @@
 *     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
 *     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
 *     FITNESS FOR A PARTICULAR PURPOSE.
-*
-*
+*     
+*     
 *     Xilinx hardware products are not intended for use in life support
 *     appliances, devices, or systems. Use in such applications is
 *     expressly prohibited.
-*
-*
-*     (c) Copyright 2003-2004 Xilinx Inc.
+*     
+*     
+*     (c) Copyright 2002-2004 Xilinx Inc.
 *     All rights reserved.
-*
-*
+*     
+*     
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc.,
 *     675 Mass Ave, Cambridge, MA 02139, USA.
 *
-******************************************************************************/
-/*****************************************************************************/
-/**
+* FILENAME:
 *
-* @file xdma_channel_sg.c
+* xdma_channel_sg.c
 *
-* <b>Description</b>
+* DESCRIPTION:
 *
 * This file contains the implementation of the XDmaChannel component which is
 * related to scatter gather operations.
 *
-* <b>Scatter Gather Operations</b>
+* Scatter Gather Operations
 *
 * The DMA channel may support scatter gather operations. A scatter gather
 * operation automates the DMA channel such that multiple buffers can be
@@ -55,7 +53,7 @@
 * scatter gather operations of the DMA channel to describe the buffers to be
 * processed.
 *
-* <b>Scatter Gather List Operations</b>
+* Scatter Gather List Operations
 *
 * A scatter gather list may be supported by each DMA channel.  The scatter
 * gather list allows buffer descriptors to be put into the list by a device
@@ -93,32 +91,32 @@
 * hardware design only allows descriptors to cause it to stop after a descriptor
 * has been processed rather than before it is processed.  A series of
 * descriptors are put into the list followed by a commit operation, or each
-* descriptor may be committed.  A commit operation is performed by changing a
+* descriptor may be commited.  A commit operation is performed by changing a
 * single descriptor, the first of the series of puts, to indicate that the
 * hardware may now use all descriptors after it.  The last descriptor in the
 * list is always set to cause the hardware to stop after it is processed.
 *
-* <b>Typical Scatter Gather Processing</b>
+* Typical Scatter Gather Processing
 *
 * The following steps illustrate the typical processing to use the
 * scatter gather features of a DMA channel.
 *
 * 1. Create a scatter gather list for the DMA channel which puts empty buffer
-*    descriptors into the list.<br>
+*    descriptors into the list.
 * 2. Create buffer descriptors which describe the buffers to be filled with
-*    receive data or the buffers which contain data to be sent.<br>
+*    receive data or the buffers which contain data to be sent.
 * 3. Put buffer descriptors into the DMA channel scatter list such that scatter
-*    gather operations are requested.<br>
+*    gather operations are requested.
 * 4. Commit the buffer descriptors in the list such that they are ready to be
-*    used by the DMA channel hardware.<br>
-* 5. Start the scatter gather operations of the DMA channel.<br>
+*    used by the DMA channel hardware.
+* 5. Start the scatter gather operations of the DMA channel.
 * 6. Process any interrupts which occur as a result of the scatter gather
 *    operations or poll the DMA channel to determine the status.  This may
 *    be accomplished by getting the packet count for the channel and then
 *    getting the appropriate number of descriptors from the list for that
 *    number of packets.
 *
-* <b>Minimizing Interrupts</b>
+* Minimizing Interrupts
 *
 * The Scatter Gather operating mode is designed to reduce the amount of CPU
 * throughput necessary to manage the hardware for devices. A key to the CPU
@@ -132,7 +130,7 @@
 * which the CPU must service, an algorithm referred to as "interrupt coalescing"
 * is utilized.
 *
-* <b>Interrupt Coalescing</b>
+* Interrupt Coalescing
 *
 * The principle of interrupt coalescing is to wait before generating an
 * interrupt until a certain number of packets have been received or sent. An
@@ -144,7 +142,7 @@
 * combination to allow a reduction in the number of interrupts processed by the
 * CPU for packet reception.
 *
-* <b>Unserviced Packet Count</b>
+* Unserviced Packet Count
 *
 * The purpose of the packet counter is to count the number of packets received
 * or transmitted and provide an interrupt when a specific number of packets
@@ -175,16 +173,18 @@
 * operations. The hardware ensures that the operation is atomic such that
 * simultaneous accesses are properly handled.
 *
-* <b>Packet Wait Bound</b>
+* Packet Wait Bound
 *
 * The purpose of the packet wait bound is to augment the unserviced packet
 * count. Whenever there is no pending interrupt for the channel and the
 * unserviced packet count is non-zero, a timer starts counting timeout at the
-* value contained the packet wait bound register.  If the timeout is
+* value contained the the packet wait bound register.  If the timeout is
 * reached, an interrupt is generated such that the software may service the
 * data which was buffered.
 *
-* <b>Special Test Conditions:</b>
+* NOTES:
+*
+* Special Test Conditions:
 *
 * The scatter gather list processing must be thoroughly tested if changes are
 * made.  Testing should include putting and committing single descriptors and
@@ -197,13 +197,13 @@
 * have a traverse the list after the hardware has finished processing some
 * number of descriptors.  The Commit Pointer points to the descriptor in the
 * list which is to be committed.  It is also used to determine that no
-* descriptor is waiting to be committed (NULL).  The Last Pointer points to
+* descriptor is waiting to be commited (NULL).  The Last Pointer points to
 * the last descriptor that was put into the list.  It typically points
 * to the previous descriptor to the one pointed to by the Put Pointer.
 * Comparisons are done between these pointers to determine when the following
 * special conditions exist.
 
-* <b>Single Put And Commit</b>
+* Single Put And Commit
 *
 * The buffer descriptor is ready to be used by the hardware so it is important
 * for the descriptor to not appear to be waiting to be committed.  The commit
@@ -213,14 +213,14 @@
 * this one.  But in this case, this is the last descriptor in the list such
 * that it must not be changed.
 *
-* <b>3 Or More Puts And Commit</b>
+* 3 Or More Puts And Commit
 *
 * A series of 3 or more puts followed by a single commit is different in that
 * only the 1st descriptor put into the list is changed when the commit is done.
 * This requires each put starting on the 3rd to change the previous descriptor
 * so that it allows the hardware to continue to the next descriptor in the list.
 *
-* <b>The 1st Put Following A Commit</b>
+* The 1st Put Following A Commit
 *
 * The commit caused the commit pointer to be NULL indicating that there are no
 * descriptors waiting to be committed.  It is necessary for the next put to set
@@ -234,8 +234,6 @@
 * ----- ---- -------- ------------------------------------------------------
 * 1.00a rpm  02/03/03 Removed the XST_DMA_SG_COUNT_EXCEEDED return code
 *                     from SetPktThreshold.
-*       rmm  12/04/03 CR 180871. Fixed XDmaChannel_SgStop() function.
-* 1.00a xd   10/27/04 Doxygenated for inclusion in API documentation
 * </pre>
 *
 ******************************************************************************/
@@ -251,13 +249,13 @@
 /* simple virt<-->phy pointer conversions for a single dma channel */
 #define P_TO_V(p) \
 	((p) ? \
-	(InstancePtr->VirtPtr + ((u32)(p) - (u32)InstancePtr->PhyPtr)) : \
-	0)
+	 (InstancePtr->VirtPtr + ((u32)(p) - (u32)InstancePtr->PhyPtr)) : \
+	 0)
 
 #define V_TO_P(v) \
 	((v) ? \
-	(InstancePtr->PhyPtr + ((u32)(v) - (u32)InstancePtr->VirtPtr)) : \
-	0)
+	 (InstancePtr->PhyPtr + ((u32)(v) - (u32)InstancePtr->VirtPtr)) : \
+	 0)
 
 /************************** Constant Definitions *****************************/
 
@@ -267,8 +265,7 @@
 
 /***************** Macros (Inline Functions) Definitions *********************/
 
-/**
- * the following macro copies selected fields of a buffer descriptor to another
+/* the following macro copies selected fields of a buffer descriptor to another
  * buffer descriptor, this was provided by the buffer descriptor component but
  * was moved here since it is only used internally to this component and since
  * it does not copy all fields
@@ -299,8 +296,13 @@
 
 /************************** Function Prototypes ******************************/
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SgStart
+*
+* DESCRIPTION:
 *
 * This function starts a scatter gather operation for a scatter gather
 * DMA channel.  The first buffer descriptor in the buffer descriptor list
@@ -309,36 +311,37 @@
 * descriptors put into the scatter gather list such that there are scatter
 * operations ready to be performed.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
-* - A status containing XST_SUCCESS if scatter gather was started successfully
-*   for the DMA channel.
-*   <br><br>
-* - A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
-*   been created.
-*   <br><br>
-* - A value of XST_DMA_SG_LIST_EMPTY indicates scatter gather was not started
-*   because the scatter gather list of the DMA channel does not contain any
-*   buffer descriptors that are ready to be processed by the hardware.
-*   <br><br>
-* - A value of XST_DMA_SG_IS_STARTED indicates scatter gather was not started
-*   because the scatter gather was not stopped, but was already started.
-*   <br><br>
-* - A value of XST_DMA_SG_BD_NOT_COMMITTED indicates the buffer descriptor of
-*   scatter gather list which was to be started is not committed to the list.
-*   This status is more likely if this function is being called from an ISR
-*   and non-ISR processing is putting descriptors into the list.
-*   <br><br>
-* - A value of XST_DMA_SG_NO_DATA indicates that the buffer descriptor of the
-*   scatter gather list which was to be started had already been used by the
-*   hardware for a DMA transfer that has been completed.
+* RETURN VALUE:
+*
+* A status containing XST_SUCCESS if scatter gather was started successfully
+* for the DMA channel.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
 *
-* @note
+* A value of XST_DMA_SG_LIST_EMPTY indicates scatter gather was not started
+* because the scatter gather list of the DMA channel does not contain any
+* buffer descriptors that are ready to be processed by the hardware.
+*
+* A value of XST_DMA_SG_IS_STARTED indicates scatter gather was not started
+* because the scatter gather was not stopped, but was already started.
+*
+* A value of XST_DMA_SG_BD_NOT_COMMITTED indicates the buffer descriptor of
+* scatter gather list which was to be started is not committed to the list.
+* This status is more likely if this function is being called from an ISR
+* and non-ISR processing is putting descriptors into the list.
+*
+* A value of XST_DMA_SG_NO_DATA indicates that the buffer descriptor of the
+* scatter gather list which was to be started had already been used by the
+* hardware for a DMA transfer that has been completed.
+*
+* NOTES:
 *
 * It is the responsibility of the caller to get all the buffer descriptors
 * after performing a stop operation and before performing a start operation.
@@ -346,8 +349,7 @@
 * buffer descriptors may be processed by the hardware more than once.
 *
 ******************************************************************************/
-XStatus
-XDmaChannel_SgStart(XDmaChannel * InstancePtr)
+XStatus XDmaChannel_SgStart(XDmaChannel * InstancePtr)
 {
 	u32 Register;
 	XBufDescriptor *LastDescriptorPtr;
@@ -382,7 +384,7 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 	 * finished processing
 	 */
 	LastDescriptorPtr = (XBufDescriptor *)
-		P_TO_V(XIo_In32(InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
+	    P_TO_V(XIo_In32(InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
 
 	/* setup the first buffer descriptor that will be sent when the scatter
 	 * gather channel is enabled, this is only necessary one time since
@@ -396,8 +398,8 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 		XBufDescriptor *NextDescriptorPtr;
 
 		/* get the next descriptor to be started, if the status indicates it
-		 * hasn't already been used by the hw, then it's OK to start it,
-		 * sw sets the status of each descriptor to busy and then hw clears
+		 * hasn't already been used by the h/w, then it's OK to start it,
+		 * s/w sets the status of each descriptor to busy and then h/w clears
 		 * the busy when it is complete
 		 */
 		NextDescriptorPtr =
@@ -408,7 +410,7 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 			return XST_DMA_SG_NO_DATA;
 		}
 		/* don't start the DMA SG channel if the descriptor to be processed
-		 * by hw is to be committed by the sw, this function can be called
+		 * by h/w is to be committed by the s/w, this function can be called
 		 * such that it interrupts a thread that was putting into the list
 		 */
 		if (NextDescriptorPtr == InstancePtr->CommitPtr) {
@@ -417,7 +419,7 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 	}
 
 	/* start the scatter gather operation by clearing the stop bit in the
-	 * control register and setting the enable bit in the sw control register,
+	 * control register and setting the enable bit in the s/w control register,
 	 * both of these are necessary to cause it to start, right now the order of
 	 * these statements is important, the software control register should be
 	 * set 1st.  The other order can cause the CPU to have a loss of sync
@@ -441,8 +443,13 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SgStop
+*
+* DESCRIPTION:
 *
 * This function stops a scatter gather operation for a scatter gather
 * DMA channel. This function starts the process of stopping a scatter
@@ -459,29 +466,28 @@ XDmaChannel_SgStart(XDmaChannel * Instan
 * operation is stopped and the caller is responsible for handling the
 * interrupt.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * BufDescriptorPtr is also a return value which contains a pointer to the
 * buffer descriptor which the scatter gather operation completed when it
 * was stopped.
 *
-* @return
-* - A status containing XST_SUCCESS if scatter gather was stopped successfully
-*   for the DMA channel.
-*   <br><br>
-* - A value of XST_DMA_SG_IS_STOPPED indicates scatter gather was not stopped
-*   because the scatter gather is not started, but was already stopped.
-*   <br><br>
-* - BufDescriptorPtr contains a pointer to the buffer descriptor which was
-*   completed when the operation was stopped.
+* RETURN VALUE:
+*
+* A status containing XST_SUCCESS if scatter gather was stopped successfully
+* for the DMA channel.
+*
+* A value of XST_DMA_SG_IS_STOPPED indicates scatter gather was not stoppped
+* because the scatter gather is not started, but was already stopped.
 *
-* @note
+* BufDescriptorPtr contains a pointer to the buffer descriptor which was
+* completed when the operation was stopped.
+*
+* NOTES:
 *
 * This function implements a loop which polls the hardware for an infinite
 * amount of time. If the hardware is not operating correctly, this function
@@ -530,13 +536,18 @@ XDmaChannel_SgStop(XDmaChannel * Instanc
 	 * descriptor that the scatter gather DMA channel was processing
 	 */
 	*BufDescriptorPtr = (XBufDescriptor *)
-		P_TO_V(XIo_In32(InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
+	    P_TO_V(XIo_In32(InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
 
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_CreateSgList
+*
+* DESCRIPTION:
 *
 * This function creates a scatter gather list in the DMA channel.  A scatter
 * gather list consists of a list of buffer descriptors that are available to
@@ -548,34 +559,29 @@ XDmaChannel_SgStop(XDmaChannel * Instanc
 * be called before non-empty buffer descriptors may be put into the DMA channel
 * to request scatter gather operations.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * MemoryPtr contains a pointer to the memory which is to be used for buffer
 * descriptors and must not be cached (virtual).
 *
-* @param
-*
 * ByteCount contains the number of bytes for the specified memory to be used
 * for buffer descriptors.
 *
-* @param
+* PhyPtr contains a pointer to the physical memory use for buffer descriptors.
+*
+* RETURN VALUE:
 *
-* PhyPtr contains a pointer to the physical memory used for buffer descriptors.
+* A status contains XST_SUCCESS if the scatter gather list was successfully
+* created.
 *
-* @return
-* - A status contains XST_SUCCESS if the scatter gather list was successfully
-*   created.
-*   <br><br>
-* - A value of XST_DMA_SG_LIST_EXISTS indicates that the scatter gather list
-*   was not created because the list has already been created.
+* A value of XST_DMA_SG_LIST_EXISTS indicates that the scatter gather list
+* was not created because the list has already been created.
 *
-* @note
+* NOTES:
 *
 * None.
 *
@@ -597,7 +603,7 @@ XDmaChannel_CreateSgList(XDmaChannel * I
 	XASSERT_NONVOID(MemoryPtr != NULL);
 	XASSERT_NONVOID(((u32) MemoryPtr & 3) == 0);
 	XASSERT_NONVOID(ByteCount != 0);
-	XASSERT_NONVOID(ByteCount >= sizeof (XBufDescriptor));
+	XASSERT_NONVOID(ByteCount >= sizeof(XBufDescriptor));
 	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
 
 	/* if the scatter gather list has already been created, then return
@@ -617,7 +623,7 @@ XDmaChannel_CreateSgList(XDmaChannel * I
 	 * is not large enough for a complete buffer descriptor
 	 */
 	UsedByteCount = 0;
-	while ((UsedByteCount + sizeof (XBufDescriptor)) <= ByteCount) {
+	while ((UsedByteCount + sizeof(XBufDescriptor)) <= ByteCount) {
 		/* setup a pointer to the next buffer descriptor in the memory and
 		 * update # of used bytes to know when all of memory is used
 		 */
@@ -647,7 +653,7 @@ XDmaChannel_CreateSgList(XDmaChannel * I
 		 */
 		InstancePtr->TotalDescriptorCount++;
 
-		UsedByteCount += sizeof (XBufDescriptor);
+		UsedByteCount += sizeof(XBufDescriptor);
 	}
 
 	/* connect the last buffer descriptor created and inserted in the list
@@ -669,31 +675,35 @@ XDmaChannel_CreateSgList(XDmaChannel * I
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_IsSgListEmpty
+*
+* DESCRIPTION:
 *
 * This function determines if the scatter gather list of a DMA channel is
 * empty with regard to buffer descriptors which are pointing to buffers to be
 * used for scatter gather operations.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
+* RETURN VALUE:
 *
 * A value of TRUE if the scatter gather list is empty, otherwise a value of
 * FALSE.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-u32
-XDmaChannel_IsSgListEmpty(XDmaChannel * InstancePtr)
+u32 XDmaChannel_IsSgListEmpty(XDmaChannel * InstancePtr)
 {
 	/* assert to verify valid input arguments */
 
@@ -706,8 +716,13 @@ XDmaChannel_IsSgListEmpty(XDmaChannel * 
 	return (InstancePtr->ActiveDescriptorCount == 0);
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_PutDescriptor
+*
+* DESCRIPTION:
 *
 * This function puts a buffer descriptor into the DMA channel scatter
 * gather list. A DMA channel maintains a list of buffer descriptors which are
@@ -721,33 +736,32 @@ XDmaChannel_IsSgListEmpty(XDmaChannel * 
 * span a single packet to be put into the list while preventing the hardware
 * from starting the first buffer descriptor of the packet.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * BufferDescriptorPtr is a pointer to the buffer descriptor to be put into
 * the next available location of the scatter gather list.
 *
-* @return
-* - A status which indicates XST_SUCCESS if the buffer descriptor was
-*   successfully put into the scatter gather list.
-*   <br><br>
-* - A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
-*   been created.
-*   <br><br>
-* - A value of XST_DMA_SG_LIST_FULL indicates the buffer descriptor was not
-*   put into the list because the list was full.
-*   <br><br>
-* - A value of XST_DMA_SG_BD_LOCKED indicates the buffer descriptor was not
-*   put into the list because the buffer descriptor in the list which is to
-*   be overwritten was locked.  A locked buffer descriptor indicates the higher
-*   layered software is still using the buffer descriptor.
+* RETURN VALUE:
 *
-* @note
+* A status which indicates XST_SUCCESS if the buffer descriptor was
+* successfully put into the scatter gather list.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
+*
+* A value of XST_DMA_SG_LIST_FULL indicates the buffer descriptor was not
+* put into the list because the list was full.
+*
+* A value of XST_DMA_SG_BD_LOCKED indicates the buffer descriptor was not
+* put into the list because the buffer descriptor in the list which is to
+* be overwritten was locked.  A locked buffer descriptor indicates the higher
+* layered software is still using the buffer descriptor.
+*
+* NOTES:
 *
 * It is necessary to create a scatter gather list for a DMA channel before
 * putting buffer descriptors into it.
@@ -790,7 +804,7 @@ XDmaChannel_PutDescriptor(XDmaChannel * 
 	}
 
 	/* set the scatter gather stop bit in the control word of the descriptor
-	 * to cause the hw to stop after it processes this descriptor since it
+	 * to cause the h/w to stop after it processes this descriptor since it
 	 * will be the last in the list
 	 */
 	Control = XBufDescriptor_GetControl(BufferDescriptorPtr);
@@ -805,8 +819,8 @@ XDmaChannel_PutDescriptor(XDmaChannel * 
 	XBufDescriptor_SetDeviceStatus(BufferDescriptorPtr, 0);
 
 	/* copy the descriptor into the next position in the list so it's ready to
-	 * be used by the hw, this assumes the descriptor in the list prior to this
-	 * one still has the stop bit in the control word set such that the hw
+	 * be used by the h/w, this assumes the descriptor in the list prior to this
+	 * one still has the stop bit in the control word set such that the h/w
 	 * use this one yet
 	 */
 	CopyBufferDescriptor(BufferDescriptorPtr, InstancePtr->PutPtr);
@@ -840,13 +854,19 @@ XDmaChannel_PutDescriptor(XDmaChannel * 
 	 * the commit pointer to track the correct descriptor to be committed
 	 */
 	InstancePtr->LastPtr = InstancePtr->PutPtr;
-	InstancePtr->PutPtr = P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->PutPtr));
+	InstancePtr->PutPtr =
+	    P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->PutPtr));
 
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_CommitPuts
+*
+* DESCRIPTION:
 *
 * This function commits the buffer descriptors which have been put into the
 * scatter list for the DMA channel since the last commit operation was
@@ -856,27 +876,27 @@ XDmaChannel_PutDescriptor(XDmaChannel * 
 * starting to use the buffer descriptors in the list before they are ready
 * to be used (multiple buffer descriptors for a single packet).
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
-* - A status indicating XST_SUCCESS if the buffer descriptors of the list were
-*   successfully committed.
-*   <br><br>
-* - A value of XST_DMA_SG_NOTHING_TO_COMMIT indicates that the buffer descriptors
-*   were not committed because there was nothing to commit in the list.  All the
-*   buffer descriptors which are in the list are committed.
+* RETURN VALUE:
+*
+* A status indicating XST_SUCCESS if the buffer descriptors of the list were
+* successfully committed.
 *
-* @note
+* A value of XST_DMA_SG_NOTHING_TO_COMMIT indicates that the buffer descriptors
+* were not committed because there was nothing to commit in the list.  All the
+* buffer descriptors which are in the list are commited.
+*
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-XStatus
-XDmaChannel_CommitPuts(XDmaChannel * InstancePtr)
+XStatus XDmaChannel_CommitPuts(XDmaChannel * InstancePtr)
 {
 	/* assert to verify input arguments */
 
@@ -892,7 +912,7 @@ XDmaChannel_CommitPuts(XDmaChannel * Ins
 	}
 
 	/* last descriptor in the list must have scatter gather disabled so the end
-	 * of the list is hit by hw, if descriptor to commit is not last in list,
+	 * of the list is hit by h/w, if descriptor to commit is not last in list,
 	 * commit descriptors by enabling scatter gather in the descriptor
 	 */
 	if (InstancePtr->CommitPtr != InstancePtr->LastPtr) {
@@ -911,8 +931,13 @@ XDmaChannel_CommitPuts(XDmaChannel * Ins
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetDescriptor
+*
+* DESCRIPTION:
 *
 * This function gets a buffer descriptor from the scatter gather list of the
 * DMA channel. The buffer descriptor is retrieved from the scatter gather list
@@ -923,34 +948,33 @@ XDmaChannel_CommitPuts(XDmaChannel * Ins
 * allow the device using the scatter gather operation to get the results of the
 * operation.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * BufDescriptorPtr is a pointer to a pointer to the buffer descriptor which
 * was retrieved from the list.  The buffer descriptor is not really removed
 * from the list, but it is changed to a state such that the hardware will not
 * use it again until it is put into the scatter gather list of the DMA channel.
 *
-* @return
-* - A status indicating XST_SUCCESS if a buffer descriptor was retrieved from
-*   the scatter gather list of the DMA channel.
-*   <br><br>
-* - A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
-*   been created.
-*   <br><br>
-* - A value of XST_DMA_SG_LIST_EMPTY indicates no buffer descriptor was
-*   retrieved from the list because there are no buffer descriptors to be
-*   processed in the list.
-*   <br><br>
-* - BufDescriptorPtr is updated to point to the buffer descriptor which was
-*   retrieved from the list if the status indicates success.
+* RETURN VALUE:
+*
+* A status indicating XST_SUCCESS if a buffer descriptor was retrieved from
+* the scatter gather list of the DMA channel.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
 *
-* @note
+* A value of XST_DMA_SG_LIST_EMPTY indicates no buffer descriptor was
+* retrieved from the list because there are no buffer descriptors to be
+* processed in the list.
+*
+* BufDescriptorPtr is updated to point to the buffer descriptor which was
+* retrieved from the list if the status indicates success.
+*
+* NOTES:
 *
 * None.
 *
@@ -996,38 +1020,43 @@ XDmaChannel_GetDescriptor(XDmaChannel * 
 	 * was retrieved from the list by setting it to the next buffer descriptor
 	 * in the list and indicate one less descriptor in the list now
 	 */
-	InstancePtr->GetPtr = P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->GetPtr));
+	InstancePtr->GetPtr =
+	    P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->GetPtr));
 	InstancePtr->ActiveDescriptorCount--;
 
 	return XST_SUCCESS;
 }
 
-/*********************** Interrupt Coalescing Functions **********************/
+/*********************** Interrupt Collescing Functions **********************/
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktCount
+*
+* DESCRIPTION:
 *
 * This function returns the value of the unserviced packet count register of
 * the DMA channel.  This count represents the number of packets that have been
 * sent or received by the hardware, but not processed by software.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
+* RETURN VALUE:
 *
 * The unserviced packet counter register contents for the DMA channel.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-u32
-XDmaChannel_GetPktCount(XDmaChannel * InstancePtr)
+u32 XDmaChannel_GetPktCount(XDmaChannel * InstancePtr)
 {
 	/* assert to verify input arguments */
 
@@ -1039,31 +1068,35 @@ XDmaChannel_GetPktCount(XDmaChannel * In
 	return XIo_In32(InstancePtr->RegBaseAddress + XDC_UPC_REG_OFFSET);
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_DecrementPktCount
+*
+* DESCRIPTION:
 *
 * This function decrements the value of the unserviced packet count register.
 * This informs the hardware that the software has processed a packet.  The
 * unserviced packet count register may only be decremented by one in the
 * hardware.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
+* RETURN VALUE:
 *
 * None.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-void
-XDmaChannel_DecrementPktCount(XDmaChannel * InstancePtr)
+void XDmaChannel_DecrementPktCount(XDmaChannel * InstancePtr)
 {
 	u32 Register;
 
@@ -1084,8 +1117,13 @@ XDmaChannel_DecrementPktCount(XDmaChanne
 	}
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SetPktThreshold
+*
+* DESCRIPTION:
 *
 * This function sets the value of the packet count threshold register of the
 * DMA channel.  It reflects the number of packets that must be sent or
@@ -1093,35 +1131,32 @@ XDmaChannel_DecrementPktCount(XDmaChanne
 * a concept called "interrupt coalescing", which is used to reduce the number
 * of interrupts from devices with high data rates.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * Threshold is the value that is written to the threshold register of the
 * DMA channel.
 *
-* @return
+* RETURN VALUE:
 *
 * A status containing XST_SUCCESS if the packet count threshold was
 * successfully set.
 *
-* @note
+* NOTES:
 *
 * The packet threshold could be set to larger than the number of descriptors
 * allocated to the DMA channel. In this case, the wait bound will take over
 * and always indicate data arrival. There was a check in this function that
-* returned an error if the threshold was larger than the number of descriptors,
+* returned an error if the treshold was larger than the number of descriptors,
 * but that was removed because users would then have to set the threshold
 * only after they set descriptor space, which is an order dependency that
-* caused confusion.
+* caused confustion.
 *
 ******************************************************************************/
-XStatus
-XDmaChannel_SetPktThreshold(XDmaChannel * InstancePtr, u8 Threshold)
+XStatus XDmaChannel_SetPktThreshold(XDmaChannel * InstancePtr, u8 Threshold)
 {
 	/* assert to verify input arguments, don't assert the threshold since
 	 * it's range is unknown
@@ -1141,8 +1176,13 @@ XDmaChannel_SetPktThreshold(XDmaChannel 
 	return XST_SUCCESS;
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktThreshold
+*
+* DESCRIPTION:
 *
 * This function gets the value of the packet count threshold register of the
 * DMA channel.  This value reflects the number of packets that must be sent or
@@ -1150,25 +1190,24 @@ XDmaChannel_SetPktThreshold(XDmaChannel 
 * called "interrupt coalescing", which is used to reduce the number of
 * interrupts from devices with high data rates.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
+* RETURN VALUE:
 *
 * The packet threshold register contents for the DMA channel and is a value in
 * the range 0 - 1023.  A value of 0 indicates the packet wait bound timer is
 * disabled.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-u8
-XDmaChannel_GetPktThreshold(XDmaChannel * InstancePtr)
+u8 XDmaChannel_GetPktThreshold(XDmaChannel * InstancePtr)
 {
 	/* assert to verify input arguments */
 
@@ -1181,8 +1220,13 @@ XDmaChannel_GetPktThreshold(XDmaChannel 
 	return (u8) XIo_In32(InstancePtr->RegBaseAddress + XDC_PCT_REG_OFFSET);
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SetPktWaitBound
+*
+* DESCRIPTION:
 *
 * This function sets the value of the packet wait bound register of the
 * DMA channel.  This value reflects the timer value used to trigger an
@@ -1191,29 +1235,26 @@ XDmaChannel_GetPktThreshold(XDmaChannel 
 *
 * The timer is in millisecond units with +/- 33% accuracy.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @param
-*
 * WaitBound is the value, in milliseconds, to be stored in the wait bound
 * register of the DMA channel and is a value in the range 0  - 1023.  A value
 * of 0 disables the packet wait bound timer.
 *
-* @return
+* RETURN VALUE:
 *
 * None.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-void
-XDmaChannel_SetPktWaitBound(XDmaChannel * InstancePtr, u32 WaitBound)
+void XDmaChannel_SetPktWaitBound(XDmaChannel * InstancePtr, u32 WaitBound)
 {
 	/* assert to verify input arguments */
 
@@ -1228,8 +1269,13 @@ XDmaChannel_SetPktWaitBound(XDmaChannel 
 	XIo_Out32(InstancePtr->RegBaseAddress + XDC_PWB_REG_OFFSET, WaitBound);
 }
 
-/*****************************************************************************/
-/**
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktWaitBound
+*
+* DESCRIPTION:
 *
 * This function gets the value of the packet wait bound register of the
 * DMA channel.  This value contains the timer value used to trigger an
@@ -1238,23 +1284,22 @@ XDmaChannel_SetPktWaitBound(XDmaChannel 
 *
 * The timer is in millisecond units with +/- 33% accuracy.
 *
-* @param
+* ARGUMENTS:
 *
 * InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
 * channel should be configured to use scatter gather in order for this function
 * to be called.
 *
-* @return
+* RETURN VALUE:
 *
 * The packet wait bound register contents for the DMA channel.
 *
-* @note
+* NOTES:
 *
 * None.
 *
 ******************************************************************************/
-u32
-XDmaChannel_GetPktWaitBound(XDmaChannel * InstancePtr)
+u32 XDmaChannel_GetPktWaitBound(XDmaChannel * InstancePtr)
 {
 	/* assert to verify input arguments */
 
Index: linux-2.6.10/drivers/xilinx_common/xdma_channel.h
===================================================================
--- linux-2.6.10.orig/drivers/xilinx_common/xdma_channel.h
+++ linux-2.6.10/drivers/xilinx_common/xdma_channel.h
@@ -1,14 +1,14 @@
 /******************************************************************************
 *
 *     Author: Xilinx, Inc.
-*
-*
+*     
+*     
 *     This program is free software; you can redistribute it and/or modify it
 *     under the terms of the GNU General Public License as published by the
 *     Free Software Foundation; either version 2 of the License, or (at your
 *     option) any later version.
-*
-*
+*     
+*     
 *     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 *     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 *     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
@@ -20,28 +20,26 @@
 *     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
 *     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
 *     FITNESS FOR A PARTICULAR PURPOSE.
-*
-*
+*     
+*     
 *     Xilinx hardware products are not intended for use in life support
 *     appliances, devices, or systems. Use in such applications is
 *     expressly prohibited.
-*
-*
-*     (c) Copyright 2001-2004 Xilinx Inc.
+*     
+*     
+*     (c) Copyright 2002-2004 Xilinx Inc.
 *     All rights reserved.
-*
-*
+*     
+*     
 *     You should have received a copy of the GNU General Public License along
 *     with this program; if not, write to the Free Software Foundation, Inc.,
 *     675 Mass Ave, Cambridge, MA 02139, USA.
 *
-******************************************************************************/
-/*****************************************************************************/
-/**
+* FILENAME:
 *
-* @file xdma_channel.h
+* xdma_channel.h
 *
-* <b>Description</b>
+* DESCRIPTION:
 *
 * This file contains the DMA channel component implementation. This component
 * supports a distributed DMA design in which each device can have it's own
@@ -60,7 +58,7 @@
 * until the DMA operation completes.  DMA could be considered a primitive form
 * of multiprocessing such that caching and address translation can be an issue.
 *
-* <b>Scatter Gather Operations</b>
+* Scatter Gather Operations
 *
 * The DMA channel may support scatter gather operations. A scatter gather
 * operation automates the DMA channel such that multiple buffers can be
@@ -69,7 +67,7 @@
 * scatter gather operations of the DMA channel to describe the buffers to be
 * processed.
 *
-* <b>Scatter Gather List Operations</b>
+* Scatter Gather List Operations
 *
 * A scatter gather list may be supported by each DMA channel.  The scatter
 * gather list allows buffer descriptors to be put into the list by a device
@@ -90,24 +88,24 @@
 * descriptor from a scatter gather list and prevent it from being overwritten
 * until the buffer associated with the buffer descriptor has been processed.
 *
-* <b>Typical Scatter Gather Processing</b>
+* Typical Scatter Gather Processing
 *
 * The following steps illustrate the typical processing to use the
 * scatter gather features of a DMA channel.
 *
 * 1. Create a scatter gather list for the DMA channel which puts empty buffer
-*    descriptors into the list.<br>
+*    descriptors into the list.
 * 2. Create buffer descriptors which describe the buffers to be filled with
-*       receive data or the buffers which contain data to be sent.<br>
+* 	 receive data or the buffers which contain data to be sent.
 * 3. Put buffer descriptors into the DMA channel scatter list such that scatter
-*    gather operations are requested.<br>
+*    gather operations are requested.
 * 4. Commit the buffer descriptors in the list such that they are ready to be
-*    used by the DMA channel hardware.<br>
-* 5. Start the scatter gather operations of the DMA channel.<br>
+*    used by the DMA channel hardware.
+* 5. Start the scatter gather operations of the DMA channel.
 * 6. Process any interrupts which occur as a result of the scatter gather
 *    operations or poll the DMA channel to determine the status.
 *
-* <b>Interrupts</b>
+* Interrupts
 *
 * Each DMA channel has the ability to generate an interrupt.  This component
 * does not perform processing for the interrupt as this processing is typically
@@ -115,7 +113,7 @@
 * responsibility of the caller of DMA functions to manage the interrupt
 * including connecting to the interrupt and enabling/disabling the interrupt.
 *
-* <b>Critical Sections</b>
+* Critical Sections
 *
 * It is the responsibility of the device driver designer to use critical
 * sections as necessary when calling functions of the DMA channel.  This
@@ -124,12 +122,12 @@
 * and from an interrupt context could produce unpredictable behavior such that
 * the caller must provide the appropriate critical sections.
 *
-* <b>Address Translation</b>
+* Address Translation
 *
 * All addresses of data structures which are passed to DMA functions must
 * be physical (real) addresses as opposed to logical (virtual) addresses.
 *
-* <b>Caching</b>
+* Caching
 *
 * The memory which is passed to the function which creates the scatter gather
 * list must not be cached such that buffer descriptors are non-cached.  This
@@ -147,33 +145,25 @@
 * invalidated prior to using any data buffers which are the result of a DMA
 * operation.
 *
-* <b>Memory Alignment</b>
+* Memory Alignment
 *
 * The addresses of data buffers which are passed to DMA functions must be
 * 32 bit word aligned since the DMA hardware performs 32 bit word transfers.
 *
-* <b>Mutual Exclusion</b>
+* Mutual Exclusion
 *
 * The functions of the DMA channel are not thread safe such that the caller
 * of all DMA functions is responsible for ensuring mutual exclusion for a
 * DMA channel.  Mutual exclusion across multiple DMA channels is not
 * necessary.
 *
-* @note
+* NOTES:
 *
 * Many of the provided functions which are register accessors don't provide
 * a lot of error detection. The caller is expected to understand the impact
 * of a function call based upon the current state of the DMA channel.  This
 * is done to minimize the overhead in this component.
 *
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a xd  10/27/04  Doxygenated for inclusion in API documentation
-* </pre>
-*
 ******************************************************************************/
 
 #ifndef XDMA_CHANNEL_H		/* prevent circular inclusions */
@@ -189,117 +179,96 @@
 
 /************************** Constant Definitions *****************************/
 
-/** @name DMA control register bit fields
- *
- * the following constants provide access to the bit fields of the DMA control
+/* the following constants provide access to the bit fields of the DMA control
  * register (DMACR)
- * @{
  */
-#define XDC_DMACR_SOURCE_INCR_MASK   0x80000000UL /**< increment source address */
-#define XDC_DMACR_DEST_INCR_MASK     0x40000000UL /**< increment dest address */
-#define XDC_DMACR_SOURCE_LOCAL_MASK  0x20000000UL /**< local source address */
-#define XDC_DMACR_DEST_LOCAL_MASK    0x10000000UL /**< local dest address */
-#define XDC_DMACR_SG_DISABLE_MASK    0x08000000UL /**< scatter gather disable */
-#define XDC_DMACR_GEN_BD_INTR_MASK   0x04000000UL /**< descriptor interrupt */
-#define XDC_DMACR_LAST_BD_MASK       XDC_CONTROL_LAST_BD_MASK /**< last buffer
-                                                                   descriptor */
-#define XDC_DMACR_DRE_MODE_MASK      0x01000000UL /**< DRE/normal mode */
-/* @} */
-
-/** @name DMA status register bit fields
- *
- * the following constants provide access to the bit fields of the DMA status
+#define XDC_DMACR_SOURCE_INCR_MASK	0x80000000UL	/* increment source address */
+#define XDC_DMACR_DEST_INCR_MASK	0x40000000UL	/* increment dest address */
+#define XDC_DMACR_SOURCE_LOCAL_MASK 0x20000000UL	/* local source address */
+#define XDC_DMACR_DEST_LOCAL_MASK	0x10000000UL	/* local dest address */
+#define XDC_DMACR_SG_DISABLE_MASK	0x08000000UL	/* scatter gather disable */
+#define XDC_DMACR_GEN_BD_INTR_MASK	0x04000000UL	/* descriptor interrupt */
+#define XDC_DMACR_LAST_BD_MASK		XDC_CONTROL_LAST_BD_MASK	/* last buffer */
+									/*     descriptor  */
+#define XDC_DMACR_DRE_MODE_MASK		0x01000000UL	/* DRE/normal mode */
+
+/* the following constants provide access to the bit fields of the DMA status
  * register (DMASR)
- * @{
  */
-#define XDC_DMASR_BUSY_MASK          0x80000000UL /**< channel is busy */
-#define XDC_DMASR_BUS_ERROR_MASK     0x40000000UL /**< bus error occurred */
-#define XDC_DMASR_BUS_TIMEOUT_MASK   0x20000000UL /**< bus timeout occurred */
-#define XDC_DMASR_LAST_BD_MASK       XDC_STATUS_LAST_BD_MASK /**< last buffer
-                                                                  descriptor */
-#define XDC_DMASR_SG_BUSY_MASK       0x08000000UL /**< scatter gather is busy */
-/* @} */
-
-/** @name Interrupt Status/Enable Register bit fields
- *
- * the following constants provide access to the bit fields of the interrupt
+#define XDC_DMASR_BUSY_MASK			0x80000000UL	/* channel is busy */
+#define XDC_DMASR_BUS_ERROR_MASK	0x40000000UL	/* bus error occurred */
+#define XDC_DMASR_BUS_TIMEOUT_MASK	0x20000000UL	/* bus timeout occurred */
+#define XDC_DMASR_LAST_BD_MASK		XDC_STATUS_LAST_BD_MASK	/* last buffer */
+								/* descriptor  */
+#define XDC_DMASR_SG_BUSY_MASK		0x08000000UL	/* scatter gather is busy */
+
+/* the following constants provide access to the bit fields of the interrupt
  * status register (ISR) and the interrupt enable register (IER), bit masks
  * match for both registers such that they are named IXR
- * @{
  */
-#define XDC_IXR_DMA_DONE_MASK       0x1UL  /**< dma operation done */
-#define XDC_IXR_DMA_ERROR_MASK      0x2UL  /**< dma operation error */
-#define XDC_IXR_PKT_DONE_MASK       0x4UL  /**< packet done */
-#define XDC_IXR_PKT_THRESHOLD_MASK  0x8UL  /**< packet count threshold */
-#define XDC_IXR_PKT_WAIT_BOUND_MASK 0x10UL /**< packet wait bound reached */
-#define XDC_IXR_SG_DISABLE_ACK_MASK 0x20UL /**< scatter gather disable
-                                                acknowledge occurred */
-#define XDC_IXR_SG_END_MASK         0x40UL /**< last buffer descriptor
-                                                disabled scatter gather */
-#define XDC_IXR_BD_MASK             0x80UL /**< buffer descriptor done */
-/* @} */
+#define XDC_IXR_DMA_DONE_MASK		0x1UL	/* dma operation done */
+#define XDC_IXR_DMA_ERROR_MASK	    0x2UL	/* dma operation error */
+#define XDC_IXR_PKT_DONE_MASK	    0x4UL	/* packet done */
+#define XDC_IXR_PKT_THRESHOLD_MASK 	0x8UL	/* packet count threshold */
+#define XDC_IXR_PKT_WAIT_BOUND_MASK 0x10UL	/* packet wait bound reached */
+#define XDC_IXR_SG_DISABLE_ACK_MASK 0x20UL	/* scatter gather disable
+						   acknowledge occurred */
+#define XDC_IXR_SG_END_MASK			0x40UL	/* last buffer descriptor
+							   disabled scatter gather */
+#define XDC_IXR_BD_MASK				0x80UL	/* buffer descriptor done */
 
 /**************************** Type Definitions *******************************/
 
-/**
+/*
  * the following structure contains data which is on a per instance basis
  * for the XDmaChannel component
  */
 typedef struct XDmaChannelTag {
-	XVersion Version;	    /**< version of the driver */
-	u32 RegBaseAddress;	/**< base address of registers */
-	u32 IsReady;		/**< device is initialized and ready */
-
-	XBufDescriptor *PutPtr;	    /**< keep track of where to put into list */
-	XBufDescriptor *GetPtr;	    /**< keep track of where to get from list */
-	XBufDescriptor *CommitPtr;  /**< keep track of where to commit in list */
-	XBufDescriptor *LastPtr;    /**< keep track of the last put in the list */
-	void *VirtPtr;		    /**< virtual base of memory */
-	void *PhyPtr;		    /**< physical base of memory */
-	u32 TotalDescriptorCount;
-				/**< total # of descriptors in the list */
-	u32 ActiveDescriptorCount;
-				/**< # of descriptors pointing to buffers
-                                         in the buffer descriptor list */
+	XVersion Version;	/* version of the driver */
+	u32 RegBaseAddress;	/* base address of registers */
+	u32 IsReady;		/* device is initialized and ready */
+
+	XBufDescriptor *PutPtr;	/* keep track of where to put into list */
+	XBufDescriptor *GetPtr;	/* keep track of where to get from list */
+	XBufDescriptor *CommitPtr;	/* keep track of where to commit in list */
+	XBufDescriptor *LastPtr;	/* keep track of the last put in the list */
+	void *VirtPtr;		/* virtual base of memory */
+	void *PhyPtr;		/* physical base of memory */
+	u32 TotalDescriptorCount;	/* total # of descriptors in the list */
+	u32 ActiveDescriptorCount;	/* # of descriptors pointing to buffers
+					 * in the buffer descriptor list */
 } XDmaChannel;
 
 /***************** Macros (Inline Functions) Definitions *********************/
 
 /************************** Function Prototypes ******************************/
 
-/**
- * Standard functions
- */
 XStatus XDmaChannel_Initialize(XDmaChannel * InstancePtr, u32 BaseAddress);
 u32 XDmaChannel_IsReady(XDmaChannel * InstancePtr);
 XVersion *XDmaChannel_GetVersion(XDmaChannel * InstancePtr);
 XStatus XDmaChannel_SelfTest(XDmaChannel * InstancePtr);
 void XDmaChannel_Reset(XDmaChannel * InstancePtr);
 
-/**
- * Control functions
- */
+/* Control functions */
+
 u32 XDmaChannel_GetControl(XDmaChannel * InstancePtr);
 void XDmaChannel_SetControl(XDmaChannel * InstancePtr, u32 Control);
 
-/**
- * Status functions
- */
+/* Status functions */
+
 u32 XDmaChannel_GetStatus(XDmaChannel * InstancePtr);
 void XDmaChannel_SetIntrStatus(XDmaChannel * InstancePtr, u32 Status);
 u32 XDmaChannel_GetIntrStatus(XDmaChannel * InstancePtr);
 void XDmaChannel_SetIntrEnable(XDmaChannel * InstancePtr, u32 Enable);
 u32 XDmaChannel_GetIntrEnable(XDmaChannel * InstancePtr);
 
-/**
- * DMA without scatter gather functions
- */
+/* DMA without scatter gather functions */
+
 void XDmaChannel_Transfer(XDmaChannel * InstancePtr,
 			  u32 * SourcePtr, u32 * DestinationPtr, u32 ByteCount);
 
-/**
- * Scatter gather functions
- */
+/* Scatter gather functions */
+
 XStatus XDmaChannel_SgStart(XDmaChannel * InstancePtr);
 XStatus XDmaChannel_SgStop(XDmaChannel * InstancePtr,
 			   XBufDescriptor ** BufDescriptorPtr);
@@ -313,9 +282,8 @@ XStatus XDmaChannel_CommitPuts(XDmaChann
 XStatus XDmaChannel_GetDescriptor(XDmaChannel * InstancePtr,
 				  XBufDescriptor ** BufDescriptorPtr);
 
-/**
- * Packet functions for interrupt coalescing
- */
+/* Packet functions for interrupt collescing */
+
 u32 XDmaChannel_GetPktCount(XDmaChannel * InstancePtr);
 void XDmaChannel_DecrementPktCount(XDmaChannel * InstancePtr);
 XStatus XDmaChannel_SetPktThreshold(XDmaChannel * InstancePtr, u8 Threshold);
Index: linux-2.6.10/drivers/net/xilinx_emac/xemac.c
===================================================================
--- linux-2.6.10.orig/drivers/net/xilinx_emac/xemac.c
+++ linux-2.6.10/drivers/net/xilinx_emac/xemac.c
@@ -27,7 +27,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002-2005 Xilinx Inc.
+*     (c) Copyright 2003-2005 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -65,6 +65,15 @@
 *                     the packet fifo driver.
 * 1.00e rmm  04/06/04 Changed XEmac_Initialize() to clear the instance data.
 *                     Added XEM_NO_SGEND_INT_OPTION processing to XEmac_Start().
+* 1.00f ???  ???????? Other changes?
+* 1.00f jvb  10/13/05 I changed Initialize() into Init(), and made Init() take a
+*                     pointer to a config structure instead of a device id.
+*                     I moved Initialize() into xemac_sinit.c, and had
+*                     Initialize() call Init() after it retrieved the config
+*                     structure from the device id.
+*                     I removed include of xparameters.h along with any
+*                     dependencies on xparameters.h.
+*
 * </pre>
 ******************************************************************************/
 
@@ -106,40 +115,37 @@ static void StubSgHandler(void *CallBack
 * - Reset the Ethernet MAC
 *
 * @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param DeviceId is the unique id of the device controlled by this XEmac
-*        instance.  Passing in a device id associates the generic XEmac
-*        instance to a specific device, as chosen by the caller or application
-*        developer.
+* @param Config is a reference to a structure containing information about
+*        a specific EMAC device. XEmac_Init initializes an InstancePtr object
+*        for a specific device specified by the contents of Config. XEmac_Init
+*        can initialize multiple instance objects with the use of multiple
+*        calls giving different Config information on each call.
+* @param EffectiveAddr is the device base address in the virtual memory address
+*        space. The caller is responsible for keeping the address mapping
+*        from EffectiveAddr to the device physical base address unchanged
+*        once this function is invoked. Unexpected errors may occur if the
+*        address mapping changes after this function is called. If address
+*        translation is not used, use Config->BaseAddress for this parameters,
+*        passing the physical address instead.
 *
 * @return
 *
 * - XST_SUCCESS if initialization was successful
-* - XST_DEVICE_NOT_FOUND if device configuration information was not found for
-*   a device with the supplied device ID.
 *
 * @note
 *
 * None.
 *
 ******************************************************************************/
-XStatus
-XEmac_Initialize(XEmac * InstancePtr, u16 DeviceId)
+XStatus XEmac_CfgInitialize(XEmac * InstancePtr, XEmac_Config * Config,
+			    u32 EffectiveAddr)
 {
 	XStatus Result;
 
 	XASSERT_NONVOID(InstancePtr != NULL);
 
 	/* Clear instance memory */
-	memset(InstancePtr, 0, sizeof (XEmac));
-
-	/*
-	 * Lookup the device configuration in the temporary CROM table. Use this
-	 * configuration info down below when initializing this component.
-	 */
-	InstancePtr->ConfigPtr = XEmac_LookupConfig(DeviceId);
-	if (InstancePtr->ConfigPtr == NULL) {
-		return XST_DEVICE_NOT_FOUND;
-	}
+	memset(InstancePtr, 0, sizeof(XEmac));
 
 	/*
 	 * Set some default values
@@ -158,8 +164,16 @@ XEmac_Initialize(XEmac * InstancePtr, u1
 	/*
 	 * Save the baseaddress for faster access
 	 */
-	InstancePtr->BaseAddress = InstancePtr->ConfigPtr->BaseAddress;
-	InstancePtr->PhysAddress = InstancePtr->ConfigPtr->PhysAddress;
+	InstancePtr->BaseAddress = EffectiveAddr;
+	InstancePtr->PhysAddress = Config->PhysAddress;
+
+	/*
+	 * Save other config items
+	 */
+	InstancePtr->IpIfDmaConfig = Config->IpIfDmaConfig;
+	InstancePtr->HasMii = Config->HasMii;
+	InstancePtr->HasCam = Config->HasCam;
+	InstancePtr->HasJumbo = Config->HasJumbo;
 
 	/*
 	 * Configure the send and receive FIFOs in the MAC
@@ -250,8 +264,7 @@ XEmac_Initialize(XEmac * InstancePtr, u1
 * provide protection of this shared data (typically using a semaphore).
 *
 ******************************************************************************/
-XStatus
-XEmac_Start(XEmac * InstancePtr)
+XStatus XEmac_Start(XEmac * InstancePtr)
 {
 	u32 ControlReg;
 	XStatus Result;
@@ -404,8 +417,7 @@ XEmac_Start(XEmac * InstancePtr)
 * provide protection of this shared data (typically using a semaphore).
 *
 ******************************************************************************/
-XStatus
-XEmac_Stop(XEmac * InstancePtr)
+XStatus XEmac_Stop(XEmac * InstancePtr)
 {
 	u32 ControlReg;
 
@@ -431,8 +443,8 @@ XEmac_Stop(XEmac * InstancePtr)
 
 		XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
 
-		(void) XDmaChannel_SgStop(&InstancePtr->SendChannel, &BdTemp);
-		(void) XDmaChannel_SgStop(&InstancePtr->RecvChannel, &BdTemp);
+		(void)XDmaChannel_SgStop(&InstancePtr->SendChannel, &BdTemp);
+		(void)XDmaChannel_SgStop(&InstancePtr->RecvChannel, &BdTemp);
 
 		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
 	}
@@ -517,8 +529,7 @@ XEmac_Stop(XEmac * InstancePtr)
 * care of resetting all hardware blocks, including the MAC.
 *
 ******************************************************************************/
-void
-XEmac_Reset(XEmac * InstancePtr)
+void XEmac_Reset(XEmac * InstancePtr)
 {
 	XASSERT_VOID(InstancePtr != NULL);
 	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
@@ -526,7 +537,7 @@ XEmac_Reset(XEmac * InstancePtr)
 	/*
 	 * Stop the device first
 	 */
-	(void) XEmac_Stop(InstancePtr);
+	(void)XEmac_Stop(InstancePtr);
 
 	/*
 	 * Take the driver out of polled mode
@@ -548,14 +559,14 @@ XEmac_Reset(XEmac * InstancePtr)
 		 * values of these functions since they only return error if the device
 		 * is not stopped.
 		 */
-		(void) XEmac_SetPktThreshold(InstancePtr, XEM_SEND,
-					     XEM_SGDMA_DFT_THRESHOLD);
-		(void) XEmac_SetPktThreshold(InstancePtr, XEM_RECV,
-					     XEM_SGDMA_DFT_THRESHOLD);
-		(void) XEmac_SetPktWaitBound(InstancePtr, XEM_SEND,
-					     XEM_SGDMA_DFT_WAITBOUND);
-		(void) XEmac_SetPktWaitBound(InstancePtr, XEM_RECV,
-					     XEM_SGDMA_DFT_WAITBOUND);
+		(void)XEmac_SetPktThreshold(InstancePtr, XEM_SEND,
+					    XEM_SGDMA_DFT_THRESHOLD);
+		(void)XEmac_SetPktThreshold(InstancePtr, XEM_RECV,
+					    XEM_SGDMA_DFT_THRESHOLD);
+		(void)XEmac_SetPktWaitBound(InstancePtr, XEM_SEND,
+					    XEM_SGDMA_DFT_WAITBOUND);
+		(void)XEmac_SetPktWaitBound(InstancePtr, XEM_RECV,
+					    XEM_SGDMA_DFT_WAITBOUND);
 	}
 }
 
@@ -578,8 +589,7 @@ XEmac_Reset(XEmac * InstancePtr)
 * None.
 *
 ******************************************************************************/
-XStatus
-XEmac_SetMacAddress(XEmac * InstancePtr, u8 * AddressPtr)
+XStatus XEmac_SetMacAddress(XEmac * InstancePtr, u8 * AddressPtr)
 {
 	u32 MacAddr = 0;
 
@@ -627,8 +637,7 @@ XEmac_SetMacAddress(XEmac * InstancePtr,
 * None.
 *
 ******************************************************************************/
-void
-XEmac_GetMacAddress(XEmac * InstancePtr, u8 * BufferPtr)
+void XEmac_GetMacAddress(XEmac * InstancePtr, u8 * BufferPtr)
 {
 	u32 MacAddrHi;
 	u32 MacAddrLo;
@@ -664,8 +673,7 @@ XEmac_GetMacAddress(XEmac * InstancePtr,
 * None.
 *
 ******************************************************************************/
-static XStatus
-ConfigureDma(XEmac * InstancePtr)
+static XStatus ConfigureDma(XEmac * InstancePtr)
 {
 	XStatus Result;
 
@@ -705,8 +713,7 @@ ConfigureDma(XEmac * InstancePtr)
 * None.
 *
 ******************************************************************************/
-static XStatus
-ConfigureFifo(XEmac * InstancePtr)
+static XStatus ConfigureFifo(XEmac * InstancePtr)
 {
 	XStatus Result;
 
@@ -750,8 +757,7 @@ ConfigureFifo(XEmac * InstancePtr)
 * None.
 *
 ******************************************************************************/
-static void
-StubSgHandler(void *CallBackRef, XBufDescriptor * BdPtr, u32 NumBds)
+static void StubSgHandler(void *CallBackRef, XBufDescriptor * BdPtr, u32 NumBds)
 {
 	XASSERT_VOID_ALWAYS();
 }
@@ -773,8 +779,7 @@ StubSgHandler(void *CallBackRef, XBufDes
 * None.
 *
 ******************************************************************************/
-static void
-StubFifoHandler(void *CallBackRef)
+static void StubFifoHandler(void *CallBackRef)
 {
 	XASSERT_VOID_ALWAYS();
 }
@@ -797,8 +802,7 @@ StubFifoHandler(void *CallBackRef)
 * None.
 *
 ******************************************************************************/
-static void
-StubErrorHandler(void *CallBackRef, XStatus ErrorCode)
+static void StubErrorHandler(void *CallBackRef, XStatus ErrorCode)
 {
 	XASSERT_VOID_ALWAYS();
 }
Index: linux-2.6.10/drivers/net/xilinx_emac/xemac.h
===================================================================
--- linux-2.6.10.orig/drivers/net/xilinx_emac/xemac.h
+++ linux-2.6.10/drivers/net/xilinx_emac/xemac.h
@@ -1,3 +1,4 @@
+/* $Id: xemac.h,v 1.1 2005/05/18 22:32:39 jbonesio Exp $ */
 /******************************************************************************
 *
 *     Author: Xilinx, Inc.
@@ -27,7 +28,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002-2005 Xilinx Inc.
+*     (c) Copyright 2003-2005 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -99,7 +100,7 @@
 * The driver may not enforce this alignment so it is up to the user to
 * guarantee the proper alignment.
 *
-* <b>Receive Address Filtering<b>
+* <b>Receive Address Filtering</b>
 *
 * The device can be set to accept frames whose destination MAC address:
 *
@@ -281,6 +282,11 @@
 *                     functions. Moved some IFG and PHY constants to xemac_l.h.
 * 1.00f rmm  10/19/04 Added programmable CAM address filtering. Added jumbo
 *                     frame support. Added XEmac_PhyReset() function.
+* 1.00f jvb  10/13/05 I separated dependency on the config and xparameters.h
+*                     from the driver initialization.
+*                     I added the new Init routine to the list of prototypes.
+*                     I removed the pointer to the config structure from the
+*                     instance structure.
 * </pre>
 *
 ******************************************************************************/
@@ -472,11 +478,11 @@ typedef struct {
 	u16 DeviceId;	    /**< Unique ID  of device */
 	u32 BaseAddress;    /**< Register base address */
 	u32 PhysAddress;    /**< Physical Base address */
-	u32 HasCounters;    /**< Does device have counters? */
+	u32 HasCounters;   /**< Does device have counters? */
 	u8 IpIfDmaConfig;   /**< IPIF/DMA hardware configuration */
-	u32 HasMii;	    /**< Does device support MII? */
-	u32 HasCam;	    /**< Does device have multicast CAM */
-	u32 HasJumbo;	    /**< Can device transfer jumbo frames */
+	u32 HasMii;	   /**< Does device support MII? */
+	u32 HasCam;	   /**< Does device have multicast CAM */
+	u32 HasJumbo;	   /**< Can device transfer jumbo frames */
 } XEmac_Config;
 
 /** @name Typedefs for callbacks
@@ -526,12 +532,15 @@ typedef void (*XEmac_ErrorHandler) (void
  * to a variable of this type is then passed to the driver API functions.
  */
 typedef struct {
-	u32 BaseAddress;	/* Base address, virtual (of IPIF) */
-	u32 PhysAddress;	/* Base address, physical (of IPIF) */
+	u32 BaseAddress;	/* Base address (of IPIF) */
+	u32 PhysAddress;	/* Base address, physical  (of IPIF) */
 	u32 IsStarted;		/* Device is currently started */
 	u32 IsReady;		/* Device is initialized and ready */
 	u32 IsPolled;		/* Device is in polled mode */
-	XEmac_Config *ConfigPtr;	/* Configuration table entry */
+	u8 IpIfDmaConfig;	/* IPIF/DMA hardware configuration */
+	u32 HasMii;		/* Does device support MII? */
+	u32 HasCam;		/* Does device have multicast CAM */
+	u32 HasJumbo;		/* Can device transfer jumbo frames */
 
 	XEmac_Stats Stats;
 	XPacketFifoV200a RecvFifo;	/* FIFO used to receive frames */
@@ -578,7 +587,7 @@ typedef struct {
 *
 ******************************************************************************/
 #define XEmac_mIsSgDma(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->IpIfDmaConfig == XEM_CFG_DMA_SG) ? \
+    (((InstancePtr)->IpIfDmaConfig == XEM_CFG_DMA_SG) ? \
      TRUE : FALSE)
 
 /*****************************************************************************/
@@ -598,7 +607,7 @@ typedef struct {
 *
 ******************************************************************************/
 #define XEmac_mIsSimpleDma(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->IpIfDmaConfig == XEM_CFG_SIMPLE_DMA) ? \
+    (((InstancePtr)->IpIfDmaConfig == XEM_CFG_SIMPLE_DMA) ? \
      TRUE : FALSE)
 
 /*****************************************************************************/
@@ -640,7 +649,7 @@ typedef struct {
 *
 ******************************************************************************/
 #define XEmac_mHasCam(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->HasCam == 1) ? TRUE : FALSE)
+    (((InstancePtr)->HasCam == 1) ? TRUE : FALSE)
 
 /*****************************************************************************/
 /**
@@ -660,7 +669,7 @@ typedef struct {
 *
 ******************************************************************************/
 #define XEmac_mHasMii(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->HasMii == 1) ? TRUE : FALSE)
+    (((InstancePtr)->HasMii == 1) ? TRUE : FALSE)
 
 /*****************************************************************************/
 /**
@@ -681,18 +690,24 @@ typedef struct {
 *
 ******************************************************************************/
 #define XEmac_mHasJumbo(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->HasJumbo == 1) ? TRUE : FALSE)
+    (((InstancePtr)->HasJumbo == 1) ? TRUE : FALSE)
 
 /************************** Function Prototypes ******************************/
 
 /*
- * Initialization functions in xemac.c
+ * Initialization functions in xemac_sinit.c
  */
 XStatus XEmac_Initialize(XEmac * InstancePtr, u16 DeviceId);
+XEmac_Config *XEmac_LookupConfig(u16 DeviceId);
+
+/*
+ * Initialization functions in xemac.c
+ */
+XStatus XEmac_CfgInitialize(XEmac * InstancePtr, XEmac_Config * Config,
+			    u32 EffectiveAddr);
 XStatus XEmac_Start(XEmac * InstancePtr);
 XStatus XEmac_Stop(XEmac * InstancePtr);
 void XEmac_Reset(XEmac * InstancePtr);
-XEmac_Config *XEmac_LookupConfig(u16 DeviceId);
 
 /*
  * Diagnostic functions in xemac_selftest.c
Index: linux-2.6.10/drivers/net/xilinx_emac/xemac_intr_dma.c
===================================================================
--- linux-2.6.10.orig/drivers/net/xilinx_emac/xemac_intr_dma.c
+++ linux-2.6.10/drivers/net/xilinx_emac/xemac_intr_dma.c
@@ -27,7 +27,7 @@
 *     expressly prohibited.
 *
 *
-*     (c) Copyright 2002-2005 Xilinx Inc.
+*     (c) Copyright 2003 Xilinx Inc.
 *     All rights reserved.
 *
 *
@@ -67,7 +67,7 @@
 *                     reset had cleared it.
 * 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
 *                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Instead of invoking once for each packet received,
+* 1.00e rmm  04/06/04 Instead of invoking once for each packet received, 
 *                     send/recv callbacks are invoked once for all packets.
 *                     Added functions XEmac_GetSgRecvFreeDesc() and XEmac_Get-
 *                     SgSendFreeDesc().
@@ -163,8 +163,7 @@ static void HandleEmacDmaIntr(XEmac * In
 * started.
 *
 ******************************************************************************/
-XStatus
-XEmac_SgSend(XEmac * InstancePtr, XBufDescriptor * BdPtr, int Delay)
+XStatus XEmac_SgSend(XEmac * InstancePtr, XBufDescriptor * BdPtr, int Delay)
 {
 	XStatus Result;
 	u32 BdControl;
@@ -190,7 +189,7 @@ XEmac_SgSend(XEmac * InstancePtr, XBufDe
 	XBufDescriptor_SetControl(BdPtr, BdControl | XEM_DFT_SEND_BD_MASK);
 
 	XBufDescriptor_SetDestAddress(BdPtr,
-				      InstancePtr->PhysAddress +
+				      InstancePtr->BaseAddress +
 				      XEM_PFIFO_TXDATA_OFFSET);
 
 	/*
@@ -225,7 +224,7 @@ XEmac_SgSend(XEmac * InstancePtr, XBufDe
 			 * that can be modified at interrupt or task levels, so a critical
 			 * section is required.
 			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->SendChannel);
+			(void)XDmaChannel_SgStart(&InstancePtr->SendChannel);
 		}
 	}
 
@@ -276,8 +275,7 @@ XEmac_SgSend(XEmac * InstancePtr, XBufDe
 * started.
 *
 ******************************************************************************/
-XStatus
-XEmac_SgRecv(XEmac * InstancePtr, XBufDescriptor * BdPtr)
+XStatus XEmac_SgRecv(XEmac * InstancePtr, XBufDescriptor * BdPtr)
 {
 	XStatus Result;
 	u32 BdControl;
@@ -301,7 +299,7 @@ XEmac_SgRecv(XEmac * InstancePtr, XBufDe
 	BdControl = XBufDescriptor_GetControl(BdPtr);
 	XBufDescriptor_SetControl(BdPtr, BdControl | XEM_DFT_RECV_BD_MASK);
 	XBufDescriptor_SetSrcAddress(BdPtr,
-				     InstancePtr->PhysAddress +
+				     InstancePtr->BaseAddress +
 				     XEM_PFIFO_RXDATA_OFFSET);
 
 	/*
@@ -331,7 +329,7 @@ XEmac_SgRecv(XEmac * InstancePtr, XBufDe
 	 * already started. The DMA component accesses data here that can be
 	 * modified at interrupt or task levels, so a critical section is required.
 	 */
-	(void) XDmaChannel_SgStart(&InstancePtr->RecvChannel);
+	(void)XDmaChannel_SgStart(&InstancePtr->RecvChannel);
 
 	XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
 
@@ -360,8 +358,7 @@ XEmac_SgRecv(XEmac * InstancePtr, XBufDe
 * None.
 *
 ******************************************************************************/
-void
-XEmac_IntrHandlerDma(void *InstancePtr)
+void XEmac_IntrHandlerDma(void *InstancePtr)
 {
 	u32 IntrStatus;
 	XEmac *EmacPtr = (XEmac *) InstancePtr;
@@ -451,8 +448,7 @@ XEmac_IntrHandlerDma(void *InstancePtr)
 * caused confustion.
 *
 ******************************************************************************/
-XStatus
-XEmac_SetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 Threshold)
+XStatus XEmac_SetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 Threshold)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
@@ -518,8 +514,8 @@ XEmac_SetPktThreshold(XEmac * InstancePt
 * None.
 *
 ******************************************************************************/
-XStatus
-XEmac_GetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 * ThreshPtr)
+XStatus XEmac_GetPktThreshold(XEmac * InstancePtr, u32 Direction,
+			      u8 * ThreshPtr)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
@@ -584,8 +580,8 @@ XEmac_GetPktThreshold(XEmac * InstancePt
 * None.
 *
 ******************************************************************************/
-XStatus
-XEmac_SetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 TimerValue)
+XStatus XEmac_SetPktWaitBound(XEmac * InstancePtr, u32 Direction,
+			      u32 TimerValue)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
@@ -655,8 +651,7 @@ XEmac_SetPktWaitBound(XEmac * InstancePt
 * None.
 *
 ******************************************************************************/
-XStatus
-XEmac_GetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 * WaitPtr)
+XStatus XEmac_GetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 * WaitPtr)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
@@ -721,9 +716,8 @@ XEmac_GetPktWaitBound(XEmac * InstancePt
 * components must be initialized before the memory space is set.
 *
 ******************************************************************************/
-XStatus
-XEmac_SetSgRecvSpace(XEmac * InstancePtr, u32 * MemoryPtr, u32 ByteCount,
-		    void *PhyPtr)
+XStatus XEmac_SetSgRecvSpace(XEmac * InstancePtr, u32 * MemoryPtr,
+			     u32 ByteCount, void *PhyPtr)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(MemoryPtr != NULL);
@@ -768,9 +762,8 @@ XEmac_SetSgRecvSpace(XEmac * InstancePtr
 * components must be initialized before the memory space is set.
 *
 ******************************************************************************/
-XStatus
-XEmac_SetSgSendSpace(XEmac * InstancePtr, u32 * MemoryPtr, u32 ByteCount,
-		    void *PhyPtr)
+XStatus XEmac_SetSgSendSpace(XEmac * InstancePtr, u32 * MemoryPtr,
+			     u32 ByteCount, void *PhyPtr)
 {
 	XASSERT_NONVOID(InstancePtr != NULL);
 	XASSERT_NONVOID(MemoryPtr != NULL);
@@ -788,7 +781,7 @@ XEmac_SetSgSendSpace(XEmac * InstancePtr
 /*****************************************************************************/
 /**
 *
-* Return the number of free buffer descriptor slots that can be added to the
+* Return the number of free buffer descriptor slots that can be added to the 
 * send descriptor ring with XEmac_SgSend() before filling it up.
 *
 * @param InstancePtr is a pointer to the XEmac instance to be worked on.
@@ -803,8 +796,7 @@ XEmac_SetSgSendSpace(XEmac * InstancePtr
 * None.
 *
 ******************************************************************************/
-unsigned
-XEmac_GetSgSendFreeDesc(XEmac * InstancePtr)
+unsigned XEmac_GetSgSendFreeDesc(XEmac * InstancePtr)
 {
 	unsigned Slots;
 
@@ -820,7 +812,7 @@ XEmac_GetSgSendFreeDesc(XEmac * Instance
 /*****************************************************************************/
 /**
 *
-* Return the number of free buffer descriptor slots that can be added to the
+* Return the number of free buffer descriptor slots that can be added to the 
 * receive descriptor ring with XEmac_SgRecv() before filling it up.
 *
 * @param InstancePtr is a pointer to the XEmac instance to be worked on.
@@ -835,8 +827,7 @@ XEmac_GetSgSendFreeDesc(XEmac * Instance
 * None.
 *
 ******************************************************************************/
-unsigned
-XEmac_GetSgRecvFreeDesc(XEmac * InstancePtr)
+unsigned XEmac_GetSgRecvFreeDesc(XEmac * InstancePtr)
 {
 	unsigned Slots;
 
@@ -879,9 +870,8 @@ XEmac_GetSgRecvFreeDesc(XEmac * Instance
 * None.
 *
 ******************************************************************************/
-void
-XEmac_SetSgRecvHandler(XEmac * InstancePtr, void *CallBackRef,
-		       XEmac_SgHandler FuncPtr)
+void XEmac_SetSgRecvHandler(XEmac * InstancePtr, void *CallBackRef,
+			    XEmac_SgHandler FuncPtr)
 {
 	/*
 	 * Asserted IsDmaSg here instead of run-time check because there is really
@@ -925,9 +915,8 @@ XEmac_SetSgRecvHandler(XEmac * InstanceP
 * None.
 *
 ******************************************************************************/
-void
-XEmac_SetSgSendHandler(XEmac * InstancePtr, void *CallBackRef,
-		       XEmac_SgHandler FuncPtr)
+void XEmac_SetSgSendHandler(XEmac * InstancePtr, void *CallBackRef,
+			    XEmac_SgHandler FuncPtr)
 {
 	/*
 	 * Asserted IsDmaSg here instead of run-time check because there is really
@@ -990,8 +979,7 @@ XEmac_SetSgSendHandler(XEmac * InstanceP
 * None.
 *
 ******************************************************************************/
-static void
-HandleDmaRecvIntr(XEmac * InstancePtr)
+static void HandleDmaRecvIntr(XEmac * InstancePtr)
 {
 	XStatus Result;
 	u32 IntrStatus;
@@ -1107,7 +1095,7 @@ HandleDmaRecvIntr(XEmac * InstancePtr)
 			 * Ignore the return status since we know the list exists and we
 			 * don't care if the list is empty or the channel is already started.
 			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->RecvChannel);
+			(void)XDmaChannel_SgStart(&InstancePtr->RecvChannel);
 		}
 	}
 
@@ -1182,8 +1170,7 @@ HandleDmaRecvIntr(XEmac * InstancePtr)
 * None.
 *
 ******************************************************************************/
-static void
-HandleDmaSendIntr(XEmac * InstancePtr)
+static void HandleDmaSendIntr(XEmac * InstancePtr)
 {
 	XStatus Result;
 	u32 IntrStatus;
@@ -1325,7 +1312,7 @@ HandleDmaSendIntr(XEmac * InstancePtr)
 			 * Ignore the return status since we know the list exists and we
 			 * don't care if the list is empty or the channel is already started.
 			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->SendChannel);
+			(void)XDmaChannel_SgStart(&InstancePtr->SendChannel);
 		}
 	}
 
@@ -1369,8 +1356,7 @@ HandleDmaSendIntr(XEmac * InstancePtr)
 * None.
 *
 ******************************************************************************/
-static void
-HandleEmacDmaIntr(XEmac * InstancePtr)
+static void HandleEmacDmaIntr(XEmac * InstancePtr)
 {
 	u32 IntrStatus;
 
Index: linux-2.6.10/drivers/net/xilinx_emac/adapter.c
===================================================================
--- linux-2.6.10.orig/drivers/net/xilinx_emac/adapter.c
+++ linux-2.6.10/drivers/net/xilinx_emac/adapter.c
@@ -41,19 +41,7 @@
 
 #define TX_TIMEOUT (3*HZ)	/* Transmission timeout is 3 seconds. */
 
-#define XEMAC_MAX_DEVICE_ID 4
-static XEmac_Config * xemac_cfgs[XEMAC_MAX_DEVICE_ID];
-
 DEFINE_SPINLOCK(XE_spinlock);
-/*
- * Lookup the device configuration based on the unique device ID.
- * Prototyped in xemac.h.
- */
-inline XEmac_Config * XEmac_LookupConfig(u16 DeviceId)
-{
-	return (DeviceId < XEMAC_MAX_DEVICE_ID) ?
-		xemac_cfgs[DeviceId] : NULL;
-}
 
 /*
  * Helper function to reset the underlying hardware.  This is called
@@ -101,14 +89,14 @@ void xenet_reset(struct net_device *ndev
 		 * can safely ignore the return values.  We cast them to void
 		 * to make that explicit.
 		 */
-		(void) XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
-					     &SendThreshold);
-		(void) XEmac_GetPktWaitBound(&lp->Emac, XEM_SEND,
-					     &SendWaitBound);
-		(void) XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
-					     &RecvThreshold);
-		(void) XEmac_GetPktWaitBound(&lp->Emac, XEM_RECV,
-					     &RecvWaitBound);
+		(void)XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
+					    &SendThreshold);
+		(void)XEmac_GetPktWaitBound(&lp->Emac, XEM_SEND,
+					    &SendWaitBound);
+		(void)XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
+					    &RecvThreshold);
+		(void)XEmac_GetPktWaitBound(&lp->Emac, XEM_RECV,
+					    &RecvWaitBound);
 	}
 
 	XEmac_Reset(&lp->Emac);
@@ -119,9 +107,9 @@ void xenet_reset(struct net_device *ndev
 	 * XEmac_Reset() so we can safely ignore the return values.
 	 * We cast them to void to make that explicit.
 	 */
-	(void) XEmac_SetMacAddress(&lp->Emac, ndev->dev_addr);
-	(void) XEmac_SetInterframeGap(&lp->Emac, IfgPart1, IfgPart2);
-	(void) XEmac_SetOptions(&lp->Emac, Options);
+	(void)XEmac_SetMacAddress(&lp->Emac, ndev->dev_addr);
+	(void)XEmac_SetInterframeGap(&lp->Emac, IfgPart1, IfgPart2);
+	(void)XEmac_SetOptions(&lp->Emac, Options);
 	if (XEmac_mIsSgDma(&lp->Emac)) {
 		/*
 		 * The following four functions will return an error if
@@ -131,14 +119,10 @@ void xenet_reset(struct net_device *ndev
 		 * we can safely ignore the return values.  We cast them
 		 * to void to make that explicit.
 		 */
-		(void) XEmac_SetPktThreshold(&lp->Emac, XEM_SEND,
-					     SendThreshold);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
-					     SendWaitBound);
-		(void) XEmac_SetPktThreshold(&lp->Emac, XEM_RECV,
-					     RecvThreshold);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
-					     RecvWaitBound);
+		(void)XEmac_SetPktThreshold(&lp->Emac, XEM_SEND, SendThreshold);
+		(void)XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND, SendWaitBound);
+		(void)XEmac_SetPktThreshold(&lp->Emac, XEM_RECV, RecvThreshold);
+		(void)XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV, RecvWaitBound);
 	}
 
 	/*
@@ -147,7 +131,7 @@ void xenet_reset(struct net_device *ndev
 	 * missing.  None of these can happen at this point, so we cast the
 	 * return to void to make that explicit.
 	 */
-	(void) XEmac_Start(&lp->Emac);
+	(void)XEmac_Start(&lp->Emac);
 
 	/* Make sure that the send handler and we don't both free the skb. */
 	spin_lock_irqsave(&lp->skb_lock, flags);
@@ -239,7 +223,7 @@ static int get_phy_status(struct net_dev
  */
 static void poll_mii(unsigned long data)
 {
-	struct net_device *ndev = (struct net_device *) data;
+	struct net_device *ndev = (struct net_device *)data;
 	struct net_local *lp = netdev_priv(ndev);
 	u32 Options;
 	unsigned long flags;
@@ -276,7 +260,8 @@ static void poll_mii(unsigned long data)
 			       ndev->name);
 			netif_carrier_on(ndev);
 		} else {
-			printk(KERN_INFO "%s: Link carrier lost.\n", ndev->name);
+			printk(KERN_INFO "%s: Link carrier lost.\n",
+			       ndev->name);
 			netif_carrier_off(ndev);
 		}
 	}
@@ -309,7 +294,7 @@ static void xenet_tx_timeout(struct net_
  */
 static void ErrorHandler(void *CallbackRef, XStatus Code)
 {
-	struct net_device *ndev = (struct net_device *) CallbackRef;
+	struct net_device *ndev = (struct net_device *)CallbackRef;
 	int need_reset;
 	need_reset = status_requires_reset(Code);
 
@@ -330,7 +315,7 @@ static void ErrorHandler(void *CallbackR
  */
 static irqreturn_t xenet_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	struct net_device *ndev = (struct net_device *) dev_id;
+	struct net_device *ndev = (struct net_device *)dev_id;
 	struct net_local *lp = netdev_priv(ndev);
 
 	/* Call it. */
@@ -355,7 +340,7 @@ static int xenet_open(struct net_device 
 	 * stopped, an error will be returned.  In this case, we don't really
 	 * care, so cast it to void to make it explicit.
 	 */
-	(void) XEmac_Stop(&lp->Emac);
+	(void)XEmac_Stop(&lp->Emac);
 
 	/* Set the MAC address each time opened. */
 	if (XEmac_SetMacAddress(&lp->Emac, ndev->dev_addr) != XST_SUCCESS) {
@@ -374,7 +359,8 @@ static int xenet_open(struct net_device 
 		int retval;
 		/* Grab the IRQ */
 		retval =
-		    request_irq(ndev->irq, &xenet_interrupt, 0, ndev->name, ndev);
+		    request_irq(ndev->irq, &xenet_interrupt, 0, ndev->name,
+				ndev);
 		if (retval) {
 			printk(KERN_ERR
 			       "%s: Could not allocate interrupt %d.\n",
@@ -390,9 +376,14 @@ static int xenet_open(struct net_device 
 			      ? FULL_DUPLEX : HALF_DUPLEX);
 		if (mac_duplex != phy_duplex) {
 			switch (phy_duplex) {
-			case HALF_DUPLEX: Options &= ~XEM_FDUPLEX_OPTION; break;
-			case FULL_DUPLEX: Options |=  XEM_FDUPLEX_OPTION; break;
-			case UNKNOWN_DUPLEX: break;
+			case HALF_DUPLEX:
+				Options &= ~XEM_FDUPLEX_OPTION;
+				break;
+			case FULL_DUPLEX:
+				Options |= XEM_FDUPLEX_OPTION;
+				break;
+			case UNKNOWN_DUPLEX:
+				break;
 			}
 		}
 	}
@@ -401,8 +392,7 @@ static int xenet_open(struct net_device 
 	 * started.  We know it isn't started so we can safely ignore the
 	 * return value.  We cast it to void to make that explicit.
 	 */
-	(void) XEmac_SetOptions(&lp->Emac, Options | XEM_FLOW_CONTROL_OPTION);
-
+	(void)XEmac_SetOptions(&lp->Emac, Options | XEM_FLOW_CONTROL_OPTION);
 
 	if (XEmac_Start(&lp->Emac) != XST_SUCCESS) {
 		printk(KERN_ERR "%s: Could not start device.\n", ndev->name);
@@ -414,7 +404,7 @@ static int xenet_open(struct net_device 
 	netif_start_queue(ndev);
 
 	/* Set up the PHY monitoring timer. */
-	lp->phy_timer.expires = jiffies + 2*HZ;
+	lp->phy_timer.expires = jiffies + 2 * HZ;
 	lp->phy_timer.data = (unsigned long)ndev;
 	lp->phy_timer.function = &poll_mii;
 	add_timer(&lp->phy_timer);
@@ -447,7 +437,7 @@ static int xenet_close(struct net_device
 	return 0;
 }
 
-static struct net_device_stats * xenet_get_stats(struct net_device *ndev)
+static struct net_device_stats *xenet_get_stats(struct net_device *ndev)
 {
 	struct net_local *lp = netdev_priv(ndev);
 	return &lp->net_stats;
@@ -485,7 +475,7 @@ static void xenet_set_multicast_list(str
 	 * stopped, but in this case we don't care so cast it to void
 	 * to make it explicit
 	 */
-	(void) XEmac_Stop(&lp->Emac);
+	(void)XEmac_Stop(&lp->Emac);
 
 	Options = XEmac_GetOptions(&lp->Emac);
 
@@ -523,7 +513,7 @@ static void xenet_set_multicast_list(str
 	 * started.  We know it isn't started so we can safely ignore the
 	 * return value.  We cast it to void to make that explicit.
 	 */
-	(void) XEmac_SetOptions(&lp->Emac, Options);
+	(void)XEmac_SetOptions(&lp->Emac, Options);
 
 	/*
 	 * XEmac_Start returns an error when: it is already started, the send
@@ -531,17 +521,18 @@ static void xenet_set_multicast_list(str
 	 * missing.  None of these can happen at this point, so we cast the
 	 * return to void to make that explicit.
 	 */
-	(void) XEmac_Start(&lp->Emac);
+	(void)XEmac_Start(&lp->Emac);
 
 	/* All done, get those interrupts and timers going again. */
 	local_bh_enable();
 	enable_irq(ndev->irq);
 }
 
-static int xenet_ethtool_get_settings (struct net_device *dev, struct ethtool_cmd* ecmd)
+static int xenet_ethtool_get_settings(struct net_device *dev,
+				      struct ethtool_cmd *ecmd)
 {
 	int ret;
-	struct net_local *lp = (struct net_local *) dev->priv;
+	struct net_local *lp = (struct net_local *)dev->priv;
 	u32 mac_options;
 	u8 threshold;
 	u16 mii_cmd;
@@ -549,8 +540,8 @@ static int xenet_ethtool_get_settings (s
 	u16 mii_advControl;
 	XStatus xs;
 
-	memset (ecmd, 0, sizeof(struct ethtool_cmd));
-	mac_options = XEmac_GetOptions (&(lp->Emac));
+	memset(ecmd, 0, sizeof(struct ethtool_cmd));
+	mac_options = XEmac_GetOptions(&(lp->Emac));
 	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_BMCR, &mii_cmd);
 	if (xs != XST_SUCCESS) {
 		printk(KERN_ERR
@@ -565,7 +556,8 @@ static int xenet_ethtool_get_settings (s
 		       dev->name, xs);
 		return -1;
 	}
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_ADVERTISE, &mii_advControl);
+	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_ADVERTISE,
+			   &mii_advControl);
 	if (xs != XST_SUCCESS) {
 		printk(KERN_ERR
 		       "%s: Could not read mii advertisement control register; error %d\n",
@@ -585,13 +577,14 @@ static int xenet_ethtool_get_settings (s
 		ecmd->supported |= SUPPORTED_10baseT_Full;
 	if (mii_status & BMSR_10HALF)
 		ecmd->supported |= SUPPORTED_10baseT_Half;
-		ecmd->supported |= SUPPORTED_MII;
+	ecmd->supported |= SUPPORTED_MII;
 	if (mii_status & BMSR_ANEGCAPABLE)
 		ecmd->supported |= SUPPORTED_Autoneg;
 	if (mii_status & BMSR_ANEGCOMPLETE) {
 		ecmd->autoneg = AUTONEG_ENABLE;
 		ecmd->advertising |= ADVERTISED_Autoneg;
-		if ((mii_advControl & ADVERTISE_100FULL) || (mii_advControl & ADVERTISE_100HALF))
+		if ((mii_advControl & ADVERTISE_100FULL)
+		    || (mii_advControl & ADVERTISE_100HALF))
 			ecmd->speed = SPEED_100;
 		else
 			ecmd->speed = SPEED_10;
@@ -615,11 +608,15 @@ static int xenet_ethtool_get_settings (s
 	ecmd->phy_address = lp->Emac.PhysAddress;
 	ecmd->transceiver = XCVR_INTERNAL;
 	if (XEmac_mIsSgDma(&lp->Emac)) {
-		if ((ret = XEmac_GetPktThreshold(&lp->Emac, XEM_SEND, &threshold)) == XST_SUCCESS) {
+		if ((ret =
+		     XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
+					   &threshold)) == XST_SUCCESS) {
 			ecmd->maxtxpkt = threshold;
 		} else
 			return -EIO;
-		if ((ret = XEmac_GetPktThreshold(&lp->Emac, XEM_RECV, &threshold)) == XST_SUCCESS) {
+		if ((ret =
+		     XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
+					   &threshold)) == XST_SUCCESS) {
 			ecmd->maxrxpkt = threshold;
 		} else
 			return -EIO;
@@ -627,66 +624,86 @@ static int xenet_ethtool_get_settings (s
 	return 0;
 }
 
-static int xenet_ethtool_get_coalesce (struct net_device *dev, struct ethtool_coalesce* ec)
+static int xenet_ethtool_get_coalesce(struct net_device *dev,
+				      struct ethtool_coalesce *ec)
 {
 	int ret;
-	struct net_local *lp = (struct net_local *) dev->priv;
+	struct net_local *lp = (struct net_local *)dev->priv;
 	u8 threshold;
 
-	memset (ec, 0, sizeof(struct ethtool_coalesce));
-	if ((ret = XEmac_GetPktThreshold(&lp->Emac, XEM_RECV, &threshold)) != XST_SUCCESS) {
+	memset(ec, 0, sizeof(struct ethtool_coalesce));
+	if ((ret =
+	     XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
+				   &threshold)) != XST_SUCCESS) {
 		printk(KERN_INFO "XEmac_GetPktThreshold error %d\n", ret);
 		return -EIO;
 	}
 	ec->rx_max_coalesced_frames = threshold;
-	if ((ret = XEmac_GetPktWaitBound (&lp->Emac, XEM_RECV, &(ec->rx_coalesce_usecs))) != XST_SUCCESS) {
-		printk (KERN_INFO "XEmac_GetPktWaitBound error %d\n", ret);
+	if ((ret =
+	     XEmac_GetPktWaitBound(&lp->Emac, XEM_RECV,
+				   &(ec->rx_coalesce_usecs))) != XST_SUCCESS) {
+		printk(KERN_INFO "XEmac_GetPktWaitBound error %d\n", ret);
 		return -EIO;
 	}
-	if ((ret = XEmac_GetPktThreshold(&lp->Emac, XEM_SEND, &threshold)) != XST_SUCCESS) {
-		printk (KERN_INFO "XEmac_GetPktThreshold send error %d\n", ret);
+	if ((ret =
+	     XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
+				   &threshold)) != XST_SUCCESS) {
+		printk(KERN_INFO "XEmac_GetPktThreshold send error %d\n", ret);
 		return -EIO;
 	}
-	ec->tx_max_coalesced_frames = threshold; 
-	if ((ret = XEmac_GetPktWaitBound (&lp->Emac, XEM_SEND, &(ec->tx_coalesce_usecs))) != XST_SUCCESS) {
-		printk (KERN_INFO "XEmac_GetPktWaitBound send error %d\n", ret);
+	ec->tx_max_coalesced_frames = threshold;
+	if ((ret =
+	     XEmac_GetPktWaitBound(&lp->Emac, XEM_SEND,
+				   &(ec->tx_coalesce_usecs))) != XST_SUCCESS) {
+		printk(KERN_INFO "XEmac_GetPktWaitBound send error %d\n", ret);
 		return -EIO;
 	}
 	return 0;
 }
 
-static int xenet_ethtool_set_coalesce (struct net_device *dev, struct ethtool_coalesce* ec)
+static int xenet_ethtool_set_coalesce(struct net_device *dev,
+				      struct ethtool_coalesce *ec)
 {
 	int ret;
-	struct net_local *lp = (struct net_local *) dev->priv;
+	struct net_local *lp = (struct net_local *)dev->priv;
 	unsigned long flags;
 
 	spin_lock_irqsave(&XE_spinlock, flags);
-	if ((ret = XEmac_Stop(&lp->Emac)) != XST_SUCCESS){
+	if ((ret = XEmac_Stop(&lp->Emac)) != XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
 		return -EIO;
 	}
-	if ((ret = XEmac_SetPktThreshold(&lp->Emac, XEM_RECV, ec->rx_max_coalesced_frames)) != XST_SUCCESS) {
+	if ((ret =
+	     XEmac_SetPktThreshold(&lp->Emac, XEM_RECV,
+				   ec->rx_max_coalesced_frames)) !=
+	    XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
-		printk (KERN_INFO "XEmac_SetPktThreshold error %d\n", ret);
+		printk(KERN_INFO "XEmac_SetPktThreshold error %d\n", ret);
 		return -EIO;
-	} 
-	if ((ret = XEmac_SetPktWaitBound (&lp->Emac, XEM_RECV, ec->rx_coalesce_usecs)) != XST_SUCCESS) {
+	}
+	if ((ret =
+	     XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
+				   ec->rx_coalesce_usecs)) != XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
-		printk (KERN_INFO "XEmac_SetPktWaitBound error %d\n", ret);
+		printk(KERN_INFO "XEmac_SetPktWaitBound error %d\n", ret);
 		return -EIO;
 	}
-	if ((ret = XEmac_SetPktThreshold(&lp->Emac, XEM_SEND, ec->tx_max_coalesced_frames)) != XST_SUCCESS) {
+	if ((ret =
+	     XEmac_SetPktThreshold(&lp->Emac, XEM_SEND,
+				   ec->tx_max_coalesced_frames)) !=
+	    XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
-		printk (KERN_INFO "XEmac_SetPktThreshold send error %d\n", ret);
+		printk(KERN_INFO "XEmac_SetPktThreshold send error %d\n", ret);
 		return -EIO;
-	} 
-	if ((ret = XEmac_SetPktWaitBound (&lp->Emac, XEM_SEND, ec->tx_coalesce_usecs)) != XST_SUCCESS) {
+	}
+	if ((ret =
+	     XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
+				   ec->tx_coalesce_usecs)) != XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
-		printk (KERN_INFO "XEmac_SetPktWaitBound send error %d\n", ret);
+		printk(KERN_INFO "XEmac_SetPktWaitBound send error %d\n", ret);
 		return -EIO;
 	}
-	if ((ret = XEmac_Start(&lp->Emac)) != XST_SUCCESS){
+	if ((ret = XEmac_Start(&lp->Emac)) != XST_SUCCESS) {
 		spin_unlock_irqrestore(&XE_spinlock, flags);
 		return -EIO;
 	}
@@ -694,17 +711,19 @@ static int xenet_ethtool_set_coalesce (s
 	return 0;
 }
 
-static int xenet_ethtool_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo* ed)
+static int xenet_ethtool_get_drvinfo(struct net_device *dev,
+				     struct ethtool_drvinfo *ed)
 {
-	memset (ed, 0, sizeof(struct ethtool_drvinfo));
-	strcpy (ed->driver, DRIVER_NAME);
-	strcpy (ed->version, DRIVER_VERSION);
-	return 0; 
+	memset(ed, 0, sizeof(struct ethtool_drvinfo));
+	strcpy(ed->driver, DRIVER_NAME);
+	strcpy(ed->version, DRIVER_VERSION);
+	return 0;
 }
 
-static int xenet_ethtool_get_ringparam (struct net_device *dev, struct ethtool_ringparam* erp)
+static int xenet_ethtool_get_ringparam(struct net_device *dev,
+				       struct ethtool_ringparam *erp)
 {
-	memset (erp, 0, sizeof(struct ethtool_ringparam));
+	memset(erp, 0, sizeof(struct ethtool_ringparam));
 	erp->rx_max_pending = XEM_DFT_RECV_DESC;
 	erp->tx_max_pending = XEM_DFT_SEND_DESC;
 	erp->rx_pending = XEM_DFT_RECV_DESC;
@@ -718,28 +737,31 @@ struct mac_regsDump {
 	u16 data[EMAG_REGS_N];
 };
 
-static void xenet_ethtool_get_regs (struct net_device *dev, struct ethtool_regs* regs, void* ret)
+static void xenet_ethtool_get_regs(struct net_device *dev,
+				   struct ethtool_regs *regs, void *ret)
 {
-	struct net_local *lp = (struct net_local *) dev->priv;
-	struct mac_regsDump* dump = (struct mac_regsDump*)regs;
+	struct net_local *lp = (struct net_local *)dev->priv;
+	struct mac_regsDump *dump = (struct mac_regsDump *)regs;
 	int i;
 	XStatus r;
 
 	dump->hd.version = 0;
 	dump->hd.len = EMAG_REGS_N * sizeof(dump->data);
-	for (i=0; i<EMAG_REGS_N; i++) {
-		if ((r = XEmac_PhyRead (&(lp->Emac), lp->mii_addr, i, &(dump->data[i]))) != XST_SUCCESS) {
-			printk (KERN_INFO "PhyRead ERROR %d\n", r);
-			*(int*)ret = -EIO;
+	for (i = 0; i < EMAG_REGS_N; i++) {
+		if ((r =
+		     XEmac_PhyRead(&(lp->Emac), lp->mii_addr, i,
+				   &(dump->data[i]))) != XST_SUCCESS) {
+			printk(KERN_INFO "PhyRead ERROR %d\n", r);
+			*(int *)ret = -EIO;
 			return;
 		}
 	}
-	*(int*)ret = 0;
+	*(int *)ret = 0;
 }
 
-static int xenet_do_ethtool_ioctl (struct net_device *dev, struct ifreq *rq)
+static int xenet_do_ethtool_ioctl(struct net_device *dev, struct ifreq *rq)
 {
-	struct net_local *lp = (struct net_local *) dev->priv;
+	struct net_local *lp = (struct net_local *)dev->priv;
 	struct ethtool_cmd ecmd;
 	struct ethtool_coalesce eco;
 	struct ethtool_drvinfo edrv;
@@ -754,18 +776,19 @@ static int xenet_do_ethtool_ioctl (struc
 	u16 mii_reg_autoneg;
 	u32 flags;
 
-	if (copy_from_user(&ecmd, rq->ifr_data, sizeof (ecmd.cmd)))
+	if (copy_from_user(&ecmd, rq->ifr_data, sizeof(ecmd.cmd)))
 		return -EFAULT;
 	switch (ecmd.cmd) {
 	case ETHTOOL_GSET:
 		ret = xenet_ethtool_get_settings(dev, &ecmd);
 		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &ecmd, sizeof (ecmd)))
+			if (copy_to_user(rq->ifr_data, &ecmd, sizeof(ecmd)))
 				ret = -EFAULT;
 		}
 		break;
 	case ETHTOOL_SSET:
-		if (copy_from_user(&ecmd, rq->ifr_data, sizeof (struct ethtool_cmd)))
+		if (copy_from_user
+		    (&ecmd, rq->ifr_data, sizeof(struct ethtool_cmd)))
 			return -EFAULT;
 		mii_reg_sset = 0;
 		if (ecmd.speed == SPEED_100)
@@ -782,7 +805,9 @@ static int xenet_do_ethtool_ioctl (struc
 				ret = -EIO;
 				break;
 			}
-			result = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_ADVERTISE, &mii_reg_sset);
+			result =
+			    XEmac_PhyRead(&lp->Emac, lp->mii_addr,
+					  MII_ADVERTISE, &mii_reg_sset);
 			if (result != XST_SUCCESS) {
 				spin_unlock_irqrestore(&XE_spinlock, flags);
 				ret = -EIO;
@@ -790,22 +815,38 @@ static int xenet_do_ethtool_ioctl (struc
 			}
 			if (ecmd.speed == SPEED_100) {
 				if (ecmd.duplex == DUPLEX_FULL) {
-					mii_reg_sset |= (ADVERTISE_10FULL | ADVERTISE_100FULL |
-						ADVERTISE_10HALF | ADVERTISE_100HALF);
+					mii_reg_sset |=
+					    (ADVERTISE_10FULL |
+					     ADVERTISE_100FULL |
+					     ADVERTISE_10HALF |
+					     ADVERTISE_100HALF);
 				} else {
-					mii_reg_sset |= (ADVERTISE_10HALF | ADVERTISE_100HALF);
-					mii_reg_sset &= ~(ADVERTISE_10FULL | ADVERTISE_100FULL);
+					mii_reg_sset |=
+					    (ADVERTISE_10HALF |
+					     ADVERTISE_100HALF);
+					mii_reg_sset &=
+					    ~(ADVERTISE_10FULL |
+					      ADVERTISE_100FULL);
 				}
 			} else {
 				if (ecmd.duplex == DUPLEX_FULL) {
-					mii_reg_sset |= (ADVERTISE_10FULL | ADVERTISE_10HALF);
-					mii_reg_sset &= ~(ADVERTISE_100FULL| ADVERTISE_100HALF);
+					mii_reg_sset |=
+					    (ADVERTISE_10FULL |
+					     ADVERTISE_10HALF);
+					mii_reg_sset &=
+					    ~(ADVERTISE_100FULL |
+					      ADVERTISE_100HALF);
 				} else {
 					mii_reg_sset |= (ADVERTISE_10HALF);
-					mii_reg_sset &= ~(ADVERTISE_100FULL| ADVERTISE_100HALF | ADVERTISE_10FULL);
+					mii_reg_sset &=
+					    ~(ADVERTISE_100FULL |
+					      ADVERTISE_100HALF |
+					      ADVERTISE_10FULL);
 				}
 			}
-			result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr, MII_ADVERTISE, mii_reg_sset);
+			result =
+			    XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
+					   MII_ADVERTISE, mii_reg_sset);
 			spin_unlock_irqrestore(&XE_spinlock, flags);
 			if (result != XST_SUCCESS) {
 				ret = -EIO;
@@ -849,13 +890,15 @@ static int xenet_do_ethtool_ioctl (struc
 			epp.rx_pause = 0;
 			epp.tx_pause = 0;
 		}
-		if (copy_to_user(rq->ifr_data, &epp, sizeof(struct ethtool_pauseparam)))
+		if (copy_to_user
+		    (rq->ifr_data, &epp, sizeof(struct ethtool_pauseparam)))
 			ret = -EFAULT;
 		else
 			ret = 0;
 		break;
 	case ETHTOOL_SPAUSEPARAM:
-		if (copy_from_user(&epp, rq->ifr_data, sizeof (struct ethtool_pauseparam)))
+		if (copy_from_user
+		    (&epp, rq->ifr_data, sizeof(struct ethtool_pauseparam)))
 			return -EFAULT;
 		ret = xenet_ethtool_get_settings(dev, &ecmd);
 		if (ret < 0) {
@@ -890,7 +933,7 @@ static int xenet_do_ethtool_ioctl (struc
 				Options |= XEM_INSERT_PAD_OPTION;
 			else
 				Options &= ~XEM_INSERT_PAD_OPTION;
-			(void)XEmac_SetOptions(&lp->Emac,Options);
+			(void)XEmac_SetOptions(&lp->Emac, Options);
 			(void)XEmac_Start(&(lp->Emac));
 			spin_unlock_irqrestore(&XE_spinlock, flags);
 		}
@@ -900,12 +943,15 @@ static int xenet_do_ethtool_ioctl (struc
 		eco.cmd = ecmd.cmd;
 		ret = xenet_ethtool_get_coalesce(dev, &eco);
 		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &eco, sizeof (struct ethtool_coalesce)))
+			if (copy_to_user
+			    (rq->ifr_data, &eco,
+			     sizeof(struct ethtool_coalesce)))
 				ret = -EFAULT;
 		}
 		break;
 	case ETHTOOL_SCOALESCE:
-		if (copy_from_user(&eco, rq->ifr_data, sizeof (struct ethtool_coalesce)))
+		if (copy_from_user
+		    (&eco, rq->ifr_data, sizeof(struct ethtool_coalesce)))
 			return -EFAULT;
 		ret = xenet_ethtool_set_coalesce(dev, &eco);
 		break;
@@ -913,23 +959,28 @@ static int xenet_do_ethtool_ioctl (struc
 		edrv.cmd = edrv.cmd;
 		ret = xenet_ethtool_get_drvinfo(dev, &edrv);
 		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &edrv, sizeof (struct ethtool_drvinfo)))
+			if (copy_to_user
+			    (rq->ifr_data, &edrv,
+			     sizeof(struct ethtool_drvinfo)))
 				ret = -EFAULT;
 		}
 		break;
 	case ETHTOOL_GREGS:
 		regs.hd.cmd = edrv.cmd;
-		xenet_ethtool_get_regs (dev, &(regs.hd), &ret);
+		xenet_ethtool_get_regs(dev, &(regs.hd), &ret);
 		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &regs, sizeof (struct mac_regsDump)))
+			if (copy_to_user
+			    (rq->ifr_data, &regs, sizeof(struct mac_regsDump)))
 				ret = -EFAULT;
 		}
 		break;
 	case ETHTOOL_GRINGPARAM:
 		erp.cmd = edrv.cmd;
-		ret = xenet_ethtool_get_ringparam (dev, &(erp));
+		ret = xenet_ethtool_get_ringparam(dev, &(erp));
 		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &erp, sizeof (struct ethtool_ringparam)))
+			if (copy_to_user
+			    (rq->ifr_data, &erp,
+			     sizeof(struct ethtool_ringparam)))
 				ret = -EFAULT;
 		}
 		break;
@@ -957,13 +1008,13 @@ static int xenet_ioctl(struct net_device
 {
 	struct net_local *lp = netdev_priv(ndev);
 	/* mii_ioctl_data has 4 u16 fields: phy_id, reg_num, val_in & val_out */
-	struct mii_ioctl_data *data = (struct mii_ioctl_data *) &ifr->ifr_data;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
 
 	XStatus Result;
 
 	switch (cmd) {
 	case SIOCETHTOOL:
-		return xenet_do_ethtool_ioctl(ndev, ifr);	
+		return xenet_do_ethtool_ioctl(ndev, ifr);
 	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
 		data->phy_id = lp->mii_addr;
 		/* Fall Through */
@@ -977,7 +1028,7 @@ static int xenet_ioctl(struct net_device
 		Result = XEmac_PhyRead(&lp->Emac, data->phy_id,
 				       data->reg_num, &data->val_out);
 		/* Start the PHY timer up again. */
-		lp->phy_timer.expires = jiffies + 2*HZ;
+		lp->phy_timer.expires = jiffies + 2 * HZ;
 		add_timer(&lp->phy_timer);
 
 		if (Result != XST_SUCCESS) {
@@ -1000,7 +1051,7 @@ static int xenet_ioctl(struct net_device
 		Result = XEmac_PhyWrite(&lp->Emac, data->phy_id,
 					data->reg_num, data->val_in);
 		/* Start the PHY timer up again. */
-		lp->phy_timer.expires = jiffies + 2*HZ;
+		lp->phy_timer.expires = jiffies + 2 * HZ;
 		add_timer(&lp->phy_timer);
 
 		if (Result != XST_SUCCESS) {
@@ -1024,7 +1075,7 @@ static void xenet_remove_ndev(struct net
 {
 	struct net_local *lp = netdev_priv(ndev);
 
-	iounmap((void *) lp->Emac.BaseAddress);
+	iounmap((void *)lp->Emac.BaseAddress);
 
 	/* Free up the memory. */
 	if (lp->saved_skb)
@@ -1033,11 +1084,11 @@ static void xenet_remove_ndev(struct net
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
-static void xenet_netpoll (struct net_device *netdev)
+static void xenet_netpoll(struct net_device *netdev)
 {
 	unsigned long flags;
 	spin_lock_irqsave(&XE_spinlock, flags);
-	xenet_interrupt(netdev->irq, netdev, NULL );
+	xenet_interrupt(netdev->irq, netdev, NULL);
 	spin_unlock_irqrestore(&XE_spinlock, flags);
 }
 #endif
@@ -1049,10 +1100,11 @@ static int xenet_probe(struct device *de
 	struct platform_device *pdev = to_platform_device(dev);
 	struct xemac_platform_data *pdata;
 	struct resource *r_irq, *r_mem;
+	XEmac_Config xemac_config;
 	u32 maddr;
 	int retval;
 
-	pdata = (struct xemac_platform_data *) pdev->dev.platform_data;
+	pdata = (struct xemac_platform_data *)pdev->dev.platform_data;
 
 	if (pdata == NULL) {
 		printk(KERN_ERR "xemac %d: Couldn't find platform data.\n",
@@ -1070,10 +1122,10 @@ static int xenet_probe(struct device *de
 	}
 
 	/* Create an ethernet device instance */
-	ndev = alloc_etherdev(sizeof (struct net_local));
+	ndev = alloc_etherdev(sizeof(struct net_local));
 	if (ndev == NULL) {
 		printk(KERN_ERR "xemac %d: Could not allocate net device.\n",
-			pdev->id);
+		       pdev->id);
 		return -ENOMEM;
 	}
 	dev_set_drvdata(dev, ndev);
@@ -1083,27 +1135,22 @@ static int xenet_probe(struct device *de
 	 * The private data are zeroed out by alloc_etherdev() already.
 	 */
 	lp = netdev_priv(ndev);
-	lp->Config.DeviceId = pdev->id;
+	xemac_config.DeviceId = pdev->id;
 	spin_lock_init(&lp->skb_lock);
 	spin_lock_init(&XE_spinlock);
 	init_timer(&lp->phy_timer);
 
 	/* Initialize the rest of the private data */
-	lp->Config.PhysAddress = r_mem->start;
-	lp->Config.BaseAddress = (u32)ioremap(r_mem->start,
-		 			      r_mem->end - r_mem->start + 1);
-	lp->Config.IpIfDmaConfig = pdata->dma_mode;
-	lp->Config.HasCounters = (pdata->device_flags & XEMAC_HAS_ERR_COUNT) ?
-					1 : 0;
-	lp->Config.HasMii = (pdata->device_flags & XEMAC_HAS_MII) ? 1 : 0;
-
-	/* The following line would not be needed if XEmac_Initialize took
-	 * ptr to XEmac_Config instead of DeviceId as the second arg.
-	 */
-	if (lp->Config.DeviceId < XEMAC_MAX_DEVICE_ID)
-		xemac_cfgs[lp->Config.DeviceId] = &lp->Config;
+        xemac_config.PhysAddress = r_mem->start;
+        xemac_config.BaseAddress = (u32)ioremap(r_mem->start,
+                                                r_mem->end - r_mem->start + 1);
+        xemac_config.IpIfDmaConfig = pdata->dma_mode;
+        xemac_config.HasCounters = (pdata->device_flags & XEMAC_HAS_ERR_COUNT) ?
+	    1 : 0;
+	xemac_config.HasMii = (pdata->device_flags & XEMAC_HAS_MII) ? 1 : 0;
 
-	if (XEmac_Initialize(&lp->Emac, lp->Config.DeviceId) != XST_SUCCESS) {
+        if (XEmac_CfgInitialize(&lp->Emac, &xemac_config,
+                                xemac_config.BaseAddress) != XST_SUCCESS) {
 		printk(KERN_ERR "%s: Could not initialize device.\n",
 		       ndev->name);
 		xenet_remove_ndev(ndev);
@@ -1136,10 +1183,10 @@ static int xenet_probe(struct device *de
 				      SGDMA_DEFAULT_THRESHOLD);
 		XEmac_SetPktThreshold(&lp->Emac, XEM_RECV,
 				      SGDMA_DEFAULT_THRESHOLD);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
-					     SGDMA_DEFAULT_WAITBOUND);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
-					     SGDMA_DEFAULT_WAITBOUND);
+		(void)XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
+					    SGDMA_DEFAULT_WAITBOUND);
+		(void)XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
+					    SGDMA_DEFAULT_WAITBOUND);
 
 		/* disable SGEND interrupt */
 		XEmac_SetOptions(&lp->Emac, XEmac_GetOptions(&lp->Emac) |
@@ -1204,8 +1251,8 @@ static int xenet_probe(struct device *de
 
 	printk(KERN_INFO
 	       "%s: Xilinx EMAC #%d at 0x%08X mapped to 0x%08X, irq=%d\n",
-	       ndev->name, lp->Config.DeviceId,
-	       lp->Config.PhysAddress, lp->Config.BaseAddress, ndev->irq);
+               ndev->name, xemac_config.DeviceId,
+               xemac_config.PhysAddress, xemac_config.BaseAddress, ndev->irq);
 	return 0;
 }
 
@@ -1216,16 +1263,15 @@ static int xenet_remove(struct device *d
 	unregister_netdev(ndev);
 	xenet_remove_ndev(ndev);
 
-	return 0;	/* success */
+	return 0;		/* success */
 }
 
-
 static struct device_driver xenet_driver = {
-	.name		= DRIVER_NAME,
-	.bus		= &platform_bus_type,
+	.name = DRIVER_NAME,
+	.bus = &platform_bus_type,
 
-	.probe		= xenet_probe,
-	.remove		= xenet_remove
+	.probe = xenet_probe,
+	.remove = xenet_remove
 };
 
 static int __init xenet_init(void)
Index: linux-2.6.10/drivers/net/xilinx_emac/adapter.h
===================================================================
--- linux-2.6.10.orig/drivers/net/xilinx_emac/adapter.h
+++ linux-2.6.10/drivers/net/xilinx_emac/adapter.h
@@ -77,15 +77,6 @@ struct net_local {
 	 * reference any of the fields inside of the structure).
 	 */
 	XEmac Emac;
-	/*
-	 * Currently XEmac has a pointer to XEmac_Config structure.
-	 * This pointer is used not only by XEmac_Initialize(), but
-	 * by XEmac_mIsSgDma() et al as well. For this reason the
-	 * XEmac_Config structure must exist as long as the device
-	 * is alive. Otherwise we could drop this structure right
-	 * after XEmac_Initialize() returns.
-	 */
-	XEmac_Config Config;
 
 	/*
 	 * SGDMA stuff
Index: linux-2.6.10/mvl_patches/pro-0650.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0650.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(650);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

