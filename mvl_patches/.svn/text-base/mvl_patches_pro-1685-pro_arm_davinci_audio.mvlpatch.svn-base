#! /usr/bin/env bash
# Patch: -pro_arm_davinci_audio
# Date: Mon Jan 21 23:06:44 2008
# Source: MontaVista Software, Inc.
# MR: 25659
# Type: Enhancement
# Disposition: local
# Signed-off-by: Jerry Alexander <jalexander@mvista.com>
# Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
# Description:
#         1) Added McBSP support for DM355 SoC
#         2) Added McASP interface support for DM646x SoC
#         3) Added Audio OSS support for Davinci DM646x SoC
#         4) Added Audio OSS support for Davicni DM355 SoC
#         5) moved existant DM644x Audio OSS support from sound/oss/
#            to sound/oss/dm644x/
#         6) Added AIC32 codec support
#         7) Modified AIC33 codec to support McASP.
# 
#  arch/arm/mach-davinci/mcasp.c                       | 1303 ++++++++++++++++++++
#  arch/arm/mach-davinci/mcbsp.c                       |  147 +-
#  include/asm-arm/arch-davinci/davinci-audio-config.h |   48 
#  include/asm-arm/arch-davinci/evm_audio_info.h       |  209 +++
#  include/asm-arm/arch-davinci/mcasp.h                |  343 +++++
#  include/asm-arm/arch-davinci/mcbsp.h                |    6 
#  sound/oss/Kconfig                                   |   36 
#  sound/oss/Makefile                                  |    5 
#  sound/oss/davinci-aic33.h                           |  246 ---
#  sound/oss/davinci-audio-aic33.c                     | 1101 ----------------
#  sound/oss/davinci-audio-dma-intfc.c                 | 1041 ---------------
#  sound/oss/davinci-audio-dma-intfc.h                 |   63 
#  sound/oss/davinci-audio.c                           | 1195 ------------------
#  sound/oss/davinci-audio.h                           |  117 -
#  sound/oss/dm644x/Kconfig                            |   32 
#  sound/oss/dm644x/Makefile                           |    7 
#  sound/oss/dm644x/davinci-aic33.h                    |  249 +++
#  sound/oss/dm644x/davinci-audio-aic33.c              | 1171 +++++++++++++++++
#  sound/oss/dm644x/davinci-audio-dma-intfc.c          | 1147 +++++++++++++++++
#  sound/oss/dm644x/davinci-audio-dma-intfc.h          |   67 +
#  sound/oss/dm644x/davinci-audio.c                    | 1213 ++++++++++++++++++
#  sound/oss/dm644x/davinci-audio.h                    |  122 +
#  sound/oss/dm646x/Kconfig                            |   22 
#  sound/oss/dm646x/Makefile                           |    5 
#  sound/oss/dm646x/audio_controller.c                 | 1221 ++++++++++++++++++
#  sound/oss/dm646x/audio_controller.h                 |  129 +
#  sound/oss/dm646x/davinci-aic32.h                    |  250 +++
#  sound/oss/dm646x/davinci-audio-aic32.c              |  956 ++++++++++++++
#  sound/oss/dm646x/davinci-audio-dma-intfc.c          | 1164 +++++++++++++++++
#  sound/oss/dm646x/davinci-audio-dma-intfc.h          |   70 +
#  sound/oss/dm646x/evm_audio_info.c                   |  372 +++++
#  31 files changed, 10224 insertions(+), 3833 deletions(-)
# 

PATCHNUM=1685
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 25659
Type: Enhancement
Disposition: local
Signed-off-by: Jerry Alexander <jalexander@mvista.com>
Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
Description:
        1) Added McBSP support for DM355 SoC
        2) Added McASP interface support for DM646x SoC
        3) Added Audio OSS support for Davinci DM646x SoC
        4) Added Audio OSS support for Davicni DM355 SoC
        5) moved existant DM644x Audio OSS support from sound/oss/
           to sound/oss/dm644x/
        6) Added AIC32 codec support
        7) Modified AIC33 codec to support McASP.

 arch/arm/mach-davinci/mcasp.c                       | 1303 ++++++++++++++++++++
 arch/arm/mach-davinci/mcbsp.c                       |  147 +-
 include/asm-arm/arch-davinci/davinci-audio-config.h |   48 
 include/asm-arm/arch-davinci/evm_audio_info.h       |  209 +++
 include/asm-arm/arch-davinci/mcasp.h                |  343 +++++
 include/asm-arm/arch-davinci/mcbsp.h                |    6 
 mvl_patches/pro-1685.c                              |   16 
 sound/oss/Kconfig                                   |   36 
 sound/oss/Makefile                                  |    5 
 sound/oss/davinci-aic33.h                           |  246 ---
 sound/oss/davinci-audio-aic33.c                     | 1101 ----------------
 sound/oss/davinci-audio-dma-intfc.c                 | 1041 ---------------
 sound/oss/davinci-audio-dma-intfc.h                 |   63 
 sound/oss/davinci-audio.c                           | 1195 ------------------
 sound/oss/davinci-audio.h                           |  117 -
 sound/oss/dm644x/Kconfig                            |   32 
 sound/oss/dm644x/Makefile                           |    7 
 sound/oss/dm644x/davinci-aic33.h                    |  249 +++
 sound/oss/dm644x/davinci-audio-aic33.c              | 1171 +++++++++++++++++
 sound/oss/dm644x/davinci-audio-dma-intfc.c          | 1147 +++++++++++++++++
 sound/oss/dm644x/davinci-audio-dma-intfc.h          |   67 +
 sound/oss/dm644x/davinci-audio.c                    | 1213 ++++++++++++++++++
 sound/oss/dm644x/davinci-audio.h                    |  122 +
 sound/oss/dm646x/Kconfig                            |   22 
 sound/oss/dm646x/Makefile                           |    5 
 sound/oss/dm646x/audio_controller.c                 | 1221 ++++++++++++++++++
 sound/oss/dm646x/audio_controller.h                 |  129 +
 sound/oss/dm646x/davinci-aic32.h                    |  250 +++
 sound/oss/dm646x/davinci-audio-aic32.c              |  956 ++++++++++++++
 sound/oss/dm646x/davinci-audio-dma-intfc.c          | 1164 +++++++++++++++++
 sound/oss/dm646x/davinci-audio-dma-intfc.h          |   70 +
 sound/oss/dm646x/evm_audio_info.c                   |  372 +++++
 32 files changed, 10240 insertions(+), 3833 deletions(-)

Index: linux-2.6.10/arch/arm/mach-davinci/mcbsp.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/mcbsp.c
+++ linux-2.6.10/arch/arm/mach-davinci/mcbsp.c
@@ -30,11 +30,15 @@
 #include <asm/arch/edma.h>
 #include <asm/arch/irqs.h>
 #include <asm/arch/mcbsp.h>
+#include <asm/arch/cpu.h>
 #include <asm/hardware/clock.h>
 
 struct clk *mbspclk = NULL;
+struct clk *mbspclk0 = NULL;
+struct clk *mbspclk1 = NULL;
 
 /* #define CONFIG_MCBSP_DEBUG */
+#define EDMA_EVTMUX (0x01C4001C)
 
 #ifdef CONFIG_MCBSP_DEBUG
 #define DBG(x...)       printk(KERN_INFO x)
@@ -433,8 +437,14 @@ int davinci_mcbsp_xmit_buffer(unsigned i
 	davinci_set_dma_transfer_params(mcbsp[id].dma_tx_lch, 2, length / 2, 1,
 					0, ASYNC);
 
-	davinci_set_dma_dest_params(mcbsp[id].dma_tx_lch,
-				    (unsigned long)0x01E02004, 0, 0);
+	if (!cpu_is_davinci_dm355())
+		davinci_set_dma_dest_params(mcbsp[id].dma_tx_lch,
+				  (unsigned long) (DAVINCI_MCBSP_BASE + 4), 0,
+				  0);
+	else
+		davinci_set_dma_dest_params(mcbsp[id].dma_tx_lch,
+				  (unsigned long) (DAVINCI_MCBSP1_BASE + 4), 0,
+				  0);
 
 	davinci_set_dma_src_params(mcbsp[id].dma_tx_lch, (buffer), 0, 0);
 	davinci_set_dma_src_index(mcbsp[id].dma_tx_lch, 2, 0);
@@ -470,8 +480,12 @@ int davinci_mcbsp_recv_buffer(unsigned i
 	davinci_set_dma_transfer_params(mcbsp[id].dma_rx_lch, 2, length / 2, 1,
 					0, ASYNC);
 
-	davinci_set_dma_src_params(mcbsp[id].dma_rx_lch,
-				   (unsigned long)0x01E02000, 0, 0);
+	if (!cpu_is_davinci_dm355())
+		davinci_set_dma_src_params(mcbsp[id].dma_rx_lch,
+				 (unsigned long) DAVINCI_MCBSP_BASE, 0, 0);
+	else
+		davinci_set_dma_src_params(mcbsp[id].dma_rx_lch,
+				 (unsigned long) DAVINCI_MCBSP1_BASE, 0, 0);
 
 	davinci_set_dma_dest_params(mcbsp[id].dma_rx_lch,
 				    (unsigned long)virt_to_phys((void *)buffer),
@@ -488,7 +502,10 @@ int davinci_mcbsp_recv_buffer(unsigned i
 
 struct clk * davinci_mcbsp_get_clock(void)
 {
-	return mbspclk;
+	if (!cpu_is_davinci_dm355())
+		return mbspclk;
+	else
+		return mbspclk1;
 }
 
 struct davinci_mcbsp_info {
@@ -497,52 +514,102 @@ struct davinci_mcbsp_info {
 	u16 rx_irq, tx_irq;
 };
 
+#ifdef CONFIG_ARCH_DAVINCI_DM355
+static const struct davinci_mcbsp_info mcbsp_davinci[] = {
+	[0] = {.virt_base = IO_ADDRESS(DAVINCI_MCBSP0_BASE),
+	       .dma_rx_sync = DM355_DMA_MCBSP0_RX,
+	       .dma_tx_sync = DM355_DMA_MCBSP0_TX,
+	       .rx_irq = IRQ_MBRINT,
+	       .tx_irq = IRQ_MBXINT},
+	[1] = {.virt_base = IO_ADDRESS(DAVINCI_MCBSP1_BASE),
+	       .dma_rx_sync = DM355_DMA_MCBSP1_RX,
+	       .dma_tx_sync = DM355_DMA_MCBSP1_TX,
+	       .rx_irq = IRQ_MBRINT,
+	       .tx_irq = IRQ_MBXINT},
+};
+#else
 static const struct davinci_mcbsp_info mcbsp_davinci[] = {
-	[0] = {.virt_base = IO_ADDRESS(DAVINCI_MCBSP1_BASE),
-	       .dma_rx_sync = DAVINCI_DMA_MCBSP1_RX,
-	       .dma_tx_sync = DAVINCI_DMA_MCBSP1_TX,
-	       .rx_irq = DAVINCI_McBSP1RX,
-	       .tx_irq = DAVINCI_McBSP1TX},
+	[0] = {.virt_base = IO_ADDRESS(DAVINCI_MCBSP_BASE),
+	       .dma_rx_sync = DAVINCI_DMA_MCBSP_RX,
+	       .dma_tx_sync = DAVINCI_DMA_MCBSP_TX,
+	       .rx_irq = IRQ_MBRINT,
+	       .tx_irq = IRQ_MBXINT},
 };
+#endif
 
 static int __init davinci_mcbsp_init(void)
 {
 	int mcbsp_count = 0, i;
 	static const struct davinci_mcbsp_info *mcbsp_info;
 	struct clk *clkp;
+	struct clk *clkp0, *clkp1;
 
-	clkp = clk_get (NULL, "McBSPCLK0");
-	if (IS_ERR(clkp)) {
-		return -1;
+	if (cpu_is_davinci_dm355()) {
+		/* enable EDMA event for MCBSP1 */
+		__REG(EDMA_EVTMUX) &= ~(0x3);
+
+		clkp0 = clk_get (NULL, "McBSPCLK0");
+	} else {
+		clkp = clk_get (NULL, "McBSPCLK0");
 	}
-	else
-	{
+
+	if (!cpu_is_davinci_dm355()) {
+		if (IS_ERR(clkp)) {
+			return -1;
+		}
+	} else {
+		if (IS_ERR(clkp0)) {
+			printk(KERN_ERR
+			       "mcbsp: could not acquire McBSP0 clk\n");
+			return PTR_ERR(clkp0);
+		}
+	}
+
+	if (!cpu_is_davinci_dm355()) {
 		mbspclk = clkp;
 		clk_use (mbspclk);
 		clk_enable (mbspclk);
+	} else {
+		mbspclk0 = clkp0;
+		clk_use (mbspclk0);
+		clk_enable (mbspclk0);
+	}
+
+	mcbsp_info = mcbsp_davinci;
+	mcbsp_count = ARRAY_SIZE(mcbsp_davinci);
+
+	for (i = 0; i < DAVINCI_MAX_MCBSP_COUNT; i++) {
+		if (i >= mcbsp_count) {
+			mcbsp[i].io_base = 0;
+			mcbsp[i].free = 0;
+			continue;
+		}
+		mcbsp[i].id = i + 1;
+		mcbsp[i].free = 1;
+		mcbsp[i].dma_tx_lch = -1;
+		mcbsp[i].dma_rx_lch = -1;
 
-		mcbsp_info = mcbsp_davinci;
-		mcbsp_count = ARRAY_SIZE(mcbsp_davinci);
+		mcbsp[i].io_base = mcbsp_info[i].virt_base;
+		mcbsp[i].tx_irq = mcbsp_info[i].tx_irq;
+		mcbsp[i].rx_irq = mcbsp_info[i].rx_irq;
+		mcbsp[i].dma_rx_sync = mcbsp_info[i].dma_rx_sync;
+		mcbsp[i].dma_tx_sync = mcbsp_info[i].dma_tx_sync;
+		spin_lock_init(&mcbsp[i].lock);
+	}
 
-		for (i = 0; i < DAVINCI_MAX_MCBSP_COUNT; i++) {
-			if (i >= mcbsp_count) {
-				mcbsp[i].io_base = 0;
-				mcbsp[i].free = 0;
-				continue;
-			}
-			mcbsp[i].id = i + 1;
-			mcbsp[i].free = 1;
-			mcbsp[i].dma_tx_lch = -1;
-			mcbsp[i].dma_rx_lch = -1;
-
-			mcbsp[i].io_base = mcbsp_info[i].virt_base;
-			mcbsp[i].tx_irq = mcbsp_info[i].tx_irq;
-			mcbsp[i].rx_irq = mcbsp_info[i].rx_irq;
-			mcbsp[i].dma_rx_sync = mcbsp_info[i].dma_rx_sync;
-			mcbsp[i].dma_tx_sync = mcbsp_info[i].dma_tx_sync;
-			spin_lock_init(&mcbsp[i].lock);
+	if (cpu_is_davinci_dm355()) {
+		clkp1 = clk_get(NULL, "McBSPCLK1");
+		if (IS_ERR(clkp1)) {
+			printk(KERN_ERR
+			       "mcbsp: could not acquire McBSP1 clk\n");
+			return PTR_ERR(clkp1);
+		} else {
+			mbspclk1 = clkp1;
+			clk_use(mbspclk1);
+			clk_enable(mbspclk1);
 		}
 	}
+
 	return 0;
 }
 
@@ -556,9 +623,15 @@ static void __exit davinci_mcbsp_exit(vo
 		mcbsp[i].dma_rx_lch = -1;
     }
 
-    clk_unuse (mbspclk);
-    clk_disable (mbspclk);
-
+	if (!cpu_is_davinci_dm355()) {
+		clk_unuse (mbspclk);
+		clk_disable (mbspclk);
+	} else {
+		clk_unuse (mbspclk0);
+		clk_unuse (mbspclk1);
+		clk_disable (mbspclk0);
+		clk_disable (mbspclk1);
+	}
 	return;
 }
 
Index: linux-2.6.10/include/asm-arm/arch-davinci/mcbsp.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/mcbsp.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/mcbsp.h
@@ -33,7 +33,6 @@
 #include <asm/arch/hardware.h>
 #include <asm/arch/irqs.h>
 
-#define DAVINCI_MCBSP1_BASE	 DAVINCI_MCBSP_BASE
 #define DAVINCI_DMA_MCBSP1_RX 3
 #define DAVINCI_DMA_MCBSP1_TX 2
 
@@ -73,7 +72,11 @@
 #define XCERG	0x3c
 #define XCERH	0x3e
 
+#ifndef CONFIG_ARCH_DAVINCI_DM355
 #define DAVINCI_MAX_MCBSP_COUNT 1
+#else
+#define DAVINCI_MAX_MCBSP_COUNT 2
+#endif
 
 /********************** McBSP SPCR1 bit definitions ***********************/
 #define RRST			0x0001
@@ -192,6 +195,7 @@ struct davinci_mcbsp_reg_cfg {
 
 typedef enum {
 	DAVINCI_MCBSP1 = 0,
+	DAVINCI_MCBSP2
 } davinci_mcbsp_id;
 
 typedef enum {
Index: linux-2.6.10/arch/arm/mach-davinci/mcasp.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/arm/mach-davinci/mcasp.c
@@ -0,0 +1,1303 @@
+/*
+ * mcasp.c - Interface to Multichannel Audio Serial Port (McASP)
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+
+#include <asm/io.h>
+#include <asm/arch/mcasp.h>
+#include <asm/hardware/clock.h>
+#include <asm/atomic.h>
+
+#include <asm/arch/evm_audio_info.h>
+#include <asm/arch/davinci-audio-config.h>
+
+#define MODULE_NAME   "McASP"
+
+/* Debug levels */
+#define LOW      25
+#define MEDIUM   50
+#define HIGH     75
+#define CRITICAL 100
+
+/* Undefine/define this to disable/enable debugging */
+/* #define McASP_DEBUG */
+
+#ifdef McASP_DEBUG
+static s8 mcasp_debug_level = LOW;
+#define McASP_DEBUG0(format, arg...)	printk(KERN_ALERT MODULE_NAME \
+					       " DEBUG: " format "\n",  ## arg )
+#define McASP_DEBUG1(level, format, arg...)	 do {\
+	if (level <= mcasp_debug_level) {	\
+		printk(KERN_ALERT MODULE_NAME " DEBUG: " \
+		       format "\n",  ## arg );\
+	}} while (0)
+
+#define mcasp_info(format, arg...) printk(KERN_INFO MODULE_NAME " INFO: "\
+					  format "\n",  ## arg )
+#define mcasp_warn(format, arg...) printk(KERN_WARNING MODULE_NAME  \
+					  " WARNING: " format "\n",  ## arg )
+#define mcasp_err(format, arg...) printk(KERN_ERR MODULE_NAME " ERROR: " \
+					 format "\n",  ## arg )
+
+#else				/* McASP_DEBUG */
+#define McASP_DEBUG0(fmt, args...)
+#define McASP_DEBUG1(level, fmt, args...)
+#define mcasp_info(format, arg...)
+#define mcasp_warn(format, arg...)
+#define mcasp_err(format, arg...)
+#endif				/* McASP_DEBUG */
+
+/* Undefine/define this to disable/enable tracing */
+/* #define McASP_TRACE */
+
+#ifdef McASP_TRACE
+
+#define McASP_FN_IN   \
+	printk(KERN_ALERT MODULE_NAME " DEBUG: Entering Function %s\n", \
+		 __FUNCTION__ )
+#define McASP_FN_OUT(retval)  \
+	printk(KERN_ALERT MODULE_NAME \
+		 " DEBUG: Leaving Function %s (Ret = %d)\n", \
+		 __FUNCTION__, retval )
+#define McASP_FN_OUT_ADDR(retval)  \
+	printk(KERN_ALERT MODULE_NAME \
+		 " DEBUG: Leaving Function %s (Ret = %lx)\n", \
+		 __FUNCTION__, (unsigned long)retval )
+#else				/* McASP_TRACE */
+#define McASP_FN_IN
+#define McASP_FN_OUT(retval)
+#define McASP_FN_OUT_ADDR(retval)
+#endif				/* McASP_TRACE */
+
+/* If the McASP unit is in use, just display a warning. The warns the user if
+ * the user calls a function (accidently) which requires the mcasp
+ * to be stopped, which might result in unexpected behaviour of McASP.
+ */
+#define DISPLAY_MCASP_IN_USE_WARNING(id)      do {\
+   if (mcasp_get(id) < 0) { \
+     mcasp_warn ("McASP%d is in use. Hope you know what you are doing!\n", id);\
+   }} while (0)
+
+/* Since the internal clock of is 24MHz on Davinci-HD EVM, only the following
+ * MAX_SAMPLE_RATES sample rates are supported. */
+#define MAX_SAMPLE_RATES 2
+static u32 sample_rates_supported[MAX_SAMPLE_RATES] = { 22050, 44100 };
+
+struct asp_file_operations mcasp_fops = {
+	.init = mcasp_dev_init,
+	.de_init = mcasp_dev_deinit,
+	.configure = mcasp_configure,
+	.unconfigure = mcasp_unconfigure,
+	.configure_reg = mcasp_reg_configure,
+	.start = mcasp_start,
+	.stop = mcasp_stop,
+	.start_tx = mcasp_start_tx,
+	.stop_tx = mcasp_stop_tx,
+	.start_rx = mcasp_start_rx,
+	.stop_rx = mcasp_stop_rx,
+	.get_info = mcasp_get_info,
+	.get_config = mcasp_get_config,
+	.get_clock = mcasp_get_clock,
+	.set_sample_rate = mcasp_set_sample_rate,
+	.get_sample_rate = mcasp_get_sample_rate,
+};
+
+mcasp_device_t *mcasp;
+
+static inline mcasp_unit_t *find_mcasp(u8 mcasp_id)
+{
+	struct list_head *temp;
+	mcasp_unit_t *unit = NULL;
+
+	McASP_FN_IN;
+	if (mcasp == NULL) {
+		mcasp_err("McASP is not initialized\n");
+		return NULL;
+	}
+
+	/* look at the first element */
+	unit = list_entry(mcasp->mcasp_list, struct __mcasp_unit, list);
+	if (unit->info.id == mcasp_id) {
+		return unit;
+	}
+
+	/* go throu the rest of the list */
+	list_for_each(temp, mcasp->mcasp_list) {
+		unit = list_entry(temp, struct __mcasp_unit, list);
+		if (unit->info.id == mcasp_id) {
+			return unit;
+		}
+		unit = NULL;
+	}
+
+	mcasp_err("McASP with ID=%d was not initialized\n", mcasp_id);
+	return unit;
+}
+
+struct clk *mcasp_get_clock(u8 mcasp_id)
+{				/* Change */
+	mcasp_unit_t *mcasp_unit;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return NULL;	/* Unlikely */
+	}
+
+	return mcasp_unit->clock;
+}
+EXPORT_SYMBOL(mcasp_get_clock);
+
+static inline u8 __mcasp_unit_count(void)
+{
+	struct list_head *temp;
+	u8 unit_count = 0;
+
+	McASP_FN_IN;
+	list_for_each(temp, mcasp->mcasp_list) {
+		unit_count++;
+	}
+
+	McASP_FN_OUT(unit_count);
+	return unit_count;
+}
+
+static inline void __mcasp_set_pinmux(void)
+{
+	McASP_FN_IN;
+#define AUXCLK_NK 	__REG(0x01C4005C)
+	/* NK : This bit must be set to enable AUXCLK */
+	AUXCLK_NK &= 0xFEFFFFFF;
+	/* Ideally the base port should take care of setting the proper pinmux
+	 * settings. If there are any other pinmuxing settings to be done, then
+	 * please do it here and call the function at the required place. */
+	McASP_FN_OUT(0);
+}
+
+static inline s8 __mcasp_set_lpsc(u8 mcasp_id)
+{
+	struct clk *clkp;
+	mcasp_unit_t *mcasp_unit;
+	u8 ret_val = 0;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		ret_val = -1;	/* Unlikely */
+	} else if (mcasp_unit->info.lpsc != NULL) {
+		clkp = clk_get(NULL, mcasp_unit->info.lpsc);
+
+		if (IS_ERR(clkp)) {
+			mcasp_err("Unable to get the clock for McASP%d\n",
+				  mcasp_id);
+			McASP_FN_OUT(-1);
+			ret_val = 1;
+		} else {
+			mcasp_unit->clock = clkp;
+			clk_use(mcasp_unit->clock);
+			clk_enable(mcasp_unit->clock);
+		}
+	}
+
+	McASP_FN_OUT(0);
+	return ret_val;
+}
+
+static inline void mcasp_set_reg(volatile u32 reg, u32 val)
+{
+	outl(inl(reg) | val, reg);
+}
+
+static inline u32 mcasp_get_reg(volatile u32 reg)
+{
+	return inl(reg);
+}
+
+s8 mcasp_get_free(void)
+{
+	struct list_head *temp;
+	mcasp_unit_t *unit = NULL;
+
+	McASP_FN_IN;
+	if (mcasp == NULL) {
+		mcasp_err("McASP is not initialized\n");
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	list_for_each(temp, mcasp->mcasp_list) {
+		unit = list_entry(temp, struct __mcasp_unit, list);
+		if ((atomic_read(&unit->tx_in_use) == 0) &&
+		    (atomic_read(&unit->rx_in_use) == 0)) {
+			McASP_FN_OUT(unit->info.id);
+			return unit->info.id;
+		}
+	}
+
+	McASP_FN_OUT(-1);
+	return -1;
+}
+EXPORT_SYMBOL(mcasp_get_free);
+
+s8 mcasp_get(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if ((atomic_read(&mcasp_unit->tx_in_use) == 1) ||
+	    (atomic_read(&mcasp_unit->rx_in_use) == 1)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_get);
+
+s8 mcasp_put(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	DISPLAY_MCASP_IN_USE_WARNING(mcasp_id);
+
+	if (atomic_read(&mcasp_unit->tx_in_use) != 0) {
+		atomic_set(&mcasp_unit->tx_in_use, 0);
+	}
+
+	if (atomic_read(&mcasp_unit->rx_in_use) != 0) {
+		atomic_set(&mcasp_unit->rx_in_use, 0);
+	}
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_put);
+
+static inline void mcasp_set_gblctl(mcasp_registers_t *regs, u32 val)
+{
+	McASP_FN_IN;
+	mcasp_set_reg((u32) & regs->gblctl, val);
+	while ((mcasp_get_reg((u32) & regs->gblctl) & val) != val) ;
+	McASP_FN_OUT(0);
+}
+
+static inline void mcasp_set_gblctlr(mcasp_registers_t *regs, u32 val)
+{
+	McASP_FN_IN;
+	mcasp_set_reg((u32) & regs->gblctlr, val);
+	while ((mcasp_get_reg((u32) & regs->gblctl) & val) != val) ;
+	McASP_FN_OUT(0);
+}
+
+static inline void mcasp_set_gblctlx(mcasp_registers_t *regs, u32 val)
+{
+	McASP_FN_IN;
+	mcasp_set_reg((u32) & regs->gblctlx, val);
+	while ((mcasp_get_reg((u32) & regs->gblctl) & val) != val) ;
+	McASP_FN_OUT(0);
+}
+
+s8 mcasp_start_rx(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+	mcasp_registers_t *regs;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (atomic_read(&mcasp_unit->rx_in_use) == 1) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	mcasp_set_gblctlr(regs, RXHCLKRST);
+	mcasp_set_gblctlr(regs, RXCLKRST);
+	mcasp_set_gblctlr(regs, RXSERCLR);
+
+	mcasp_set_reg((u32) & regs->rxbuf[0], 0);
+
+	mcasp_set_gblctlr(regs, RXSMRST);
+	mcasp_set_gblctlr(regs, RXFSRST);
+
+	mcasp_set_reg((u32) & regs->rxbuf[0], 0);
+
+	mcasp_set_gblctlr(regs, RXSMRST);
+	mcasp_set_gblctlr(regs, RXFSRST);
+
+	atomic_set(&mcasp_unit->rx_in_use, 1);
+
+	McASP_FN_OUT(-1);
+	return 0;
+}
+
+s8 mcasp_start_tx(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+	mcasp_registers_t *regs;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (atomic_read(&mcasp_unit->tx_in_use) == 1) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	mcasp_set_gblctlx(regs, TXHCLKRST);
+	mcasp_set_gblctlx(regs, TXCLKRST);
+	mcasp_set_gblctlx(regs, TXSERCLR);
+
+	mcasp_set_reg((u32) & regs->txbuf[0], 0);
+
+	mcasp_set_gblctlx(regs, TXSMRST);
+	mcasp_set_gblctlx(regs, TXFSRST);
+
+	mcasp_set_reg((u32) & regs->txbuf[0], 0);
+	do {
+	} while (!(regs->xrsrctl[0] & 0x10));	/* Check for Tx ready */
+	regs->txbuf[0] = 0;
+
+	atomic_set(&mcasp_unit->tx_in_use, 1);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+
+s8 mcasp_stop_rx(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+	mcasp_registers_t *regs;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (atomic_read(&mcasp_unit->rx_in_use) != 1) {
+		mcasp_info("McASP%d is not started\n", mcasp_id);
+		McASP_FN_OUT(-1);
+		return 1;
+	}
+
+	regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	regs->gblctlr = 0;
+	regs->rxstat = 0xFFFFFFFF;
+
+	atomic_set(&mcasp_unit->rx_in_use, 0);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+
+s8 mcasp_stop_tx(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+	mcasp_registers_t *regs;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (atomic_read(&mcasp_unit->tx_in_use) != 1) {
+		mcasp_info("McASP%d is not started\n", mcasp_id);
+		McASP_FN_OUT(1);
+		return 1;
+	}
+	regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	regs->gblctlx = 0;
+	regs->txstat = 0xFFFFFFFF;
+	atomic_set(&mcasp_unit->tx_in_use, 0);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+
+s8 mcasp_stop(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (mcasp_unit->info.flags & TX_SUPPORT) {
+		if (atomic_read(&mcasp_unit->tx_in_use) != 1) {
+			mcasp_info("McASP%d TX is not started\n", mcasp_id);
+		} else {
+			mcasp_stop_tx(mcasp_id);
+		}
+	}
+
+	if (mcasp_unit->info.flags & RX_SUPPORT) {
+		if (atomic_read(&mcasp_unit->rx_in_use) != 1) {
+			mcasp_info("McASP%d RX is not started\n", mcasp_id);
+		} else {
+			mcasp_stop_rx(mcasp_id);
+		}
+	}
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_stop);
+
+s8 mcasp_start(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (unlikely(mcasp_unit == NULL)) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (mcasp_unit->info.flags & TX_SUPPORT) {
+		if (atomic_read(&mcasp_unit->tx_in_use) == 1) {
+			mcasp_err
+			    ("McASP%d TX is in use. Stop it before starting"
+			     " it again\n", mcasp_id);
+		} else {
+			mcasp_start_tx(mcasp_id);
+		}
+	}
+
+	if (mcasp_unit->info.flags & RX_SUPPORT) {
+		if (atomic_read(&mcasp_unit->rx_in_use) == 1) {
+			mcasp_err
+			    ("McASP%d RX is in use. Stop it before starting"
+			     " it again\n", mcasp_id);
+		} else {
+			mcasp_start_rx(mcasp_id);
+		}
+	}
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_start);
+
+#ifdef McASP_DEBUG
+static void dump_registers(u8 mcasp_id)
+{
+	/* Nirmal: Need to dump registers of the intended McASP for Debug */
+	mcasp_registers_t *mcasp_regs, *config;
+	mcasp_unit_t *mcasp_unit;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return;		/* Unlikely */
+	}
+
+	config = &mcasp_unit->config;
+
+	mcasp_regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	printk(KERN_DEBUG "\nGBL CTL 	: %08x", mcasp_regs->gblctl);
+
+	printk(KERN_DEBUG "\nPFUNC 	: %08x", mcasp_regs->pfunc);
+	printk(KERN_DEBUG "\nPDIR 		: %08x", mcasp_regs->pdir);
+	printk(KERN_DEBUG "\nAMUTE 	: %08x", mcasp_regs->amute);
+	printk(KERN_DEBUG "\nDLB CTL 	: %08x", mcasp_regs->lbctl);
+	printk(KERN_DEBUG "\nDIT CTL 	: %08x", mcasp_regs->txditctl);
+	printk(KERN_DEBUG "\nRXMASK 	: %08x", mcasp_regs->rxmask);
+	printk(KERN_DEBUG "\nRX FMT 	: %08x", mcasp_regs->rxfmt);
+	printk(KERN_DEBUG "\nRX FMCTL 	: %08x", mcasp_regs->rxfmctl);
+	printk(KERN_DEBUG "\nACLKR CTL 	: %08x", mcasp_regs->aclkrctl);
+	printk(KERN_DEBUG "\nAHCLKR CTL 	: %08x", mcasp_regs->ahclkrctl);
+	printk(KERN_DEBUG "\nRX TDM 	: %08x", mcasp_regs->rxtdm);
+	printk(KERN_DEBUG "\nEVTR CTL	: %08x", mcasp_regs->evtctlr);
+	printk(KERN_DEBUG "\nRX STAT 	: %08x", mcasp_regs->rxstat);
+	printk(KERN_DEBUG "\nRXTDM SLOT 	: %08x", mcasp_regs->rxtdmslot);
+	printk(KERN_DEBUG "\nRX CLKCHK 	: %08x", mcasp_regs->rxclkchk);
+	printk(KERN_DEBUG "\nREVTCTL 	: %08x", mcasp_regs->revtctl);
+
+	printk(KERN_DEBUG "\nTX MASK 	: %08x", mcasp_regs->txmask);
+	printk(KERN_DEBUG "\nTX FMT 	: %08x", mcasp_regs->txfmt);
+	printk(KERN_DEBUG "\nTX FMCTL 	: %08x", mcasp_regs->txfmctl);
+	printk(KERN_DEBUG "\nACLKXCTL 	: %08x", mcasp_regs->aclkxctl);
+	printk(KERN_DEBUG "\nAHCLKXTL 	: %08x", mcasp_regs->ahclkxctl);
+	printk(KERN_DEBUG "\nTXTDM 	: %08x", mcasp_regs->txtdm);
+	printk(KERN_DEBUG "\nEVTX CTL	: %08x", mcasp_regs->evtctlx);
+	printk(KERN_DEBUG "\nTX STATL 	: %08x", mcasp_regs->txstat);
+	printk(KERN_DEBUG "\nTX TDMSLOT 	: %08x", mcasp_regs->txtdmslot);
+	printk(KERN_DEBUG "\nTX CLKCHK 	: %08x", mcasp_regs->txclkchk);
+}
+#endif				/* MCASP_DEBUG */
+
+static inline void __mcasp_configure_regs(u8 mcasp_id)
+{
+	mcasp_registers_t *mcasp_regs, *config;
+	mcasp_unit_t *mcasp_unit;
+	u32 val = 0;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return;		/* Unlikely */
+	}
+
+	config = &mcasp_unit->config;
+
+	__mcasp_set_pinmux();
+
+	if (__mcasp_set_lpsc(mcasp_id) < 0) {
+		mcasp_err("Error setting LPSC domains\n");
+	}
+
+	mcasp_regs = (mcasp_registers_t *) mcasp_unit->info.reg_base;
+
+	mcasp_set_reg((u32) & mcasp_regs->gblctl, 0x00000000);
+
+	/* Reset */
+	val = ~(RXCLKRST | RXHCLKRST | RXSERCLR | RXSMRST | RXFSRST | TXCLKRST |
+		TXHCLKRST | TXSERCLR | TXSMRST | TXFSRST);
+	mcasp_regs->gblctl = val;
+
+	mcasp_regs->pwremumgt = config->pwremumgt;
+	mcasp_regs->pfunc = config->pfunc;
+	mcasp_regs->pdir = config->pdir;
+	mcasp_regs->amute = config->amute;
+	mcasp_regs->lbctl = config->lbctl;
+	mcasp_regs->txditctl = config->txditctl;
+	mcasp_regs->rxmask = config->rxmask;
+	mcasp_regs->rxfmt = config->rxfmt;
+	mcasp_regs->rxfmctl = config->rxfmctl;
+	mcasp_regs->aclkrctl = config->aclkrctl;
+	mcasp_regs->ahclkrctl = config->ahclkrctl;
+	mcasp_regs->rxtdm = config->rxtdm;
+	mcasp_regs->evtctlr = config->evtctlr;
+	mcasp_regs->rxstat = config->rxstat;
+	mcasp_regs->rxtdmslot = config->rxtdmslot;
+	mcasp_regs->rxclkchk = config->rxclkchk;
+	mcasp_regs->revtctl = config->revtctl;
+
+	mcasp_regs->txmask = config->txmask;
+	mcasp_regs->txfmt = config->txfmt;
+	mcasp_regs->txfmctl = config->txfmctl;
+	mcasp_regs->aclkxctl = config->aclkxctl;
+	mcasp_regs->ahclkxctl = config->ahclkxctl;
+	mcasp_regs->txtdm = config->txtdm;
+	mcasp_regs->evtctlx = config->evtctlx;
+	mcasp_regs->txstat = config->txstat;
+	mcasp_regs->txtdmslot = config->txtdmslot;
+	mcasp_regs->txclkchk = config->txclkchk;
+	mcasp_regs->xevtctl = config->xevtctl;
+
+	for (val = 0; val < mcasp_unit->info.serializer_count; val++) {
+		mcasp_regs->xrsrctl[val] = config->xrsrctl[val];
+	}
+
+	/* Is there a need to clear the tx and rx buf */
+	for (val = 0; val < mcasp_unit->info.serializer_count; val++) {
+		mcasp_regs->txbuf[val] = 0x00000000;
+	}
+
+	for (val = 0; val < mcasp_unit->info.serializer_count; val++) {
+		mcasp_regs->rxbuf[val] = 0x00000000;
+	}
+#ifdef McASP_DEBUG
+	/* Nirmal: dump registers */
+	dump_registers(mcasp_id);
+#endif
+	McASP_FN_OUT(0);
+}
+
+s32 mcasp_get_sample_rate(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return -1;	/* Unlikely */
+	}
+
+	return mcasp_unit->sample_rate;
+}
+
+s32 mcasp_set_sample_rate(u8 mcasp_id, u32 sample_rate)
+{
+	u32 ret_val = 0, i = 0;
+	mcasp_unit_t *mcasp_unit;
+	mcasp_registers_t *config;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return -1;	/* Unlikely */
+	}
+
+	config = &mcasp_unit->config;
+
+	for (i = 0; i < MAX_SAMPLE_RATES; i++) {
+		if (sample_rate == sample_rates_supported[i]) {
+			switch (sample_rate) {
+			case 22050:
+				config->aclkxctl = 0x000000A0;
+				config->ahclkxctl = 0x0008021;
+				config->txfmctl = 0x00000002;
+
+				config->aclkrctl = 0x000000A0;
+				config->ahclkrctl = 0x0008010;
+				config->rxfmctl = 0x00000002;
+
+				config->pdir |= (0x7 << 26);
+				break;
+
+			case 44100:
+				config->aclkxctl = 0x000000A0;
+				config->ahclkxctl = 0x0008010;
+				config->txfmctl = 0x00000002;
+
+				config->aclkrctl = 0x000000A0;
+				config->ahclkrctl = 0x0008010;
+				config->rxfmctl = 0x00000002;
+
+				config->pdir |= (0x7 << 26);
+				break;
+			}
+			__mcasp_configure_regs(mcasp_id);
+			ret_val = sample_rates_supported[i];
+			break;
+		}
+		ret_val = mcasp_unit->sample_rate;
+	}
+
+	mcasp_unit->sample_rate = ret_val;
+	return ret_val;
+}
+
+s8 mcasp_configure(u8 mcasp_id, void *cfg)
+{
+	mcasp_registers_t mcasp_config;
+	audio_config_t *audio_cfg = (audio_config_t *) cfg;
+	u8 cnt = 0;
+	mcasp_unit_t *mcasp_unit;
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return -1;	/* Unlikely */
+	}
+
+	memset(&mcasp_config, 0, sizeof(mcasp_registers_t));
+
+	/* Default configuration */
+	mcasp_config.pwremumgt = 0x00000001;
+	mcasp_config.pfunc = 0x00000000;
+	mcasp_config.pdir = 0x00000001;
+	mcasp_config.amute = 0x00000000;
+	mcasp_config.lbctl = 0x00000000;
+	mcasp_config.txditctl = 0x00000000;
+	mcasp_config.rxmask = 0xFFFFFFFF;
+	mcasp_config.rxfmt = 0x000080f0;
+	mcasp_config.rxfmctl = 0x00000000;
+	mcasp_config.aclkrctl = 0x00000000;
+	mcasp_config.ahclkrctl = 0x00008000;
+	mcasp_config.rxtdm = 0x00000000;
+	mcasp_config.evtctlr = 0x00000000;
+	mcasp_config.rxstat = 0xFFFFFFFF;
+	mcasp_config.rxtdmslot = 0x00000000;
+	mcasp_config.rxclkchk = 0x00000000;
+	mcasp_config.revtctl = 0x00000000;
+	mcasp_config.txmask = 0xFFFFFFFF;
+	mcasp_config.txfmt = 0x000080f0;
+	mcasp_config.txfmctl = 0x00000000;
+	mcasp_config.aclkxctl = 0x00000000;
+	mcasp_config.ahclkxctl = 0x00008000;
+	mcasp_config.txtdm = 0x00000000;
+	mcasp_config.evtctlx = 0x00000000;
+	mcasp_config.txstat = 0xFFFFFFFF;
+	mcasp_config.txtdmslot = 0x00000000;
+	mcasp_config.txclkchk = 0x00000000;
+	mcasp_config.xevtctl = 0x00000000;
+	mcasp_config.xrsrctl[0] = 0x1;
+	mcasp_config.xrsrctl[1] = 0x2;
+
+	if (audio_cfg->mode == CODEC_IS_MASTER) {
+		mcasp_config.aclkrctl = 0x00000000;
+		mcasp_config.ahclkrctl = 0x00008000;
+		mcasp_config.rxfmctl = 0x00000000;
+
+		mcasp_config.aclkxctl = 0x00000000;
+		mcasp_config.ahclkxctl = 0x00008000;
+		mcasp_config.txfmctl = 0x00000000;
+
+		mcasp_config.pdir &= ~(0x3F << 26);
+	} else {
+		/* Codec is Slave */
+		printk(KERN_INFO "Configuring the McASP as Master\n");
+
+		mcasp_config.aclkxctl = 0x000000A0;
+		mcasp_config.ahclkxctl = 0x0008010;
+		mcasp_config.txfmctl = 0x00000002;
+
+		mcasp_config.aclkrctl = 0x000000A0;
+		mcasp_config.ahclkrctl = 0x0008010;
+		mcasp_config.rxfmctl = 0x00000002;
+
+		mcasp_config.pdir |= (0x7 << 26);
+	}
+
+	if (audio_cfg->channel_size < 8 || audio_cfg->channel_size > 32) {
+		printk(KERN_EMERG "Invalid channel size\n");
+		return -1;
+	}
+
+	switch (audio_cfg->channel_size) {
+	case 8:
+		mcasp_config.rxfmt |= (0x03 << 4);
+		mcasp_config.txfmt |= (0x03 << 4);
+		break;
+
+	case 12:
+		mcasp_config.rxfmt |= (0x05 << 4);
+		mcasp_config.txfmt |= (0x05 << 4);
+		break;
+
+	case 16:
+		mcasp_config.rxfmt |= (0x07 << 4);
+		mcasp_config.txfmt |= (0x07 << 4);
+		break;
+
+	case 20:
+		mcasp_config.rxfmt |= (0x09 << 4);
+		mcasp_config.txfmt |= (0x09 << 4);
+		break;
+
+	case 24:
+		mcasp_config.rxfmt |= (0x0B << 4);
+		mcasp_config.txfmt |= (0x0B << 4);
+		break;
+
+	case 28:
+		mcasp_config.rxfmt |= (0x0D << 4);
+		mcasp_config.txfmt |= (0x0D << 4);
+		break;
+
+	case 32:
+		mcasp_config.rxfmt |= (0x0F << 4);
+		mcasp_config.txfmt |= (0x0F << 4);
+		break;
+
+	default:
+		return -1;
+	}
+
+	if (audio_cfg->loopback == 1) {
+		/* Enable Loopback */
+		mcasp_config.lbctl |= audio_cfg->loopback;
+	}
+
+	if (audio_cfg->amute == 1) {
+		/* Enable AMUTE. Drive high if error detected. */
+		mcasp_config.amute |= audio_cfg->amute;
+		mcasp_config.pdir |= (0x1 << 25);	/* ???? */
+	}
+
+	/* NK: slots should not be MORE than 384 */
+	if (audio_cfg->tdm_slots < 0 || audio_cfg->tdm_slots > 384) {
+		printk(KERN_EMERG "Invalid number of slots\n");
+		return -1;
+	}
+
+	mcasp_config.rxfmctl |= (audio_cfg->tdm_slots << 7);
+	mcasp_config.txfmctl |= (audio_cfg->tdm_slots << 7);
+
+	/* NK: This should not be done for the DIT */
+	if (audio_cfg->tdm_slots < 384) {
+		for (cnt = 0; cnt < audio_cfg->tdm_slots; cnt++) {
+			mcasp_config.txtdm |= (1 << cnt);
+			mcasp_config.rxtdm |= (1 << cnt);
+		}
+	}
+	if (audio_cfg->tdm_slots == 0) {
+		/* Receive frame sync duration is 1 bit
+		 * for burst mode*/
+		mcasp_config.rxfmctl &= 0xFFFFFFEF;
+		mcasp_config.txfmctl &= 0xFFFFFFEF;
+	} else {
+		mcasp_config.rxfmctl |= 0x10;
+		mcasp_config.txfmctl |= 0x10;
+	}
+
+	for (cnt = 0; cnt < audio_cfg->serializer_count; cnt++) {
+		switch (audio_cfg->serializer_mode[cnt]) {
+		case 0:
+			mcasp_config.xrsrctl[cnt] |= SERIALIZER_IS_INACTIVE;
+			break;
+
+		case 1:
+			mcasp_config.xrsrctl[cnt] |= SERIALIZER_IS_TX;
+			mcasp_config.pdir |= (1 << cnt);
+			break;
+
+		case 2:
+			mcasp_config.xrsrctl[cnt] |= SERIALIZER_IS_RX;
+			mcasp_config.pdir &= ~(1 << cnt);
+			break;
+
+		default:
+			printk(KERN_EMERG "Invalid mode for the serializers\n");
+			return -1;
+		}
+	}
+	/* Nirmal: Configure the McASP for the DIT */
+	/* For want of any other suitable param,I am using tdm_slots */
+	if (audio_cfg->tdm_slots == 384) {
+
+		printk(KERN_INFO "Configuring the McASP %d for DIT \n",
+		       mcasp_id);
+
+		mcasp_config.xrsrctl[0] = 0x1;
+		mcasp_config.xrsrctl[1] = 0x0;
+		mcasp_config.xrsrctl[2] = 0x0;
+		mcasp_config.xrsrctl[3] = 0x0;
+
+		/* Set the PDIR for Serialiser as output */
+		mcasp_config.pdir = 0x10000001;
+
+		/* All PINS as McASP */
+		mcasp_config.pfunc = 0x00000000;
+
+		/* TXMASK for 24 bits */
+		mcasp_config.txmask = 0x00FFFFFF;
+
+		/* Set the TX format : 24 bit right rotation, 32 bit slot, Pad 0
+		   and LSB first */
+		mcasp_config.txfmt = 0x000000F6;
+
+		/* Set TX frame synch : DIT Mode, 1 bit width, internal, rising
+		   edge */
+		mcasp_config.txfmctl = 0x0000C002;
+
+		/* Set the TX tdm : for all the slots */
+		mcasp_config.txtdm = 0xFFFFFFFF;
+
+		/* Set the TX clock controls : div = 1 and internal */
+		mcasp_config.aclkxctl = 0x00000060;
+
+		/* Set the TX high clock with approriate divisor */
+		/* Set as per the required rate */
+		switch (audio_cfg->sample_rate) {
+
+			/* Both 44100 and 48000 have the same clock setting. */
+		case 44100:
+			mcasp_config.ahclkxctl = 0x00008003;
+			break;
+
+		case 48000:
+			mcasp_config.ahclkxctl = 0x00008003;
+			break;
+
+		default:
+			printk(KERN_ERR "\n Sampling rate %d not supported\n",
+			       audio_cfg->sample_rate);
+			printk(KERN_ERR "\n Switching to default Sampling rate \
+						48000\n");
+			mcasp_config.ahclkxctl = 0x00008003;
+			audio_cfg->sample_rate = 48000;
+			break;
+		}
+
+		mcasp_unit->sample_rate = audio_cfg->sample_rate;
+		/* Enable the DIT */
+		mcasp_config.txditctl = 0x00000001;	/* 1 */
+
+	} else {
+		/* Receive frame sync duration is 1 bit
+		 * for burst mode*/
+		mcasp_config.rxfmctl &= 0xFFFFFFEF;
+		mcasp_config.txfmctl &= 0xFFFFFFEF;
+	}
+	/* NK : up to this */
+	if (mcasp_reg_configure(mcasp_id, &mcasp_config) < 0) {
+		mcasp_err("Unable to configure McASP\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+s8 mcasp_reg_configure(u8 mcasp_id, void *cfg)
+{
+	mcasp_unit_t *mcasp_unit = NULL;
+	mcasp_registers_t *mcasp_config = (mcasp_registers_t *) cfg;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (mcasp_get(mcasp_id) < 0) {
+		mcasp_err("McASP%d is in use. Stop it before configuring\n",
+			  mcasp_id);
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	memcpy(&mcasp_unit->config, mcasp_config, sizeof(mcasp_registers_t));
+	__mcasp_configure_regs(mcasp_id);
+	atomic_set(&mcasp_unit->init, 1);
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_reg_configure);
+
+void *mcasp_get_info(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit = NULL;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return NULL;
+	}
+
+	McASP_FN_OUT_ADDR(&mcasp_unit->info);
+	return (void *)&mcasp_unit->info;
+}
+EXPORT_SYMBOL(mcasp_get_info);
+
+void *mcasp_get_config(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit = NULL;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(0);
+		return NULL;
+	}
+
+	if (atomic_read(&mcasp_unit->init) != 1) {
+		mcasp_info("McASP%d is not configured\n", mcasp_id);
+		McASP_FN_OUT(0);
+		return NULL;
+	}
+
+	McASP_FN_OUT_ADDR(&mcasp_unit->config);
+	return (void *)&mcasp_unit->config;
+}
+EXPORT_SYMBOL(mcasp_get_config);
+
+
+s8 mcasp_unconfigure(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit = NULL;
+
+	McASP_FN_IN;
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (atomic_read(&mcasp_unit->init) != 1) {
+		mcasp_info("McASP%d was not configured\n", mcasp_id);
+		McASP_FN_OUT(-1);
+		return 1;
+	}
+
+	DISPLAY_MCASP_IN_USE_WARNING(mcasp_id);
+
+	if (mcasp_stop(mcasp_id) < 0) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	memset(&mcasp_unit->config, 0, sizeof(mcasp_registers_t));
+	atomic_set(&mcasp_unit->init, 0);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_unconfigure);
+
+static inline u8 check_for_duplicate_id(u8 mcasp_count, mcasp_info_t
+					* mcasp_info)
+{
+	u8 *arr = NULL;
+	u8 i = 0, j = 0;
+	mcasp_info_t *info = mcasp_info;
+
+	McASP_FN_IN;
+	arr = (u8 *) kmalloc(mcasp_count, GFP_KERNEL);
+
+	if (arr == NULL) {
+		mcasp_err("Unable to allocate memory\n");
+		McASP_FN_OUT(1);
+		return 1;
+	}
+
+	for (i = 0; i < mcasp_count; i++) {
+		arr[i] = info->id;
+		info++;
+	}
+
+	for (i = 0; i < mcasp_count - 1; i++) {
+		for (j = i; j < mcasp_count - 1; j++) {
+			if (arr[i] == arr[j + 1]) {
+				kfree(arr);
+				McASP_FN_OUT(1);
+				return 1;
+			}
+		}
+	}
+
+	kfree(arr);
+	McASP_FN_OUT(0);
+	return 0;
+}
+
+s8 mcasp_dev_init(u8 mcasp_count, void *info)
+{
+	u8 i = 0;
+	mcasp_info_t *mcasp_info = (mcasp_info_t *) info;
+
+	McASP_FN_IN;
+	if (unlikely(mcasp_count <= 0)) {
+		mcasp_err("Invalid count of McASP units\n");
+		McASP_FN_OUT(-EINVAL);
+		return -EINVAL;
+	}
+
+	if (check_for_duplicate_id(mcasp_count, mcasp_info)) {
+		mcasp_err("McASP ID's have to be unique\n");
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (mcasp != NULL) {
+		mcasp_err("\n\nMcASP Device has already been initialized\n\n");
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	mcasp = (mcasp_device_t *) kmalloc(sizeof(mcasp_device_t), GFP_KERNEL);
+
+	if (unlikely(mcasp == NULL)) {
+		mcasp_err("Unable to allocate memory.\n");
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	mcasp->count = mcasp_count;
+	mcasp->mcasp_list = NULL;
+
+	do {
+		mcasp_unit_t *mcasp_unit = NULL;
+
+		mcasp_unit = (mcasp_unit_t *) kmalloc(sizeof(mcasp_unit_t),
+						      GFP_KERNEL);
+
+		if (unlikely(mcasp_unit == NULL)) {
+			mcasp_err("Unable to allocate memory.\n");
+			McASP_FN_OUT(-1);
+			return -1;
+		}
+
+		memset(mcasp_unit, 0, sizeof(mcasp_unit_t));
+
+		INIT_LIST_HEAD(&mcasp_unit->list);
+		memcpy(&(mcasp_unit->info), &mcasp_info[i],
+		       sizeof(mcasp_unit_t));
+		memset(&mcasp_unit->config, 0, sizeof(mcasp_registers_t));
+		mcasp_unit->clock = NULL;
+		mcasp_unit->sample_rate =
+		    sample_rates_supported[MAX_SAMPLE_RATES - 1];
+		atomic_set(&mcasp_unit->init, 0);
+		atomic_set(&mcasp_unit->tx_in_use, 0);
+		atomic_set(&mcasp_unit->rx_in_use, 0);
+
+		if (unlikely(mcasp->mcasp_list == NULL)) {
+			mcasp->mcasp_list = &mcasp_unit->list;
+		} else {
+			list_add(&mcasp_unit->list, mcasp->mcasp_list);
+		}
+	} while (++i < mcasp_count);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_dev_init);
+
+s8 mcasp_dev_deinit(u8 mcasp_id)
+{
+	mcasp_unit_t *mcasp_unit = NULL;
+
+	McASP_FN_IN;
+	if (mcasp == NULL) {
+		mcasp_err("McASP Device has not been initialized\n");
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	mcasp_unit = find_mcasp(mcasp_id);
+
+	if (mcasp_unit == NULL) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	DISPLAY_MCASP_IN_USE_WARNING(mcasp_id);
+
+	if (mcasp_stop(mcasp_id) < 0) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (mcasp_unconfigure(mcasp_id) < 0) {
+		McASP_FN_OUT(-1);
+		return -1;
+	}
+
+	if (__mcasp_unit_count() == 1) {
+		mcasp->mcasp_list = NULL;
+		kfree(mcasp);
+		mcasp = NULL;
+	} else {
+		if (mcasp->mcasp_list == &mcasp_unit->list) {
+			mcasp->mcasp_list = mcasp_unit->list.next;
+		}
+	}
+
+	list_del(&mcasp_unit->list);
+	clk_unuse(mcasp_unit->clock);
+	clk_disable(mcasp_unit->clock);
+	kfree(mcasp_unit);
+
+	McASP_FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(mcasp_dev_deinit);
+
+static int __init mcasp_init(void)
+{
+	McASP_FN_IN;
+	McASP_FN_OUT(0);
+	return 0;
+}
+
+static void __exit mcasp_exit(void)
+{
+	McASP_FN_IN;
+	if (mcasp != NULL) {
+		u8 cnt = __mcasp_unit_count();
+		u8 *arr = NULL, i = 0;
+		struct list_head *temp = NULL;
+		mcasp_unit_t *mcasp_unit = NULL;
+
+		arr = (u8 *) kmalloc(cnt, GFP_KERNEL);
+
+		if (arr == NULL) {
+			mcasp_err("Unable to allocate memory\n");
+			goto failure;
+		}
+
+		list_for_each(temp, mcasp->mcasp_list) {
+			mcasp_unit =
+			    list_entry(temp, struct __mcasp_unit, list);
+			arr[i] = mcasp_unit->info.id;
+			i++;
+		}
+
+		for (i = 0; i < cnt; i++) {
+			mcasp_dev_deinit(arr[i]);
+		}
+
+		kfree(arr);
+	}
+
+failure:
+	McASP_FN_OUT(0);
+}
+
+module_init(mcasp_init);
+module_exit(mcasp_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("Multichannel Audio Serial Port (McASP) Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/include/asm-arm/arch-davinci/davinci-audio-config.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/davinci-audio-config.h
@@ -0,0 +1,48 @@
+#ifndef __DAVINCI_AUDIO_CONFIG_H_
+#define __DAVINCI_AUDIO_CONFIG_H_
+
+/*
+ * davinci-audio-config.h - An interface to make the configuration of ASP and
+ *                          codec easy.
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#define CODEC_IS_MASTER                    0
+#define CODEC_IS_SLAVE                     1
+
+#define SERIALIZER_IS_TX                1
+#define SERIALIZER_IS_RX                2
+#define SERIALIZER_IS_INACTIVE          0
+
+#define MAX_SERIALIZER_COUNT           16 /* Serializer Count */
+
+typedef struct audio_config {
+    u8 mcasp_id;
+    u8 mode;
+    u8 channel_size;
+    u8 serializer_count;
+    u8 serializer_mode[MAX_SERIALIZER_COUNT];
+    u8 loopback;
+    u8 amute;
+    s16 tdm_slots;
+    u32 sample_rate;
+}audio_config_t;
+
+#endif /* __DAVINCI_AUDIO_CONFIG_H_ */
Index: linux-2.6.10/include/asm-arm/arch-davinci/evm_audio_info.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/evm_audio_info.h
@@ -0,0 +1,209 @@
+#ifndef __EVM_AUDIO_INFO_H__
+#define __EVM_AUDIO_INFO_H__
+
+/*
+ * evm_audio_info.h - Header file which defines the layout of ASP and codec on
+ *                    an EVM.
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+
+#define MAX_SERIALIZER_COUNT 16
+#define MAX_ASP		2	/* Maximum number of ASP's */
+#define MAX_CODEC	1	/* Highest number of codec's under any of the
+				   #ASP */
+
+#define ASP_SLAVE           0
+#define ASP_MASTER          1
+
+#define TRUE     1
+#define FALSE    0
+
+#define ERR_INVALID_CODEC_ID              100
+#define ERR_INVALID_CODEC_FOPS_OR_INFO    101
+#define ERR_INVALID_ASP_ID                102
+#define ERR_INVALID_ASP_FOPS_OR_INFO      103
+#define ERR_DUP_CODEC_ID                  104
+#define ERR_INVAL_ASP_CNT                 105
+#define ERR_DUP_ASP_ID                    106
+#define ERR_NULL_AUDIO_CONFIG		  107
+#define ERR_AUDIO_DEVICE_NOT_FOUND	  108
+#define ERR_DIT_ENABLED_WITH_CODECS       109
+
+#define TX_SUPPORT  0x01
+#define RX_SUPPORT  0x02
+
+typedef struct asp_info {
+	/* Set -1 to indicate an unsupported or uninitialized feature */
+    s8 id;
+    u32 reg_base;
+    u32 tx_data_port;
+    u32 rx_data_port;
+    s8 tx_dma_evt;
+    s8 rx_dma_evt;
+    s8 tx_irq;
+    s8 rx_irq;
+    s8 serializer_count;
+    s8 left_dit_channel_count;
+    s8 right_dit_channel_count;
+    const char *lpsc;		/* Initialize this to NULL if there is no LPSC
+				   domain to be initialized. Sometimes this init
+				   of the power domain could be done by some
+				   other portion of the BSP (eg: U-boot) or
+				   sometime the module might not need any LPSC
+				   to be initializd. */
+    s8 flags;	                /* Useful to indicate things like feature
+				   supported */
+}asp_info_t;
+
+typedef struct codec_info {
+    const char *lpsc;		/* Initialize this to NULL if there is no LPSC
+				   domain to be initialized. Sometimes this init
+				   of the power domain could be done by some
+				   other portion of the BSP (eg: U-boot) or
+				   sometime the module might not need any LPSC
+				   to be initializd. */
+    s8 flags;			/* Useful to indicate things like feature
+				   supported */
+}codec_info_t;
+
+/* Values for audio codec types */
+enum codec_type {
+    CODEC_UNKNOWN = 0,
+    CODEC_AIC23,
+    CODEC_AIC32,
+    CODEC_AIC33
+};
+
+typedef struct audio_codec {
+    u8 id;			/* Codec ID */
+    enum codec_type type;	/* Type of Codec. Choose from list. Add any new
+				   codec to the list */
+    u8 is_configured:1;
+    u8 is_initialized:1;
+    u8 is_in_use:1;
+
+    struct codec_file_operations *c_op;	/* File operations needed for the
+					   central controller to access some of
+					   the functionalities of the codec. */
+    struct codec_info *c_info;	/* Hardware information */
+
+    u8 device_instance;		/* This is the number that is returned by the
+				 * register_sound_dsp function. This will be
+				 * updated by the code. DON'T UPDATE THIS
+				 * MANUALLY. Even if you update the value will
+				 * be overwritten. */
+    u8 pid;
+	    /* It was planned to store the audio_state variable here. Just
+	     * including one variable here was causing some glibc error (****
+	     * glibc detected *** double free or corruption: 0x00012008 ***)
+	     * . So its been moved to asp structure. Keeping here would be a
+	     * neat way as it easily accomidates maintaing different
+	     * audio_states for each codec else we might need to make the
+	     * audio_state in the ASP structure an array to store the different
+	     * audio_states*/
+	/* void *audio_state; */
+}audio_codec_t;
+
+/* Values for ASP type */
+enum asp_type {
+    MCASP = 1,
+    MCBSP
+};
+
+enum asp_mode {
+    MASTER = 0,
+    SLAVE
+};
+
+typedef struct audio_serial_port {
+    u8 id;			/* ID of the ASP */
+    enum asp_type type;	/* McASP/McBSP or any other new ASP. Add new asp
+				   to the list above. */
+    enum asp_mode master_mode;		/* 0-Slave, 1-Master */
+
+    u8 is_configured:1;
+    u8 is_initialized:1;
+    u8 is_in_use:1;
+
+    struct asp_file_operations *a_op; /* File operations which might need to be
+					 called by the central controller. */
+    struct asp_info *a_info;	/* Hardware Information */
+    u8 dit_enabled;
+    u8 need_tx_for_rx; 		/* Some cases, you might need to run Dummy TX
+				   for RX. Enable this in such cases*/
+    u8 codec_count;		/* Number of Audio codec's connected to the ASP
+				 */
+    audio_codec_t codec[MAX_CODEC];	/* Pointer to the codec/s */
+    void *audio_state;		/* Make it an array if ever there are more then
+				   once codec per ASP */
+}audio_serial_port_t;
+
+typedef struct evm_audio_info {
+    u8 asp_count;		/* Number of serial ports (mcasp/mcbsp's) */
+    struct audio_serial_port asp[MAX_ASP];      /* Pointer to the ASP/s */
+} evm_audio_info_t;
+
+s8 get_parent_id (u8 id);
+
+typedef struct asp_file_operations {
+    s8 (*init)(u8 asp_count, void *info);
+    s8 (*de_init)(u8 id);
+    s8 (*configure)(u8 id, void *cfg);
+    s8 (*unconfigure)(u8 id);
+    s8 (*configure_reg)(u8 mcasp_id, void *cfg);
+    s8 (*start)(u8 id);
+    s8 (*stop)(u8 id);
+    s8 (*start_tx)(u8 id);
+    s8 (*stop_tx)(u8 id);
+    s8 (*start_rx)(u8 id);
+    s8 (*stop_rx)(u8 id);
+    void *(*get_info)(u8 id);
+    void *(*get_config)(u8 id);
+    struct clk *(*get_clock)(u8 id);
+    s32 (*set_sample_rate)(u8 id, u32 sample_rate);
+    s32 (*get_sample_rate)(u8 id);
+    s8 (*get)(u8 id);
+    s8 (*put)(u8 id);
+}asp_fops_t;
+
+
+typedef struct codec_file_operations {
+    s8 (*init)(void);
+    s8 (*de_init)(u8 id);
+    s8 (*configure)(u8 id, void *ptr);
+    s8 (*unconfigure)(u8 id);
+    s8 (*start)(u8 id);
+    s8 (*stop)(u8 id);
+    s8 (*get_info)(u8 id);
+    s8 (*get_config)(u8 id);
+    int (*ioctl)(struct inode *inode, struct file *file, uint cmd, ulong arg);
+}codec_fops_t;
+
+s8 validate_evm_audio_config (evm_audio_info_t **info);
+s8 find_audio_device ( u8 dev_instance, u8 *asp_id_ptr, u8 *codec_id_ptr );
+unsigned long get_rx_dma_src_address (u8 device_instance);
+unsigned long get_tx_dma_dest_address (u8 device_instance);
+asp_fops_t *get_asp_fops(u8 device_instance);
+codec_fops_t *get_codec_fops(u8 device_instance);
+u8 is_dit_enabled (u8 device_instance);
+#endif /* __EVM_AUDIO_INFO_H__ */
Index: linux-2.6.10/include/asm-arm/arch-davinci/mcasp.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-arm/arch-davinci/mcasp.h
@@ -0,0 +1,343 @@
+#ifndef __ASM_ARM_MCASP_H__
+#define __ASM_ARM_MCASP_H__
+
+/*
+ * mcasp.h - Definitions for the interface to MultiChannel Audio Serial Port
+ * 		(McASP).
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+/* Counts */
+#define MAX_SERIALIZER_COUNT           16	/* Serializer Count */
+#define MAX_DIT_LEFT_CHAN_STAT_COUNT   6	/* Left (even TDM slot) Channel
+						 * status register count */
+#define MAX_DIT_RIGHT_CHAN_STAT_COUNT  6	/* Right (odd TDM slot) Channel
+						 * status register count */
+#define MAX_LEFT_USR_DATA_REG_FILE     6	/* Left (even TDM slot) user
+						 * data register count */
+#define MAX_RIGHT_USR_DATA_REG_FILE    6	/* Right (odd TDM slot) user
+						 * data register count */
+#define TX_SUPPORT 0x01
+#define RX_SUPPORT 0x02
+
+/* McASP Register Overlay Structure */
+typedef struct mcasp_registers {
+	volatile u32 pid;	/* VBUS Std. Peripheral ID Register */
+	volatile u32 pwremumgt;	/* Power Down and Emulation Management
+				 * Register */
+	volatile u32 rsvd_08_0c[2];	/* Reserved */
+	volatile u32 pfunc;	/* Pin Function Register */
+	volatile u32 pdir;	/* Pin Direction Register */
+	volatile u32 pdout;	/* Pin Data Out Register */
+	volatile u32 pdset;	/* Writes Affect: Pin Data Set Register
+				 * (Alternate Write Address PDOUT)*/
+	/* PDIN is also an alias for PDSET */
+	volatile u32 pdclr;	/* Pin Data Clear Register
+				 * (Alternate Write Address PDOUT */
+	volatile u32 rsvd_24_2c[3];	/* Reserved */
+	volatile u32 tlgc;	/* IODFT Test Logic Global Control Register */
+	volatile u32 tlmr;	/* IODFT Test Logic MISR Result Register */
+	volatile u32 rsvd_38_40[3];	/* Reserved */
+	volatile u32 gblctl;	/* Global Control Register */
+	volatile u32 amute;	/* Mute Control Register */
+	volatile u32 lbctl;	/* Loop-Back Test Control Register */
+	volatile u32 txditctl;	/* Transmit DIT Mode Control Register */
+	volatile u32 rsvd_54_5c[3];	/* Reserved */
+	volatile u32 gblctlr;	/* Alias of GBLCTL containing only Receiver
+				 * Reset bits - allows transmit to be reset
+				 * independently from Receive */
+	volatile u32 rxmask;	/* Receiver Format Unit Bit Mask Register */
+	volatile u32 rxfmt;	/* Receive Bitstream Format Register */
+	volatile u32 rxfmctl;	/* Receive Frame Sync Control Register */
+	volatile u32 aclkrctl;	/* Receive Clock Control Register */
+	volatile u32 ahclkrctl;	/* High Frequency Receive Clock Control Register
+				 * */
+	volatile u32 rxtdm;	/* Receive TDM Slot 0-31 Register */
+	volatile u32 evtctlr;	/* Receiver Interrupt Control */
+	volatile u32 rxstat;	/* Status Register - Receiver */
+	volatile u32 rxtdmslot;	/* Current Receive TDM Slot */
+	volatile u32 rxclkchk;	/* Receiver Clock Check Control Register */
+	volatile u32 revtctl;	/* Receiver DMA Event Control */
+	volatile u32 rsvd_90_9c[4];	/* Reserved */
+	volatile u32 gblctlx;	/* Alias of GBLCTL containing only Transmit
+				 * Reset bits - allows transmit to be reset
+				 * independently from Receive*/
+	volatile u32 txmask;	/* Transmit Format Unit Bit Mask Register */
+	volatile u32 txfmt;	/* Transmit Bitstream Format Register */
+	volatile u32 txfmctl;	/* Transmit Frame Sync Control Register */
+	volatile u32 aclkxctl;	/* Transmit Clock Control Register */
+	volatile u32 ahclkxctl;	/* High Frequency Transmit Clock Control
+				 * Register*/
+	volatile u32 txtdm;	/* Transmit TDM Slot 0-31 Register */
+	volatile u32 evtctlx;	/* Transmitter Interrupt Control */
+	volatile u32 txstat;	/* Status Register - Transmitter */
+	volatile u32 txtdmslot;	/* Current Transmit TDM Slot */
+	volatile u32 txclkchk;	/* Transmit Clock Check Control Register */
+	volatile u32 xevtctl;	/* Transmitter DMA Control */
+	volatile u32 rsvd_d0_fc[12];	/* Reserved */
+	/* Left (even TDM Slot) Channel Status Register File*/
+	volatile u32 ditcsra[MAX_DIT_LEFT_CHAN_STAT_COUNT];
+	/* Right (odd TDM slot) Channel Status RegisterFile*/
+	volatile u32 ditcsrb[MAX_DIT_RIGHT_CHAN_STAT_COUNT];
+	/* Left (even TDM slot) User Data Register File */
+	volatile u32 ditudra[MAX_LEFT_USR_DATA_REG_FILE];
+	/* Right (odd TDM Slot) User Data Register File */
+	volatile u32 ditudrb[MAX_RIGHT_USR_DATA_REG_FILE];
+	volatile u32 rsvd_160_17c[8];	/* Reserved */
+	volatile u32 xrsrctl[MAX_SERIALIZER_COUNT];	/* Serializer n Control
+							 * Register */
+	volatile u32 rsvd_1c0_1fc[16];	/* Reserved */
+	volatile u32 txbuf[MAX_SERIALIZER_COUNT];	/* Transmit Buffer for
+							 * Serializer n */
+	volatile u32 rsvd_240_27c[16];	/* Reserved */
+	volatile u32 rxbuf[MAX_SERIALIZER_COUNT];	/* Receive Buffer for
+							 * Serializer n */
+} mcasp_registers_t;
+
+typedef struct __mcasp_info {
+	    /* Set -1 to indicate an unsupported or uninitialized feature */
+    s8 id;
+    u32 reg_base;
+    u32 tx_data_port;
+    u32 rx_data_port;
+    s8 tx_dma_evt;
+    s8 rx_dma_evt;
+    s8 tx_irq;
+    s8 rx_irq;
+    s8 serializer_count;
+    s8 left_dit_channel_count;
+    s8 right_dit_channel_count;
+    const char *lpsc;		/* Initialize this to NULL if there is no LPSC
+				   domain to be initialized. Sometimes this init
+				   of the power domain could be done by some
+				   other portion of the BSP (eg: U-boot) or
+				   sometime the module might not need any LPSC
+				   to be initializd. */
+    s8 flags;
+} mcasp_info_t;
+
+typedef struct __mcasp_unit {
+    struct list_head list;
+    struct __mcasp_info info;
+    struct mcasp_registers config;
+    struct clk *clock;
+    u32 sample_rate;
+    atomic_t init;
+    atomic_t rx_in_use;
+    atomic_t tx_in_use;
+} mcasp_unit_t;
+
+typedef struct __mcasp_device {
+	u8 count;
+	struct list_head *mcasp_list;	/* Points to the list of mcasp's */
+} mcasp_device_t;
+
+/* Register Bits */
+#define BIT(n) (1<<n)
+
+/* PWREMUMGT Power Down and Emulation Management Register Bits */
+#define FREE         BIT(0)
+#define SOFT         BIT(1)
+
+/* Pin Function / GPIO Enable Register Bits */
+#define AXR(n)       (1<<n)
+#define PFUNC_AMUTE  BIT(25)
+#define ACLKX        BIT(26)
+#define AHCLKX       BIT(27)
+#define AFSX         BIT(28)
+#define ACLKR        BIT(29)
+#define AHCLKR       BIT(30)
+#define AFSR         BIT(31)
+
+/* Pin Direction Register Bits */
+#define AXR(n)       (1<<n)
+#define PDIR_AMUTE   BIT(25)
+#define ACLKX        BIT(26)
+#define AHCLKX       BIT(27)
+#define AFSX         BIT(28)
+#define ACLKR        BIT(29)
+#define AHCLKR       BIT(30)
+#define AFSR         BIT(31)
+
+/* Transmit DIT Control Register Bits */
+#define DITEN        BIT(0)	/* Transmit DIT mode enable/disable */
+#define VA           BIT(2)
+#define VB           BIT(3)
+
+/* Transmit Bitstream Format Register Bits */
+#define TXROT(val)   (val)
+#define TXSEL        BIT(3)
+#define TXSSZ(val)   (val<<4)
+#define TXPBIT(val)  (val<<8)
+#define TXPAD(val)   (val<<13)
+#define TXORD        BIT(15)
+#define FSXDLY(val)  (val<<16)
+
+/* Receive Bitstream Format Register Bits */
+#define RXROT(val)   (val)
+#define RXSEL        BIT(3)
+#define RXSSZ(val)   (val<<4)
+#define RXPBIT(val)  (val<<8)
+#define RXPAD(val)   (val<<13)
+#define RXORD        BIT(15)
+#define FSRDLY(val)  (val<<16)
+
+/* Transmit Frame Control Register Bits */
+#define FSXPOL       BIT(0)
+#define AFSXE        BIT(1)
+#define FSXDUR       BIT(4)
+#define FSXMOD(val)  (val<<7)
+
+/* Receive Frame Control Register Bits */
+#define FSRPOL       BIT(0)
+#define AFSRE        BIT(1)
+#define FSRDUR       BIT(4)
+#define FSRMOD(val)  (val<<7)
+
+/* Transmit Clock Control Register Bits */
+#define ACLKXDIV(val) (val)
+#define ACLKXE       BIT(5)
+#define TX_ASYNC     BIT(6)
+#define ACLKXPOL     BIT(7)
+
+/* Receive Clock Control Register Bits */
+#define ACLKRDIV(val) (val)
+#define ACLKRE       BIT(5)
+#define ACLKRPOL     BIT(7)
+
+/* High Frequency Transmit Clock Control Register Bits */
+#define AHCLKXDIV(val) (val)
+#define AHCLKXPOL    BIT(14)
+#define AHCLKXE      BIT(15)
+
+/* High Frequency Receive Clock Control Register Bits */
+#define AHCLKRDIV(val) (val)
+#define AHCLKRPOL    BIT(14)
+#define AHCLKRE      BIT(15)
+
+/* Serializer Control Register Bits */
+#define MODE(val)    (val)
+#define DISMOD(val)  (val<<2)
+#define TXSTATE      BIT(4)
+#define RXSTATE      BIT(5)
+
+/* Loop Back Control Register Bits */
+#define LBEN         BIT(0)
+#define LBORD        BIT(1)
+#define LBGENMODE(val) (val<<2)
+
+/* Transmit TDM Slot Register configuration */
+#define TXTDMS(n)    (1<<n)
+
+/* Receive TDM Slot Register configuration */
+#define RXTDMS(n)    (1<<n)
+
+/* Global Control Register Bits */
+#define RXCLKRST     BIT(0)	/* Receiver Clock Divider Reset */
+#define RXHCLKRST    BIT(1)	/* Receiver High Frequency Clock Divider */
+#define RXSERCLR     BIT(2)	/* Receiver Serializer Clear */
+#define RXSMRST      BIT(3)	/* Receiver State Machine Reset */
+#define RXFSRST      BIT(4)	/* Frame Sync Generator Reset */
+#define TXCLKRST     BIT(8)	/* Transmitter Clock Divider Reset */
+#define TXHCLKRST    BIT(9)	/* Transmitter High Frequency Clock Divider
+				 * and Transmit Bad Clock Detect /32 Counter
+				 * Reset */
+#define TXSERCLR     BIT(10)	/* Transmit Serializer Clear */
+#define TXSMRST      BIT(11)	/* Transmitter State Machine Reset */
+#define TXFSRST      BIT(12)	/* Frame Sync Generator Reset */
+
+/* Mute Control Register Bits */
+#define MUTENA(val)  (val)
+#define MUTEINPOL    BIT(2)
+#define MUTEINENA    BIT(3)
+#define MUTEIN       BIT(4)
+#define MUTER        BIT(5)
+#define MUTEX        BIT(6)
+#define MUTEFSR      BIT(7)
+#define MUTEFSX      BIT(8)
+#define MUTEBADCLKR  BIT(9)
+#define MUTEBADCLKX  BIT(10)
+#define MUTERXDMAERR BIT(11)
+#define MUTETXDMAERR BIT(12)
+
+/* Transmitter Event Control Register Bits */
+#define TXUNDRNINTENA BIT(0)
+#define TXUNFSRINTENA BIT(1)
+#define TXBADCLKINTENA BIT(2)
+#define TXDMAERRINTENA BIT(3)
+#define TXLASTINTENA  BIT(4)
+#define TXDATAINTENA  BIT(5)
+#define TXSOFINTENA   BIT(7)
+
+/* Receiver Event Control Register Bits */
+#define RXOVRNINTENA BIT(0)
+#define RXUNFSRINTENA BIT(1)
+#define RXBADCLKINTENA BIT(2)
+#define RXDMAERRINTENA BIT(3)
+#define RXLASTINTENA BIT(4)
+#define RXDATAINTENA BIT(5)
+#define RXSOFINTENA  BIT(7)
+
+/* Transmitter Status Register bits. All are not defined */
+#define TXBADCLK     BIT(2)
+
+/* Receiver Status Register bits. All are not defined */
+#define RXBADCLK     BIT(2)
+
+/* Transmit Clock Check Control Register Bits */
+#define TXPS(val)    (val)
+#define TXBADSW      BIT(7)
+#define TXMIN(val)   (val<<8)
+#define TXMAX(val)   (val<<16)
+#define TXCOUNT(val) (val<<24)
+
+/* Receiver Clock Check Control Register Bits */
+#define RXPS(val)    (val)
+#define RXMIN(val)   (val<<8)
+#define RXMAX(val)   (val<<16)
+#define RXCOUNT(val) (val<<24)
+
+/* Receiver DMA Event Control Register bits */
+#define RXDATADMADIS BIT(0)
+
+/* Transmitter DMA Event Control Register bits */
+#define TXDATADMADIS BIT(0)
+
+struct clk *mcasp_get_clock(u8 mcasp_id);
+s8 mcasp_get_free (void);
+s8 mcasp_get(u8 mcasp_id);
+s8 mcasp_put(u8 mcasp_id);
+s8 mcasp_stop_rx (u8 mcasp_id);
+s8 mcasp_stop_tx (u8 mcasp_id);
+s8 mcasp_stop(u8 mcasp_id);
+s8 mcasp_start(u8 mcasp_id);
+s8 mcasp_start_tx (u8 mcasp_id);
+s8 mcasp_start_rx (u8 mcasp_id);
+s8 mcasp_configure(u8 mcasp_id, void *mcasp_config);
+s8 mcasp_stop_tx (u8 mcasp_id);
+s8 mcasp_reg_configure (u8 mcasp_id, void *cfg);
+void *mcasp_get_info (u8 mcasp_id);
+void *mcasp_get_config (u8 mcasp_id);
+s8 mcasp_unconfigure(u8 mcasp_id);
+s8 mcasp_dev_init(u8 mcasp_count, void *mcasp_info);
+s8 mcasp_dev_deinit(u8 mcasp_id);
+s32 mcasp_set_sample_rate(u8 id, u32 sample_rate);
+s32 mcasp_get_sample_rate(u8 id);
+#endif				/* __ASM_ARM_MCASP_H__ */
Index: linux-2.6.10/sound/oss/Kconfig
===================================================================
--- linux-2.6.10.orig/sound/oss/Kconfig
+++ linux-2.6.10/sound/oss/Kconfig
@@ -1151,34 +1151,12 @@ config SOUND_SH_DAC_AUDIO_CHANNEL
 	default "1"
 	depends on SOUND_SH_DAC_AUDIO
 
-config SOUND_DAVINCI
-	tristate "DaVinci Sound Driver"
-	depends on ARCH_DAVINCI && SOUND_PRIME!=n && SOUND
-	---help---
-	DaVinci Sound driver
 
-config SOUND_DAVINCI_TLV320AIC33
-       tristate "TLV320AIC33 Stereo Codec"
-       depends on SOUND_DAVINCI
-       select SENSORS_TLV320AIC33
-       ---help---
-         If you say yes here you get support for the I2C control
-         interface for Texas Instruments TLV320AIC33 audio codec.
-
-menu "DaVinci Audio Options"
-	depends on SOUND_DAVINCI
-
-choice
-	prompt "Mono/Stereo Jack Support"
-	default MONOSTEREO_SAMEJACK
-
-config MONOSTEREO_DIFFJACK
-	bool "Mono and Stereo on different jacks"
-
-config MONOSTEREO_SAMEJACK
-	bool "Mono and Stereo on same jacks"
-
-endchoice
-
-endmenu
+comment "Audio options for Davinci DM646x based systems will be visible only if the Davinci DM646x based system EVM is selected"
+	depends !MACH_DAVINCI_HD_EVM
+source "sound/oss/dm646x/Kconfig"
+
+comment "Audio options for Davinci DM644x based systems will be visible only if the Davinci DM644x based system EVM is selected"
+	depends !MACH_DAVINCI_EVM
+source "sound/oss/dm644x/Kconfig"
 
Index: linux-2.6.10/sound/oss/Makefile
===================================================================
--- linux-2.6.10.orig/sound/oss/Makefile
+++ linux-2.6.10/sound/oss/Makefile
@@ -12,9 +12,6 @@ obj-$(CONFIG_SOUND_OMAP)        += omap-
 obj-$(CONFIG_SOUND_OMAP_TSC2101)+= omap-audio-tsc2101.o
 obj-$(CONFIG_SOUND_OMAP_TLV320AIC23) += omap-audio-aic23.o
 
-obj-$(CONFIG_SOUND_DAVINCI)	+= davinci-audio-dma-intfc.o davinci-audio.o
-obj-$(CONFIG_SOUND_DAVINCI_TLV320AIC33) += davinci-audio-aic33.o
-
 # Please leave it as is, cause the link order is significant !
 
 obj-$(CONFIG_SOUND_SH_DAC_AUDIO)	+= sh_dac_audio.o
@@ -98,6 +95,8 @@ endif
 obj-$(CONFIG_SOUND_EMU10K1)	+= emu10k1/
 obj-$(CONFIG_SOUND_CS4281)	+= cs4281/
 obj-$(CONFIG_DMASOUND)		+= dmasound/
+obj-$(CONFIG_SOUND_DAVINCI)	+= dm644x/
+obj-$(CONFIG_SOUND_DAVINCI_HD)	+= dm646x/
 
 # Declare multi-part drivers.
 
Index: linux-2.6.10/sound/oss/davinci-aic33.h
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-aic33.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * linux/sound/oss/davinci-aic33.h
- *
- * Glue driver for AIC33 for Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *  -------
- *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x Processor
- */
-
-#ifndef __ASM_ARCH_AIC33_H
-#define __ASM_ARCH_AIC33_H
-
-/* Codec TLV320AIC33 */
-#define REGISTER_ADDR0  0x00
-#define REGISTER_ADDR1          0x01
-#define REGISTER_ADDR2          0x02
-#define REGISTER_ADDR3          0x03
-#define REGISTER_ADDR4          0x04
-#define REGISTER_ADDR5          0x05
-#define REGISTER_ADDR6          0x06
-#define REGISTER_ADDR7          0x07
-#define REGISTER_ADDR8          0x08
-#define REGISTER_ADDR9          0x09
-#define REGISTER_ADDR10         0x0A
-#define REGISTER_ADDR11         0x0B
-#define REGISTER_ADDR12         0x0C
-#define REGISTER_ADDR15         0x0F
-#define REGISTER_ADDR16         0x10
-#define REGISTER_ADDR17         0x11
-#define REGISTER_ADDR18         0x12
-#define REGISTER_ADDR19         0x13
-#define REGISTER_ADDR20         0x14
-#define REGISTER_ADDR21         0x15
-#define REGISTER_ADDR22         0x16
-#define REGISTER_ADDR23         0x17
-#define REGISTER_ADDR24         0x18
-#define REGISTER_ADDR25         0x19
-#define REGISTER_ADDR26         0x1A
-#define REGISTER_ADDR27         0x1B
-#define REGISTER_ADDR28         0x1C
-#define REGISTER_ADDR29         0x1D
-#define REGISTER_ADDR30         0x1E
-#define REGISTER_ADDR31         0x1F
-#define REGISTER_ADDR32         0x20
-#define REGISTER_ADDR33         0x21
-#define REGISTER_ADDR37         0x25
-#define REGISTER_ADDR38         0x26
-#define REGISTER_ADDR40         0x28
-#define REGISTER_ADDR41         0x29
-#define REGISTER_ADDR43         0x2B
-#define REGISTER_ADDR44         0x2C
-#define REGISTER_ADDR45         0x2D
-#define REGISTER_ADDR46         0x2E
-#define REGISTER_ADDR47         0x2F
-#define REGISTER_ADDR51         0x33
-#define REGISTER_ADDR58         0x3A
-#define REGISTER_ADDR64         0x40
-#define REGISTER_ADDR65         0x41
-#define REGISTER_ADDR73         0x49
-#define REGISTER_ADDR74         0x4A
-#define REGISTER_ADDR75         0x4B
-#define REGISTER_ADDR76         0x4C
-#define REGISTER_ADDR77         0x4D
-#define REGISTER_ADDR78         0x4E
-#define REGISTER_ADDR79         0x4F
-#define REGISTER_ADDR80         0x50
-#define REGISTER_ADDR81         0x51
-#define REGISTER_ADDR82         0x52
-#define REGISTER_ADDR83         0x53
-#define REGISTER_ADDR84         0x54
-#define REGISTER_ADDR85         0x55
-#define REGISTER_ADDR86         0x56
-#define REGISTER_ADDR87         0x57
-#define REGISTER_ADDR88         0x58
-#define REGISTER_ADDR89         0x59
-#define REGISTER_ADDR90         0x5A
-#define REGISTER_ADDR91         0x5B
-#define REGISTER_ADDR92         0x5C
-#define REGISTER_ADDR93         0x5D
-#define REGISTER_ADDR94         0x5E
-
-// Page Select register 0
-#define PAGE_SELECT0            0
-#define PAGE_SELECT1            1
-
-// Software reset register 1
-#define SOFT_RESET              0x80
-
-// Codec sample rate select register 2
-#define ADC_FS_MAX              0xA0
-#define ADC_FS_MIN              0x00
-
-#define DAC_FS_MAX              0x0A
-#define DAC_FS_MIN              0x00
-
-// PLL Programming registerA 3
-#define PLL_ENABLE              0x80
-
-// Codec Datapath setup register 7
-#define FS_REF_44_1             0x80
-#define FS_REF_DEFAULT_48       0x00
-#define ADC_DUAL_RATE_MODE      0x40
-#define DAC_DUAL_RATE_MODE      0x20
-#define LDAC_LCHAN              0x08
-#define LDAC_RCHAN              0x10
-#define LDAC_MONO_MIX           0x18
-
-#define RDAC_RCHAN              0x02
-#define RDAC_LCHAN              0x04
-#define RDAC_MONO_MIX           0x06
-
-//Audio serial data interface control registerA 8
-#define BIT_CLK_MASTER          0x80
-#define WORD_CLK_MASTER         0x40
-#define DOUT_TRI_STATE          0x20
-#define CLK_TRANS_MASTER        0x10
-#define ENABLE_3D               0x04
-#define DM_ENABLE_128           0x01
-#define DM_ENABLE_64            0x02
-#define DM_ENABLE_32            0x03
-
-//Audio serial data interface control registerB 9
-#define DSP_MODE                0x40
-#define RJ_MODE                 0x80
-#define LJ_MODE                 0xC0
-#define WORD_LENGTH20           0x10
-#define WORD_LENGTH24           0x20
-#define WORD_LENGTH32           0x30
-#define BITCLOCK_256CLK_FRAME   0x08
-
-//Left/Right ADC PGA gain control register 15 & 16
-#define ADC_PGA_MUTE            0x80
-#define ADC_PGA_GAIN_MAX        0x78
-#define ADC_PGA_GAIN_MIN        0x00
-
-// MIC3L/R to left/right ADC control register 17 & 18
-#define ADCPGA_GAIN_MAX         0x00
-#define MIC3L_ADCPGA_GAIN_MIN   0x80
-#define MIC3L_ADCPGA_DISCONNECT 0xF0
-
-#define MIC3R_ADCPGA_GAIN_MIN   0x08
-#define MIC3R_ADCPGA_DISCONNECT 0x0F
-
-//LINE1L to left ADC Control Register 19
-#define DIFF_MODE               0x80
-#define LINE_ADCPGA_GAIN_MIN    0x40
-#define LINE_ADCPGA_DISCONNECT  0x78
-#define ADC_CHAN_ON             0x04
-#define ADCPGA_SOFT_STEP2FS     0x01
-#define ADCPGA_SOFT_STEP_OFF    0x03
-
-//LINE2L to left ADC Control Register 20
-#define ADC_WEAK_INPUT_BIAS     0x04
-
-//MICBIAS control register 25
-#define MICBIAS_OUTPUT_2_0V     0x40
-#define MICBIAS_OUTPUT_2_5V     0x80
-#define MICBIAS_OUTPUT_AVDD     0xC0
-
-//LEFT/RIGHT AGC Control registerA 26 & 29
-#define AGC_ENABLE              0x80
-#define AGC_TARGET_GAIN_MAX     0x00
-#define AGC_TARGET_GAIN_MIN     0x70
-#define AGC_ATTACK_TIME_11      0x04
-#define AGC_ATTACK_TIME_16      0x08
-#define AGC_ATTACK_TIME_20      0x0C
-#define AGC_DECAY_TIME_200      0x01
-#define AGC_DECAY_TIME_400      0x02
-#define AGC_DECAY_TIME_500      0x03
-
-//LEFT AGC Control registerB 27 & 30
-#define AGC_GAIN_ALLOWED_MAX    0xEE
-#define AGC_GAIN_ALLOWED_MIN    0x00
-
-//DAC Power and output driver control register 37
-#define LEFT_DAC_POWER_ON       0x80
-#define RIGHT_DAC_POWER_ON      0x40
-
-//High Power Output Stage Control Register 40
-#define LINE2L_BYPASS_DISABLE_DEFAULT    0x00
-#define LINE2LP_BYPASS_SINGLE            0x10
-#define LINE2LM_BYPASS_SINGLE            0x20
-#define LINE2LPM_BYPASS_DIFFERENTIAL     0x30
-
-#define LINE2R_BYPASS_DISABLE_DEFAULT    0x00
-#define LINE2RP_BYPASS_SINGLE            0x04
-#define LINE2RM_BYPASS_SINGLE            0x08
-#define LINE2RPM_BYPASS_DIFFERENTIAL     0x0C
-
-//DAC Output Switching Control Register 41
-#define LEFT_DAC_DEFAULT_L1     0x00
-#define LEFT_DAC_L2             0x80
-#define LEFT_DAC_L3             0x40
-#define RIGHT_DAC_DEFAULT_R1    0x00
-#define RIGHT_DAC_R2            0x08
-#define RIGHT_DAC_R3            0x04
-
-//LEFT/RIGHT DAC Digital volume control register 43 & 44
-#define DAC_CHAN_MUTE            0x80
-#define DAC_DIG_VOL_GAIN_MAX     0x00	// 0.0db
-#define DAC_DIG_VOL_GAIN_MIN     0x7F	// -63.5db
-
-//LINE2L to HPLOUT Volume Control Register 45
-#define LINE2L_HPLOUT_ROUTED              0x80
-
-//PGA_L to HPLOUT Volume Control Register 46
-#define PGAL_HPLOUT_ROUTED                0x80
-
-//any to LOP/M Volume control
-#define LOPM_ON                 0x80
-#define LOPM_VOL_GAIN_MAX       0x00	//0 db
-#define LOPM_VOL_GAIN_MIN       0x76	//-78.3 db is MUTE
-
-//MONO_LOP/M output level volume control register 79
-#define LOPM_POWER_ON            0x01
-#define LOPM_MUTE_OFF            0x08
-#define LOPM_OUTPUT_LEVEL_MIN    0x00
-#define LOPM_OUTPUT_LEVEL_MAX    0x90
-
-//Module Power Status Register 94
-#define HPROUT_DRIVER_POWER_ON           0x02
-
-#define LIV_MAX                         0x0077
-#define LIV_MIN                         0x0000
-
-#define LHV_MAX                         0x0077
-#define LHV_MIN                         0x0000
-
-#define LIG_MAX							0x0077
-#define LIG_MIN							0x0000
-
-#define LOG_MAX							0x007f
-#define LOG_MIN							0x0000
-
-#endif				/* __ASM_ARCH_AIC33_H */
Index: linux-2.6.10/sound/oss/davinci-audio-aic33.c
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-audio-aic33.c
+++ /dev/null
@@ -1,1101 +0,0 @@
-/*
- * linux/sound/oss/davinci-audio-aic33.c
- *
- * Glue driver for AIC33 for Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *  -------
- *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x Processor
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/errno.h>
-#include <linux/sound.h>
-#include <linux/soundcard.h>
-#include <sound/davincisound.h>
-
-#include <asm/uaccess.h>
-#include <asm/hardware.h>
-#include <asm/io.h>
-#include <asm/mach-types.h>
-
-#include <asm/arch/mcbsp.h>
-#include <asm/hardware/clock.h>
-#include "davinci-aic33.h"
-
-#include "davinci-audio.h"
-#include "davinci-audio-dma-intfc.h"
-
-#ifdef CONFIG_PROC_FS
-#include <linux/proc_fs.h>
-#define PROC_START_FILE "driver/aic33-audio-start"
-#define PROC_STOP_FILE  "driver/aic33-audio-stop"
-#endif
-
-//#define DEBUG
-
-#ifdef DEBUG
-#define DPRINTK(ARGS...)        do { \
-                                        printk("<%s>: ",__FUNCTION__);printk(ARGS); \
-                                } while (0)
-#else
-#define DPRINTK( x... )
-#endif
-
-#define CODEC_NAME               "AIC33"
-#define PLATFORM_NAME            "DAVINCI"
-
-/* Define to set the AIC33 as the master w.r.t McBSP */
-#define AIC33_MASTER
-
-/* codec clock frequency */
-#define MCLK  22
-
-/*
- * AUDIO related MACROS
- */
-#define DEFAULT_BITPERSAMPLE          16
-#define AUDIO_RATE_DEFAULT            48000
-#define DEFAULT_MCBSP_CLOCK           81000000
-
-/* Select the McBSP For Audio */
-#define AUDIO_MCBSP                   DAVINCI_MCBSP1
-
-#define REC_MASK                      (SOUND_MASK_LINE | SOUND_MASK_MIC)
-#define DEV_MASK                      (REC_MASK | SOUND_MASK_VOLUME)
-
-#define MONO			      1
-#define STEREO			      2
-
-#define SET_VOLUME                    1
-#define SET_LINE                      2
-#define SET_MIC                       3
-#define SET_RECSRC		      4
-#define SET_IGAIN		      5
-#define SET_OGAIN		      6
-#define SET_BASS                      7
-#define SET_TREBLE                    8
-#define SET_MICBIAS		      9
-
-#define DEFAULT_OUTPUT_VOLUME         70
-#define DEFAULT_INPUT_VOLUME          20	/* 0 ==> mute line in */
-#define DEFAULT_INPUT_IGAIN	      20
-#define DEFAULT_INPUT_OGAIN	      100
-
-#define OUTPUT_VOLUME_MIN             LHV_MIN
-#define OUTPUT_VOLUME_MAX             LHV_MAX
-#define OUTPUT_VOLUME_RANGE           (OUTPUT_VOLUME_MAX - OUTPUT_VOLUME_MIN)
-
-#define INPUT_VOLUME_MIN              LIV_MIN
-#define INPUT_VOLUME_MAX              LIV_MAX
-#define INPUT_VOLUME_RANGE            (INPUT_VOLUME_MAX - INPUT_VOLUME_MIN)
-
-#define INPUT_GAIN_MIN		      LIG_MIN
-#define INPUT_GAIN_MAX		      LIG_MAX
-#define INPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
-
-#define OUTPUT_GAIN_MIN		      LOG_MIN
-#define OUTPUT_GAIN_MAX		      LOG_MAX
-#define OUTPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
-
-#define NUMBER_SAMPLE_RATES_SUPPORTED 11
-
-static audio_stream_t output_stream = {
-	.id = "AIC33 out",
-	.dma_dev = DAVINCI_DMA_MCBSP1_TX,
-	.input_or_output = FMODE_WRITE
-};
-
-static audio_stream_t input_stream = {
-	.id = "AIC33 in",
-	.dma_dev = DAVINCI_DMA_MCBSP1_RX,
-	.input_or_output = FMODE_READ
-};
-
-static int audio_dev_id, mixer_dev_id;
-
-static struct aic33_local_info {
-	u8 volume;
-	u16 volume_reg;
-	u8 line;
-	u8 mic;
-	int recsrc;
-	u8 nochan;
-	u16 igain;
-	u16 ogain;
-	u8 micbias;
-	u8 bass;
-	u8 treble;
-	u16 input_volume_reg;
-	int mod_cnt;
-} aic33_local;
-
-struct sample_rate_reg_info {
-	u32 sample_rate;
-	u32 Fsref;
-	float divider;
-	u8 data;
-};
-
-/* To Store the default sample rate */
-static long audio_samplerate = AUDIO_RATE_DEFAULT;
-
-extern struct clk *davinci_mcbsp_get_clock(void);
-
-/* DAC USB-mode sampling rates*/
-static const struct sample_rate_reg_info
- reg_info[NUMBER_SAMPLE_RATES_SUPPORTED] = {
-/*  {sample_rate, Fsref, divider, data}*/
-	{96000, 96000, 1, 0x00},
-	{88200, 88200, 1, 0x00},
-	{48000, 48000, 1, 0x00},
-	{44100, 44100, 1, 0x00},
-	{32000, 48000, 1.5, 0x11},
-	{24000, 96000, 4, 0x66},
-	{22050, 44100, 2, 0x22},
-	{16000, 48000, 3, 0x44},
-	{12000, 48000, 4, 0x66},
-	{11025, 44100, 4, 0x66},
-	{8000, 48000, 6, 0xAA},
-};
-
-static struct davinci_mcbsp_reg_cfg initial_config = {
-	.spcr2 = FREE | XINTM(3),
-	.spcr1 = RINTM(3),
-	.rcr2 = RWDLEN2(DAVINCI_MCBSP_WORD_16) | RDATDLY(1),
-	.rcr1 = RFRLEN1(1) | RWDLEN1(DAVINCI_MCBSP_WORD_16),
-	.xcr2 = XWDLEN2(DAVINCI_MCBSP_WORD_16) | XDATDLY(1) | XFIG,
-	.xcr1 = XFRLEN1(1) | XWDLEN1(DAVINCI_MCBSP_WORD_16),
-	.srgr1 = FWID(DEFAULT_BITPERSAMPLE - 1),
-	.srgr2 = FSGM | FPER(DEFAULT_BITPERSAMPLE * 2 - 1),
-#ifndef AIC33_MASTER
-	/* configure McBSP to be the I2S master */
-	.pcr0 = FSXM | FSRM | CLKXM | CLKRM | CLKXP | CLKRP,
-#else
-	/* configure McBSP to be the I2S slave */
-	.pcr0 = CLKXP | CLKRP,
-#endif				/* AIC33_MASTER */
-};
-
-static void davinci_aic33_initialize(void *dummy);
-static void davinci_aic33_shutdown(void *dummy);
-static int davinci_aic33_ioctl(struct inode *inode, struct file *file,
-			       uint cmd, ulong arg);
-static int davinci_aic33_probe(void);
-
-#ifdef MODULE
-static void davinci_aic33_remove(void);
-#endif
-
-static int davinci_aic33_suspend(void);
-static int davinci_aic33_resume(void);
-static inline void aic33_configure(void);
-static int mixer_open(struct inode *inode, struct file *file);
-static int mixer_release(struct inode *inode, struct file *file);
-static int mixer_ioctl(struct inode *inode, struct file *file, uint cmd,
-		       ulong arg);
-
-#ifdef CONFIG_PROC_FS
-static int codec_start(char *buf, char **start, off_t offset, int count,
-		       int *eof, void *data);
-static int codec_stop(char *buf, char **start, off_t offset, int count,
-		      int *eof, void *data);
-#endif
-
-/* File Op structure for mixer */
-static struct file_operations davinci_mixer_fops = {
-	.open = mixer_open,
-	.release = mixer_release,
-	.ioctl = mixer_ioctl,
-	.owner = THIS_MODULE
-};
-
-/* To store characteristic info regarding the codec for the audio driver */
-static audio_state_t aic33_state = {
-	.owner = THIS_MODULE,
-	.output_stream = &output_stream,
-	.input_stream = &input_stream,
-/*    .need_tx_for_rx = 1, //Once the Full Duplex works  */
-	.need_tx_for_rx = 0,
-	.hw_init = davinci_aic33_initialize,
-	.hw_shutdown = davinci_aic33_shutdown,
-	.client_ioctl = davinci_aic33_ioctl,
-	.hw_probe = davinci_aic33_probe,
-	.hw_remove = __exit_p(davinci_aic33_remove),
-	.hw_suspend = davinci_aic33_suspend,
-	.hw_resume = davinci_aic33_resume,
-	.sem = __COMPAT_MUTEX_INITIALIZER(aic33_state.sem),
-};
-
-/* This will be defined in the audio.h */
-static struct file_operations *davinci_audio_fops;
-
-extern int tlv320aic33_write_value(u8 reg, u16 value);
-extern int tlv320aic33_read_value(u8 address, u8 * regValue);
-
-/* TLV320AIC33 read */
-static __inline__ void audio_aic33_read(u8 address, u8 * regValue)
-{
-	tlv320aic33_read_value(address, regValue);
-}
-
-/* TLV320AIC33 write */
-static __inline__ void audio_aic33_write(u8 address, u16 data)
-{
-	if (tlv320aic33_write_value(address, data) < 0)
-		printk(KERN_INFO "aic33 write failed for reg = %d\n", address);
-}
-
-static int aic33_update(int flag, int val)
-{
-	u16 volume;
-	s16 left_gain, left_val, right_gain, right_val;
-
-	switch (flag) {
-	case SET_VOLUME:
-		/* Ignore separate left/right channel for now,
-	   	   even the codec does support it. */
-		val &= 0xff;
-
-		if (val < 0 || val > 100) {
-			DPRINTK("Trying a bad volume value(%d)!\n", val);
-			return -EPERM;
-		}
-		// Convert 0 -> 100 volume to 0x77 (LHV_MIN) -> 0x00 (LHV_MAX)
-		volume =
-		    ((val * OUTPUT_VOLUME_RANGE) / 100) + OUTPUT_VOLUME_MIN;
-
-		aic33_local.volume_reg = OUTPUT_VOLUME_MAX - volume;
-
-		if (aic33_local.nochan == STEREO) {
-			audio_aic33_write(47, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(64, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(82, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(92, LOPM_ON | aic33_local.volume_reg);
-		} else if (aic33_local.nochan == MONO) {
-#ifdef CONFIG_MONOSTEREO_DIFFJACK
-			/* DACL1 to MONO_LOP/M routing and volume control */
-			audio_aic33_write(75, LOPM_ON | aic33_local.volume_reg);
-
-			/* DACR1 to MONO_LOP/M routing and volume control */
-			audio_aic33_write(78, LOPM_ON | aic33_local.volume_reg);
-#else
-			audio_aic33_write(47, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(64, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(82, LOPM_ON | aic33_local.volume_reg);
-			audio_aic33_write(92, LOPM_ON | aic33_local.volume_reg);
-#endif
-		}
-
-		break;
-
-	case SET_LINE:
-	case SET_MIC:
-		/* Ignore separate left/right channel for now,
-	   	   even the codec does support it. */
-		val &= 0xff;
-
-		if (val < 0 || val > 100) {
-			DPRINTK("Trying a bad volume value(%d)!\n", val);
-			return -EPERM;
-		}
-
-		volume = ((val * INPUT_VOLUME_RANGE) / 100) + INPUT_VOLUME_MIN;
-
-		aic33_local.input_volume_reg = volume;
-
-		audio_aic33_write(15, aic33_local.input_volume_reg);
-		audio_aic33_write(16, aic33_local.input_volume_reg);
-
-		break;
-
-	case SET_RECSRC:
-		/* Ignore separate left/right channel for now,
-	   	   even the codec does support it. */
-		val &= 0xff;
-
-		if (hweight32(val) > 1)
-			val &= ~aic33_local.recsrc;
-
-		if (val == SOUND_MASK_MIC) {
-			/* enable the mic input*/
-			DPRINTK("Enabling mic\n");
-			audio_aic33_write(17, 0x0);
-			audio_aic33_write(18, 0x0);
-
-			/* enable ADC's and disable the line input*/
-			audio_aic33_write(19, 0x7C);
-			audio_aic33_write(22, 0x7C);
-
-		}
-		else if (val == SOUND_MASK_LINE) {
-			/* enable ADC's, enable line iput */
-			DPRINTK(" Enabling line in\n");
-			audio_aic33_write(19, 0x4);
-			audio_aic33_write(22, 0x4);
-
-			/* disable the mic input */
-			audio_aic33_write(17, 0xff);
-			audio_aic33_write(18, 0xff);
-		}
-		else {
-			/* do nothing */
-		}
-		aic33_local.recsrc = val;
-		break;
-
-	case SET_IGAIN:
-		left_val = val & 0xFF;
-		right_val = val >> 8;
-
-		if (left_val < 0 || left_val > 100) {
-			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
-			return -EPERM;
-		}
-		if (right_val < 0 || right_val > 100) {
-			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
-			return -EPERM;
-		}
-
-		left_gain = ((left_val * INPUT_GAIN_RANGE) / 100) + INPUT_GAIN_MIN;
-		right_gain = ((right_val * INPUT_GAIN_RANGE) / 100) + INPUT_GAIN_MIN;
-
-		DPRINTK("left gain reg val = 0x%x", left_gain << 1);
-		DPRINTK("right gain reg val = 0x%x", left_gain << 1);
-
-		/* Left AGC control */
-		audio_aic33_write(26, 0x80);
-		audio_aic33_write(27, left_gain << 1);
-		audio_aic33_write(28, 0x0);
-
-		/* Right AGC control */
-		audio_aic33_write(29, 0x80);
-		audio_aic33_write(30, right_gain << 1);
-		audio_aic33_write(31, 0x0);
-
-		break;
-
-	case SET_OGAIN:
-		left_val = val & 0xFF;
-		right_val = val >> 8;
-
-		if (left_val < 0 || left_val > 100) {
-			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
-			return -EPERM;
-		}
-		if (right_val < 0 || right_val > 100) {
-			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
-			return -EPERM;
-		}
-
-		left_gain = ((left_val * OUTPUT_GAIN_RANGE) / 100) + OUTPUT_GAIN_MIN;
-		left_gain = OUTPUT_GAIN_MAX - left_gain;
-		right_gain = ((right_val * OUTPUT_GAIN_RANGE) / 100) + OUTPUT_GAIN_MIN;
-		right_gain = OUTPUT_GAIN_MAX - right_gain;
-
-		/* Left/Right DAC digital volume gain */
-		audio_aic33_write(43, left_gain);
-		audio_aic33_write(44, right_gain);
-		break;
-
-	case SET_MICBIAS:
-		/* Ignore separate left/right channel for now,
-	   	   even the codec does support it. */
-		val &= 0xff;
-
-		if (val < 0 || val > 3) {
-			DPRINTK
-			    ("Request for non supported mic bias level(%d)!\n",
-			     val);
-			return -EPERM;
-		}
-
-		if (val == 0)
-			audio_aic33_write(25, 0x00);
-
-		else if (val == 1)
-			audio_aic33_write(25, MICBIAS_OUTPUT_2_0V);
-
-		else if (val == 2)
-			audio_aic33_write(25, MICBIAS_OUTPUT_2_5V);
-
-		else if (val == 3)
-			audio_aic33_write(25, MICBIAS_OUTPUT_AVDD);
-
-		break;
-
-	case SET_BASS:
-		break;
-
-	case SET_TREBLE:
-		break;
-	}
-	return 0;
-}
-
-static int mixer_open(struct inode *inode, struct file *file)
-{
-	/* Any mixer specific initialization */
-	return 0;
-}
-
-static int mixer_release(struct inode *inode, struct file *file)
-{
-	/* Any mixer specific Un-initialization */
-	return 0;
-}
-
-static int
-mixer_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
-{
-	int val;
-	int ret = 0;
-	int nr = _IOC_NR(cmd);
-
-	/*
-	 * We only accept mixer (type 'M') ioctls.
-	 */
-	if (_IOC_TYPE(cmd) != 'M')
-		return -EINVAL;
-
-	DPRINTK(" 0x%08x\n", cmd);
-
-	if (cmd == SOUND_MIXER_INFO) {
-		struct mixer_info mi;
-
-		strncpy(mi.id, "AIC33", sizeof(mi.id));
-		strncpy(mi.name, "TI AIC33", sizeof(mi.name));
-		mi.modify_counter = aic33_local.mod_cnt;
-
-		return copy_to_user((void *)arg, &mi, sizeof(mi));
-	}
-
-	if (_IOC_DIR(cmd) & _IOC_WRITE) {
-		ret = get_user(val, (int *)arg);
-		if (ret)
-			goto out;
-
-		switch (nr) {
-		case SOUND_MIXER_VOLUME:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_VOLUME, val);
-			if (!ret)
-				aic33_local.volume = val;
-			break;
-
-		case SOUND_MIXER_LINE:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_LINE, val);
-			if (!ret)
-				aic33_local.line = val;
-			break;
-
-		case SOUND_MIXER_MIC:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_MIC, val);
-			if (!ret)
-				aic33_local.mic = val;
-			break;
-
-		case SOUND_MIXER_RECSRC:
-			if ((val & SOUND_MASK_LINE) ||
-			    (val & SOUND_MASK_MIC)) {
-				if (aic33_local.recsrc != val) {
-					aic33_local.mod_cnt++;
-					aic33_update(SET_RECSRC, val);
-				}
-			}
-			else {
-				ret = -EINVAL;
-			}
-			break;
-
-		case SOUND_MIXER_BASS:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_BASS, val);
-			if (!ret)
-				aic33_local.bass = val;
-			break;
-
-		case SOUND_MIXER_TREBLE:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_TREBLE, val);
-			if (!ret)
-				aic33_local.treble = val;
-			break;
-
-		case SOUND_MIXER_IGAIN:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_IGAIN, val);
-			if (!ret)
-				aic33_local.igain = val;
-			break;
-
-		case SOUND_MIXER_OGAIN:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_OGAIN, val);
-			if (!ret)
-				aic33_local.ogain = val;
-			break;
-
-		case SOUND_MIXER_MICBIAS:
-			aic33_local.mod_cnt++;
-			ret = aic33_update(SET_MICBIAS, val);
-			if (!ret)
-				aic33_local.micbias = val;
-			break;
-
-		default:
-			ret = -EINVAL;
-		}
-	}
-
-	if (ret == 0 && _IOC_DIR(cmd) & _IOC_READ) {
-		ret = 0;
-
-		switch (nr) {
-		case SOUND_MIXER_VOLUME:
-			val = aic33_local.volume;
-			break;
-		case SOUND_MIXER_LINE:
-			val = aic33_local.line;
-			break;
-		case SOUND_MIXER_MIC:
-			val = aic33_local.mic;
-			break;
-		case SOUND_MIXER_RECSRC:
-			val = aic33_local.recsrc;
-			break;
-		case SOUND_MIXER_RECMASK:
-			val = REC_MASK;
-			break;
-		case SOUND_MIXER_IGAIN:
-			val = aic33_local.igain;
-			break;
-		case SOUND_MIXER_OGAIN:
-			val = aic33_local.ogain;
-			break;
-		case SOUND_MIXER_DEVMASK:
-			val = DEV_MASK;
-			break;
-		case SOUND_MIXER_BASS:
-			val = aic33_local.bass;
-			break;
-		case SOUND_MIXER_TREBLE:
-			val = aic33_local.treble;
-			break;
-		case SOUND_MIXER_CAPS:
-			val = 0;
-			break;
-		case SOUND_MIXER_STEREODEVS:
-			val = SOUND_MASK_VOLUME;
-			break;
-		case SOUND_MIXER_MICBIAS:
-			val = aic33_local.micbias;
-			break;
-		default:
-			val = 0;
-			ret = -EINVAL;
-			break;
-		}
-
-		if (ret == 0)
-			ret = put_user(val, (int *)arg);
-	}
-      out:
-	return ret;
-}
-
-int davinci_set_samplerate(long sample_rate)
-{
-	u8 count = 0;
-
-	/* wait for any frame to complete */
-	udelay(125);
-
-	/* Search for the right sample rate */
-	while ((reg_info[count].sample_rate != sample_rate) &&
-	       (count < NUMBER_SAMPLE_RATES_SUPPORTED)) {
-		count++;
-	}
-
-	if (count == NUMBER_SAMPLE_RATES_SUPPORTED) {
-		DPRINTK("Invalid Sample Rate %d requested\n", (int)sample_rate);
-		return -EPERM;
-	}
-
-	/*   CODEC DATAPATH SETUP  */
-
-	/* Fsref to 48kHz, dual rate mode upto 96kHz */
-	if (reg_info[count].Fsref == 96000)
-		audio_aic33_write(7,
-				  FS_REF_DEFAULT_48 | ADC_DUAL_RATE_MODE |
-				  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
-
-	/* Fsref to 44.1kHz, dual rate mode upto 88.2kHz */
-	else if (reg_info[count].Fsref == 88200)
-		audio_aic33_write(7,
-				  FS_REF_44_1 | ADC_DUAL_RATE_MODE |
-			  	  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
-
-	/* Fsref to 48kHz */
-	else if (reg_info[count].Fsref == 48000)
-		audio_aic33_write(7,
-				  FS_REF_DEFAULT_48 | LDAC_LCHAN | RDAC_RCHAN);
-
-	/* Fsref to 44.1kHz */
-	else if (reg_info[count].Fsref == 44100)
-		audio_aic33_write(7, FS_REF_44_1 | LDAC_LCHAN | RDAC_RCHAN);
-
-
-	/* Codec sample rate select */
-	audio_aic33_write(2, reg_info[count].data);
-
-	/* If PLL is to be used for generation of Fsref
-	   Generate the Fsref using the PLL */
-#if(MCLK==33)
-
-	if ((reg_info[count].Fsref == 96000) | (reg_info[count].Fsref == 48000)) {
-		/* For MCLK = 33.8688 MHz and to get Fsref = 48kHz
-		   Fsref = (MCLK * k * R)/(2048 * p);
-		   Select P = 2, R= 1, K = 5.8049, which results in J = 5, D = 8049 */
-
-		/*Enable the PLL | Q-value | P-value */
-		audio_aic33_write(3, PLL_ENABLE | 0x10 | 0x02);
-		audio_aic33_write(4, 0x14);	/* J-value */
-		audio_aic33_write(5, 0x7D);	/* D-value 8-MSB's */
-		audio_aic33_write(6, 0x04);	/* D-value 6-LSB's */
-
-	}
-
-	else if ((reg_info[count].Fsref == 88200) | (reg_info[count].Fsref ==
-						     44100)) {
-
-		/* MCLK = 33.8688 MHz and to get Fsref = 44.1kHz
-		   Fsref = (MCLK * k * R)/(2048 * p);
-		   Select P = 2, R =1, K = 5.3333, which results in J = 5, D = 3333 */
-
-		/*Enable the PLL | Q-value | P-value */
-		audio_aic33_write(3, PLL_ENABLE | 0x10 | 0x02);
-		audio_aic33_write(4, 0x14);	/* J-value */
-		audio_aic33_write(5, 0x34);	/* D-value 8-MSB's */
-		audio_aic33_write(6, 0x14);	/* D-value 6-LSB's */
-	}
-#elif(MCLK==22)
-
-	if ((reg_info[count].Fsref == 96000) | (reg_info[count].Fsref == 48000)) {
-		/* For MCLK = 22.5792 MHz and to get Fsref = 48kHz
-		   Fsref = (MCLK * k * R)/(2048 * p);
-		   Select P = 2, R= 1, K = 8.7075, which results in J = 8, D = 7075 */
-
-		/*Enable the PLL | Q-value | P-value */
-		audio_aic33_write(3, PLL_ENABLE | 0x10 | 0x02);
-		audio_aic33_write(4, (8 << 2));	/* J-value */
-		audio_aic33_write(5, (unsigned char)(7075 >> 6));	/* D-value 8-MSB's */
-		audio_aic33_write(6, (unsigned char)(7075 << 2));	/* D-value 6-LSB's */
-
-	}
-
-	else if ((reg_info[count].Fsref == 88200) | (reg_info[count].Fsref ==
-						     44100)) {
-
-		/* MCLK = 22.5792 MHz and to get Fsref = 44.1kHz
-		   Fsref = (MCLK * k * R)/(2048 * p);
-		   Select P = 2, R =1, K = 8.0000, which results in J = 8, D = 0000 */
-
-		/*Enable the PLL | Q-value | P-value */
-		audio_aic33_write(3, PLL_ENABLE | 0x10 | 0x02);
-		audio_aic33_write(4, (8 << 2));	/* J-value */
-		audio_aic33_write(5, 0x00);	/* D-value 8-MSB's */
-		audio_aic33_write(6, 0x00);	/* D-value 6-LSB's */
-	}
-#else
-#error "unknown audio codec frequency"
-#endif
-
-	audio_samplerate = sample_rate;
-
-#ifndef AIC33_MASTER
-	{
-		int clkgdv = 0;
-		unsigned long clkval = 0;
-		struct clk *mbspclk;
-
-		/*
-		   Set Sample Rate at McBSP
-
-		   Formula :
-		   Codec System Clock = Input clock to McBSP;
-		   clkgdv = ((Codec System Clock / (SampleRate * BitsPerSample * 2)) - 1);
-
-		   FWID = BitsPerSample - 1;
-		   FPER = (BitsPerSample * 2) - 1;
-		 */
-
-		mbspclk = davinci_mcbsp_get_clock();
-		if (mbspclk == NULL) {
-			DPRINTK(" Failed to get internal clock to MCBSP");
-			return -EPERM;
-		}
-
-		clkval = clk_get_rate(mbspclk);
-		DPRINTK("mcbsp_clk = %ld\n", clkval);
-
-		if (clkval)
-			clkgdv =
-			    (clkval /
-			     (sample_rate * DEFAULT_BITPERSAMPLE * 2)) - 1;
-		else {
-			DPRINTK(" Failed to get the MCBSP clock\n");
-			return -EPERM;
-		}
-
-		DPRINTK("clkgdv = %d\n", clkgdv);
-
-		if (clkgdv > 255 || clkgdv < 0) {
-
-			/* For requested sampling rate, the input clock to MCBSP cant be devided
-			   down to get the in range clock devider value for 16 bits sample */
-			DPRINTK("Invalid Sample Rate %d requested\n",
-				(int)sample_rate);
-			return -EPERM;
-		}
-
-		initial_config.srgr1 =
-		    (FWID(DEFAULT_BITPERSAMPLE - 1) | CLKGDV(clkgdv));
-
-		initial_config.srgr2 =
-		    (CLKSM | FSGM | FPER(DEFAULT_BITPERSAMPLE * 2 - 1));
-
-		davinci_mcbsp_stop_tx(AUDIO_MCBSP);
-		davinci_mcbsp_stop_rx(AUDIO_MCBSP);
-		davinci_mcbsp_config(AUDIO_MCBSP, &initial_config);
-	}
-#endif				/* AIC33_MASTER */
-
-	return 0;
-}
-
-static void davinci_aic33_shutdown(void *dummy)
-{
-	/*
-	   Turn off codec after it is done.
-	   Can't do it immediately, since it may still have
-	   buffered data.
-
-	   Wait 20ms (arbitrary value) and then turn it off.
-	 */
-
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule_timeout(2);
-
-	davinci_mcbsp_stop_tx(AUDIO_MCBSP);
-	davinci_mcbsp_stop_rx(AUDIO_MCBSP);
-	davinci_mcbsp_free(AUDIO_MCBSP);
-
-	/* Self clearing aic33 software reset */
-	audio_aic33_write(1, 0x80);
-}
-
-static void davinci_set_mono_stereo(int mode)
-{
-	if (mode == MONO) {
-
-#ifdef CONFIG_MONOSTEREO_DIFFJACK
-		/* MONO_LOP/M Output level control register */
-		audio_aic33_write(79, 0x99);
-#else
-		/* Driver power ON pop control */
-		audio_aic33_write(42, 0x6C);
-
-		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
-		audio_aic33_write(86, 0x99);
-		audio_aic33_write(93, 0x99);
-#endif
-		/* Left DAC power up, Right DAC power down */
-		audio_aic33_write(37, 0xa0);
-	} else if (mode == STEREO) {
-		/* Driver power ON pop control */
-		audio_aic33_write(42, 0x6C);
-
-		/* HPLOUT/HPROUT output level control */
-		audio_aic33_write(51, 0x99);
-		audio_aic33_write(65, 0x99);
-
-		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
-		audio_aic33_write(86, 0x99);
-		audio_aic33_write(93, 0x99);
-
-		/* Left/Right DAC power up */
-		audio_aic33_write(37, 0xe0);
-	} else
-		DPRINTK(" REQUEST FOR INVALID MODE\n");
-}
-
-static inline void aic33_configure()
-{
-	DPRINTK(" CONFIGURING AIC33\n");
-
-	/* Page select register */
-	audio_aic33_write(0, 0x0);
-
-	//audio_aic33_write(38, 0x10);
-
-	davinci_set_mono_stereo(aic33_local.nochan);
-
-#ifdef AIC33_MASTER
-	/* Enable bit and word clock as Master mode, 3-d disabled */
-	audio_aic33_write(8, 0xc0 /*0xc4 */ );
-#endif
-
-	aic33_update(SET_LINE, aic33_local.line);
-	aic33_update(SET_VOLUME, aic33_local.volume);
-	aic33_update(SET_RECSRC, aic33_local.recsrc);
-	aic33_update(SET_IGAIN, aic33_local.igain);
-	aic33_update(SET_OGAIN, aic33_local.ogain);
-	aic33_update(SET_MICBIAS, aic33_local.micbias);
-}
-
-static void davinci_aic33_initialize(void *dummy)
-{
-	DPRINTK("entry\n");
-
-	/* initialize with default sample rate */
-	audio_samplerate = AUDIO_RATE_DEFAULT;
-
-	if (davinci_mcbsp_request(AUDIO_MCBSP) < 0) {
-		DPRINTK("MCBSP request failed\n");
-		return;
-	}
-
-	/* if configured, then stop mcbsp */
-	davinci_mcbsp_stop_tx(AUDIO_MCBSP);
-	davinci_mcbsp_stop_rx(AUDIO_MCBSP);
-
-	/* set initial (default) sample rate */
-	davinci_set_samplerate(audio_samplerate);
-
-	davinci_mcbsp_config(AUDIO_MCBSP, &initial_config);
-
-	DPRINTK("exit\n");
-}
-
-static int
-davinci_aic33_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
-{
-	long val;
-	int ret = 0;
-
-	DPRINTK(" 0x%08x\n", cmd);
-
-	/*
-	 * These are platform dependent ioctls which are not handled by the
-	 * generic davinci-audio module.
-	 */
-	switch (cmd) {
-	case SNDCTL_DSP_STEREO:
-		ret = get_user(val, (int *)arg);
-		if (ret)
-			return ret;
-		/* the Davinci supports AIC33 as stereo, mono on stereo jack */
-		ret = (val == 0) ? -EINVAL : 1;
-		return put_user(ret, (int *)arg);
-
-	case SNDCTL_DSP_CHANNELS:
-
-		ret = get_user(val, (long *)arg);
-		if (ret) {
-			DPRINTK("get_user failed\n");
-			break;
-		}
-		if (val == STEREO) {
-			DPRINTK("Driver support for AIC33 as stereo\n");
-			aic33_local.nochan = STEREO;
-			davinci_set_mono_stereo(aic33_local.nochan);
-		} else if (val == MONO) {
-			DPRINTK("Driver support for AIC33 as mono\n");
-			aic33_local.nochan = MONO;
-			davinci_set_mono_stereo(aic33_local.nochan);
-		} else {
-			DPRINTK
-			    ("Driver support for AIC33 as stereo/mono mode\n");
-			return -EPERM;
-		}
-
-	case SOUND_PCM_READ_CHANNELS:
-		/* the Davinci supports AIC33 as stereo, mono on stereo jack */
-		if (aic33_local.nochan == MONO)
-			return put_user(MONO, (long *)arg);
-		else
-			return put_user(STEREO, (long *)arg);
-
-	case SNDCTL_DSP_SPEED:
-		ret = get_user(val, (long *)arg);
-		if (ret) {
-			DPRINTK("get_user failed\n");
-			break;
-		}
-		ret = davinci_set_samplerate(val);
-		if (ret) {
-			DPRINTK("davinci_set_samplerate failed\n");
-			break;
-		}
-		/* fall through */
-
-	case SOUND_PCM_READ_RATE:
-		return put_user(audio_samplerate, (long *)arg);
-
-	case SNDCTL_DSP_SETFMT:	/* set Format */
-		ret = get_user(val, (long *)arg);
-		if (ret) {
-			DPRINTK("get_user failed\n");
-			break;
-		}
-		if (val != AFMT_S16_LE) {
-			DPRINTK
-			    ("Driver supports only AFMT_S16_LE audio format\n");
-			return -EPERM;
-		}
-
-	case SOUND_PCM_READ_BITS:
-	case SNDCTL_DSP_GETFMTS:
-		/* we can do 16-bit only */
-		return put_user(AFMT_S16_LE, (long *)arg);
-
-	default:
-		/* Maybe this is meant for the mixer (As per OSS Docs) */
-		return mixer_ioctl(inode, file, cmd, arg);
-	}
-
-	return ret;
-}
-
-static int davinci_aic33_probe(void)
-{
-	/* Get the fops from audio oss driver */
-	if (!(davinci_audio_fops = audio_get_fops())) {
-		DPRINTK
-		    ("Unable to get the file operations for AIC33 OSS driver\n");
-		audio_unregister_codec(&aic33_state);
-		return -EPERM;
-	}
-
-	aic33_local.volume = DEFAULT_OUTPUT_VOLUME;
-	aic33_local.line = DEFAULT_INPUT_VOLUME;
-	aic33_local.recsrc = SOUND_MASK_LINE;	/* either of SOUND_MASK_LINE/SOUND_MASK_MIC */
-	aic33_local.igain = DEFAULT_INPUT_IGAIN | (DEFAULT_INPUT_IGAIN << 8);
-	aic33_local.ogain = DEFAULT_INPUT_OGAIN | (DEFAULT_INPUT_OGAIN << 8);
-	aic33_local.nochan = STEREO;
-	aic33_local.micbias = 1;
-	aic33_local.mod_cnt = 0;
-
-	/* register devices */
-	audio_dev_id = register_sound_dsp(davinci_audio_fops, -1);
-	mixer_dev_id = register_sound_mixer(&davinci_mixer_fops, -1);
-
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry(PROC_START_FILE, 0 /* default mode */ ,
-			       NULL /* parent dir */ ,
-			       codec_start, NULL /* client data */ );
-
-	create_proc_read_entry(PROC_STOP_FILE, 0 /* default mode */ ,
-			       NULL /* parent dir */ ,
-			       codec_stop, NULL /* client data */ );
-#endif
-
-	/* Announcement Time */
-	DPRINTK(PLATFORM_NAME " " CODEC_NAME " audio support initialized\n");
-	return 0;
-}
-
-#ifdef MODULE
-static void __exit davinci_aic33_remove(void)
-{
-	/* Un-Register the codec with the audio driver */
-	unregister_sound_dsp(audio_dev_id);
-	unregister_sound_mixer(mixer_dev_id);
-
-#ifdef CONFIG_PROC_FS
-	remove_proc_entry(PROC_START_FILE, NULL);
-	remove_proc_entry(PROC_STOP_FILE, NULL);
-#endif
-}
-#endif				/* MODULE */
-
-static int davinci_aic33_suspend(void)
-{
-	/* Empty for the moment */
-	return 0;
-}
-
-static int davinci_aic33_resume(void)
-{
-	/* Empty for the moment */
-	return 0;
-}
-
-static int __init audio_aic33_init(void)
-{
-	int err = 0;
-
-	/* register the codec with the audio driver */
-	if ((err = audio_register_codec(&aic33_state))) {
-		DPRINTK
-		    ("Failed to register AIC33 driver with Audio OSS Driver\n");
-	} else {
-		DPRINTK("codec driver register success\n");
-	}
-
-	/* configure aic33 with default params */
-	aic33_configure();
-
-	return err;
-}
-
-static void __exit audio_aic33_exit(void)
-{
-	davinci_aic33_shutdown(NULL);
-	(void)audio_unregister_codec(&aic33_state);
-	return;
-}
-
-#ifdef CONFIG_PROC_FS
-static int codec_start(char *buf, char **start, off_t offset, int count,
-		       int *eof, void *data)
-{
-	davinci_aic33_initialize(NULL);
-
-	DPRINTK("AIC33 codec initialization done.\n");
-	return 0;
-}
-
-static int codec_stop(char *buf, char **start, off_t offset, int count,
-		      int *eof, void *data)
-{
-	davinci_aic33_shutdown(NULL);
-
-	DPRINTK("AIC33 codec shutdown.\n");
-	return 0;
-}
-#endif				/* CONFIG_PROC_FS */
-
-module_init(audio_aic33_init);
-module_exit(audio_aic33_exit);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("Glue audio driver for the TI AIC33 codec.");
-MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/davinci-audio-dma-intfc.c
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-audio-dma-intfc.c
+++ /dev/null
@@ -1,1041 +0,0 @@
-
-/*
- * linux/sound/oss/davinci-audio-dma-intfc.c
- *
- * Common audio DMA handling for the Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *
- * 2004-06-07   Sriram Kannan   - Created new file from omap_audio_dma_intfc.c. This file
- *                                will contain only the DMA interface and buffer handling of OMAP
- *                                audio driver.
- *
- * 2004-06-22   Sriram Kannan   - removed legacy code (auto-init). Self-linking of DMA logical channel.
- *
- * 2004-08-12   Nishanth Menon  - Modified to integrate Audio requirements on 1610,1710 platforms
- *
- * 2004-11-01   Nishanth Menon  - 16xx platform code base modified to support multi channel chaining.
- *
- * 2004-12-15   Nishanth Menon  - Improved 16xx platform channel logic introduced - tasklets, queue handling updated
- *
- * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI Davinci DM644x processor
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/poll.h>
-#include <linux/pm.h>
-#include <linux/errno.h>
-#include <linux/sound.h>
-#include <linux/soundcard.h>
-#include <linux/sysrq.h>
-#include <linux/interrupt.h>
-#include <linux/dma-mapping.h>
-#include <linux/completion.h>
-#include <linux/delay.h>
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/semaphore.h>
-#include <asm/delay.h>
-
-#include <asm/arch/mcbsp.h>
-#include <asm/arch/edma.h>
-#include <asm/arch/memory.h>
-
-#include "davinci-audio-dma-intfc.h"
-#include "davinci-audio.h"
-
-#undef DEBUG
-//#define DEBUG
-#ifdef DEBUG
-#define DPRINTK(ARGS...)  printk(KERN_INFO "<%s>: ",__FUNCTION__);printk(ARGS)
-#define FN_IN printk(KERN_INFO "[%s]: start\n", __FUNCTION__)
-#define FN_OUT(n) printk(KERN_INFO "[%s]: end(%u)\n",__FUNCTION__, n)
-#else
-
-#define DPRINTK( x... )
-#define FN_IN
-#define FN_OUT(x)
-#endif
-
-#define ERR(ARGS...) printk(KERN_ERR "{%s}-ERROR: ", __FUNCTION__);printk(ARGS);
-
-#define AUDIO_NAME                  "davinci-audio"
-#define MCBSP_DXR   0x01E02004
-#define MCBSP_DRR   0x01E02000
-
-#define AUDIO_ACTIVE(state)     ((state)->rd_ref || (state)->wr_ref)
-
-#define SPIN_ADDR                    (dma_addr_t)0
-#define SPIN_SIZE                    2048
-
-#define NUMBER_OF_CHANNELS_TO_LINK  2
-
-/* Channel Queue Handling macros
- * tail always points to the current free entry
- * Head always points to the current entry being used
- * end is either head or tail
- */
-#define AUDIO_QUEUE_INIT(s) s->dma_q_head = s->dma_q_tail = s->dma_q_count = 0;
-#define AUDIO_QUEUE_FULL(s) (NUMBER_OF_CHANNELS_TO_LINK == s->dma_q_count)
-#define AUDIO_QUEUE_LAST(s) (1 == s->dma_q_count)
-#define AUDIO_QUEUE_EMPTY(s) (0 == s->dma_q_count)
-#define __AUDIO_INCREMENT_QUEUE(end) ((end)=((end)+1)%NUMBER_OF_CHANNELS_TO_LINK)
-#define AUDIO_INCREMENT_HEAD(s) __AUDIO_INCREMENT_QUEUE(s->dma_q_head);\
-                                                      s->dma_q_count--;
-#define AUDIO_INCREMENT_TAIL(s) __AUDIO_INCREMENT_QUEUE(s->dma_q_tail);\
-                                                      s->dma_q_count++;
-
-/* DMA buffer fragmentation sizes */
-#define MAX_DMA_SIZE         (0xffff*2)
-#define CUT_DMA_SIZE         MAX_DMA_SIZE
-
-/**************************** DATA STRUCTURES *********************************/
-
-struct audio_isr_work_item {
-	int current_lch;
-	u16 ch_status;
-	audio_stream_t *s;
-};
-
-static char work_item_running = 0;
-static struct audio_isr_work_item work1, work2;
-
-/*********************** MODULE SPECIFIC FUNCTIONS PROTOTYPES ****************/
-
-static void audio_dsr_handler(unsigned long);
-DECLARE_TASKLET(audio_isr_work1, audio_dsr_handler, (unsigned long)&work1);
-DECLARE_TASKLET(audio_isr_work2, audio_dsr_handler, (unsigned long)&work2);
-
-static void sound_dma_irq_handler(int lch, u16 ch_status, void *data);
-static void audio_dma_callback(int lch, u16 ch_status, void *data);
-static int davinci_start_sound_dma(audio_stream_t * s, dma_addr_t dma_ptr,
-				   u_int size);
-static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
-				     u_int dma_size);
-static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
-					u_int dma_size);
-static int audio_start_dma_chain(audio_stream_t * s);
-
-/************************** GLOBAL FUNCTIONS DEFINTIONS ***********************/
-
-/*******************************************************************************
- *
- * Buffer creation/destruction
- *
- ******************************************************************************/
-int audio_setup_buf(audio_stream_t * s)
-{
-	int frag;
-	int dmasize = 0;
-	char *dmabuf = NULL;
-	dma_addr_t dmaphys = 0;
-	FN_IN;
-
-	if (s->buffers) {
-		FN_OUT(1);
-		return -EBUSY;
-	}
-
-	/* Allocate memory for all buffer fragments */
-	s->buffers = kmalloc(sizeof(audio_buf_t) * s->nbfrags, GFP_KERNEL);
-	if (!s->buffers)
-		goto err;
-
-	/* Initialise all the memory to 0 */
-	memset(s->buffers, 0, sizeof(audio_buf_t) * s->nbfrags);
-
-	for (frag = 0; frag < s->nbfrags; frag++) {
-		audio_buf_t *b = &s->buffers[frag];
-
-		/*
-		 * Let's allocate non-cached memory for DMA buffers.
-		 * We try to allocate all memory at once.
-		 * If this fails (a common reason is memory fragmentation),
-		 * then we allocate more smaller buffers.
-		 */
-		if (!dmasize) {
-			dmasize = (s->nbfrags - frag) * s->fragsize;
-			do {
-				/* allocate consistent memory for DMA
-				   dmaphys(handle)= device viewed address.
-				   dmabuf = CPU-viewed address */
-				dmabuf =
-				    dma_alloc_coherent(NULL, dmasize, &dmaphys,
-						       0);
-
-				/* For allocating the IRAM memory */
-				//dmaphys = (dma_addr_t)(DAVINCI_IRAM_BASE + 0x1000);
-				//dmabuf = (DAVINCI_IRAM_VIRT + 0x1000);
-				if (!dmabuf)
-					dmasize -= s->fragsize;
-			}
-			while (!dmabuf && dmasize);
-
-			if (!dmabuf)
-				goto err;
-
-			b->master = dmasize;
-			memzero(dmabuf, dmasize);
-		}
-		b->data = dmabuf;
-		b->dma_addr = dmaphys;
-		dmabuf += s->fragsize;
-		dmaphys += s->fragsize;
-		dmasize -= s->fragsize;
-	}
-	s->usr_head = s->dma_head = s->dma_tail = 0;
-	AUDIO_QUEUE_INIT(s);
-	s->started = 0;
-	s->mcbsp_tx_started = 0;
-	s->mcbsp_rx_started = 0;
-
-	s->dma_started = 0;
-	s->bytecount = 0;
-	s->fragcount = 0;
-	s->prevbuf = 0;
-
-	init_completion(&s->wfc);
-	s->wfc.done = s->nbfrags;
-
-	FN_OUT(0);
-	return 0;
-      err:
-	audio_discard_buf(s);
-	FN_OUT(1);
-	return -ENOMEM;
-}
-
-void audio_discard_buf(audio_stream_t * s)
-{
-	FN_IN;
-	/* ensure DMA isn't using those buffers */
-	audio_reset(s);
-	if (s->buffers) {
-		int frag;
-		for (frag = 0; frag < s->nbfrags; frag++) {
-			if (!s->buffers[frag].master)
-				continue;
-
-			dma_free_coherent(NULL,
-					  s->buffers[frag].master,
-					  s->buffers[frag].data,
-					  s->buffers[frag].dma_addr);
-
-		}
-		kfree(s->buffers);
-		s->buffers = NULL;
-	}
-	FN_OUT(0);
-}
-
-/*******************************************************************************
- *
- * DMA channel requests
- *
- ******************************************************************************/
-int
-davinci_request_sound_dma(int device_id, const char *device_name, void *data,
-			  int *master_ch, int **channels)
-{
-	int i, err = 0;
-	int *chan = NULL;
-	int tcc;
-
-	FN_IN;
-	if (unlikely((NULL == channels) || (NULL == device_name))) {
-		BUG();
-		return -EPERM;
-	}
-	/* Try allocate memory for the num channels */
-	*channels = (int *)kmalloc(sizeof(int) * NUMBER_OF_CHANNELS_TO_LINK,
-				   GFP_KERNEL);
-	chan = *channels;
-	if (NULL == chan) {
-		ERR("No Memory for channel allocs!\n");
-		FN_OUT(-ENOMEM);
-		return -ENOMEM;
-	}
-
-	/* request for the Master channel and setup the params */
-	i = 0;
-	err = davinci_request_dma(device_id, device_name,
-				  sound_dma_irq_handler, data, master_ch, &tcc,
-				  EVENTQ_0);
-
-	/* Handle Failure condition here */
-	if (err < 0) {
-		ERR("Error in requesting Master channel %d = 0x%x\n", device_id,
-		    err);
-
-		FN_OUT(err);
-		return err;
-
-	}
-
-	DPRINTK("Master chan = %d\n", *master_ch);
-
-	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
-		err = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, device_name,
-					  sound_dma_irq_handler, data, &chan[i],
-					  &tcc, EVENTQ_0);
-
-		/* Handle Failure condition here */
-		if (err < 0) {
-			int j;
-
-			for (j = 0; j < i; j++)
-				davinci_free_dma(chan[j]);
-
-			kfree(chan);
-			*channels = NULL;
-			ERR("Error in requesting channel %d=0x%x\n", i, err);
-			FN_OUT(err);
-			return err;
-		}
-	}
-
-	/* Chain the channels together */
-	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
-		int cur_chan = chan[i];
-		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 ==
-				 i) ? chan[0] : chan[i + 1]);
-		davinci_dma_link_lch(cur_chan, nex_chan);
-	}
-
-	FN_OUT(0);
-	return 0;
-}
-
-/******************************************************************************
- *
- * DMA channel requests Freeing
- *
- ******************************************************************************/
-int davinci_free_sound_dma(int master_ch, int **channels)
-{
-	int i;
-	int *chan = NULL;
-	FN_IN;
-	if (unlikely(NULL == channels)) {
-		BUG();
-		return -EPERM;
-	}
-	if (unlikely(NULL == *channels)) {
-		BUG();
-		return -EPERM;
-	}
-	chan = (*channels);
-
-	/* release the Master channel */
-	davinci_free_dma(master_ch);
-
-	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
-		int cur_chan = chan[i];
-		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 == i) ?
-				chan[0] : chan[i + 1]);
-
-		davinci_dma_unlink_lch(cur_chan, nex_chan);
-		davinci_free_dma(cur_chan);
-	}
-	kfree(*channels);
-	*channels = NULL;
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * Process DMA requests - This will end up starting the transfer.
- * Proper fragments of Transfers will be initiated.
- *
- ******************************************************************************/
-int audio_process_dma(audio_stream_t * s)
-{
-	int ret = 0;
-	unsigned long flags;
-	FN_IN;
-
-	/* Dont let the ISR over ride touching the in_use flag */
-	local_irq_save(flags);
-	if (1 == s->in_use) {
-		local_irq_restore(flags);
-		DPRINTK("Called again while In Use\n");
-		return 0;
-	}
-	s->in_use = 1;
-	local_irq_restore(flags);
-
-	if (s->stopped)
-		goto spin;
-
-	if (s->dma_spinref > 0 && s->pending_frags) {
-		s->dma_spinref = 0;
-		DMA_CLEAR(s);
-	}
-
-	while (s->pending_frags) {
-		audio_buf_t *b = &s->buffers[s->dma_head];
-		u_int dma_size = s->fragsize - b->offset;
-
-		if (dma_size > MAX_DMA_SIZE) {
-			DPRINTK("dma_size > MAX_DMA_SIZE\n");
-			dma_size = CUT_DMA_SIZE;
-		}
-
-		ret = davinci_start_sound_dma(s, b->dma_addr + b->offset,
-					      dma_size);
-		if (ret) {
-			DPRINTK("error\n");
-			goto process_out;
-		}
-
-		b->dma_ref++;
-		b->offset += dma_size;
-		if (b->offset >= s->fragsize) {
-			s->pending_frags--;
-			if (++s->dma_head >= s->nbfrags)
-				s->dma_head = 0;
-		}
-	}
-      spin:
-	if (s->spin_idle) {
-		int spincnt = 0;
-		DPRINTK("we are spinning\n");
-		while (davinci_start_sound_dma(s, SPIN_ADDR, SPIN_SIZE) == 0)
-			spincnt++;
-		/*
-		 * Note: if there is still a data buffer being
-		 * processed then the ref count is negative.  This
-		 * allows for the DMA termination to be accounted in
-		 * the proper order.  Of course dma_spinref can't be
-		 * greater than 0 if dma_ref is not 0 since we kill
-		 * the spinning above as soon as there is real data to process.
-		 */
-		if (s->buffers && s->buffers[s->dma_tail].dma_ref)
-			spincnt = -spincnt;
-		s->dma_spinref += spincnt;
-	}
-
-      process_out:
-	s->in_use = 0;
-
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * Prime Rx - Since the recieve buffer has no time limit as to when it would
- *            arrive, we need to prime it
- *
- ******************************************************************************/
-void audio_prime_rx(audio_state_t * state)
-{
-	audio_stream_t *is = state->input_stream;
-
-	FN_IN;
-	if (state->need_tx_for_rx) {
-		/*
-		 * With some codecs like the Philips UDA1341 we must ensure
-		 * there is an output stream at any time while recording since
-		 * this is how the UDA1341 gets its clock from the SA1100.
-		 * So while there is no playback data to send, the output DMA
-		 * will spin with all zeroes.  We use the cache flush special
-		 * area for that.
-		 */
-		state->output_stream->spin_idle = 1;
-		audio_process_dma(state->output_stream);
-	}
-	is->pending_frags = is->nbfrags;
-
-	init_completion(&is->wfc);
-	is->wfc.done = 0;
-
-	is->active = 1;
-	audio_process_dma(is);
-
-	FN_OUT(0);
-	return;
-}
-
-/*******************************************************************************
- *
- * set the fragment size
- *
- ******************************************************************************/
-int audio_set_fragments(audio_stream_t * s, int val)
-{
-	FN_IN;
-	if (s->active)
-		return -EBUSY;
-	if (s->buffers)
-		audio_discard_buf(s);
-	s->nbfrags = (val >> 16) & 0x7FFF;
-	val &= 0xFFFF;
-	if (val < 4)
-		val = 4;
-	if (val > 15)
-		val = 15;
-	s->fragsize = 1 << val;
-	if (s->nbfrags < 2)
-		s->nbfrags = 2;
-	if (s->nbfrags * s->fragsize > 128 * 1024)
-		s->nbfrags = 128 * 1024 / s->fragsize;
-	FN_OUT(0);
-	if (audio_setup_buf(s))
-		return -ENOMEM;
-	return val | (s->nbfrags << 16);
-
-}
-
-/*******************************************************************************
- *
- * Sync up the buffers before we shutdown, else under-run errors will happen
- *
- ******************************************************************************/
-int audio_sync(struct file *file)
-{
-	audio_state_t *state = file->private_data;
-	audio_stream_t *s = state->output_stream;
-	audio_buf_t *b;
-	u_int shiftval = 0;
-	unsigned long flags;
-
-	DECLARE_WAITQUEUE(wait, current);
-
-	FN_IN;
-
-	if (!(file->f_mode & FMODE_WRITE) || !s->buffers || s->mapped) {
-		FN_OUT(1);
-		return 0;
-	}
-
-	/*
-	 * Send current buffer if it contains data.  Be sure to send
-	 * a full sample count.
-	 */
-	b = &s->buffers[s->usr_head];
-	mdelay(20);
-	if (b->offset &= ~3) {
-		/*wait for a buffer to become free */
-		if (wait_for_completion_interruptible(&s->wfc))
-			return 0;
-		/*
-		 * HACK ALERT !
-		 * To avoid increased complexity in the rest of the code
-		 * where full fragment sizes are assumed, we cheat a little
-		 * with the start pointer here and don't forget to restore
-		 * it later.
-		 */
-		shiftval = s->fragsize - b->offset;
-		b->offset = shiftval;
-		b->dma_addr -= shiftval;
-		b->data -= shiftval;
-		local_irq_save(flags);
-		s->bytecount -= shiftval;
-		if (++s->usr_head >= s->nbfrags)
-			s->usr_head = 0;
-
-		s->pending_frags++;
-		audio_process_dma(s);
-		local_irq_restore(flags);
-	}
-
-	/* Let's wait for all buffers to complete */
-	set_current_state(TASK_INTERRUPTIBLE);
-	add_wait_queue(&s->wq, &wait);
-
-	while ((s->pending_frags || (s->wfc.done < s->nbfrags))
-	       && !signal_pending(current)) {
-		schedule();
-		set_current_state(TASK_INTERRUPTIBLE);
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&s->wq, &wait);
-
-	/* undo the pointer hack above */
-	if (shiftval) {
-		local_irq_save(flags);
-		b->dma_addr += shiftval;
-		b->data += shiftval;
-		/* ensure sane DMA code behavior if not yet processed */
-		if (b->offset != 0)
-			b->offset = s->fragsize;
-		local_irq_restore(flags);
-	}
-
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * Stop all the DMA channels of the stream
- *
- ******************************************************************************/
-void audio_stop_dma(audio_stream_t * s)
-{
-
-	unsigned long flags;
-	FN_IN;
-	DPRINTK("audio_stop_dma\n");
-
-	if (s->dma_spinref > 0 || !s->buffers)
-		return;
-
-	local_irq_save(flags);
-
-	if(s->mcbsp_tx_started || s->mcbsp_rx_started) {
-		if (s->input_or_output == FMODE_WRITE) {
-			davinci_mcbsp_stop_tx(0);
-			s->mcbsp_tx_started = 0;
-		} else {
-			davinci_mcbsp_stop_rx(0);
-			s->mcbsp_rx_started = 0;
-		}
-	}
-	s->started = 0;
-
-	if (s->spin_idle) {
-#if 0
-		DMA_START(s, SPIN_ADDR, SPIN_SIZE);
-		DMA_START(s, SPIN_ADDR, SPIN_SIZE);
-#endif
-		s->dma_spinref = 2;
-	} else
-		s->dma_spinref = 0;
-
-	local_irq_restore(flags);
-
-	FN_OUT(0);
-	return;
-}
-
-/*******************************************************************************
- *
- * Get the dma posn
- *
- ******************************************************************************/
-u_int audio_get_dma_pos(audio_stream_t * s)
-{
-	audio_buf_t *b = &s->buffers[s->dma_tail];
-	u_int offset = 0;
-
-	FN_IN;
-	if (b->dma_ref) {
-		edmacc_paramentry_regs temp;
-
-		davinci_get_dma_params(s->master_ch, &temp);
-
-		if (s->input_or_output == FMODE_WRITE)
-			offset = temp.src - b->dma_addr;
-		else if (s->input_or_output == FMODE_READ)
-			offset = temp.dst - b->dma_addr;
-		if (offset >= s->fragsize)
-			offset = s->fragsize - 4;
-	} else if (s->pending_frags) {
-		offset = b->offset;
-	} else {
-		offset = 0;
-	}
-	FN_OUT(offset);
-	return offset;
-}
-
-/*******************************************************************************
- *
- * Reset the audio buffers
- *
- ******************************************************************************/
-void audio_reset(audio_stream_t * s)
-{
-	audio_buf_t *b;
-	FN_IN;
-	if (s->buffers) {
-		audio_stop_dma(s);
-		/* back up pointers to be ready to restart from the same spot */
-		while (s->dma_head != s->dma_tail) {
-			b = &s->buffers[s->dma_head];
-			if (b->dma_ref) {
-				b->dma_ref = 0;
-				b->offset = 0;
-			}
-			s->pending_frags++;
-			if (s->dma_head == 0)
-				s->dma_head = s->nbfrags;
-			s->dma_head--;
-		}
-		b = &s->buffers[s->dma_head];
-		if (b->dma_ref) {
-			b->offset = 0;
-			b->dma_ref = 0;
-		}
-
-		s->buffers[s->dma_head].offset = 0;
-		s->buffers[s->usr_head].offset = 0;
-		s->usr_head = s->dma_head;
-		s->pending_frags = 0;
-		init_completion(&s->wfc);
-		s->wfc.done = s->nbfrags;
-	}
-	AUDIO_QUEUE_INIT(s);
-	s->active = 0;
-	s->stopped = 0;
-	s->started = 0;
-	s->dma_started = 0;
-
-	davinci_stop_dma(s->master_ch);
-	FN_OUT(0);
-	return;
-}
-
-/*******************************************************************************
- *
- * Clear any pending transfers
- *
- ******************************************************************************/
-void davinci_clear_sound_dma(audio_stream_t * s)
-{
-#if 0
-	FN_IN;
-	davinci_clear_dma(s->lch[s->dma_q_head]);
-	FN_OUT(0);
-#endif
-	return;
-}
-
-/*******************************************************************************
- *
- * DMA related functions
- *
- ******************************************************************************/
-static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
-				     u_int dma_size)
-{
-	FN_IN;
-	DPRINTK("audio_set_dma_params_play channel = %d dma_ptr = %x \
-                       dma_size=%x\n", channel, dma_ptr, dma_size);
-
-	davinci_set_dma_src_params(channel, (unsigned long)(dma_ptr), 0, 0);
-	davinci_set_dma_dest_params(channel, (unsigned long)MCBSP_DXR, 0, 0);
-	davinci_set_dma_src_index(channel, 2, 0);
-	davinci_set_dma_dest_index(channel, 0, 0);
-	davinci_set_dma_transfer_params(channel, 2, dma_size / 2, 1, 0, ASYNC);
-
-	FN_OUT(0);
-	return 0;
-}
-
-static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
-					u_int dma_size)
-{
-	FN_IN;
-	DPRINTK("audio_set_dma_params_capture channel = %d dma_ptr = %x \
-                      dma_size=%x\n", channel, dma_ptr, dma_size);
-
-	davinci_set_dma_src_params(channel, (unsigned long)MCBSP_DRR, 0, 0);
-	davinci_set_dma_dest_params(channel, (unsigned long)(dma_ptr), 0, 0);
-	davinci_set_dma_src_index(channel, 0, 0);
-	davinci_set_dma_dest_index(channel, 2, 0);
-	davinci_set_dma_transfer_params(channel, 2, dma_size / 2, 1, 0, ASYNC);
-
-	FN_OUT(0);
-	return 0;
-}
-
-static int audio_start_dma_chain(audio_stream_t * s)
-{
-	unsigned long flags;
-	int channel = s->lch[s->dma_q_head];
-	FN_IN;
-
-	if (!s->started) {
-		edmacc_paramentry_regs temp;
-		davinci_get_dma_params(channel, &temp);
-		davinci_set_dma_params(s->master_ch, &temp);
-		s->started = 1;
-
-		if (!s->dma_started) {
-			davinci_start_dma(s->master_ch);
-			s->dma_started = 1;
-		}
-		local_irq_save(flags);
-		if(!s->mcbsp_tx_started || !s->mcbsp_rx_started) {
-			local_irq_restore(flags);
-			if (s->input_or_output == FMODE_WRITE) {
-				davinci_mcbsp_start_tx(0);
-				s->mcbsp_tx_started = 1;
-			} else {
-				davinci_mcbsp_start_rx(0);
-				s->mcbsp_rx_started = 1;
-			}
-			local_irq_restore(flags);
-		} else
-			local_irq_restore(flags);
-	}
-
-	/* else the dma itself will progress forward with out our help */
-	FN_OUT(0);
-	return 0;
-}
-
-/* Start DMA -
- * Do the initial set of work to initialize all the channels as required.
- * We shall then initate a transfer
- */
-
-static int davinci_start_sound_dma(audio_stream_t * s, dma_addr_t dma_ptr,
-				   u_int dma_size)
-{
-	int ret = -EPERM;
-
-	FN_IN;
-	if (unlikely(dma_size > MAX_DMA_SIZE)) {
-		ERR("DmaSoundDma: Start: overflowed %d-%d\n", dma_size,
-		    MAX_DMA_SIZE);
-		return -EOVERFLOW;
-	}
-
-	if (AUDIO_QUEUE_FULL(s)) {
-		DPRINTK("queue full\n");
-		ret = -2;
-		goto sound_out;
-	}
-	if (s->input_or_output == FMODE_WRITE)
-		/*playback */
-	{
-		ret = audio_set_dma_params_play(s->lch[s->dma_q_tail],
-						dma_ptr, dma_size);
-	} else {
-		ret = audio_set_dma_params_capture(s->lch[s->dma_q_tail],
-						   dma_ptr, dma_size);
-	}
-	if (ret != 0) {
-		ret = -2;	/* indicate queue full */
-		goto sound_out;
-	}
-	AUDIO_INCREMENT_TAIL(s);
-	ret = audio_start_dma_chain(s);
-	if (ret) {
-		ERR("dma start failed");
-	}
-      sound_out:
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * ISR related functions
- *
- ******************************************************************************/
-/* The work item handler */
-static void audio_dsr_handler(unsigned long inData)
-{
-	void *data = (void *)inData;
-	struct audio_isr_work_item *work = data;
-	audio_stream_t *s = (work->s);
-	int sound_curr_lch = work->current_lch;
-	u16 ch_status = work->ch_status;
-
-	FN_IN;
-	DPRINTK("lch=%d,status=0x%x, data=%p as=%p\n", sound_curr_lch,
-		ch_status, data, s);
-	if (AUDIO_QUEUE_EMPTY(s)) {
-		DPRINTK("Interrupt(%d)  for empty queue(h=%d, T=%d)???\n",
-			sound_curr_lch, s->dma_q_head, s->dma_q_tail);
-		DPRINTK("nbfrag=%d,pendfrags=%d,USR-H=%d, QH-%d QT-%d\n",
-			s->nbfrags, s->pending_frags, s->usr_head, s->dma_head,
-			s->dma_tail);
-		AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
-		FN_OUT(-1);
-		return;
-	}
-
-	AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
-
-	/* Try to fill again */
-	audio_dma_callback(sound_curr_lch, ch_status, s);
-	FN_OUT(0);
-
-}
-
-/* Macro to trace the IRQ calls - checks for multi-channel irqs */
-//#define IRQ_TRACE
-#ifdef IRQ_TRACE
-#define MAX_UP 10
-static char xyz[MAX_UP] = { 0 };
-static int h = 0;
-#endif
-
-/* ISRs have to be short and smart.. So we transfer every heavy duty stuff to
- * the work item
- */
-static void sound_dma_irq_handler(int sound_curr_lch, u16 ch_status, void *data)
-{
-	audio_stream_t *s = (audio_stream_t *) data;
-	FN_IN;
-
-	if (ch_status == DMA_COMPLETE) {
-
-#ifdef IRQ_TRACE
-		xyz[h++] = '0' + sound_curr_lch;
-		if (h == MAX_UP - 1) {
-			DPRINTK("%s-", xyz);
-			h = 0;
-		}
-#endif
-
-		sound_curr_lch = s->lch[s->dma_q_head];
-
-		DPRINTK("lch=%d,status=0x%x, data=%p\n", sound_curr_lch,
-			ch_status, data);
-
-		if (AUDIO_QUEUE_LAST(s)) {
-			audio_stream_t *s = data;
-			audio_buf_t *b = &s->buffers[s->dma_tail];
-
-			if (s->dma_spinref > 0) {
-				s->dma_spinref--;
-			} else if (!s->buffers) {
-				DPRINTK
-				    ("davinci_audio: received DMA IRQ for non\
-                              existent buffers!\n");
-				return;
-			} else if (b->dma_ref && --b->dma_ref == 0 &&
-				   b->offset >= s->fragsize) {
-				/* This fragment is done */
-				b->offset = 0;
-				s->bytecount += s->fragsize;
-				s->fragcount++;
-				s->dma_spinref = -s->dma_spinref;
-
-				if (++s->dma_tail >= s->nbfrags)
-					s->dma_tail = 0;
-
-				if (!s->mapped) {
-					complete(&s->wfc);
-				} else
-					s->pending_frags++;
-
-				wake_up(&s->wq);
-			}
-
-			AUDIO_INCREMENT_HEAD(s);
-			audio_stop_dma(s);
-			return;
-		}
-
-		/* Start the work item  - we ping pong the work items */
-		if (!work_item_running) {
-			work1.current_lch = sound_curr_lch;
-			work1.ch_status = ch_status;
-			work1.s = s;
-			/* schedule tasklet 1 */
-			tasklet_schedule(&audio_isr_work1);
-			work_item_running = 1;
-		} else {
-			work2.current_lch = sound_curr_lch;
-			work2.ch_status = ch_status;
-			work2.s = s;
-			/* schedule tasklet 2 */
-			tasklet_schedule(&audio_isr_work2);
-			work_item_running = 0;
-		}
-	} else {
-		DPRINTK("Error in DMA \n");
-	}
-
-	FN_OUT(0);
-	return;
-}
-
-/* The call back that handles buffer stuff */
-static void audio_dma_callback(int lch, u16 ch_status, void *data)
-{
-	audio_stream_t *s = data;
-	audio_buf_t *b = &s->buffers[s->dma_tail];
-	FN_IN;
-
-	if (s->dma_spinref > 0) {
-		s->dma_spinref--;
-	} else if (!s->buffers) {
-		DPRINTK
-		    ("davinci_audio: received DMA IRQ for non existent buffers!\n");
-		return;
-	} else if (b->dma_ref && --b->dma_ref == 0 && b->offset >= s->fragsize) {
-		/* This fragment is done */
-		b->offset = 0;
-		s->bytecount += s->fragsize;
-		s->fragcount++;
-		s->dma_spinref = -s->dma_spinref;
-
-		if (++s->dma_tail >= s->nbfrags)
-			s->dma_tail = 0;
-
-		if (!s->mapped) {
-			complete(&s->wfc);
-		} else
-			s->pending_frags++;
-
-		wake_up(&s->wq);
-	}
-
-	audio_process_dma(s);
-
-	FN_OUT(0);
-	return;
-}
-
-/*******************************************************************************
- *
- * audio_get_dma_callback(): return the dma interface call back function
- *
- ******************************************************************************/
-dma_callback_t audio_get_dma_callback(void)
-{
-	FN_IN;
-	FN_OUT(0);
-	return audio_dma_callback;
-}
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION
-    ("Common DMA handling for Audio driver on DAVINCI processors");
-MODULE_LICENSE("GPL");
-
-EXPORT_SYMBOL(davinci_clear_sound_dma);
-EXPORT_SYMBOL(davinci_request_sound_dma);
-EXPORT_SYMBOL(davinci_free_sound_dma);
-
-EXPORT_SYMBOL(audio_get_dma_callback);
-EXPORT_SYMBOL(audio_setup_buf);
-EXPORT_SYMBOL(audio_process_dma);
-EXPORT_SYMBOL(audio_prime_rx);
-EXPORT_SYMBOL(audio_set_fragments);
-EXPORT_SYMBOL(audio_sync);
-EXPORT_SYMBOL(audio_stop_dma);
-EXPORT_SYMBOL(audio_get_dma_pos);
-EXPORT_SYMBOL(audio_reset);
-EXPORT_SYMBOL(audio_discard_buf);
Index: linux-2.6.10/sound/oss/davinci-audio-dma-intfc.h
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-audio-dma-intfc.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * linux/sound/oss/davinci-audio-dma-intfc.h
- *
- * Common audio DMA handling for the Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *
- * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI Davinci DM644x processor
- */
-
-#ifndef __DAVINCI_AUDIO_DMA_INTFC_H
-#define __DAVINCI_AUDIO_DMA_INTFC_H
-
-/******************************* INCLUDES *************************************/
-
-/* Requires davinci-audio.h */
-#include "davinci-audio.h"
-
-/************************** GLOBAL MACROS *************************************/
-
-/* Provide the Macro interfaces common across platforms */
-#define DMA_REQUEST(e,s, cb)   {e=davinci_request_sound_dma(s->dma_dev, s->id, s, &s->master_ch, &s->lch);}
-#define DMA_FREE(s)             davinci_free_sound_dma(s->master_ch,&s->lch)
-#define DMA_CLEAR(s)            davinci_clear_sound_dma(s)
-
-/************************** GLOBAL DATA STRUCTURES ****************************/
-
-typedef void (*dma_callback_t) (int lch, u16 ch_status, void *data);
-
-/************************** GLOBAL FUNCTIONS **********************************/
-
-dma_callback_t audio_get_dma_callback(void);
-int audio_setup_buf(audio_stream_t * s);
-int audio_process_dma(audio_stream_t * s);
-void audio_prime_rx(audio_state_t * state);
-int audio_set_fragments(audio_stream_t * s, int val);
-int audio_sync(struct file *file);
-void audio_stop_dma(audio_stream_t * s);
-u_int audio_get_dma_pos(audio_stream_t * s);
-void audio_reset(audio_stream_t * s);
-void audio_discard_buf(audio_stream_t * s);
-
-/**************** ARCH SPECIFIC FUNCIONS **************************************/
-
-void davinci_clear_sound_dma(audio_stream_t * s);
-
-int davinci_request_sound_dma(int device_id, const char *device_name,
-			      void *data, int *master_ch, int **channels);
-int davinci_free_sound_dma(int master_ch, int **channels);
-
-#endif				/* #ifndef __DAVINCI_AUDIO_DMA_INTFC_H */
Index: linux-2.6.10/sound/oss/davinci-audio.c
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-audio.c
+++ /dev/null
@@ -1,1195 +0,0 @@
-/*
- * linux/sound/oss/davinci-audio.c
- *
- * Common audio handling for the Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *
- * 2004/08/12   Nishanth Menon - Modified to integrate Audio requirements on 1610,1710 platforms
- *
- * 2004-11-01   Nishanth Menon - modified to support 16xx and 17xx
- *                platform multi channel chaining.
- *
- * 2004-11-04   Nishanth Menon - Added support for power management
- *
- * 2004-12-17   Nishanth Menon - Provided proper module handling support
- *
- * 2005-10-01   Rishi Bhattacharya - Adapted to TI Davinci Family of processors
- */
-
-/***************************** INCLUDES ************************************/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/poll.h>
-#include <linux/pm.h>
-#include <linux/errno.h>
-#include <linux/sound.h>
-#include <linux/soundcard.h>
-#include <linux/sysrq.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/completion.h>
-
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/hardware.h>
-#include <asm/semaphore.h>
-
-#include "davinci-audio-dma-intfc.h"
-#include "davinci-audio.h"
-
-/***************************** MACROS ************************************/
-
-#undef DEBUG
-//#define DEBUG
-#ifdef DEBUG
-#define DPRINTK  printk
-#define FN_IN printk("[davinci_audio.c:[%s] start\n", __FUNCTION__)
-#define FN_OUT(n) printk("[davinci_audio.c:[%s] end(%d)\n", __FUNCTION__ , n)
-#else
-#define DPRINTK( x... )
-#define FN_IN
-#define FN_OUT(x)
-#endif
-
-#define DAVINCI_AUDIO_NAME              "davinci-audio"
-
-#define AUDIO_NBFRAGS_DEFAULT   4
-#define AUDIO_FRAGSIZE_DEFAULT   3072
-
-/*************/
-
-/* HACK ALERT!: These values will bave to be tuned as this is a trade off b/w
- * Sampling Rate vs buffer size and delay we are prepared to do before giving up
- */
-#define MAX_QUEUE_FULL_RETRIES 1000000
-#define QUEUE_WAIT_TIME        10
-
-#define AUDIO_ACTIVE(state)     ((state)->rd_ref || (state)->wr_ref)
-
-#define SPIN_ADDR               (dma_addr_t)0
-#define SPIN_SIZE               2048
-
-/********************** MODULES SPECIFIC FUNCTION PROTOTYPES ***************/
-
-static int audio_write(struct file *file, const char *buffer,
-		       size_t count, loff_t * ppos);
-
-static int audio_read(struct file *file, char *buffer, size_t count,
-		      loff_t * ppos);
-
-static int audio_mmap(struct file *file, struct vm_area_struct *vma);
-
-static unsigned int audio_poll(struct file *file,
-			       struct poll_table_struct *wait);
-
-static loff_t audio_llseek(struct file *file, loff_t offset, int origin);
-
-static int audio_ioctl(struct inode *inode, struct file *file, uint cmd,
-		       ulong arg);
-
-static int audio_open(struct inode *inode, struct file *file);
-
-static int audio_release(struct inode *inode, struct file *file);
-
-static int audio_probe(struct device *dev);
-
-static int audio_remove(struct device *dev);
-
-static void audio_shutdown(struct device *dev);
-
-static int audio_suspend(struct device *dev, u32 state, u32 level);
-
-static int audio_resume(struct device *dev, u32 level);
-
-static void audio_free(struct device *dev);
-
-/***************************** Data Structures ********************************/
-
-/*
- * The function pointer set to be registered by the codec.
- */
-static audio_state_t audio_state = { 0 };
-
-/* DMA Call back function */
-static dma_callback_t audio_dma_callback = 0;
-
-/* File Ops structure */
-static struct file_operations davinci_audio_fops = {
-	.open = audio_open,
-	.release = audio_release,
-	.write = audio_write,
-	.read = audio_read,
-	.mmap = audio_mmap,
-	.poll = audio_poll,
-	.ioctl = audio_ioctl,
-	.llseek = audio_llseek,
-	.owner = THIS_MODULE
-};
-
-/* Driver information */
-static struct device_driver davinci_audio_driver = {
-	.name = DAVINCI_AUDIO_NAME,
-	.bus = &platform_bus_type,
-	.probe = audio_probe,
-	.remove = audio_remove,
-	.suspend = audio_suspend,
-	.resume = audio_resume,
-	.shutdown = audio_shutdown,
-};
-
-/* Device Information */
-static struct platform_device davinci_audio_device = {
-	.name = DAVINCI_AUDIO_NAME,
-	.dev = {
-		.driver_data = &audio_state,
-		.release = audio_free,
-		},
-	.id = 0,
-};
-
-/***************************** GLOBAL FUNCTIONs *******************************/
-
-/* Power Management Functions for Linux Device Model  */
-/* DEBUG PUPOSES ONLY! */
-#ifdef CONFIG_PM
-//#undef CONFIG_PM
-#endif
-
-#ifdef CONFIG_PM
-/*******************************************************************************
- *
- * audio_ldm_suspend(): Suspend operation
- *
- ******************************************************************************/
-static int audio_ldm_suspend(void *data)
-{
-	audio_state_t *state = data;
-
-	FN_IN;
-
-	/*
-	 * Reject the suspend request if we are already actively transmitting data
-	 * Rationale: We dont want to be suspended while in the middle of a call!
-	 */
-	if (AUDIO_ACTIVE(state) && state->hw_init) {
-		DPRINTK("Audio device Active, Cannot Suspend");
-		return -EPERM;
-#if 0
-		/* NOTE:
-		 * This Piece of code is commented out in hope
-		 * That one day we would need to suspend the device while
-		 * audio operations are in progress and resume the operations
-		 * once the resume is done.
-		 * This is just a sample implementation of how it could be done.
-		 * Currently NOT SUPPORTED
-		 */
-		audio_stream_t *is = state->input_stream;
-		audio_stream_t *os = state->output_stream;
-		int stopstate;
-		if (is && is->buffers) {
-			DPRINTK("IS Suspend\n");
-			stopstate = is->stopped;
-			audio_stop_dma(is);
-			DMA_CLEAR(is);
-			is->dma_spinref = 0;
-			is->stopped = stopstate;
-		}
-		if (os && os->buffers) {
-			DPRINTK("OS Suspend\n");
-			stopstate = os->stopped;
-			audio_stop_dma(os);
-			DMA_CLEAR(os);
-			os->dma_spinref = 0;
-			os->stopped = stopstate;
-		}
-#endif
-	}
-
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * audio_ldm_resume(): Resume Operations
- *
- ******************************************************************************/
-static int audio_ldm_resume(void *data)
-{
-	audio_state_t *state = data;
-
-	FN_IN;
-	if (AUDIO_ACTIVE(state) && state->hw_init) {
-		/* Should never occur - since we never suspend with active state */
-		BUG();
-		return -EPERM;
-#if 0
-		/* NOTE:
-		 * This Piece of code is commented out in hope
-		 * That one day we would need to suspend the device while
-		 * audio operations are in progress and resume the operations
-		 * once the resume is done.
-		 * This is just a sample implementation of how it could be done.
-		 * Currently NOT SUPPORTED
-		 */
-		audio_stream_t *is = state->input_stream;
-		audio_stream_t *os = state->output_stream;
-		if (os && os->buffers) {
-			DPRINTK("OS Resume\n");
-			audio_reset(os);
-			audio_process_dma(os);
-		}
-		if (is && is->buffers) {
-			DPRINTK("IS Resume\n");
-			audio_reset(is);
-			audio_process_dma(is);
-		}
-#endif
-	}
-	FN_OUT(0);
-	return 0;
-}
-#endif				/* End of #ifdef CONFIG_PM */
-
-/*******************************************************************************
- *
- * audio_free(): The Audio driver release function
- * This is a dummy function required by the platform driver
- *
- ******************************************************************************/
-static void audio_free(struct device *dev)
-{
-	/* Nothing to Release! */
-}
-
-/*******************************************************************************
- *
- * audio_probe(): The Audio driver probe function
- * WARNING!!!!  : It is expected that the codec would have registered with us by now
- *
- ******************************************************************************/
-static int audio_probe(struct device *dev)
-{
-	int ret;
-	FN_IN;
-	if (!audio_state.hw_probe) {
-		DPRINTK("Probe Function Not Registered\n");
-		return -ENODEV;
-	}
-	ret = audio_state.hw_probe();
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_remove() Function to handle removal operations
- *
- ******************************************************************************/
-static int audio_remove(struct device *dev)
-{
-	FN_IN;
-	if (audio_state.hw_remove) {
-		audio_state.hw_remove();
-	}
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * audio_shutdown(): Function to handle shutdown operations
- *
- ******************************************************************************/
-static void audio_shutdown(struct device *dev)
-{
-	FN_IN;
-	if (audio_state.hw_cleanup) {
-		audio_state.hw_cleanup();
-	}
-	FN_OUT(0);
-	return;
-}
-
-/*******************************************************************************
- *
- * audio_suspend(): Function to handle suspend operations
- *
- ******************************************************************************/
-static int audio_suspend(struct device *dev, u32 state, u32 level)
-{
-	int ret = 0;
-
-#ifdef CONFIG_PM
-	void *data = dev->driver_data;
-	FN_IN;
-	if (level != 3) {
-		return 0;
-	}
-	if (audio_state.hw_suspend) {
-		ret = audio_ldm_suspend(data);
-		if (ret == 0)
-			ret = audio_state.hw_suspend();
-	}
-	if (ret) {
-		DPRINTK("Audio Suspend Failed \n");
-	} else {
-		DPRINTK("Audio Suspend Success \n");
-	}
-#endif				/* CONFIG_PM */
-
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_resume(): Function to handle resume operations
- *
- ******************************************************************************/
-static int audio_resume(struct device *dev, u32 level)
-{
-	int ret = 0;
-
-#ifdef  CONFIG_PM
-	void *data = dev->driver_data;
-	FN_IN;
-	if (level != 0) {
-		return 0;
-	}
-	if (audio_state.hw_resume) {
-		ret = audio_ldm_resume(data);
-		if (ret == 0)
-			ret = audio_state.hw_resume();
-	}
-	if (ret) {
-		DPRINTK(" Audio Resume Failed \n");
-	} else {
-		DPRINTK(" Audio Resume Success \n");
-	}
-#endif				/* CONFIG_PM */
-
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_get_fops(): Return the fops required to get the function pointers of
- *                   DAVINCI Audio Driver
- *
- ******************************************************************************/
-struct file_operations *audio_get_fops(void)
-{
-	FN_IN;
-	FN_OUT(0);
-	return &davinci_audio_fops;
-}
-
-/*******************************************************************************
- *
- * audio_register_codec(): Register a Codec fn points using this function
- * WARNING!!!!!          : Codecs should ensure that they do so! no sanity checks
- *                         during runtime is done due to obvious performance
- *                         penalties.
- *
- ******************************************************************************/
-int audio_register_codec(audio_state_t * codec_state)
-{
-	int ret;
-	FN_IN;
-
-	/* We dont handle multiple codecs now */
-	if (audio_state.hw_init) {
-		DPRINTK(" Codec Already registered\n");
-		return -EPERM;
-	}
-
-	/* Grab the dma Callback */
-	audio_dma_callback = audio_get_dma_callback();
-	if (!audio_dma_callback) {
-		DPRINTK("Unable to get call back function\n");
-		return -EPERM;
-	}
-
-	/* Sanity checks */
-	if (!codec_state) {
-		DPRINTK("NULL ARGUMENT!\n");
-		return -EPERM;
-	}
-
-	if (!codec_state->hw_probe || !codec_state->hw_init
-	    || !codec_state->hw_shutdown || !codec_state->client_ioctl) {
-		DPRINTK
-		    ("Required Fn Entry point Missing probe=%p init=%p,down=%p,ioctl=%p!\n",
-		     codec_state->hw_probe, codec_state->hw_init,
-		     codec_state->hw_shutdown, codec_state->client_ioctl);
-		return -EPERM;
-	}
-
-	memcpy(&audio_state, codec_state, sizeof(audio_state_t));
-	sema_init(&audio_state.sem, 1);
-
-	ret = platform_device_register(&davinci_audio_device);
-	if (ret != 0) {
-		DPRINTK("Platform dev_register failed =%d\n", ret);
-		ret = -ENODEV;
-		goto register_out;
-	}
-
-	ret = driver_register(&davinci_audio_driver);
-	if (ret != 0) {
-		DPRINTK("Device Register failed =%d\n", ret);
-		ret = -ENODEV;
-		platform_device_unregister(&davinci_audio_device);
-		goto register_out;
-	}
-
-	DPRINTK("audio driver register success\n");
-
-      register_out:
-
-	FN_OUT(ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_unregister_codec(): Un-Register a Codec using this function
- *
- ******************************************************************************/
-int audio_unregister_codec(audio_state_t * codec_state)
-{
-	FN_IN;
-
-	/* We dont handle multiple codecs now */
-	if (!audio_state.hw_init) {
-		DPRINTK(" No Codec registered\n");
-		return -EPERM;
-	}
-	/* Security check */
-	if (audio_state.hw_init != codec_state->hw_init) {
-		DPRINTK
-		    ("Attempt to unregister codec which was not registered with us\n");
-		return -EPERM;
-	}
-
-	driver_unregister(&davinci_audio_driver);
-	platform_device_unregister(&davinci_audio_device);
-
-	memset(&audio_state, 0, sizeof(audio_state_t));
-
-	FN_OUT(0);
-	return 0;
-}
-
-/***************************** MODULES SPECIFIC FUNCTION **********************/
-
-/*******************************************************************************
- *
- * audio_write(): Exposed to write() call
- *
- ******************************************************************************/
-static int
-audio_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
-{
-	const char *buffer0 = buffer;
-	audio_state_t *state = file->private_data;
-	audio_stream_t *s = state->output_stream;
-	int chunksize, ret = 0;
-	unsigned long flags;
-
-	DPRINTK("audio_write: count=%d\n", count);
-	if (*ppos != file->f_pos) {
-		DPRINTK("FPOS not ppos ppos=0x%x fpos =0x%x\n", (u32) * ppos,
-			(u32) file->f_pos);
-		return -ESPIPE;
-	}
-	if (s->mapped) {
-		DPRINTK("s already mapped\n");
-		return -ENXIO;
-	}
-	if (!s->buffers && audio_setup_buf(s)) {
-		DPRINTK("NO MEMORY\n");
-		return -ENOMEM;
-	}
-
-	while (count > 0) {
-		audio_buf_t *b = &s->buffers[s->usr_head];
-
-		/* Wait for a buffer to become free */
-		if (file->f_flags & O_NONBLOCK) {
-			ret = -EAGAIN;
-			if (!s->wfc.done)
-				break;
-			else {
-				local_irq_save(flags);
-				s->wfc.done--;
-				local_irq_restore(flags);
-			}
-		} else {
-			ret = -ERESTARTSYS;
-			if (wait_for_completion_interruptible(&s->wfc))
-				break;
-		}
-
-		/* Feed the current buffer */
-		chunksize = s->fragsize - b->offset;
-		if (chunksize > count)
-			chunksize = count;
-		DPRINTK("write %d to %d\n", chunksize, s->usr_head);
-		if (copy_from_user(b->data + b->offset, buffer, chunksize)) {
-			DPRINTK("Audio: CopyFrom User failed \n");
-			complete(&s->wfc);
-			return -EFAULT;
-		}
-
-		buffer += chunksize;
-		count -= chunksize;
-		b->offset += chunksize;
-
-		if (b->offset < s->fragsize) {
-			complete(&s->wfc);
-			break;
-		}
-
-		/* Update pointers and send current fragment to DMA */
-		local_irq_save(flags);
-		b->offset = 0;
-		if (++s->usr_head >= s->nbfrags)
-			s->usr_head = 0;
-		/* Add the num of frags pending */
-		s->pending_frags++;
-		s->active = 1;
-		local_irq_restore(flags);
-		audio_process_dma(s);
-	}
-
-	if ((buffer - buffer0))
-		ret = buffer - buffer0;
-
-	DPRINTK("audio_write: return=%d\n", ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_read(): Exposed as read() function
- *
- ******************************************************************************/
-static int
-audio_read(struct file *file, char *buffer, size_t count, loff_t * ppos)
-{
-	char *buffer0 = buffer;
-	audio_state_t *state = file->private_data;
-	audio_stream_t *s = state->input_stream;
-	int chunksize, ret = 0;
-	unsigned long flags;
-
-	DPRINTK("audio_read: count=%d\n", count);
-
-	if (*ppos != file->f_pos) {
-		DPRINTK("AudioRead - FPOS not ppos ppos=0x%x fpos =0x%x\n",
-			(u32) * ppos, (u32) file->f_pos);
-		return -ESPIPE;
-	}
-	if (s->mapped) {
-		DPRINTK("AudioRead - s already mapped\n");
-		return -ENXIO;
-	}
-
-	if (!s->active) {
-		if (!s->buffers && audio_setup_buf(s)) {
-			DPRINTK("AudioRead - No Memory\n");
-			return -ENOMEM;
-		}
-		audio_prime_rx(state);
-	}
-
-	while (count > 0) {
-		audio_buf_t *b = &s->buffers[s->usr_head];
-
-		/* Wait for a buffer to become full */
-		if (file->f_flags & O_NONBLOCK) {
-			ret = -EAGAIN;
-			if (!s->wfc.done)
-				break;
-			else {
-                                local_irq_save(flags);
-                                s->wfc.done--;
-                                local_irq_restore(flags);
-                        }
-		} else {
-			ret = -ERESTARTSYS;
-			if (wait_for_completion_interruptible(&s->wfc))
-				break;
-		}
-
-		/* Grab data from the current buffer */
-		chunksize = s->fragsize - b->offset;
-		if (chunksize > count)
-			chunksize = count;
-
-		DPRINTK("read %d from %d\n", chunksize, s->usr_head);
-		if (copy_to_user(buffer, b->data + b->offset, chunksize)) {
-			complete(&s->wfc);
-			return -EFAULT;
-		}
-		buffer += chunksize;
-		count -= chunksize;
-		b->offset += chunksize;
-		if (b->offset < s->fragsize) {
-			complete(&s->wfc);
-			break;
-		}
-
-		/* Update pointers and return current fragment to DMA */
-		local_irq_save(flags);
-		b->offset = 0;
-		if (++s->usr_head >= s->nbfrags)
-			s->usr_head = 0;
-
-		s->pending_frags++;
-		local_irq_restore(flags);
-		DPRINTK(KERN_INFO
-			"calling audio_process_dma from audio_read\n");
-		audio_process_dma(s);
-	}
-
-	if ((buffer - buffer0))
-		ret = buffer - buffer0;
-	DPRINTK("audio_read: return=%d\n", ret);
-	return ret;
-}
-
-/*******************************************************************************
- *
- * audio_mmap(): Exposed as mmap Function
- * !!WARNING: Still under development
- *
- ******************************************************************************/
-static int audio_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	audio_state_t *state = file->private_data;
-	audio_stream_t *s;
-	unsigned long size, vma_addr;
-	int i, ret = 0;
-
-	FN_IN;
-	if (vma->vm_pgoff != 0)
-		return -EINVAL;
-
-	if (vma->vm_flags & VM_WRITE) {
-		if (!state->wr_ref)
-			return -EINVAL;;
-		s = state->output_stream;
-	} else if (vma->vm_flags & VM_READ) {
-		if (!state->rd_ref)
-			return -EINVAL;
-		s = state->input_stream;
-	} else
-		return -EINVAL;
-
-	if (s->mapped)
-		return -EINVAL;
-	size = vma->vm_end - vma->vm_start;
-	if (size != s->fragsize * s->nbfrags)
-		return -EINVAL;
-	if (!s->buffers && audio_setup_buf(s))
-		return -ENOMEM;
-	vma_addr = vma->vm_start;
-	for (i = 0; i < s->nbfrags; i++) {
-		audio_buf_t *buf = &s->buffers[i];
-		if (!buf->master)
-			continue;
-#if 0
-		ret =
-		    remap_pfn_range(vma, vma_addr, buf->dma_addr >> PAGE_SHIFT,
-				    buf->master, vma->vm_page_prot);
-#endif
-		if (ret)
-			return ret;
-		vma_addr += buf->master;
-	}
-	s->mapped = 1;
-
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * audio_poll(): Exposed as poll function
- *
- ******************************************************************************/
-static unsigned int
-audio_poll(struct file *file, struct poll_table_struct *wait)
-{
-	audio_state_t *state = file->private_data;
-	audio_stream_t *is = state->input_stream;
-	audio_stream_t *os = state->output_stream;
-	unsigned int mask = 0;
-
-	DPRINTK("audio_poll(): mode=%s%s\n",
-		(file->f_mode & FMODE_READ) ? "r" : "",
-		(file->f_mode & FMODE_WRITE) ? "w" : "");
-
-	if (file->f_mode & FMODE_READ) {
-		/* Start audio input if not already active */
-		if (!is->active) {
-			if (!is->buffers && audio_setup_buf(is))
-				return -ENOMEM;
-			audio_prime_rx(state);
-		}
-		poll_wait(file, &is->wq, wait);
-	}
-
-	if (file->f_mode & FMODE_WRITE) {
-		if (!os->buffers && audio_setup_buf(os))
-			return -ENOMEM;
-		poll_wait(file, &os->wq, wait);
-	}
-
-	if (file->f_mode & FMODE_READ)
-		if ((is->mapped && is->bytecount > 0) ||
-		    (!is->mapped && is->wfc.done > 0))
-			mask |= POLLIN | POLLRDNORM;
-
-	if (file->f_mode & FMODE_WRITE)
-		if ((os->mapped && os->bytecount > 0) ||
-		    (!os->mapped && os->wfc.done > 0))
-			mask |= POLLOUT | POLLWRNORM;
-
-	DPRINTK("audio_poll() returned mask of %s%s\n",
-		(mask & POLLIN) ? "r" : "", (mask & POLLOUT) ? "w" : "");
-
-	FN_OUT(mask);
-	return mask;
-}
-
-/*******************************************************************************
- *
- * audio_llseek(): Exposed as lseek() function.
- *
- ******************************************************************************/
-static loff_t audio_llseek(struct file *file, loff_t offset, int origin)
-{
-	FN_IN;
-	FN_OUT(0);
-	return -ESPIPE;
-}
-
-/*******************************************************************************
- *
- * audio_ioctl(): Handles generic ioctls. If there is a request for something this
- * fn cannot handle, its then given to client specific ioctl routine, that will take
- * up platform specific requests
- *
- ******************************************************************************/
-static int
-audio_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
-{
-	audio_state_t *state = file->private_data;
-	audio_stream_t *os = state->output_stream;
-	audio_stream_t *is = state->input_stream;
-	long val;
-
-	DPRINTK(__FILE__ " audio_ioctl 0x%08x\n", cmd);
-
-	/* dispatch based on command */
-	switch (cmd) {
-	case OSS_GETVERSION:
-		return put_user(SOUND_VERSION, (int *)arg);
-
-	case SNDCTL_DSP_GETBLKSIZE:
-		if (file->f_mode & FMODE_WRITE)
-			return put_user(os->fragsize, (int *)arg);
-		else
-			return put_user(is->fragsize, (int *)arg);
-
-	case SNDCTL_DSP_GETCAPS:
-		val = DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP;
-		if (is && os)
-			val |= DSP_CAP_DUPLEX;
-		FN_OUT(1);
-		return put_user(val, (int *)arg);
-
-	case SNDCTL_DSP_SETFRAGMENT:
-		if (get_user(val, (long *)arg)) {
-			FN_OUT(2);
-			return -EFAULT;
-		}
-		if (file->f_mode & FMODE_READ) {
-			int ret = audio_set_fragments(is, val);
-			if (ret < 0) {
-				FN_OUT(3);
-				return ret;
-			}
-			ret = put_user(ret, (int *)arg);
-			if (ret) {
-				FN_OUT(4);
-				return ret;
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			int ret = audio_set_fragments(os, val);
-			if (ret < 0) {
-				FN_OUT(5);
-				return ret;
-			}
-			ret = put_user(ret, (int *)arg);
-			if (ret) {
-				FN_OUT(6);
-				return ret;
-			}
-		}
-		FN_OUT(7);
-		return 0;
-
-	case SNDCTL_DSP_SYNC:
-		FN_OUT(8);
-		return audio_sync(file);
-
-	case SNDCTL_DSP_SETDUPLEX:
-		FN_OUT(9);
-		return 0;
-
-	case SNDCTL_DSP_POST:
-		FN_OUT(10);
-		return 0;
-
-	case SNDCTL_DSP_GETTRIGGER:
-		val = 0;
-		if (file->f_mode & FMODE_READ && is->active && !is->stopped)
-			val |= PCM_ENABLE_INPUT;
-		if (file->f_mode & FMODE_WRITE && os->active && !os->stopped)
-			val |= PCM_ENABLE_OUTPUT;
-		FN_OUT(11);
-		return put_user(val, (int *)arg);
-
-	case SNDCTL_DSP_SETTRIGGER:
-		if (get_user(val, (int *)arg)) {
-			FN_OUT(12);
-			return -EFAULT;
-		}
-		if (file->f_mode & FMODE_READ) {
-			if (val & PCM_ENABLE_INPUT) {
-				unsigned long flags;
-				if (!is->active) {
-					if (!is->buffers && audio_setup_buf(is)) {
-						FN_OUT(13);
-						return -ENOMEM;
-					}
-					audio_prime_rx(state);
-				}
-				local_irq_save(flags);
-				is->stopped = 0;
-				local_irq_restore(flags);
-				audio_process_dma(is);
-
-			} else {
-				is->stopped = 1;
-				audio_stop_dma(is);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			if (val & PCM_ENABLE_OUTPUT) {
-				unsigned long flags;
-				if (!os->buffers && audio_setup_buf(os)) {
-					FN_OUT(14);
-					return -ENOMEM;
-				}
-				local_irq_save(flags);
-				if (os->mapped && !os->pending_frags) {
-					os->pending_frags = os->nbfrags;
-					init_completion(&os->wfc);
-					os->wfc.done = 0;
-					os->active = 1;
-				}
-				os->stopped = 0;
-				local_irq_restore(flags);
-				audio_process_dma(os);
-			} else {
-				os->stopped = 1;
-				audio_stop_dma(os);
-			}
-		}
-		FN_OUT(15);
-		return 0;
-
-	case SNDCTL_DSP_GETOPTR:
-	case SNDCTL_DSP_GETIPTR:
-		{
-			count_info inf = { 0, };
-			audio_stream_t *s =
-			    (cmd == SNDCTL_DSP_GETOPTR) ? os : is;
-			int bytecount, offset;
-			unsigned long flags;
-
-			if ((s == is && !(file->f_mode & FMODE_READ)) ||
-			    (s == os && !(file->f_mode & FMODE_WRITE))) {
-				FN_OUT(16);
-				return -EINVAL;
-			}
-			if (s->active) {
-				local_irq_save(flags);
-				offset = audio_get_dma_pos(s);
-				inf.ptr = s->dma_tail * s->fragsize + offset;
-				bytecount = s->bytecount + offset;
-				s->bytecount = -offset;
-				inf.blocks = s->fragcount;
-				s->fragcount = 0;
-				local_irq_restore(flags);
-				if (bytecount < 0)
-					bytecount = 0;
-				inf.bytes = bytecount;
-			}
-			FN_OUT(17);
-			return copy_to_user((void *)arg, &inf, sizeof(inf));
-		}
-
-	case SNDCTL_DSP_GETOSPACE:
-	case SNDCTL_DSP_GETISPACE:
-		{
-			audio_buf_info inf = { 0, };
-			audio_stream_t *s =
-			    (cmd == SNDCTL_DSP_GETOSPACE) ? os : is;
-			audio_buf_t *b = NULL;
-
-			if ((s == is && !(file->f_mode & FMODE_READ)) ||
-			    (s == os && !(file->f_mode & FMODE_WRITE))) {
-				FN_OUT(18);
-				return -EINVAL;
-			}
-			if (!s->buffers && audio_setup_buf(s)) {
-				FN_OUT(19);
-				return -ENOMEM;
-			}
-			b = &s->buffers[s->usr_head];
-			inf.bytes = s->wfc.done * s->fragsize;
-			inf.bytes -= b->offset;
-			if(inf.bytes < 0)
-				inf.bytes = 0;
-
-			inf.fragments = inf.bytes / s->fragsize;
-			inf.fragsize = s->fragsize;
-			inf.fragstotal = s->nbfrags;
-			FN_OUT(20);
-			return copy_to_user((void *)arg, &inf, sizeof(inf));
-		}
-
-	case SNDCTL_DSP_NONBLOCK:
-		file->f_flags |= O_NONBLOCK;
-		FN_OUT(21);
-		return 0;
-
-	case SNDCTL_DSP_RESET:
-		if (file->f_mode & FMODE_READ) {
-			audio_reset(is);
-			if (state->need_tx_for_rx) {
-				unsigned long flags;
-				local_irq_save(flags);
-				os->spin_idle = 0;
-				local_irq_restore(flags);
-			}
-		}
-		if (file->f_mode & FMODE_WRITE) {
-			audio_reset(os);
-		}
-		FN_OUT(22);
-		return 0;
-
-	default:
-		/*
-		 * Let the client of this module handle the
-		 * non generic ioctls
-		 */
-		FN_OUT(23);
-		return state->client_ioctl(inode, file, cmd, arg);
-	}
-
-	FN_OUT(0);
-	return 0;
-}
-
-/*******************************************************************************
- *
- * audio_open(): Exposed as open() function
- *
- ******************************************************************************/
-static int audio_open(struct inode *inode, struct file *file)
-{
-	audio_state_t *state = (&audio_state);
-	audio_stream_t *os = state->output_stream;
-	audio_stream_t *is = state->input_stream;
-	int err, need_tx_dma;
-	static unsigned char aic33_init_flag = 0;
-
-	FN_IN;
-
-	/* Lock the module */
-	if (!try_module_get(THIS_MODULE)) {
-		DPRINTK("Failed to get module\n");
-		return -ESTALE;
-	}
-	/* Lock the codec module */
-	if (!try_module_get(state->owner)) {
-		DPRINTK("Failed to get codec module\n");
-		module_put(THIS_MODULE);
-		return -ESTALE;
-	}
-
-	down(&state->sem);
-
-	/* access control */
-	err = -ENODEV;
-	if ((file->f_mode & FMODE_WRITE) && !os)
-		goto out;
-	if ((file->f_mode & FMODE_READ) && !is)
-		goto out;
-	err = -EBUSY;
-	if ((file->f_mode & FMODE_WRITE) && state->wr_ref)
-		goto out;
-	if ((file->f_mode & FMODE_READ) && state->rd_ref)
-		goto out;
-	err = -EINVAL;
-	if ((file->f_mode & FMODE_READ) && state->need_tx_for_rx && !os)
-		goto out;
-
-	/* request DMA channels */
-	need_tx_dma = ((file->f_mode & FMODE_WRITE) ||
-		       ((file->f_mode & FMODE_READ) && state->need_tx_for_rx));
-	if (state->wr_ref || (state->rd_ref && state->need_tx_for_rx))
-		need_tx_dma = 0;
-	if (need_tx_dma) {
-		DPRINTK("DMA REQUEST FOR playback\n");
-		DMA_REQUEST(err, os, audio_dma_callback);
-		if (err < 0)
-			goto out;
-	}
-	if (file->f_mode & FMODE_READ) {
-		DPRINTK("DMA REQUEST FOR record\n");
-		DMA_REQUEST(err, is, audio_dma_callback);
-		if (err < 0) {
-			if (need_tx_dma)
-				DMA_FREE(os);
-			goto out;
-		}
-	}
-
-	/* now complete initialisation */
-	if (!AUDIO_ACTIVE(state)) {
-		if (state->hw_init && !aic33_init_flag) {
-			state->hw_init(state->data);
-			aic33_init_flag = 0;
-		}
-	}
-
-	if ((file->f_mode & FMODE_WRITE)) {
-		DPRINTK("SETUP FOR PLAYBACK\n");
-		state->wr_ref = 1;
-		audio_reset(os);
-		os->fragsize = AUDIO_FRAGSIZE_DEFAULT;
-		os->nbfrags = AUDIO_NBFRAGS_DEFAULT;
-		os->mapped = 0;
-		init_waitqueue_head(&os->wq);
-	}
-
-	if (file->f_mode & FMODE_READ) {
-		DPRINTK("SETUP FOR RECORD\n");
-		state->rd_ref = 1;
-		audio_reset(is);
-		is->fragsize = AUDIO_FRAGSIZE_DEFAULT;
-		is->nbfrags = AUDIO_NBFRAGS_DEFAULT;
-		is->mapped = 0;
-		init_waitqueue_head(&is->wq);
-	}
-
-	file->private_data = state;
-	err = 0;
-
-      out:
-	up(&state->sem);
-	if (err) {
-		module_put(state->owner);
-		module_put(THIS_MODULE);
-	}
-	FN_OUT(err);
-	return err;
-}
-
-/*******************************************************************************
- *
- * audio_release(): Exposed as release function()
- *
- ******************************************************************************/
-static int audio_release(struct inode *inode, struct file *file)
-{
-	audio_state_t *state = file->private_data;
-	audio_stream_t *os = state->output_stream;
-	audio_stream_t *is = state->input_stream;
-
-	FN_IN;
-
-	down(&state->sem);
-
-	if (file->f_mode & FMODE_READ) {
-		audio_discard_buf(is);
-		DMA_FREE(is);
-		is->dma_spinref = 0;
-		if (state->need_tx_for_rx) {
-			os->spin_idle = 0;
-			if (!state->wr_ref) {
-				DMA_FREE(os);
-				os->dma_spinref = 0;
-			}
-		}
-		state->rd_ref = 0;
-	}
-
-	if (file->f_mode & FMODE_WRITE) {
-		audio_sync(file);
-		audio_discard_buf(os);
-		if (!state->need_tx_for_rx || !state->rd_ref) {
-			DMA_FREE(os);
-			os->dma_spinref = 0;
-		}
-		state->wr_ref = 0;
-	}
-
-	up(&state->sem);
-
-	module_put(state->owner);
-	module_put(THIS_MODULE);
-
-	FN_OUT(0);
-	return 0;
-}
-
-EXPORT_SYMBOL(audio_register_codec);
-EXPORT_SYMBOL(audio_unregister_codec);
-EXPORT_SYMBOL(audio_get_fops);
-
-MODULE_AUTHOR("Texas Instruments");
-MODULE_DESCRIPTION("Common audio handling for DAVINCI processors");
-MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/davinci-audio.h
===================================================================
--- linux-2.6.10.orig/sound/oss/davinci-audio.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * linux/sound/oss/davinci-audio.h
- *
- * Common audio handling for the Davinci processors
- *
- * Copyright (C) 2006 Texas Instruments, Inc.
- *
- * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- * History:
- *
- * 2005-10-01   Rishi Bhattacharya - Adapted to TI Davinci Family of processors
- */
-
-#ifndef __DAVINCI_AUDIO_H
-#define __DAVINCI_AUDIO_H
-
-/* Requires dma.h */
-#include <asm/arch/dma.h>
-
-/*
- * Buffer Management
- */
-typedef struct {
-	int offset;		/* current offset */
-	char *data;		/* points to actual buffer */
-	dma_addr_t dma_addr;	/* physical buffer address */
-	int dma_ref;		/* DMA refcount */
-	int master;		/* owner for buffer allocation, contain size when true */
-} audio_buf_t;
-
-/*
- * Structure describing the data stream related information
- */
-typedef struct {
-	char *id;		/* identification string */
-	audio_buf_t *buffers;	/* pointer to audio buffer structures */
-	u_int usr_head;		/* user fragment index */
-	u_int dma_head;		/* DMA fragment index to go */
-	u_int dma_tail;		/* DMA fragment index to complete */
-	u_int fragsize;		/* fragment i.e. buffer size */
-	u_int nbfrags;		/* nbr of fragments i.e. buffers */
-	u_int pending_frags;	/* Fragments sent to DMA */
-	int dma_dev;		/* device identifier for DMA */
-	u_int prevbuf;		/* Prev pending frag size sent to DMA */
-	char started;		/* to store if the chain was started or not */
-	int dma_q_head;		/* DMA Channel Q Head */
-	int dma_q_tail;		/* DMA Channel Q Tail */
-	char dma_q_count;	/* DMA Channel Q Count */
-	char in_use;		/*  Is this is use? */
-	int master_ch;
-	int *lch;		/*  Chain of channels this stream is linked to */
-	int input_or_output;	/* Direction of this data stream */
-	int bytecount;		/* nbr of processed bytes */
-	int fragcount;		/* nbr of fragment transitions */
-	struct completion wfc;	/* wait for "nbfrags" fragment completion */
-	wait_queue_head_t wq;	/* for poll */
-	int dma_spinref;	/* DMA is spinning */
-	int mapped:1;		/* mmap()'ed buffers */
-	int active:1;		/* actually in progress */
-	int stopped:1;		/* might be active but stopped */
-	int spin_idle:1;	/* have DMA spin on zeros when idle */
-	int dma_started;	/* to store if DMA was started or not */
-	int mcbsp_tx_started;
-	int mcbsp_rx_started;
-} audio_stream_t;
-
-/*
- * State structure for one instance
- */
-typedef struct {
-	struct module *owner;	/* Codec module ID */
-	audio_stream_t *output_stream;
-	audio_stream_t *input_stream;
-	int rd_ref:1;		/* open reference for recording */
-	int wr_ref:1;		/* open reference for playback */
-	int need_tx_for_rx:1;	/* if data must be sent while receiving */
-	void *data;
-	void (*hw_init) (void *);
-	void (*hw_shutdown) (void *);
-	int (*client_ioctl) (struct inode *, struct file *, uint, ulong);
-	int (*hw_probe) (void);
-	void (*hw_remove) (void);
-	void (*hw_cleanup) (void);
-	int (*hw_suspend) (void);
-	int (*hw_resume) (void);
-	struct pm_dev *pm_dev;
-	struct compat_semaphore sem;	/* to protect against races in attach() */
-} audio_state_t;
-
-#ifdef AUDIO_PM
-void audio_ldm_suspend(void *data);
-
-void audio_ldm_resume(void *data);
-
-#endif
-
-/* Register a Codec using this function */
-extern int audio_register_codec(audio_state_t * codec_state);
-/* Un-Register a Codec using this function */
-extern int audio_unregister_codec(audio_state_t * codec_state);
-/* Function to provide fops of davinci audio driver */
-extern struct file_operations *audio_get_fops(void);
-/* Function to initialize the device info for audio driver */
-extern int audio_dev_init(void);
-/* Function to un-initialize the device info for audio driver */
-void audio_dev_uninit(void);
-
-#endif				/* End of #ifndef __DAVINCI_AUDIO_H */
Index: linux-2.6.10/sound/oss/dm644x/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/Kconfig
@@ -0,0 +1,32 @@
+# Menu for  Davinci DM644x based systems audio
+
+menu " Davinci DM644x based systems audio support"
+        depends on SOUND && (MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM)
+
+config SOUND_DAVINCI
+	tristate "DaVinci Sound Driver"
+	depends on ARCH_DAVINCI && (MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM) && SOUND_PRIME!=n && SOUND
+	---help---
+	DaVinci Sound driver
+
+config SOUND_DAVINCI_TLV320AIC33
+       tristate "TLV320AIC33 Stereo Codec"
+       depends on SOUND_DAVINCI
+       default y if SOUND_DAVINCI
+       select SENSORS_TLV320AIC33
+       ---help---
+         If you say yes here you get support for the I2C control
+         interface for Texas Instruments TLV320AIC33 audio codec.
+
+choice
+	prompt "Mono/Stereo Jack Support"
+	default MONOSTEREO_SAMEJACK
+
+config MONOSTEREO_DIFFJACK
+	bool "Mono and Stereo on different jacks"
+
+config MONOSTEREO_SAMEJACK
+	bool "Mono and Stereo on same jacks"
+endchoice
+
+endmenu
Index: linux-2.6.10/sound/oss/dm644x/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/Makefile
@@ -0,0 +1,7 @@
+# Makefile for the Davinci-Audio Files.
+
+obj-$(CONFIG_SOUND_DAVINCI)	+= davinci-audio-oss.o
+obj-$(CONFIG_SOUND_DAVINCI_TLV320AIC33) += davinci-audio-aic33.o
+
+davinci-audio-oss-objs := davinci-audio-dma-intfc.o davinci-audio.o
+
Index: linux-2.6.10/sound/oss/dm644x/davinci-aic33.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-aic33.h
@@ -0,0 +1,249 @@
+/*
+ * linux/sound/oss/davinci-aic33.h
+ *
+ * Glue driver for AIC33 for Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *  -------
+ *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x
+ * 					Processor
+ */
+
+#ifndef __ASM_ARCH_AIC33_H
+#define __ASM_ARCH_AIC33_H
+
+/* Codec TLV320AIC33 */
+#define REGISTER_ADDR0  0x00
+#define REGISTER_ADDR1          0x01
+#define REGISTER_ADDR2          0x02
+#define REGISTER_ADDR3          0x03
+#define REGISTER_ADDR4          0x04
+#define REGISTER_ADDR5          0x05
+#define REGISTER_ADDR6          0x06
+#define REGISTER_ADDR7          0x07
+#define REGISTER_ADDR8          0x08
+#define REGISTER_ADDR9          0x09
+#define REGISTER_ADDR10         0x0A
+#define REGISTER_ADDR11         0x0B
+#define REGISTER_ADDR12         0x0C
+#define REGISTER_ADDR15         0x0F
+#define REGISTER_ADDR16         0x10
+#define REGISTER_ADDR17         0x11
+#define REGISTER_ADDR18         0x12
+#define REGISTER_ADDR19         0x13
+#define REGISTER_ADDR20         0x14
+#define REGISTER_ADDR21         0x15
+#define REGISTER_ADDR22         0x16
+#define REGISTER_ADDR23         0x17
+#define REGISTER_ADDR24         0x18
+#define REGISTER_ADDR25         0x19
+#define REGISTER_ADDR26         0x1A
+#define REGISTER_ADDR27         0x1B
+#define REGISTER_ADDR28         0x1C
+#define REGISTER_ADDR29         0x1D
+#define REGISTER_ADDR30         0x1E
+#define REGISTER_ADDR31         0x1F
+#define REGISTER_ADDR32         0x20
+#define REGISTER_ADDR33         0x21
+#define REGISTER_ADDR37         0x25
+#define REGISTER_ADDR38         0x26
+#define REGISTER_ADDR40         0x28
+#define REGISTER_ADDR41         0x29
+#define REGISTER_ADDR42         0x2A
+#define REGISTER_ADDR43         0x2B
+#define REGISTER_ADDR44         0x2C
+#define REGISTER_ADDR45         0x2D
+#define REGISTER_ADDR46         0x2E
+#define REGISTER_ADDR47         0x2F
+#define REGISTER_ADDR51         0x33
+#define REGISTER_ADDR58         0x3A
+#define REGISTER_ADDR64         0x40
+#define REGISTER_ADDR65         0x41
+#define REGISTER_ADDR73         0x49
+#define REGISTER_ADDR74         0x4A
+#define REGISTER_ADDR75         0x4B
+#define REGISTER_ADDR76         0x4C
+#define REGISTER_ADDR77         0x4D
+#define REGISTER_ADDR78         0x4E
+#define REGISTER_ADDR79         0x4F
+#define REGISTER_ADDR80         0x50
+#define REGISTER_ADDR81         0x51
+#define REGISTER_ADDR82         0x52
+#define REGISTER_ADDR83         0x53
+#define REGISTER_ADDR84         0x54
+#define REGISTER_ADDR85         0x55
+#define REGISTER_ADDR86         0x56
+#define REGISTER_ADDR87         0x57
+#define REGISTER_ADDR88         0x58
+#define REGISTER_ADDR89         0x59
+#define REGISTER_ADDR90         0x5A
+#define REGISTER_ADDR91         0x5B
+#define REGISTER_ADDR92         0x5C
+#define REGISTER_ADDR93         0x5D
+#define REGISTER_ADDR94         0x5E
+#define REGISTER_ADDR102        0x66
+
+/* Page Select register 0 */
+#define PAGE_SELECT0            0
+#define PAGE_SELECT1            1
+
+/* Software reset register 1 */
+#define SOFT_RESET              0x80
+
+/* Codec sample rate select register 2 */
+#define ADC_FS_MAX              0xA0
+#define ADC_FS_MIN              0x00
+
+#define DAC_FS_MAX              0x0A
+#define DAC_FS_MIN              0x00
+
+/* PLL Programming registerA 3 */
+#define PLL_ENABLE              0x80
+
+/* Codec Datapath setup register 7 */
+#define FS_REF_44_1             0x80
+#define FS_REF_DEFAULT_48       0x00
+#define ADC_DUAL_RATE_MODE      0x40
+#define DAC_DUAL_RATE_MODE      0x20
+#define LDAC_LCHAN              0x08
+#define LDAC_RCHAN              0x10
+#define LDAC_MONO_MIX           0x18
+
+#define RDAC_RCHAN              0x02
+#define RDAC_LCHAN              0x04
+#define RDAC_MONO_MIX           0x06
+
+/* Audio serial data interface control registerA 8 */
+#define BIT_CLK_MASTER          0x80
+#define WORD_CLK_MASTER         0x40
+#define DOUT_TRI_STATE          0x20
+#define CLK_TRANS_MASTER        0x10
+#define ENABLE_3D               0x04
+#define DM_ENABLE_128           0x01
+#define DM_ENABLE_64            0x02
+#define DM_ENABLE_32            0x03
+
+/* Audio serial data interface control registerB 9 */
+#define DSP_MODE                0x40
+#define RJ_MODE                 0x80
+#define LJ_MODE                 0xC0
+#define WORD_LENGTH20           0x10
+#define WORD_LENGTH24           0x20
+#define WORD_LENGTH32           0x30
+#define BITCLOCK_256CLK_FRAME   0x08
+
+/* Left/Right ADC PGA gain control register 15 & 16 */
+#define ADC_PGA_MUTE            0x80
+#define ADC_PGA_GAIN_MAX        0x78
+#define ADC_PGA_GAIN_MIN        0x00
+
+/* MIC3L/R to left/right ADC control register 17 & 18 */
+#define ADCPGA_GAIN_MAX         0x00
+#define MIC3L_ADCPGA_GAIN_MIN   0x80
+#define MIC3L_ADCPGA_DISCONNECT 0xF0
+
+#define MIC3R_ADCPGA_GAIN_MIN   0x08
+#define MIC3R_ADCPGA_DISCONNECT 0x0F
+
+/* LINE1L to left ADC Control Register 19 */
+#define DIFF_MODE               0x80
+#define LINE_ADCPGA_GAIN_MIN    0x40
+#define LINE_ADCPGA_DISCONNECT  0x78
+#define ADC_CHAN_ON             0x04
+#define ADCPGA_SOFT_STEP2FS     0x01
+#define ADCPGA_SOFT_STEP_OFF    0x03
+
+/* LINE2L to left ADC Control Register 20 */
+#define ADC_WEAK_INPUT_BIAS     0x04
+
+/* MICBIAS control register 25 */
+#define MICBIAS_OUTPUT_2_0V     0x40
+#define MICBIAS_OUTPUT_2_5V     0x80
+#define MICBIAS_OUTPUT_AVDD     0xC0
+
+/* LEFT/RIGHT AGC Control registerA 26 & 29 */
+#define AGC_ENABLE              0x80
+#define AGC_TARGET_GAIN_MAX     0x00
+#define AGC_TARGET_GAIN_MIN     0x70
+#define AGC_ATTACK_TIME_11      0x04
+#define AGC_ATTACK_TIME_16      0x08
+#define AGC_ATTACK_TIME_20      0x0C
+#define AGC_DECAY_TIME_200      0x01
+#define AGC_DECAY_TIME_400      0x02
+#define AGC_DECAY_TIME_500      0x03
+
+/* LEFT AGC Control registerB 27 & 30 */
+#define AGC_GAIN_ALLOWED_MAX    0xEE
+#define AGC_GAIN_ALLOWED_MIN    0x00
+
+/* DAC Power and output driver control register 37 */
+#define LEFT_DAC_POWER_ON       0x80
+#define RIGHT_DAC_POWER_ON      0x40
+
+/* High Power Output Stage Control Register 40 */
+#define LINE2L_BYPASS_DISABLE_DEFAULT    0x00
+#define LINE2LP_BYPASS_SINGLE            0x10
+#define LINE2LM_BYPASS_SINGLE            0x20
+#define LINE2LPM_BYPASS_DIFFERENTIAL     0x30
+
+#define LINE2R_BYPASS_DISABLE_DEFAULT    0x00
+#define LINE2RP_BYPASS_SINGLE            0x04
+#define LINE2RM_BYPASS_SINGLE            0x08
+#define LINE2RPM_BYPASS_DIFFERENTIAL     0x0C
+
+/* DAC Output Switching Control Register 41 */
+#define LEFT_DAC_DEFAULT_L1     0x00
+#define LEFT_DAC_L2             0x80
+#define LEFT_DAC_L3             0x40
+#define RIGHT_DAC_DEFAULT_R1    0x00
+#define RIGHT_DAC_R2            0x08
+#define RIGHT_DAC_R3            0x04
+
+/* LEFT/RIGHT DAC Digital volume control register 43 & 44 */
+#define DAC_CHAN_MUTE            0x80
+#define DAC_DIG_VOL_GAIN_MAX     0x00 /* 0.0db */
+#define DAC_DIG_VOL_GAIN_MIN     0x7F /* -63.5db */
+
+/* LINE2L to HPLOUT Volume Control Register 45 */
+#define LINE2L_HPLOUT_ROUTED              0x80
+
+/* PGA_L to HPLOUT Volume Control Register 46 */
+#define PGAL_HPLOUT_ROUTED                0x80
+
+/* any to LOP/M Volume control */
+#define LOPM_ON                 0x80
+#define LOPM_VOL_GAIN_MAX       0x00 /* 0 db */
+#define LOPM_VOL_GAIN_MIN       0x76 /* -78.3 db is MUTE */
+
+/* MONO_LOP/M output level volume control register 79 */
+#define LOPM_POWER_ON            0x01
+#define LOPM_MUTE_OFF            0x08
+#define LOPM_OUTPUT_LEVEL_MIN    0x00
+#define LOPM_OUTPUT_LEVEL_MAX    0x90
+
+/* Module Power Status Register 94 */
+#define HPROUT_DRIVER_POWER_ON           0x02
+
+#define LIV_MAX                         0x0077
+#define LIV_MIN                         0x0000
+
+#define LHV_MAX                         0x0077
+#define LHV_MIN                         0x0000
+
+#define LIG_MAX				0x0077
+#define LIG_MIN				0x0000
+
+#define LOG_MAX				0x007f
+#define LOG_MIN				0x0000
+
+#endif				/* __ASM_ARCH_AIC33_H */
Index: linux-2.6.10/sound/oss/dm644x/davinci-audio-aic33.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-audio-aic33.c
@@ -0,0 +1,1171 @@
+/*
+ * linux/sound/oss/davinci-audio-aic33.c
+ *
+ * Glue driver for AIC33 for Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *  -------
+ *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x
+ * 					Processor
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <sound/davincisound.h>
+
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/mcbsp.h>
+#include <asm/hardware/clock.h>
+#include "davinci-aic33.h"
+
+#include "davinci-audio.h"
+#include "davinci-audio-dma-intfc.h"
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#define PROC_START_FILE "driver/aic33-audio-start"
+#define PROC_STOP_FILE  "driver/aic33-audio-stop"
+#endif
+
+/* #define DEBUG */
+
+#ifdef DEBUG
+#define DPRINTK(ARGS...)        do { \
+				printk(KERN_DEBUG "<%s>: ", __FUNCTION__);\
+				printk(KERN_DEBUG ARGS); \
+				} while (0)
+#else
+#define DPRINTK( x... )
+#endif
+
+#define CODEC_NAME               "AIC33"
+#define PLATFORM_NAME            "DAVINCI"
+
+/* Define to set the AIC33 as the master w.r.t McBSP */
+#define AIC33_MASTER
+
+/* codec clock frequency */
+static int aic33_mclk;
+#define	MCLK_22  0
+#define	MCLK_27  1
+#define	MCLK_33  2
+
+
+/*
+ * AUDIO related MACROS
+ */
+#define DEFAULT_BITPERSAMPLE          16
+#define AUDIO_RATE_DEFAULT            48000
+
+/* Select the McBSP For Audio */
+#define AUDIO_MCBSP		      ((cpu_is_davinci_dm355()) ? \
+					   DAVINCI_MCBSP2 : DAVINCI_MCBSP1)
+
+#define REC_MASK                      (SOUND_MASK_LINE | SOUND_MASK_MIC)
+#define DEV_MASK                      (REC_MASK | SOUND_MASK_VOLUME)
+
+#define MONO			      1
+#define STEREO			      2
+
+#define SET_VOLUME                    1
+#define SET_LINE                      2
+#define SET_MIC                       3
+#define SET_RECSRC		      4
+#define SET_IGAIN		      5
+#define SET_OGAIN		      6
+#define SET_BASS                      7
+#define SET_TREBLE                    8
+#define SET_MICBIAS		      9
+
+#define DEFAULT_OUTPUT_VOLUME         70
+#define DEFAULT_INPUT_VOLUME          20	/* 0 ==> mute line in */
+#define DEFAULT_INPUT_IGAIN	      20
+#define DEFAULT_INPUT_OGAIN	      100
+
+#define OUTPUT_VOLUME_MIN             LHV_MIN
+#define OUTPUT_VOLUME_MAX             LHV_MAX
+#define OUTPUT_VOLUME_RANGE           (OUTPUT_VOLUME_MAX - OUTPUT_VOLUME_MIN)
+
+#define INPUT_VOLUME_MIN              LIV_MIN
+#define INPUT_VOLUME_MAX              LIV_MAX
+#define INPUT_VOLUME_RANGE            (INPUT_VOLUME_MAX - INPUT_VOLUME_MIN)
+
+#define INPUT_GAIN_MIN		      LIG_MIN
+#define INPUT_GAIN_MAX		      LIG_MAX
+#define INPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
+
+#define OUTPUT_GAIN_MIN		      LOG_MIN
+#define OUTPUT_GAIN_MAX		      LOG_MAX
+#define OUTPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
+
+#define NUMBER_SAMPLE_RATES_SUPPORTED 11
+
+static audio_stream_t output_stream = {
+	.id = "AIC33 out",
+	.input_or_output = FMODE_WRITE
+};
+
+static audio_stream_t input_stream = {
+	.id = "AIC33 in",
+	.input_or_output = FMODE_READ
+};
+
+static int audio_dev_id, mixer_dev_id;
+
+static struct aic33_local_info {
+	u8 volume;
+	u16 volume_reg;
+	u8 line;
+	u8 mic;
+	int recsrc;
+	u8 nochan;
+	u16 igain;
+	u16 ogain;
+	u8 micbias;
+	u8 bass;
+	u8 treble;
+	u16 input_volume_reg;
+	int mod_cnt;
+} aic33_local;
+
+struct sample_rate_reg_info {
+	u32 sample_rate;
+	u32 Fsref;
+	float divider;
+	u8 data;
+};
+
+/* To Store the default sample rate */
+static long audio_samplerate = AUDIO_RATE_DEFAULT;
+
+extern struct clk *davinci_mcbsp_get_clock(void);
+
+/* DAC USB-mode sampling rates*/
+static const struct sample_rate_reg_info
+ reg_info[NUMBER_SAMPLE_RATES_SUPPORTED] = {
+/*  {sample_rate, Fsref, divider, data}*/
+	{96000, 96000, 1, 0x00},
+	{88200, 88200, 1, 0x00},
+	{48000, 48000, 1, 0x00},
+	{44100, 44100, 1, 0x00},
+	{32000, 48000, 1.5, 0x11},
+	{24000, 96000, 4, 0x66},
+	{22050, 44100, 2, 0x22},
+	{16000, 48000, 3, 0x44},
+	{12000, 48000, 4, 0x66},
+	{11025, 44100, 4, 0x66},
+	{8000, 48000, 6, 0xAA},
+};
+
+static struct davinci_mcbsp_reg_cfg initial_config = {
+	.spcr2 = FREE | XINTM(3),
+	.spcr1 = RINTM(3),
+	.rcr2 = RWDLEN2(DAVINCI_MCBSP_WORD_16) | RDATDLY(1),
+	.rcr1 = RFRLEN1(1) | RWDLEN1(DAVINCI_MCBSP_WORD_16),
+	.xcr2 = XWDLEN2(DAVINCI_MCBSP_WORD_16) | XDATDLY(1) | XFIG,
+	.xcr1 = XFRLEN1(1) | XWDLEN1(DAVINCI_MCBSP_WORD_16),
+	.srgr1 = FWID(DEFAULT_BITPERSAMPLE - 1),
+	.srgr2 = FSGM | FPER(DEFAULT_BITPERSAMPLE * 2 - 1),
+#ifndef AIC33_MASTER
+	/* configure McBSP to be the I2S master */
+	.pcr0 = FSXM | FSRM | CLKXM | CLKRM | CLKXP | CLKRP,
+#else
+	/* configure McBSP to be the I2S slave */
+	.pcr0 = CLKXP | CLKRP,
+#endif				/* AIC33_MASTER */
+};
+
+static void davinci_aic33_initialize(void *dummy);
+static void davinci_aic33_shutdown(void *dummy);
+static int davinci_aic33_ioctl(struct inode *inode, struct file *file,
+			       uint cmd, ulong arg);
+static int davinci_aic33_probe(void);
+
+#ifdef MODULE
+static void davinci_aic33_remove(void);
+#endif
+
+static int davinci_aic33_suspend(void);
+static int davinci_aic33_resume(void);
+static inline void aic33_configure(void);
+static int mixer_open(struct inode *inode, struct file *file);
+static int mixer_release(struct inode *inode, struct file *file);
+static int mixer_ioctl(struct inode *inode, struct file *file, uint cmd,
+		       ulong arg);
+
+#ifdef CONFIG_PROC_FS
+static int codec_start(char *buf, char **start, off_t offset, int count,
+		       int *eof, void *data);
+static int codec_stop(char *buf, char **start, off_t offset, int count,
+		      int *eof, void *data);
+#endif
+
+/* File Op structure for mixer */
+static struct file_operations davinci_mixer_fops = {
+	.open = mixer_open,
+	.release = mixer_release,
+	.ioctl = mixer_ioctl,
+	.owner = THIS_MODULE
+};
+
+/* To store characteristic info regarding the codec for the audio driver */
+static audio_state_t aic33_state = {
+	.owner = THIS_MODULE,
+	.output_stream = &output_stream,
+	.input_stream = &input_stream,
+/*    .need_tx_for_rx = 1, //Once the Full Duplex works  */
+	.need_tx_for_rx = 0,
+	.hw_init = davinci_aic33_initialize,
+	.hw_shutdown = davinci_aic33_shutdown,
+	.client_ioctl = davinci_aic33_ioctl,
+	.hw_probe = davinci_aic33_probe,
+	.hw_remove = __exit_p(davinci_aic33_remove),
+	.hw_suspend = davinci_aic33_suspend,
+	.hw_resume = davinci_aic33_resume,
+	.sem = __COMPAT_MUTEX_INITIALIZER(aic33_state.sem),
+};
+
+/* This will be defined in the audio.h */
+static struct file_operations *davinci_audio_fops;
+
+extern int tlv320aic33_write_value(u8 reg, u16 value);
+extern int tlv320aic33_read_value(u8 address, u8 * regValue);
+
+/* TLV320AIC33 read */
+static __inline__ void audio_aic33_read(u8 address, u8 * regValue)
+{
+	tlv320aic33_read_value(address, regValue);
+}
+
+/* TLV320AIC33 write */
+static __inline__ void audio_aic33_write(u8 address, u16 data)
+{
+	if (tlv320aic33_write_value(address, data) < 0)
+		printk(KERN_INFO "aic33 write failed for reg = %d\n", address);
+}
+
+static int aic33_update(int flag, int val)
+{
+	u16 volume;
+	s16 left_gain, left_val, right_gain, right_val;
+
+	switch (flag) {
+	case SET_VOLUME:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 100) {
+			DPRINTK("Trying a bad volume value(%d)!\n", val);
+			return -EPERM;
+		}
+		/* Convert 0 -> 100 volume to 0x77 (LHV_MIN) -> 0x00 (LHV_MAX)
+		 */
+
+		volume =
+		    ((val * OUTPUT_VOLUME_RANGE) / 100) + OUTPUT_VOLUME_MIN;
+
+		aic33_local.volume_reg = OUTPUT_VOLUME_MAX - volume;
+
+		if (aic33_local.nochan == STEREO) {
+			audio_aic33_write(REGISTER_ADDR47, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR64, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR82, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR92, LOPM_ON |
+					  aic33_local.volume_reg);
+		} else if (aic33_local.nochan == MONO) {
+#ifdef CONFIG_MONOSTEREO_DIFFJACK
+			/* DACL1 to MONO_LOP/M routing and volume control */
+			audio_aic33_write(REGISTER_ADDR75, LOPM_ON |
+					  aic33_local.volume_reg);
+			/* DACR1 to MONO_LOP/M routing and volume control */
+			audio_aic33_write(REGISTER_ADDR78, LOPM_ON |
+					  aic33_local.volume_reg);
+#else
+			audio_aic33_write(REGISTER_ADDR47, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR64, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR82, LOPM_ON |
+					  aic33_local.volume_reg);
+			audio_aic33_write(REGISTER_ADDR92, LOPM_ON |
+					  aic33_local.volume_reg);
+#endif
+		}
+
+		break;
+
+	case SET_LINE:
+	case SET_MIC:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 100) {
+			DPRINTK("Trying a bad volume value(%d)!\n", val);
+			return -EPERM;
+		}
+
+		volume = ((val * INPUT_VOLUME_RANGE) / 100) + INPUT_VOLUME_MIN;
+
+		aic33_local.input_volume_reg = volume;
+
+		audio_aic33_write(REGISTER_ADDR15,
+				  aic33_local.input_volume_reg);
+		audio_aic33_write(REGISTER_ADDR16,
+				  aic33_local.input_volume_reg);
+		break;
+
+	case SET_RECSRC:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (hweight32(val) > 1)
+			val &= ~aic33_local.recsrc;
+
+		if (val == SOUND_MASK_MIC) {
+			/* enable the mic input*/
+			DPRINTK("Enabling mic\n");
+			audio_aic33_write(REGISTER_ADDR17, 0x0);
+			audio_aic33_write(REGISTER_ADDR18, 0x0);
+
+			/* enable ADC's and disable the line input*/
+			audio_aic33_write(REGISTER_ADDR19, 0x7C);
+			audio_aic33_write(REGISTER_ADDR22, 0x7C);
+
+		} else if (val == SOUND_MASK_LINE) {
+			/* enable ADC's, enable line iput */
+			DPRINTK(" Enabling line in\n");
+			audio_aic33_write(REGISTER_ADDR19, 0x4);
+			audio_aic33_write(REGISTER_ADDR22, 0x4);
+
+			/* disable the mic input */
+			audio_aic33_write(REGISTER_ADDR17, 0xff);
+			audio_aic33_write(REGISTER_ADDR18, 0xff);
+		} else {
+			/* do nothing */
+		}
+		aic33_local.recsrc = val;
+		break;
+
+	case SET_IGAIN:
+		left_val = val & 0xFF;
+		right_val = val >> 8;
+
+		if (left_val < 0 || left_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
+			return -EPERM;
+		}
+		if (right_val < 0 || right_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
+			return -EPERM;
+		}
+
+		left_gain = ((left_val * INPUT_GAIN_RANGE) / 100) +
+			INPUT_GAIN_MIN;
+		right_gain = ((right_val * INPUT_GAIN_RANGE) / 100) +
+			INPUT_GAIN_MIN;
+
+		DPRINTK("left gain reg val = 0x%x", left_gain << 1);
+		DPRINTK("right gain reg val = 0x%x", left_gain << 1);
+
+		/* Left AGC control */
+		audio_aic33_write(REGISTER_ADDR26, 0x80);
+		audio_aic33_write(REGISTER_ADDR27, left_gain << 1);
+		audio_aic33_write(REGISTER_ADDR28, 0x0);
+
+		/* Right AGC control */
+		audio_aic33_write(REGISTER_ADDR29, 0x80);
+		audio_aic33_write(REGISTER_ADDR30, right_gain << 1);
+		audio_aic33_write(REGISTER_ADDR31, 0x0);
+
+		break;
+
+	case SET_OGAIN:
+		left_val = val & 0xFF;
+		right_val = val >> 8;
+
+		if (left_val < 0 || left_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
+			return -EPERM;
+		}
+		if (right_val < 0 || right_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
+			return -EPERM;
+		}
+
+		left_gain = ((left_val * OUTPUT_GAIN_RANGE) / 100) +
+			OUTPUT_GAIN_MIN;
+		left_gain = OUTPUT_GAIN_MAX - left_gain;
+		right_gain = ((right_val * OUTPUT_GAIN_RANGE) / 100) +
+			OUTPUT_GAIN_MIN;
+		right_gain = OUTPUT_GAIN_MAX - right_gain;
+
+		/* Left/Right DAC digital volume gain */
+		audio_aic33_write(REGISTER_ADDR43, left_gain);
+		audio_aic33_write(REGISTER_ADDR44, right_gain);
+		break;
+
+	case SET_MICBIAS:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 3) {
+			DPRINTK
+			    ("Request for non supported mic bias level(%d)!\n",
+			     val);
+			return -EPERM;
+		}
+
+		if (val == 0)
+			audio_aic33_write(REGISTER_ADDR25, 0x00);
+
+		else if (val == 1)
+			audio_aic33_write(REGISTER_ADDR25, MICBIAS_OUTPUT_2_0V);
+
+		else if (val == 2)
+			audio_aic33_write(REGISTER_ADDR25, MICBIAS_OUTPUT_2_5V);
+
+		else if (val == 3)
+			audio_aic33_write(REGISTER_ADDR25, MICBIAS_OUTPUT_AVDD);
+
+		break;
+
+	case SET_BASS:
+		break;
+
+	case SET_TREBLE:
+		break;
+	}
+	return 0;
+}
+
+static int mixer_open(struct inode *inode, struct file *file)
+{
+	/* Any mixer specific initialization */
+	return 0;
+}
+
+static int mixer_release(struct inode *inode, struct file *file)
+{
+	/* Any mixer specific Un-initialization */
+	return 0;
+}
+
+static int
+mixer_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
+{
+	int val;
+	int ret = 0;
+	int nr = _IOC_NR(cmd);
+
+	/*
+	 * We only accept mixer (type 'M') ioctls.
+	 */
+	if (_IOC_TYPE(cmd) != 'M')
+		return -EINVAL;
+
+	DPRINTK(" 0x%08x\n", cmd);
+
+	if (cmd == SOUND_MIXER_INFO) {
+		struct mixer_info mi;
+
+		strncpy(mi.id, "AIC33", sizeof(mi.id));
+		strncpy(mi.name, "TI AIC33", sizeof(mi.name));
+		mi.modify_counter = aic33_local.mod_cnt;
+
+		return copy_to_user((void *)arg, &mi, sizeof(mi));
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		ret = get_user(val, (int *)arg);
+		if (ret)
+			goto out;
+
+		switch (nr) {
+		case SOUND_MIXER_VOLUME:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_VOLUME, val);
+			if (!ret)
+				aic33_local.volume = val;
+			break;
+
+		case SOUND_MIXER_LINE:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_LINE, val);
+			if (!ret)
+				aic33_local.line = val;
+			break;
+
+		case SOUND_MIXER_MIC:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_MIC, val);
+			if (!ret)
+				aic33_local.mic = val;
+			break;
+
+		case SOUND_MIXER_RECSRC:
+			if ((val & SOUND_MASK_LINE) ||
+			    (val & SOUND_MASK_MIC)) {
+				if (aic33_local.recsrc != val) {
+					aic33_local.mod_cnt++;
+					aic33_update(SET_RECSRC, val);
+				}
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+
+		case SOUND_MIXER_BASS:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_BASS, val);
+			if (!ret)
+				aic33_local.bass = val;
+			break;
+
+		case SOUND_MIXER_TREBLE:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_TREBLE, val);
+			if (!ret)
+				aic33_local.treble = val;
+			break;
+
+		case SOUND_MIXER_IGAIN:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_IGAIN, val);
+			if (!ret)
+				aic33_local.igain = val;
+			break;
+
+		case SOUND_MIXER_OGAIN:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_OGAIN, val);
+			if (!ret)
+				aic33_local.ogain = val;
+			break;
+
+		case SOUND_MIXER_MICBIAS:
+			aic33_local.mod_cnt++;
+			ret = aic33_update(SET_MICBIAS, val);
+			if (!ret)
+				aic33_local.micbias = val;
+			break;
+
+		default:
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == 0 && _IOC_DIR(cmd) & _IOC_READ) {
+		ret = 0;
+
+		switch (nr) {
+		case SOUND_MIXER_VOLUME:
+			val = aic33_local.volume;
+			break;
+		case SOUND_MIXER_LINE:
+			val = aic33_local.line;
+			break;
+		case SOUND_MIXER_MIC:
+			val = aic33_local.mic;
+			break;
+		case SOUND_MIXER_RECSRC:
+			val = aic33_local.recsrc;
+			break;
+		case SOUND_MIXER_RECMASK:
+			val = REC_MASK;
+			break;
+		case SOUND_MIXER_IGAIN:
+			val = aic33_local.igain;
+			break;
+		case SOUND_MIXER_OGAIN:
+			val = aic33_local.ogain;
+			break;
+		case SOUND_MIXER_DEVMASK:
+			val = DEV_MASK;
+			break;
+		case SOUND_MIXER_BASS:
+			val = aic33_local.bass;
+			break;
+		case SOUND_MIXER_TREBLE:
+			val = aic33_local.treble;
+			break;
+		case SOUND_MIXER_CAPS:
+			val = 0;
+			break;
+		case SOUND_MIXER_STEREODEVS:
+			val = SOUND_MASK_VOLUME;
+			break;
+		case SOUND_MIXER_MICBIAS:
+			val = aic33_local.micbias;
+			break;
+		default:
+			val = 0;
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret == 0)
+			ret = put_user(val, (int *)arg);
+	}
+out:
+	return ret;
+}
+
+int davinci_set_samplerate(long sample_rate)
+{
+	u8 count = 0;
+	u8 j_val = 0;
+	u16 d_val = 0;
+
+	/* wait for any frame to complete */
+	udelay(125);
+
+	/* Search for the right sample rate */
+	while ((reg_info[count].sample_rate != sample_rate) &&
+	       (count < NUMBER_SAMPLE_RATES_SUPPORTED)) {
+		count++;
+	}
+
+	if (count == NUMBER_SAMPLE_RATES_SUPPORTED) {
+		DPRINTK("Invalid Sample Rate %d requested\n", (int)sample_rate);
+		return -EPERM;
+	}
+
+	/*   CODEC DATAPATH SETUP  */
+
+	/* Fsref to 48kHz, dual rate mode upto 96kHz */
+	if (reg_info[count].Fsref == 96000)
+		audio_aic33_write(REGISTER_ADDR7,
+				  FS_REF_DEFAULT_48 | ADC_DUAL_RATE_MODE |
+				  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 44.1kHz, dual rate mode upto 88.2kHz */
+	else if (reg_info[count].Fsref == 88200)
+		audio_aic33_write(REGISTER_ADDR7,
+				  FS_REF_44_1 | ADC_DUAL_RATE_MODE |
+				  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 48kHz */
+	else if (reg_info[count].Fsref == 48000)
+		audio_aic33_write(REGISTER_ADDR7,
+				  FS_REF_DEFAULT_48 | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 44.1kHz */
+	else if (reg_info[count].Fsref == 44100)
+		audio_aic33_write(REGISTER_ADDR7, FS_REF_44_1 | LDAC_LCHAN |
+				  RDAC_RCHAN);
+
+	/* Codec sample rate select */
+	audio_aic33_write(REGISTER_ADDR2, reg_info[count].data);
+
+	/* If PLL is to be used for generation of Fsref
+	   Generate the Fsref using the PLL */
+
+	/*Enable the PLL | Q-value | P-value */
+	audio_aic33_write(REGISTER_ADDR3, PLL_ENABLE | 0x10 | 0x02);
+
+	if ((reg_info[count].Fsref == 96000) |
+	    (reg_info[count].Fsref == 48000)) {
+		/*
+		 * For MCLK = 22.5792 MHz and to get Fsref = 48kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R= 1, K = 8.7075, which results in J = 8,
+		 * D = 7075
+		 *
+		 * For MCLK = 27 MHz and to get Fsref = 48kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R= 1, K = 7.2818, which results in J = 7,
+		 * D = 2818
+		 *
+		 * For MCLK = 33.8688 MHz and to get Fsref = 48kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R= 1, K = 5.8049, which results in J = 5,
+		 * D = 8049
+		 */
+
+		switch (aic33_mclk) {
+		case MCLK_22:
+			j_val = 8;
+			d_val = 7075;
+			break;
+		case MCLK_27:
+			j_val = 7;
+			d_val = 2818;
+			break;
+		case MCLK_33:
+			j_val = 5;
+			d_val = 8049;
+			break;
+		default:
+			printk(KERN_ERR "unknown audio codec frequency \n");
+		}
+	} else if ((reg_info[count].Fsref == 88200) |
+		   (reg_info[count].Fsref == 44100)) {
+		/*
+		 * MCLK = 22.5792 MHz and to get Fsref = 44.1kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R =1, K = 8.0000, which results in J = 8,
+		 * D = 0000
+		 *
+		 * MCLK = 27 MHz and to get Fsref = 44.1kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R =1, K = 6.6901, which results in J = 6,
+		 * D = 6901
+		 *
+		 * MCLK = 33.8688 MHz and to get Fsref = 44.1kHz
+		 * Fsref = (MCLK * k * R)/(2048 * p);
+		 * Select P = 2, R =1, K = 5.3333, which results in J = 5,
+		 * D = 3333
+		 */
+
+		switch (aic33_mclk) {
+		case MCLK_22:
+			j_val = 8;
+			d_val = 0;
+			break;
+		case MCLK_27:
+			j_val = 6;
+			d_val = 6901;
+			break;
+		case MCLK_33:
+			j_val = 5;
+			d_val = 3333;
+			break;
+		default:
+			printk(KERN_ERR "unknown audio codec frequency \n");
+		}
+	}
+
+	/* J-value */
+	audio_aic33_write(REGISTER_ADDR4, j_val << 2);
+	/* D-value 8-MSB's */
+	audio_aic33_write(REGISTER_ADDR5, (unsigned char)(d_val >> 6));
+	/* D-value 6-LSB's */
+	audio_aic33_write(REGISTER_ADDR6, (unsigned char)(d_val << 2));
+
+	audio_samplerate = sample_rate;
+
+#ifndef AIC33_MASTER
+	{
+		int clkgdv = 0;
+		unsigned long clkval = 0;
+		struct clk *mbspclk;
+
+		/*
+		   Set Sample Rate at McBSP
+
+		   Formula :
+		   Codec System Clock = Input clock to McBSP;
+		   clkgdv = ((Codec System Clock /
+				(SampleRate * BitsPerSample * 2)) - 1);
+
+		   FWID = BitsPerSample - 1;
+		   FPER = (BitsPerSample * 2) - 1;
+		 */
+
+		mbspclk = davinci_mcbsp_get_clock();
+		if (mbspclk == NULL) {
+			DPRINTK(" Failed to get internal clock to MCBSP");
+			return -EPERM;
+		}
+
+		clkval = clk_get_rate(mbspclk);
+		DPRINTK("mcbsp_clk = %ld\n", clkval);
+
+		if (clkval)
+			clkgdv =
+			    (clkval /
+			     (sample_rate * DEFAULT_BITPERSAMPLE * 2)) - 1;
+		else {
+			DPRINTK(" Failed to get the MCBSP clock\n");
+			return -EPERM;
+		}
+
+		DPRINTK("clkgdv = %d\n", clkgdv);
+
+		if (clkgdv > 255 || clkgdv < 0) {
+
+			/* For requested sampling rate, the input clock to MCBSP
+			   cant be devided down to get the in range clock
+			   divider value for 16 bits sample */
+
+			DPRINTK("Invalid Sample Rate %d requested\n",
+				(int)sample_rate);
+			return -EPERM;
+		}
+
+		initial_config.srgr1 =
+		    (FWID(DEFAULT_BITPERSAMPLE - 1) | CLKGDV(clkgdv));
+
+		initial_config.srgr2 =
+		    (CLKSM | FSGM | FPER(DEFAULT_BITPERSAMPLE * 2 - 1));
+
+		davinci_mcbsp_stop_tx(AUDIO_MCBSP);
+		davinci_mcbsp_stop_rx(AUDIO_MCBSP);
+		davinci_mcbsp_config(AUDIO_MCBSP, &initial_config);
+	}
+#endif				/* AIC33_MASTER */
+
+	return 0;
+}
+
+static void davinci_aic33_shutdown(void *dummy)
+{
+	/*
+	   Turn off codec after it is done.
+	   Can't do it immediately, since it may still have
+	   buffered data.
+
+	   Wait 20ms (arbitrary value) and then turn it off.
+	 */
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(2);
+
+	davinci_mcbsp_stop_tx(AUDIO_MCBSP);
+	davinci_mcbsp_stop_rx(AUDIO_MCBSP);
+	davinci_mcbsp_free(AUDIO_MCBSP);
+
+	/* Self clearing aic33 software reset */
+	audio_aic33_write(1, 0x80);
+}
+
+static void davinci_set_mono_stereo(int mode)
+{
+	if (mode == MONO) {
+
+#ifdef CONFIG_MONOSTEREO_DIFFJACK
+		/* MONO_LOP/M Output level control register */
+		audio_aic33_write(REGISTER_ADDR79, 0x99);
+#else
+		/* Driver power ON pop control */
+		audio_aic33_write(REGISTER_ADDR42, 0x6C);
+
+		/* HPLOUT/HPROUT output level control */
+		audio_aic33_write(REGISTER_ADDR51, 0x99);
+		audio_aic33_write(REGISTER_ADDR65, 0x99);
+
+		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
+		audio_aic33_write(REGISTER_ADDR86, 0x99);
+		audio_aic33_write(REGISTER_ADDR93, 0x99);
+#endif
+		/* Left DAC power up, Right DAC power down */
+		audio_aic33_write(REGISTER_ADDR37, 0xa0);
+	} else if (mode == STEREO) {
+		/* Driver power ON pop control */
+		audio_aic33_write(REGISTER_ADDR42, 0x6C);
+
+		/* HPLOUT/HPROUT output level control */
+		audio_aic33_write(REGISTER_ADDR51, 0x99);
+		audio_aic33_write(REGISTER_ADDR65, 0x99);
+
+		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
+		audio_aic33_write(REGISTER_ADDR86, 0x99);
+		audio_aic33_write(REGISTER_ADDR93, 0x99);
+
+		/* Left/Right DAC power up */
+		audio_aic33_write(REGISTER_ADDR37, 0xe0);
+	} else
+		DPRINTK(" REQUEST FOR INVALID MODE\n");
+}
+
+static inline void aic33_configure()
+{
+	DPRINTK(" CONFIGURING AIC33\n");
+
+	/* Page select register */
+	audio_aic33_write(REGISTER_ADDR0, 0x0);
+
+	/* audio_aic33_write(REGISTER_ADDR38, 0x10); */
+	davinci_set_mono_stereo(aic33_local.nochan);
+#ifdef AIC33_MASTER
+	/* Enable bit and word clock as Master mode, 3-d disabled */
+	audio_aic33_write(REGISTER_ADDR8, 0xc0 /*0xc4 */ );
+#endif
+
+	aic33_update(SET_LINE, aic33_local.line);
+	aic33_update(SET_VOLUME, aic33_local.volume);
+	aic33_update(SET_RECSRC, aic33_local.recsrc);
+	aic33_update(SET_IGAIN, aic33_local.igain);
+	aic33_update(SET_OGAIN, aic33_local.ogain);
+	aic33_update(SET_MICBIAS, aic33_local.micbias);
+}
+
+static void davinci_aic33_initialize(void *dummy)
+{
+	DPRINTK("entry\n");
+
+	/* initialize with default sample rate */
+	audio_samplerate = AUDIO_RATE_DEFAULT;
+
+	if (davinci_mcbsp_request(AUDIO_MCBSP) < 0) {
+		DPRINTK("MCBSP request failed\n");
+		return;
+	}
+
+	/* if configured, then stop mcbsp */
+	davinci_mcbsp_stop_tx(AUDIO_MCBSP);
+	davinci_mcbsp_stop_rx(AUDIO_MCBSP);
+
+	/* set initial (default) sample rate */
+	davinci_set_samplerate(audio_samplerate);
+
+	davinci_mcbsp_config(AUDIO_MCBSP, &initial_config);
+
+	DPRINTK("exit\n");
+}
+
+static int
+davinci_aic33_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
+{
+	long val;
+	int ret = 0;
+
+	DPRINTK(" 0x%08x\n", cmd);
+
+	/*
+	 * These are platform dependent ioctls which are not handled by the
+	 * generic davinci-audio module.
+	 */
+	switch (cmd) {
+	case SNDCTL_DSP_STEREO:
+		ret = get_user(val, (int *)arg);
+		if (ret)
+			return ret;
+		/* the Davinci supports AIC33 as stereo, mono on stereo jack */
+		ret = (val == 0) ? -EINVAL : 1;
+		return put_user(ret, (int *)arg);
+
+	case SNDCTL_DSP_CHANNELS:
+
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		if (val == STEREO) {
+			DPRINTK("Driver support for AIC33 as stereo\n");
+			aic33_local.nochan = STEREO;
+			davinci_set_mono_stereo(aic33_local.nochan);
+		} else if (val == MONO) {
+			DPRINTK("Driver support for AIC33 as mono\n");
+			aic33_local.nochan = MONO;
+			davinci_set_mono_stereo(aic33_local.nochan);
+		} else {
+			DPRINTK
+			    ("Driver support for AIC33 as stereo/mono mode\n");
+			return -EPERM;
+		}
+
+	case SOUND_PCM_READ_CHANNELS:
+		/* the Davinci supports AIC33 as stereo, mono on stereo jack */
+		if (aic33_local.nochan == MONO)
+			return put_user(MONO, (long *)arg);
+		else
+			return put_user(STEREO, (long *)arg);
+
+	case SNDCTL_DSP_SPEED:
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		ret = davinci_set_samplerate(val);
+		if (ret) {
+			DPRINTK("davinci_set_samplerate failed\n");
+			break;
+		}
+		/* fall through */
+
+	case SOUND_PCM_READ_RATE:
+		return put_user(audio_samplerate, (long *)arg);
+
+	case SNDCTL_DSP_SETFMT:	/* set Format */
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		if (val != AFMT_S16_LE) {
+			DPRINTK
+			    ("Driver supports only AFMT_S16_LE audio format\n");
+			return -EPERM;
+		}
+
+	case SOUND_PCM_READ_BITS:
+	case SNDCTL_DSP_GETFMTS:
+		/* we can do 16-bit only */
+		return put_user(AFMT_S16_LE, (long *)arg);
+
+	default:
+		/* Maybe this is meant for the mixer (As per OSS Docs) */
+		return mixer_ioctl(inode, file, cmd, arg);
+	}
+
+	return ret;
+}
+
+static int davinci_aic33_probe(void)
+{
+	davinci_audio_fops = audio_get_fops();
+
+	/* Get the fops from audio oss driver */
+	if (!davinci_audio_fops) {
+		DPRINTK
+		    ("Unable to get the file operations for AIC33 OSS\
+			driver\n");
+
+		audio_unregister_codec(&aic33_state);
+		return -EPERM;
+	}
+
+	aic33_local.volume = DEFAULT_OUTPUT_VOLUME;
+	aic33_local.line = DEFAULT_INPUT_VOLUME;
+	/* either of SOUND_MASK_LINE/SOUND_MASK_MIC */
+	aic33_local.recsrc = SOUND_MASK_LINE;
+	aic33_local.igain = DEFAULT_INPUT_IGAIN | (DEFAULT_INPUT_IGAIN << 8);
+	aic33_local.ogain = DEFAULT_INPUT_OGAIN | (DEFAULT_INPUT_OGAIN << 8);
+	aic33_local.nochan = STEREO;
+	aic33_local.micbias = 1;
+	aic33_local.mod_cnt = 0;
+
+	/* register devices */
+	audio_dev_id = register_sound_dsp(davinci_audio_fops, -1);
+	mixer_dev_id = register_sound_mixer(&davinci_mixer_fops, -1);
+
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry(PROC_START_FILE, 0 /* default mode */ ,
+			       NULL /* parent dir */ ,
+			       codec_start, NULL /* client data */ );
+
+	create_proc_read_entry(PROC_STOP_FILE, 0 /* default mode */ ,
+			       NULL /* parent dir */ ,
+			       codec_stop, NULL /* client data */ );
+#endif
+
+	/* Announcement Time */
+	DPRINTK(PLATFORM_NAME " " CODEC_NAME " audio support initialized\n");
+	return 0;
+}
+
+#ifdef MODULE
+static void __exit davinci_aic33_remove(void)
+{
+	/* Un-Register the codec with the audio driver */
+	unregister_sound_dsp(audio_dev_id);
+	unregister_sound_mixer(mixer_dev_id);
+
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry(PROC_START_FILE, NULL);
+	remove_proc_entry(PROC_STOP_FILE, NULL);
+#endif
+}
+#endif				/* MODULE */
+
+static int davinci_aic33_suspend(void)
+{
+	/* Empty for the moment */
+	return 0;
+}
+
+static int davinci_aic33_resume(void)
+{
+	/* Empty for the moment */
+	return 0;
+}
+
+static int __init audio_aic33_init(void)
+{
+	int err = 0;
+
+	if (cpu_is_davinci_dm355()) {
+		input_stream.dma_dev = DM355_DMA_MCBSP1_RX;
+		output_stream.dma_dev = DM355_DMA_MCBSP1_TX;
+		aic33_mclk = MCLK_27;
+	}
+
+	if (cpu_is_davinci_dm644x()) {
+		input_stream.dma_dev = DAVINCI_DMA_MCBSP_RX;
+		output_stream.dma_dev = DAVINCI_DMA_MCBSP_TX;
+		aic33_mclk = MCLK_22;
+	}
+
+	err = audio_register_codec (&aic33_state);
+
+	/* register the codec with the audio driver */
+	if (err) {
+		DPRINTK
+		    ("Failed to register AIC33 driver with Audio OSS Driver\n");
+	} else {
+		DPRINTK("codec driver register success\n");
+	}
+
+	/* configure aic33 with default params */
+	aic33_configure();
+
+	return err;
+}
+
+static void __exit audio_aic33_exit(void)
+{
+	davinci_aic33_shutdown(NULL);
+	(void)audio_unregister_codec(&aic33_state);
+	return;
+}
+
+#ifdef CONFIG_PROC_FS
+static int codec_start(char *buf, char **start, off_t offset, int count,
+		       int *eof, void *data)
+{
+	davinci_aic33_initialize(NULL);
+
+	DPRINTK("AIC33 codec initialization done.\n");
+	return 0;
+}
+
+static int codec_stop(char *buf, char **start, off_t offset, int count,
+		      int *eof, void *data)
+{
+	davinci_aic33_shutdown(NULL);
+
+	DPRINTK("AIC33 codec shutdown.\n");
+	return 0;
+}
+#endif				/* CONFIG_PROC_FS */
+
+module_init(audio_aic33_init);
+module_exit(audio_aic33_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("Glue audio driver for the TI AIC33 codec.");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/dm644x/davinci-audio-dma-intfc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-audio-dma-intfc.c
@@ -0,0 +1,1147 @@
+
+/*
+ * linux/sound/oss/davinci-audio-dma-intfc.c
+ *
+ * Common audio DMA handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2004-06-07   Sriram Kannan   - Created new file from
+ *				  omap_audio_dma_intfc.c. This file will contain
+ *				  only the DMA interface and buffer handling of
+ *				  OMAP audio driver.
+ *
+ * 2004-06-22   Sriram Kannan   - removed legacy code (auto-init). Self-linking
+ * 				  of DMA logical channel.
+ *
+ * 2004-08-12   Nishanth Menon  - Modified to integrate Audio requirements on
+ * 				  1610,1710 platforms
+ *
+ * 2004-11-01   Nishanth Menon  - 16xx platform code base modified to support
+ * 				  multi channel chaining.
+ *
+ * 2004-12-15   Nishanth Menon  - Improved 16xx platform channel logic
+ * 				  introduced - tasklets, queue handling updated
+ *
+ * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI
+ * 						     Davinci DM644x processor
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/sysrq.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/semaphore.h>
+#include <asm/delay.h>
+
+#include <asm/arch/mcbsp.h>
+#include <asm/arch/edma.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/cpu.h>
+
+#include "davinci-audio-dma-intfc.h"
+#include "davinci-audio.h"
+
+#undef DEBUG
+/* #define DEBUG */
+#ifdef DEBUG
+#define DPRINTK(ARGS...)  do {\
+				printk(KERN_INFO "<%s>: ", __FUNCTION__);\
+				printk(KERN_INFO ARGS);\
+			  } while (0)
+#define FN_IN printk(KERN_INFO "[%s]: start\n", __FUNCTION__)
+#define FN_OUT(n) printk(KERN_INFO "[%s]: end(%u)\n", __FUNCTION__, n)
+#else
+
+#define DPRINTK( x... )
+#define FN_IN
+#define FN_OUT(x)
+#endif
+
+#define ERR(ARGS...)	do {\
+				printk(KERN_ERR "{%s}-ERROR: ", __FUNCTION__);\
+				printk(KERN_ERR ARGS);\
+			} while (0)
+#define AUDIO_NAME                  "davinci-audio"
+#define MCBSP_DXR   (cpu_is_davinci_dm355() ? 0x01E04004 : 0x01E02004)
+#define MCBSP_DRR   (cpu_is_davinci_dm355() ? 0x01E04000 : 0x01E02000)
+
+#define AUDIO_ACTIVE(state)     ((state)->rd_ref || (state)->wr_ref)
+
+#define SPIN_ADDR                    (dma_addr_t)0
+#define SPIN_SIZE                    2048
+
+#define NUMBER_OF_CHANNELS_TO_LINK  2
+
+/* Channel Queue Handling macros
+ * tail always points to the current free entry
+ * Head always points to the current entry being used
+ * end is either head or tail
+ */
+#define AUDIO_QUEUE_INIT(s) s->dma_q_head = s->dma_q_tail = s->dma_q_count = 0;
+#define AUDIO_QUEUE_FULL(s) (NUMBER_OF_CHANNELS_TO_LINK == s->dma_q_count)
+#define AUDIO_QUEUE_LAST(s) (1 == s->dma_q_count)
+#define AUDIO_QUEUE_EMPTY(s) (0 == s->dma_q_count)
+#define __AUDIO_INCREMENT_QUEUE(end) ((end) = \
+				      ((end)+1)%NUMBER_OF_CHANNELS_TO_LINK)
+
+#define AUDIO_INCREMENT_HEAD(s) do {\
+					__AUDIO_INCREMENT_QUEUE(s->dma_q_head);\
+					s->dma_q_count--;\
+				} while (0)
+#define AUDIO_INCREMENT_TAIL(s) do {\
+					__AUDIO_INCREMENT_QUEUE(s->dma_q_tail);\
+					s->dma_q_count++;\
+				} while (0)
+
+/* DMA buffer fragmentation sizes */
+#define MAX_DMA_SIZE         (0xffff*2)
+#define CUT_DMA_SIZE         MAX_DMA_SIZE
+
+/**************************** DATA STRUCTURES *********************************/
+
+struct audio_isr_work_item {
+	int current_lch;
+	u16 ch_status;
+	audio_stream_t *s;
+};
+
+static char work_item_running;
+static struct audio_isr_work_item work1, work2;
+
+/*********************** MODULE SPECIFIC FUNCTIONS PROTOTYPES ****************/
+
+static void audio_dsr_handler(unsigned long);
+DECLARE_TASKLET(audio_isr_work1, audio_dsr_handler, (unsigned long)&work1);
+DECLARE_TASKLET(audio_isr_work2, audio_dsr_handler, (unsigned long)&work2);
+
+static void sound_dma_irq_handler(int lch, u16 ch_status, void *data);
+static void audio_dma_callback(int lch, u16 ch_status, void *data);
+static int davinci_start_sound_dma(audio_stream_t *s, dma_addr_t dma_ptr,
+				   u_int size);
+static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
+				     u_int dma_size);
+static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
+					u_int dma_size);
+static int audio_start_dma_chain(audio_stream_t *s);
+
+/************************** GLOBAL FUNCTIONS DEFINTIONS ***********************/
+
+/*******************************************************************************
+ *
+ * Buffer creation/destruction
+ *
+ ******************************************************************************/
+int audio_setup_buf(audio_stream_t *s)
+{
+	int frag;
+	int dmasize = 0;
+	char *dmabuf = NULL;
+	dma_addr_t dmaphys = 0;
+	FN_IN;
+
+	if (s->buffers) {
+		FN_OUT(1);
+		return -EBUSY;
+	}
+
+	/* Allocate memory for all buffer fragments */
+	s->buffers = kmalloc(sizeof(audio_buf_t) * s->nbfrags, GFP_KERNEL);
+	if (!s->buffers)
+		goto err;
+
+	/* Initialise all the memory to 0 */
+	memset(s->buffers, 0, sizeof(audio_buf_t) * s->nbfrags);
+
+	for (frag = 0; frag < s->nbfrags; frag++) {
+		audio_buf_t *b = &s->buffers[frag];
+
+		/*
+		 * Let's allocate non-cached memory for DMA buffers.
+		 * We try to allocate all memory at once.
+		 * If this fails (a common reason is memory fragmentation),
+		 * then we allocate more smaller buffers.
+		 */
+		if (!dmasize) {
+			dmasize = (s->nbfrags - frag) * s->fragsize;
+			do {
+				/* allocate consistent memory for DMA
+				   dmaphys(handle)= device viewed address.
+				   dmabuf = CPU-viewed address */
+				dmabuf =
+				    dma_alloc_coherent(NULL, dmasize, &dmaphys,
+						       0);
+
+				/* For allocating the IRAM memory */
+				/*
+				   dmaphys =
+				   (dma_addr_t)(DAVINCI_IRAM_BASE + 0x1000);
+				   dmabuf = (DAVINCI_IRAM_VIRT + 0x1000);
+				*/
+				if (!dmabuf)
+					dmasize -= s->fragsize;
+			}
+			while (!dmabuf && dmasize);
+
+			if (!dmabuf)
+				goto err;
+
+			b->master = dmasize;
+			memzero(dmabuf, dmasize);
+		}
+		b->data = dmabuf;
+		b->dma_addr = dmaphys;
+		dmabuf += s->fragsize;
+		dmaphys += s->fragsize;
+		dmasize -= s->fragsize;
+	}
+	s->usr_head = s->dma_head = s->dma_tail = 0;
+	AUDIO_QUEUE_INIT(s);
+	s->started = 0;
+	s->mcbsp_tx_started = 0;
+	s->mcbsp_rx_started = 0;
+
+	atomic_set(&s->playing_null, 0);
+
+	s->dma_started = 0;
+	s->bytecount = 0;
+	s->fragcount = 0;
+	s->prevbuf = 0;
+
+	init_completion(&s->wfc);
+	s->wfc.done = s->nbfrags;
+
+	FN_OUT(0);
+	return 0;
+err:
+	audio_discard_buf(s);
+	FN_OUT(1);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(audio_setup_buf);
+
+void audio_discard_buf(audio_stream_t *s)
+{
+	FN_IN;
+	/* ensure DMA isn't using those buffers */
+	audio_reset(s);
+	if (s->buffers) {
+		int frag;
+		for (frag = 0; frag < s->nbfrags; frag++) {
+			if (!s->buffers[frag].master)
+				continue;
+
+			dma_free_coherent(NULL,
+					  s->buffers[frag].master,
+					  s->buffers[frag].data,
+					  s->buffers[frag].dma_addr);
+
+		}
+		kfree(s->buffers);
+		s->buffers = NULL;
+	}
+	FN_OUT(0);
+}
+EXPORT_SYMBOL(audio_discard_buf);
+
+/*******************************************************************************
+ *
+ * DMA channel requests
+ *
+ ******************************************************************************/
+
+#define NULL_FRAGSIZE (1024)
+static char null_buffer[NULL_FRAGSIZE]; /* FIXME. Should it be global */
+
+int
+davinci_request_sound_dma(int device_id, const char *device_name, void *data,
+			  int *master_ch, int **channels)
+{
+	int i, err = 0;
+	int *chan = NULL;
+	int tcc;
+	audio_stream_t *stream = (audio_stream_t *)data;
+	edmacc_paramentry_regs temp;
+
+	FN_IN;
+	if (unlikely((NULL == channels) || (NULL == device_name))) {
+		BUG();
+		return -EPERM;
+	}
+	/* Try allocate memory for the num channels */
+	*channels = (int *)kmalloc(sizeof(int) * NUMBER_OF_CHANNELS_TO_LINK,
+				   GFP_KERNEL);
+	chan = *channels;
+	if (NULL == chan) {
+		ERR("No Memory for channel allocs!\n");
+		FN_OUT(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	/* request for the Master channel and setup the params */
+	i = 0;
+	err = davinci_request_dma(device_id, device_name,
+				  sound_dma_irq_handler, data, master_ch, &tcc,
+				  EVENTQ_0);
+
+	/* Handle Failure condition here */
+	if (err < 0) {
+		ERR("Error in requesting Master channel %d = 0x%x\n", device_id,
+		    err);
+
+		FN_OUT(err);
+		return err;
+
+	}
+
+	DPRINTK("Master chan = %d\n", *master_ch);
+
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		err = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, device_name,
+					  sound_dma_irq_handler, data, &chan[i],
+					  &tcc, EVENTQ_0);
+
+		/* Handle Failure condition here */
+		if (err < 0) {
+			int j;
+
+			for (j = 0; j < i; j++)
+				davinci_free_dma(chan[j]);
+
+			kfree(chan);
+			*channels = NULL;
+			ERR("Error in requesting channel %d=0x%x\n", i, err);
+			FN_OUT(err);
+			return err;
+		}
+	}
+
+	/* Chain the channels together */
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		int cur_chan = chan[i];
+		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 ==
+				 i) ? chan[0] : chan[i + 1]);
+		davinci_dma_link_lch(cur_chan, nex_chan);
+	}
+
+	if ( stream->input_or_output == FMODE_WRITE ) {
+	    err = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, device_name,
+				      sound_dma_irq_handler, data,
+				      &stream->null_lch, &tcc, EVENTQ_0);
+
+	    /* Handle Failure condition here */
+	    if (err < 0) {
+		int j;
+		for (j = 0; j < i; j++)
+		    davinci_free_dma(chan[j]);
+
+		kfree(chan);
+		*channels = NULL;
+		ERR("Error in requesting channel for NULL transfer\n");
+		FN_OUT(err);
+		return err;
+	    }
+
+	    memset(null_buffer, 0, NULL_FRAGSIZE);
+	    davinci_dma_link_lch(stream->null_lch, stream->null_lch);
+	    audio_set_dma_params_play (stream->null_lch
+				       , (dma_addr_t)null_buffer,
+				       NULL_FRAGSIZE);
+
+		    /* Disable interrupts for the null buffer */
+	    davinci_get_dma_params(stream->null_lch, &temp);
+	    temp.opt = (temp.opt & 0xFFEFFFFF);
+	    davinci_set_dma_params(stream->null_lch, &temp);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_request_sound_dma);
+
+/******************************************************************************
+ *
+ * DMA channel requests Freeing
+ *
+ ******************************************************************************/
+int davinci_free_sound_dma(int master_ch, int **channels, void *data)
+{
+	int i;
+	int *chan = NULL;
+	audio_stream_t *stream = (audio_stream_t *)data;
+
+	FN_IN;
+	if (unlikely(NULL == channels)) {
+		BUG();
+		return -EPERM;
+	}
+	if (unlikely(NULL == *channels)) {
+		BUG();
+		return -EPERM;
+	}
+	chan = (*channels);
+
+	/* release the Master channel */
+	davinci_free_dma(master_ch);
+
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		int cur_chan = chan[i];
+		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 == i) ?
+				chan[0] : chan[i + 1]);
+
+		davinci_dma_unlink_lch(cur_chan, nex_chan);
+		davinci_free_dma(cur_chan);
+	}
+	kfree(*channels);
+	*channels = NULL;
+
+	if ( stream->input_or_output == FMODE_WRITE ) {
+	    davinci_free_dma(stream->null_lch);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_free_sound_dma);
+
+/*******************************************************************************
+ *
+ * Process DMA requests - This will end up starting the transfer.
+ * Proper fragments of Transfers will be initiated.
+ *
+ ******************************************************************************/
+int audio_process_dma(audio_stream_t *s)
+{
+	int ret = 0;
+	unsigned long flags;
+	FN_IN;
+
+	/* Dont let the ISR over ride touching the in_use flag */
+	local_irq_save(flags);
+	if (1 == s->in_use) {
+		local_irq_restore(flags);
+		DPRINTK("Called again while In Use\n");
+		return 0;
+	}
+	s->in_use = 1;
+	local_irq_restore(flags);
+
+	if (s->stopped)
+		goto spin;
+
+	if (s->dma_spinref > 0 && s->pending_frags) {
+		s->dma_spinref = 0;
+		DMA_CLEAR(s);
+	}
+
+	while (s->pending_frags) {
+		audio_buf_t *b = &s->buffers[s->dma_head];
+		u_int dma_size = s->fragsize - b->offset;
+
+		if (dma_size > MAX_DMA_SIZE) {
+			DPRINTK("dma_size > MAX_DMA_SIZE\n");
+			dma_size = CUT_DMA_SIZE;
+		}
+
+		ret = davinci_start_sound_dma(s, b->dma_addr + b->offset,
+					      dma_size);
+		if (ret) {
+			DPRINTK("error\n");
+			goto process_out;
+		}
+
+		b->dma_ref++;
+		b->offset += dma_size;
+		if (b->offset >= s->fragsize) {
+			s->pending_frags--;
+			if (++s->dma_head >= s->nbfrags)
+				s->dma_head = 0;
+		}
+	}
+spin:
+	if (s->spin_idle) {
+		int spincnt = 0;
+		DPRINTK("we are spinning\n");
+		while (davinci_start_sound_dma(s, SPIN_ADDR, SPIN_SIZE) == 0)
+			spincnt++;
+		/*
+		 * Note: if there is still a data buffer being
+		 * processed then the ref count is negative.  This
+		 * allows for the DMA termination to be accounted in
+		 * the proper order.  Of course dma_spinref can't be
+		 * greater than 0 if dma_ref is not 0 since we kill
+		 * the spinning above as soon as there is real data to process.
+		 */
+		if (s->buffers && s->buffers[s->dma_tail].dma_ref)
+			spincnt = -spincnt;
+		s->dma_spinref += spincnt;
+	}
+
+process_out:
+	s->in_use = 0;
+
+	FN_OUT(ret);
+	return ret;
+}
+EXPORT_SYMBOL(audio_process_dma);
+
+/*******************************************************************************
+ *
+ * Prime Rx - Since the recieve buffer has no time limit as to when it would
+ *            arrive, we need to prime it
+ *
+ ******************************************************************************/
+void audio_prime_rx(audio_state_t *state)
+{
+	audio_stream_t *is = state->input_stream;
+
+	FN_IN;
+	if (state->need_tx_for_rx) {
+		/*
+		 * With some codecs like the Philips UDA1341 we must ensure
+		 * there is an output stream at any time while recording since
+		 * this is how the UDA1341 gets its clock from the SA1100.
+		 * So while there is no playback data to send, the output DMA
+		 * will spin with all zeroes.  We use the cache flush special
+		 * area for that.
+		 */
+		state->output_stream->spin_idle = 1;
+		audio_process_dma(state->output_stream);
+	}
+	is->pending_frags = is->nbfrags;
+
+	init_completion(&is->wfc);
+	is->wfc.done = 0;
+
+	is->active = 1;
+	audio_process_dma(is);
+
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_prime_rx);
+
+/*******************************************************************************
+ *
+ * set the fragment size
+ *
+ ******************************************************************************/
+int audio_set_fragments(audio_stream_t *s, int val)
+{
+	FN_IN;
+	if (s->active)
+		return -EBUSY;
+	if (s->buffers)
+		audio_discard_buf(s);
+	s->nbfrags = (val >> 16) & 0x7FFF;
+	val &= 0xFFFF;
+	if (val < 4)
+		val = 4;
+	if (val > 15)
+		val = 15;
+	s->fragsize = 1 << val;
+	if (s->nbfrags < 2)
+		s->nbfrags = 2;
+	if (s->nbfrags * s->fragsize > 128 * 1024)
+		s->nbfrags = 128 * 1024 / s->fragsize;
+	FN_OUT(0);
+	if (audio_setup_buf(s))
+		return -ENOMEM;
+	return val | (s->nbfrags << 16);
+
+}
+EXPORT_SYMBOL(audio_set_fragments);
+
+/*******************************************************************************
+ *
+ * Sync up the buffers before we shutdown, else under-run errors will happen
+ *
+ ******************************************************************************/
+int audio_sync(struct file *file)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->output_stream;
+	audio_buf_t *b;
+	u_int shiftval = 0;
+	unsigned long flags;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	FN_IN;
+
+	if (!(file->f_mode & FMODE_WRITE) || !s->buffers || s->mapped) {
+		FN_OUT(1);
+		return 0;
+	}
+
+	/*
+	 * Send current buffer if it contains data.  Be sure to send
+	 * a full sample count.
+	 */
+	b = &s->buffers[s->usr_head];
+	mdelay(20);
+
+	b->offset &= ~3;
+
+	if (b->offset) {
+		/*wait for a buffer to become free */
+		if (wait_for_completion_interruptible(&s->wfc))
+			return 0;
+		/*
+		 * HACK ALERT !
+		 * To avoid increased complexity in the rest of the code
+		 * where full fragment sizes are assumed, we cheat a little
+		 * with the start pointer here and don't forget to restore
+		 * it later.
+		 */
+		shiftval = s->fragsize - b->offset;
+		b->offset = shiftval;
+		b->dma_addr -= shiftval;
+		b->data -= shiftval;
+		local_irq_save(flags);
+		s->bytecount -= shiftval;
+		if (++s->usr_head >= s->nbfrags)
+			s->usr_head = 0;
+
+		s->pending_frags++;
+		audio_process_dma(s);
+		local_irq_restore(flags);
+	}
+
+	/* Let's wait for all buffers to complete */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&s->wq, &wait);
+
+	while ((s->pending_frags || (s->wfc.done < s->nbfrags))
+	       && !signal_pending(current)) {
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&s->wq, &wait);
+
+	/* undo the pointer hack above */
+	if (shiftval) {
+		local_irq_save(flags);
+		b->dma_addr += shiftval;
+		b->data += shiftval;
+		/* ensure sane DMA code behavior if not yet processed */
+		if (b->offset != 0)
+			b->offset = s->fragsize;
+		local_irq_restore(flags);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(audio_sync);
+
+/*******************************************************************************
+ *
+ * Stop all the DMA channels of the stream
+ *
+ ******************************************************************************/
+void audio_stop_dma(audio_stream_t *s)
+{
+
+	unsigned long flags;
+	FN_IN;
+	DPRINTK("audio_stop_dma\n");
+
+	if (s->dma_spinref > 0 || !s->buffers)
+		return;
+
+	local_irq_save(flags);
+
+	if (s->mcbsp_tx_started || s->mcbsp_rx_started) {
+		if (s->input_or_output == FMODE_WRITE) {
+			if (!cpu_is_davinci_dm355())
+				davinci_mcbsp_stop_tx(0);
+			else
+				davinci_mcbsp_stop_tx(1);
+
+			s->mcbsp_tx_started = 0;
+		} else {
+			if (!cpu_is_davinci_dm355())
+				davinci_mcbsp_stop_rx(0);
+			else
+				davinci_mcbsp_stop_rx(1);
+
+			s->mcbsp_rx_started = 0;
+		}
+	}
+	s->started = 0;
+
+	if (s->spin_idle) {
+		/*
+		  DMA_START(s, SPIN_ADDR, SPIN_SIZE);
+		  DMA_START(s, SPIN_ADDR, SPIN_SIZE);
+		*/
+		s->dma_spinref = 2;
+	} else
+		s->dma_spinref = 0;
+
+	local_irq_restore(flags);
+
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_stop_dma);
+
+/*******************************************************************************
+ *
+ * Get the dma posn
+ *
+ ******************************************************************************/
+u_int audio_get_dma_pos(audio_stream_t *s)
+{
+	audio_buf_t *b = &s->buffers[s->dma_tail];
+	u_int offset = 0;
+
+	FN_IN;
+	if (b->dma_ref) {
+		edmacc_paramentry_regs temp;
+
+		davinci_get_dma_params(s->master_ch, &temp);
+
+		if (s->input_or_output == FMODE_WRITE)
+			offset = temp.src - b->dma_addr;
+		else if (s->input_or_output == FMODE_READ)
+			offset = temp.dst - b->dma_addr;
+		if (offset >= s->fragsize)
+			offset = s->fragsize - 4;
+	} else if (s->pending_frags) {
+		offset = b->offset;
+	} else {
+		offset = 0;
+	}
+	FN_OUT(offset);
+	return offset;
+}
+EXPORT_SYMBOL(audio_get_dma_pos);
+
+/*******************************************************************************
+ *
+ * Reset the audio buffers
+ *
+ ******************************************************************************/
+void audio_reset(audio_stream_t *s)
+{
+	audio_buf_t *b;
+	FN_IN;
+	if (s->buffers) {
+		audio_stop_dma(s);
+		/* back up pointers to be ready to restart from the same spot */
+		while (s->dma_head != s->dma_tail) {
+			b = &s->buffers[s->dma_head];
+			if (b->dma_ref) {
+				b->dma_ref = 0;
+				b->offset = 0;
+			}
+			s->pending_frags++;
+			if (s->dma_head == 0)
+				s->dma_head = s->nbfrags;
+			s->dma_head--;
+		}
+		b = &s->buffers[s->dma_head];
+		if (b->dma_ref) {
+			b->offset = 0;
+			b->dma_ref = 0;
+		}
+
+		s->buffers[s->dma_head].offset = 0;
+		s->buffers[s->usr_head].offset = 0;
+		s->usr_head = s->dma_head;
+		s->pending_frags = 0;
+		init_completion(&s->wfc);
+		s->wfc.done = s->nbfrags;
+	}
+	AUDIO_QUEUE_INIT(s);
+	s->active = 0;
+	s->stopped = 0;
+	s->started = 0;
+	s->dma_started = 0;
+
+	davinci_stop_dma(s->master_ch);
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_reset);
+
+/*******************************************************************************
+ *
+ * Clear any pending transfers
+ *
+ ******************************************************************************/
+void davinci_clear_sound_dma(audio_stream_t *s)
+{
+	FN_IN;
+	/* davinci_clear_dma(s->lch[s->dma_q_head]); */
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(davinci_clear_sound_dma);
+
+/*******************************************************************************
+ *
+ * DMA related functions
+ *
+ ******************************************************************************/
+static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
+				     u_int dma_size)
+{
+	FN_IN;
+	DPRINTK("audio_set_dma_params_play channel = %d dma_ptr = %x \
+		dma_size = %x\n", channel, dma_ptr, dma_size);
+
+	davinci_set_dma_src_params(channel, (unsigned long)(dma_ptr), 0, 0);
+	davinci_set_dma_dest_params(channel, (unsigned long)MCBSP_DXR, 0, 0);
+	davinci_set_dma_src_index(channel, 2, 0);
+	davinci_set_dma_dest_index(channel, 0, 0);
+	davinci_set_dma_transfer_params(channel, 2, dma_size / 2, 1, 0, ASYNC);
+
+	FN_OUT(0);
+	return 0;
+}
+
+static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
+					u_int dma_size)
+{
+	FN_IN;
+	DPRINTK("audio_set_dma_params_capture channel = %d dma_ptr = %x \
+		dma_size = %x\n", channel, dma_ptr, dma_size);
+
+	davinci_set_dma_src_params(channel, (unsigned long)MCBSP_DRR, 0, 0);
+	davinci_set_dma_dest_params(channel, (unsigned long)(dma_ptr), 0, 0);
+	davinci_set_dma_src_index(channel, 0, 0);
+	davinci_set_dma_dest_index(channel, 2, 0);
+	davinci_set_dma_transfer_params(channel, 2, dma_size / 2, 1, 0, ASYNC);
+
+	FN_OUT(0);
+	return 0;
+}
+
+static int audio_start_dma_chain(audio_stream_t *s)
+{
+	unsigned long flags;
+	int channel = s->lch[s->dma_q_head];
+	FN_IN;
+
+	if (!s->started) {
+		edmacc_paramentry_regs temp;
+		davinci_get_dma_params(channel, &temp);
+		davinci_set_dma_params(s->master_ch, &temp);
+		s->started = 1;
+
+		if (!s->dma_started) {
+			davinci_start_dma(s->master_ch);
+			s->dma_started = 1;
+		}
+		local_irq_save(flags);
+		if (!s->mcbsp_tx_started || !s->mcbsp_rx_started) {
+			local_irq_restore(flags);
+			if (s->input_or_output == FMODE_WRITE) {
+				if (!cpu_is_davinci_dm355())
+					davinci_mcbsp_start_tx(0);
+				else
+					davinci_mcbsp_start_tx(1);
+
+				s->mcbsp_tx_started = 1;
+			} else {
+				if (!cpu_is_davinci_dm355())
+					davinci_mcbsp_start_rx(0);
+				else
+					davinci_mcbsp_start_rx(1);
+
+				s->mcbsp_rx_started = 1;
+			}
+			local_irq_restore(flags);
+		} else
+			local_irq_restore(flags);
+	}
+
+	if (s->input_or_output == FMODE_WRITE &&
+	    atomic_read(&s->playing_null) == 1) {
+	    edmacc_paramentry_regs temp;
+	    davinci_get_dma_params(channel, &temp);
+	    davinci_set_dma_params(s->master_ch, &temp);
+	    atomic_set(&s->playing_null, 0);
+	}
+
+	/* else the dma itself will progress forward with out our help */
+	FN_OUT(0);
+	return 0;
+}
+
+/* Start DMA -
+ * Do the initial set of work to initialize all the channels as required.
+ * We shall then initate a transfer
+ */
+
+static int davinci_start_sound_dma(audio_stream_t *s, dma_addr_t dma_ptr,
+				   u_int dma_size)
+{
+	int ret = -EPERM;
+
+	FN_IN;
+	if (unlikely(dma_size > MAX_DMA_SIZE)) {
+		ERR("DmaSoundDma: Start: overflowed %d-%d\n", dma_size,
+		    MAX_DMA_SIZE);
+		return -EOVERFLOW;
+	}
+
+	if (AUDIO_QUEUE_FULL(s)) {
+		DPRINTK("queue full\n");
+		ret = -2;
+		goto sound_out;
+	}
+	if (s->input_or_output == FMODE_WRITE)
+		/*playback */
+	{
+		ret = audio_set_dma_params_play(s->lch[s->dma_q_tail],
+						dma_ptr, dma_size);
+	} else {
+		ret = audio_set_dma_params_capture(s->lch[s->dma_q_tail],
+						   dma_ptr, dma_size);
+	}
+	if (ret != 0) {
+		ret = -2;	/* indicate queue full */
+		goto sound_out;
+	}
+	AUDIO_INCREMENT_TAIL(s);
+	ret = audio_start_dma_chain(s);
+	if (ret) {
+		ERR("dma start failed");
+	}
+
+sound_out:
+	FN_OUT(ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * ISR related functions
+ *
+ ******************************************************************************/
+/* The work item handler */
+static void audio_dsr_handler(unsigned long inData)
+{
+	void *data = (void *)inData;
+	struct audio_isr_work_item *work = data;
+	audio_stream_t *s = (work->s);
+	int sound_curr_lch = work->current_lch;
+	u16 ch_status = work->ch_status;
+
+	FN_IN;
+	DPRINTK("lch=%d,status=0x%x, data=%p as=%p\n", sound_curr_lch,
+		ch_status, data, s);
+	if (AUDIO_QUEUE_EMPTY(s)) {
+		DPRINTK("Interrupt(%d)  for empty queue(h=%d, T=%d)???\n",
+			sound_curr_lch, s->dma_q_head, s->dma_q_tail);
+		DPRINTK("nbfrag=%d,pendfrags=%d,USR-H=%d, QH-%d QT-%d\n",
+			s->nbfrags, s->pending_frags, s->usr_head, s->dma_head,
+			s->dma_tail);
+		AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
+		FN_OUT(-1);
+		return;
+	}
+
+	AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
+
+	/* Try to fill again */
+	audio_dma_callback(sound_curr_lch, ch_status, s);
+	FN_OUT(0);
+
+}
+
+/* Macro to trace the IRQ calls - checks for multi-channel irqs */
+/* #define IRQ_TRACE */
+#ifdef IRQ_TRACE
+#define MAX_UP 10
+static char xyz[MAX_UP] = { 0 };
+static int h;
+#endif
+
+/* ISRs have to be short and smart.. So we transfer every heavy duty stuff to
+ * the work item
+ */
+static void sound_dma_irq_handler(int sound_curr_lch, u16 ch_status, void *data)
+{
+	audio_stream_t *s = (audio_stream_t *) data;
+	FN_IN;
+
+	if (ch_status == DMA_COMPLETE) {
+
+	    if (unlikely(s->input_or_output == FMODE_WRITE &&
+			 atomic_read(&s->playing_null) == 1)) {
+		return;
+	    }
+
+#ifdef IRQ_TRACE
+		xyz[h++] = '0' + sound_curr_lch;
+		if (h == MAX_UP - 1) {
+			DPRINTK("%s-", xyz);
+			h = 0;
+		}
+#endif
+
+		sound_curr_lch = s->lch[s->dma_q_head];
+
+		DPRINTK("lch=%d,status=0x%x, data=%p\n", sound_curr_lch,
+			ch_status, data);
+
+		if (AUDIO_QUEUE_LAST(s)) {
+			audio_stream_t *s = data;
+			audio_buf_t *b = &s->buffers[s->dma_tail];
+
+			if (s->dma_spinref > 0) {
+				s->dma_spinref--;
+			} else if (!s->buffers) {
+				DPRINTK
+				    ("davinci_audio: received DMA IRQ for non\
+					existent buffers !\n");
+				return;
+			} else if (b->dma_ref && --b->dma_ref == 0 &&
+				   b->offset >= s->fragsize) {
+				/* This fragment is done */
+				b->offset = 0;
+				s->bytecount += s->fragsize;
+				s->fragcount++;
+				s->dma_spinref = -s->dma_spinref;
+
+				if (++s->dma_tail >= s->nbfrags)
+					s->dma_tail = 0;
+
+				if (!s->mapped) {
+					complete(&s->wfc);
+				} else
+					s->pending_frags++;
+
+				wake_up(&s->wq);
+			}
+
+			AUDIO_INCREMENT_HEAD(s);
+
+			if (s->input_or_output == FMODE_WRITE) {
+			    edmacc_paramentry_regs temp;
+			    davinci_get_dma_params(s->null_lch, &temp);
+			    davinci_set_dma_params(s->master_ch, &temp);
+			    atomic_set(&s->playing_null, 1);
+			} else {
+			    audio_stop_dma(s);
+			}
+
+			return;
+		}
+
+		/* Start the work item  - we ping pong the work items */
+		if (!work_item_running) {
+			work1.current_lch = sound_curr_lch;
+			work1.ch_status = ch_status;
+			work1.s = s;
+			/* schedule tasklet 1 */
+			tasklet_schedule(&audio_isr_work1);
+			work_item_running = 1;
+		} else {
+			work2.current_lch = sound_curr_lch;
+			work2.ch_status = ch_status;
+			work2.s = s;
+			/* schedule tasklet 2 */
+			tasklet_schedule(&audio_isr_work2);
+			work_item_running = 0;
+		}
+	} else {
+		DPRINTK("Error in DMA \n");
+	}
+
+	FN_OUT(0);
+	return;
+}
+
+/* The call back that handles buffer stuff */
+static void audio_dma_callback(int lch, u16 ch_status, void *data)
+{
+	audio_stream_t *s = data;
+	audio_buf_t *b = &s->buffers[s->dma_tail];
+	FN_IN;
+
+	if (s->dma_spinref > 0) {
+		s->dma_spinref--;
+	} else if (!s->buffers) {
+		DPRINTK
+		    ("davinci_audio: received DMA IRQ for non existent \
+			buffers !\n");
+		return;
+	} else if (b->dma_ref && --b->dma_ref == 0 &&
+		   b->offset >= s->fragsize) {
+		/* This fragment is done */
+		b->offset = 0;
+		s->bytecount += s->fragsize;
+		s->fragcount++;
+		s->dma_spinref = -s->dma_spinref;
+
+		if (++s->dma_tail >= s->nbfrags)
+			s->dma_tail = 0;
+
+		if (!s->mapped) {
+			complete(&s->wfc);
+		} else
+			s->pending_frags++;
+
+		wake_up(&s->wq);
+	}
+
+	audio_process_dma(s);
+
+	FN_OUT(0);
+	return;
+}
+
+/*******************************************************************************
+ *
+ * audio_get_dma_callback(): return the dma interface call back function
+ *
+ ******************************************************************************/
+dma_callback_t audio_get_dma_callback(void)
+{
+	FN_IN;
+	FN_OUT(0);
+	return audio_dma_callback;
+}
+EXPORT_SYMBOL(audio_get_dma_callback);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION
+    ("Common DMA handling for Audio driver on DAVINCI processors");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/dm644x/davinci-audio-dma-intfc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-audio-dma-intfc.h
@@ -0,0 +1,67 @@
+/*
+ * linux/sound/oss/davinci-audio-dma-intfc.h
+ *
+ * Common audio DMA handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI
+ * 						Davinci DM644x processor
+ */
+
+#ifndef __DAVINCI_AUDIO_DMA_INTFC_H
+#define __DAVINCI_AUDIO_DMA_INTFC_H
+
+/******************************* INCLUDES *************************************/
+
+/* Requires davinci-audio.h */
+#include "davinci-audio.h"
+
+/************************** GLOBAL MACROS *************************************/
+
+/* Provide the Macro interfaces common across platforms */
+#define DMA_REQUEST(e, s, cb)   {e = davinci_request_sound_dma(s->dma_dev, \
+							       s->id, s, \
+							       &s->master_ch, \
+							       &s->lch); }
+#define DMA_FREE(s)             davinci_free_sound_dma(s->master_ch, &s->lch, s)
+#define DMA_CLEAR(s)            davinci_clear_sound_dma(s)
+
+/************************** GLOBAL DATA STRUCTURES ****************************/
+
+typedef void (*dma_callback_t) (int lch, u16 ch_status, void *data);
+
+/************************** GLOBAL FUNCTIONS **********************************/
+
+dma_callback_t audio_get_dma_callback(void);
+int audio_setup_buf(audio_stream_t *s);
+int audio_process_dma(audio_stream_t *s);
+void audio_prime_rx(audio_state_t *state);
+int audio_set_fragments(audio_stream_t *s, int val);
+int audio_sync(struct file *file);
+void audio_stop_dma(audio_stream_t *s);
+u_int audio_get_dma_pos(audio_stream_t *s);
+void audio_reset(audio_stream_t *s);
+void audio_discard_buf(audio_stream_t *s);
+
+/**************** ARCH SPECIFIC FUNCIONS **************************************/
+
+void davinci_clear_sound_dma(audio_stream_t *s);
+
+int davinci_request_sound_dma(int device_id, const char *device_name,
+			      void *data, int *master_ch, int **channels);
+int davinci_free_sound_dma(int master_ch, int **channels, void *data);
+
+#endif				/* #ifndef __DAVINCI_AUDIO_DMA_INTFC_H */
Index: linux-2.6.10/sound/oss/dm644x/davinci-audio.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-audio.c
@@ -0,0 +1,1213 @@
+/*
+ * linux/sound/oss/davinci-audio.c
+ *
+ * Common audio handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2004/08/12   Nishanth Menon - Modified to integrate Audio requirements on
+ * 					1610,1710 platforms
+ *
+ * 2004-11-01   Nishanth Menon - modified to support 16xx and 17xx
+ *                platform multi channel chaining.
+ *
+ * 2004-11-04   Nishanth Menon - Added support for power management
+ *
+ * 2004-12-17   Nishanth Menon - Provided proper module handling support
+ *
+ * 2005-10-01   Rishi Bhattacharya - Adapted to TI Davinci Family of processors
+ */
+
+/***************************** INCLUDES ************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/completion.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/semaphore.h>
+
+#include "davinci-audio-dma-intfc.h"
+#include "davinci-audio.h"
+
+/***************************** MACROS ************************************/
+
+#undef DEBUG
+/* #define DEBUG */
+#ifdef DEBUG
+#define DPRINTK  printk
+#define FN_IN printk(KERN_DEBUG "[davinci_audio.c:[%s] start\n", __FUNCTION__)
+#define FN_OUT(n) printk(KERN_DEBUG "[davinci_audio.c:[%s] end(%d)\n", \
+			 __FUNCTION__ , n)
+#else
+#define DPRINTK( x... )
+#define FN_IN
+#define FN_OUT(x)
+#endif
+
+#define DAVINCI_AUDIO_NAME              "davinci-audio"
+
+#define AUDIO_NBFRAGS_DEFAULT   4
+#define AUDIO_FRAGSIZE_DEFAULT   3072
+
+/*************/
+
+/* HACK ALERT!: These values will bave to be tuned as this is a trade off b/w
+ * Sampling Rate vs buffer size and delay we are prepared to do before giving up
+ */
+#define MAX_QUEUE_FULL_RETRIES 1000000
+#define QUEUE_WAIT_TIME        10
+
+#define AUDIO_ACTIVE(state)     ((state)->rd_ref || (state)->wr_ref)
+
+#define SPIN_ADDR               (dma_addr_t)0
+#define SPIN_SIZE               2048
+
+/********************** MODULES SPECIFIC FUNCTION PROTOTYPES ***************/
+
+static int audio_write(struct file *file, const char *buffer,
+		       size_t count, loff_t *ppos);
+
+static int audio_read(struct file *file, char *buffer, size_t count,
+		      loff_t *ppos);
+
+static int audio_mmap(struct file *file, struct vm_area_struct *vma);
+
+static unsigned int audio_poll(struct file *file,
+			       struct poll_table_struct *wait);
+
+static loff_t audio_llseek(struct file *file, loff_t offset, int origin);
+
+static int audio_ioctl(struct inode *inode, struct file *file, uint cmd,
+		       ulong arg);
+
+static int audio_open(struct inode *inode, struct file *file);
+
+static int audio_release(struct inode *inode, struct file *file);
+
+static int audio_probe(struct device *dev);
+
+static int audio_remove(struct device *dev);
+
+static void audio_shutdown(struct device *dev);
+
+static int audio_suspend(struct device *dev, u32 state, u32 level);
+
+static int audio_resume(struct device *dev, u32 level);
+
+static void audio_free(struct device *dev);
+
+/***************************** Data Structures ********************************/
+
+/*
+ * The function pointer set to be registered by the codec.
+ */
+static audio_state_t audio_state = { 0 };
+
+/* DMA Call back function */
+static dma_callback_t audio_dma_callback;
+
+/* File Ops structure */
+static struct file_operations davinci_audio_fops = {
+	.open = audio_open,
+	.release = audio_release,
+	.write = audio_write,
+	.read = audio_read,
+	.mmap = audio_mmap,
+	.poll = audio_poll,
+	.ioctl = audio_ioctl,
+	.llseek = audio_llseek,
+	.owner = THIS_MODULE
+};
+
+/* Driver information */
+static struct device_driver davinci_audio_driver = {
+	.name = DAVINCI_AUDIO_NAME,
+	.bus = &platform_bus_type,
+	.probe = audio_probe,
+	.remove = audio_remove,
+	.suspend = audio_suspend,
+	.resume = audio_resume,
+	.shutdown = audio_shutdown,
+};
+
+/* Device Information */
+static struct platform_device davinci_audio_device = {
+	.name = DAVINCI_AUDIO_NAME,
+	.dev = {
+		.driver_data = &audio_state,
+		.release = audio_free,
+		},
+	.id = 0,
+};
+
+/***************************** GLOBAL FUNCTIONs *******************************/
+
+/* Power Management Functions for Linux Device Model  */
+/* DEBUG PUPOSES ONLY! */
+#ifdef CONFIG_PM
+/* #undef CONFIG_PM */
+#endif
+
+#ifdef CONFIG_PM
+/*******************************************************************************
+ *
+ * audio_ldm_suspend(): Suspend operation
+ *
+ ******************************************************************************/
+static int audio_ldm_suspend(void *data)
+{
+	audio_state_t *state = data;
+
+	FN_IN;
+
+	/* Reject the suspend request if we are already actively transmitting
+	   data.
+	   Rationale: We dont want to be suspended while in the middle of a
+	   call!
+	 */
+
+	if (AUDIO_ACTIVE(state) && state->hw_init) {
+		DPRINTK("Audio device Active, Cannot Suspend");
+		return -EPERM;
+
+		/* NOTE:
+		 * This Piece of code is commented out in hope
+		 * That one day we would need to suspend the device while
+		 * audio operations are in progress and resume the operations
+		 * once the resume is done.
+		 * This is just a sample implementation of how it could be done.
+		 * Currently NOT SUPPORTED
+		 */
+		/*
+		   audio_stream_t *is = state->input_stream;
+		   audio_stream_t *os = state->output_stream;
+		   int stopstate;
+
+		   if (is && is->buffers) {
+		   DPRINTK("IS Suspend\n");
+		   stopstate = is->stopped;
+		   audio_stop_dma(is);
+		   DMA_CLEAR(is);
+		   is->dma_spinref = 0;
+		   is->stopped = stopstate;
+		   }
+		   if (os && os->buffers) {
+		   DPRINTK("OS Suspend\n");
+		   stopstate = os->stopped;
+		   audio_stop_dma(os);
+		   DMA_CLEAR(os);
+		   os->dma_spinref = 0;
+		   os->stopped = stopstate;
+		   }
+		*/
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+
+/*******************************************************************************
+ *
+ * audio_ldm_resume(): Resume Operations
+ *
+ ******************************************************************************/
+static int audio_ldm_resume(void *data)
+{
+	audio_state_t *state = data;
+
+	FN_IN;
+	if (AUDIO_ACTIVE(state) && state->hw_init) {
+		/* Should never occur - since we never suspend with active state
+		 */
+
+		BUG();
+		return -EPERM;
+
+		/* NOTE:
+		 * This Piece of code is commented out in hope
+		 * That one day we would need to suspend the device while
+		 * audio operations are in progress and resume the operations
+		 * once the resume is done.
+		 * This is just a sample implementation of how it could be done.
+		 * Currently NOT SUPPORTED
+		 */
+		/*
+		  audio_stream_t *is = state->input_stream;
+		  audio_stream_t *os = state->output_stream;
+		  if (os && os->buffers) {
+		  DPRINTK("OS Resume\n");
+		  audio_reset(os);
+		  audio_process_dma(os);
+		  }
+		  if (is && is->buffers) {
+		  DPRINTK("IS Resume\n");
+		  audio_reset(is);
+		  audio_process_dma(is);
+		  }
+		*/
+	}
+	FN_OUT(0);
+	return 0;
+}
+#endif				/* End of #ifdef CONFIG_PM */
+
+/*******************************************************************************
+ *
+ * audio_free(): The Audio driver release function
+ * This is a dummy function required by the platform driver
+ *
+ ******************************************************************************/
+static void audio_free(struct device *dev)
+{
+	/* Nothing to Release! */
+}
+
+/*******************************************************************************
+ *
+ * audio_probe(): The Audio driver probe function
+ * WARNING!!!!  : It is expected that the codec would have registered with us by
+ * now
+ *
+ ******************************************************************************/
+static int audio_probe(struct device *dev)
+{
+	int ret;
+	FN_IN;
+	if (!audio_state.hw_probe) {
+		DPRINTK("Probe Function Not Registered\n");
+		return -ENODEV;
+	}
+	ret = audio_state.hw_probe();
+	FN_OUT(ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * audio_remove() Function to handle removal operations
+ *
+ ******************************************************************************/
+static int audio_remove(struct device *dev)
+{
+	FN_IN;
+	if (audio_state.hw_remove) {
+		audio_state.hw_remove();
+	}
+	FN_OUT(0);
+	return 0;
+}
+
+/*******************************************************************************
+ *
+ * audio_shutdown(): Function to handle shutdown operations
+ *
+ ******************************************************************************/
+static void audio_shutdown(struct device *dev)
+{
+	FN_IN;
+	if (audio_state.hw_cleanup) {
+		audio_state.hw_cleanup();
+	}
+	FN_OUT(0);
+	return;
+}
+
+/*******************************************************************************
+ *
+ * audio_suspend(): Function to handle suspend operations
+ *
+ ******************************************************************************/
+static int audio_suspend(struct device *dev, u32 state, u32 level)
+{
+	int ret = 0;
+
+#ifdef CONFIG_PM
+	void *data = dev->driver_data;
+	FN_IN;
+	if (level != 3) {
+		return 0;
+	}
+	if (audio_state.hw_suspend) {
+		ret = audio_ldm_suspend(data);
+		if (ret == 0)
+			ret = audio_state.hw_suspend();
+	}
+	if (ret) {
+		DPRINTK("Audio Suspend Failed \n");
+	} else {
+		DPRINTK("Audio Suspend Success \n");
+	}
+#endif				/* CONFIG_PM */
+
+	FN_OUT(ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * audio_resume(): Function to handle resume operations
+ *
+ ******************************************************************************/
+static int audio_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+
+#ifdef  CONFIG_PM
+	void *data = dev->driver_data;
+	FN_IN;
+	if (level != 0) {
+		return 0;
+	}
+	if (audio_state.hw_resume) {
+		ret = audio_ldm_resume(data);
+		if (ret == 0)
+			ret = audio_state.hw_resume();
+	}
+	if (ret) {
+		DPRINTK(" Audio Resume Failed \n");
+	} else {
+		DPRINTK(" Audio Resume Success \n");
+	}
+#endif				/* CONFIG_PM */
+
+	FN_OUT(ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * audio_get_fops(): Return the fops required to get the function pointers of
+ *                   DAVINCI Audio Driver
+ *
+ ******************************************************************************/
+struct file_operations *audio_get_fops(void)
+{
+	FN_IN;
+	FN_OUT(0);
+	return &davinci_audio_fops;
+}
+EXPORT_SYMBOL(audio_get_fops);
+
+/*******************************************************************************
+ *
+ * audio_register_codec(): Register a Codec fn points using this function
+ * WARNING!!!!!          : Codecs should ensure that they do so! no sanity
+ * 			checks during runtime is done due to obvious performance
+ * 			penalties.
+ *
+ ******************************************************************************/
+int audio_register_codec(audio_state_t *codec_state)
+{
+	int ret;
+	FN_IN;
+
+	/* We dont handle multiple codecs now */
+	if (audio_state.hw_init) {
+		DPRINTK(" Codec Already registered\n");
+		return -EPERM;
+	}
+
+	/* Grab the dma Callback */
+	audio_dma_callback = audio_get_dma_callback();
+	if (!audio_dma_callback) {
+		DPRINTK("Unable to get call back function\n");
+		return -EPERM;
+	}
+
+	/* Sanity checks */
+	if (!codec_state) {
+		DPRINTK("NULL ARGUMENT!\n");
+		return -EPERM;
+	}
+
+	if (!codec_state->hw_probe || !codec_state->hw_init
+	    || !codec_state->hw_shutdown || !codec_state->client_ioctl) {
+		DPRINTK
+			("Required Fn Entry point Missing probe = %p\
+				init = %p, down = %p, ioctl = %p !\n",
+			 codec_state->hw_probe, codec_state->hw_init,
+			 codec_state->hw_shutdown, codec_state->client_ioctl);
+		return -EPERM;
+	}
+
+	memcpy(&audio_state, codec_state, sizeof(audio_state_t));
+	sema_init(&audio_state.sem, 1);
+
+	ret = platform_device_register(&davinci_audio_device);
+	if (ret != 0) {
+		DPRINTK("Platform dev_register failed =%d\n", ret);
+		ret = -ENODEV;
+		goto register_out;
+	}
+
+	ret = driver_register(&davinci_audio_driver);
+	if (ret != 0) {
+		DPRINTK("Device Register failed =%d\n", ret);
+		ret = -ENODEV;
+		platform_device_unregister(&davinci_audio_device);
+		goto register_out;
+	}
+
+	DPRINTK("audio driver register success\n");
+
+register_out:
+
+	FN_OUT(ret);
+	return ret;
+}
+EXPORT_SYMBOL(audio_register_codec);
+
+/*******************************************************************************
+ *
+ * audio_unregister_codec(): Un-Register a Codec using this function
+ *
+ ******************************************************************************/
+int audio_unregister_codec(audio_state_t *codec_state)
+{
+	FN_IN;
+
+	/* We dont handle multiple codecs now */
+	if (!audio_state.hw_init) {
+		DPRINTK(" No Codec registered\n");
+		return -EPERM;
+	}
+	/* Security check */
+	if (audio_state.hw_init != codec_state->hw_init) {
+		DPRINTK
+			("Attempt to unregister codec which was not registered \
+				with us\n");
+		return -EPERM;
+	}
+
+	driver_unregister(&davinci_audio_driver);
+	platform_device_unregister(&davinci_audio_device);
+
+	memset(&audio_state, 0, sizeof(audio_state_t));
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(audio_unregister_codec);
+
+/***************************** MODULES SPECIFIC FUNCTION **********************/
+
+/*******************************************************************************
+ *
+ * audio_write(): Exposed to write() call
+ *
+ ******************************************************************************/
+static int
+audio_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
+{
+	const char *buffer0 = buffer;
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->output_stream;
+	int chunksize, ret = 0;
+	unsigned long flags;
+
+	DPRINTK("audio_write: count=%d\n", count);
+	if (*ppos != file->f_pos) {
+		DPRINTK("FPOS not ppos ppos=0x%x fpos =0x%x\n", (u32) * ppos,
+			(u32) file->f_pos);
+		return -ESPIPE;
+	}
+	if (s->mapped) {
+		DPRINTK("s already mapped\n");
+		return -ENXIO;
+	}
+	if (!s->buffers && audio_setup_buf(s)) {
+		DPRINTK("NO MEMORY\n");
+		return -ENOMEM;
+	}
+
+	while (count > 0) {
+		audio_buf_t *b = &s->buffers[s->usr_head];
+
+		/* Wait for a buffer to become free */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (!s->wfc.done)
+				break;
+			else {
+				local_irq_save(flags);
+				s->wfc.done--;
+				local_irq_restore(flags);
+			}
+		} else {
+			ret = -ERESTARTSYS;
+			if (wait_for_completion_interruptible(&s->wfc))
+				break;
+		}
+
+		/* Feed the current buffer */
+		chunksize = s->fragsize - b->offset;
+		if (chunksize > count)
+			chunksize = count;
+		DPRINTK("write %d to %d\n", chunksize, s->usr_head);
+		if (copy_from_user(b->data + b->offset, buffer, chunksize)) {
+			DPRINTK("Audio: CopyFrom User failed \n");
+			complete(&s->wfc);
+			return -EFAULT;
+		}
+
+		buffer += chunksize;
+		count -= chunksize;
+		b->offset += chunksize;
+
+		if (b->offset < s->fragsize) {
+			complete(&s->wfc);
+			break;
+		}
+
+		/* Update pointers and send current fragment to DMA */
+		local_irq_save(flags);
+		b->offset = 0;
+		if (++s->usr_head >= s->nbfrags)
+			s->usr_head = 0;
+		/* Add the num of frags pending */
+		s->pending_frags++;
+		s->active = 1;
+		local_irq_restore(flags);
+		audio_process_dma(s);
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+
+	DPRINTK("audio_write: return=%d\n", ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * audio_read(): Exposed as read() function
+ *
+ ******************************************************************************/
+static int
+audio_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	char *buffer0 = buffer;
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->input_stream;
+	int chunksize, ret = 0;
+	unsigned long flags;
+
+	DPRINTK("audio_read: count=%d\n", count);
+
+	if (*ppos != file->f_pos) {
+		DPRINTK("AudioRead - FPOS not ppos ppos=0x%x fpos =0x%x\n",
+			(u32) * ppos, (u32) file->f_pos);
+		return -ESPIPE;
+	}
+	if (s->mapped) {
+		DPRINTK("AudioRead - s already mapped\n");
+		return -ENXIO;
+	}
+
+	if (!s->active) {
+		if (!s->buffers && audio_setup_buf(s)) {
+			DPRINTK("AudioRead - No Memory\n");
+			return -ENOMEM;
+		}
+		audio_prime_rx(state);
+	}
+
+	while (count > 0) {
+		audio_buf_t *b = &s->buffers[s->usr_head];
+
+		/* Wait for a buffer to become full */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (!s->wfc.done)
+				break;
+			else {
+				local_irq_save(flags);
+				s->wfc.done--;
+				local_irq_restore(flags);
+			}
+		} else {
+			ret = -ERESTARTSYS;
+			if (wait_for_completion_interruptible(&s->wfc))
+				break;
+		}
+
+		/* Grab data from the current buffer */
+		chunksize = s->fragsize - b->offset;
+		if (chunksize > count)
+			chunksize = count;
+
+		DPRINTK("read %d from %d\n", chunksize, s->usr_head);
+		if (copy_to_user(buffer, b->data + b->offset, chunksize)) {
+			complete(&s->wfc);
+			return -EFAULT;
+		}
+		buffer += chunksize;
+		count -= chunksize;
+		b->offset += chunksize;
+		if (b->offset < s->fragsize) {
+			complete(&s->wfc);
+			break;
+		}
+
+		/* Update pointers and return current fragment to DMA */
+		local_irq_save(flags);
+		b->offset = 0;
+		if (++s->usr_head >= s->nbfrags)
+			s->usr_head = 0;
+
+		s->pending_frags++;
+		local_irq_restore(flags);
+		DPRINTK(KERN_INFO
+			"calling audio_process_dma from audio_read\n");
+		audio_process_dma(s);
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+	DPRINTK("audio_read: return=%d\n", ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * audio_mmap(): Exposed as mmap Function
+ * !!WARNING: Still under development
+ *
+ ******************************************************************************/
+static int audio_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s;
+	unsigned long size, vma_addr;
+	int i, ret = 0;
+
+	FN_IN;
+	if (vma->vm_pgoff != 0)
+		return -EINVAL;
+
+	if (vma->vm_flags & VM_WRITE) {
+		if (!state->wr_ref)
+			return -EINVAL;
+		s = state->output_stream;
+	} else if (vma->vm_flags & VM_READ) {
+		if (!state->rd_ref)
+			return -EINVAL;
+		s = state->input_stream;
+	} else
+		return -EINVAL;
+
+	if (s->mapped)
+		return -EINVAL;
+	size = vma->vm_end - vma->vm_start;
+	if (size != s->fragsize * s->nbfrags)
+		return -EINVAL;
+	if (!s->buffers && audio_setup_buf(s))
+		return -ENOMEM;
+	vma_addr = vma->vm_start;
+	for (i = 0; i < s->nbfrags; i++) {
+		audio_buf_t *buf = &s->buffers[i];
+		if (!buf->master)
+			continue;
+		/*
+		  ret =
+		  remap_pfn_range(vma, vma_addr, buf->dma_addr >> PAGE_SHIFT,
+		  buf->master, vma->vm_page_prot);
+		*/
+
+		if (ret)
+			return ret;
+		vma_addr += buf->master;
+	}
+	s->mapped = 1;
+
+	FN_OUT(0);
+	return 0;
+}
+
+/*******************************************************************************
+ *
+ * audio_poll(): Exposed as poll function
+ *
+ ******************************************************************************/
+static unsigned int
+audio_poll(struct file *file, struct poll_table_struct *wait)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *is = state->input_stream;
+	audio_stream_t *os = state->output_stream;
+	unsigned int mask = 0;
+
+	DPRINTK("audio_poll(): mode=%s%s\n",
+		(file->f_mode & FMODE_READ) ? "r" : "",
+		(file->f_mode & FMODE_WRITE) ? "w" : "");
+
+	if (file->f_mode & FMODE_READ) {
+		/* Start audio input if not already active */
+		if (!is->active) {
+			if (!is->buffers && audio_setup_buf(is))
+				return -ENOMEM;
+			audio_prime_rx(state);
+		}
+		poll_wait(file, &is->wq, wait);
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!os->buffers && audio_setup_buf(os))
+			return -ENOMEM;
+		poll_wait(file, &os->wq, wait);
+	}
+
+	if (file->f_mode & FMODE_READ)
+		if ((is->mapped && is->bytecount > 0) ||
+		    (!is->mapped && is->wfc.done > 0))
+			mask |= POLLIN | POLLRDNORM;
+
+	if (file->f_mode & FMODE_WRITE)
+		if ((os->mapped && os->bytecount > 0) ||
+		    (!os->mapped && os->wfc.done > 0))
+			mask |= POLLOUT | POLLWRNORM;
+
+	DPRINTK("audio_poll() returned mask of %s%s\n",
+		(mask & POLLIN) ? "r" : "", (mask & POLLOUT) ? "w" : "");
+
+	FN_OUT(mask);
+	return mask;
+}
+
+/*******************************************************************************
+ *
+ * audio_llseek(): Exposed as lseek() function.
+ *
+ ******************************************************************************/
+static loff_t audio_llseek(struct file *file, loff_t offset, int origin)
+{
+	FN_IN;
+	FN_OUT(0);
+	return -ESPIPE;
+}
+
+/*******************************************************************************
+ *
+ * audio_ioctl(): Handles generic ioctls. If there is a request for something
+ * this fn cannot handle, its then given to client specific ioctl routine, that
+ * will take up platform specific requests
+ *
+ ******************************************************************************/
+static int
+audio_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	long val;
+
+	DPRINTK(__FILE__ " audio_ioctl 0x%08x\n", cmd);
+
+	/* dispatch based on command */
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(os->fragsize, (int *)arg);
+		else
+			return put_user(is->fragsize, (int *)arg);
+
+	case SNDCTL_DSP_GETCAPS:
+		val = DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP;
+		if (is && os)
+			val |= DSP_CAP_DUPLEX;
+		FN_OUT(1);
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (long *)arg)) {
+			FN_OUT(2);
+			return -EFAULT;
+		}
+		if (file->f_mode & FMODE_READ) {
+			int ret = audio_set_fragments(is, val);
+			if (ret < 0) {
+				FN_OUT(3);
+				return ret;
+			}
+			ret = put_user(ret, (int *)arg);
+			if (ret) {
+				FN_OUT(4);
+				return ret;
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			int ret = audio_set_fragments(os, val);
+			if (ret < 0) {
+				FN_OUT(5);
+				return ret;
+			}
+			ret = put_user(ret, (int *)arg);
+			if (ret) {
+				FN_OUT(6);
+				return ret;
+			}
+		}
+		FN_OUT(7);
+		return 0;
+
+	case SNDCTL_DSP_SYNC:
+		FN_OUT(8);
+		return audio_sync(file);
+
+	case SNDCTL_DSP_SETDUPLEX:
+		FN_OUT(9);
+		return 0;
+
+	case SNDCTL_DSP_POST:
+		FN_OUT(10);
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		if (file->f_mode & FMODE_READ && is->active && !is->stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && os->active && !os->stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		FN_OUT(11);
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *)arg)) {
+			FN_OUT(12);
+			return -EFAULT;
+		}
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT) {
+				unsigned long flags;
+				if (!is->active) {
+					if (!is->buffers &&
+					    audio_setup_buf(is)) {
+						FN_OUT(13);
+						return -ENOMEM;
+					}
+					audio_prime_rx(state);
+				}
+				local_irq_save(flags);
+				is->stopped = 0;
+				local_irq_restore(flags);
+				audio_process_dma(is);
+
+			} else {
+				is->stopped = 1;
+				audio_stop_dma(is);
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT) {
+				unsigned long flags;
+				if (!os->buffers && audio_setup_buf(os)) {
+					FN_OUT(14);
+					return -ENOMEM;
+				}
+				local_irq_save(flags);
+				if (os->mapped && !os->pending_frags) {
+					os->pending_frags = os->nbfrags;
+					init_completion(&os->wfc);
+					os->wfc.done = 0;
+					os->active = 1;
+				}
+				os->stopped = 0;
+				local_irq_restore(flags);
+				audio_process_dma(os);
+			} else {
+				os->stopped = 1;
+				audio_stop_dma(os);
+			}
+		}
+		FN_OUT(15);
+		return 0;
+
+	case SNDCTL_DSP_GETOPTR:
+	case SNDCTL_DSP_GETIPTR:
+		{
+			count_info inf = { 0, };
+			audio_stream_t *s =
+			    (cmd == SNDCTL_DSP_GETOPTR) ? os : is;
+			int bytecount, offset;
+			unsigned long flags;
+
+			if ((s == is && !(file->f_mode & FMODE_READ)) ||
+			    (s == os && !(file->f_mode & FMODE_WRITE))) {
+				FN_OUT(16);
+				return -EINVAL;
+			}
+			if (s->active) {
+				local_irq_save(flags);
+				offset = audio_get_dma_pos(s);
+				inf.ptr = s->dma_tail * s->fragsize + offset;
+				bytecount = s->bytecount + offset;
+				s->bytecount = -offset;
+				inf.blocks = s->fragcount;
+				s->fragcount = 0;
+				local_irq_restore(flags);
+				if (bytecount < 0)
+					bytecount = 0;
+				inf.bytes = bytecount;
+			}
+			FN_OUT(17);
+			return copy_to_user((void *)arg, &inf, sizeof(inf));
+		}
+
+	case SNDCTL_DSP_GETOSPACE:
+	case SNDCTL_DSP_GETISPACE:
+		{
+			audio_buf_info inf = { 0, };
+			audio_stream_t *s =
+			    (cmd == SNDCTL_DSP_GETOSPACE) ? os : is;
+			audio_buf_t *b = NULL;
+
+			if ((s == is && !(file->f_mode & FMODE_READ)) ||
+			    (s == os && !(file->f_mode & FMODE_WRITE))) {
+				FN_OUT(18);
+				return -EINVAL;
+			}
+			if (!s->buffers && audio_setup_buf(s)) {
+				FN_OUT(19);
+				return -ENOMEM;
+			}
+			b = &s->buffers[s->usr_head];
+			inf.bytes = s->wfc.done * s->fragsize;
+			inf.bytes -= b->offset;
+			if (inf.bytes < 0)
+				inf.bytes = 0;
+
+			inf.fragments = inf.bytes / s->fragsize;
+			inf.fragsize = s->fragsize;
+			inf.fragstotal = s->nbfrags;
+			FN_OUT(20);
+			return copy_to_user((void *)arg, &inf, sizeof(inf));
+		}
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		FN_OUT(21);
+		return 0;
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_READ) {
+			audio_reset(is);
+			if (state->need_tx_for_rx) {
+				unsigned long flags;
+				local_irq_save(flags);
+				os->spin_idle = 0;
+				local_irq_restore(flags);
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			audio_reset(os);
+		}
+		FN_OUT(22);
+		return 0;
+
+	default:
+		/*
+		 * Let the client of this module handle the
+		 * non generic ioctls
+		 */
+		FN_OUT(23);
+		return state->client_ioctl(inode, file, cmd, arg);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+
+/*******************************************************************************
+ *
+ * audio_open(): Exposed as open() function
+ *
+ ******************************************************************************/
+static int audio_open(struct inode *inode, struct file *file)
+{
+	audio_state_t *state = (&audio_state);
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	int err, need_tx_dma;
+	static unsigned char aic33_init_flag;
+
+	FN_IN;
+
+	/* Lock the module */
+	if (!try_module_get(THIS_MODULE)) {
+		DPRINTK("Failed to get module\n");
+		return -ESTALE;
+	}
+	/* Lock the codec module */
+	if (!try_module_get(state->owner)) {
+		DPRINTK("Failed to get codec module\n");
+		module_put(THIS_MODULE);
+		return -ESTALE;
+	}
+
+	down(&state->sem);
+
+	/* access control */
+	err = -ENODEV;
+	if ((file->f_mode & FMODE_WRITE) && !os)
+		goto out;
+	if ((file->f_mode & FMODE_READ) && !is)
+		goto out;
+	err = -EBUSY;
+	if ((file->f_mode & FMODE_WRITE) && state->wr_ref)
+		goto out;
+	if ((file->f_mode & FMODE_READ) && state->rd_ref)
+		goto out;
+	err = -EINVAL;
+	if ((file->f_mode & FMODE_READ) && state->need_tx_for_rx && !os)
+		goto out;
+
+	/* request DMA channels */
+	need_tx_dma = ((file->f_mode & FMODE_WRITE) ||
+		       ((file->f_mode & FMODE_READ) && state->need_tx_for_rx));
+	if (state->wr_ref || (state->rd_ref && state->need_tx_for_rx))
+		need_tx_dma = 0;
+	if (need_tx_dma) {
+		DPRINTK("DMA REQUEST FOR playback\n");
+		DMA_REQUEST(err, os, audio_dma_callback);
+		if (err < 0)
+			goto out;
+	}
+	if (file->f_mode & FMODE_READ) {
+		DPRINTK("DMA REQUEST FOR record\n");
+		DMA_REQUEST(err, is, audio_dma_callback);
+		if (err < 0) {
+			if (need_tx_dma)
+				DMA_FREE(os);
+			goto out;
+		}
+	}
+
+	/* now complete initialisation */
+	if (!AUDIO_ACTIVE(state)) {
+		if (state->hw_init && !aic33_init_flag) {
+			state->hw_init(state->data);
+			aic33_init_flag = 0;
+		}
+	}
+
+	if ((file->f_mode & FMODE_WRITE)) {
+		DPRINTK("SETUP FOR PLAYBACK\n");
+		state->wr_ref = 1;
+		audio_reset(os);
+		os->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+		os->nbfrags = AUDIO_NBFRAGS_DEFAULT;
+		os->mapped = 0;
+		init_waitqueue_head(&os->wq);
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		DPRINTK("SETUP FOR RECORD\n");
+		state->rd_ref = 1;
+		audio_reset(is);
+		is->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+		is->nbfrags = AUDIO_NBFRAGS_DEFAULT;
+		is->mapped = 0;
+		init_waitqueue_head(&is->wq);
+	}
+
+	file->private_data = state;
+	err = 0;
+
+out:
+	up(&state->sem);
+	if (err) {
+		module_put(state->owner);
+		module_put(THIS_MODULE);
+	}
+	FN_OUT(err);
+	return err;
+}
+
+/*******************************************************************************
+ *
+ * audio_release(): Exposed as release function()
+ *
+ ******************************************************************************/
+static int audio_release(struct inode *inode, struct file *file)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+
+	FN_IN;
+
+	down(&state->sem);
+
+	if (file->f_mode & FMODE_READ) {
+		audio_discard_buf(is);
+		DMA_FREE(is);
+		is->dma_spinref = 0;
+		if (state->need_tx_for_rx) {
+			os->spin_idle = 0;
+			if (!state->wr_ref) {
+				DMA_FREE(os);
+				os->dma_spinref = 0;
+			}
+		}
+		state->rd_ref = 0;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		audio_sync(file);
+		audio_discard_buf(os);
+		if (!state->need_tx_for_rx || !state->rd_ref) {
+			DMA_FREE(os);
+			os->dma_spinref = 0;
+		}
+		state->wr_ref = 0;
+	}
+
+	if (!AUDIO_ACTIVE(state)) {
+		if (state->hw_shutdown)
+			state->hw_shutdown(state->data);
+	}
+
+	up(&state->sem);
+
+	module_put(state->owner);
+	module_put(THIS_MODULE);
+
+	FN_OUT(0);
+	return 0;
+}
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("Common audio handling for DAVINCI processors");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/dm644x/davinci-audio.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm644x/davinci-audio.h
@@ -0,0 +1,122 @@
+/*
+ * linux/sound/oss/davinci-audio.h
+ *
+ * Common audio handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2005-10-01   Rishi Bhattacharya - Adapted to TI Davinci Family of processors
+ */
+
+#ifndef __DAVINCI_AUDIO_H
+#define __DAVINCI_AUDIO_H
+
+/* Requires dma.h */
+#include <asm/arch/dma.h>
+#include <asm/atomic.h>
+/*
+ * Buffer Management
+ */
+typedef struct {
+	int offset;		/* current offset */
+	char *data;		/* points to actual buffer */
+	dma_addr_t dma_addr;	/* physical buffer address */
+	int dma_ref;		/* DMA refcount */
+	int master;		/* owner for buffer allocation, contain size
+				 * when true */
+} audio_buf_t;
+
+/*
+ * Structure describing the data stream related information
+ */
+typedef struct {
+	char *id;		/* identification string */
+	audio_buf_t *buffers;	/* pointer to audio buffer structures */
+	u_int usr_head;		/* user fragment index */
+	u_int dma_head;		/* DMA fragment index to go */
+	u_int dma_tail;		/* DMA fragment index to complete */
+	u_int fragsize;		/* fragment i.e. buffer size */
+	u_int nbfrags;		/* nbr of fragments i.e. buffers */
+	u_int pending_frags;	/* Fragments sent to DMA */
+	int dma_dev;		/* device identifier for DMA */
+	u_int prevbuf;		/* Prev pending frag size sent to DMA */
+	char started;		/* to store if the chain was started or not */
+	int dma_q_head;		/* DMA Channel Q Head */
+	int dma_q_tail;		/* DMA Channel Q Tail */
+	char dma_q_count;	/* DMA Channel Q Count */
+	char in_use;		/*  Is this is use? */
+	int master_ch;
+	int *lch;		/*  Chain of channels this stream is linked to
+				 *  */
+	int input_or_output;	/* Direction of this data stream */
+	int bytecount;		/* nbr of processed bytes */
+	int fragcount;		/* nbr of fragment transitions */
+	struct completion wfc;	/* wait for "nbfrags" fragment completion */
+	wait_queue_head_t wq;	/* for poll */
+	int dma_spinref;	/* DMA is spinning */
+	int mapped:1;		/* mmap()'ed buffers */
+	int active:1;		/* actually in progress */
+	int stopped:1;		/* might be active but stopped */
+	int spin_idle:1;	/* have DMA spin on zeros when idle */
+	int dma_started;	/* to store if DMA was started or not */
+	int mcbsp_tx_started;
+	int mcbsp_rx_started;
+	atomic_t playing_null;
+	int null_lch;		/* Link channel for playing the null data */
+} audio_stream_t;
+
+/*
+ * State structure for one instance
+ */
+typedef struct {
+	struct module *owner;	/* Codec module ID */
+	audio_stream_t *output_stream;
+	audio_stream_t *input_stream;
+	int rd_ref:1;		/* open reference for recording */
+	int wr_ref:1;		/* open reference for playback */
+	int need_tx_for_rx:1;	/* if data must be sent while receiving */
+	void *data;
+	void (*hw_init) (void *);
+	void (*hw_shutdown) (void *);
+	int (*client_ioctl) (struct inode *, struct file *, uint, ulong);
+	int (*hw_probe) (void);
+	void (*hw_remove) (void);
+	void (*hw_cleanup) (void);
+	int (*hw_suspend) (void);
+	int (*hw_resume) (void);
+	struct pm_dev *pm_dev;
+	struct compat_semaphore sem;	/* to protect against races in attach()
+					 * */
+} audio_state_t;
+
+#ifdef AUDIO_PM
+void audio_ldm_suspend(void *data);
+
+void audio_ldm_resume(void *data);
+
+#endif
+
+/* Register a Codec using this function */
+extern int audio_register_codec(audio_state_t *codec_state);
+/* Un-Register a Codec using this function */
+extern int audio_unregister_codec(audio_state_t *codec_state);
+/* Function to provide fops of davinci audio driver */
+extern struct file_operations *audio_get_fops(void);
+/* Function to initialize the device info for audio driver */
+extern int audio_dev_init(void);
+/* Function to un-initialize the device info for audio driver */
+void audio_dev_uninit(void);
+
+#endif				/* End of #ifndef __DAVINCI_AUDIO_H */
Index: linux-2.6.10/sound/oss/dm646x/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/Kconfig
@@ -0,0 +1,22 @@
+# Menu for Davinci DM646x based systems audio
+
+menu " Davinci DM646x based systems audio support"
+        depends on SOUND && MACH_DAVINCI_HD_EVM
+
+
+config SOUND_DAVINCI_HD
+	tristate "DaVinci HD Sound Driver"
+	depends on ARCH_DAVINCI && MACH_DAVINCI_HD_EVM && SOUND_PRIME!=n && SOUND
+	---help---
+	DaVinci HD Sound driver
+
+config SOUND_DAVINCI_TLV320AIC32
+       tristate "TLV320AIC32 Stereo Codec"
+       depends on SOUND_DAVINCI_HD
+       default y if SOUND_DAVINCI_HD
+       select SENSORS_TLV320AIC33
+       ---help---
+         If you say yes here you get support for the I2C control
+         interface for Texas Instruments TLV320AIC32 audio codec.
+
+endmenu
Index: linux-2.6.10/sound/oss/dm646x/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/Makefile
@@ -0,0 +1,5 @@
+# Makefile for Davinci_HD related audio files
+obj-$(CONFIG_SOUND_DAVINCI_HD) += davinci-audio-oss.o
+obj-$(CONFIG_SOUND_DAVINCI_TLV320AIC32) += davinci-audio-aic32.o
+
+davinci-audio-oss-objs := davinci-audio-dma-intfc.o evm_audio_info.o audio_controller.o
\ No newline at end of file
Index: linux-2.6.10/sound/oss/dm646x/audio_controller.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/audio_controller.c
@@ -0,0 +1,1221 @@
+/*
+ * audio_controller.c
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/completion.h>
+#include <linux/semaphore.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/evm_audio_info.h>
+#include <asm/arch/davinci-audio-config.h>
+#include "audio_controller.h"
+#include "davinci-audio-dma-intfc.h"
+
+static unsigned int audio_ctlr_poll(struct file *file, struct poll_table_struct
+				    *wait);
+
+static loff_t audio_ctlr_llseek(struct file *file, loff_t offset, int origin);
+
+static int audio_ctlr_open(struct inode *inode, struct file *file);
+
+static int audio_ctlr_write(struct file *file, const char *buffer,
+			    size_t count, loff_t *ppos);
+
+static int audio_ctlr_read(struct file *file, char *buffer, size_t count,
+			   loff_t *ppos);
+
+static int audio_ctlr_ioctl(struct inode *inode, struct file *file, uint cmd,
+			    ulong arg);
+static int audio_ctlr_release(struct inode *inode, struct file *file);
+
+
+static struct file_operations audio_controller_fops = {
+	.open = audio_ctlr_open,
+	.write = audio_ctlr_write,
+	.release = audio_ctlr_release,
+	.read = audio_ctlr_read,
+	.ioctl = audio_ctlr_ioctl,
+	.poll = audio_ctlr_poll,
+	.llseek = audio_ctlr_llseek,
+	.owner = THIS_MODULE
+};
+
+extern struct file_operations davinci_mixer_fops;
+
+#define CONFIGURED_AS_INACTIVE  0
+#define CONFIGURED_AS_TX        1
+#define CONFIGURED_AS_RX        2
+
+static evm_audio_info_t *evm_aud_info;
+/* Nirmal: Introducing new global. This may be required if we want to support
+   different sampling frequencies for DIT. As of now let it be 4 */
+int acount = 4;
+
+/* This audio config is for each ASP */
+static audio_config_t audio_cfg[] = {
+	{
+		.mcasp_id = 0,
+		.mode = CODEC_IS_MASTER,
+		.channel_size = 32,
+		.serializer_count = 4,
+		.serializer_mode[0] = CONFIGURED_AS_TX,
+		.serializer_mode[1] = CONFIGURED_AS_RX,
+		.serializer_mode[2] = CONFIGURED_AS_INACTIVE,
+		.serializer_mode[3] = CONFIGURED_AS_INACTIVE,
+		.loopback = 0,
+		.amute = 0,
+		.tdm_slots = 0,
+		.sample_rate  = 48000,
+	},
+	{
+		.mcasp_id = 1,
+		.mode = CODEC_IS_SLAVE,
+		.channel_size = 32,
+		.serializer_count = 4,
+		.serializer_mode[0] = CONFIGURED_AS_TX,
+		.serializer_mode[1] = CONFIGURED_AS_INACTIVE,
+		.serializer_mode[2] = CONFIGURED_AS_INACTIVE,
+		.serializer_mode[3] = CONFIGURED_AS_INACTIVE,
+		.loopback = 0,
+		.amute = 0,
+		.tdm_slots = 384, /* Configure this McASP for DIT */
+		.sample_rate  = 48000,
+	}
+};
+
+#define AUDIO_FRAGSIZE_DEFAULT 3072
+#define AUDIO_NBFRAGS_DEFAULT 4
+
+static s8 validate_file_mode ( u8 asp_id, struct file *file)
+{
+	/* If the file is opened in a mode which the ASP is not configured to
+	 * operate in, return an error */
+	u8 write = TRUE, read = TRUE;
+	s8 ret_code;
+	u8 cnt = 0;
+
+	if ( (file->f_mode & FMODE_WRITE) ) {
+		write = FALSE;
+		for (cnt = 0; cnt < audio_cfg[asp_id].serializer_count; cnt++) {
+			if (audio_cfg[asp_id].serializer_mode[cnt] ==
+			    CONFIGURED_AS_TX) {
+				write = TRUE;
+				break;
+			}
+		}
+	}
+
+	if ( (file->f_mode & FMODE_READ) ) {
+		read = FALSE;
+		for (cnt = 0; cnt < audio_cfg[asp_id].serializer_count; cnt++) {
+			if (audio_cfg[asp_id].serializer_mode[cnt] ==
+			    CONFIGURED_AS_RX) {
+				read = TRUE;
+				break;
+			}
+		}
+	}
+
+	if ( (write == FALSE) || (read == FALSE) ) {
+		ret_code = -1;
+	} else {
+		ret_code = 0;
+	}
+
+	return ret_code;
+}
+
+static audio_state_t *initialize_audio_state (u8 asp_id, u8 codec_id)
+{
+	audio_state_t *audio_state;
+	audio_stream_t *output_stream;
+	audio_stream_t *input_stream;
+	audio_state_t *ret_code = NULL;
+
+	audio_state = (audio_state_t *) kmalloc (sizeof(audio_state_t),
+						 GFP_KERNEL);
+
+	if ( audio_state == NULL ) {
+		ret_code = NULL;
+	} else {
+		ret_code = audio_state;
+
+		output_stream = (audio_stream_t *) kmalloc
+			(sizeof(audio_stream_t), GFP_KERNEL);
+		if ( output_stream == NULL ) {
+			kfree(audio_state);
+			ret_code = NULL;
+		} else {
+			input_stream = (audio_stream_t *) kmalloc
+				(sizeof(audio_stream_t), GFP_KERNEL);
+			if ( input_stream == NULL ) {
+				kfree(audio_state);
+				kfree(output_stream);
+				ret_code = NULL;
+			}
+		}
+	}
+
+	if ( ret_code != NULL ) {
+		memset (audio_state, 0, sizeof(audio_state_t));
+		memset (output_stream, 0, sizeof(audio_stream_t));
+		memset (input_stream, 0, sizeof(audio_stream_t));
+
+		output_stream->id = "Output Stream";
+		output_stream->dma_dev =
+			evm_aud_info->asp[asp_id].a_info[asp_id].tx_dma_evt;
+		output_stream->input_or_output = FMODE_WRITE;
+
+		input_stream->id = "Input Stream";
+		input_stream->dma_dev =
+			evm_aud_info->asp[asp_id].a_info[asp_id].rx_dma_evt;
+		input_stream->input_or_output = FMODE_READ;
+
+		audio_state->output_stream = output_stream;
+		audio_state->input_stream = input_stream;
+
+		if (evm_aud_info->asp[asp_id].need_tx_for_rx == 1) {
+			audio_state->need_tx_for_rx = 1;
+		} else {
+			audio_state->need_tx_for_rx = 0;
+		}
+
+		sema_init(&audio_state->sem, 1);
+		audio_state->owner = THIS_MODULE;
+		evm_aud_info->asp[asp_id].audio_state = (void *)audio_state;
+	}
+
+	return ret_code;
+}
+
+static loff_t audio_ctlr_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static unsigned int audio_ctlr_poll ( struct file *file, struct
+				      poll_table_struct *wait )
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *is = state->input_stream;
+	audio_stream_t *os = state->output_stream;
+	unsigned int mask = 0;
+
+	if (file->f_mode & FMODE_READ) {
+		/* Start audio input if not already active */
+		if (!is->active) {
+			if (!is->buffers && audio_setup_buf(is)) {
+				return -ENOMEM;
+			}
+			audio_prime_rx(state);
+		}
+
+		poll_wait(file, &is->wq, wait);
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!os->buffers && audio_setup_buf(os)) {
+			return -ENOMEM;
+		}
+
+		poll_wait(file, &os->wq, wait);
+	}
+
+	if (file->f_mode & FMODE_READ)
+		if ((is->mapped && is->bytecount > 0) ||
+		    (!is->mapped && is->wfc.done > 0))
+			mask |= POLLIN | POLLRDNORM;
+
+	if (file->f_mode & FMODE_WRITE)
+		if ((os->mapped && os->bytecount > 0) ||
+		    (!os->mapped && os->wfc.done > 0))
+			mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+static int audio_ctlr_open ( struct inode *inode, struct file *file )
+{
+	u8 codec_id, asp_id;
+	s8 status = 0;
+	s8 ret_code = 0;
+	int need_tx_dma;
+
+	audio_state_t *state = NULL;
+	audio_stream_t *os = NULL;
+	audio_stream_t *is = NULL;
+
+	u8 dev_instance = iminor (inode);
+
+	/* With this given minor number, search the codec */
+	status = find_audio_device ( dev_instance, &asp_id, &codec_id );
+
+	if (status != 0) {
+		printk(KERN_INFO " Device could not be opened, status %d",
+		       status);
+		ret_code = -ENODEV;
+	}
+
+	if ( validate_file_mode (asp_id, file) < 0 ) {
+		printk (KERN_INFO "Device does not support the requested file \
+		mode.\n");
+		ret_code = -EINVAL;
+	}
+
+	if ( ret_code == 0 ) {
+		if ( evm_aud_info->asp[asp_id].audio_state == NULL ) {
+			state = initialize_audio_state (asp_id, codec_id);
+			if (state == NULL) {
+				ret_code = -ENOMEM;
+			} else {
+				os = state->output_stream;
+				is = state->input_stream;
+				os->device_instance = is->device_instance =
+					dev_instance;
+			}
+		} else {
+			state = (audio_state_t *)
+				evm_aud_info->asp[asp_id].audio_state;
+			os = state->output_stream;
+			is = state->input_stream;
+			os->device_instance = is->device_instance =
+				dev_instance;
+		}
+	}
+
+	/* Lock the module */
+	if (!try_module_get(THIS_MODULE)) {
+		printk (KERN_ERR "Failed to get module\n");
+		return -ESTALE;
+	}
+
+	/* Lock the codec module */
+	if (!try_module_get(state->owner)) {
+		printk (KERN_ERR "Failed to get codec module\n");
+		module_put(THIS_MODULE);
+		return -ESTALE;
+	}
+
+	down(&state->sem);
+
+	/* Reset the acount */
+	acount = 4;
+
+	if (ret_code != 0) {
+		module_put(state->owner);
+		module_put(THIS_MODULE);
+
+		up(&state->sem);
+		return ret_code;
+	}
+
+	if (((file->f_mode & FMODE_WRITE) && !os) ||
+	    ((file->f_mode & FMODE_READ) && !is)) {
+		up(&state->sem);
+		return -ENODEV;
+	}
+
+	if (((file->f_mode & FMODE_WRITE) && state->wr_ref) ||
+	    ((file->f_mode & FMODE_READ) && state->rd_ref)) {
+		up(&state->sem);
+		return -EBUSY;
+	}
+
+	if ((file->f_mode & FMODE_READ) && state->need_tx_for_rx && !os) {
+		up(&state->sem);
+		return -EINVAL;
+	}
+
+	/*
+	 * Basic parameters are OK. Allocate the DMA channels
+	 * for read and write
+	 */
+
+	/* Check the stream for which DMA is required */
+	need_tx_dma = ((file->f_mode & FMODE_WRITE) ||
+		      ((file->f_mode & FMODE_READ) &&  state->need_tx_for_rx));
+
+	if (state->wr_ref || (state->rd_ref && state->need_tx_for_rx))
+		need_tx_dma = 0;
+
+	if (need_tx_dma) {
+		DMA_REQUEST(ret_code, os, audio_dma_callback);
+		if (ret_code < 0)
+			printk(KERN_ERR
+			       "Failed to request the DMA for playback\n");
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		DMA_REQUEST(ret_code, is, audio_dma_callback);
+		if (ret_code < 0) {
+			if (need_tx_dma)
+				DMA_FREE(os);
+			printk(KERN_ERR
+			       "Failed to request the DMA for recording\n");
+		}
+	}
+
+	if (ret_code == 0) {
+		if ((file->f_mode & FMODE_WRITE)) {
+			state->wr_ref = 1;
+			audio_reset (os);
+			os->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+			os->nbfrags = AUDIO_NBFRAGS_DEFAULT;
+			os->mapped = 0;
+			init_waitqueue_head (&os->wq);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			state->rd_ref = 1;
+			audio_reset(is);
+			is->fragsize = AUDIO_FRAGSIZE_DEFAULT;
+			is->nbfrags = AUDIO_NBFRAGS_DEFAULT;
+			is->mapped = 0;
+			init_waitqueue_head(&is->wq);
+		}
+
+		file->private_data = (void *) state;
+	}
+
+	up(&state->sem);
+
+	return ret_code;
+}
+
+/* audio_ctlr_write function. Writes the amount the data supplied by the
+ * user to the device */
+static int audio_ctlr_write(struct file *file, const char *buffer, size_t count,
+			    loff_t *ppos)
+{
+	const char *buffer0 = buffer;
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->output_stream;
+	int chunksize, ret = 0;
+	unsigned long flags;
+
+	if (*ppos != file->f_pos) {
+		printk(KERN_ERR "FPOS not ppos ppos=0x%x fpos =0x%x\n",
+		       (u32) *ppos, (u32) file->f_pos);
+		ret = -ESPIPE;
+	} else if (s->mapped) {
+		printk(KERN_ERR "s already mapped\n");
+		ret = -ENXIO;
+	} else if (!s->buffers && audio_setup_buf(s)) {
+		printk(KERN_ERR "NO MEMORY\n");
+		ret = -ENOMEM;
+	} else {
+		while (count > 0) {
+			audio_buf_t *b = &s->buffers[s->usr_head];
+
+			/* Wait for a buffer to become free */
+			if (file->f_flags & O_NONBLOCK) {
+				ret = -EAGAIN;
+				if (!s->wfc.done) {
+					break;
+				} else {
+					local_irq_save(flags);
+					s->wfc.done--;
+					local_irq_restore(flags);
+				}
+			} else {
+				ret = -ERESTARTSYS;
+				if ( wait_for_completion_interruptible(&s->wfc)
+					) {
+					break;
+				}
+			}
+
+			/* Feed the current buffer */
+			chunksize = s->fragsize - b->offset;
+			if (chunksize > count)
+				chunksize = count;
+
+			if (copy_from_user(b->data + b->offset, buffer,
+					   chunksize)) {
+				printk(KERN_ERR "Audio: CopyFrom User failed \
+						\n");
+				complete(&s->wfc);
+				ret = -EFAULT;
+				break;
+			}
+
+			buffer += chunksize;
+			count -= chunksize;
+			b->offset += chunksize;
+
+			if (b->offset < s->fragsize) {
+				complete(&s->wfc);
+				break;
+			}
+
+			b->offset = 0;
+
+			if (++s->usr_head >= s->nbfrags)
+				s->usr_head = 0;
+
+			s->pending_frags++;
+			s->active = 1;
+
+			audio_process_dma(s);
+		}
+
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+
+	return ret;
+}
+
+/* 	audio_ctlr_read function. Reads the data and gives to the user. */
+
+static int audio_ctlr_read(struct file *file, char *buffer, size_t count,
+			   loff_t *ppos)
+{
+	char *buffer0 = buffer;
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->input_stream;
+	int chunksize, ret = 0;
+	unsigned long flags;
+
+	if (*ppos != file->f_pos) {
+		printk(KERN_ERR
+		       "AudioRead - FPOS not ppos ppos=0x%x fpos = 0x%x\n",
+		       (u32) * ppos, (u32) file->f_pos);
+		return -ESPIPE;
+	}
+
+	if (s->mapped) {
+		printk(KERN_ERR "AudioRead - s already mapped\n");
+		return -ENXIO;
+	}
+
+	if (!s->active) {
+		if (!s->buffers && audio_setup_buf(s)) {
+			printk(KERN_ERR "AudioRead - No Memory\n");
+			return -ENOMEM;
+		}
+
+		audio_prime_rx(state);
+	}
+
+	while (count > 0) {
+		audio_buf_t *b = &s->buffers[s->usr_head];
+		/* Wait for a buffer to become full */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (!s->wfc.done) {
+				break;
+			} else {
+				local_irq_save(flags);
+				s->wfc.done--;
+				local_irq_restore(flags);
+			}
+		} else {
+			ret = -ERESTARTSYS;
+			if (wait_for_completion_interruptible(&s->wfc)) {
+				break;
+			}
+		}
+		/* Grab data from the current buffer */
+		chunksize = s->fragsize - b->offset;
+
+		if (chunksize > count)
+			chunksize = count;
+
+		if (copy_to_user(buffer, b->data + b->offset, chunksize)) {
+			complete(&s->wfc);
+			return -EFAULT;
+		}
+		buffer += chunksize;
+		count -= chunksize;
+		b->offset += chunksize;
+		if (b->offset < s->fragsize) {
+			complete(&s->wfc);
+			break;
+		}
+		/* Update pointers and return current fragment to DMA */
+		local_irq_save(flags);
+
+		b->offset = 0;
+
+		if (++s->usr_head >= s->nbfrags)
+			s->usr_head = 0;
+
+		s->pending_frags++;
+
+		local_irq_restore(flags);
+
+		audio_process_dma(s);
+	}
+
+	if ((buffer - buffer0))
+		ret = buffer - buffer0;
+
+	return ret;
+}
+
+
+static int audio_ctlr_release(struct inode *inode, struct file *file)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	s8 status = 0;
+	u8 codec_id = 0, asp_id = 0;
+	u8 dev_instance = iminor (inode);
+
+	status = find_audio_device ( dev_instance, &asp_id, &codec_id );
+
+	if (status != 0) {
+		printk(KERN_INFO " Audio device could not be found");
+		return -ENODEV;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		audio_discard_buf(is);
+		DMA_FREE(is);
+		is->dma_spinref = 0;
+		if (state->need_tx_for_rx) {
+			os->spin_idle = 0;
+			if (!state->wr_ref) {
+				DMA_FREE(os);
+				os->dma_spinref = 0;
+			}
+		}
+		state->rd_ref = 0;
+		evm_aud_info->asp[asp_id].a_op->stop_rx(asp_id);
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		audio_sync(file);
+		audio_discard_buf(os);
+		if (!state->need_tx_for_rx || !state->rd_ref) {
+			DMA_FREE(os);
+			os->dma_spinref = 0;
+		}
+		state->wr_ref = 0;
+		evm_aud_info->asp[asp_id].a_op->stop_tx(asp_id);
+	}
+
+	if ( !state->wr_ref && !state->rd_ref ) {
+		module_put(state->owner);
+		module_put(THIS_MODULE);
+		atomic_set(&os->playing_null, 0);
+
+		kfree(os);
+		kfree(is);
+		kfree(state);
+		evm_aud_info->asp[asp_id].audio_state = NULL;
+	}
+
+	return 0;
+}
+
+static void configure_codec ( u8 dev_instance )
+{
+	u8 codec_id, asp_id;
+	s8 status = 0;
+	s8 ret_code = 0;
+
+	/* With this given minor number, search the codec */
+	status = find_audio_device ( dev_instance, &asp_id, &codec_id );
+
+	if (unlikely(status != 0)) {
+		printk(KERN_INFO " Device could not be opened");
+		ret_code = -ENODEV;
+	} else {
+		ret_code =
+			evm_aud_info->asp[asp_id].a_op->init(
+				evm_aud_info->asp_count,
+				evm_aud_info->asp[asp_id].a_info);
+		if ( evm_aud_info->asp[asp_id].master_mode == ASP_MASTER ) {
+			/* If ASP is master, configure ASP first and then the
+			   codec */
+			ret_code =
+				evm_aud_info->asp[asp_id].a_op->configure(
+					asp_id, &audio_cfg[asp_id]);
+			if (ret_code != 0) {
+				printk(KERN_ERR "Unable to initialise ASP %d",
+				       asp_id);
+			} else {
+				if ( evm_aud_info->asp[asp_id].dit_enabled !=
+				     1) {
+					/* NK: Changes may be required according
+					   to the FILE_MODES ??????*/
+					ret_code =
+						evm_aud_info->asp[asp_id].
+						codec[codec_id].c_op->configure(
+							codec_id,
+							&audio_cfg[asp_id]);
+					if ( ret_code != 0 ) {
+						printk(KERN_ERR
+						       "Unable to initialise\
+							Codec %d", codec_id);
+					}
+				}
+			}
+		} else {		/* If ASP is Slave */
+			/* Got the desired codec and ASP. Configure them */
+			ret_code =
+				evm_aud_info->asp[asp_id].codec[codec_id].
+				c_op->configure(
+					codec_id, (void *)&audio_cfg[asp_id]);
+			if ( ret_code != 0 ) {
+				printk(KERN_ERR "Unable to initialise Codec %d",
+				       codec_id);
+			} else {
+				/* NK: Changes may be required according to the
+				   FILE_MODES ??????*/
+				ret_code = evm_aud_info->asp[asp_id].
+					a_op->configure(
+						asp_id, &audio_cfg[asp_id]);
+				if ( ret_code != 0 ) {
+					printk(KERN_ERR "Unable to initialise\
+							Codec %d", codec_id);
+				}
+			}
+		}
+	}
+}
+
+s8 register_all_codecs ( void )
+{
+	s8 retcode = -1;
+	u8 asp_cnt = 0, codec_cnt = 0;
+	int minor = 0;
+	int mixer_dev_id;
+
+	printk(KERN_INFO
+	       "Registering Audio Devices. Total communication	peripherals \
+		(ASP) : %d \n", evm_aud_info->asp_count);
+
+	if (evm_aud_info != NULL) {
+		for ( asp_cnt = 0; asp_cnt < evm_aud_info->asp_count; asp_cnt++
+			) {
+			audio_serial_port_t *asp = NULL;
+
+			asp = &evm_aud_info->asp[asp_cnt];
+
+			if ( evm_aud_info->asp[asp_cnt].dit_enabled ==
+			     1 ) {
+				audio_codec_t *codec = NULL;
+				minor = register_sound_dsp
+					(&audio_controller_fops, -1);
+
+				if (minor < 0) {
+					printk (KERN_INFO \
+						"SPDIF on ASP = %d is not" \
+						"initialized. Skipping to" \
+						"the next one\n", \
+						asp->id);
+					continue;
+				} else {
+					codec = &asp[asp_cnt].codec[codec_cnt];
+					/* If atleast once codec is initialized,
+					   then we return success */
+					retcode = 0;
+					codec->device_instance = minor;
+					/* Initialise the minor number */
+					evm_aud_info->asp[asp_cnt].codec[0].
+						device_instance = minor;
+					configure_codec(minor);
+					printk (KERN_INFO \
+						"SPDIF on ASP = %d is" \
+						"initialized."\
+						"Using minor number : %d\n", \
+						asp->id, minor);
+				}
+
+				continue;
+			}
+
+			for ( codec_cnt = 0; codec_cnt < asp->codec_count;
+			      codec_cnt++ ) {
+				audio_codec_t *codec = NULL;
+
+				minor = register_sound_dsp
+					(&audio_controller_fops, -1);
+				mixer_dev_id =
+					register_sound_mixer(
+						&davinci_mixer_fops, -1);
+
+				if (minor < 0) {
+					printk (KERN_INFO \
+						"Codec with ID = %d on ASP =" \
+						"%d is not" \
+						"initialized. Skipping to the"\
+						"next one\n", \
+						codec->id, asp->id);
+					continue;
+				} else {
+					codec = &asp[asp_cnt].codec[codec_cnt];
+					/* If atleast once codec is initialized,
+					   then we return success */
+					retcode = 0;
+					codec->device_instance = minor;
+					configure_codec(minor);
+					printk (KERN_INFO \
+						"Codec with ID = %d on ASP ="\
+						" %d is initialized."\
+						"Using minor number :  %d\n", \
+						codec->id, asp->id, minor);
+				}
+			}
+		}
+	}
+
+	return retcode;
+}
+
+
+/*******************************************************************************
+ * audio_ioctl(): Handles generic ioctls. If there is a request for something
+ * this fn cannot handle, its then given to client specific ioctl routine, that
+ * will take up platform specific requests
+ ******************************************************************************/
+static int audio_ctlr_ioctl(struct inode *inode, struct file *file, uint cmd,
+			    ulong arg)
+{
+	audio_state_t *state = (audio_state_t *)file->private_data;
+	audio_stream_t *os = state->output_stream;
+	audio_stream_t *is = state->input_stream;
+	long val;
+	int ret = 0;
+	static int default_rate = 48000;
+	u8 codec_id, asp_id;
+	s8 status = 0;
+	u8 dev_instance = iminor (inode);
+
+	status = find_audio_device ( dev_instance, &asp_id, &codec_id );
+
+	if (status != 0) {
+		printk(KERN_INFO " Audio device could not be found");
+		return -ENODEV;
+	}
+
+	/* dispatch based on command */
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(os->fragsize, (int *)arg);
+		else
+			return put_user(is->fragsize, (int *)arg);
+
+	case SNDCTL_DSP_GETCAPS:
+		val = DSP_CAP_REALTIME | DSP_CAP_TRIGGER | DSP_CAP_MMAP;
+		if (is && os)
+			val |= DSP_CAP_DUPLEX;
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (long *)arg)) {
+			return -EFAULT;
+		}
+		if (file->f_mode & FMODE_READ) {
+			int ret = audio_set_fragments(is, val);
+			if (ret < 0) {
+				return ret;
+			}
+			ret = put_user(ret, (int *)arg);
+			if (ret) {
+				return ret;
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			int ret = audio_set_fragments(os, val);
+
+			if (ret < 0) {
+				return ret;
+			}
+
+			ret = put_user(ret, (int *)arg);
+			if (ret) {
+				return ret;
+			}
+		}
+		return 0;
+
+	case SNDCTL_DSP_SYNC:
+		return audio_sync(file);
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		if (file->f_mode & FMODE_READ && is->active && !is->stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && os->active && !os->stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *)arg)) {
+			return -EFAULT;
+		}
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT) {
+				unsigned long flags;
+				if (!is->active) {
+					if ( !is->buffers && audio_setup_buf(is)
+						) {
+						return -ENOMEM;
+					}
+					audio_prime_rx(state);
+				}
+				local_irq_save(flags);
+				is->stopped = 0;
+				local_irq_restore(flags);
+				audio_process_dma(is);
+			} else {
+				is->stopped = 1;
+				audio_stop_dma(is);
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT) {
+				unsigned long flags;
+				if (!os->buffers && audio_setup_buf(os)) {
+					return -ENOMEM;
+				}
+				local_irq_save(flags);
+				if (os->mapped && !os->pending_frags) {
+					os->pending_frags = os->nbfrags;
+					init_completion(&os->wfc);
+					os->wfc.done = 0;
+					os->active = 1;
+				}
+				os->stopped = 0;
+				local_irq_restore(flags);
+				audio_process_dma(os);
+			} else {
+				os->stopped = 1;
+				audio_stop_dma(os);
+			}
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOPTR:
+	case SNDCTL_DSP_GETIPTR:
+	{
+		count_info inf = { 0, };
+		audio_stream_t *s =
+			(cmd == SNDCTL_DSP_GETOPTR) ? os : is;
+		int bytecount, offset;
+		unsigned long flags;
+		if ((s == is && !(file->f_mode & FMODE_READ)) ||
+		    (s == os && !(file->f_mode & FMODE_WRITE))) {
+			return -EINVAL;
+		}
+		if (s->active) {
+			local_irq_save(flags);
+			offset = audio_get_dma_pos(s);
+			inf.ptr = s->dma_tail * s->fragsize + offset;
+			bytecount = s->bytecount + offset;
+			s->bytecount = -offset;
+			inf.blocks = s->fragcount;
+			s->fragcount = 0;
+			local_irq_restore(flags);
+			if (bytecount < 0)
+				bytecount = 0;
+			inf.bytes = bytecount;
+		}
+		return copy_to_user((void *)arg, &inf, sizeof(inf));
+	}
+
+	case SNDCTL_DSP_GETOSPACE:
+	case SNDCTL_DSP_GETISPACE:
+	{
+		audio_buf_info inf = { 0, };
+		audio_stream_t *s =
+			(cmd == SNDCTL_DSP_GETOSPACE) ? os : is;
+		if ((s == is && !(file->f_mode & FMODE_READ)) ||
+		    (s == os && !(file->f_mode & FMODE_WRITE))) {
+			return -EINVAL;
+		}
+		if (!s->buffers && audio_setup_buf(s)) {
+			return -ENOMEM;
+		}
+		inf.bytes = s->wfc.done * s->fragsize;
+
+		inf.fragments = inf.bytes / s->fragsize;
+		inf.fragsize = s->fragsize;
+		inf.fragstotal = s->nbfrags;
+		return copy_to_user((void *)arg, &inf, sizeof(inf));
+	}
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_READ) {
+			audio_reset(is);
+			if (state->need_tx_for_rx) {
+				unsigned long flags;
+				local_irq_save(flags);
+				os->spin_idle = 0;
+				local_irq_restore(flags);
+			}
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			audio_reset(os);
+		}
+		return 0;
+
+	default:
+		/* Nirmal: If McASP is configured for the DIT, do not call codec
+		   ioctls */
+		if (evm_aud_info->asp[asp_id].dit_enabled == 1) {
+			/* Take some of the ioctls, which other wise are
+			   applicable to codec */
+			switch (cmd) {
+			case SOUND_PCM_READ_RATE:
+				return put_user(default_rate, (long *)arg);
+				break;
+
+			case SOUND_PCM_READ_BITS:
+			case SNDCTL_DSP_GETFMTS:
+				/* NK: Only 16 bit little endian format is
+				   supported */
+				return put_user(AFMT_S16_LE, (long *)arg);
+				break;
+
+			case SNDCTL_DSP_SPEED:
+				ret = get_user(val, (long *)arg);
+				if (ret) {
+					printk(KERN_ERR "get_user failed\n");
+					return -1;
+				}
+				if (val > 48000) {
+					printk(KERN_ERR "\n Sample rate %d not"\
+					       "supported", (int)val);
+					return -1;
+				} else {
+					/* Set the desired sampling frequency */
+					audio_cfg[asp_id].sample_rate = val;
+					ret = evm_aud_info->asp[asp_id].
+						a_op->configure(
+							asp_id,
+							&audio_cfg[asp_id]
+							);
+					return ret;
+				}
+				break;
+
+			case SNDCTL_DSP_SETFMT:
+				/* set the desired Format */
+				ret = get_user(val, (long *)arg);
+				if (ret) {
+					printk("get_user failed\n");
+					break;
+				}
+				if (val == AFMT_S16_LE) {
+					printk (KERN_ERR "\n Setting" \
+						" AFMT_S16_LE requested" \
+						" Format ");
+					acount = 4;
+					return 0;
+				}
+				/*
+				  else if (val == AFMT_U8 ) {
+				  printk ("\n Setting" \
+				  " AFMT_U8 requested Format");
+				  acount = 2;
+				  return 0;
+				  }
+				*/
+				else{
+					printk (KERN_ERR "\n Requested Format"\
+						" not supported\n");
+					return -EPERM;
+				}
+				break;
+			default:
+				printk(KERN_ERR "\n This ioctl might not be"\
+				       " applicable for DIT\n");
+				return 0;
+			}
+		} else {
+			switch (cmd) {
+			case SNDCTL_DSP_SPEED:
+				if ( evm_aud_info->asp[asp_id].master_mode ==
+				     ASP_MASTER &&
+				     evm_aud_info->asp[asp_id].dit_enabled != 1
+					) {
+					asp_fops_t *asp_fops = NULL;
+					u32 sample_rate = 0;
+
+					asp_fops = get_asp_fops(dev_instance);
+
+					ret = get_user(val, (long *)arg);
+					if (ret) {
+						printk("get_user failed\n");
+						break;
+					}
+
+					sample_rate =
+						asp_fops->set_sample_rate(
+							asp_id, val);
+
+					if (sample_rate != val) {
+						printk (KERN_ERR
+							"asp_fops->"\
+							"set_sample_rate "\
+							"failed\n");
+					}
+
+					return put_user(sample_rate,
+							(long *)arg);
+				} else {
+					if ( evm_aud_info->asp[asp_id].
+					     codec[codec_id].c_op->ioctl !=
+					     NULL) {
+						return (evm_aud_info->
+							asp[asp_id].
+							codec[codec_id].
+							c_op->ioctl(inode,
+								    file,
+								    cmd,
+								    arg)
+							);
+					} else {
+						printk (KERN_INFO "Ioctl "\
+							"command (%d) not "\
+							" supported\n", cmd);
+						return 0;
+					}
+				}
+				break;
+
+			case SOUND_PCM_READ_RATE:
+				if ( evm_aud_info->asp[asp_id].master_mode
+				     == ASP_MASTER &&
+				     evm_aud_info->asp[asp_id].dit_enabled != 1
+					) {
+					asp_fops_t *asp_fops = NULL;
+					u32 sample_rate = 0;
+
+					asp_fops = get_asp_fops(dev_instance);
+					sample_rate =
+						asp_fops->get_sample_rate(
+							asp_id);
+
+					return put_user(sample_rate,
+							(long *)arg);
+				} else {
+					if (evm_aud_info->asp[asp_id].
+					    codec[codec_id].c_op->ioctl !=
+					    NULL) {
+						return (evm_aud_info->
+							asp[asp_id].
+							codec[codec_id].
+							c_op->ioctl(inode,
+								    file,
+								    cmd,
+								    arg));
+					} else {
+						printk (KERN_INFO "Ioctl "\
+							"command (%d) not "\
+							"supported\n", cmd);
+						return 0;
+					}
+				}
+				break;
+
+			default:
+				if (evm_aud_info->asp[asp_id].codec[codec_id].
+				    c_op->ioctl !=
+				    NULL) {
+					return (evm_aud_info->
+						asp[asp_id].
+						codec[codec_id].
+						c_op->ioctl(inode,
+							    file,
+							    cmd,
+							    arg));
+				} else {
+					printk (KERN_INFO "Ioctl "\
+						"command (%d) not "\
+						"supported\n", cmd);
+					return 0;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static int __init audio_controller_init ( void )
+{
+	s8 retcode = 0;
+
+	if (validate_evm_audio_config (&evm_aud_info) < 0 ) {
+		retcode = -EINVAL;
+	} else {
+		/* Register codecs described in the evm_aud_info
+		   structure */
+		register_all_codecs ();
+	}
+
+	return 0;
+}
+
+static void __exit audio_controller_exit ( void )
+{
+	return;
+}
+
+module_init(audio_controller_init);
+module_exit(audio_controller_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("Generic Audio Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/sound/oss/dm646x/audio_controller.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/audio_controller.h
@@ -0,0 +1,129 @@
+#ifndef __AUDIO_CONTROLLER_H_
+#define __AUDIO_CONTROLLER_H_
+/*
+ * audio_controller.h - Common audio handling. Replaces the old davinci-audio.h
+ *                      to make things more generic, independent of ASP and
+ * 			codec.
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+/* Requires dma.h */
+#include <asm/arch/dma.h>
+#include <asm/atomic.h>
+#include <asm/arch/davinci-audio-config.h>
+
+/* Structure related to the audio buffer management */
+typedef struct {
+	/* current offset of data within the Fragment */
+    s32 		offset;
+	/* points to actual data buffer */
+    s8 			*data;
+	/* physical buffer address */
+    dma_addr_t 	dma_addr;
+	/* DMA reference count. Number of buffers DMA'd */
+    s32 		dma_ref;
+	/* owner for buffer allocation, contain size when true */
+    s32 		master;
+} audio_buf_t;
+
+/* Structure describing the data stream related information */
+typedef struct {
+    s8 			*id;			/* identification string */
+    audio_buf_t	*buffers; /* point32er to audio buffer structures */
+    u32 		usr_head;		/* user fragment index */
+    u32 		dma_head;		/* DMA fragment index to go */
+    u32 		dma_tail; /* DMA fragment index to complete */
+    u32 		fragsize;		/* fragment i.e. buffer size */
+    u32 		nbfrags;	/* nbr of fragments i.e. buffers */
+    u32 		pending_frags;	/* Fragments sent to DMA */
+    s32 		dma_dev;		/* device identifier for DMA */
+    u32 		prevbuf;	/* Prev pending frag size sent to DMA */
+    s8 			started;/* to store if the chain was started or not */
+    s32 		dma_q_head;		/* DMA Channel Q Head */
+    s32 		dma_q_tail;		/* DMA Channel Q Tail */
+    s8 			dma_q_count;	/* DMA Channel Q Count */
+    s8 			in_use;			/*  Is this is use? */
+    s32 		master_ch;
+    s32 		*lch; /*  Chain of channels this stream is linked to */
+    s32 		input_or_output;/* Direction of this data stream */
+    s32 		bytecount;		/* nbr of processed bytes */
+    s32 		fragcount;	/* nbr of fragment transitions */
+    struct completion wfc;	/* wait for "nbfrags" fragment completion */
+    wait_queue_head_t wq;		/* for poll */
+    s32 		dma_spinref;	/* DMA is spinning */
+    s32 		mapped:1;		/* mmap()'ed buffers */
+    s32 		active:1;		/* actually in progress */
+    s32 		stopped:1;	/* might be active but stopped */
+    s32 		spin_idle:1;/* have DMA spin on zeros when idle */
+    s32 		dma_started;	/* to store if DMA was started or not */
+    s32		        asp_tx_started;
+    s32		        asp_rx_started;
+    u8                  device_instance; /* For storing the minor number of the
+					    device to refer to in
+					    audio_ctrl_open */
+    atomic_t            playing_null;
+    s32                 null_lch;
+    atomic_t            syncing;
+} audio_stream_t;
+
+/* State structure for one opened instance */
+typedef struct {
+    struct module 	*owner;				/* Codec module ID */
+    audio_stream_t 	*output_stream;
+    audio_stream_t 	*input_stream;
+    s32 		rd_ref:1;	/* open reference for recording */
+    s32 		wr_ref:1;	/* open reference for playback */
+    s32 		need_tx_for_rx:1;/* if data must be sent while receiving
+					  */
+    void		*data;
+    void		(*hw_init) (void *);
+    void		(*hw_shutdown) (void *);
+    s32         	(*client_ioctl) (struct inode *, struct file *, u32,
+					 ulong);
+    s32 		(*hw_probe) (void);
+    void 		(*hw_remove) (void);
+    void 		(*hw_cleanup) (void);
+    s32 		(*hw_suspend) (void);
+    s32 		(*hw_resume) (void);
+    struct pm_dev 	*pm_dev;
+    struct compat_semaphore sem; /* to protect against races in attach() */
+} audio_state_t;
+
+
+#ifdef AUDIO_PM
+void audio_ldm_suspend(void *data);
+
+void audio_ldm_resume(void *data);
+
+#endif
+
+/* Register a Codec using this function */
+extern int audio_register_codec(audio_state_t *codec_state);
+/* Un-Register a Codec using this function */
+extern int audio_unregister_codec(audio_state_t *codec_state);
+/* Function to provide fops of davinci audio driver */
+extern struct file_operations *audio_get_fops(void);
+/* Function to initialize the device info for audio driver */
+extern int audio_dev_init(void);
+/* Function to un-initialize the device info for audio driver */
+void audio_dev_uninit(void);
+
+#endif /* __AUDIO_CONTROLLER_H_ */
Index: linux-2.6.10/sound/oss/dm646x/davinci-aic32.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/davinci-aic32.h
@@ -0,0 +1,250 @@
+/*
+ * linux/sound/oss/davinci-aic32.h
+ *
+ * Glue driver for AIC32 for Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *  -------
+ *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x
+ * Processor
+ */
+
+#ifndef __ASM_ARCH_AIC32_H
+#define __ASM_ARCH_AIC32_H
+
+/* Codec TLV320AIC32 */
+/* Not all the registers are defined here. Only used ones are defined */
+#define REGISTER_ADDR0          0x00
+#define REGISTER_ADDR1          0x01
+#define REGISTER_ADDR2          0x02
+#define REGISTER_ADDR3          0x03
+#define REGISTER_ADDR4          0x04
+#define REGISTER_ADDR5          0x05
+#define REGISTER_ADDR6          0x06
+#define REGISTER_ADDR7          0x07
+#define REGISTER_ADDR8          0x08
+#define REGISTER_ADDR9          0x09
+#define REGISTER_ADDR10         0x0A
+#define REGISTER_ADDR11         0x0B
+#define REGISTER_ADDR12         0x0C
+#define REGISTER_ADDR15         0x0F
+#define REGISTER_ADDR16         0x10
+#define REGISTER_ADDR17         0x11
+#define REGISTER_ADDR18         0x12
+#define REGISTER_ADDR19         0x13
+#define REGISTER_ADDR20         0x14
+#define REGISTER_ADDR21         0x15
+#define REGISTER_ADDR22         0x16
+#define REGISTER_ADDR23         0x17
+#define REGISTER_ADDR24         0x18
+#define REGISTER_ADDR25         0x19
+#define REGISTER_ADDR26         0x1A
+#define REGISTER_ADDR27         0x1B
+#define REGISTER_ADDR28         0x1C
+#define REGISTER_ADDR29         0x1D
+#define REGISTER_ADDR30         0x1E
+#define REGISTER_ADDR31         0x1F
+#define REGISTER_ADDR32         0x20
+#define REGISTER_ADDR33         0x21
+#define REGISTER_ADDR37         0x25
+#define REGISTER_ADDR38         0x26
+#define REGISTER_ADDR40         0x28
+#define REGISTER_ADDR41         0x29
+#define REGISTER_ADDR42         0x2A
+#define REGISTER_ADDR43         0x2B
+#define REGISTER_ADDR44         0x2C
+#define REGISTER_ADDR45         0x2D
+#define REGISTER_ADDR46         0x2E
+#define REGISTER_ADDR47         0x2F
+#define REGISTER_ADDR51         0x33
+#define REGISTER_ADDR58         0x3A
+#define REGISTER_ADDR64         0x40
+#define REGISTER_ADDR65         0x41
+#define REGISTER_ADDR73         0x49
+#define REGISTER_ADDR74         0x4A
+#define REGISTER_ADDR75         0x4B
+#define REGISTER_ADDR76         0x4C
+#define REGISTER_ADDR77         0x4D
+#define REGISTER_ADDR78         0x4E
+#define REGISTER_ADDR79         0x4F
+#define REGISTER_ADDR80         0x50
+#define REGISTER_ADDR81         0x51
+#define REGISTER_ADDR82         0x52
+#define REGISTER_ADDR83         0x53
+#define REGISTER_ADDR84         0x54
+#define REGISTER_ADDR85         0x55
+#define REGISTER_ADDR86         0x56
+#define REGISTER_ADDR87         0x57
+#define REGISTER_ADDR88         0x58
+#define REGISTER_ADDR89         0x59
+#define REGISTER_ADDR90         0x5A
+#define REGISTER_ADDR91         0x5B
+#define REGISTER_ADDR92         0x5C
+#define REGISTER_ADDR93         0x5D
+#define REGISTER_ADDR94         0x5E
+#define REGISTER_ADDR102        0x66
+
+/* Page Select register 0 */
+#define PAGE_SELECT0            0
+#define PAGE_SELECT1            1
+
+/* Software reset register 1 */
+#define SOFT_RESET              0x80
+
+/* Codec sample rate select register 2 */
+#define ADC_FS_MAX              0xA0
+#define ADC_FS_MIN              0x00
+
+#define DAC_FS_MAX              0x0A
+#define DAC_FS_MIN              0x00
+
+/* PLL Programming registerA 3 */
+#define PLL_ENABLE              0x80
+
+/* Codec Datapath setup register 7 */
+#define FS_REF_44_1             0x80
+#define FS_REF_DEFAULT_48       0x00
+#define ADC_DUAL_RATE_MODE      0x40
+#define DAC_DUAL_RATE_MODE      0x20
+#define LDAC_LCHAN              0x08
+#define LDAC_RCHAN              0x10
+#define LDAC_MONO_MIX           0x18
+
+#define RDAC_RCHAN              0x02
+#define RDAC_LCHAN              0x04
+#define RDAC_MONO_MIX           0x06
+
+/* Audio serial data interface control registerA 8 */
+#define BIT_CLK_MASTER          0x80
+#define WORD_CLK_MASTER         0x40
+#define DOUT_TRI_STATE          0x20
+#define CLK_TRANS_MASTER        0x10
+#define ENABLE_3D               0x04
+#define DM_ENABLE_128           0x01
+#define DM_ENABLE_64            0x02
+#define DM_ENABLE_32            0x03
+
+/* Audio serial data interface control registerB 9 */
+#define DSP_MODE                0x40
+#define RJ_MODE                 0x80
+#define LJ_MODE                 0xC0
+#define WORD_LENGTH20           0x10
+#define WORD_LENGTH24           0x20
+#define WORD_LENGTH32           0x30
+#define BITCLOCK_256CLK_FRAME   0x08
+
+/* Left/Right ADC PGA gain control register 15 & 16 */
+#define ADC_PGA_MUTE            0x80
+#define ADC_PGA_GAIN_MAX        0x78
+#define ADC_PGA_GAIN_MIN        0x00
+
+/*  MIC3L/R to left/right ADC control register 17 & 18 */
+#define ADCPGA_GAIN_MAX         0x00
+#define MIC3L_ADCPGA_GAIN_MIN   0x80
+#define MIC3L_ADCPGA_DISCONNECT 0xF0
+
+#define MIC3R_ADCPGA_GAIN_MIN   0x08
+#define MIC3R_ADCPGA_DISCONNECT 0x0F
+
+/* LINE1L to left ADC Control Register 19 */
+#define DIFF_MODE               0x80
+#define LINE_ADCPGA_GAIN_MIN    0x40
+#define LINE_ADCPGA_DISCONNECT  0x78
+#define ADC_CHAN_ON             0x04
+#define ADCPGA_SOFT_STEP2FS     0x01
+#define ADCPGA_SOFT_STEP_OFF    0x03
+
+/* LINE2L to left ADC Control Register 20 */
+#define ADC_WEAK_INPUT_BIAS     0x04
+
+/* MICBIAS control register 25 */
+#define MICBIAS_OUTPUT_2_0V     0x40
+#define MICBIAS_OUTPUT_2_5V     0x80
+#define MICBIAS_OUTPUT_AVDD     0xC0
+
+/* LEFT/RIGHT AGC Control registerA 26 & 29 */
+#define AGC_ENABLE              0x80
+#define AGC_TARGET_GAIN_MAX     0x00
+#define AGC_TARGET_GAIN_MIN     0x70
+#define AGC_ATTACK_TIME_11      0x04
+#define AGC_ATTACK_TIME_16      0x08
+#define AGC_ATTACK_TIME_20      0x0C
+#define AGC_DECAY_TIME_200      0x01
+#define AGC_DECAY_TIME_400      0x02
+#define AGC_DECAY_TIME_500      0x03
+
+/* LEFT AGC Control registerB 27 & 30 */
+#define AGC_GAIN_ALLOWED_MAX    0xEE
+#define AGC_GAIN_ALLOWED_MIN    0x00
+
+/* DAC Power and output driver control register 37 */
+#define LEFT_DAC_POWER_ON       0x80
+#define RIGHT_DAC_POWER_ON      0x40
+
+/* High Power Output Stage Control Register 40 */
+#define LINE2L_BYPASS_DISABLE_DEFAULT    0x00
+#define LINE2LP_BYPASS_SINGLE            0x10
+#define LINE2LM_BYPASS_SINGLE            0x20
+#define LINE2LPM_BYPASS_DIFFERENTIAL     0x30
+
+#define LINE2R_BYPASS_DISABLE_DEFAULT    0x00
+#define LINE2RP_BYPASS_SINGLE            0x04
+#define LINE2RM_BYPASS_SINGLE            0x08
+#define LINE2RPM_BYPASS_DIFFERENTIAL     0x0C
+
+/* DAC Output Switching Control Register 41 */
+#define LEFT_DAC_DEFAULT_L1     0x00
+#define LEFT_DAC_L2             0x80
+#define LEFT_DAC_L3             0x40
+#define RIGHT_DAC_DEFAULT_R1    0x00
+#define RIGHT_DAC_R2            0x08
+#define RIGHT_DAC_R3            0x04
+
+/* LEFT/RIGHT DAC Digital volume control register 43 & 44 */
+#define DAC_CHAN_MUTE            0x80
+#define DAC_DIG_VOL_GAIN_MAX     0x00	/* 0.0db */
+#define DAC_DIG_VOL_GAIN_MIN     0x7F	/* -63.5db */
+
+/* LINE2L to HPLOUT Volume Control Register 45 */
+#define LINE2L_HPLOUT_ROUTED              0x80
+
+/* PGA_L to HPLOUT Volume Control Register 46 */
+#define PGAL_HPLOUT_ROUTED                0x80
+
+/* any to LOP/M Volume control */
+#define LOPM_ON                 0x80
+#define LOPM_VOL_GAIN_MAX       0x00	/* 0 db */
+#define LOPM_VOL_GAIN_MIN       0x76	/* -78.3 db is MUTE */
+
+/* MONO_LOP/M output level volume control register 79 */
+#define LOPM_POWER_ON            0x01
+#define LOPM_MUTE_OFF            0x08
+#define LOPM_OUTPUT_LEVEL_MIN    0x00
+#define LOPM_OUTPUT_LEVEL_MAX    0x90
+
+/* Module Power Status Register 94 */
+#define HPROUT_DRIVER_POWER_ON           0x02
+
+#define LIV_MAX                         0x0077
+#define LIV_MIN                         0x0000
+
+#define LHV_MAX                         0x0077
+#define LHV_MIN                         0x0000
+
+#define LIG_MAX							0x0077
+#define LIG_MIN							0x0000
+
+#define LOG_MAX							0x007f
+#define LOG_MIN							0x0000
+
+#endif				/* __ASM_ARCH_AIC32_H */
Index: linux-2.6.10/sound/oss/dm646x/davinci-audio-aic32.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/davinci-audio-aic32.c
@@ -0,0 +1,956 @@
+/*
+ * linux/sound/oss/davinci-audio-aic32.c
+ *
+ * Glue driver for AIC32 for Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *  -------
+ *  2005-10-18 Rishi Bhattacharya - Support for AIC33 codec and Davinci DM644x
+ *                                  Processor
+ *
+ *  2007-07-06   Nirmal Pandey, Suresh Rajashekara - Included new sound driver
+ *              arch (to support multiple ASP types and codec types)
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <sound/davincisound.h>
+
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <asm/hardware/clock.h>
+#include "davinci-aic32.h"
+#include <asm/arch/evm_audio_info.h>
+
+#include "audio_controller.h"
+#include "davinci-audio-dma-intfc.h"
+
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#define PROC_START_FILE "driver/aic32-audio-start"
+#define PROC_STOP_FILE  "driver/aic32-audio-stop"
+#endif
+
+/* #define DEBUG */
+
+#ifdef DEBUG
+#define DPRINTK(ARGS...)        do { \
+					printk(KERN_DEBUG "<%s>: ", \
+					       __FUNCTION__);\
+					printk(KERN_DEBUG ARGS);\
+				} while (0)
+#else
+#define DPRINTK( x... )
+#endif
+
+#define CODEC_NAME               "AIC32"
+#define PLATFORM_NAME            "DAVINCI"
+
+/* Define to set the AIC32 as the master w.r.t McBSP/McASP */
+#define AIC32_MASTER
+
+/* codec clock frequency */
+#define MCLK  22
+
+#ifdef DEBUG
+
+#define FN_IN   printk(KERN_DEBUG "Entering Function %s\n", __FUNCTION__ );
+#define FN_OUT  printk(KERN_DEBUG "Exiting Function %s\n", __FUNCTION__ );
+
+#else  /* DEBUG */
+
+#define FN_IN
+#define FN_OUT
+
+#endif /* DEBUG */
+/*
+ * AUDIO related MACROS
+ */
+#define DEFAULT_BITPERSAMPLE          16
+#define AUDIO_RATE_DEFAULT            48000
+#define DEFAULT_MCBSP_CLOCK           81000000
+
+/* Select the McBSP For Audio */
+#define AUDIO_MCBSP                   DAVINCI_MCBSP1
+
+#define REC_MASK                      (SOUND_MASK_LINE | SOUND_MASK_MIC)
+#define DEV_MASK                      (REC_MASK | SOUND_MASK_VOLUME)
+
+#define MONO			      1
+#define STEREO			      2
+
+#define SET_VOLUME                    1
+#define SET_LINE                      2
+#define SET_MIC                       3
+#define SET_RECSRC		      4
+#define SET_IGAIN		      5
+#define SET_OGAIN		      6
+#define SET_BASS                      7
+#define SET_TREBLE                    8
+#define SET_MICBIAS		      9
+
+#define DEFAULT_OUTPUT_VOLUME         70
+#define DEFAULT_INPUT_VOLUME          20	/* 0 ==> mute line in */
+#define DEFAULT_INPUT_IGAIN	      20
+#define DEFAULT_INPUT_OGAIN	      100
+
+#define OUTPUT_VOLUME_MIN             LHV_MIN
+#define OUTPUT_VOLUME_MAX             LHV_MAX
+#define OUTPUT_VOLUME_RANGE           (OUTPUT_VOLUME_MAX - OUTPUT_VOLUME_MIN)
+
+#define INPUT_VOLUME_MIN              LIV_MIN
+#define INPUT_VOLUME_MAX              LIV_MAX
+#define INPUT_VOLUME_RANGE            (INPUT_VOLUME_MAX - INPUT_VOLUME_MIN)
+
+#define INPUT_GAIN_MIN		      LIG_MIN
+#define INPUT_GAIN_MAX		      LIG_MAX
+#define INPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
+
+#define OUTPUT_GAIN_MIN		      LOG_MIN
+#define OUTPUT_GAIN_MAX		      LOG_MAX
+#define OUTPUT_GAIN_RANGE	      (INPUT_GAIN_MAX - INPUT_GAIN_MIN)
+
+static struct aic32_local_info {
+	u8 volume;
+	u16 volume_reg;
+	u8 line;
+	u8 mic;
+	int recsrc;
+	u8 nochan;
+	u16 igain;
+	u16 ogain;
+	u8 micbias;
+	u8 bass;
+	u8 treble;
+	u16 input_volume_reg;
+	int mod_cnt;
+} aic32_local;
+
+struct sample_rate_reg_info {
+	u32 sample_rate;
+	u32 Fsref;
+	float divider;
+	u8 data;
+};
+
+/* To Store the default sample rate */
+static long audio_samplerate = AUDIO_RATE_DEFAULT;
+
+#define NUMBER_SAMPLE_RATES_SUPPORTED 34
+
+/* DAC USB-mode sampling rates*/
+static const struct sample_rate_reg_info
+ reg_info[NUMBER_SAMPLE_RATES_SUPPORTED] = {
+/*  {sample_rate, Fsref, divider, data}*/
+	{96000, 96000, 1, 0x00},
+	{88200, 88200, 1, 0x00},
+	{64000, 96000, 1.5, 0x11}, /* New */
+	{58800, 88200, 1.5, 0x11}, /* New */
+	{48000, 48000, 1, 0x00},
+	{44100, 44100, 1, 0x00},
+	{38400, 96000, 2.5, 0x33}, /* New */
+	{35280, 88200, 2.5, 0x33}, /* New */
+	{32000, 48000, 1.5, 0x11},
+	{29400, 44100, 1.5, 0x11}, /* New */
+	{27429, 96000, 3.5, 0x55}, /* New */
+	{25200, 88200, 3.5, 0x55}, /* New */
+	{24000, 96000, 4, 0x66},
+	{22050, 44100, 2, 0x22},
+	{21332, 96000, 4.5, 0x66}, /* New */
+	{19600, 88200, 4.5, 0x66}, /* New */
+	{19200, 48000, 2.5, 0x33}, /* New */
+	{17640, 44100, 2.5, 0x33}, /* New */
+	{17455, 96000, 5.5, 0x88}, /* New */
+	{16036, 88200, 5.5, 0x88}, /* New */
+	{16000, 48000, 3, 0x44},
+	{14700, 44100, 3, 0x44}, /* New */
+	{13714, 48000, 3.5, 0x55}, /* New */
+	{12600, 44100, 3.5, 0x55}, /* New */
+	{12000, 48000, 4, 0x66},
+	{11025, 44100, 4, 0x66},
+	{10667, 48000, 4.5, 0x77}, /* New */
+	{9800, 44100, 4.5, 0x77}, /* New */
+	{9600, 48000, 5, 0x88},	/* New */
+	{8820, 44100, 5, 0x88},	/* New */
+	{8727, 48000, 5.5, 0x99}, /* New */
+	{8018, 44100, 5.5, 0x99}, /* New */
+	{8000, 48000, 6, 0xAA},
+	{7350, 44100, 6, 0xAA},	/* New */
+ };
+
+static void davinci_aic32_initialize(void *dummy);
+/* static void davinci_aic32_shutdown(void *dummy); */
+int davinci_aic32_ioctl(struct inode *inode, struct file *file,
+			       uint cmd, ulong arg);
+
+/* static int davinci_aic32_probe(void); */
+
+/* #ifdef MODULE */
+/* static void davinci_aic32_remove(void); */
+/* #endif */
+
+/* static int davinci_aic32_suspend(void); */
+/* static int davinci_aic32_resume(void); */
+
+static inline void aic32_configure(audio_config_t *audio_cfg);
+static int mixer_open(struct inode *inode, struct file *file);
+static int mixer_release(struct inode *inode, struct file *file);
+static int mixer_ioctl(struct inode *inode, struct file *file, uint cmd,
+		       ulong arg);
+
+s8 aic32_config(u8 id, void *ptr)
+{
+    void *dummy;
+    audio_config_t *audio_cfg = (audio_config_t *)ptr;
+
+    aic32_local.volume = DEFAULT_OUTPUT_VOLUME;
+    aic32_local.line = DEFAULT_INPUT_VOLUME;
+    /* either of SOUND_MASK_LINE/SOUND_MASK_MIC */
+    aic32_local.recsrc = SOUND_MASK_LINE;
+    aic32_local.igain = DEFAULT_INPUT_IGAIN | (DEFAULT_INPUT_IGAIN << 8);
+    aic32_local.ogain = DEFAULT_INPUT_OGAIN | (DEFAULT_INPUT_OGAIN << 8);
+    aic32_local.nochan = STEREO;
+    aic32_local.micbias = 1;
+    aic32_local.mod_cnt = 0;
+    aic32_configure(audio_cfg);
+
+    davinci_aic32_initialize(dummy);
+/*     davinci_set_samplerate(AUDIO_RATE_DEFAULT); */
+    return 0;
+}
+
+codec_fops_t aic32_fops = {
+    .configure = aic32_config,
+    .ioctl = davinci_aic32_ioctl,
+};
+
+/* File Op structure for mixer */
+struct file_operations davinci_mixer_fops = {
+	.open = mixer_open,
+	.release = mixer_release,
+	.ioctl = mixer_ioctl,
+	.owner = THIS_MODULE
+};
+
+extern int tlv320aic33_write_value(u8 reg, u16 value);
+extern int tlv320aic33_read_value(u8 address, u8 * regValue);
+
+/* TLV320AIC32 read */
+static __inline__ void audio_aic32_read(u8 address, u8 * regValue)
+{
+    FN_IN;
+    tlv320aic33_read_value(address, regValue);
+    FN_OUT;
+}
+
+/* TLV320AIC32 write */
+static __inline__ void audio_aic32_write(u8 address, u16 data)
+{
+    FN_IN;
+    if (tlv320aic33_write_value(address, data) < 0)
+	printk(KERN_INFO "aic32 write failed for reg = %d\n", address);
+    FN_OUT;
+}
+
+static int aic32_update(int flag, int val)
+{
+	u16 volume;
+	s16 left_gain, left_val, right_gain, right_val;
+
+	FN_IN;
+
+	switch (flag) {
+	case SET_VOLUME:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 100) {
+			DPRINTK("Trying a bad volume value(%d)!\n", val);
+			return -EPERM;
+		}
+		/* Convert 0 -> 100 volume to 0x77(LHV_MIN) -> 0x00(LHV_MAX) */
+		volume =
+		    ((val * OUTPUT_VOLUME_RANGE) / 100) + OUTPUT_VOLUME_MIN;
+
+		aic32_local.volume_reg = OUTPUT_VOLUME_MAX - volume;
+
+		if (aic32_local.nochan == STEREO) {
+			audio_aic32_write(REGISTER_ADDR47, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR64, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR82, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR92, LOPM_ON |
+					  aic32_local.volume_reg);
+		} else if (aic32_local.nochan == MONO) {
+#ifdef CONFIG_MONOSTEREO_DIFFJACK
+			/* DACL1 to MONO_LOP/M routing and volume control */
+			audio_aic32_write(REGISTER_ADDR75, LOPM_ON |
+					  aic32_local.volume_reg);
+			/* DACR1 to MONO_LOP/M routing and volume control */
+			audio_aic32_write(REGISTER_ADDR78, LOPM_ON |
+					  aic32_local.volume_reg);
+#else
+			audio_aic32_write(REGISTER_ADDR47, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR64, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR82, LOPM_ON |
+					  aic32_local.volume_reg);
+			audio_aic32_write(REGISTER_ADDR92, LOPM_ON |
+					  aic32_local.volume_reg);
+#endif
+		}
+
+		break;
+
+	case SET_LINE:
+	case SET_MIC:
+		/* Ignore separate left/right channel for now even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 100) {
+			DPRINTK("Trying a bad volume value(%d)!\n", val);
+			return -EPERM;
+		}
+
+		volume = ((val * INPUT_VOLUME_RANGE) / 100) + INPUT_VOLUME_MIN;
+
+		aic32_local.input_volume_reg = volume;
+
+		audio_aic32_write(REGISTER_ADDR15,
+				  aic32_local.input_volume_reg);
+		audio_aic32_write(REGISTER_ADDR16,
+				  aic32_local.input_volume_reg);
+		break;
+
+	case SET_RECSRC:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (hweight32(val) > 1)
+			val &= ~aic32_local.recsrc;
+
+		if (val == SOUND_MASK_MIC) {
+			/* enable the mic input*/
+			DPRINTK("Enabling mic\n");
+			audio_aic32_write(REGISTER_ADDR17, 0x0);
+			audio_aic32_write(REGISTER_ADDR18, 0x0);
+
+			/* enable ADC's and disable the line input*/
+			audio_aic32_write(REGISTER_ADDR19, 0x7C);
+			audio_aic32_write(REGISTER_ADDR22, 0x7C);
+
+		} else if (val == SOUND_MASK_LINE) {
+			/* enable ADC's, enable line iput */
+			DPRINTK(" Enabling line in\n");
+			audio_aic32_write(REGISTER_ADDR19, 0x4);
+			audio_aic32_write(REGISTER_ADDR22, 0x4);
+
+			/* disable the mic input */
+			audio_aic32_write(REGISTER_ADDR17, 0xff);
+			audio_aic32_write(REGISTER_ADDR18, 0xff);
+		} else {
+			/* do nothing */
+		}
+		aic32_local.recsrc = val;
+		break;
+
+	case SET_IGAIN:
+		left_val = val & 0xFF;
+		right_val = val >> 8;
+
+		if (left_val < 0 || left_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
+			return -EPERM;
+		}
+		if (right_val < 0 || right_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
+			return -EPERM;
+		}
+
+		left_gain = ((left_val * INPUT_GAIN_RANGE) / 100) +
+			INPUT_GAIN_MIN;
+		right_gain = ((right_val * INPUT_GAIN_RANGE) / 100) +
+			INPUT_GAIN_MIN;
+
+		DPRINTK("left gain reg val = 0x%x", left_gain << 1);
+		DPRINTK("right gain reg val = 0x%x", left_gain << 1);
+
+		/* Left AGC control */
+		audio_aic32_write(REGISTER_ADDR26, 0x80);
+		audio_aic32_write(REGISTER_ADDR27, left_gain << 1);
+		audio_aic32_write(REGISTER_ADDR28, 0x0);
+
+		/* Right AGC control */
+		audio_aic32_write(REGISTER_ADDR29, 0x80);
+		audio_aic32_write(REGISTER_ADDR30, right_gain << 1);
+		audio_aic32_write(REGISTER_ADDR31, 0x0);
+
+		break;
+
+	case SET_OGAIN:
+		left_val = val & 0xFF;
+		right_val = val >> 8;
+
+		if (left_val < 0 || left_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", left_val);
+			return -EPERM;
+		}
+		if (right_val < 0 || right_val > 100) {
+			DPRINTK("Trying a bad igain value(%d)!\n", right_val);
+			return -EPERM;
+		}
+
+		left_gain = ((left_val * OUTPUT_GAIN_RANGE) / 100) +
+			OUTPUT_GAIN_MIN;
+		left_gain = OUTPUT_GAIN_MAX - left_gain;
+		right_gain = ((right_val * OUTPUT_GAIN_RANGE) / 100) +
+			OUTPUT_GAIN_MIN;
+		right_gain = OUTPUT_GAIN_MAX - right_gain;
+
+		/* Left/Right DAC digital volume gain */
+		audio_aic32_write(REGISTER_ADDR43, left_gain);
+		audio_aic32_write(REGISTER_ADDR44, right_gain);
+		break;
+
+	case SET_MICBIAS:
+		/* Ignore separate left/right channel for now, even the codec
+		   does support it. */
+
+		val &= 0xff;
+
+		if (val < 0 || val > 3) {
+			DPRINTK
+			    ("Request for non supported mic bias level(%d)!\n",
+			     val);
+			return -EPERM;
+		}
+
+		if (val == 0)
+			audio_aic32_write(REGISTER_ADDR25, 0x00);
+
+		else if (val == 1)
+			audio_aic32_write(REGISTER_ADDR25, MICBIAS_OUTPUT_2_0V);
+
+		else if (val == 2)
+			audio_aic32_write(REGISTER_ADDR25, MICBIAS_OUTPUT_2_5V);
+
+		else if (val == 3)
+			audio_aic32_write(REGISTER_ADDR25, MICBIAS_OUTPUT_AVDD);
+
+		break;
+
+	case SET_BASS:
+		break;
+
+	case SET_TREBLE:
+		break;
+	}
+	FN_OUT;
+
+	return 0;
+}
+
+static int mixer_open(struct inode *inode, struct file *file)
+{
+	    /* Any mixer specific initialization */
+	return 0;
+}
+
+static int mixer_release(struct inode *inode, struct file *file)
+{
+	    /* Any mixer specific Un-initialization */
+	return 0;
+}
+
+static int mixer_ioctl(struct inode *inode, struct file *file, uint cmd, ulong
+		       arg)
+{
+	int val;
+	int ret = 0;
+	int nr = _IOC_NR(cmd);
+
+	/*
+	 * We only accept mixer (type 'M') ioctls.
+	 */
+	FN_IN;
+
+	if (_IOC_TYPE(cmd) != 'M')
+		return -EINVAL;
+
+	DPRINTK(" 0x%08x\n", cmd);
+
+	if (cmd == SOUND_MIXER_INFO) {
+		struct mixer_info mi;
+
+		strncpy(mi.id, "AIC32", sizeof(mi.id));
+		strncpy(mi.name, "TI AIC32", sizeof(mi.name));
+		mi.modify_counter = aic32_local.mod_cnt;
+
+		return copy_to_user((void *)arg, &mi, sizeof(mi));
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		ret = get_user(val, (int *)arg);
+		if (ret)
+			goto out;
+
+		switch (nr) {
+		case SOUND_MIXER_VOLUME:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_VOLUME, val);
+			if (!ret)
+				aic32_local.volume = val;
+			break;
+
+		case SOUND_MIXER_LINE:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_LINE, val);
+			if (!ret)
+				aic32_local.line = val;
+			break;
+
+		case SOUND_MIXER_MIC:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_MIC, val);
+			if (!ret)
+				aic32_local.mic = val;
+			break;
+
+		case SOUND_MIXER_RECSRC:
+			if ((val & SOUND_MASK_LINE) ||
+			    (val & SOUND_MASK_MIC)) {
+				if (aic32_local.recsrc != val) {
+					aic32_local.mod_cnt++;
+					aic32_update(SET_RECSRC, val);
+				}
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+
+		case SOUND_MIXER_BASS:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_BASS, val);
+			if (!ret)
+				aic32_local.bass = val;
+			break;
+
+		case SOUND_MIXER_TREBLE:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_TREBLE, val);
+			if (!ret)
+				aic32_local.treble = val;
+			break;
+
+		case SOUND_MIXER_IGAIN:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_IGAIN, val);
+			if (!ret)
+				aic32_local.igain = val;
+			break;
+
+		case SOUND_MIXER_OGAIN:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_OGAIN, val);
+			if (!ret)
+				aic32_local.ogain = val;
+			break;
+
+		case SOUND_MIXER_MICBIAS:
+			aic32_local.mod_cnt++;
+			ret = aic32_update(SET_MICBIAS, val);
+			if (!ret)
+				aic32_local.micbias = val;
+			break;
+
+		default:
+			ret = -EINVAL;
+		}
+	}
+
+	if (ret == 0 && _IOC_DIR(cmd) & _IOC_READ) {
+		ret = 0;
+
+		switch (nr) {
+		case SOUND_MIXER_VOLUME:
+			val = aic32_local.volume;
+			break;
+		case SOUND_MIXER_LINE:
+			val = aic32_local.line;
+			break;
+		case SOUND_MIXER_MIC:
+			val = aic32_local.mic;
+			break;
+		case SOUND_MIXER_RECSRC:
+			val = aic32_local.recsrc;
+			break;
+		case SOUND_MIXER_RECMASK:
+			val = REC_MASK;
+			break;
+		case SOUND_MIXER_IGAIN:
+			val = aic32_local.igain;
+			break;
+		case SOUND_MIXER_OGAIN:
+			val = aic32_local.ogain;
+			break;
+		case SOUND_MIXER_DEVMASK:
+			val = DEV_MASK;
+			break;
+		case SOUND_MIXER_BASS:
+			val = aic32_local.bass;
+			break;
+		case SOUND_MIXER_TREBLE:
+			val = aic32_local.treble;
+			break;
+		case SOUND_MIXER_CAPS:
+			val = 0;
+			break;
+		case SOUND_MIXER_STEREODEVS:
+			val = SOUND_MASK_VOLUME;
+			break;
+		case SOUND_MIXER_MICBIAS:
+			val = aic32_local.micbias;
+			break;
+		default:
+			val = 0;
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret == 0)
+			ret = put_user(val, (int *)arg);
+	}
+out:
+	FN_OUT;
+	return ret;
+}
+
+int davinci_set_samplerate(long sample_rate)
+{
+	u8 count = 0;
+
+	FN_IN;
+
+	/* wait for any frame to complete */
+	udelay(125);
+
+	/* Search for the right sample rate */
+	while ((reg_info[count].sample_rate != sample_rate) &&
+	       (count < NUMBER_SAMPLE_RATES_SUPPORTED)) {
+
+		    /* Issue an info to the user if the requested sample rate is
+		       not exactly equal to whats supported, but quite close.*/
+	    if (abs(sample_rate-reg_info[count].sample_rate) <= 5) {
+		    printk(KERN_INFO "Nearest supported sampling rate is %d. \
+					You might consider using this.\n",
+		       reg_info[count].sample_rate);
+	    }
+
+	    count++;
+	}
+
+	if (count == NUMBER_SAMPLE_RATES_SUPPORTED) {
+		DPRINTK("Invalid Sample Rate %d requested\n", (int)sample_rate);
+		return -EPERM;
+	}
+
+	/*   CODEC DATAPATH SETUP  */
+
+	/* Fsref to 48kHz, dual rate mode upto 96kHz */
+	if (reg_info[count].Fsref == 96000)
+		audio_aic32_write(REGISTER_ADDR7,
+				  FS_REF_DEFAULT_48 | ADC_DUAL_RATE_MODE |
+				  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 44.1kHz, dual rate mode upto 88.2kHz */
+	else if (reg_info[count].Fsref == 88200)
+		audio_aic32_write(REGISTER_ADDR7,
+				  FS_REF_44_1 | ADC_DUAL_RATE_MODE |
+				  DAC_DUAL_RATE_MODE | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 48kHz */
+	else if (reg_info[count].Fsref == 48000)
+		audio_aic32_write(REGISTER_ADDR7,
+				  FS_REF_DEFAULT_48 | LDAC_LCHAN | RDAC_RCHAN);
+
+	/* Fsref to 44.1kHz */
+	else if (reg_info[count].Fsref == 44100)
+		audio_aic32_write(REGISTER_ADDR7, FS_REF_44_1 | LDAC_LCHAN |
+				  RDAC_RCHAN);
+
+	/* Codec sample rate select */
+	audio_aic32_write(REGISTER_ADDR2, reg_info[count].data);
+
+	/* If PLL is to be used for generation of Fsref
+	   Generate the Fsref using the PLL */
+
+	if ((reg_info[count].Fsref == 96000) |
+	    (reg_info[count].Fsref == 48000)) {
+		    /* For MCLK = 27 MHz and to get Fsref = 48kHz
+		       Fsref = (MCLK * k * R)/(2048 * p);
+		       Select P = 2, R= 1, K = 7.2817, which results in J = 7, D
+		       = 2817 */
+
+		    /*Enable the PLL | Q-value | P-value */
+	    audio_aic32_write(REGISTER_ADDR3, PLL_ENABLE | 0x10 | 0x02);
+	    audio_aic32_write(REGISTER_ADDR4, 0x1C);	/* J-value */
+	    audio_aic32_write(REGISTER_ADDR5, 0x2C);	/* D-value 8-MSB's */
+	    audio_aic32_write(REGISTER_ADDR6, 0x01);	/* D-value 6-LSB's */
+	} else if ((reg_info[count].Fsref == 88200)
+		   | (reg_info[count].Fsref == 44100)) {
+
+		    /* MCLK = 27 MHz and to get Fsref = 44.1kHz
+		       Fsref = (MCLK * k * R)/(2048 * p);
+		       Select P = 2, R =1, K = 6.6901, which results in J = 6, D
+		       = 6901 */
+
+		    /*Enable the PLL | Q-value | P-value */
+	    audio_aic32_write(REGISTER_ADDR3, PLL_ENABLE | 0x10 | 0x02);
+	    audio_aic32_write(REGISTER_ADDR4, 0x18);	/* J-value */
+	    audio_aic32_write(REGISTER_ADDR5, 0x6B);	/* D-value 8-MSB's */
+	    audio_aic32_write(REGISTER_ADDR6, 0x35);	/* D-value 6-LSB's */
+	}
+
+	audio_samplerate = sample_rate;
+
+	FN_OUT;
+	return 0;
+}
+
+static void davinci_set_mono_stereo(int mode)
+{
+    FN_IN;
+	if (mode == MONO) {
+
+#ifdef CONFIG_MONOSTEREO_DIFFJACK
+		/* MONO_LOP/M Output level control register */
+		audio_aic32_write(REGISTER_ADDR79, 0x99);
+#else
+		/* Driver power ON pop control */
+		audio_aic32_write(REGISTER_ADDR42, 0x6C);
+
+		/* HPLOUT/HPROUT output level control */
+		audio_aic32_write(REGISTER_ADDR51, 0x99);
+		audio_aic32_write(REGISTER_ADDR65, 0x99);
+
+		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
+		audio_aic32_write(REGISTER_ADDR86, 0x99);
+		audio_aic32_write(REGISTER_ADDR93, 0x99);
+#endif
+		/* Left DAC power up, Right DAC power down */
+		audio_aic32_write(REGISTER_ADDR37, 0xa0);
+	} else if (mode == STEREO) {
+		/* Driver power ON pop control */
+		audio_aic32_write(REGISTER_ADDR42, 0x6C);
+
+		/* HPLOUT/HPROUT output level control */
+		audio_aic32_write(REGISTER_ADDR51, 0x99);
+		audio_aic32_write(REGISTER_ADDR65, 0x99);
+
+		/* LEFT_LOP/M, RIGHT_LOP/M output level control */
+		audio_aic32_write(REGISTER_ADDR86, 0x99);
+		audio_aic32_write(REGISTER_ADDR93, 0x99);
+
+		/* Left/Right DAC power up */
+		audio_aic32_write(REGISTER_ADDR37, 0xe0);
+	} else
+		DPRINTK(" REQUEST FOR INVALID MODE\n");
+
+	FN_OUT;
+}
+
+/* Select the desired mode. Define any one of the following.*/
+#define AIC32_I2S_MODE              1
+/* #define AIC32_RIGHT_JUSTIFIED_MODE  1 */
+/* #define AIC32_LEFT_JUSTIFIED_MODE   1 */
+
+static inline void aic32_configure(audio_config_t *audio_cfg)
+{
+    FN_IN;
+
+    DPRINTK(" CONFIGURING AIC32\n");
+
+	    /* Page select register */
+    audio_aic32_write(REGISTER_ADDR0, 0x0);
+
+    /* audio_aic32_write(REGISTER_ADDR38, 0x10); */
+
+    davinci_set_mono_stereo(aic32_local.nochan);
+
+    if (audio_cfg->mode == CODEC_IS_MASTER) {
+		/* Enable bit and word clock as Master mode, 3-d disabled */
+	audio_aic32_write(REGISTER_ADDR8, 0xc0 /*0xc4 */ );
+		/* Enabling 3d generates shrill noise */
+    } else {
+		/* Enable bit and word clock as slave mode, 3-d disabled */
+	audio_aic32_write(REGISTER_ADDR8, 0x00);
+	audio_aic32_write(REGISTER_ADDR102, 0xA2);
+    }
+
+    switch (audio_cfg->tdm_slots) {
+    default:
+    case 0:
+	    audio_aic32_write(REGISTER_ADDR9, 0x40);	/* DSP Mode */
+	    break;
+
+    case 2:
+#ifdef AIC32_I2S_MODE
+	    audio_aic32_write(REGISTER_ADDR9, 0x00); /* I2S Mode */
+#endif /* AIC32_I2S_MODE */
+#ifdef AIC32_RIGHT_JUSTIFIED_MODE
+	    /* Right Justified Mode  */
+	    audio_aic32_write(REGISTER_ADDR9, 0x80);
+#endif /* AIC32_RIGHT_JUSTIFIED_MODE */
+#ifdef AIC32_LEFT_JUSTIFIED_MODE
+	    /* Left Justified Mode */
+	    audio_aic32_write(REGISTER_ADDR9, 0xC0);
+#endif /* AIC32_LEFT_JUSTIFIED_MODE */
+	    break;
+    }
+
+    aic32_update(SET_LINE, aic32_local.line);
+    aic32_update(SET_VOLUME, aic32_local.volume);
+    aic32_update(SET_RECSRC, aic32_local.recsrc);
+    aic32_update(SET_IGAIN, aic32_local.igain);
+    aic32_update(SET_OGAIN, aic32_local.ogain);
+    aic32_update(SET_MICBIAS, aic32_local.micbias);
+    FN_OUT;
+}
+
+static void davinci_aic32_initialize(void *dummy)
+{
+	FN_IN;
+
+	DPRINTK("entry\n");
+
+	/* initialize with default sample rate */
+	audio_samplerate = AUDIO_RATE_DEFAULT;
+
+	/* set initial (default) sample rate */
+	davinci_set_samplerate(audio_samplerate);
+
+	FN_OUT;
+
+	DPRINTK("exit\n");
+}
+
+int davinci_aic32_ioctl(struct inode *inode, struct file *file, uint cmd, ulong
+			arg)
+{
+	long val;
+	int ret = 0;
+
+	FN_IN;
+
+	/*
+	 * These are platform dependent ioctls which are not handled by the
+	 * generic davinci-audio module.
+	 */
+	switch (cmd) {
+	case SNDCTL_DSP_STEREO:
+		ret = get_user(val, (int *)arg);
+		if (ret)
+			return ret;
+		/* the Davinci supports AIC32 as stereo, mono on stereo jack */
+		ret = (val == 0) ? -EINVAL : 1;
+		return put_user(ret, (int *)arg);
+
+	case SNDCTL_DSP_CHANNELS:
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		if (val == STEREO) {
+			DPRINTK("Driver support for AIC32 as stereo\n");
+			aic32_local.nochan = STEREO;
+			davinci_set_mono_stereo(aic32_local.nochan);
+		} else if (val == MONO) {
+			DPRINTK("Driver support for AIC32 as mono\n");
+			aic32_local.nochan = MONO;
+			davinci_set_mono_stereo(aic32_local.nochan);
+		} else {
+			DPRINTK
+			    ("Driver support for AIC32 as stereo/mono mode\n");
+			return -EPERM;
+		}
+
+	case SOUND_PCM_READ_CHANNELS:
+		/* the Davinci supports AIC32 as stereo, mono on stereo jack */
+		if (aic32_local.nochan == MONO)
+			return put_user(MONO, (long *)arg);
+		else
+			return put_user(STEREO, (long *)arg);
+
+	case SNDCTL_DSP_SPEED:
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		ret = davinci_set_samplerate(val);
+		if (ret) {
+			DPRINTK("davinci_set_samplerate failed\n");
+			break;
+		}
+		/* fall through */
+
+	case SOUND_PCM_READ_RATE:
+		return put_user(audio_samplerate, (long *)arg);
+
+	case SNDCTL_DSP_SETFMT:	/* set Format */
+		ret = get_user(val, (long *)arg);
+		if (ret) {
+			DPRINTK("get_user failed\n");
+			break;
+		}
+		if (val != AFMT_S16_LE) {
+			DPRINTK
+			    ("Driver supports only AFMT_S16_LE audio format\n");
+			return -EPERM;
+		}
+		break;
+
+	case SOUND_PCM_READ_BITS:
+	case SNDCTL_DSP_GETFMTS:
+		/* we can do 16-bit only */
+		return put_user(AFMT_S16_LE, (long *)arg);
+
+	default:
+		/* Maybe this is meant for the mixer (As per OSS Docs) */
+		return mixer_ioctl(inode, file, cmd, arg);
+	}
+	FN_OUT;
+
+	return ret;
+}
+EXPORT_SYMBOL(davinci_aic32_ioctl);
Index: linux-2.6.10/sound/oss/dm646x/davinci-audio-dma-intfc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/davinci-audio-dma-intfc.c
@@ -0,0 +1,1164 @@
+/*
+ * linux/sound/oss/davinci-audio-dma-intfc.c
+ *
+ * Common audio DMA handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2004-06-07   Sriram Kannan   - Created new file from
+ *                                omap_audio_dma_intfc.c. This file will contain
+ *                                only the DMA interface and buffer handling of
+ *                                OMAP audio driver.
+ *
+ * 2004-06-22   Sriram Kannan   - removed legacy code (auto-init). Self-linking
+ *                                of DMA logical channel.
+ *
+ * 2004-08-12   Nishanth Menon  - Modified to integrate Audio requirements on
+ *                                1610,1710 platforms
+ *
+ * 2004-11-01   Nishanth Menon  - 16xx platform code base modified to support
+ *                                multi channel chaining.
+ *
+ * 2004-12-15   Nishanth Menon  - Improved 16xx platform channel logic
+ *                                introduced - tasklets, queue handling updated
+ *
+ * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI
+ *                                                   Davinci DM644x processor
+ *
+ * 2007-07-06   Nirmal Pandey, Suresh Rajashekara - Included new sound driver
+ *                                                  arch (to support multiple
+ *                                                  ASP types and codec types)
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/pm.h>
+#include <linux/errno.h>
+#include <linux/sound.h>
+#include <linux/soundcard.h>
+#include <linux/sysrq.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/semaphore.h>
+#include <asm/delay.h>
+
+#include <asm/arch/mcasp.h>
+
+#include "davinci-audio-dma-intfc.h"
+#include "audio_controller.h"
+#include <asm/arch/evm_audio_info.h>
+
+#include <asm/arch/edma.h>
+#include <asm/arch/memory.h>
+
+#undef DEBUG
+/* #define DEBUG */
+#ifdef DEBUG
+#define DPRINTK(ARGS...)  do {\
+				printk(KERN_INFO "<%s>: ", __FUNCTION__);\
+				printk(KERN_INFO ARGS);\
+			} while (0)
+#define FN_IN printk(KERN_INFO "[%s]: start\n", __FUNCTION__)
+#define FN_OUT(n) printk(KERN_INFO "[%s]: end(%u)\n", __FUNCTION__, n)
+#else
+
+#define DPRINTK( x... )
+#define FN_IN
+#define FN_OUT(x)
+#endif
+
+#define ERR(ARGS...) do {\
+			printk(KERN_ERR "{%s}-ERROR: ", __FUNCTION__);\
+			printk(KERN_ERR ARGS);\
+			} while (0)
+
+#define AUDIO_NAME  "davinci-hd-audio"
+
+#define AUDIO_ACTIVE(state)     ((state)->rd_ref || (state)->wr_ref)
+
+#define SPIN_ADDR                    (dma_addr_t)0
+#define SPIN_SIZE                    2048
+
+#define NUMBER_OF_CHANNELS_TO_LINK  2
+
+/* Channel Queue Handling macros
+ * tail always points to the current free entry
+ * Head always points to the current entry being used
+ * end is either head or tail
+ */
+#define AUDIO_QUEUE_INIT(s) s->dma_q_head = s->dma_q_tail = s->dma_q_count = 0;
+#define AUDIO_QUEUE_FULL(s) (NUMBER_OF_CHANNELS_TO_LINK == s->dma_q_count)
+#define AUDIO_QUEUE_LAST(s) (1 == s->dma_q_count)
+#define AUDIO_QUEUE_EMPTY(s) (0 == s->dma_q_count)
+#define __AUDIO_INCREMENT_QUEUE(end) \
+	((end) = ((end)+1)%NUMBER_OF_CHANNELS_TO_LINK)
+#define AUDIO_INCREMENT_HEAD(s) do {\
+				__AUDIO_INCREMENT_QUEUE(s->dma_q_head);\
+							s->dma_q_count--;\
+				} while (0)
+#define AUDIO_INCREMENT_TAIL(s) do {\
+				__AUDIO_INCREMENT_QUEUE(s->dma_q_tail);\
+							s->dma_q_count++;\
+				} while (0)
+/* DMA buffer fragmentation sizes */
+#define MAX_DMA_SIZE         (0xffff*2)
+#define CUT_DMA_SIZE         MAX_DMA_SIZE
+
+/**************************** DATA STRUCTURES *********************************/
+
+struct audio_isr_work_item {
+	int current_lch;
+	u16 ch_status;
+	audio_stream_t *s;
+};
+
+static char work_item_running;
+static struct audio_isr_work_item work1, work2;
+
+extern int acount;
+/*********************** MODULE SPECIFIC FUNCTIONS PROTOTYPES ****************/
+
+static void audio_dsr_handler(unsigned long);
+DECLARE_TASKLET(audio_isr_work1, audio_dsr_handler, (unsigned long)&work1);
+DECLARE_TASKLET(audio_isr_work2, audio_dsr_handler, (unsigned long)&work2);
+
+static void sound_dma_irq_handler(int lch, u16 ch_status, void *data);
+static void audio_dma_callback(int lch, u16 ch_status, void *data);
+static int davinci_start_sound_dma(audio_stream_t *s, dma_addr_t dma_ptr,
+				   u_int size);
+static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
+				     u_int dma_size, unsigned long dma_addr);
+static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
+					u_int dma_size, unsigned long dma_addr);
+static int audio_start_dma_chain(audio_stream_t *s);
+
+/************************** GLOBAL FUNCTIONS DEFINTIONS ***********************/
+
+/*******************************************************************************
+ *
+ * Buffer creation/destruction
+ *
+ ******************************************************************************/
+int audio_setup_buf(audio_stream_t *s)
+{
+	int frag;
+	int dmasize = 0;
+	char *dmabuf = NULL;
+	dma_addr_t dmaphys = 0;
+	FN_IN;
+
+	if (s->buffers) {
+		FN_OUT(1);
+		return -EBUSY;
+	}
+
+	/* Allocate memory for all buffer fragments */
+	s->buffers = kmalloc(sizeof(audio_buf_t) * s->nbfrags, GFP_KERNEL);
+	if (!s->buffers)
+		goto err;
+
+	/* Initialise all the memory to 0 */
+	memset(s->buffers, 0, sizeof(audio_buf_t) * s->nbfrags);
+
+	for (frag = 0; frag < s->nbfrags; frag++) {
+		audio_buf_t *b = &s->buffers[frag];
+
+		/*
+		 * Let's allocate non-cached memory for DMA buffers.
+		 * We try to allocate all memory at once.
+		 * If this fails (a common reason is memory fragmentation),
+		 * then we allocate more smaller buffers.
+		 */
+		if (!dmasize) {
+			dmasize = (s->nbfrags - frag) * s->fragsize;
+			do {
+				/* allocate consistent memory for DMA
+				   dmaphys(handle)= device viewed address.
+				   dmabuf = CPU-viewed address */
+				dmabuf =
+				    dma_alloc_coherent(NULL, dmasize, &dmaphys,
+						       0);
+
+				/* For allocating the IRAM memory */
+				/*
+				   dmaphys =
+				   (dma_addr_t)(DAVINCI_IRAM_BASE + 0x1000);
+				   dmabuf = (DAVINCI_IRAM_VIRT + 0x1000);
+				*/
+				if (!dmabuf)
+					dmasize -= s->fragsize;
+			}
+			while (!dmabuf && dmasize);
+
+			if (!dmabuf)
+				goto err;
+
+			b->master = dmasize;
+			memzero(dmabuf, dmasize);
+		}
+		b->data = dmabuf;
+		b->dma_addr = dmaphys;
+		dmabuf += s->fragsize;
+		dmaphys += s->fragsize;
+		dmasize -= s->fragsize;
+	}
+	s->usr_head = s->dma_head = s->dma_tail = 0;
+	AUDIO_QUEUE_INIT(s);
+	s->started = 0;
+	s->asp_tx_started = 0;
+	s->asp_rx_started = 0;
+	atomic_set(&s->playing_null, 0);
+	s->dma_started = 0;
+	s->bytecount = 0;
+	s->fragcount = 0;
+	s->prevbuf = 0;
+
+	init_completion(&s->wfc);
+	s->wfc.done = s->nbfrags;
+
+	FN_OUT(0);
+	return 0;
+err:
+	audio_discard_buf(s);
+	FN_OUT(1);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(audio_setup_buf);
+
+void audio_discard_buf(audio_stream_t *s)
+{
+	FN_IN;
+	/* ensure DMA isn't using those buffers */
+	audio_reset(s);
+	if (s->buffers) {
+		int frag;
+		for (frag = 0; frag < s->nbfrags; frag++) {
+			if (!s->buffers[frag].master)
+				continue;
+
+			dma_free_coherent(NULL,
+					  s->buffers[frag].master,
+					  s->buffers[frag].data,
+					  s->buffers[frag].dma_addr);
+
+		}
+		kfree(s->buffers);
+		s->buffers = NULL;
+	}
+	FN_OUT(0);
+}
+EXPORT_SYMBOL(audio_discard_buf);
+
+/*******************************************************************************
+ *
+ * DMA channel requests
+ *
+ ******************************************************************************/
+
+	/* FIXME: Move */
+#define NULL_FRAGSIZE (1024)
+static char null_buffer[NULL_FRAGSIZE];
+
+int davinci_request_sound_dma(int device_id, const char *device_name, void
+			      *data, int *master_ch, int **channels)
+{
+	int i, err = 0;
+	int *chan = NULL;
+	int tcc;
+	audio_stream_t *stream = (audio_stream_t *)data;
+	unsigned long dma_addr;
+	edmacc_paramentry_regs temp;
+
+	FN_IN;
+	if (unlikely((NULL == channels) || (NULL == device_name))) {
+		BUG();
+		return -EPERM;
+	}
+	/* Try allocate memory for the num channels */
+	*channels = (int *)kmalloc(sizeof(int) * NUMBER_OF_CHANNELS_TO_LINK,
+				   GFP_KERNEL);
+	chan = *channels;
+	if (NULL == chan) {
+		ERR("No Memory for channel allocs!\n");
+		FN_OUT(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	/* request for the Master channel and setup the params */
+	i = 0;
+	err = davinci_request_dma(device_id, device_name,
+				  sound_dma_irq_handler, data, master_ch, &tcc,
+				  EVENTQ_2);
+
+	/* Handle Failure condition here */
+	if (err < 0) {
+		ERR("Error in requesting Master channel %d = 0x%x\n", device_id,
+		    err);
+
+		FN_OUT(err);
+		return err;
+
+	}
+
+	DPRINTK("Master chan = %d\n", *master_ch);
+
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		err = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, device_name,
+					  sound_dma_irq_handler, data, &chan[i],
+					  &tcc, EVENTQ_2);
+
+		/* Handle Failure condition here */
+		if (err < 0) {
+			int j;
+
+			for (j = 0; j < i; j++)
+				davinci_free_dma(chan[j]);
+
+			kfree(chan);
+			*channels = NULL;
+			ERR("Error in requesting channel %d=0x%x\n", i, err);
+			FN_OUT(err);
+			return err;
+		}
+	}
+
+	/* Chain the channels together */
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		int cur_chan = chan[i];
+		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 ==
+				 i) ? chan[0] : chan[i + 1]);
+		davinci_dma_link_lch(cur_chan, nex_chan);
+	}
+
+		/* For playing NULL, when no data is given by the userspace */
+	if ( stream->input_or_output == FMODE_WRITE ) {
+	    err = davinci_request_dma(DAVINCI_EDMA_PARAM_ANY, device_name,
+				      sound_dma_irq_handler, data,
+				      &stream->null_lch, &tcc, EVENTQ_2);
+
+		    /* Handle Failure condition here */
+	    if (err < 0) {
+		int j;
+
+		for (j = 0; j < i; j++)
+		    davinci_free_dma(chan[j]);
+
+		kfree(chan);
+		*channels = NULL;
+		ERR("Error in requesting NULL channel\n");
+		FN_OUT(err);
+		return err;
+	    }
+
+	    memset(null_buffer, 0, NULL_FRAGSIZE);
+	    davinci_dma_link_lch(stream->null_lch, stream->null_lch);
+	    dma_addr = get_tx_dma_dest_address (stream->device_instance);
+	    audio_set_dma_params_play (stream->null_lch
+				       , (dma_addr_t)null_buffer,
+				       NULL_FRAGSIZE, dma_addr);
+
+		    /* Disable interrupts for the null buffer */
+	    davinci_get_dma_params(stream->null_lch, &temp);
+	    temp.opt = (temp.opt & 0xFFEFFFFF);
+	    davinci_set_dma_params(stream->null_lch, &temp);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_request_sound_dma);
+
+/******************************************************************************
+ *
+ * DMA channel requests Freeing
+ *
+ ******************************************************************************/
+int davinci_free_sound_dma(int master_ch, int **channels, void *data)
+{
+	int i;
+	int *chan = NULL;
+	audio_stream_t *stream = (audio_stream_t *)data;
+
+	FN_IN;
+	if (unlikely(NULL == channels)) {
+		BUG();
+		return -EPERM;
+	}
+	if (unlikely(NULL == *channels)) {
+		BUG();
+		return -EPERM;
+	}
+	chan = (*channels);
+
+	/* release the Master channel */
+	davinci_free_dma(master_ch);
+
+	for (i = 0; i < NUMBER_OF_CHANNELS_TO_LINK; i++) {
+		int cur_chan = chan[i];
+		int nex_chan = ((NUMBER_OF_CHANNELS_TO_LINK - 1 == i) ?
+				chan[0] : chan[i + 1]);
+
+		davinci_dma_unlink_lch(cur_chan, nex_chan);
+		davinci_free_dma(cur_chan);
+	}
+	kfree(*channels);
+	*channels = NULL;
+
+	if ( stream->input_or_output == FMODE_WRITE ) {
+	    davinci_free_dma(stream->null_lch);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_free_sound_dma);
+
+/*******************************************************************************
+ *
+ * Process DMA requests - This will end up starting the transfer.
+ * Proper fragments of Transfers will be initiated.
+ *
+ ******************************************************************************/
+int audio_process_dma(audio_stream_t *s)
+{
+	int ret = 0;
+	unsigned long flags;
+	FN_IN;
+
+	/* Dont let the ISR over ride touching the in_use flag */
+	local_irq_save(flags);
+	if (1 == s->in_use) {
+		local_irq_restore(flags);
+		DPRINTK("Called again while In Use\n");
+		return 0;
+	}
+	s->in_use = 1;
+	local_irq_restore(flags);
+
+	if (s->stopped)
+		goto spin;
+
+	if (s->dma_spinref > 0 && s->pending_frags) {
+		s->dma_spinref = 0;
+		DMA_CLEAR(s);
+	}
+
+	while (s->pending_frags) {
+		audio_buf_t *b = &s->buffers[s->dma_head];
+		u_int dma_size = s->fragsize - b->offset;
+
+		if (dma_size > MAX_DMA_SIZE) {
+			DPRINTK("dma_size > MAX_DMA_SIZE\n");
+			dma_size = CUT_DMA_SIZE;
+		}
+
+		ret = davinci_start_sound_dma(s, b->dma_addr + b->offset,
+					      dma_size);
+		if (ret) {
+			DPRINTK("error\n");
+			goto process_out;
+		}
+
+		b->dma_ref++;
+		b->offset += dma_size;
+		if (b->offset >= s->fragsize) {
+			s->pending_frags--;
+			if (++s->dma_head >= s->nbfrags)
+				s->dma_head = 0;
+		}
+	}
+spin:
+	if (s->spin_idle) {
+		int spincnt = 0;
+		DPRINTK("we are spinning\n");
+		while (davinci_start_sound_dma(s, SPIN_ADDR, SPIN_SIZE) == 0)
+			spincnt++;
+		/*
+		 * Note: if there is still a data buffer being
+		 * processed then the ref count is negative.  This
+		 * allows for the DMA termination to be accounted in
+		 * the proper order.  Of course dma_spinref can't be
+		 * greater than 0 if dma_ref is not 0 since we kill
+		 * the spinning above as soon as there is real data to process.
+		 */
+		if (s->buffers && s->buffers[s->dma_tail].dma_ref)
+			spincnt = -spincnt;
+		s->dma_spinref += spincnt;
+	}
+
+process_out:
+	s->in_use = 0;
+
+	FN_OUT(ret);
+	return ret;
+}
+EXPORT_SYMBOL(audio_process_dma);
+
+/*******************************************************************************
+ *
+ * Prime Rx - Since the recieve buffer has no time limit as to when it would
+ *            arrive, we need to prime it
+ *
+ ******************************************************************************/
+void audio_prime_rx(audio_state_t *state)
+{
+	audio_stream_t *is = state->input_stream;
+
+	FN_IN;
+	if (state->need_tx_for_rx) {
+		/*
+		 * With some codecs like the Philips UDA1341 we must ensure
+		 * there is an output stream at any time while recording since
+		 * this is how the UDA1341 gets its clock from the SA1100.
+		 * So while there is no playback data to send, the output DMA
+		 * will spin with all zeroes.  We use the cache flush special
+		 * area for that.
+		 */
+		state->output_stream->spin_idle = 1;
+		audio_process_dma(state->output_stream);
+	}
+	is->pending_frags = is->nbfrags;
+
+	init_completion(&is->wfc);
+	is->wfc.done = 0;
+
+	is->active = 1;
+	audio_process_dma(is);
+
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_prime_rx);
+
+/*******************************************************************************
+ *
+ * set the fragment size
+ *
+ ******************************************************************************/
+int audio_set_fragments(audio_stream_t *s, int val)
+{
+	FN_IN;
+
+	if (s->active)
+		return -EBUSY;
+	if (s->buffers)
+		audio_discard_buf(s);
+
+	s->nbfrags = (val >> 16) & 0x7FFF;
+	val &= 0xFFFF;
+
+	if (val < 4)
+		val = 4;
+	if (val > 15)
+		val = 15;
+
+	s->fragsize = 1 << val;
+	if (s->nbfrags < 2)
+		s->nbfrags = 2;
+	if (s->nbfrags * s->fragsize > 128 * 1024)
+		s->nbfrags = 128 * 1024 / s->fragsize;
+	FN_OUT(0);
+	if (audio_setup_buf(s))
+		return -ENOMEM;
+	return val | (s->nbfrags << 16);
+}
+EXPORT_SYMBOL(audio_set_fragments);
+
+/*******************************************************************************
+ *
+ * Sync up the buffers before we shutdown, else under-run errors will happen
+ *
+ ******************************************************************************/
+int audio_sync(struct file *file)
+{
+	audio_state_t *state = file->private_data;
+	audio_stream_t *s = state->output_stream;
+	audio_buf_t *b;
+	u_int shiftval = 0;
+	unsigned long flags;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	FN_IN;
+
+	if (!(file->f_mode & FMODE_WRITE) || !s->buffers || s->mapped) {
+		FN_OUT(1);
+		return 0;
+	}
+
+	/*
+	 * Send current buffer if it contains data.  Be sure to send
+	 * a full sample count.
+	 */
+	b = &s->buffers[s->usr_head];
+	mdelay(20);
+
+	b->offset &= ~3;
+
+	if (b->offset) {
+		/*wait for a buffer to become free */
+		if (wait_for_completion_interruptible(&s->wfc))
+			return 0;
+		/*
+		 * HACK ALERT !
+		 * To avoid increased complexity in the rest of the code
+		 * where full fragment sizes are assumed, we cheat a little
+		 * with the start pointer here and don't forget to restore
+		 * it later.
+		 */
+		shiftval = s->fragsize - b->offset;
+		b->offset = shiftval;
+		b->dma_addr -= shiftval;
+		b->data -= shiftval;
+		local_irq_save(flags);
+		s->bytecount -= shiftval;
+		if (++s->usr_head >= s->nbfrags)
+			s->usr_head = 0;
+
+		s->pending_frags++;
+
+		atomic_set(&s->syncing, 1);
+		audio_process_dma(s);
+		atomic_set(&s->syncing, 0);
+		local_irq_restore(flags);
+	}
+
+	/* Let's wait for all buffers to complete */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&s->wq, &wait);
+
+	while ((s->pending_frags || (s->wfc.done < s->nbfrags))
+	       && !signal_pending(current)) {
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&s->wq, &wait);
+
+	/* undo the pointer hack above */
+	if (shiftval) {
+		local_irq_save(flags);
+		b->dma_addr += shiftval;
+		b->data += shiftval;
+		/* ensure sane DMA code behavior if not yet processed */
+		if (b->offset != 0)
+			b->offset = s->fragsize;
+		local_irq_restore(flags);
+	}
+
+	FN_OUT(0);
+	return 0;
+}
+EXPORT_SYMBOL(audio_sync);
+
+/*******************************************************************************
+ *
+ * Stop all the DMA channels of the stream
+ *
+ ******************************************************************************/
+void audio_stop_dma(audio_stream_t *s)
+{
+	unsigned long flags;
+	asp_fops_t *asp_fops = NULL;
+	u8 asp_id, codec_id;
+
+	FN_IN;
+	DPRINTK("audio_stop_dma\n");
+
+	if (s->dma_spinref > 0 || !s->buffers)
+		return;
+
+	local_irq_save(flags);
+
+	asp_fops = get_asp_fops(s->device_instance);
+	find_audio_device(s->device_instance, &asp_id, &codec_id);
+
+	if (s->asp_tx_started || s->asp_rx_started) {
+	    if (s->input_or_output == FMODE_WRITE) {
+		asp_fops->stop_tx(asp_id);
+		s->asp_tx_started = 0;
+	    } else {
+		asp_fops->stop_rx(asp_id);
+		s->asp_rx_started = 0;
+	    }
+	}
+
+	s->started = 0;
+
+	if (s->spin_idle) {
+		/* DMA_START(s, SPIN_ADDR, SPIN_SIZE); */
+		/* DMA_START(s, SPIN_ADDR, SPIN_SIZE); */
+		s->dma_spinref = 2;
+	} else
+		s->dma_spinref = 0;
+
+	local_irq_restore(flags);
+
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_stop_dma);
+
+/*******************************************************************************
+ *
+ * Get the dma posn
+ *
+ ******************************************************************************/
+u_int audio_get_dma_pos(audio_stream_t *s)
+{
+	audio_buf_t *b = &s->buffers[s->dma_tail];
+	u_int offset = 0;
+
+	FN_IN;
+	if (b->dma_ref) {
+		edmacc_paramentry_regs temp;
+
+		davinci_get_dma_params(s->master_ch, &temp);
+
+		if (s->input_or_output == FMODE_WRITE)
+			offset = temp.src - b->dma_addr;
+		else if (s->input_or_output == FMODE_READ)
+			offset = temp.dst - b->dma_addr;
+		if (offset >= s->fragsize)
+			offset = s->fragsize - 4;
+	} else if (s->pending_frags) {
+		offset = b->offset;
+	} else {
+		offset = 0;
+	}
+	FN_OUT(offset);
+	return offset;
+}
+EXPORT_SYMBOL(audio_get_dma_pos);
+
+/*******************************************************************************
+ *
+ * Reset the audio buffers
+ *
+ ******************************************************************************/
+void audio_reset(audio_stream_t *s)
+{
+	audio_buf_t *b;
+	FN_IN;
+	if (s->buffers) {
+		audio_stop_dma(s);
+		/* back up pointers to be ready to restart from the same spot */
+		while (s->dma_head != s->dma_tail) {
+			b = &s->buffers[s->dma_head];
+			if (b->dma_ref) {
+				b->dma_ref = 0;
+				b->offset = 0;
+			}
+			s->pending_frags++;
+			if (s->dma_head == 0)
+				s->dma_head = s->nbfrags;
+			s->dma_head--;
+		}
+		b = &s->buffers[s->dma_head];
+		if (b->dma_ref) {
+			b->offset = 0;
+			b->dma_ref = 0;
+		}
+
+		s->buffers[s->dma_head].offset = 0;
+		s->buffers[s->usr_head].offset = 0;
+		s->usr_head = s->dma_head;
+		s->pending_frags = 0;
+		init_completion(&s->wfc);
+		s->wfc.done = s->nbfrags;
+	}
+	AUDIO_QUEUE_INIT(s);
+	s->active = 0;
+	s->stopped = 0;
+
+	FN_OUT(0);
+	return;
+}
+EXPORT_SYMBOL(audio_reset);
+
+/*******************************************************************************
+ *
+ * Clear any pending transfers
+ *
+ ******************************************************************************/
+void davinci_clear_sound_dma(audio_stream_t *s)
+{
+	return;
+}
+EXPORT_SYMBOL(davinci_clear_sound_dma);
+
+#define Async 0
+#define ABsync 1
+
+/*******************************************************************************
+ *
+ * DMA related functions
+ *
+ ******************************************************************************/
+static int audio_set_dma_params_play(int channel, dma_addr_t dma_ptr,
+				     u_int dma_size, unsigned long dest_addr)
+{
+	FN_IN;
+	DPRINTK("audio_set_dma_params_play channel = %d dma_ptr = %x \
+		dma_size = %x\n", channel, dma_ptr, dma_size);
+
+	davinci_set_dma_src_params(channel, (unsigned long)(dma_ptr), 0, 0);
+	davinci_set_dma_dest_params(channel, dest_addr, 0, 0);
+	davinci_set_dma_src_index(channel, acount, 0);
+	davinci_set_dma_dest_index(channel, 0, 0);
+	davinci_set_dma_transfer_params(channel, acount, dma_size / acount, 1,
+					0, Async);
+
+	FN_OUT(0);
+	return 0;
+}
+
+static int audio_set_dma_params_capture(int channel, dma_addr_t dma_ptr,
+					u_int dma_size, unsigned long src_addr)
+{
+	FN_IN;
+	DPRINTK("audio_set_dma_params_capture channel = %d dma_ptr = %x \
+		dma_size = %x\n", channel, dma_ptr, dma_size);
+
+	davinci_set_dma_src_params(channel, src_addr, 0, 0);
+	davinci_set_dma_dest_params(channel, (unsigned long)(dma_ptr), 0, 0);
+	davinci_set_dma_src_index(channel, 0, 0);
+	davinci_set_dma_dest_index(channel, acount, 0);
+	davinci_set_dma_transfer_params(channel, acount, dma_size / acount, 1,
+					0, Async);
+
+	FN_OUT(0);
+	return 0;
+}
+
+int audio_start_dma_chain(audio_stream_t *s)
+{
+	unsigned long flags;
+	int channel = s->lch[s->dma_q_head];
+	asp_fops_t *asp_fops = NULL;
+	u8 asp_id, codec_id;
+
+	FN_IN;
+
+	if (!s->started) {
+		edmacc_paramentry_regs temp;
+		davinci_get_dma_params(channel, &temp);
+		davinci_set_dma_params(s->master_ch, &temp);
+
+		s->started = 1;
+
+		if (!s->dma_started) {
+			davinci_start_dma(s->master_ch);
+			s->dma_started = 1;
+		}
+		local_irq_save(flags);
+
+		if (!s->asp_tx_started || !s->asp_rx_started) {
+		    local_irq_restore(flags);
+		    asp_fops = get_asp_fops(s->device_instance);
+		    find_audio_device(s->device_instance, &asp_id, &codec_id);
+
+		    if (s->input_or_output == FMODE_WRITE) {
+			asp_fops->start_tx(asp_id);
+			s->asp_tx_started = 1;
+		    } else {
+			asp_fops->start_rx(asp_id);
+			s->asp_rx_started = 1;
+		    }
+		    local_irq_restore(flags);
+		} else
+		    local_irq_restore(flags);
+	}
+
+	if (s->input_or_output == FMODE_WRITE && atomic_read(&s->playing_null)
+	    == 1) {
+	    edmacc_paramentry_regs temp;
+	    davinci_get_dma_params(channel, &temp);
+	    davinci_set_dma_params(s->master_ch, &temp);
+	    atomic_set(&s->playing_null, 0);
+	}
+
+	/* else the dma itself will progress forward with out our help */
+	FN_OUT(0);
+	return 0;
+}
+
+/* Start DMA -
+ * Do the initial set of work to initialize all the channels as required.
+ * We shall then initate a transfer
+ */
+
+static int davinci_start_sound_dma(audio_stream_t *s, dma_addr_t dma_ptr,
+				   u_int dma_size)
+{
+	int ret = -EPERM;
+	unsigned long dma_addr;
+
+	FN_IN;
+	if (unlikely(dma_size > MAX_DMA_SIZE)) {
+		ERR("DmaSoundDma: Start: overflowed %d-%d\n", dma_size,
+		    MAX_DMA_SIZE);
+		return -EOVERFLOW;
+	}
+
+	if (AUDIO_QUEUE_FULL(s)) {
+		DPRINTK("queue full\n");
+		ret = -2;
+		goto sound_out;
+	}
+	if (s->input_or_output == FMODE_WRITE)
+		/*playback */
+	{
+	    dma_addr = get_tx_dma_dest_address (s->device_instance);
+	    ret = audio_set_dma_params_play(s->lch[s->dma_q_tail],
+					    dma_ptr, dma_size, dma_addr);
+	} else {
+	    dma_addr = get_rx_dma_src_address (s->device_instance);
+	    ret = audio_set_dma_params_capture(s->lch[s->dma_q_tail],
+					       dma_ptr, dma_size, dma_addr);
+	}
+	if (ret != 0) {
+		ret = -2;	/* indicate queue full */
+		goto sound_out;
+	}
+	AUDIO_INCREMENT_TAIL(s);
+
+	/* This is done to avoid the noise that would be generated during the
+	   SPDIF loopback app. */
+	if ( s->dma_q_count >= NUMBER_OF_CHANNELS_TO_LINK) {
+		ret = audio_start_dma_chain(s);
+	} else if (is_dit_enabled (s->device_instance) != 1) {
+		ret = audio_start_dma_chain(s);
+	}
+
+	if (ret) {
+		ERR("dma start failed");
+	}
+sound_out:
+	FN_OUT(ret);
+	return ret;
+}
+
+/*******************************************************************************
+ *
+ * ISR related functions
+ *
+ ******************************************************************************/
+/* The work item handler */
+static void audio_dsr_handler(unsigned long inData)
+{
+	void *data = (void *)inData;
+	struct audio_isr_work_item *work = data;
+	audio_stream_t *s = (work->s);
+	int sound_curr_lch = work->current_lch;
+	u16 ch_status = work->ch_status;
+
+	FN_IN;
+	DPRINTK("lch=%d,status=0x%x, data=%p as=%p\n", sound_curr_lch,
+		ch_status, data, s);
+	if (AUDIO_QUEUE_EMPTY(s)) {
+		DPRINTK("Interrupt(%d)  for empty queue(h=%d, T=%d)???\n",
+			sound_curr_lch, s->dma_q_head, s->dma_q_tail);
+		DPRINTK("nbfrag=%d,pendfrags=%d,USR-H=%d, QH-%d QT-%d\n",
+			s->nbfrags, s->pending_frags, s->usr_head, s->dma_head,
+			s->dma_tail);
+		AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
+		FN_OUT(-1);
+		return;
+	}
+
+	AUDIO_INCREMENT_HEAD(s);	/* Empty the queue */
+
+	/* Try to fill again */
+	audio_dma_callback(sound_curr_lch, ch_status, s);
+	FN_OUT(0);
+
+}
+
+/* Macro to trace the IRQ calls - checks for multi-channel irqs */
+#define IRQ_TRACE
+#ifdef IRQ_TRACE
+#define MAX_UP 10
+static char xyz[MAX_UP] = { 0 };
+static int h;
+#endif
+
+/* ISRs have to be short and smart.. So we transfer every heavy duty stuff to
+ * the work item
+ */
+static void sound_dma_irq_handler(int sound_curr_lch, u16 ch_status, void *data)
+{
+	audio_stream_t *s = (audio_stream_t *) data;
+	FN_IN;
+
+	if (ch_status == DMA_COMPLETE) {
+
+	    if (unlikely(s->input_or_output == FMODE_WRITE &&
+			 atomic_read(&s->playing_null) == 1)) {
+		return;
+	    }
+
+#ifdef IRQ_TRACE
+		xyz[h++] = '0' + sound_curr_lch;
+		if (h == MAX_UP - 1) {
+			DPRINTK("%s-", xyz);
+			h = 0;
+		}
+#endif
+
+		sound_curr_lch = s->lch[s->dma_q_head];
+
+		DPRINTK("lch=%d,status=0x%x, data=%p\n", sound_curr_lch,
+			ch_status, data);
+
+		if (AUDIO_QUEUE_LAST(s)) {
+			audio_stream_t *s = data;
+			audio_buf_t *b = &s->buffers[s->dma_tail];
+
+			if (s->dma_spinref > 0) {
+				s->dma_spinref--;
+			} else if (!s->buffers) {
+				DPRINTK
+				("davinci_audio: received DMA IRQ for non\
+					existent buffers !\n");
+				return;
+			} else if (b->dma_ref && --b->dma_ref == 0 &&
+				   b->offset >= s->fragsize) {
+				/* This fragment is done */
+				b->offset = 0;
+				s->bytecount += s->fragsize;
+				s->fragcount++;
+				s->dma_spinref = -s->dma_spinref;
+
+				if (++s->dma_tail >= s->nbfrags)
+					s->dma_tail = 0;
+
+				if (!s->mapped) {
+					complete(&s->wfc);
+				} else
+					s->pending_frags++;
+
+				wake_up(&s->wq);
+			}
+
+			AUDIO_INCREMENT_HEAD(s);
+			if (s->input_or_output == FMODE_WRITE) {
+			    edmacc_paramentry_regs temp;
+
+			    davinci_get_dma_params(s->null_lch, &temp);
+			    davinci_set_dma_params(s->master_ch, &temp);
+			    atomic_set(&s->playing_null, 1);
+			} else {
+			    audio_stop_dma(s);
+			}
+
+			return;
+		}
+
+		/* Start the work item  - we ping pong the work items */
+		if (!work_item_running) {
+			work1.current_lch = sound_curr_lch;
+			work1.ch_status = ch_status;
+			work1.s = s;
+			/* schedule tasklet 1 */
+			tasklet_schedule(&audio_isr_work1);
+			work_item_running = 1;
+		} else {
+			work2.current_lch = sound_curr_lch;
+			work2.ch_status = ch_status;
+			work2.s = s;
+			/* schedule tasklet 2 */
+			tasklet_schedule(&audio_isr_work2);
+			work_item_running = 0;
+		}
+	} else {
+		DPRINTK("Error in DMA \n");
+	}
+
+	FN_OUT(0);
+	return;
+}
+
+/* The call back that handles buffer stuff */
+static void audio_dma_callback(int lch, u16 ch_status, void *data)
+{
+	audio_stream_t *s = data;
+	audio_buf_t *b = &s->buffers[s->dma_tail];
+	FN_IN;
+
+	if (s->dma_spinref > 0) {
+		s->dma_spinref--;
+	} else if (!s->buffers) {
+		DPRINTK
+		    ("davinci_audio: received DMA IRQ for non existent\
+		buffers !\n");
+
+		return;
+	} else if (b->dma_ref && --b->dma_ref == 0 &&
+		   b->offset >= s->fragsize) {
+		/* This fragment is done */
+		b->offset = 0;
+		s->bytecount += s->fragsize;
+		s->fragcount++;
+		s->dma_spinref = -s->dma_spinref;
+
+		if (++s->dma_tail >= s->nbfrags)
+			s->dma_tail = 0;
+
+		if (!s->mapped) {
+			complete(&s->wfc);
+		} else
+			s->pending_frags++;
+
+		wake_up(&s->wq);
+	}
+
+	audio_process_dma(s);
+
+	FN_OUT(0);
+	return;
+}
+
+/*******************************************************************************
+ *
+ * audio_get_dma_callback(): return the dma interface call back function
+ *
+ ******************************************************************************/
+dma_callback_t audio_get_dma_callback(void)
+{
+	FN_IN;
+	FN_OUT(0);
+	return audio_dma_callback;
+}
+EXPORT_SYMBOL(audio_get_dma_callback);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("Common DMA handling for Audio driver on DAVINCI\
+			processors");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.10/sound/oss/dm646x/davinci-audio-dma-intfc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/davinci-audio-dma-intfc.h
@@ -0,0 +1,70 @@
+/*
+ * linux/sound/oss/davinci-audio-dma-intfc.h
+ *
+ * Common audio DMA handling for the Davinci processors
+ *
+ * Copyright (C) 2006 Texas Instruments, Inc.
+ *
+ * Copyright (C) 2000, 2001 Nicolas Pitre <nico@cam.org>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * History:
+ *
+ * 2005-10-01   Rishi Bhattacharya / Sharath Kumar - Added support for TI
+ * 						     Davinci DM644x processor
+ *
+ * 2007-07-06   Nirmal Pandey, Suresh Rajashekara - Included new sound driver
+ *              arch (to support multiple ASP types and codec types)
+ */
+
+#ifndef __DAVINCI_AUDIO_DMA_INTFC_H
+#define __DAVINCI_AUDIO_DMA_INTFC_H
+
+/******************************* INCLUDES *************************************/
+
+/* Requires davinci-audio.h */
+#include "audio_controller.h"
+
+/************************** GLOBAL MACROS *************************************/
+
+/* Provide the Macro interfaces common across platforms */
+#define DMA_REQUEST(e, s, cb)   {e = davinci_request_sound_dma(s->dma_dev, \
+							       s->id, s, \
+							       &s->master_ch, \
+							       &s->lch); }
+#define DMA_FREE(s)             davinci_free_sound_dma(s->master_ch, &s->lch, s)
+#define DMA_CLEAR(s)            davinci_clear_sound_dma(s)
+
+/************************** GLOBAL DATA STRUCTURES ****************************/
+
+typedef void (*dma_callback_t) (int lch, u16 ch_status, void *data);
+
+/************************** GLOBAL FUNCTIONS **********************************/
+
+dma_callback_t audio_get_dma_callback(void);
+int audio_setup_buf(audio_stream_t *s);
+int audio_process_dma(audio_stream_t *s);
+void audio_prime_rx(audio_state_t *state);
+int audio_set_fragments(audio_stream_t *s, int val);
+int audio_sync(struct file *file);
+void audio_stop_dma(audio_stream_t *s);
+u_int audio_get_dma_pos(audio_stream_t *s);
+void audio_reset(audio_stream_t *s);
+void audio_discard_buf(audio_stream_t *s);
+
+/**************** ARCH SPECIFIC FUNCIONS **************************************/
+
+void davinci_clear_sound_dma(audio_stream_t *s);
+
+int davinci_request_sound_dma(int device_id, const char *device_name,
+			      void *data, int *master_ch, int **channels);
+int davinci_free_sound_dma(int master_ch, int **channels, void *data);
+
+#endif				/* #ifndef __DAVINCI_AUDIO_DMA_INTFC_H */
Index: linux-2.6.10/sound/oss/dm646x/evm_audio_info.c
===================================================================
--- /dev/null
+++ linux-2.6.10/sound/oss/dm646x/evm_audio_info.c
@@ -0,0 +1,372 @@
+/*
+ * evm_audio_info.c - EVM specific layout
+ *
+ *
+ * Copyright (C) 2007  Texas Instruments, India
+ * Author:Nirmal Pandey <n-pandey@ti.com>,
+ *        Suresh Rajashekara <suresh.r@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+
+#include <asm/arch/evm_audio_info.h>
+#include <asm/arch/mcasp.h>
+
+extern struct asp_file_operations mcasp_fops;
+extern codec_fops_t aic32_fops;
+
+#define MCASP0 			0
+#define MCASP0_REG_BASE		0x01D01000
+#define MCASP0_TX_DMA_PORT	0x01D01400
+#define MCASP0_RX_DMA_PORT	0x01D01400
+#define MCASP0_TX_DMA_EVT	6
+#define MCASP0_RX_DMA_EVT	9
+#define MCASP0_TX_IRQ		28
+#define MCASP0_RX_IRQ		29
+#define MCASP0_SERIALIZER_COUNT	4
+
+#define MCASP1			1
+#define MCASP1_REG_BASE		0x01D01800
+#define MCASP1_TX_DMA_PORT	0x01D01C00
+#define MCASP1_TX_DMA_EVT	12
+#define MCASP1_TX_IRQ		32
+#define MCASP1_SERIALIZER_COUNT	1
+
+
+asp_info_t mcasp_info[] = {
+	[0] = {
+		.id = MCASP0,
+		.reg_base = IO_ADDRESS(MCASP0_REG_BASE),
+		.tx_data_port = MCASP0_TX_DMA_PORT,
+		.rx_data_port = MCASP0_RX_DMA_PORT,
+		.tx_dma_evt = MCASP0_TX_DMA_EVT,
+		.rx_dma_evt = MCASP0_RX_DMA_EVT,
+		.tx_irq = MCASP0_TX_IRQ,
+		.rx_irq = MCASP0_RX_IRQ,
+		.serializer_count = MCASP0_SERIALIZER_COUNT,
+		.left_dit_channel_count = 0,
+		.right_dit_channel_count = 0,
+		.lpsc = "McASPCLK0",
+		.flags = TX_SUPPORT | RX_SUPPORT,
+	},
+	[1] = {
+		.id = MCASP1,
+		.reg_base = IO_ADDRESS(MCASP1_REG_BASE),
+		.tx_data_port = MCASP1_TX_DMA_PORT,
+		.rx_data_port = -1,
+		.tx_dma_evt = MCASP1_TX_DMA_EVT,
+		.rx_dma_evt = -1,
+		.tx_irq = MCASP1_TX_IRQ,
+		.rx_irq = -1,
+		.serializer_count = MCASP1_SERIALIZER_COUNT,
+		.left_dit_channel_count = 0,
+		.right_dit_channel_count = 0,
+		.lpsc = "McASPCLK1",
+		.flags = TX_SUPPORT,
+	},
+};
+
+
+struct codec_info aic32_info = {
+	.lpsc = NULL,
+	.flags = 0,
+};
+
+evm_audio_info_t evm_aud_info = {
+	.asp_count = 2,
+	.asp[0] = {
+		.id = 0,
+		.type = MCASP,
+		/* For Davinci-HD if ASP needs to be made as master, then
+		   need_tx_for_rx has to be 1, because of the issue we have with
+		   the clock interference of ACLKX and ACLKR. This is not
+		   necessary for S/PDIF*/
+		.master_mode = ASP_SLAVE,
+		.is_configured = FALSE,
+		.is_initialized = FALSE,
+		.is_in_use = FALSE,
+		.a_op = &mcasp_fops,
+		.a_info = (struct asp_info *)&mcasp_info,
+		.dit_enabled = 0,
+		.need_tx_for_rx = 0,
+		.codec_count = 1,
+		.codec[0] = {
+			.id = 0,
+			.type = CODEC_AIC32,
+			.is_configured = FALSE,
+			.is_initialized = FALSE,
+			.is_in_use = FALSE,
+			.c_op = &aic32_fops,
+			.c_info = &aic32_info,
+			.device_instance = 0,
+			.pid = 0,
+		}
+	},
+	.asp[1] = {
+		.id = 1,
+		.type = MCASP,
+		.master_mode = ASP_MASTER,
+		.is_configured = FALSE,
+		.is_initialized = FALSE,
+		.is_in_use = FALSE,
+		.a_op = &mcasp_fops,
+		.a_info = (struct asp_info *)&mcasp_info,
+		.dit_enabled = 1,
+		.need_tx_for_rx = 0,
+		.codec_count = 0,
+		.codec[0] = {
+			.id = 1,
+			.type = CODEC_UNKNOWN,
+			.is_configured = FALSE,
+			.is_initialized = FALSE,
+			.is_in_use = FALSE,
+			.c_op = NULL,
+			.c_info = NULL,
+			.device_instance = 0,
+			.pid = 1,
+		}
+	},
+};
+
+s8 find_audio_device ( u8 dev_instance, u8 *asp_id_ptr, u8 *codec_id_ptr )
+{
+	s8 ret_code = 0;
+	u8 asp_count, count, ccount, codec_count;
+	u8 found = FALSE;
+	u8 asp_id;
+
+	/* Find the ASP and codec for the given device number */
+	if (evm_aud_info.asp_count == 0) {
+		ret_code = -ERR_NULL_AUDIO_CONFIG;
+	} else {
+		asp_count = evm_aud_info.asp_count;
+		/* Search for each ASP */
+		for (count = 0; count < asp_count; count++) {
+			asp_id = evm_aud_info.asp[count].id;
+			codec_count = evm_aud_info.asp[count].codec_count;
+			/* NK: make sure that if codec_count is zero, dit is
+			   enabled */
+			if ( (codec_count == 0) &&
+			     (evm_aud_info.asp[count].dit_enabled != 1) ) {
+				/* This McASP is not having a codec or DIT */
+				/* There might be some problem with the config
+				 */
+				/* Lets go ahed for the time being */
+				continue; /* No codec connected with this ASP */
+			} else {
+				/* search each codec within given ASP */
+				/* NK: Lets make sure that if codec_count is
+				   zero, dit is enabled, make codec count as 1
+				*/
+				if (evm_aud_info.asp[count].dit_enabled == 1) {
+					/* making codec count as one. This will
+					   enable us to search for the given ASP
+					*/
+					codec_count = 1;
+				}
+				for ( ccount = 0; ccount < codec_count; ccount++
+					) {
+					if ( dev_instance ==
+					     evm_aud_info.asp[count].
+					     codec[ccount].device_instance ) {
+						/* codec with desired device
+						   number has been found */
+						*asp_id_ptr = count;
+						*codec_id_ptr = ccount;
+						found = TRUE;
+						break;
+					}
+				}
+
+				if ( found ) {
+					break;
+				}
+			}
+		}
+	}
+
+	if (!found) {
+		ret_code = -ERR_AUDIO_DEVICE_NOT_FOUND;
+		printk(KERN_INFO"McASP with minor number %d not found"
+		       , dev_instance);
+	}
+
+	return(ret_code);
+}
+EXPORT_SYMBOL(find_audio_device);
+
+u8 is_dit_enabled (u8 device_instance)
+{
+	u8 asp_id = 0, codec_id = 0;
+
+	find_audio_device (device_instance, &asp_id, &codec_id);
+	return evm_aud_info.asp[asp_id].dit_enabled;
+}
+
+unsigned long get_tx_dma_dest_address (u8 device_instance)
+{
+	u8 asp_id = 0, codec_id = 0;
+
+	find_audio_device (device_instance, &asp_id, &codec_id);
+	return evm_aud_info.asp[asp_id].a_info[asp_id].tx_data_port;
+}
+EXPORT_SYMBOL(get_tx_dma_dest_address);
+
+unsigned long get_rx_dma_src_address (u8 device_instance)
+{
+	u8 asp_id = 0, codec_id = 0;
+
+	find_audio_device (device_instance, &asp_id, &codec_id);
+	return evm_aud_info.asp[asp_id].a_info[asp_id].rx_data_port;
+}
+EXPORT_SYMBOL(get_rx_dma_src_address);
+
+asp_fops_t *get_asp_fops(u8 device_instance)
+{
+	u8 asp_id = 0, codec_id = 0;
+
+	find_audio_device (device_instance, &asp_id, &codec_id);
+	return evm_aud_info.asp[asp_id].a_op;
+}
+EXPORT_SYMBOL(get_asp_fops);
+
+codec_fops_t *get_codec_fops(u8 device_instance)
+{
+	u8 asp_id = 0, codec_id = 0;
+
+	find_audio_device (device_instance, &asp_id, &codec_id);
+	return evm_aud_info.asp[asp_id].codec[codec_id].c_op;
+}
+EXPORT_SYMBOL(get_codec_fops);
+
+static s8 validate_evm_codec_config (audio_codec_t *codec)
+{
+	s8 retcode = 0;
+
+	if ( codec->id > MAX_CODEC ) {
+		retcode = -ERR_INVALID_CODEC_ID;
+	} else {
+		codec->is_configured = FALSE;
+		codec->is_initialized = FALSE;
+		codec->is_in_use = FALSE;
+		codec->device_instance = 0;
+
+		if ( codec->c_info == NULL && codec->c_op != NULL ) {
+			retcode = -ERR_INVALID_CODEC_FOPS_OR_INFO;
+		}
+	}
+
+	return retcode;
+}
+
+
+static s8 validate_evm_asp_config (audio_serial_port_t *asp)
+{
+	s8 retcode = 0;
+	u8 cnt = 0;
+	u8 *codec_id_arr = NULL;
+
+	codec_id_arr = (u8 *) kmalloc (asp->codec_count, GFP_KERNEL);
+
+	if (codec_id_arr == NULL) {
+		retcode = -ENOMEM;
+	} else {
+		memset(codec_id_arr, 0, asp->codec_count);
+
+		if ( asp->id > MAX_ASP ) {
+			retcode = -ERR_INVALID_ASP_ID;
+		} else {
+			asp->is_configured = FALSE;
+			asp->is_initialized = FALSE;
+			asp->is_in_use = FALSE;
+
+			if ( asp->a_info == NULL && asp->a_op != NULL ) {
+				retcode = -ERR_INVALID_ASP_FOPS_OR_INFO;
+			} else {
+
+				if ( asp->dit_enabled == 1 && asp->codec_count
+				     != 0 ) {
+					retcode = -ERR_DIT_ENABLED_WITH_CODECS;
+				} else {
+					for (cnt = 0; cnt < asp->codec_count;
+					     cnt++) {
+
+						retcode =
+						validate_evm_codec_config
+							(&asp->codec[cnt]);
+						if (retcode < 0 ) {
+							break;
+						}
+
+						if (
+						codec_id_arr[asp->codec[cnt].id]
+						== TRUE ) {
+							retcode =
+							-ERR_DUP_CODEC_ID;
+							break;
+						} else {
+							codec_id_arr[
+								asp->codec[
+									cnt].id]
+								= TRUE;
+						}
+
+						asp->codec[cnt].pid = asp->id;
+					}
+				}
+			}
+		}
+
+		kfree(codec_id_arr);
+	}
+
+	return retcode;
+}
+
+s8 validate_evm_audio_config (evm_audio_info_t **evm_info)
+{
+	s8 retcode = 0;
+	u8 cnt = 0;
+	u8 asp_id_arr[MAX_ASP] = {0};
+	evm_audio_info_t *info;
+
+	info = &evm_aud_info;
+
+	if (unlikely(info->asp_count > MAX_ASP)) {
+		info = NULL;
+		retcode = -ERR_INVAL_ASP_CNT;
+	} else {
+		for (cnt = 0; cnt < info->asp_count; cnt++) {
+			retcode = validate_evm_asp_config (&info->asp[cnt]);
+			if (retcode < 0 ) {
+				info = NULL;
+				break;
+			}
+
+			if (asp_id_arr[info->asp[cnt].id] == TRUE) {
+				info = NULL;
+				retcode = -ERR_DUP_ASP_ID;
+				break;
+			} else {
+				asp_id_arr[info->asp[cnt].id] = TRUE;
+			}
+		}
+	}
+
+	*evm_info = info;
+	return retcode;
+}
+EXPORT_SYMBOL(validate_evm_audio_config);
Index: linux-2.6.10/mvl_patches/pro-1685.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1685.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1685);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

