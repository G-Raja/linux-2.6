#! /usr/bin/env bash
# Patch: -mips_db1200
# Date: Wed Apr  5 15:07:28 2006
# Source: MontaVista Software, Inc. | http://source.mvista.com
# MR: 15503, 15923
# Type: Integration
# Disposition: MontaVista (all of the stuff has been pushed upstream)
# Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
# Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
# Description:
# 
# Support for AMD DB1200 in MVL 2.6 tree (PRO 4.0.1.ASYNC). This patch
# adds the DBAu1200 board from AMD to the MVL 2.6 tree. This patch adds
# support for RT and HRT.
# 
# Changeset:
# 
# +++ linux-2.6.10/arch/mips/Kconfig
# +++ linux-2.6.10/arch/mips/Makefile
# +++ linux-2.6.10/arch/mips/au1000/common/cputable.c
# +++ linux-2.6.10/arch/mips/au1000/common/gpio.c
# +++ linux-2.6.10/arch/mips/au1000/common/irq.c
# +++ linux-2.6.10/arch/mips/au1000/common/platform.c
# +++ linux-2.6.10/arch/mips/au1000/common/time.c
# +++ linux-2.6.10/arch/mips/au1000/pb1200/Makefile
# +++ linux-2.6.10/arch/mips/au1000/pb1200/board_setup.c
# +++ linux-2.6.10/arch/mips/au1000/pb1200/init.c
# +++ linux-2.6.10/arch/mips/au1000/pb1200/irqmap.c
# +++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
# +++ linux-2.6.10/arch/mips/kernel/proc.c
# +++ linux-2.6.10/arch/mips/mm/c-r4k.c
# +++ linux-2.6.10/arch/mips/mm/tlbex.c
# +++ linux-2.6.10/drivers/ide/Kconfig
# +++ linux-2.6.10/drivers/ide/ide-proc.c
# +++ linux-2.6.10/drivers/ide/mips/Makefile
# +++ linux-2.6.10/drivers/ide/mips/au1xxx-ide.c
# +++ linux-2.6.10/drivers/mmc/Kconfig
# +++ linux-2.6.10/drivers/mmc/Makefile
# +++ linux-2.6.10/drivers/mmc/au1xmmc.c
# +++ linux-2.6.10/drivers/mmc/au1xmmc.h
# +++ linux-2.6.10/drivers/mtd/nand/Kconfig
# +++ linux-2.6.10/drivers/mtd/nand/au1550nd.c
# +++ linux-2.6.10/drivers/net/Kconfig
# +++ linux-2.6.10/drivers/net/smc91x.h
# +++ linux-2.6.10/drivers/video/Kconfig
# +++ linux-2.6.10/drivers/video/Makefile
# +++ linux-2.6.10/drivers/video/au1200fb.c
# +++ linux-2.6.10/drivers/video/au1200fb.h
# +++ linux-2.6.10/include/asm-mips/bootinfo.h
# +++ linux-2.6.10/include/asm-mips/cpu.h
# +++ linux-2.6.10/include/asm-mips/mach-au1x00/au1000.h
# +++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx.h
# +++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx_ide.h
# +++ linux-2.6.10/include/asm-mips/mach-au1x00/ioremap.h
# +++ linux-2.6.10/include/asm-mips/mach-db1x00/db1200.h
# +++ linux-2.6.10/include/asm-mips/mach-db1x00/db1x00.h
# +++ linux-2.6.10/include/asm-mips/mach-pb1x00/pb1200.h
# +++ linux-2.6.10/include/linux/ide.h
# 
#  arch/mips/Kconfig                         |   14 
#  arch/mips/Makefile                        |   14 
#  arch/mips/au1000/common/cputable.c        |    2 
#  arch/mips/au1000/common/gpio.c            |  119 +
#  arch/mips/au1000/common/irq.c             |    2 
#  arch/mips/au1000/common/platform.c        |  243 +++
#  arch/mips/au1000/common/time.c            |    6 
#  arch/mips/au1000/pb1200/Makefile          |    5 
#  arch/mips/au1000/pb1200/board_setup.c     |  202 +++
#  arch/mips/au1000/pb1200/init.c            |   69 +
#  arch/mips/au1000/pb1200/irqmap.c          |  184 ++
#  arch/mips/kernel/cpu-probe.c              |    4 
#  arch/mips/kernel/proc.c                   |    1 
#  arch/mips/mm/c-r4k.c                      |    1 
#  arch/mips/mm/tlbex.c                      |    1 
#  drivers/ide/Kconfig                       |   29 
#  drivers/ide/ide-proc.c                    |    1 
#  drivers/ide/mips/Makefile                 |    1 
#  drivers/ide/mips/au1xxx-ide.c             | 1250 +++++++++++++++++++
#  drivers/mmc/Kconfig                       |   10 
#  drivers/mmc/Makefile                      |    1 
#  drivers/mmc/au1xmmc.c                     | 1026 +++++++++++++++
#  drivers/mmc/au1xmmc.h                     |   92 +
#  drivers/mtd/nand/Kconfig                  |    2 
#  drivers/mtd/nand/au1550nd.c               |  118 +
#  drivers/net/smc91x.h                      |   32 
#  drivers/video/Kconfig                     |    8 
#  drivers/video/Makefile                    |    1 
#  drivers/video/au1200fb.c                  | 1944 ++++++++++++++++++++++++++++++
#  drivers/video/au1200fb.h                  |  288 ++++
#  include/asm-mips/bootinfo.h               |    3 
#  include/asm-mips/cpu.h                    |    1 
#  include/asm-mips/mach-au1x00/au1000.h     |   72 -
#  include/asm-mips/mach-au1x00/au1xxx.h     |   42 
#  include/asm-mips/mach-au1x00/au1xxx_ide.h |  303 ++++
#  include/asm-mips/mach-au1x00/ioremap.h    |   31 
#  include/asm-mips/mach-db1x00/db1200.h     |  227 +++
#  include/asm-mips/mach-db1x00/db1x00.h     |    7 
#  include/asm-mips/mach-pb1x00/pb1200.h     |  255 +++
#  include/linux/ide.h                       |    2 
#  40 files changed, 6552 insertions(+), 61 deletions(-)
# 

PATCHNUM=430
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. | http://source.mvista.com
MR: 15503, 15923
Type: Integration
Disposition: MontaVista (all of the stuff has been pushed upstream)
Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Description:

Support for AMD DB1200 in MVL 2.6 tree (PRO 4.0.1.ASYNC). This patch
adds the DBAu1200 board from AMD to the MVL 2.6 tree. This patch adds
support for RT and HRT.

Changeset:

+++ linux-2.6.10/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/au1000/common/cputable.c
+++ linux-2.6.10/arch/mips/au1000/common/gpio.c
+++ linux-2.6.10/arch/mips/au1000/common/irq.c
+++ linux-2.6.10/arch/mips/au1000/common/platform.c
+++ linux-2.6.10/arch/mips/au1000/common/time.c
+++ linux-2.6.10/arch/mips/au1000/pb1200/Makefile
+++ linux-2.6.10/arch/mips/au1000/pb1200/board_setup.c
+++ linux-2.6.10/arch/mips/au1000/pb1200/init.c
+++ linux-2.6.10/arch/mips/au1000/pb1200/irqmap.c
+++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
+++ linux-2.6.10/arch/mips/kernel/proc.c
+++ linux-2.6.10/arch/mips/mm/c-r4k.c
+++ linux-2.6.10/arch/mips/mm/tlbex.c
+++ linux-2.6.10/drivers/ide/Kconfig
+++ linux-2.6.10/drivers/ide/ide-proc.c
+++ linux-2.6.10/drivers/ide/mips/Makefile
+++ linux-2.6.10/drivers/ide/mips/au1xxx-ide.c
+++ linux-2.6.10/drivers/mmc/Kconfig
+++ linux-2.6.10/drivers/mmc/Makefile
+++ linux-2.6.10/drivers/mmc/au1xmmc.c
+++ linux-2.6.10/drivers/mmc/au1xmmc.h
+++ linux-2.6.10/drivers/mtd/nand/Kconfig
+++ linux-2.6.10/drivers/mtd/nand/au1550nd.c
+++ linux-2.6.10/drivers/net/Kconfig
+++ linux-2.6.10/drivers/net/smc91x.h
+++ linux-2.6.10/drivers/video/Kconfig
+++ linux-2.6.10/drivers/video/Makefile
+++ linux-2.6.10/drivers/video/au1200fb.c
+++ linux-2.6.10/drivers/video/au1200fb.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/cpu.h
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1000.h
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx.h
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx_ide.h
+++ linux-2.6.10/include/asm-mips/mach-au1x00/ioremap.h
+++ linux-2.6.10/include/asm-mips/mach-db1x00/db1200.h
+++ linux-2.6.10/include/asm-mips/mach-db1x00/db1x00.h
+++ linux-2.6.10/include/asm-mips/mach-pb1x00/pb1200.h
+++ linux-2.6.10/include/linux/ide.h

 arch/mips/Kconfig                         |   14 
 arch/mips/Makefile                        |   14 
 arch/mips/au1000/common/cputable.c        |    2 
 arch/mips/au1000/common/gpio.c            |  119 +
 arch/mips/au1000/common/irq.c             |    2 
 arch/mips/au1000/common/platform.c        |  243 +++
 arch/mips/au1000/common/time.c            |    6 
 arch/mips/au1000/pb1200/Makefile          |    5 
 arch/mips/au1000/pb1200/board_setup.c     |  202 +++
 arch/mips/au1000/pb1200/init.c            |   69 +
 arch/mips/au1000/pb1200/irqmap.c          |  184 ++
 arch/mips/kernel/cpu-probe.c              |    4 
 arch/mips/kernel/proc.c                   |    1 
 arch/mips/mm/c-r4k.c                      |    1 
 arch/mips/mm/tlbex.c                      |    1 
 drivers/ide/Kconfig                       |   29 
 drivers/ide/ide-proc.c                    |    1 
 drivers/ide/mips/Makefile                 |    1 
 drivers/ide/mips/au1xxx-ide.c             | 1250 +++++++++++++++++++
 drivers/mmc/Kconfig                       |   10 
 drivers/mmc/Makefile                      |    1 
 drivers/mmc/au1xmmc.c                     | 1026 +++++++++++++++
 drivers/mmc/au1xmmc.h                     |   92 +
 drivers/mtd/nand/Kconfig                  |    2 
 drivers/mtd/nand/au1550nd.c               |  118 +
 drivers/net/smc91x.h                      |   32 
 drivers/video/Kconfig                     |    8 
 drivers/video/Makefile                    |    1 
 drivers/video/au1200fb.c                  | 1944 ++++++++++++++++++++++++++++++
 drivers/video/au1200fb.h                  |  288 ++++
 include/asm-mips/bootinfo.h               |    3 
 include/asm-mips/cpu.h                    |    1 
 include/asm-mips/mach-au1x00/au1000.h     |   72 -
 include/asm-mips/mach-au1x00/au1xxx.h     |   42 
 include/asm-mips/mach-au1x00/au1xxx_ide.h |  303 ++++
 include/asm-mips/mach-au1x00/ioremap.h    |   31 
 include/asm-mips/mach-db1x00/db1200.h     |  227 +++
 include/asm-mips/mach-db1x00/db1x00.h     |    7 
 include/asm-mips/mach-pb1x00/pb1200.h     |  255 +++
 include/linux/ide.h                       |    2 
 mvl_patches/pro-0430.c                    |   16 
 41 files changed, 6568 insertions(+), 61 deletions(-)

Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -597,6 +597,8 @@ config SOC_AU1500
 	bool "SOC_AU1500"
 config SOC_AU1550
 	bool "SOC_AU1550"
+config SOC_AU1200
+	bool "SOC_AU1200"
 
 endchoice
 
@@ -638,6 +640,12 @@ config MIPS_PB1550
 	select HW_HAS_PCI
 	select MIPS_DISABLE_OBSOLETE_IDE
 
+config MIPS_PB1200
+	bool "AMD Alchemy PB1200 board"
+	select SOC_AU1200
+	select DMA_NONCOHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+
 config MIPS_DB1000
 	bool "DB1000 board"
 	depends on SOC_AU1000
@@ -663,6 +671,12 @@ config MIPS_DB1550
 	select DMA_COHERENT
 	select MIPS_DISABLE_OBSOLETE_IDE
 
+config MIPS_DB1200
+	bool "AMD Alchemy DB1200 board"
+	select SOC_AU1200
+	select DMA_NONCOHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+
 config MIPS_BOSPORUS
 	bool "Bosporus board"
 	depends on SOC_AU1500
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -278,6 +278,13 @@ cflags-$(CONFIG_MIPS_PB1550)	+= -Iinclud
 load-$(CONFIG_MIPS_PB1550)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Pb1200 eval board
+#
+libs-$(CONFIG_MIPS_PB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_PB1200)	+= -Iinclude/asm-mips/mach-pb1x00
+load-$(CONFIG_MIPS_PB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Db1000 eval board
 #
 libs-$(CONFIG_MIPS_DB1000)	+= arch/mips/au1000/db1x00/
@@ -285,6 +292,13 @@ cflags-$(CONFIG_MIPS_DB1000)	+= -Iinclud
 load-$(CONFIG_MIPS_DB1000)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Db1200 eval board
+#
+libs-$(CONFIG_MIPS_DB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_DB1200)	+= -Iinclude/asm-mips/mach-db1x00
+load-$(CONFIG_MIPS_DB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Db1100 eval board
 #
 libs-$(CONFIG_MIPS_DB1100)	+= arch/mips/au1000/db1x00/
Index: linux-2.6.10/arch/mips/au1000/common/cputable.c
===================================================================
--- linux-2.6.10.orig/arch/mips/au1000/common/cputable.c
+++ linux-2.6.10/arch/mips/au1000/common/cputable.c
@@ -40,6 +40,8 @@ struct cpu_spec	cpu_specs[] = {
     { 0xffffffff, 0x02030204, "Au1100 BE", 0, 1 },
     { 0xffffffff, 0x03030200, "Au1550 AA", 0, 1 },
     { 0xffffffff, 0x04030200, "Au1200 AA", 0, 1 },
+    { 0xffffffff, 0x04030200, "Au1200 AB", 0, 0 },
+    { 0xffffffff, 0x04030201, "Au1200 AC", 0, 1 },
     { 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0 },
 };
 
Index: linux-2.6.10/arch/mips/au1000/common/gpio.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/au1000/common/gpio.c
@@ -0,0 +1,119 @@
+/*
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <au1000.h>
+#include <au1xxx_gpio.h>
+
+#define gpio1 sys
+#if !defined(CONFIG_SOC_AU1000)
+static AU1X00_GPIO2 * const gpio2 = (AU1X00_GPIO2 *)GPIO2_BASE;
+
+#define GPIO2_OUTPUT_ENABLE_MASK 0x00010000
+
+int au1xxx_gpio2_read(int signal)
+{
+	signal -= 200;
+/*	gpio2->dir &= ~(0x01 << signal);						//Set GPIO to input */
+	return ((gpio2->pinstate >> signal) & 0x01);
+}
+
+void au1xxx_gpio2_write(int signal, int value)
+{
+	signal -= 200;
+
+	gpio2->output = (GPIO2_OUTPUT_ENABLE_MASK << signal) | 
+		(value << signal);
+}
+
+void au1xxx_gpio2_tristate(int signal)
+{
+	signal -= 200;
+	gpio2->dir &= ~(0x01 << signal); 	/* Set GPIO to input */
+}
+#endif
+
+int au1xxx_gpio1_read(int signal)
+{
+/*	gpio1->trioutclr |= (0x01 << signal); */
+	return ((gpio1->pinstaterd >> signal) & 0x01);
+}
+
+void au1xxx_gpio1_write(int signal, int value)
+{
+	if(value)
+		gpio1->outputset = (0x01 << signal);
+	else
+		gpio1->outputclr = (0x01 << signal);	/* Output a Zero */
+}
+
+void au1xxx_gpio1_tristate(int signal)
+{
+	gpio1->trioutclr = (0x01 << signal);		/* Tristate signal */
+}
+
+
+int au1xxx_gpio_read(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		return 0;
+#else
+		return au1xxx_gpio2_read(signal);
+#endif
+	else
+		return au1xxx_gpio1_read(signal);
+}
+
+void au1xxx_gpio_write(int signal, int value)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_write(signal, value);
+#endif
+	else
+		au1xxx_gpio1_write(signal, value);
+}
+
+void au1xxx_gpio_tristate(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_tristate(signal);
+#endif
+	else
+		au1xxx_gpio1_tristate(signal);
+}
+
+void au1xxx_gpio1_set_inputs(void)
+{
+	gpio1->pininputen = 0;
+}
+
+EXPORT_SYMBOL(au1xxx_gpio1_set_inputs);
+EXPORT_SYMBOL(au1xxx_gpio_tristate);
+EXPORT_SYMBOL(au1xxx_gpio_write);
+EXPORT_SYMBOL(au1xxx_gpio_read);
Index: linux-2.6.10/arch/mips/au1000/common/irq.c
===================================================================
--- linux-2.6.10.orig/arch/mips/au1000/common/irq.c
+++ linux-2.6.10/arch/mips/au1000/common/irq.c
@@ -492,6 +492,7 @@ void intc0_req0_irqdispatch(struct pt_re
 
 	if (!intc0_req0) return;
 
+#ifdef AU1000_USB_DEV_REQ_INT
 	/*
 	 * Because of the tight timing of SETUP token to reply
 	 * transactions, the USB devices-side packet complete
@@ -502,6 +503,7 @@ void intc0_req0_irqdispatch(struct pt_re
 		do_IRQ(AU1000_USB_DEV_REQ_INT, regs);
 		return;
 	}
+#endif
 
 	irq = au_ffs(intc0_req0) - 1;
 	intc0_req0 &= ~(1<<irq);
Index: linux-2.6.10/arch/mips/au1000/common/platform.c
===================================================================
--- linux-2.6.10.orig/arch/mips/au1000/common/platform.c
+++ linux-2.6.10/arch/mips/au1000/common/platform.c
@@ -13,8 +13,9 @@
 #include <linux/init.h>
 #include <linux/resource.h>
 
-#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx.h>
 
+/* OHCI (USB full speed host controller) */
 static struct resource au1xxx_usb_ohci_resources[] = {
 	[0] = {
 		.start		= USB_OHCI_BASE,
@@ -42,8 +43,248 @@ static struct platform_device au1xxx_usb
 	.resource	= au1xxx_usb_ohci_resources,
 };
 
+/*** AU1100 LCD controller ***/
+
+#ifdef CONFIG_FB_AU1100
+static struct resource au1100_lcd_resources[] = {
+	[0] = {
+		.start          = LCD_PHYS_ADDR,
+		.end            = LCD_PHYS_ADDR + 0x800 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = AU1100_LCD_INT,
+		.end            = AU1100_LCD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 au1100_lcd_dmamask = ~(u32)0;
+
+static struct platform_device au1100_lcd_device = {
+	.name           = "au1100-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &au1100_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1100_lcd_resources),
+	.resource       = au1100_lcd_resources,
+};
+#endif
+
+#ifdef CONFIG_SOC_AU1200
+/* EHCI (USB high speed host controller) */
+static struct resource au1xxx_usb_ehci_resources[] = {
+	[0] = {
+		.start		= USB_EHCI_BASE,
+		.end		= USB_EHCI_BASE + USB_EHCI_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1000_USB_HOST_INT,
+		.end		= AU1000_USB_HOST_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_ehci_device = {
+	.name		= "au1xxx-ehci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_ehci_resources),
+	.resource	= au1xxx_usb_ehci_resources,
+};
+
+/* Au1200 UDC (USB gadget controller) */
+static struct resource au1xxx_usb_gdt_resources[] = {
+	[0] = {
+		.start		= USB_UDC_BASE,
+		.end		= USB_UDC_BASE + USB_UDC_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1200_USB_INT,
+		.end		= AU1200_USB_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource au1xxx_mmc_resources[] = {
+	[0] = {
+		.start          = SD0_PHYS_ADDR,
+		.end            = SD0_PHYS_ADDR + 0x40,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= SD1_PHYS_ADDR,
+		.end 		= SD1_PHYS_ADDR + 0x40,
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start          = AU1200_SD_INT,
+		.end            = AU1200_SD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_gdt_device = {
+	.name		= "au1xxx-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_gdt_resources),
+	.resource	= au1xxx_usb_gdt_resources,
+};
+
+/* Au1200 UOC (USB OTG controller) */
+static struct resource au1xxx_usb_otg_resources[] = {
+	[0] = {
+		.start		= USB_UOC_BASE,
+		.end		= USB_UOC_BASE + USB_UOC_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1200_USB_INT,
+		.end		= AU1200_USB_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 uoc_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_otg_device = {
+	.name		= "au1xxx-uoc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &uoc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_otg_resources),
+	.resource	= au1xxx_usb_otg_resources,
+};
+
+static struct resource au1200_lcd_resources[] = {
+	[0] = {
+		.start          = LCD_PHYS_ADDR,
+		.end            = LCD_PHYS_ADDR + 0x800 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = AU1200_LCD_INT,
+		.end            = AU1200_LCD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource au1200_ide0_resources[] = {
+	[0] = {
+		.start		= AU1XXX_ATA_PHYS_ADDR, 
+		.end 		= AU1XXX_ATA_PHYS_ADDR + AU1XXX_ATA_PHYS_LEN,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1XXX_ATA_INT,
+		.end		= AU1XXX_ATA_INT,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static u64 au1200_lcd_dmamask = ~(u32)0;
+
+static struct platform_device au1200_lcd_device = {
+	.name           = "au1200-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &au1200_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1200_lcd_resources),
+	.resource       = au1200_lcd_resources,
+};
+
+
+static u64 ide0_dmamask = ~(u32)0;
+
+static struct platform_device au1200_ide0_device = {
+	.name		= "au1200-ide",
+	.id		= 0,
+	.dev = {
+		.dma_mask 		= &ide0_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources = ARRAY_SIZE(au1200_ide0_resources),
+	.resource	= au1200_ide0_resources,
+};
+
+static u64 au1xxx_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device au1xxx_mmc_device = {
+	.name = "au1xxx-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &au1xxx_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1xxx_mmc_resources),
+	.resource       = au1xxx_mmc_resources,
+};
+#endif /* #ifdef CONFIG_SOC_AU1200 */
+
+static struct platform_device au1x00_pcmcia_device = {
+	.name 		= "au1x00-pcmcia",
+	.id 		= 0,
+};
+
+#ifdef CONFIG_MIPS_DB1200
+ 
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.name	= "smc91x-regs",
+		.start	= AU1XXX_SMC91111_PHYS_ADDR,
+		.end	= AU1XXX_SMC91111_PHYS_ADDR + 0xfffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AU1XXX_SMC91111_IRQ,
+		.end	= AU1XXX_SMC91111_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+ 
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+ 	.id		= -1,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+ 
+#endif
+
+
 static struct platform_device *au1xxx_platform_devices[] __initdata = {
 	&au1xxx_usb_ohci_device,
+	&au1x00_pcmcia_device,
+#ifdef CONFIG_FB_AU1100
+	&au1100_lcd_device,
+#endif
+#ifdef CONFIG_SOC_AU1200
+	&au1200_lcd_device,
+	&au1200_ide0_device,
+ 	&au1xxx_mmc_device,
+#endif
+#ifdef CONFIG_MIPS_DB1200
+ 	&smc91x_device,
+#endif
 };
 
 int au1xxx_platform_init(void)
Index: linux-2.6.10/arch/mips/au1000/common/time.c
===================================================================
--- linux-2.6.10.orig/arch/mips/au1000/common/time.c
+++ linux-2.6.10/arch/mips/au1000/common/time.c
@@ -296,7 +296,13 @@ unsigned long cal_r4koff(void)
 		count = cpu_speed / 2;
 		no_au1xxx_32khz = 1;
 	}
+
+#ifdef CONFIG_SOC_AU1200
+	mips_hpt_frequency = cpu_speed;
+#else
 	mips_hpt_frequency = count;
+#endif
+
 	// Equation: Baudrate = CPU / (SD * 2 * CLKDIV * 16)
 	set_au1x00_uart_baud_base(cpu_speed / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
 	spin_unlock_irqrestore(&time_lock, flags);
Index: linux-2.6.10/arch/mips/au1000/pb1200/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/au1000/pb1200/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the Alchemy Semiconductor PB1200 board.
+#
+
+lib-y := init.o board_setup.o irqmap.o
Index: linux-2.6.10/arch/mips/au1000/pb1200/board_setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/au1000/pb1200/board_setup.c
@@ -0,0 +1,202 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Alchemy Pb1200/Db1200 board setup.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#include <linux/ide.h>
+#endif
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_ETH_INT DB1200_ETH_INT
+#define PB1200_IDE_INT DB1200_IDE_INT
+#endif
+
+extern unsigned int mips_hpt_frequency;
+
+extern void _board_init_irq(void);
+extern void	(*board_init_irq)(void);
+
+void board_reset (void)
+{
+	bcsr->resets = 0;
+	bcsr->system = 0;
+}
+
+void __init board_setup(void)
+{
+	char *argptr = NULL;
+	u32 pin_func;
+	u32 sys_freqctrl, sys_clksrc;
+	u32 cpu_speed;
+
+#if 0
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+	au_writel(pin_func, SYS_PINFUNC);
+
+	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
+#endif
+
+#if defined(CONFIG_I2C_AU1550)
+	{
+	u32 freq0, clksrc;
+
+	/* Select SMBUS in CPLD */
+	bcsr->resets &= ~(BCSR_RESETS_PCS0MUX);
+
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func &= ~(3<<17 | 1<<4);
+	/* Set GPIOs correctly */
+	pin_func |= 2<<17;
+	au_writel(pin_func, SYS_PINFUNC);
+	au_sync();
+
+	/* The i2c driver depends on 50Mhz clock */
+	freq0 = au_readl(SYS_FREQCTRL0);
+	au_sync();
+	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
+	/* 396Mhz / (3+1)*2 == 49.5Mhz */
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+	freq0 |= SYS_FC_FE1;
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+
+	clksrc = au_readl(SYS_CLKSRC);
+	au_sync();
+	clksrc &= ~0x01f00000;
+	/* bit 22 is EXTCLK0 for PSC0 */
+	clksrc |= (0x3 << 22);
+	au_writel(clksrc, SYS_CLKSRC);
+	au_sync();
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1200
+	argptr = prom_getcmdline();
+#ifdef CONFIG_MIPS_PB1200
+	strcat(argptr, " video=au1200fb:panel:bs");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	strcat(argptr, " video=au1200fb:panel:bs");
+#endif
+#endif
+
+	/* The Pb1200 development board uses external MUX for PSC0 to
+	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	*/
+#if defined(CONFIG_AU1XXX_PSC_SPI) && defined(CONFIG_I2C_AU1550)
+	#error I2C and SPI are mutually exclusive. Both are physically connected to PSC0.\
+			Refer to Pb1200/Db1200 documentation.
+#elif defined( CONFIG_AU1XXX_PSC_SPI )
+	bcsr->resets |= BCSR_RESETS_PCS0MUX;
+	/*Hard Coding Value to enable Temp Sensors [bit 14] Value for SOC Au1200. Pls refer documentation*/
+	  bcsr->resets =0x900f;	  
+#elif defined( CONFIG_I2C_AU1550 )
+	bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+#endif
+	au_sync();
+
+#ifdef CONFIG_MIPS_PB1200
+	printk("AMD Alchemy Pb1200 Board\n");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	printk("AMD Alchemy Db1200 Board\n");
+#endif
+
+	/* Setup Pb1200 External Interrupt Controller */
+	{
+		extern void (*board_init_irq)(void);
+		extern void _board_init_irq(void);
+		board_init_irq = _board_init_irq;
+	}
+
+	cpu_speed = (au_readl(SYS_CPUPLL) & 0x0000003f) * 12000000;
+
+	mips_hpt_frequency = cpu_speed;
+
+}
+
+int
+board_au1200fb_panel (void)
+{
+	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	int p;
+
+	p = bcsr->switches;
+	p >>= 8;
+	p &= 0x0F;
+	return p;
+}
+
+int
+board_au1200fb_panel_init (void)
+{
+	/* Apply power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board |= (BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	/*printk("board_au1200fb_panel_init()\n"); */
+	return 0;
+}
+
+int
+board_au1200fb_panel_shutdown (void)
+{
+	/* Remove power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board &= ~(BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	/*printk("board_au1200fb_panel_shutdown()\n"); */
+	return 0;
+}
+
Index: linux-2.6.10/arch/mips/au1000/pb1200/init.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/au1000/pb1200/init.c
@@ -0,0 +1,69 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	PB1200 board setup
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "Alchemy Pb1200";
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_PB1200;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x08000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
Index: linux-2.6.10/arch/mips/au1000/pb1200/irqmap.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/au1000/pb1200/irqmap.c
@@ -0,0 +1,184 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/mach-au1x00/au1000.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_INT_BEGIN DB1200_INT_BEGIN
+#define PB1200_INT_END DB1200_INT_END
+#endif
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 }, // This is exteranl interrupt cascade
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+/*
+ *	Support for External interrupts on the PbAu1200 Development platform.
+ */
+static volatile int pb1200_cascade_en=0;
+
+irqreturn_t pb1200_cascade_handler( int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned short bisr = bcsr->int_status;
+	int extirq_nr = 0;
+
+	/* Clear all the edge interrupts. This has no effect on level */
+	bcsr->int_status = bisr;
+	for( ; bisr; bisr &= (bisr-1) )
+	{
+		extirq_nr = (PB1200_INT_BEGIN-1) + au_ffs(bisr);
+		/* Ack and dispatch IRQ */
+
+		do_IRQ(extirq_nr,regs);
+	}
+
+	return IRQ_RETVAL(1);
+}
+
+inline void pb1200_enable_irq(unsigned int irq_nr)
+{
+	bcsr->intset_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+inline void pb1200_disable_irq(unsigned int irq_nr)
+{
+	bcsr->intclr_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+static unsigned int pb1200_startup_irq( unsigned int irq_nr )
+{
+	if (++pb1200_cascade_en == 1)
+	{
+		request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
+			SA_NODELAY | SA_INTERRUPT, "Pb1200 Cascade", (void *)&pb1200_cascade_handler );
+#ifdef CONFIG_MIPS_PB1200
+    /* We have a problem with CPLD rev3. Enable a workaround */
+	if( ((bcsr->whoami & BCSR_WHOAMI_CPLD)>>4) <= 3)
+	{
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("Pb1200 must be at CPLD rev4. Please have Pb1200\n");
+		printk("updated to latest revision. This software will not\n");
+		printk("work on anything less than CPLD rev4\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		while(1);
+	}
+#endif
+	}
+	pb1200_enable_irq(irq_nr);
+	return 0;
+}
+
+static void pb1200_shutdown_irq( unsigned int irq_nr )
+{
+	pb1200_disable_irq(irq_nr);
+	if (--pb1200_cascade_en == 0)
+	{
+		free_irq(AU1000_GPIO_7,&pb1200_cascade_handler );
+	}
+	return;
+}
+
+static inline void pb1200_mask_and_ack_irq(unsigned int irq_nr)
+{
+	pb1200_disable_irq( irq_nr );
+}
+
+static void pb1200_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pb1200_enable_irq(irq_nr);
+	}
+}
+
+static struct hw_interrupt_type external_irq_type =
+{
+#ifdef CONFIG_MIPS_PB1200
+	"Pb1200 Ext",
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	"Db1200 Ext",
+#endif
+	pb1200_startup_irq,
+	pb1200_shutdown_irq,
+	pb1200_enable_irq,
+	pb1200_disable_irq,
+	pb1200_mask_and_ack_irq,
+	pb1200_end_irq,
+	NULL
+};
+
+void _board_init_irq(void)
+{
+	int irq_nr;
+
+	for (irq_nr = PB1200_INT_BEGIN; irq_nr <= PB1200_INT_END; irq_nr++)
+	{
+		irq_desc[irq_nr].handler = &external_irq_type;
+		pb1200_disable_irq(irq_nr);
+	}
+
+	/* GPIO_7 can not be hooked here, so it is hooked upon first
+	request of any source attached to the cascade */
+}
+
Index: linux-2.6.10/arch/mips/kernel/cpu-probe.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/cpu-probe.c
+++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
@@ -118,6 +118,7 @@ static inline void check_wait(void)
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
+	case CPU_AU1200:
 		if (au1k_wait_ptr != NULL) {
 			cpu_wait = au1k_wait_ptr;
 			printk(" available.\n");
@@ -517,6 +518,9 @@ static inline void cpu_probe_alchemy(str
 		case 3:
 			c->cputype = CPU_AU1550;
 			break;
+		case 4:
+			c->cputype = CPU_AU1200;
+			break;
 		default:
 			panic("Unknown Au Core!");
 			break;
Index: linux-2.6.10/arch/mips/kernel/proc.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/proc.c
+++ linux-2.6.10/arch/mips/kernel/proc.c
@@ -60,6 +60,7 @@ static const char *cpu_name[] = {
 	[CPU_TX3927]	"TX3927",
 	[CPU_AU1000]	"Au1000",
 	[CPU_AU1500]	"Au1500",
+	[CPU_AU1200]	"Au1200",
 	[CPU_4KEC]	"MIPS 4KEc",
 	[CPU_4KSC]	"MIPS 4KSc",
 	[CPU_VR41XX]	"NEC Vr41xx",
Index: linux-2.6.10/arch/mips/mm/c-r4k.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/c-r4k.c
+++ linux-2.6.10/arch/mips/mm/c-r4k.c
@@ -1026,6 +1026,7 @@ static void __init probe_pcache(void)
 		break;
 
 	case CPU_AU1500:
+	case CPU_AU1200:
 		c->icache.flags |= MIPS_CACHE_IC_F_DC;
 		break;
 	}
Index: linux-2.6.10/arch/mips/mm/tlbex.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/tlbex.c
+++ linux-2.6.10/arch/mips/mm/tlbex.c
@@ -909,6 +909,7 @@ static __init void build_tlb_write_entry
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
+	case CPU_AU1200:
 	case CPU_PR4450:
 		i_nop(p);
 		tlbw(p);
Index: linux-2.6.10/drivers/ide/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/ide/Kconfig
+++ linux-2.6.10/drivers/ide/Kconfig
@@ -781,6 +781,35 @@ config BLK_DEV_IDE_SWARM
 	bool "IDE for Sibyte evaluation boards"
 	depends on SIBYTE_SB1xxx_SOC
 
+config BLK_DEV_IDE_AU1XXX
+	bool "IDE for AMD Alchemy Au1200"
+	depends on SOC_AU1200
+choice
+	prompt "IDE Mode for AMD Alchemy Au1200"
+	default CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+	depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
+
+config BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+	bool "PIO+DbDMA IDE for AMD Alchemy Au1200"
+
+config BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	bool "MDMA2+DbDMA IDE for AMD Alchemy Au1200"
+	depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
+endchoice
+
+config BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+	bool "Enable burstable Mode on DbDMA"
+	default false
+	depends BLK_DEV_IDE_AU1XXX
+	help
+	  This option enable the burstable Flag on DbDMA controller
+	  (cf. "AMD Alchemy 'Au1200' Processor Data Book - PRELIMINARY").
+                                                                                                                         
+config BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
+	int "Maximum transfer size (KB) per request (up to 128)"
+	default "128"
+	depends BLK_DEV_IDE_AU1XXX
+
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
Index: linux-2.6.10/drivers/ide/ide-proc.c
===================================================================
--- linux-2.6.10.orig/drivers/ide/ide-proc.c
+++ linux-2.6.10/drivers/ide/ide-proc.c
@@ -65,6 +65,7 @@ static int proc_ide_read_imodel
 		case ide_4drives:	name = "4drives";	break;
 		case ide_pmac:		name = "mac-io";	break;
 		case ide_tx4939:	name = "tx4939";	break;
+		case ide_au1xxx:	name = "au1xxx";	break;
 		default:		name = "(unknown)";	break;
 	}
 	len = sprintf(page, "%s\n", name);
Index: linux-2.6.10/drivers/ide/mips/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/ide/mips/Makefile
+++ linux-2.6.10/drivers/ide/mips/Makefile
@@ -1,5 +1,6 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= ide-tx4939.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4938)	+= ide-tx4938.o
+obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 
 EXTRA_CFLAGS	:= -I../
Index: linux-2.6.10/drivers/ide/mips/au1xxx-ide.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/ide/mips/au1xxx-ide.c
@@ -0,0 +1,1250 @@
+/*
+ * linux/drivers/ide/mips/au1xxx-ide.c  version 01.30.00        Aug. 02 2005
+ *
+ * BRIEF MODULE DESCRIPTION
+ * AMD Alchemy Au1xxx IDE interface routines over the Static Bus
+ *
+ * Copyright (c) 2003-2005 AMD, Personal Connectivity Solutions
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
+ *       Interface and Linux Device Driver" Application Note.
+ */
+#undef REALLY_SLOW_IO           /* most systems can safely undef this */
+
+#include <linux/config.h>       /* for CONFIG_BLK_DEV_IDEPCI */
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/sysdev.h>
+
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/mach-au1x00/au1xxx.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#if CONFIG_PM
+#include <asm/mach-au1x00/au1xxx_pm.h>
+#endif
+
+#include <asm/mach-au1x00/au1xxx_ide.h>
+
+#define DRV_NAME	"au1200-ide"
+#define DRV_VERSION	"1.0"
+#define DRV_AUTHOR	"AMD PCS / Pete Popov <ppopov@embeddedalley.com>"
+#define DRV_DESC	"Au1200 IDE"
+
+static _auide_hwif auide_hwif;
+static spinlock_t ide_tune_drive_spin_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t ide_tune_chipset_spin_lock = SPIN_LOCK_UNLOCKED;
+static int dbdma_init_done = 0;
+
+/*
+ * local I/O functions
+ */
+u8 auide_inb(unsigned long port)
+{
+        return (au_readb(port));
+}
+
+u16 auide_inw(unsigned long port)
+{
+        return (au_readw(port));
+}
+
+u32 auide_inl(unsigned long port)
+{
+        return (au_readl(port));
+}
+
+void auide_insw(unsigned long port, void *addr, u32 count)
+{
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+
+        _auide_hwif *ahwif = &auide_hwif;
+        chan_tab_t *ctp;
+        au1x_ddma_desc_t *dp;
+
+        if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1, 
+				DDMA_FLAGS_NOIE)) {
+                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+                return;
+        }
+        ctp = *((chan_tab_t **)ahwif->rx_chan);
+        dp = ctp->cur_ptr;
+        while (dp->dscr_cmd0 & DSCR_CMD0_V)
+                ;
+        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
+#else
+        while (count--)
+        {
+                *(u16 *)addr = au_readw(port);
+                addr +=2 ;
+        }
+#endif
+}
+
+void auide_insl(unsigned long port, void *addr, u32 count)
+{
+        while (count--)
+        {
+                *(u32 *)addr = au_readl(port);
+                /* NOTE: For IDE interfaces over PCMCIA,
+                 * 32-bit access does not work
+                 */
+                addr += 4;
+        }
+}
+
+void auide_outb(u8 addr, unsigned long port)
+{
+        return (au_writeb(addr, port));
+}
+
+void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port)
+{
+        return (au_writeb(addr, port));
+}
+
+void auide_outw(u16 addr, unsigned long port)
+{
+        return (au_writew(addr, port));
+}
+
+void auide_outl(u32 addr, unsigned long port)
+{
+        return (au_writel(addr, port));
+}
+
+void auide_outsw(unsigned long port, void *addr, u32 count)
+{
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+        _auide_hwif *ahwif = &auide_hwif;
+        chan_tab_t *ctp;
+        au1x_ddma_desc_t *dp;
+
+        if(!put_source_flags(ahwif->tx_chan, (void*)addr,
+                                          count << 1, DDMA_FLAGS_NOIE)) {
+                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+                return;
+        }
+        ctp = *((chan_tab_t **)ahwif->tx_chan);
+        dp = ctp->cur_ptr;
+        while (dp->dscr_cmd0 & DSCR_CMD0_V)
+                ;
+        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
+#else
+        while (count--)
+        {
+                au_writew(*(u16 *)addr, port);
+                addr += 2;
+        }
+#endif
+}
+
+void auide_outsl(unsigned long port, void *addr, u32 count)
+{
+        while (count--)
+        {
+                au_writel(*(u32 *)addr, port);
+                /* NOTE: For IDE interfaces over PCMCIA, 
+                 * 32-bit access does not work
+                 */
+                addr += 4;
+        }
+}
+
+static void auide_tune_drive(ide_drive_t *drive, byte pio)
+{
+        int mem_sttime;
+        int mem_stcfg;
+        unsigned long flags;
+        u8 speed;
+
+        /* get the best pio mode for the drive */
+        pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+
+        printk("%s: setting Au1XXX IDE to PIO mode%d\n",
+                drive->name, pio);
+
+        spin_lock_irqsave(&ide_tune_drive_spin_lock, flags);
+
+        mem_sttime = 0;
+        mem_stcfg  = au_readl(MEM_STCFG2);
+
+        /* set pio mode! */
+        switch(pio) {
+                case 0:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO0_TWCS
+                                     | SBC_IDE_PIO0_TCSH
+                                     | SBC_IDE_PIO0_TCSOFF
+                                     | SBC_IDE_PIO0_TWP
+                                     | SBC_IDE_PIO0_TCSW
+                                     | SBC_IDE_PIO0_TPM
+                                     | SBC_IDE_PIO0_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
+
+                        au_writel(mem_sttime,MEM_STTIME2);
+                        au_writel(mem_stcfg,MEM_STCFG2);
+                        break;
+
+                case 1:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO1_TWCS
+                                     | SBC_IDE_PIO1_TCSH
+                                     | SBC_IDE_PIO1_TCSOFF
+                                     | SBC_IDE_PIO1_TWP
+                                     | SBC_IDE_PIO1_TCSW
+                                     | SBC_IDE_PIO1_TPM
+                                     | SBC_IDE_PIO1_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
+                        break;
+
+                case 2:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO2_TWCS
+                                     | SBC_IDE_PIO2_TCSH
+                                     | SBC_IDE_PIO2_TCSOFF
+                                     | SBC_IDE_PIO2_TWP
+                                     | SBC_IDE_PIO2_TCSW
+                                     | SBC_IDE_PIO2_TPM
+                                     | SBC_IDE_PIO2_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
+                        break;
+
+                case 3:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO3_TWCS
+                                     | SBC_IDE_PIO3_TCSH
+                                     | SBC_IDE_PIO3_TCSOFF
+                                     | SBC_IDE_PIO3_TWP
+                                     | SBC_IDE_PIO3_TCSW
+                                     | SBC_IDE_PIO3_TPM
+                                     | SBC_IDE_PIO3_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
+
+                        break;
+
+                case 4:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO4_TWCS
+                                     | SBC_IDE_PIO4_TCSH
+                                     | SBC_IDE_PIO4_TCSOFF
+                                     | SBC_IDE_PIO4_TWP
+                                     | SBC_IDE_PIO4_TCSW
+                                     | SBC_IDE_PIO4_TPM
+                                     | SBC_IDE_PIO4_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
+                        break;
+        }
+
+        au_writel(mem_sttime,MEM_STTIME2);
+        au_writel(mem_stcfg,MEM_STCFG2);
+
+        spin_unlock_irqrestore(&ide_tune_drive_spin_lock, flags);
+
+        speed = pio + XFER_PIO_0;
+        ide_config_drive_speed(drive, speed);
+}
+
+static int auide_tune_chipset (ide_drive_t *drive, u8 speed)
+{
+        u8 mode = 0;
+        int mem_sttime;
+        int mem_stcfg;
+        unsigned long flags;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        struct hd_driveid *id = drive->id;
+
+        /*
+         * Now see what the current drive is capable of,
+         * selecting UDMA only if the mate said it was ok.
+         */
+        if (id && (id->capability & 1) && drive->autodma &&
+            !__ide_dma_bad_drive(drive)) {
+                if (!mode && (id->field_valid & 2) && (id->dma_mword & 7)) {
+                        if      (id->dma_mword & 4)
+                                mode = XFER_MW_DMA_2;
+                        else if (id->dma_mword & 2)
+                                mode = XFER_MW_DMA_1;
+                        else if (id->dma_mword & 1)
+                                mode = XFER_MW_DMA_0;
+                }
+        }
+#endif
+
+        spin_lock_irqsave(&ide_tune_chipset_spin_lock, flags);
+
+        mem_sttime = 0;
+        mem_stcfg  = au_readl(MEM_STCFG2);
+
+        switch(speed) {
+                case XFER_PIO_4:
+                case XFER_PIO_3:
+                case XFER_PIO_2:
+                case XFER_PIO_1:
+                case XFER_PIO_0:
+                        auide_tune_drive(drive, (speed - XFER_PIO_0));
+                        break;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+                case XFER_MW_DMA_2:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA2_TWCS
+                                     | SBC_IDE_MDMA2_TCSH
+                                     | SBC_IDE_MDMA2_TCSOFF
+                                     | SBC_IDE_MDMA2_TWP
+                                     | SBC_IDE_MDMA2_TCSW
+                                     | SBC_IDE_MDMA2_TPM
+                                     | SBC_IDE_MDMA2_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
+
+                        mode = XFER_MW_DMA_2;
+                        break;
+                case XFER_MW_DMA_1:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA1_TWCS
+                                     | SBC_IDE_MDMA1_TCSH
+                                     | SBC_IDE_MDMA1_TCSOFF
+                                     | SBC_IDE_MDMA1_TWP
+                                     | SBC_IDE_MDMA1_TCSW
+                                     | SBC_IDE_MDMA1_TPM
+                                     | SBC_IDE_MDMA1_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
+
+                        mode = XFER_MW_DMA_1;
+                        break;
+                case XFER_MW_DMA_0:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA0_TWCS
+                                     | SBC_IDE_MDMA0_TCSH
+                                     | SBC_IDE_MDMA0_TCSOFF
+                                     | SBC_IDE_MDMA0_TWP
+                                     | SBC_IDE_MDMA0_TCSW
+                                     | SBC_IDE_MDMA0_TPM
+                                     | SBC_IDE_MDMA0_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
+
+                        mode = XFER_MW_DMA_0;
+                        break;
+#endif
+                default:
+                        return 1;
+        }
+
+        /*
+         * Tell the drive to switch to the new mode; abort on failure.
+         */
+        if (!mode || ide_config_drive_speed(drive, mode))
+        {
+                return 1;       /* failure */
+        }
+
+
+        au_writel(mem_sttime,MEM_STTIME2);
+        au_writel(mem_stcfg,MEM_STCFG2);
+
+        spin_unlock_irqrestore(&ide_tune_chipset_spin_lock, flags);
+
+        return 0;
+}
+
+/*
+ * Multi-Word DMA + DbDMA functions
+ */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+
+static int in_drive_list(struct hd_driveid *id, 
+                         const struct drive_list_entry *drive_table)
+{
+        for ( ; drive_table->id_model ; drive_table++){
+                if ((!strcmp(drive_table->id_model, id->model)) &&
+                        ((strstr(drive_table->id_firmware, id->fw_rev)) ||
+                        (!strcmp(drive_table->id_firmware, "ALL")))
+                )
+                        return 1;
+        }
+        return 0;
+}
+
+static int auide_build_sglist(ide_drive_t *drive,  struct request *rq)
+{
+        ide_hwif_t *hwif = drive->hwif;
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+        struct scatterlist *sg = hwif->sg_table;
+
+        ide_map_sg(drive, rq);
+
+        if (rq_data_dir(rq) == READ)
+                hwif->sg_dma_direction = DMA_FROM_DEVICE;
+        else
+                hwif->sg_dma_direction = DMA_TO_DEVICE;
+
+        return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
+                          hwif->sg_dma_direction);
+}
+
+static int auide_build_dmatable(ide_drive_t *drive)
+{
+        int i, iswrite, count = 0;
+        ide_hwif_t *hwif = HWIF(drive);
+
+        struct request *rq = HWGROUP(drive)->rq;
+
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+        struct scatterlist *sg;
+
+        iswrite = (rq_data_dir(rq) == WRITE);
+        /* Save for interrupt context */
+        ahwif->drive = drive;
+
+        /* Build sglist */
+        hwif->sg_nents = i = auide_build_sglist(drive, rq);
+
+        if (!i)
+                return 0;
+
+        /* fill the descriptors */
+        sg = hwif->sg_table;
+        while (i && sg_dma_len(sg)) {
+                u32 cur_addr;
+                u32 cur_len;
+
+                cur_addr = sg_dma_address(sg);
+                cur_len = sg_dma_len(sg);
+
+                while (cur_len) {
+                        u32 flags = DDMA_FLAGS_NOIE;
+                        unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
+
+                        if (++count >= PRD_ENTRIES) {
+                                printk(KERN_WARNING "%s: DMA table too small\n",
+                                drive->name);
+                                goto use_pio_instead;
+                        }
+
+                        /* Lets enable intr for the last descriptor only */
+                        if (1==i)
+                                flags = DDMA_FLAGS_IE;
+                        else
+                                flags = DDMA_FLAGS_NOIE;
+
+                        if (iswrite) {
+				if(!put_source_flags(ahwif->tx_chan, 
+						(void*)(page_address(sg->page) 
+							+ sg->offset), 
+						tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+							__FUNCTION__, __LINE__);
+				}
+                        } else 
+			{
+				if(!put_dest_flags(ahwif->rx_chan, 
+						(void*)(page_address(sg->page) 
+							+ sg->offset), 
+						tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+							__FUNCTION__, __LINE__);
+				}
+                        }
+
+                        cur_addr += tc;
+                        cur_len -= tc;
+                }
+                sg++;
+                i--;
+        }
+
+        if (count)
+                return 1;
+
+use_pio_instead:
+        dma_unmap_sg(ahwif->dev,
+                     hwif->sg_table,
+                     hwif->sg_nents,
+                     hwif->sg_dma_direction);
+
+        return 0; /* revert to PIO for this request */
+}
+
+static int auide_dma_end(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+
+        if (hwif->sg_nents) {
+                dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
+                             hwif->sg_dma_direction);
+                hwif->sg_nents = 0;
+        }
+
+        return 0;
+}
+
+static void auide_dma_start(ide_drive_t *drive )
+{
+//      printk("%s\n", __FUNCTION__);
+}
+
+ide_startstop_t auide_dma_intr(ide_drive_t *drive)
+{
+        //printk("%s\n", __FUNCTION__);
+
+        u8 stat = 0, dma_stat = 0;
+
+        dma_stat = HWIF(drive)->ide_dma_end(drive);
+        stat = HWIF(drive)->INB(IDE_STATUS_REG);        /* get drive status */
+        if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+                if (!dma_stat) {
+                        struct request *rq = HWGROUP(drive)->rq;
+
+                        ide_end_request(drive, 1, rq->nr_sectors);
+                        return ide_stopped;
+                }
+                printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+                                 drive->name, dma_stat);
+        }
+        return ide_error(drive, "dma_intr", stat);
+}
+
+static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+        //printk("%s\n", __FUNCTION__);
+
+        /* issue cmd to drive */
+        ide_execute_command(drive, command, &auide_dma_intr,
+                            (2*WAIT_CMD), NULL);
+}
+
+static int auide_dma_setup(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        if (drive->media != ide_disk)
+                return 1;
+
+        if (!auide_build_dmatable(drive))
+                        /* try PIO instead of DMA */
+                        return 1;
+
+        drive->waiting_for_dma = 1;
+
+        return 0;
+}
+
+static int auide_dma_check(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        if( !dbdma_init_done ){
+                auide_hwif.white_list = in_drive_list(drive->id,
+                                                      dma_white_list);
+                auide_hwif.black_list = in_drive_list(drive->id,
+                                                      dma_black_list);
+                auide_hwif.drive = drive;
+                auide_ddma_init(&auide_hwif);
+                dbdma_init_done = 1;
+        }
+#endif
+
+        /* Is the drive in our DMA black list? */
+        if ( auide_hwif.black_list ) {
+                drive->using_dma = 0;
+                printk("%s found in dma_blacklist[]! Disabling DMA.\n",
+                drive->id->model);
+        }
+        else
+                drive->using_dma = 1;
+
+        return HWIF(drive)->ide_dma_host_on(drive);
+}
+
+static int auide_dma_test_irq(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        if (!drive->waiting_for_dma)
+                printk(KERN_WARNING "%s: ide_dma_test_irq \
+                                     called while not waiting\n", drive->name);
+
+        /* If dbdma didn't execute the STOP command yet, the
+         * active bit is still set
+	 */
+        drive->waiting_for_dma++;
+        if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
+                printk(KERN_WARNING "%s: timeout waiting for ddma to \
+                                     complete\n", drive->name);
+                return 1;
+        }
+        udelay(10);
+        return 0;
+}
+
+static int auide_dma_host_on(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        return 0;
+}
+
+static int auide_dma_on(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        drive->using_dma = 1;
+        return auide_dma_host_on(drive);
+}
+
+
+static int auide_dma_host_off(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        return 0;
+}
+
+static int auide_dma_off_quietly(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        drive->using_dma = 0;
+        return auide_dma_host_off(drive);
+}
+
+static int auide_dma_lostirq(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        printk(KERN_ERR "%s: IRQ lost\n", drive->name);
+        return 0;
+}
+
+static void auide_ddma_tx_callback(int irq, void *param, struct pt_regs *regs)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        _auide_hwif *ahwif = (_auide_hwif*)param;
+        ahwif->drive->waiting_for_dma = 0;
+        return;
+}
+
+static void auide_ddma_rx_callback(int irq, void *param, struct pt_regs *regs)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        _auide_hwif *ahwif = (_auide_hwif*)param;
+        ahwif->drive->waiting_for_dma = 0;
+        return;
+}
+
+static int auide_dma_timeout(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
+
+        if (HWIF(drive)->ide_dma_test_irq(drive))
+                return 0;
+
+        return HWIF(drive)->ide_dma_end(drive);
+}
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+
+static int auide_ddma_init( _auide_hwif *auide )
+{
+//      printk("%s\n", __FUNCTION__);
+
+        dbdev_tab_t source_dev_tab;
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        dbdev_tab_t target_dev_tab;
+        ide_hwif_t *hwif = auide->hwif;
+        char warning_output [2][80];
+        int i;
+#endif
+
+        /* Add our custom device to DDMA device table */
+        /* Create our new device entries in the table */
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        source_dev_tab.dev_id = AU1XXX_ATA_DDMA_REQ;
+
+        if( auide->white_list || auide->black_list ){
+                source_dev_tab.dev_tsize       = 8;
+                source_dev_tab.dev_devwidth    = 32;
+                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                source_dev_tab.dev_intlevel    = 0;
+                source_dev_tab.dev_intpolarity = 0;
+
+                /* init device table for target - static bus controller - */
+                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
+                target_dev_tab.dev_tsize       = 8;
+                target_dev_tab.dev_devwidth    = 32;
+                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                target_dev_tab.dev_intlevel    = 0;
+                target_dev_tab.dev_intpolarity = 0;
+                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
+        }
+        else{
+                source_dev_tab.dev_tsize       = 1;
+                source_dev_tab.dev_devwidth    = 16;
+                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                source_dev_tab.dev_intlevel    = 0;
+                source_dev_tab.dev_intpolarity = 0;
+
+                /* init device table for target - static bus controller - */
+                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
+                target_dev_tab.dev_tsize       = 1;
+                target_dev_tab.dev_devwidth    = 16;
+                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                target_dev_tab.dev_intlevel    = 0;
+                target_dev_tab.dev_intpolarity = 0;
+                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
+
+                sprintf(&warning_output[0][0],
+                        "%s is not on ide driver white list.",
+                        auide_hwif.drive->id->model);
+                for ( i=strlen(&warning_output[0][0]) ; i<76; i++ ){
+                        sprintf(&warning_output[0][i]," ");
+                }
+
+                sprintf(&warning_output[1][0],
+                "To add %s please read 'Documentation/mips/AU1xxx_IDE.README'.",
+                        auide_hwif.drive->id->model);
+                for ( i=strlen(&warning_output[1][0]) ; i<76; i++ ){
+                        sprintf(&warning_output[1][i]," ");
+                }
+
+                printk("\n****************************************");
+                printk("****************************************\n");
+                printk("* %s *\n",&warning_output[0][0]);
+                printk("* Switch to safe MWDMA Mode!            ");
+                printk("                                       *\n");
+                printk("* %s *\n",&warning_output[1][0]);
+                printk("****************************************");
+                printk("****************************************\n\n");        
+        }
+#else
+        source_dev_tab.dev_id = DSCR_CMD0_ALWAYS;
+        source_dev_tab.dev_tsize       = 8;
+        source_dev_tab.dev_devwidth    = 32;
+        source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+        source_dev_tab.dev_intlevel    = 0;
+        source_dev_tab.dev_intpolarity = 0;
+#endif
+
+#if CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+        /* set flags for tx channel */
+        source_dev_tab.dev_flags =  DEV_FLAGS_OUT
+                                  | DEV_FLAGS_SYNC
+                                  | DEV_FLAGS_BURSTABLE;
+        auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+        /* set flags for rx channel */
+        source_dev_tab.dev_flags =  DEV_FLAGS_IN
+                                  | DEV_FLAGS_SYNC
+                                  | DEV_FLAGS_BURSTABLE;
+        auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+#else
+        /* set flags for tx channel */
+        source_dev_tab.dev_flags = DEV_FLAGS_OUT | DEV_FLAGS_SYNC;
+        auide->tx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
+        /* set flags for rx channel */
+        source_dev_tab.dev_flags = DEV_FLAGS_IN | DEV_FLAGS_SYNC;
+        auide->rx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
+#endif
+
+#if  defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+
+        auide->target_dev_id           = au1xxx_ddma_add_device(&target_dev_tab);
+
+        /* Get a channel for TX */
+        auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
+                                                 auide->tx_dev_id,
+                                                 auide_ddma_tx_callback,
+                                                 (void*)auide);
+        /* Get a channel for RX */
+        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+                                                 auide->target_dev_id, 
+                                                 auide_ddma_rx_callback, 
+                                                 (void*)auide);
+#else   /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
+        /*
+         * Note: if call back is not enabled, update ctp->cur_ptr manually 
+         */
+        auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
+                                                 auide->tx_dev_id,
+                                                 NULL, 
+                                                 (void*)auide);
+        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+                                                 DSCR_CMD0_ALWAYS,
+                                                 NULL,
+                                                 (void*)auide);
+#endif
+        auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan, 
+                                                             NUM_DESCRIPTORS);
+        auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan, 
+                                                             NUM_DESCRIPTORS);
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
+                                                PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
+                                                &hwif->dmatable_dma, GFP_KERNEL);
+
+        auide->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
+                                GFP_KERNEL|GFP_DMA);
+        if (auide->sg_table == NULL) {
+                return -ENOMEM;
+        }
+#endif
+        au1xxx_dbdma_start( auide->tx_chan );
+        au1xxx_dbdma_start( auide->rx_chan );
+        return 0;
+}
+
+static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif)
+{
+        int i;
+#define ide_ioreg_t unsigned long
+        ide_ioreg_t *ata_regs = hw->io_ports;
+
+	/* fixme */
+        for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
+                *ata_regs++ = (ide_ioreg_t) ahwif->regbase 
+                            + (ide_ioreg_t)(i << AU1XXX_ATA_REG_OFFSET);
+        }
+
+        /* set the Alternative Status register */
+        *ata_regs = (ide_ioreg_t) ahwif->regbase
+                  + (ide_ioreg_t)(14 << AU1XXX_ATA_REG_OFFSET);
+}
+
+static int au_ide_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+        _auide_hwif *ahwif = &auide_hwif;
+        ide_hwif_t *hwif;
+	struct resource *res;
+	int ret = 0;
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        char *mode = "MWDMA2";
+#elif defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+        char *mode = "PIO+DDMA(offload)";
+#endif
+
+        memset(&auide_hwif, 0, sizeof(_auide_hwif));
+        auide_hwif.dev                  = 0;
+
+	ahwif->dev = dev;
+	ahwif->irq = platform_get_irq(pdev, 0);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		pr_debug("%s %d: no base address\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto out;
+	}
+
+        if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
+		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
+                ret =  -EBUSY;
+		goto out;
+        }
+
+	ahwif->regbase = (u32)ioremap(res->start, res->end-res->start);
+	if (ahwif->regbase == 0) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+        hwif                            = &ide_hwifs[pdev->id];
+	hw_regs_t *hw 			= &hwif->hw;
+        hwif->irq = hw->irq             = ahwif->irq;
+        hwif->chipset                   = ide_au1xxx;
+
+        auide_setup_ports(hw, ahwif);
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
+        hwif->rqsize = CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ;
+        hwif->rqsize                    = ((hwif->rqsize > AU1XXX_ATA_RQSIZE) 
+                                        || (hwif->rqsize < 32)) ? AU1XXX_ATA_RQSIZE : hwif->rqsize;
+#else /* if kernel config is not set */
+        hwif->rqsize                    = AU1XXX_ATA_RQSIZE;
+#endif
+
+        hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
+        hwif->swdma_mask                = 0x07;
+#else
+        hwif->mwdma_mask                = 0x0;
+        hwif->swdma_mask                = 0x0;
+#endif
+        //hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+        hwif->noprobe = 0;
+        hwif->drives[0].unmask          = 1;
+        hwif->drives[1].unmask          = 1;
+
+        /* hold should be on in all cases */
+        hwif->hold                      = 1;
+        hwif->mmio                      = 2;
+
+        /* set up local I/O function entry points */
+        hwif->INB                       = auide_inb;
+        hwif->INW                       = auide_inw;
+        hwif->INL                       = auide_inl;
+        hwif->INSW                      = auide_insw;
+        hwif->INSL                      = auide_insl;
+        hwif->OUTB                      = auide_outb;
+        hwif->OUTBSYNC                  = auide_outbsync;
+        hwif->OUTW                      = auide_outw;
+        hwif->OUTL                      = auide_outl;
+        hwif->OUTSW                     = auide_outsw;
+        hwif->OUTSL                     = auide_outsl;
+
+        hwif->tuneproc                  = &auide_tune_drive;
+        hwif->speedproc                 = &auide_tune_chipset;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
+        hwif->ide_dma_timeout           = &auide_dma_timeout;
+
+        hwif->ide_dma_check             = &auide_dma_check;
+        hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
+        hwif->dma_start                 = &auide_dma_start;
+        hwif->ide_dma_end               = &auide_dma_end;
+        hwif->dma_setup                 = &auide_dma_setup;
+        hwif->ide_dma_test_irq          = &auide_dma_test_irq;
+        hwif->ide_dma_host_off          = &auide_dma_host_off;
+        hwif->ide_dma_host_on           = &auide_dma_host_on;
+        hwif->ide_dma_lostirq           = &auide_dma_lostirq;
+        hwif->ide_dma_on                = &auide_dma_on;
+
+        hwif->autodma                   = 1;
+        hwif->drives[0].autodma         = hwif->autodma;
+        hwif->drives[1].autodma         = hwif->autodma;
+        hwif->atapi_dma                 = 1;
+        hwif->drives[0].using_dma       = 1;
+        hwif->drives[1].using_dma       = 1;
+#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+        hwif->autodma                   = 0;
+        hwif->channel                   = 0;
+        hwif->hold                      = 1;
+        hwif->select_data               = 0;    /* no chipset-specific code */
+        hwif->config_data               = 0;    /* no chipset-specific code */
+
+        hwif->drives[0].autodma         = 0;
+        hwif->drives[0].drive_data      = 0;    /* no drive data */
+        hwif->drives[0].using_dma       = 0;
+        hwif->drives[0].waiting_for_dma = 0;
+        hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
+        /* secondary hdd not supported */
+        hwif->drives[1].autodma         = 0;
+
+        hwif->drives[1].drive_data      = 0;
+        hwif->drives[1].using_dma       = 0;
+        hwif->drives[1].waiting_for_dma = 0;
+        hwif->drives[1].autotune        = 2;   /* 1=autotune, 2=noautotune, 0=default */
+#endif
+        hwif->drives[0].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+        hwif->drives[1].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+
+        /*Register Driver with PM Framework*/
+#ifdef CONFIG_PM
+        auide_hwif.pm.lock    = SPIN_LOCK_UNLOCKED;
+        auide_hwif.pm.stopped = 0;
+
+        auide_hwif.pm.dev = new_au1xxx_power_device( "ide",
+                                                &au1200ide_pm_callback,
+                                                NULL);
+        if ( auide_hwif.pm.dev == NULL )
+                printk(KERN_INFO "Unable to create a power management \
+                                device entry for the au1200-IDE.\n");
+        else
+                printk(KERN_INFO "Power management device entry for the \
+                                au1200-IDE loaded.\n");
+#endif
+
+        auide_hwif.hwif                 = hwif;
+        hwif->hwif_data                 = &auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA           
+        auide_ddma_init(&auide_hwif);
+        dbdma_init_done = 1;
+#endif
+
+	probe_hwif_init(hwif);
+	dev_set_drvdata(dev, hwif);
+
+        printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
+
+out:
+        return ret;
+}
+
+static int au_ide_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	ide_hwif_t *hwif = dev_get_drvdata(dev);
+        _auide_hwif *ahwif = &auide_hwif;
+
+	ide_unregister(hwif - ide_hwifs);
+
+	iounmap((void *)ahwif->regbase);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start);
+
+	return 0;
+}
+
+static struct device_driver au1200_ide_driver = {
+	.name		= "au1200-ide",
+	.bus		= &platform_bus_type,
+	.probe 		= au_ide_probe,
+	.remove		= au_ide_remove,
+};
+
+static int __init au_ide_init(void)
+{
+	return driver_register(&au1200_ide_driver);
+}
+
+static void __init au_ide_exit(void)
+{
+	driver_unregister(&au1200_ide_driver);
+}
+
+#ifdef CONFIG_PM
+int au1200ide_pm_callback( au1xxx_power_dev_t *dev,\
+                        au1xxx_request_t request, void *data) {
+
+        unsigned int d, err = 0;
+        unsigned long flags;
+
+        spin_lock_irqsave(auide_hwif.pm.lock, flags);
+
+        switch (request){
+                case AU1XXX_PM_SLEEP:
+                        err = au1xxxide_pm_sleep(dev);
+                        break;
+                case AU1XXX_PM_WAKEUP:
+                        d = *((unsigned int*)data);
+                        if ( d > 0 && d <= 99) {
+                                err = au1xxxide_pm_standby(dev);
+                        }
+                        else {
+                                err = au1xxxide_pm_resume(dev);
+                        }
+                        break;
+                case AU1XXX_PM_GETSTATUS:
+                        err = au1xxxide_pm_getstatus(dev);
+                        break;
+                case AU1XXX_PM_ACCESS:
+                        err = au1xxxide_pm_access(dev);
+                        break;
+                case AU1XXX_PM_IDLE:
+                        err = au1xxxide_pm_idle(dev);
+                        break;
+                case AU1XXX_PM_CLEANUP:
+                        err = au1xxxide_pm_cleanup(dev);
+                        break;
+                default:
+                        err = -1;
+                        break;
+        }
+
+        spin_unlock_irqrestore(auide_hwif.pm.lock, flags);
+
+        return err;	
+}
+
+static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev ) {
+        return 0; 
+}
+
+static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev ) {
+
+        int retval;
+        ide_hwif_t *hwif = auide_hwif.hwif;
+        struct request rq;
+        struct request_pm_state rqpm;
+        ide_task_t args;
+
+        if(auide_hwif.pm.stopped)
+                return -1;
+
+        /* 
+         * wait until hard disc is ready
+         */
+        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
+                printk("Wait for drive sleep timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * sequenz to tell the high level ide driver that pm is resuming
+         */
+        memset(&rq, 0, sizeof(rq));
+        memset(&rqpm, 0, sizeof(rqpm));
+        memset(&args, 0, sizeof(args));
+        rq.flags = REQ_PM_SUSPEND;
+        rq.special = &args;
+        rq.pm = &rqpm;
+        rqpm.pm_step = ide_pm_state_start_suspend;
+        rqpm.pm_state = PMSG_SUSPEND;
+
+        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_wait);
+
+        if (wait_for_ready (&hwif->drives[0], 35000)) {
+                printk("Wait for drive sleep timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * stop dbdma channels
+         */
+        au1xxx_dbdma_reset(auide_hwif.tx_chan);
+        au1xxx_dbdma_reset(auide_hwif.rx_chan);
+
+        auide_hwif.pm.stopped = 1;
+
+        return retval;
+}
+
+static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev ) {
+
+        int retval;
+        ide_hwif_t *hwif = auide_hwif.hwif;
+        struct request rq;
+        struct request_pm_state rqpm;
+        ide_task_t args;
+
+        if(!auide_hwif.pm.stopped)
+                return -1;
+
+        /*
+         * start dbdma channels
+         */	
+        au1xxx_dbdma_start(auide_hwif.tx_chan);
+        au1xxx_dbdma_start(auide_hwif.rx_chan);
+
+        /*
+         * wait until hard disc is ready
+         */
+        if (wait_for_ready ( &hwif->drives[0], 35000)) {
+                printk("Wait for drive wake up timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * sequenz to tell the high level ide driver that pm is resuming
+         */
+        memset(&rq, 0, sizeof(rq));
+        memset(&rqpm, 0, sizeof(rqpm));
+        memset(&args, 0, sizeof(args));
+        rq.flags = REQ_PM_RESUME;
+        rq.special = &args;
+        rq.pm = &rqpm;
+        rqpm.pm_step = ide_pm_state_start_resume;
+        rqpm.pm_state = PMSG_ON;
+
+        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_head_wait);
+
+        /*
+        * wait for hard disc
+        */
+        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
+                printk("Wait for drive wake up timeout!\n");
+                retval = -1;
+        }
+
+        auide_hwif.pm.stopped = 0;
+
+        return retval;
+}
+
+static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev ) {
+        return dev->cur_state;
+}
+
+static int au1xxxide_pm_access( au1xxx_power_dev_t *dev ) {
+        if (dev->cur_state != AWAKE_STATE)
+                return 0;
+        else
+                return -1;
+}
+
+static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev ) {
+        return 0;
+}
+
+static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev ) {
+        return 0;
+}
+#endif /* CONFIG_PM */
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AU1200 IDE driver");
+
+module_init(au_ide_init);
+module_exit(au_ide_exit);
Index: linux-2.6.10/drivers/mmc/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mmc/Kconfig
+++ linux-2.6.10/drivers/mmc/Kconfig
@@ -98,4 +98,14 @@ config MMC_WBSD
 
 	  If unsure, say N.
 
+config MMC_AU1X
+	tristate "Alchemy AU1XX0 MMC Card Interface support"
+	depends on SOC_AU1X00 && MMC
+	help
+	  This selects the AMD Alchemy(R) Multimedia card interface.
+	  If you have a Alchemy platform with a MMC slot, say Y or M here.
+
+	  If unsure, say N.
+
+
 endmenu
Index: linux-2.6.10/drivers/mmc/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mmc/Makefile
+++ linux-2.6.10/drivers/mmc/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_MMC_BLOCK)		+= mmc_block.o
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
+obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
Index: linux-2.6.10/drivers/mmc/au1xmmc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mmc/au1xmmc.c
@@ -0,0 +1,1026 @@
+/* 
+ * linux/drivers/mmc/au1xmmc.c - AU1XX0 MMC driver 
+ *  
+ *  Copyright (c) 2005, Advanced Micro Devices, Inc.
+ *
+ *  Developed with help from the 2.4.30 MMC AU1XXX controller including
+ *  the following copyright notices:
+ *     Copyright (c) 2003-2004 Embedded Edge, LLC.
+ *     Portions Copyright (C) 2002 Embedix, Inc
+ *     Copyright 2002 Hewlett-Packard Company
+
+ *  2.6 version of this driver inspired by:
+ *     (drivers/mmc/wbsd.c) Copyright (C) 2004-2005 Pierre Ossman, 
+ *     All Rights Reserved.
+ *     (drivers/mmc/pxa.c) Copyright (C) 2003 Russell King, 
+ *     All Rights Reserved.
+ *
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Why is a timer used to detect insert events?
+ *
+ * From the AU1100 MMC application guide:
+ * If the Au1100-based design is intended to support both MultiMediaCards 
+ * and 1- or 4-data bit SecureDigital cards, then the solution is to 
+ * connect a weak (560KOhm) pull-up resistor to connector pin 1. 
+ * In doing so, a MMC card never enters SPI-mode communications, 
+ * but now the SecureDigital card-detect feature of CD/DAT3 is ineffective
+ * (the low to high transition will not occur).
+ *
+ * So we use the timer to check the status manually. 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+#include <asm/io.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h> 
+#include <asm/mach-au1x00/au1100_mmc.h>
+#include <asm/scatterlist.h>
+
+#include <au1xxx.h>
+#include "au1xmmc.h"
+
+#define DRIVER_NAME "au1xxx-mmc"
+
+/* Set this to enable special debugging macros */
+/* #define MMC_DEBUG */
+
+#ifdef MMC_DEBUG
+#define DEBUG(fmt, idx, args...) printk("au1xx(%d): DEBUG: " fmt, idx, ##args)
+#else
+#define DEBUG(fmt, idx, args...)
+#endif
+
+const struct {
+	u32 iobase;
+	u32 tx_devid, rx_devid;
+	u16 bcsrpwr;
+	u16 bcsrstatus;
+	u16 wpstatus;
+} au1xmmc_card_table[] = {
+	{ SD0_BASE, DSCR_CMD0_SDMS_TX0, DSCR_CMD0_SDMS_RX0, 
+	  BCSR_BOARD_SD0PWR, BCSR_INT_SD0INSERT, BCSR_STATUS_SD0WP },
+#ifndef CONFIG_MIPS_DB1200
+	{ SD1_BASE, DSCR_CMD0_SDMS_TX1, DSCR_CMD0_SDMS_RX1, 
+	  BCSR_BOARD_DS1PWR, BCSR_INT_SD1INSERT, BCSR_STATUS_SD1WP }
+#endif
+};
+
+#define AU1XMMC_CONTROLLER_COUNT \
+	(sizeof(au1xmmc_card_table) / sizeof(au1xmmc_card_table[0]))
+
+/* This array stores pointers for the hosts (used by the IRQ handler) */
+struct au1xmmc_host *au1xmmc_hosts[AU1XMMC_CONTROLLER_COUNT];
+static int dma = 1;
+
+#ifdef MODULE
+MODULE_PARM(dma, "i");
+MODULE_PARM_DESC(dma, "Use DMA engine for data transfers (0 = disabled)");
+#endif
+
+static inline void IRQ_ON(struct au1xmmc_host *host, u32 mask) 
+{
+	u32 val = au_readl(HOST_CONFIG(host));
+	val |= mask;
+	au_writel(val, HOST_CONFIG(host));
+	au_sync();
+}
+
+static inline void FLUSH_FIFO(struct au1xmmc_host *host) 
+{
+	u32 val = au_readl(HOST_CONFIG2(host));
+
+	au_writel(val | SD_CONFIG2_FF, HOST_CONFIG2(host));
+	au_sync_delay(1);
+	
+	/* SEND_STOP will turn off clock control - this re-enables it */
+	val &= ~SD_CONFIG2_DF;
+
+	au_writel(val, HOST_CONFIG2(host));
+	au_sync();
+}
+
+static inline void IRQ_OFF(struct au1xmmc_host *host, u32 mask) 
+{
+	u32 val = au_readl(HOST_CONFIG(host));
+	val &= ~mask;
+	au_writel(val, HOST_CONFIG(host));
+	au_sync();
+}
+
+static inline void SEND_STOP(struct au1xmmc_host *host) 
+{
+
+	/* We know the value of CONFIG2, so avoid a read we don't need */
+	u32 mask = SD_CONFIG2_EN;
+
+	WARN_ON(host->status != HOST_S_DATA);
+	host->status = HOST_S_STOP;
+
+	au_writel(mask | SD_CONFIG2_DF, HOST_CONFIG2(host));
+	au_sync();
+
+	/* Send the stop commmand */
+	au_writel(STOP_CMD, HOST_CMD(host));
+}
+
+static void au1xmmc_set_power(struct au1xmmc_host *host, int state) 
+{
+
+	u32 val = au1xmmc_card_table[host->id].bcsrpwr;
+
+	bcsr->board &= ~val;
+	if (state) bcsr->board |= val;
+	
+	au_sync_delay(1);
+}
+
+static inline int au1xmmc_card_inserted(struct au1xmmc_host *host) 
+{
+	return (bcsr->sig_status & au1xmmc_card_table[host->id].bcsrstatus) 
+		? 1 : 0;
+}	
+
+static inline int au1xmmc_card_readonly(struct au1xmmc_host *host) 
+{
+	return (bcsr->status & au1xmmc_card_table[host->id].wpstatus) 
+		? 1 : 0;
+}
+
+static void au1xmmc_finish_request(struct au1xmmc_host *host) 
+{
+  
+	struct mmc_request *mrq = host->mrq;
+
+	host->mrq = NULL;
+	host->flags &= HOST_F_ACTIVE; 
+
+	host->dma.len = 0;
+	host->dma.dir = 0;
+
+	host->pio.index  = 0;
+	host->pio.offset = 0;
+	host->pio.len = 0;
+
+	host->status = HOST_S_IDLE;
+
+	bcsr->disk_leds |= (1 << 8);
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void au1xmmc_tasklet_finish(unsigned long param) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) param;
+	au1xmmc_finish_request(host);
+}
+
+static int au1xmmc_send_command(struct au1xmmc_host *host, int wait,  
+				struct mmc_command *cmd) 
+{
+
+	u32 mmccmd = (cmd->opcode << SD_CMD_CI_SHIFT);
+
+	switch(cmd->flags) {
+	case MMC_RSP_R1:
+		mmccmd |= SD_CMD_RT_1;
+		break;
+	case MMC_RSP_R1B:
+		mmccmd |= SD_CMD_RT_1B;
+		break;
+	case MMC_RSP_R2:
+		mmccmd |= SD_CMD_RT_2;
+		break;
+	case MMC_RSP_R3:
+		mmccmd |= SD_CMD_RT_3;
+		break;
+	}
+
+	switch(cmd->opcode) {
+	case MMC_READ_SINGLE_BLOCK:
+	case 51:
+		mmccmd |= SD_CMD_CT_2;
+		break;
+	case MMC_READ_MULTIPLE_BLOCK:
+		mmccmd |= SD_CMD_CT_4;
+		break;
+	case MMC_WRITE_BLOCK:
+		mmccmd |= SD_CMD_CT_1;
+		break;
+	
+	case MMC_WRITE_MULTIPLE_BLOCK:
+		mmccmd |= SD_CMD_CT_3;
+		break;
+	case MMC_STOP_TRANSMISSION:
+		mmccmd |= SD_CMD_CT_7;
+		break;
+	}
+	
+	au_writel(cmd->arg, HOST_CMDARG(host));
+	au_sync();
+
+	if (wait) 
+		IRQ_OFF(host, SD_CONFIG_CR);
+	
+	au_writel((mmccmd | SD_CMD_GO), HOST_CMD(host));
+	au_sync();
+
+	/* Wait for the command to go on the line */
+
+	while(1) {
+		if (!(au_readl(HOST_CMD(host)) & SD_CMD_GO))
+			break;
+	}
+
+	/* Wait for the command to come back */
+
+	if (wait) {
+		u32 status = au_readl(HOST_STATUS(host));
+
+		while(!(status & SD_STATUS_CR)) 
+			status = au_readl(HOST_STATUS(host));
+		
+		/* Clear the CR status */
+		au_writel(SD_STATUS_CR, HOST_STATUS(host));
+
+		IRQ_ON(host, SD_CONFIG_CR);
+	}
+
+	return MMC_ERR_NONE;
+}
+
+static void au1xmmc_data_complete(struct au1xmmc_host *host, u32 status) 
+{
+
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data;
+	u32 crc;
+
+	WARN_ON(host->status != HOST_S_DATA && host->status != HOST_S_STOP);
+
+	if (host->mrq == NULL)
+		return;
+
+	data = mrq->cmd->data;
+
+	if (status == 0)
+		status = au_readl(HOST_STATUS(host));
+
+	/* The transaction is really over when the SD_STATUS_DB bit is clear */
+
+	while((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB)) 
+		status = au_readl(HOST_STATUS(host));
+
+	data->error = MMC_ERR_NONE;
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
+
+        /* Process any errors */
+
+	crc = (status & (SD_STATUS_WC | SD_STATUS_RC));
+	if (host->flags & HOST_F_XMIT) 
+		crc |= ((status & 0x07) == 0x02) ? 0 : 1;
+	
+	if (crc) 
+		data->error = MMC_ERR_BADCRC;
+
+	/* Clear the CRC bits */
+	au_writel(SD_STATUS_WC | SD_STATUS_RC, HOST_STATUS(host));
+
+	data->bytes_xfered = 0;
+
+	if (data->error == MMC_ERR_NONE) {
+		if (host->flags & HOST_F_DMA) {
+			u32 chan = DMA_CHANNEL(host);
+
+			chan_tab_t *c = *((chan_tab_t **) chan);
+			au1x_dma_chan_t *cp = c->chan_ptr;
+			data->bytes_xfered = cp->ddma_bytecnt;
+		}
+		else 
+			data->bytes_xfered = 
+				(data->blocks * (1 << data->blksz_bits)) - 
+				host->pio.len;
+	}
+
+	au1xmmc_finish_request(host);
+}
+
+static void au1xmmc_tasklet_data(unsigned long param) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) param;
+
+	u32 status = au_readl(HOST_STATUS(host));
+	au1xmmc_data_complete(host, status);
+}
+
+#define AU1XMMC_MAX_TRANSFER 8
+
+static void au1xmmc_send_pio(struct au1xmmc_host *host) 
+{
+
+	struct mmc_data *data = 0;
+	int sg_len, max, count = 0;
+	unsigned char *sg_ptr;
+	u32 status = 0;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_XMIT)) 
+		return;
+	
+	/* This is the pointer to the data buffer */
+	sg = &data->sg[host->pio.index];
+	sg_ptr = page_address(sg->page) + sg->offset + host->pio.offset;
+
+	/* This is the space left inside the buffer */
+	sg_len = data->sg[host->pio.index].length - host->pio.offset;
+
+	/* Check to if we need less then the size of the sg_buffer */
+
+	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
+	if (max > AU1XMMC_MAX_TRANSFER) max = AU1XMMC_MAX_TRANSFER;
+
+	for(count = 0; count < max; count++ ) {
+		unsigned char val;
+
+		status = au_readl(HOST_STATUS(host));		
+
+		if (!(status & SD_STATUS_TH))
+			break;
+
+		val = *sg_ptr++;
+
+		au_writel((unsigned long) val, HOST_TXPORT(host));
+		au_sync();
+	}
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		IRQ_OFF(host, SD_CONFIG_TH);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host);
+		 
+		tasklet_schedule(&host->data_task);
+	}
+}
+
+static void au1xmmc_receive_pio(struct au1xmmc_host *host) 
+{
+
+	struct mmc_data *data = 0;
+	int sg_len = 0, max = 0, count = 0;
+	unsigned char *sg_ptr = 0;
+	u32 status = 0;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_RECV)) 
+		return;
+
+	max = host->pio.len;
+
+	if (host->pio.index < host->dma.len) {
+		sg = &data->sg[host->pio.index];
+		sg_ptr = page_address(sg->page) + sg->offset + host->pio.offset;
+			
+		/* This is the space left inside the buffer */
+		sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
+
+		/* Check to if we need less then the size of the sg_buffer */
+		if (sg_len < max) max = sg_len;
+	}
+
+	if (max > AU1XMMC_MAX_TRANSFER) 
+		max = AU1XMMC_MAX_TRANSFER;
+
+	for(count = 0; count < max; count++ ) { 
+		u32 val;
+		status = au_readl(HOST_STATUS(host));
+
+		if (!(status & SD_STATUS_NE))
+			break;
+
+		if (status & SD_STATUS_RC) {
+			DEBUG("RX CRC Error [%d + %d].\n", host->id, 
+					host->pio.len, count);
+			break;
+		}
+
+		if (status & SD_STATUS_RO) {
+			DEBUG("RX Overrun [%d + %d]\n", host->id, 
+					host->pio.len, count);
+			break;
+		}
+		else if (status & SD_STATUS_RU) {
+			DEBUG("RX Underrun [%d + %d]\n", host->id, 
+					host->pio.len,	count);
+			break;
+		}
+
+		val = au_readl(HOST_RXPORT(host)); 
+
+		if (sg_ptr) 
+			*sg_ptr++ = (unsigned char) (val & 0xFF);
+	}
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (sg_len && count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		//IRQ_OFF(host, SD_CONFIG_RA | SD_CONFIG_RF);
+		IRQ_OFF(host, SD_CONFIG_NE);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host);
+
+		tasklet_schedule(&host->data_task);
+	}
+}
+
+/* static void au1xmmc_cmd_complete
+   This is called when a command has been completed - grab the response
+   and check for errors.  Then start the data transfer if it is indicated.
+*/
+
+static void au1xmmc_cmd_complete(struct au1xmmc_host *host, u32 status) 
+{
+
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd;
+	int trans;
+
+	if (!host->mrq) 
+		return;
+
+	cmd = mrq->cmd;
+	cmd->error = MMC_ERR_NONE;
+
+	if ((cmd->flags & MMC_RSP_MASK) == MMC_RSP_SHORT) {
+
+		/* Techincally, we should be getting all 48 bits of the response
+		 * (SD_RESP1 + SD_RESP2), but because our response omits the CRC,
+		 * our data ends up being shifted 8 bits to the right.  In this case,
+		 * that means that the OSR data starts at bit 31, so we can just
+		 * read RESP0 and return that 
+		 */
+
+		cmd->resp[0] = au_readl(host->iobase + SD_RESP0);
+	}
+	else if ((cmd->flags & MMC_RSP_MASK) == MMC_RSP_LONG) {
+		u32 r[4];
+		int i;
+
+		r[0] = au_readl(host->iobase + SD_RESP3);
+		r[1] = au_readl(host->iobase + SD_RESP2);
+		r[2] = au_readl(host->iobase + SD_RESP1);
+		r[3] = au_readl(host->iobase + SD_RESP0);
+		
+		/* The CRC is omitted from the response, so really we only got
+		 * 120 bytes, but the engine expects 128 bits, so we have to shift
+		 * things up 
+		 */
+		
+		for(i = 0; i < 4; i++) {
+			cmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;
+			if (i != 3) cmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;
+		}
+	}
+
+        /* Figure out errors */
+
+	if (status & (SD_STATUS_SC | SD_STATUS_WC | SD_STATUS_RC))
+		cmd->error = MMC_ERR_BADCRC;
+
+	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
+
+	if (!trans || cmd->error != MMC_ERR_NONE) {
+
+		IRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA|SD_CONFIG_RF);
+		tasklet_schedule(&host->finish_task);
+		return;
+	}
+
+	host->status = HOST_S_DATA;
+
+	if (host->flags & HOST_F_DMA) {
+		u32 channel = DMA_CHANNEL(host);
+
+		/* Start the DMA as soon as the buffer gets something in it */
+
+		if (host->flags & HOST_F_RECV) {
+			u32 mask = SD_STATUS_DB | SD_STATUS_NE;
+
+			while((status & mask) != mask) 
+				status = au_readl(HOST_STATUS(host));
+		}
+
+		au1xxx_dbdma_start(channel);
+	}
+}
+
+static void au1xmmc_set_clock(struct au1xmmc_host *host, int rate) 
+{
+
+	unsigned int pbus = get_au1x00_speed();
+	unsigned int divisor;
+	u32 config;
+
+	/* From databook:
+	   divisor = ((((cpuclock / sbus_divisor) / 2) / mmcclock) / 2) - 1
+	*/
+
+	pbus /= ((au_readl(SYS_POWERCTRL) & 0x3) + 2);
+	pbus /= 2;
+
+	divisor = ((pbus / rate) / 2) - 1;
+
+	config = au_readl(HOST_CONFIG(host));
+
+	config &= ~(SD_CONFIG_DIV);
+	config |= (divisor & SD_CONFIG_DIV) | SD_CONFIG_DE;
+
+	au_writel(config, HOST_CONFIG(host));
+	au_sync();
+}
+
+static int 
+au1xmmc_prepare_data(struct au1xmmc_host *host, struct mmc_data *data) 
+{
+
+	int datalen = data->blocks * (1 << data->blksz_bits);
+
+	if (dma != 0) 
+		host->flags |= HOST_F_DMA;
+
+	if (data->flags & MMC_DATA_READ)
+		host->flags |= HOST_F_RECV;
+	else
+		host->flags |= HOST_F_XMIT;
+
+	if (host->mrq->stop) 
+		host->flags |= HOST_F_STOP;
+		
+	host->dma.dir = DMA_BIDIRECTIONAL;
+
+	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				   data->sg_len, host->dma.dir);
+
+	if (host->dma.len == 0)
+		return MMC_ERR_TIMEOUT;
+
+	au_writel((1 << data->blksz_bits) - 1, HOST_BLKSIZE(host));	
+
+	if (host->flags & HOST_F_DMA) {
+		int i;
+		u32 channel = DMA_CHANNEL(host);
+
+		au1xxx_dbdma_stop(channel);
+
+		for(i = 0; i < host->dma.len; i++) {
+			u32 ret = 0, flags = DDMA_FLAGS_NOIE;
+			struct scatterlist *sg = &data->sg[i];
+			int sg_len = sg->length;
+			
+			int len = (datalen > sg_len) ? sg_len : datalen;
+
+			if (i == host->dma.len - 1)
+				flags = DDMA_FLAGS_IE;
+
+    			if (host->flags & HOST_F_XMIT){
+      				ret = au1xxx_dbdma_put_source_flags(channel, 
+					(void *) (page_address(sg->page) + 
+						  sg->offset), 
+					len, flags);
+			}
+    			else {
+      				ret = au1xxx_dbdma_put_dest_flags(channel, 
+					(void *) (page_address(sg->page) + 
+						  sg->offset), 
+					len, flags);
+			}
+
+    			if (!ret) 
+				goto dataerr;
+
+			datalen -= len;
+		}
+	}
+	else {
+		host->pio.index = 0;
+		host->pio.offset = 0;
+		host->pio.len = datalen;
+		
+		if (host->flags & HOST_F_XMIT)
+			IRQ_ON(host, SD_CONFIG_TH);
+		else 
+			IRQ_ON(host, SD_CONFIG_NE);
+			//IRQ_ON(host, SD_CONFIG_RA|SD_CONFIG_RF);
+	}
+
+	return MMC_ERR_NONE;
+
+ dataerr:
+	dma_unmap_sg(mmc_dev(host->mmc),data->sg,data->sg_len,host->dma.dir); 
+	return MMC_ERR_TIMEOUT;
+} 
+
+/* static void au1xmmc_request
+   This actually starts a command or data transaction
+*/
+
+static void au1xmmc_request(struct mmc_host* mmc, struct mmc_request* mrq) 
+{
+
+	struct au1xmmc_host *host = mmc_priv(mmc);
+	int ret = MMC_ERR_NONE;
+
+	WARN_ON(irqs_disabled());
+	WARN_ON(host->status != HOST_S_IDLE);
+
+	host->mrq = mrq;
+	host->status = HOST_S_CMD;
+
+	bcsr->disk_leds &= ~(1 << 8);
+
+	if (mrq->data) {
+		FLUSH_FIFO(host);
+		ret = au1xmmc_prepare_data(host, mrq->data);
+	}
+
+	if (ret == MMC_ERR_NONE)
+		ret = au1xmmc_send_command(host, 0, mrq->cmd);
+
+	if (ret != MMC_ERR_NONE) {
+		mrq->cmd->error = ret;
+		au1xmmc_finish_request(host);
+	}
+}
+
+static void au1xmmc_reset_controller(struct au1xmmc_host *host) 
+{
+
+	/* Apply the clock */
+	au_writel(SD_ENABLE_CE, HOST_ENABLE(host));
+        au_sync_delay(1);
+
+	au_writel(SD_ENABLE_R | SD_ENABLE_CE, HOST_ENABLE(host));
+	au_sync_delay(5);
+
+	au_writel(~0, HOST_STATUS(host));
+	au_sync();
+
+	au_writel(0, HOST_BLKSIZE(host));
+	au_writel(0x001fffff, HOST_TIMEOUT(host));
+	au_sync();
+
+	au_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));
+        au_sync();
+
+	au_writel(SD_CONFIG2_EN | SD_CONFIG2_FF, HOST_CONFIG2(host));
+	au_sync_delay(1);
+
+	au_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));
+	au_sync();
+
+	/* Configure interrupts */
+	au_writel(AU1XMMC_INTERRUPTS, HOST_CONFIG(host));
+	au_sync();
+}
+	
+
+static void au1xmmc_set_ios(struct mmc_host* mmc, struct mmc_ios* ios) 
+{
+	struct au1xmmc_host *host = mmc_priv(mmc);
+
+	DEBUG("set_ios (power=%u, clock=%uHz, vdd=%u, mode=%u)\n",
+	      host->id, ios->power_mode, ios->clock, ios->vdd, 
+	      ios->bus_mode);
+
+	if (ios->power_mode == MMC_POWER_OFF) 
+		au1xmmc_set_power(host, 0);
+	else if (ios->power_mode == MMC_POWER_ON) {
+		au1xmmc_set_power(host, 1);
+	}
+
+	if (ios->clock && ios->clock != host->clock) {
+		au1xmmc_set_clock(host, ios->clock);
+		host->clock = ios->clock;
+	}
+}
+
+static void au1xmmc_dma_callback(int irq, void *dev_id, struct pt_regs *regs) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) dev_id;
+	u32 status;
+
+	/* Avoid spurious interrupts */
+
+	if (!host->mrq) 
+		return;
+
+	if (host->flags & HOST_F_STOP) 
+		SEND_STOP(host);
+
+	tasklet_schedule(&host->data_task);
+}
+
+#define STATUS_TIMEOUT (SD_STATUS_RAT | SD_STATUS_DT)
+#define STATUS_DATA_IN  (SD_STATUS_NE)
+#define STATUS_DATA_OUT (SD_STATUS_TH)
+
+static irqreturn_t au1xmmc_irq(int irq, void *dev_id, struct pt_regs *regs) 
+{
+  
+	u32 status;
+	int i, ret = 0;
+
+	disable_irq(AU1100_SD_IRQ);
+
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {    
+		struct au1xmmc_host * host = au1xmmc_hosts[i];
+		u32 handled = 1;
+
+		status = au_readl(HOST_STATUS(host));
+
+		if (host->mrq && (status & STATUS_TIMEOUT)) {
+			if (status & SD_STATUS_RAT)  
+				host->mrq->cmd->error = MMC_ERR_TIMEOUT;
+			
+			else if (status & SD_STATUS_DT) 
+				host->mrq->data->error = MMC_ERR_TIMEOUT;
+		
+			/* In PIO mode, interrupts might still be enabled */
+			IRQ_OFF(host, SD_CONFIG_NE | SD_CONFIG_TH);
+
+			//IRQ_OFF(host, SD_CONFIG_TH|SD_CONFIG_RA|SD_CONFIG_RF);
+			tasklet_schedule(&host->finish_task);
+		}
+#if 0
+		else if (status & SD_STATUS_DD) {
+
+			/* Sometimes we get a DD before a NE in PIO mode */
+
+			if (!(host->flags & HOST_F_DMA) && 
+					(status & SD_STATUS_NE))
+				au1xmmc_receive_pio(host);
+			else {
+				au1xmmc_data_complete(host, status);
+				//tasklet_schedule(&host->data_task);
+			}
+		}
+#endif
+		else if (status & (SD_STATUS_CR)) {
+			if (host->status == HOST_S_CMD)
+				au1xmmc_cmd_complete(host,status);
+		}
+		else if (!(host->flags & HOST_F_DMA)) { 
+			if ((host->flags & HOST_F_XMIT) && 
+			    (status & STATUS_DATA_OUT))
+				au1xmmc_send_pio(host);
+			else if ((host->flags & HOST_F_RECV) && 
+			    (status & STATUS_DATA_IN))
+				au1xmmc_receive_pio(host);
+		}
+		else if (status & 0x203FBC70) {
+			DEBUG("Unhandled status %8.8x\n", host->id, status);
+			handled = 0;
+		}
+		
+		au_writel(status, HOST_STATUS(host));
+		au_sync();
+
+		ret |= handled;
+	}
+
+	enable_irq(AU1100_SD_IRQ);
+	return ret;
+}
+
+static void au1xmmc_poll_event(unsigned long arg) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) arg;
+
+	int card = au1xmmc_card_inserted(host);
+        int controller = (host->flags & HOST_F_ACTIVE) ? 1 : 0;
+
+	if (card != controller) {
+		host->flags &= ~HOST_F_ACTIVE;
+		if (card) host->flags |= HOST_F_ACTIVE;
+		mmc_detect_change(host->mmc);
+	}
+
+	if (host->mrq != NULL) {
+		u32 status = au_readl(HOST_STATUS(host));
+		DEBUG("PENDING - %8.8x\n", host->id, status);
+	}
+
+	mod_timer(&host->timer, jiffies + AU1XMMC_DETECT_TIMEOUT);
+}
+
+static dbdev_tab_t au1xmmc_mem_dbdev = 
+{
+	DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 8, 0x00000000, 0, 0
+};
+
+static void au1xmmc_init_dma(struct au1xmmc_host *host) 
+{
+	
+	u32 rxchan, txchan;
+	
+	int txid = au1xmmc_card_table[host->id].tx_devid;
+	int rxid = au1xmmc_card_table[host->id].rx_devid;
+	
+	/* DSCR_CMD0_ALWAYS has a stride of 32 bits, we need a stride
+	   of 8 bits.  And since devices are shared, we need to create
+	   our own to avoid freaking out other devices
+	*/
+	
+	int memid = au1xxx_ddma_add_device(&au1xmmc_mem_dbdev);
+		
+	txchan = au1xxx_dbdma_chan_alloc(memid, txid, 
+					 au1xmmc_dma_callback, (void *) host);
+
+	rxchan = au1xxx_dbdma_chan_alloc(rxid, memid, 
+					 au1xmmc_dma_callback, (void *) host);
+
+	au1xxx_dbdma_set_devwidth(txchan, 8);
+	au1xxx_dbdma_set_devwidth(rxchan, 8);
+
+	au1xxx_dbdma_ring_alloc(txchan, AU1XMMC_DESCRIPTOR_COUNT);
+	au1xxx_dbdma_ring_alloc(rxchan, AU1XMMC_DESCRIPTOR_COUNT);
+
+	host->tx_chan = txchan;
+	host->rx_chan = rxchan;
+}
+
+struct mmc_host_ops au1xmmc_ops = {
+	.request	= au1xmmc_request,
+	.set_ios	= au1xmmc_set_ios,
+};
+
+static int au1xmmc_probe(struct device *dev) 
+{
+
+	int i, ret = 0;
+
+	/* THe interrupt is shared among all controllers */
+	ret = request_irq(AU1100_SD_IRQ, au1xmmc_irq, SA_INTERRUPT, "MMC", 0);
+  
+	if (ret) {
+		printk(DRIVER_NAME "ERROR: Couldn't get int %d: %d\n", 
+				AU1100_SD_IRQ, ret);
+		return -ENXIO;
+	}
+
+	disable_irq(AU1100_SD_IRQ);
+
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {
+		struct mmc_host *mmc = mmc_alloc_host(sizeof(struct au1xmmc_host), dev);
+		struct au1xmmc_host *host = 0;
+
+		if (!mmc) {
+			printk(DRIVER_NAME "ERROR: no mem for host %d\n", i);
+			au1xmmc_hosts[i] = 0;
+			continue;
+		}
+
+		mmc->ops = &au1xmmc_ops;
+   
+		mmc->f_min =   450000;
+		mmc->f_max = 24000000;
+
+		mmc->max_seg_size = AU1XMMC_DESCRIPTOR_SIZE;
+		mmc->max_phys_segs = AU1XMMC_DESCRIPTOR_COUNT; 
+
+		mmc->ocr_avail = AU1XMMC_OCR;
+
+		host = mmc_priv(mmc);
+		host->mmc = mmc;
+
+		host->id = i;
+		host->iobase = au1xmmc_card_table[host->id].iobase;
+		host->clock = 0;
+		host->power_mode = MMC_POWER_OFF;
+		
+		host->flags = au1xmmc_card_inserted(host) ? HOST_F_ACTIVE : 0;
+		host->status = HOST_S_IDLE;
+
+		init_timer(&host->timer);
+
+		host->timer.function = au1xmmc_poll_event;
+		host->timer.data = (unsigned long) host;
+		host->timer.expires = jiffies + AU1XMMC_DETECT_TIMEOUT;
+
+		tasklet_init(&host->data_task, au1xmmc_tasklet_data, 
+				(unsigned long) host);
+
+		tasklet_init(&host->finish_task, au1xmmc_tasklet_finish, 
+				(unsigned long) host);
+
+		spin_lock_init(&host->lock);
+
+		if (dma != 0)
+			au1xmmc_init_dma(host);
+
+		au1xmmc_reset_controller(host);
+
+		mmc_add_host(mmc);
+		au1xmmc_hosts[i] = host;
+
+		add_timer(&host->timer);
+
+		printk(KERN_INFO DRIVER_NAME ": MMC Controller %d set up at %8.8X (mode=%s)\n",
+		       host->id, host->iobase, dma ? "dma" : "pio");
+	}
+  
+	enable_irq(AU1100_SD_IRQ);
+
+	return 0;
+}
+    
+static int au1xmmc_remove(struct device *dev) 
+{
+ 
+	int i;
+
+	disable_irq(AU1100_SD_IRQ);
+  
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {
+		struct au1xmmc_host *host = au1xmmc_hosts[i];
+		if (!host) continue;
+
+		tasklet_kill(&host->data_task);
+		tasklet_kill(&host->finish_task);
+
+		del_timer_sync(&host->timer);
+		au1xmmc_set_power(host, 0);
+		
+		mmc_remove_host(host->mmc);
+    
+		au1xxx_dbdma_chan_free(host->tx_chan);
+		au1xxx_dbdma_chan_free(host->rx_chan);
+   
+		au_writel(0x0, HOST_ENABLE(host));
+		au_sync();	
+	} 
+
+	free_irq(AU1100_SD_IRQ, 0);
+	return 0;
+}
+
+static struct device_driver au1xmmc_driver = {
+	.name          = DRIVER_NAME,
+	.bus           = &platform_bus_type,
+	.probe         = au1xmmc_probe,
+	.remove        = au1xmmc_remove,
+	.suspend       = NULL,
+	.resume        = NULL
+};
+
+static int __init au1xmmc_init(void) 
+{
+	return driver_register(&au1xmmc_driver);
+}
+
+static void __exit au1xmmc_exit(void) 
+{
+	driver_unregister(&au1xmmc_driver);
+}
+
+module_init(au1xmmc_init);
+module_exit(au1xmmc_exit);
+
+#ifdef MODULE
+MODULE_AUTHOR("Advanced Micro Devices, Inc");
+MODULE_DESCRIPTION("MMC/SD driver for the Alchemy Au1XXX");
+MODULE_LICENSE("GPL");
+#endif
+
Index: linux-2.6.10/drivers/mmc/au1xmmc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mmc/au1xmmc.h
@@ -0,0 +1,92 @@
+#ifndef _AU1XMMC_H_
+#define _AU1XMMC_H_
+
+/* Hardware definitions */
+
+#define AU1XMMC_DESCRIPTOR_COUNT 1
+#define AU1XMMC_DESCRIPTOR_SIZE  2048
+
+#define AU1XMMC_OCR ( MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30  | \
+		      MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33  | \
+		      MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36)
+
+/* Easy access macros */
+
+#define HOST_STATUS(h)	((h)->iobase + SD_STATUS)
+#define HOST_CONFIG(h)	((h)->iobase + SD_CONFIG)
+#define HOST_ENABLE(h)	((h)->iobase + SD_ENABLE)
+#define HOST_TXPORT(h)	((h)->iobase + SD_TXPORT)
+#define HOST_RXPORT(h)	((h)->iobase + SD_RXPORT)
+#define HOST_CMDARG(h)	((h)->iobase + SD_CMDARG)
+#define HOST_BLKSIZE(h)	((h)->iobase + SD_BLKSIZE)
+#define HOST_CMD(h)	((h)->iobase + SD_CMD)
+#define HOST_CONFIG2(h)	((h)->iobase + SD_CONFIG2)
+#define HOST_TIMEOUT(h)	((h)->iobase + SD_TIMEOUT)
+#define HOST_DEBUG(h)	((h)->iobase + SD_DEBUG)
+
+#define DMA_CHANNEL(h) \
+	( ((h)->flags & HOST_F_XMIT) ? (h)->tx_chan : (h)->rx_chan)
+
+/* This gives us a hard value for the stop command that we can write directly
+ * to the command register
+ */
+
+#define STOP_CMD (SD_CMD_RT_1B|SD_CMD_CT_7|(0xC << SD_CMD_CI_SHIFT)|SD_CMD_GO)
+
+/* This is the set of interrupts that we configure by default */
+
+
+#define AU1XMMC_INTERRUPTS (SD_CONFIG_SC | SD_CONFIG_DT | \
+		SD_CONFIG_RAT | SD_CONFIG_CR | SD_CONFIG_I)
+/* The poll event (looking for insert/remove events runs twice a second */
+#define AU1XMMC_DETECT_TIMEOUT (HZ/2)
+
+struct au1xmmc_host {
+  struct mmc_host *mmc;
+  struct mmc_request *mrq;
+
+  u32 id;
+
+  u32 flags;
+  u32 iobase;
+  u32 clock;
+  u32 bus_width;
+  u32 power_mode;
+
+  int status;
+
+   struct {
+	   int len;
+	   int dir;
+  } dma;
+
+   struct {
+	   int index;
+	   int offset;
+	   int len;
+  } pio;
+
+  u32 tx_chan;
+  u32 rx_chan;
+
+  struct timer_list timer;
+  struct tasklet_struct finish_task;
+  struct tasklet_struct data_task;
+
+  spinlock_t lock;
+};
+
+/* Status flags used by the host structure */
+
+#define HOST_F_XMIT   0x0001
+#define HOST_F_RECV   0x0002
+#define HOST_F_DMA    0x0010
+#define HOST_F_ACTIVE 0x0100
+#define HOST_F_STOP   0x1000
+
+#define HOST_S_IDLE   0x0001
+#define HOST_S_CMD    0x0002
+#define HOST_S_DATA   0x0003
+#define HOST_S_STOP   0x0004
+
+#endif
Index: linux-2.6.10/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/Kconfig
+++ linux-2.6.10/drivers/mtd/nand/Kconfig
@@ -94,7 +94,7 @@ config MTD_NAND_TX4939NDFMC
 
 config MTD_NAND_AU1550
 	tristate "Au1550 NAND support"
-	depends on SOC_AU1550 && MTD_NAND
+	depends on (SOC_AU1200 || SOC_AU1550) && MTD_NAND
 	help
 	  This enables the driver for the NAND flash controller on the
 	  AMD/Alchemy 1550 SOC.
Index: linux-2.6.10/drivers/mtd/nand/au1550nd.c
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/au1550nd.c
+++ linux-2.6.10/drivers/mtd/nand/au1550nd.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2004 Embedded Edge, LLC
  *
- * $Id: au1550nd.c,v 1.10 2004/10/31 23:48:33 ppopov Exp $
+ * $Id: au1550nd.c,v 1.11 2004/11/04 12:53:10 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -11,6 +11,7 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -21,13 +22,7 @@
 
 /* fixme: this is ugly */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 0)
-#include <asm/mach-au1x00/au1000.h>
-#ifdef CONFIG_MIPS_PB1550
-#include <asm/mach-pb1x00/pb1550.h> 
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#include <asm/mach-db1x00/db1x00.h> 
-#endif
+#include <asm/mach-au1x00/au1xxx.h>
 #else
 #include <asm/au1000.h>
 #ifdef CONFIG_MIPS_PB1550
@@ -45,39 +40,22 @@ static struct mtd_info *au1550_mtd = NUL
 static void __iomem *p_nand;
 static int nand_width = 1; /* default x8*/
 
-#define NAND_CS 1
-
 /*
  * Define partitions for flash device
  */
 const static struct mtd_partition partition_info[] = {
-#ifdef CONFIG_MIPS_PB1550
-#define NUM_PARTITIONS            2
-	{ 
-		.name = "Pb1550 NAND FS 0",
-	  	.offset = 0,
-	  	.size = 8*1024*1024 
-	},
-	{ 
-		.name = "Pb1550 NAND FS 1",
-		.offset =  MTDPART_OFS_APPEND,
- 		.size =    MTDPART_SIZ_FULL
-	}
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#define NUM_PARTITIONS            2
 	{ 
-		.name = "Db1550 NAND FS 0",
+		.name 	= "NAND FS 0",
 	  	.offset = 0,
-	  	.size = 8*1024*1024 
+	  	.size 	= 8*1024*1024 
 	},
 	{ 
-		.name = "Db1550 NAND FS 1",
+		.name 	= "NAND FS 1",
 		.offset =  MTDPART_OFS_APPEND,
- 		.size =    MTDPART_SIZ_FULL
+ 		.size 	=    MTDPART_SIZ_FULL
 	}
-#endif
 };
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
 
 
 /**
@@ -339,11 +317,13 @@ int au1550_device_ready(struct mtd_info 
 /*
  * Main initialization routine
  */
-int __init au1550_init (void)
+int __init au1xxx_nand_init (void)
 {
 	struct nand_chip *this;
 	u16 boot_swapboot = 0; /* default value */
 	int retval;
+	u32 mem_staddr;
+	u32 nand_phys;
 
 	/* Allocate memory for MTD device structure and private data */
 	au1550_mtd = kmalloc (sizeof(struct mtd_info) + 
@@ -364,8 +344,11 @@ int __init au1550_init (void)
 	au1550_mtd->priv = this;
 
 
-	/* MEM_STNDCTL: disable ints, disable nand boot */
-	au_writel(0, MEM_STNDCTL);
+	/* disable interrupts */
+	au_writel(au_readl(MEM_STNDCTL) & ~(1<<8), MEM_STNDCTL);
+ 
+	/* disable NAND boot */
+	au_writel(au_readl(MEM_STNDCTL) & ~(1<<0), MEM_STNDCTL);
 
 #ifdef CONFIG_MIPS_PB1550
 	/* set gpio206 high */
@@ -397,19 +380,60 @@ int __init au1550_init (void)
 	}
 #endif
 
-	/* Configure RCE1 - should be done by YAMON */
-	au_writel(0x5 | (nand_width << 22), 0xB4001010); /* MEM_STCFG1 */
-	au_writel(NAND_TIMING, 0xB4001014); /* MEM_STTIME1 */
-	au_sync();
-
-	/* setup and enable chip select, MEM_STADDR1 */
-	/* we really need to decode offsets only up till 0x20 */
-	au_writel((1<<28) | (NAND_PHYS_ADDR>>4) | 
-			(((NAND_PHYS_ADDR + 0x1000)-1) & (0x3fff<<18)>>18), 
-			MEM_STADDR1);
-	au_sync();
+	/* Configure chip-select; normally done by boot code, e.g. YAMON */
+#ifdef NAND_STCFG
+	if (NAND_CS == 0) {
+		au_writel(NAND_STCFG,  MEM_STCFG0);
+		au_writel(NAND_STTIME, MEM_STTIME0);
+		au_writel(NAND_STADDR, MEM_STADDR0);
+	}
+	if (NAND_CS == 1) {
+		au_writel(NAND_STCFG,  MEM_STCFG1);
+		au_writel(NAND_STTIME, MEM_STTIME1);
+		au_writel(NAND_STADDR, MEM_STADDR1);
+	}
+	if (NAND_CS == 2) {
+		au_writel(NAND_STCFG,  MEM_STCFG2);
+		au_writel(NAND_STTIME, MEM_STTIME2);
+		au_writel(NAND_STADDR, MEM_STADDR2);
+	}
+	if (NAND_CS == 3) {
+		au_writel(NAND_STCFG,  MEM_STCFG3);
+		au_writel(NAND_STTIME, MEM_STTIME3);
+		au_writel(NAND_STADDR, MEM_STADDR3);
+	}
+#endif
+ 
+	/* Locate NAND chip-select in order to determine NAND phys address */
+	mem_staddr = 0x00000000;
+	if (((au_readl(MEM_STCFG0) & 0x7) == 0x5) && (NAND_CS == 0))
+		mem_staddr = au_readl(MEM_STADDR0);
+	else if (((au_readl(MEM_STCFG1) & 0x7) == 0x5) && (NAND_CS == 1))
+		mem_staddr = au_readl(MEM_STADDR1);
+	else if (((au_readl(MEM_STCFG2) & 0x7) == 0x5) && (NAND_CS == 2))
+		mem_staddr = au_readl(MEM_STADDR2);
+	else if (((au_readl(MEM_STCFG3) & 0x7) == 0x5) && (NAND_CS == 3))
+		mem_staddr = au_readl(MEM_STADDR3);
+
+	if (mem_staddr == 0x00000000) {
+		printk("Au1xxx NAND: ERROR WITH NAND CHIP-SELECT\n");
+		kfree(au1550_mtd);
+		return 1;
+	}
+	nand_phys = (mem_staddr << 4) & 0xFFFC0000;
+
+	p_nand = (void __iomem *)ioremap(nand_phys, 0x1000);
+
+	/* make controller and MTD agree */
+	if (NAND_CS == 0)
+		nand_width = au_readl(MEM_STCFG0) & (1<<22);
+	if (NAND_CS == 1)
+		nand_width = au_readl(MEM_STCFG1) & (1<<22);
+	if (NAND_CS == 2)
+		nand_width = au_readl(MEM_STCFG2) & (1<<22);
+	if (NAND_CS == 3)
+		nand_width = au_readl(MEM_STCFG3) & (1<<22);
 
-	p_nand = ioremap(NAND_PHYS_ADDR, 0x1000);
 
 	/* Set address of hardware control function */
 	this->hwcontrol = au1550_hwcontrol;
@@ -438,7 +462,7 @@ int __init au1550_init (void)
 	}
 
 	/* Register the partitions */
-	add_mtd_partitions(au1550_mtd, partition_info, NUM_PARTITIONS);
+	add_mtd_partitions(au1550_mtd, partition_info, NB_OF(partition_info));
 
 	return 0;
 
@@ -450,7 +474,7 @@ int __init au1550_init (void)
 	return retval;
 }
 
-module_init(au1550_init);
+module_init(au1xxx_nand_init);
 
 /*
  * Clean up routine
Index: linux-2.6.10/drivers/net/smc91x.h
===================================================================
--- linux-2.6.10.orig/drivers/net/smc91x.h
+++ linux-2.6.10/drivers/net/smc91x.h
@@ -295,6 +295,38 @@ static inline void SMC_outsw (unsigned l
 #define RPC_LSA_DEFAULT		RPC_LED_TX_RX
 #define RPC_LSB_DEFAULT		RPC_LED_100_10
 
+#elif defined(CONFIG_SOC_AU1X00)
+
+#include <au1xxx.h>
+
+/* We can only do 16-bit reads and writes in the static memory space. */
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+#define SMC_IO_SHIFT		0
+#define SMC_NOWAIT		1
+
+#define SMC_inw(a, r)		au_readw((unsigned long)((a) + (r)))
+#define SMC_insw(a, r, p, l)	\
+	do {	\
+		unsigned long _a = (unsigned long)((a) + (r)); \
+		int _l = (l); \
+		u16 *_p = (u16 *)(p); \
+		while (_l-- > 0) \
+			*_p++ = au_readw(_a); \
+	} while(0)
+#define SMC_outw(v, a, r)	au_writew(v, (unsigned long)((a) + (r)))
+#define SMC_outsw(a, r, p, l)	\
+	do {	\
+		unsigned long _a = (unsigned long)((a) + (r)); \
+		int _l = (l); \
+		const u16 *_p = (const u16 *)(p); \
+		while (_l-- > 0) \
+		au_writew(*_p++ , _a); \
+	} while(0)
+
+#define set_irq_type(irq, type) do {} while (0)
+
 #else
 
 #define SMC_CAN_USE_8BIT	1
Index: linux-2.6.10/drivers/video/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/video/Kconfig
+++ linux-2.6.10/drivers/video/Kconfig
@@ -994,6 +994,14 @@ config FB_AU1100
 	bool "Au1100 LCD Driver"
 	depends on FB && EXPERIMENTAL && PCI && MIPS && MIPS_PB1100=y
 
+config FB_AU1200
+	bool "Au1200 LCD Driver"
+	depends on FB && MIPS && SOC_AU1200
+	help
+	  This is the framebuffer driver for the AMD Au1200 SOC.  It can drive
+	  various panels and CRTs by passing in kernel cmd line option
+	  au1200fb:panel=<name>.
+
 config FB_SBUS
 	bool "SBUS and UPA framebuffers"
 	depends on FB && (SPARC32 || SPARC64)
Index: linux-2.6.10/drivers/video/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/video/Makefile
+++ linux-2.6.10/drivers/video/Makefile
@@ -96,6 +96,7 @@ obj-$(CONFIG_FB_PMAGB_B)	  += pmagb-b-fb
 obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_TX3912)		  += tx3912fb.o  cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_AU1100)		  += au1100fb.o fbgen.o
+obj-$(CONFIG_FB_AU1200)		  += au1200fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_XILINX)		  += xilinxfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 
 
Index: linux-2.6.10/drivers/video/au1200fb.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/video/au1200fb.c
@@ -0,0 +1,1944 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1200 LCD Driver.
+ *
+ * Copyright 2004-2005 AMD
+ * Author: AMD
+ *
+ * Based on:
+ * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device
+ *  Created 28 Dec 1997 by Geert Uytterhoeven
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/mach-au1x00/au1000.h>
+#include "au1200fb.h"
+
+#ifdef CONFIG_PM
+#include <asm/mach-au1x00/au1xxx_pm.h>
+#endif
+
+#ifndef CONFIG_FB_AU1200_DEVS
+#define CONFIG_FB_AU1200_DEVS 4
+#endif
+
+#define DRIVER_NAME "au1200fb"
+#define DRIVER_DESC "LCD controller driver for AU1200 processors"
+
+#define DEBUG 1
+
+#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME ": " f "\n", ## arg)
+#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME ": " f "\n", ## arg)
+#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME ": " f "\n", ## arg)
+
+#if DEBUG
+#define print_dbg(f, arg...) printk(KERN_DEBUG __FILE__ ": " f "\n", ## arg)
+#else
+#define print_dbg(f, arg...) do {} while (0)
+#endif
+
+
+#define AU1200_LCD_FB_IOCTL 0x46FF
+
+#define AU1200_LCD_SET_SCREEN 1
+#define AU1200_LCD_GET_SCREEN 2
+#define AU1200_LCD_SET_WINDOW 3
+#define AU1200_LCD_GET_WINDOW 4
+#define AU1200_LCD_SET_PANEL  5
+#define AU1200_LCD_GET_PANEL  6
+
+#define SCREEN_SIZE		    (1<< 1)
+#define SCREEN_BACKCOLOR    (1<< 2)
+#define SCREEN_BRIGHTNESS   (1<< 3)
+#define SCREEN_COLORKEY     (1<< 4)
+#define SCREEN_MASK         (1<< 5)
+typedef struct au1200_lcd_global_regs_t
+{
+    unsigned int flags;
+    unsigned int xsize;
+    unsigned int ysize;
+    unsigned int backcolor;
+    unsigned int brightness;
+	unsigned int colorkey;
+	unsigned int mask;
+    unsigned int panel_choice;
+    char panel_desc[80];
+
+} au1200_lcd_global_regs_t;
+
+#define WIN_POSITION            (1<< 0)
+#define WIN_ALPHA_COLOR         (1<< 1)
+#define WIN_ALPHA_MODE          (1<< 2)
+#define WIN_PRIORITY            (1<< 3)
+#define WIN_CHANNEL             (1<< 4)
+#define WIN_BUFFER_FORMAT       (1<< 5)
+#define WIN_COLOR_ORDER         (1<< 6)
+#define WIN_PIXEL_ORDER         (1<< 7)
+#define WIN_SIZE                (1<< 8)
+#define WIN_COLORKEY_MODE       (1<< 9)
+#define WIN_DOUBLE_BUFFER_MODE  (1<< 10)
+#define WIN_RAM_ARRAY_MODE      (1<< 11)
+#define WIN_BUFFER_SCALE        (1<< 12)
+#define WIN_ENABLE	            (1<< 13)
+
+typedef struct au1200_lcd_window_regs_t
+{
+    unsigned int flags;
+    unsigned int xpos;
+    unsigned int ypos;
+    unsigned int alpha_color;
+    unsigned int alpha_mode;
+    unsigned int priority;
+    unsigned int channel;
+    unsigned int buffer_format;
+    unsigned int color_order;
+    unsigned int pixel_order;
+    unsigned int xsize;
+    unsigned int ysize;
+    unsigned int colorkey_mode;
+    unsigned int double_buffer_mode;
+    unsigned int ram_array_mode;
+    unsigned int xscale;
+    unsigned int yscale;
+    unsigned int enable;
+} au1200_lcd_window_regs_t;
+
+
+typedef struct au1200_lcd_iodata_t
+{
+
+    unsigned int subcmd;
+    au1200_lcd_global_regs_t global;
+    au1200_lcd_window_regs_t window;
+
+} au1200_lcd_iodata_t;
+
+#if defined(__BIG_ENDIAN)
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11
+#else
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00
+#endif
+#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565
+
+/* Private, per-framebuffer management information (independent of the panel itself) */
+struct au1200fb_device {
+	struct fb_info fb_info;			/* FB driver info record */
+
+	int					plane;
+	unsigned char* 		fb_mem;		/* FrameBuffer memory map */
+	unsigned int		fb_len;
+	dma_addr_t    		fb_phys;
+};
+
+static struct au1200fb_device _au1200fb_devices[CONFIG_FB_AU1200_DEVS];
+/********************************************************************/
+
+/* LCD controller restrictions */
+#define AU1200_LCD_MAX_XRES	1280
+#define AU1200_LCD_MAX_YRES	1024
+#define AU1200_LCD_MAX_BPP	32
+#define AU1200_LCD_MAX_CLK	96000000 /* fixme: this needs to go away ? */
+#define AU1200_LCD_NBR_PALETTE_ENTRIES 256
+
+/* Default number of visible screen buffer to allocate */
+#define AU1200FB_NBR_VIDEO_BUFFERS 1
+
+/********************************************************************/
+
+AU1200_LCD *lcd = (AU1200_LCD *)AU1200_LCD_ADDR;
+static int window_index = 2; /* default is zero */
+static int panel_index = 2; /* default is zero */
+static struct window_settings *win;
+static struct panel_settings *panel;
+static int noblanking = 1;
+static int nohwcursor = 0;
+
+struct window_settings
+{
+	unsigned char name[64];
+	uint32 mode_backcolor;
+	uint32 mode_colorkey;
+	uint32 mode_colorkeymsk;
+	struct
+	{
+		int xres;
+		int yres;
+		int xpos;
+		int ypos;
+		uint32 mode_winctrl1; /* winctrl1[FRM,CCO,PO,PIPE] */
+		uint32 mode_winenable;
+	} w[4];
+};
+
+#if defined(__BIG_ENDIAN)
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00
+#else
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01
+#endif
+
+extern int board_au1200fb_panel_init (void);
+extern int board_au1200fb_panel_shutdown (void);
+
+#ifdef CONFIG_PM 
+int au1200fb_pm_callback(au1xxx_power_dev_t *dev, 
+		au1xxx_request_t request, void *data);
+au1xxx_power_dev_t *LCD_pm_dev;
+#endif
+
+/*
+ * Default window configurations
+ */
+static struct window_settings windows[] =
+{
+	{ /* Index 0 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 100, 100, 100, 100,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ LCD_WINENABLE_WEN1,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+
+	{ /* Index 1 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 320, 240, 5, 5,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP |
+				LCD_WINCTRL1_PO_00,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 
+				| LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 100, 100, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 | 
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 200, 25, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+	{ /* Index 2 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_32BPP |
+				LCD_WINCTRL1_PO_00|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+	/* Need VGA 640 @ 24bpp, @ 32bpp */
+	/* Need VGA 800 @ 24bpp, @ 32bpp */
+	/* Need VGA 1024 @ 24bpp, @ 32bpp */
+} ;
+
+/*
+ * Controller configurations for various panels.
+ */
+
+struct panel_settings
+{
+	const char name[25];		/* Full name <vendor>_<model> */
+
+	struct 	fb_monspecs monspecs; 	/* FB monitor specs */
+
+	/* panel timings */
+	uint32 mode_screen;
+	uint32 mode_horztiming;
+	uint32 mode_verttiming;
+	uint32 mode_clkcontrol;
+	uint32 mode_pwmdiv;
+	uint32 mode_pwmhi;
+	uint32 mode_outmask;
+	uint32 mode_fifoctrl;
+	uint32 mode_toyclksrc;
+	uint32 mode_backlight;
+	uint32 mode_auxpll;
+	int (*device_init)(void);
+	int (*device_shutdown)(void);
+#define Xres min_xres
+#define Yres min_yres
+	u32	min_xres;		/* Minimum horizontal resolution */
+	u32	max_xres;		/* Maximum horizontal resolution */
+	u32 	min_yres;		/* Minimum vertical resolution */
+	u32 	max_yres;		/* Maximum vertical resolution */
+};
+
+/********************************************************************/
+/* fixme: Maybe a modedb for the CRT ? otherwise panels should be as-is */
+
+/* List of panels known to work with the AU1200 LCD controller.
+ * To add a new panel, enter the same specifications as the
+ * Generic_TFT one, and MAKE SURE that it doesn't conflicts 
+ * with the controller restrictions. Restrictions are:
+ *
+ * STN color panels: max_bpp <= 12
+ * STN mono panels: max_bpp <= 4
+ * TFT panels: max_bpp <= 16
+ * max_xres <= 800
+ * max_yres <= 600
+ */
+static struct panel_settings known_lcd_panels[] =
+{
+	[0] = { /* QVGA 320x240 H:33.3kHz V:110Hz */
+		.name = "QVGA_320x240",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000, 
+			.hfmax = 70000,
+			.vfmin = 60, 
+			.vfmax = 60, 
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(320) | 
+			LCD_SCREEN_SY_N(240),
+		.mode_horztiming	= 0x00c4623b,
+		.mode_verttiming	= 0x00502814,
+		.mode_clkcontrol	= 0x00020002, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		320, 320,
+		240, 240,
+	},
+
+	[1] = { /* VGA 640x480 H:30.3kHz V:58Hz */
+		.name = "VGA_640x480",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x13f9df80,
+		.mode_horztiming	= 0x003c5859,
+		.mode_verttiming	= 0x00741201,
+		.mode_clkcontrol	= 0x00020001, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		640, 480,
+		640, 480,
+	},
+
+	[2] = { /* SVGA 800x600 H:46.1kHz V:69Hz */
+		.name = "SVGA_800x600",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x18fa5780,
+		.mode_horztiming	= 0x00dc7e77,
+		.mode_verttiming	= 0x00584805,
+		.mode_clkcontrol	= 0x00020000, /* /2=48Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		800, 800,
+		600, 600,
+	},
+
+	[3] = { /* XVGA 1024x768 H:56.2kHz V:70Hz */
+		.name = "XVGA_1024x768",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x1ffaff80,
+		.mode_horztiming	= 0x007d0e57,
+		.mode_verttiming	= 0x00740a01,
+		.mode_clkcontrol	= 0x000A0000, /* /1 */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 6, /* 72MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		1024, 1024,
+		768, 768,
+	},
+
+	[4] = { /* XVGA XVGA 1280x1024 H:68.5kHz V:65Hz */
+		.name = "XVGA_1280x1024",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x27fbff80,
+		.mode_horztiming	= 0x00cdb2c7,
+		.mode_verttiming	= 0x00600002,
+		.mode_clkcontrol	= 0x000A0000, /* /1 */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 10, /* 120MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		1280, 1280,
+		1024, 1024,
+	},
+
+	[5] = { /* Samsung 1024x768 TFT */
+		.name = "Samsung_1024x768_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x1ffaff80,
+		.mode_horztiming	= 0x018cc677,
+		.mode_verttiming	= 0x00241217,
+		.mode_clkcontrol	= 0x00000000, /* SCB 0x1 /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f, /* SCB 0x0 */
+		.mode_pwmhi		= 0x03400000, /* SCB 0x0 */
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		1024, 1024,
+		768, 768,
+	},
+
+	[6] = { /* Toshiba 640x480 TFT */
+		.name = "Toshiba_640x480_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(640) | 
+			LCD_SCREEN_SY_N(480),
+		.mode_horztiming	= LCD_HORZTIMING_HPW_N(96) | 
+			LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),
+		.mode_verttiming	= LCD_VERTTIMING_VPW_N(2) | 
+			LCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32),
+		.mode_clkcontrol	= 0x00000000, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		640, 480,
+		640, 480,
+	},
+
+	[7] = { /* Sharp 320x240 TFT */
+		.name = "Sharp_320x240_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 12500,
+			.hfmax = 20000,
+			.vfmin = 38,
+			.vfmax = 81,
+			.dclkmin = 4500000,
+			.dclkmax = 6800000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(320) | 
+			LCD_SCREEN_SY_N(240),
+		.mode_horztiming	= LCD_HORZTIMING_HPW_N(60) | 
+			LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),
+		.mode_verttiming	= LCD_VERTTIMING_VPW_N(2) | 
+			LCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5),
+		.mode_clkcontrol	= LCD_CLKCONTROL_PCD_N(7), /*16=6Mhz*/
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		320, 320,
+		240, 240,
+	},
+
+	[8] = { /* Toppoly TD070WGCB2 7" 856x480 TFT */
+		.name = "Toppoly_TD070WGCB2",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,	
+			.hfmax = 70000, 
+			.vfmin = 60, 
+			.vfmax = 60, 
+			.dclkmin = 6000000, 
+			.dclkmax = 28000000, 
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(856) | 
+			LCD_SCREEN_SY_N(480),
+		.mode_horztiming	= LCD_HORZTIMING_HND2_N(43) | 
+			LCD_HORZTIMING_HND1_N(43) | LCD_HORZTIMING_HPW_N(114),
+		.mode_verttiming	= LCD_VERTTIMING_VND2_N(20) | 
+			LCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),
+		.mode_clkcontrol	= 0x00020001, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		856, 856,
+		480, 480,
+	},
+};
+
+#define NUM_PANELS (sizeof(known_lcd_panels) / sizeof(struct panel_settings))
+
+/********************************************************************/
+
+static int set_brightness(unsigned int brightness)
+{
+	unsigned int hi1, divider;
+
+	/* limit brightness pwm duty to >= 30/1600 */
+	if (brightness < 30) {
+		brightness = 30;
+	}
+	divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+	hi1 = (lcd->pwmhi >> 16) + 1;
+	hi1 = (((brightness & 0xFF)+1) * divider >> 8);
+	lcd->pwmhi &= 0xFFFF;
+	lcd->pwmhi |= (hi1 << 16);
+
+	return brightness;
+}
+
+static int
+winbpp (unsigned int winctrl1)
+{
+	/* how many bits are needed for each pixel format */
+	switch (winctrl1 & LCD_WINCTRL1_FRM)
+	{
+		case LCD_WINCTRL1_FRM_1BPP: return 1; break;
+		case LCD_WINCTRL1_FRM_2BPP: return 2; break;
+		case LCD_WINCTRL1_FRM_4BPP: return 4; break;
+		case LCD_WINCTRL1_FRM_8BPP: return 8; break;
+		case LCD_WINCTRL1_FRM_12BPP: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP655: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP565: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP556: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI5551: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA5551: return 16; break;
+		case LCD_WINCTRL1_FRM_24BPP: return 32; break;
+		case LCD_WINCTRL1_FRM_32BPP: return 32; break;
+		default: return 0; break;
+	}
+}
+
+static int
+fbinfo2index (struct fb_info *fb_info)
+{
+	int i;
+	for (i = 0; i < CONFIG_FB_AU1200_DEVS; ++i)
+	{
+		if (fb_info == (struct fb_info *)(&_au1200fb_devices[i].fb_info))
+			return i;
+	}
+	printk("au1200fb: ERROR: fbinfo2index failed!\n");
+	return -1;
+}
+
+static int au1200_setlocation (struct au1200fb_device *fbdev, int plane, int xpos, int ypos)
+{
+	uint32 winctrl0, winctrl1, winenable, fb_offset = 0;
+	int xsz, ysz;
+
+	/* FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */
+
+	winctrl0 = lcd->window[plane].winctrl0;
+	winctrl1 = lcd->window[plane].winctrl1;
+	winctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);
+	winctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);
+
+	/* Check for off-screen adjustments */
+	xsz = win->w[plane].xres;
+	ysz = win->w[plane].yres;
+	if ((xpos + win->w[plane].xres) > panel->Xres)
+	{
+		/* Off-screen to the right */
+		xsz = panel->Xres - xpos; /* off by 1 ??? */
+		/*printk("off screen right\n");*/
+	}
+
+	if ((ypos + win->w[plane].yres) > panel->Yres)
+	{
+		/* Off-screen to the bottom */
+		ysz = panel->Yres - ypos; /* off by 1 ??? */
+		/*printk("off screen bottom\n");*/
+	}
+
+	if (xpos < 0)
+	{
+		/* Off-screen to the left */
+		xsz = win->w[plane].xres + xpos;
+		fb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);
+		xpos = 0;
+		/*printk("off screen left\n");*/
+	}
+
+	if (ypos < 0)
+	{
+		/* Off-screen to the top */
+		ysz = win->w[plane].yres + ypos;
+		/* fixme: fb_offset += ((0-ypos)*fb_pars[plane].line_length); */
+		ypos = 0;
+		/*printk("off screen top\n");*/
+	}
+
+	/* record settings */
+	win->w[plane].xpos = xpos;
+	win->w[plane].ypos = ypos;
+
+	xsz -= 1;
+	ysz -= 1;
+	winctrl0 |= (xpos << 21);
+	winctrl0 |= (ypos << 10);
+	winctrl1 |= (xsz << 11);
+	winctrl1 |= (ysz << 0);
+
+	/* Disable the window while making changes, then restore WINEN */
+	winenable = lcd->winenable & (1 << plane);
+	au_sync();
+	lcd->winenable &= ~(1 << plane);
+	lcd->window[plane].winctrl0 = winctrl0;
+	lcd->window[plane].winctrl1 = winctrl1;
+	lcd->window[plane].winbuf0 =
+	lcd->window[plane].winbuf1 = fbdev->fb_phys;
+	lcd->window[plane].winbufctrl = 0; /* select winbuf0 */
+	lcd->winenable |= winenable;
+	au_sync();
+
+	return 0;
+}
+
+static void au1200_setpanel (struct panel_settings *newpanel)
+{
+	/*
+	 * Perform global setup/init of LCD controller
+	 */
+	uint32 winenable;
+
+	/* Make sure all windows disabled */
+	winenable = lcd->winenable;
+	lcd->winenable = 0;
+	au_sync();
+	/*
+	 * Ensure everything is disabled before reconfiguring
+	 */
+	if (lcd->screen & LCD_SCREEN_SEN)
+	{
+		/* Wait for vertical sync period */
+		lcd->intstatus = LCD_INT_SS;
+		while ((lcd->intstatus & LCD_INT_SS) == 0) {
+			au_sync();
+		}
+		
+		lcd->screen &= ~LCD_SCREEN_SEN;	/*disable the controller*/
+		
+		do
+		{
+			lcd->intstatus = lcd->intstatus; /*clear interrupts*/
+			au_sync();
+		}
+		/*wait for controller to shut down*/
+		while ((lcd->intstatus & LCD_INT_SD) == 0);
+		
+		/* Call shutdown of current panel (if up) */
+		/* this must occur last, because if an external clock is driving
+		    the controller, the clock cannot be turned off before first
+			shutting down the controller.
+		 */
+		if (panel->device_shutdown != NULL) panel->device_shutdown();
+	}
+
+	/* Newpanel == NULL indicates a shutdown operation only */
+	if (newpanel == NULL)
+		return;
+
+	panel = newpanel;
+	
+	printk("Panel(%s), %dx%d\n", panel->name, panel->Xres, panel->Yres);
+
+	/*
+	 * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)
+	 */
+	if (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))
+	{
+		uint32 sys_clksrc;
+		au_writel(panel->mode_auxpll, SYS_AUXPLL);
+		sys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f; 
+		sys_clksrc |= panel->mode_toyclksrc;
+		au_writel(sys_clksrc, SYS_CLKSRC);
+	}
+
+	/*
+	 * Configure panel timings
+	 */
+	lcd->screen = panel->mode_screen;
+	lcd->horztiming = panel->mode_horztiming;
+	lcd->verttiming = panel->mode_verttiming;
+	lcd->clkcontrol = panel->mode_clkcontrol;
+	lcd->pwmdiv = panel->mode_pwmdiv;
+	lcd->pwmhi = panel->mode_pwmhi;
+	lcd->outmask = panel->mode_outmask;
+	lcd->fifoctrl = panel->mode_fifoctrl;
+	au_sync();
+
+	/* fixme: Check window settings to make sure still valid 
+	 * for new geometry */
+#if 0
+	au1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);
+	au1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);
+	au1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);
+	au1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);
+#endif
+	lcd->winenable = winenable;
+
+	/*
+	 * Re-enable screen now that it is configured
+	 */
+	lcd->screen |= LCD_SCREEN_SEN;
+	au_sync();
+
+	/* Call init of panel */
+	if (panel->device_init != NULL) panel->device_init();
+
+	/* FIX!!!! not appropriate on panel change!!! Global setup/init */
+	lcd->intenable = 0;
+	lcd->intstatus = ~0;
+	lcd->backcolor = win->mode_backcolor;
+
+	/* Setup Color Key - FIX!!! */
+	lcd->colorkey = win->mode_colorkey;
+	lcd->colorkeymsk = win->mode_colorkeymsk;
+
+	/* Setup HWCursor - FIX!!! Need to support this eventually */
+	lcd->hwc.cursorctrl = 0;
+	lcd->hwc.cursorpos = 0;
+	lcd->hwc.cursorcolor0 = 0;
+	lcd->hwc.cursorcolor1 = 0;
+	lcd->hwc.cursorcolor2 = 0;
+	lcd->hwc.cursorcolor3 = 0;
+
+
+#if 0
+#define D(X) printk("%25s: %08X\n", #X, X)
+	D(lcd->screen);
+	D(lcd->horztiming);
+	D(lcd->verttiming);
+	D(lcd->clkcontrol);
+	D(lcd->pwmdiv);
+	D(lcd->pwmhi);
+	D(lcd->outmask);
+	D(lcd->fifoctrl);
+	D(lcd->window[0].winctrl0);
+	D(lcd->window[0].winctrl1);
+	D(lcd->window[0].winctrl2);
+	D(lcd->window[0].winbuf0);
+	D(lcd->window[0].winbuf1);
+	D(lcd->window[0].winbufctrl);
+	D(lcd->window[1].winctrl0);
+	D(lcd->window[1].winctrl1);
+	D(lcd->window[1].winctrl2);
+	D(lcd->window[1].winbuf0);
+	D(lcd->window[1].winbuf1);
+	D(lcd->window[1].winbufctrl);
+	D(lcd->window[2].winctrl0);
+	D(lcd->window[2].winctrl1);
+	D(lcd->window[2].winctrl2);
+	D(lcd->window[2].winbuf0);
+	D(lcd->window[2].winbuf1);
+	D(lcd->window[2].winbufctrl);
+	D(lcd->window[3].winctrl0);
+	D(lcd->window[3].winctrl1);
+	D(lcd->window[3].winctrl2);
+	D(lcd->window[3].winbuf0);
+	D(lcd->window[3].winbuf1);
+	D(lcd->window[3].winbufctrl);
+	D(lcd->winenable);
+	D(lcd->intenable);
+	D(lcd->intstatus);
+	D(lcd->backcolor);
+	D(lcd->winenable);
+	D(lcd->colorkey);
+    D(lcd->colorkeymsk);
+	D(lcd->hwc.cursorctrl);
+	D(lcd->hwc.cursorpos);
+	D(lcd->hwc.cursorcolor0);
+	D(lcd->hwc.cursorcolor1);
+	D(lcd->hwc.cursorcolor2);
+	D(lcd->hwc.cursorcolor3);
+#endif
+}
+
+static void au1200_setmode(struct au1200fb_device *fbdev)
+{
+	int plane = fbdev->plane;
+	/* Window/plane setup */
+	lcd->window[plane].winctrl1 = ( 0
+		| LCD_WINCTRL1_PRI_N(plane)
+		| win->w[plane].mode_winctrl1 /* FRM,CCO,PO,PIPE */
+		) ;
+
+	au1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);
+
+	lcd->window[plane].winctrl2 = ( 0
+		| LCD_WINCTRL2_CKMODE_00
+		| LCD_WINCTRL2_DBM
+		| LCD_WINCTRL2_BX_N( fbdev->fb_info.fix.line_length)
+		| LCD_WINCTRL2_SCX_1
+		| LCD_WINCTRL2_SCY_1
+		) ;
+	lcd->winenable |= win->w[plane].mode_winenable;
+	au_sync();
+}
+
+
+/* Inline helpers */
+
+/*#define panel_is_dual(panel)  ((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/
+/*#define panel_is_active(panel)((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/
+
+#define panel_is_color(panel) ((panel->mode_screen & LCD_SCREEN_PT) <= LCD_SCREEN_PT_CDSTN)
+
+/* Bitfields format supported by the controller. */
+struct fb_bitfield rgb_bitfields[][4] = 
+{
+  	/*     Red, 	   Green, 	 Blue, 	     Transp   */
+	[LCD_WINCTRL1_FRM_16BPP655 >> 25] =
+		{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPP565 >> 25] =
+		{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPP556 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPI1555 >> 25] =
+		{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPI5551 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPA1555 >> 25] =
+		{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPA5551 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },
+
+	[LCD_WINCTRL1_FRM_24BPP >> 25] =
+		{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_32BPP >> 25] =
+		{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 24, 0, 0 } },
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Helpers */
+	
+static void 
+au1200fb_update_fbinfo(struct fb_info *fbi)
+{
+	/* FIX!!!! This also needs to take the window pixel format into account!!! */
+
+	/* Update var-dependent FB info */
+	if (panel_is_color(panel)) {
+		if (fbi->var.bits_per_pixel <= 8) {
+			/* palettized */
+			fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+			fbi->fix.line_length = fbi->var.xres_virtual / 
+				(8/fbi->var.bits_per_pixel);
+		} else {
+			/* non-palettized */
+			fbi->fix.visual = FB_VISUAL_TRUECOLOR;
+			fbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8); 
+		}
+	} else {
+		/* mono FIX!!! mono 8 and 4 bits */
+		fbi->fix.visual = FB_VISUAL_MONO10;
+		fbi->fix.line_length = fbi->var.xres_virtual / 8;
+	}
+
+	fbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;
+	print_dbg("line length: %d\n", fbi->fix.line_length);
+	print_dbg("bits_per_pixel: %d\n", fbi->var.bits_per_pixel);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 framebuffer driver */
+
+int au1200fb_fb_open(struct fb_info *fbi, int user)
+{
+	return 0;
+}
+
+int au1200fb_fb_release(struct fb_info *fbi, int user)
+{
+	return 0;
+}
+
+/* fb_check_var
+ * Validate var settings with hardware restrictions and modify it if necessary 
+ */
+int au1200fb_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+	u32 pixclock;
+	int screen_size, plane;
+
+	plane = fbdev->plane;
+
+	/* Make sure that the mode respect all LCD controller and 
+	 * panel restrictions. */
+	var->xres = win->w[plane].xres;
+	var->yres = win->w[plane].yres;
+	
+	/* No need for virtual resolution support */
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+
+	var->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);
+
+	screen_size = var->xres_virtual * var->yres_virtual;
+	if (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);  
+	else screen_size /= (8/var->bits_per_pixel);
+
+	if (fbdev->fb_len < screen_size)
+		return -EINVAL; /* Virtual screen is to big, abort */
+
+	/* FIX!!!! what are the implicaitons of ignoring this for windows ??? */
+	/* The max LCD clock is fixed to 48MHz (value of AUX_CLK). The pixel
+	 * clock can only be obtain by dividing this value by an even integer.
+	 * Fallback to a slower pixel clock if necessary. */
+	pixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);
+	pixclock = min(pixclock, min(fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2));
+
+	if (AU1200_LCD_MAX_CLK % pixclock) {
+		int diff = AU1200_LCD_MAX_CLK % pixclock;
+		pixclock -= diff;
+	}
+
+	var->pixclock = KHZ2PICOS(pixclock/1000);
+#if 0
+	if (!panel_is_active(panel)) {
+		int pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;
+
+		if (!panel_is_color(panel) 
+			&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {
+			/* STN 8bit mono panel support is up to 6MHz pixclock */
+			var->pixclock = KHZ2PICOS(6000);
+		} else if (!pcd) {
+			/* Other STN panel support is up to 12MHz  */
+			var->pixclock = KHZ2PICOS(12000);
+		}
+	}
+#endif
+	/* Set bitfield accordingly */
+	switch (var->bits_per_pixel) {
+		case 16:
+		{
+			/* 16bpp True color.  
+			 * These must be set to MATCH WINCTRL[FORM] */
+			int idx;
+			idx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+			var->red    = rgb_bitfields[idx][0];
+			var->green  = rgb_bitfields[idx][1];
+			var->blue   = rgb_bitfields[idx][2];
+			var->transp = rgb_bitfields[idx][3];
+			break;
+		}
+
+		case 32:
+		{
+			/* 32bpp True color.  
+			 * These must be set to MATCH WINCTRL[FORM] */
+			int idx;
+			idx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+			var->red    = rgb_bitfields[idx][0];
+			var->green  = rgb_bitfields[idx][1];
+			var->blue   = rgb_bitfields[idx][2];
+			var->transp = rgb_bitfields[idx][3];
+			break;
+		}
+		default:
+			print_dbg("Unsupported depth %dbpp", var->bits_per_pixel);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* fb_set_par 
+ * Set hardware with var settings. This will enable the controller with a 
+ * specific mode, normally validated with the fb_check_var method
+ */
+int au1200fb_fb_set_par(struct fb_info *fbi)
+{
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+
+	au1200fb_update_fbinfo(fbi);
+	au1200_setmode(fbdev);
+
+	return 0;
+}
+
+/* fb_setcolreg
+ * Set color in LCD palette.
+ */
+int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)
+{
+	u32 *palette = lcd->palette;
+	u32 value;
+
+	if (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))
+		return -EINVAL;
+
+	if (fbi->var.grayscale) {
+		/* Convert color to grayscale */
+		red = green = blue = 
+			(19595 * red + 38470 * green + 7471 * blue) >> 16;
+	}
+
+	if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		/* Place color in the pseudopalette */
+		if (regno > 16)
+			return -EINVAL;
+   
+		palette = (u32*)fbi->pseudo_palette;
+
+		red   >>= (16 - fbi->var.red.length);
+		green >>= (16 - fbi->var.green.length);
+		blue  >>= (16 - fbi->var.blue.length);
+	
+		value = (red   << fbi->var.red.offset) 	|	
+			(green << fbi->var.green.offset)|
+			(blue  << fbi->var.blue.offset);
+		value &= 0xFFFF;
+
+	} else if (1 /*FIX!!! panel_is_active(fbdev->panel)*/) {
+		/* COLOR TFT PALLETTIZED (use RGB 565) */
+		value = (red & 0xF800)|((green >> 5) & 
+				0x07E0)|((blue >> 11) & 0x001F);
+		value &= 0xFFFF;
+
+	} else if (0 /*panel_is_color(fbdev->panel)*/) {
+		/* COLOR STN MODE */
+		value = 0x1234;
+		value &= 0xFFF;
+	} else {
+		/* MONOCHROME MODE */
+		value = (green >> 12) & 0x000F;
+		value &= 0xF;
+	}
+
+	palette[regno] = value;
+	
+	return 0;
+}
+
+/* fb_blank
+ * Blank the screen. Depending on the mode, the screen will be
+ * activated with the backlight color, or desactivated
+ */
+int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)
+{
+	/* Short-circuit screen blanking */
+	if (noblanking)
+		return 0;
+
+	switch (blank_mode) {
+
+	case VESA_NO_BLANKING:
+		/* printk("turn on panel\n"); */
+		au1200_setpanel(panel);
+		break;
+
+	case VESA_VSYNC_SUSPEND:
+	case VESA_HSYNC_SUSPEND:
+	case VESA_POWERDOWN:
+		/* printk("turn off panel\n"); */
+		au1200_setpanel(NULL);
+		break;
+	default: 
+		break;
+
+	}
+	return 0;
+}
+
+/* fb_mmap
+ * Map video memory in user space. We don't use the generic fb_mmap 
+ * method mainly to allow the use of the TLB streaming flag (CCA=6)
+ */
+int au1200fb_fb_mmap(struct fb_info *fbi, struct file *file, struct vm_area_struct *vma)
+{
+	unsigned int len;
+	unsigned long start=0, off,pfn;
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+	void *va;
+
+#ifdef CONFIG_PM
+	au1xxx_pm_access(LCD_pm_dev);
+#endif
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		return -EINVAL;
+	}
+    
+	start = fbdev->fb_phys & PAGE_MASK;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	pgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */
+
+	vma->vm_flags |= VM_IO;
+
+	va = (void __force *)ioremap(off, vma->vm_end - vma->vm_start);
+	pfn = virt_to_phys(va) >> PAGE_SHIFT;
+
+	if (io_remap_page_range(vma, vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+void set_global(u_int cmd, au1200_lcd_global_regs_t *pdata) {
+
+	unsigned int hi1, divider;
+	
+	/* SCREEN_SIZE: user cannot reset size, must switch panel choice */
+	
+	if (pdata->flags & SCREEN_BACKCOLOR)
+		lcd->backcolor = pdata->backcolor;
+	
+	if (pdata->flags & SCREEN_BRIGHTNESS) {
+	
+		// limit brightness pwm duty to >= 30/1600
+		if (pdata->brightness < 30) {
+			pdata->brightness = 30;
+		}
+		divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+		hi1 = (lcd->pwmhi >> 16) + 1;
+		hi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);
+		lcd->pwmhi &= 0xFFFF;
+		lcd->pwmhi |= (hi1 << 16);
+	}
+	
+	if (pdata->flags & SCREEN_COLORKEY)
+		lcd->colorkey = pdata->colorkey;
+	
+	if (pdata->flags & SCREEN_MASK)
+		lcd->colorkeymsk = pdata->mask;
+	au_sync();
+}
+
+void get_global(u_int cmd, au1200_lcd_global_regs_t *pdata) {
+	unsigned int hi1, divider;
+	
+	pdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;
+	pdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;
+	
+	pdata->backcolor = lcd->backcolor;
+	pdata->colorkey = lcd->colorkey;
+	pdata->mask = lcd->colorkeymsk;
+	
+	// brightness
+	hi1 = (lcd->pwmhi >> 16) + 1;
+	divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+	pdata->brightness = ((hi1 << 8) / divider) - 1;
+	au_sync();
+}
+
+void print_global(au1200_lcd_global_regs_t *pdata) {
+
+	printk("pdata->xsize %x\n", pdata->xsize);
+	printk("pdata->ysize %x\n", pdata->ysize);
+	printk("pdata->backcolor %x\n", pdata->backcolor);
+	printk("pdata->brightness %x\n", pdata->brightness);
+	printk("pdata->colorkey %x\n", pdata->colorkey);
+	printk("pdata->mask %x\n", pdata->mask);
+}
+
+void set_window(unsigned int plane, au1200_lcd_window_regs_t *pdata) {
+	
+	unsigned int val, bpp;
+	
+	/* Window control register 0 */
+	if (pdata->flags & WIN_POSITION) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX | 
+				LCD_WINCTRL0_OY);
+		val |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);
+		val |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);
+		lcd->window[plane].winctrl0 = val;
+	}
+	if (pdata->flags & WIN_ALPHA_COLOR) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);
+		val |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);
+		lcd->window[plane].winctrl0 = val;
+	}
+	if (pdata->flags & WIN_ALPHA_MODE) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);
+		val |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);
+		lcd->window[plane].winctrl0 = val;
+	}
+	
+	/* Window control register 1 */
+	if (pdata->flags & WIN_PRIORITY) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);
+		val |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_CHANNEL) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);
+		val |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_BUFFER_FORMAT) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);
+		val |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_COLOR_ORDER) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);
+		val |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_PIXEL_ORDER) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);
+		val |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_SIZE) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX | 
+				LCD_WINCTRL1_SZY);
+		val |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);
+		val |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);
+		lcd->window[plane].winctrl1 = val;
+		/* program buffer line width */
+		bpp = winbpp(val) / 8;
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);
+		val |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	/* Window control register 2 */
+	if (pdata->flags & WIN_COLORKEY_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);
+		val |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);
+		lcd->window[plane].winctrl2 = val;
+	}
+	if (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);
+		val |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);
+		lcd->window[plane].winctrl2 = val;
+	}
+	if (pdata->flags & WIN_RAM_ARRAY_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);
+		val |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	/* Buffer line width programmed with WIN_SIZE */
+	
+	if (pdata->flags & WIN_BUFFER_SCALE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX | 
+				LCD_WINCTRL2_SCY);
+		val |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);
+		val |= ((pdata->ysize) & LCD_WINCTRL2_SCY);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	if (pdata->flags & WIN_ENABLE) {
+		val = lcd->winenable;
+		val &= ~(1<<plane);
+		val |= (pdata->enable & 1) << plane;
+		lcd->winenable = val;
+	}
+	au_sync();
+}
+
+void get_window(unsigned int plane, au1200_lcd_window_regs_t *pdata) {
+
+	/* Window control register 0 */
+	pdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;
+	pdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;
+	pdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;
+	pdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;
+	
+	/* Window control register 1 */
+	pdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;
+	pdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;
+	pdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+	pdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;
+	pdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;
+	pdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;
+	pdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;
+	
+	/* Window control register 2 */
+	pdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;
+	pdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;
+	pdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;
+	
+	pdata->enable = (lcd->winenable >> plane) & 1;
+	au_sync();
+}
+
+static int au1200fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, struct fb_info *info)
+{
+	int plane;
+	int val;
+
+#ifdef CONFIG_PM
+	au1xxx_pm_access(LCD_pm_dev);
+#endif
+	
+	plane = fbinfo2index(info);
+	print_dbg("au1200fb: ioctl %d on plane %d\n", cmd, plane);
+	
+	if (cmd == AU1200_LCD_FB_IOCTL) {
+		au1200_lcd_iodata_t iodata;
+	
+		if (copy_from_user(&iodata, (void *) arg, sizeof(au1200_lcd_iodata_t)))
+			return -EFAULT;
+	
+		print_dbg("FB IOCTL called\n");
+	
+		switch (iodata.subcmd)
+		{
+	
+		case AU1200_LCD_SET_SCREEN:
+			print_dbg("AU1200_LCD_SET_SCREEN\n");
+			set_global(cmd, &iodata.global);
+			break;
+	
+		case AU1200_LCD_GET_SCREEN:
+			print_dbg("AU1200_LCD_GET_SCREEN\n");
+			get_global(cmd, &iodata.global);
+			break;
+	
+		case AU1200_LCD_SET_WINDOW:
+			print_dbg("AU1200_LCD_SET_WINDOW\n");
+			set_window(plane, &iodata.window);
+			break;
+	
+		case AU1200_LCD_GET_WINDOW:
+			print_dbg("AU1200_LCD_GET_WINDOW\n");
+			get_window(plane, &iodata.window);
+			break;
+	
+		case AU1200_LCD_SET_PANEL:
+			print_dbg("AU1200_LCD_SET_PANEL\n");
+			if ((iodata.global.panel_choice >= 0) && 
+					(iodata.global.panel_choice < 
+					 NUM_PANELS))
+			{
+				struct panel_settings *newpanel;
+				panel_index = iodata.global.panel_choice;
+				newpanel = &known_lcd_panels[panel_index];
+				au1200_setpanel(newpanel);
+			}
+			break;
+	
+		case AU1200_LCD_GET_PANEL:
+			print_dbg("AU1200_LCD_GET_PANEL\n");
+			iodata.global.panel_choice = panel_index;
+			break;
+	
+		default:
+			return -EINVAL;
+		}
+	
+		val = copy_to_user((void *) arg, &iodata, sizeof(au1200_lcd_iodata_t));
+		if (val) {
+			print_dbg("error: could not copy %d bytes\n", val);
+			return -EFAULT;
+		}
+	}
+	
+return 0;
+}
+
+
+static struct fb_ops au1200fb_fb_ops = 
+{
+	.owner			= THIS_MODULE,
+	.fb_open		= au1200fb_fb_open,
+	.fb_release		= au1200fb_fb_release,
+	.fb_check_var	= au1200fb_fb_check_var,
+	.fb_set_par		= au1200fb_fb_set_par,
+	.fb_setcolreg	= au1200fb_fb_setcolreg,
+	.fb_blank		= au1200fb_fb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor		= soft_cursor,
+	.fb_sync		= NULL,
+	.fb_ioctl		= au1200fb_ioctl,
+	.fb_mmap		= au1200fb_fb_mmap,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t au1200fb_handle_irq(int irq, void* dev_id, struct pt_regs *regs)
+{
+	/* Nothing to do for now, just clear any pending interrupt */
+	lcd->intstatus = lcd->intstatus;
+	au_sync();
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 LCD device probe helpers */
+
+static int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)
+{
+	struct fb_info *fbi = &fbdev->fb_info;
+	int bpp;
+	
+	memset(fbi, 0, sizeof(struct fb_info));
+	fbi->fbops = &au1200fb_fb_ops;
+	
+	bpp = winbpp(win->w[fbdev->plane].mode_winctrl1);
+
+	/* Copy monitor specs from panel data */
+	/* fixme: we're setting up LCD controller windows, so these dont give a
+	damn as to what the monitor specs are (the panel itself does, but that
+	isnt done here...so maybe need a generic catchall monitor setting??? */
+	memcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));
+
+	/* We first try the user mode passed in argument. If that failed, 
+	 * or if no one has been specified, we default to the first mode of the 
+	 * panel list. Note that after this call, var data will be set */
+	if (!fb_find_mode(&fbi->var, 
+			  fbi, 
+			  NULL, /* drv_info.opt_mode, */
+			  fbi->monspecs.modedb, 
+			  fbi->monspecs.modedb_len,
+			  fbi->monspecs.modedb, 
+			  bpp)) {
+
+		print_err("Cannot find valid mode for panel %s", panel->name);
+		return -EFAULT;
+	}
+
+	fbi->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);
+	if (!fbi->pseudo_palette) {
+		return -ENOMEM;
+	}
+	memset(fbi->pseudo_palette, 0, sizeof(u32) * 16);
+
+	if (fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {
+		print_err("Fail to allocate colormap (%d entries)",
+			   AU1200_LCD_NBR_PALETTE_ENTRIES);
+		kfree(fbi->pseudo_palette);
+		return -EFAULT;
+	}
+
+	strncpy(fbi->fix.id, "AU1200", sizeof(fbi->fix.id));
+	fbi->fix.smem_start = fbdev->fb_phys;
+	fbi->fix.smem_len = fbdev->fb_len;
+	fbi->fix.type = FB_TYPE_PACKED_PIXELS;
+	fbi->fix.xpanstep = 1;
+	fbi->fix.ypanstep = 1;
+	fbi->fix.mmio_start = 0;
+	fbi->fix.mmio_len = 0;
+	fbi->fix.accel = FB_ACCEL_NONE;
+
+	fbi->screen_base = fbdev->fb_mem;
+
+	au1200fb_update_fbinfo(fbi);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 LCD controller device driver */
+
+int au1200fb_drv_probe(struct device *dev)
+{
+	struct au1200fb_device *fbdev;
+	unsigned long page;
+	int bpp, plane, ret;
+
+	if (!dev)
+		return -EINVAL;
+
+	for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane)
+	{
+		bpp = winbpp(win->w[plane].mode_winctrl1);
+		if (win->w[plane].xres == 0)
+			win->w[plane].xres = panel->Xres;
+		if (win->w[plane].yres == 0)
+			win->w[plane].yres = panel->Yres;
+
+		fbdev = &_au1200fb_devices[plane];
+		memset((void *)fbdev, 0, sizeof(struct au1200fb_device));
+		fbdev->plane = plane;
+
+		/* Allocate the framebuffer to the maximum screen size */
+		fbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;
+
+		fbdev->fb_mem = dma_alloc_noncoherent(dev, 
+				PAGE_ALIGN(fbdev->fb_len), 
+				&fbdev->fb_phys, GFP_KERNEL);
+		if (!fbdev->fb_mem) {
+			print_err("fail to allocate frambuffer (size: %dK))", 
+				  fbdev->fb_len / 1024);
+			return -ENOMEM;
+		}
+
+		/*
+		 * Set page reserved so that mmap will work. This is necessary
+		 * since we'll be remapping normal memory.
+		 */
+		for (page = (unsigned long)fbdev->fb_phys;
+		     page < PAGE_ALIGN((unsigned long)fbdev->fb_phys + 
+			     fbdev->fb_len);
+		     page += PAGE_SIZE) {
+			SetPageReserved(pfn_to_page(page >> PAGE_SHIFT)); /* LCD DMA is NOT coherent on Au1200 */
+		}
+		print_dbg("Framebuffer memory map at %p", fbdev->fb_mem);
+		print_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);
+
+		/* Init FB data */
+		if ((ret = au1200fb_init_fbinfo(fbdev)) < 0)
+			goto failed;
+
+		/* Register new framebuffer */
+		if ((ret = register_framebuffer(&fbdev->fb_info)) < 0) {
+			print_err("cannot register new framebuffer");
+			goto failed;
+		}
+		
+		au1200fb_fb_set_par(&fbdev->fb_info);
+
+#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
+		if (plane == 0)
+			if (fb_prepare_logo(&fbdev->fb_info)) {
+				/* Start display and show logo on boot */
+				fb_set_cmap(&fbdev->fb_info.cmap, 
+						&fbdev->fb_info);
+
+				fb_show_logo(&fbdev->fb_info);
+			}
+#endif
+	}
+
+	/* Now hook interrupt too */
+	if ((ret = request_irq(AU1200_LCD_INT, au1200fb_handle_irq,
+		 	  SA_INTERRUPT | SA_SHIRQ, "lcd", (void *)dev)) < 0) {
+		print_err("fail to request interrupt line %d (err: %d)",
+			  AU1200_LCD_INT, ret);
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	/* NOTE: This only does the current plane/window that failed; others are still active */
+	if (fbdev->fb_mem)
+		dma_free_noncoherent(dev, PAGE_ALIGN(fbdev->fb_len), 
+				fbdev->fb_mem, fbdev->fb_phys);
+	if (fbdev->fb_info.cmap.len != 0)
+		fb_dealloc_cmap(&fbdev->fb_info.cmap);
+	if (fbdev->fb_info.pseudo_palette)
+		kfree(fbdev->fb_info.pseudo_palette);
+	if (plane == 0)
+		free_irq(AU1200_LCD_INT, (void*)dev);
+	return ret;
+}
+
+int au1200fb_drv_remove(struct device *dev)
+{
+	struct au1200fb_device *fbdev;
+	int plane;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* Turn off the panel */
+	au1200_setpanel(NULL);
+
+	for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane)
+	{
+		fbdev = &_au1200fb_devices[plane];
+
+		/* Clean up all probe data */
+		unregister_framebuffer(&fbdev->fb_info);
+		if (fbdev->fb_mem)
+			dma_free_noncoherent(dev, PAGE_ALIGN(fbdev->fb_len), 
+					fbdev->fb_mem, fbdev->fb_phys);
+		if (fbdev->fb_info.cmap.len != 0)
+			fb_dealloc_cmap(&fbdev->fb_info.cmap);
+		if (fbdev->fb_info.pseudo_palette)
+			kfree(fbdev->fb_info.pseudo_palette);
+	}
+
+	free_irq(AU1200_LCD_INT, (void *)dev);
+
+	return 0;
+}
+
+int au1200fb_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	/* TODO */
+	return 0;
+}
+
+int au1200fb_drv_resume(struct device *dev, u32 level)
+{
+	/* TODO */
+	return 0;
+}
+
+static struct device_driver au1200fb_driver = {
+	.name		= "au1200-lcd",
+	.bus		= &platform_bus_type,
+	.probe		= au1200fb_drv_probe,
+	.remove		= au1200fb_drv_remove,
+	.suspend	= au1200fb_drv_suspend,
+	.resume		= au1200fb_drv_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Kernel driver */
+
+static void au1200fb_setup(void)
+{
+	char* options = NULL;
+	char* this_opt;
+	int num_panels = ARRAY_SIZE(known_lcd_panels);
+	int panel_idx = -1;
+
+	fb_get_options(DRIVER_NAME, &options);
+
+	if (options) {
+		while ((this_opt = strsep(&options,",")) != NULL) {
+			/* Panel option - can be panel name, 
+			 * "bs" for board-switch, or number/index */
+			if (!strncmp(this_opt, "panel:", 6)) {
+				int i;
+				long int li;
+				char *endptr;
+				this_opt += 6;
+				/* First check for index, which allows 
+				 * to short circuit this mess */
+				li = simple_strtol(this_opt, &endptr, 0);
+				if (*endptr == '\0') {
+					panel_idx = (int)li;
+				}
+				else if (strcmp(this_opt, "bs") == 0) {
+					extern int board_au1200fb_panel(void);
+					panel_idx = board_au1200fb_panel();
+				}
+
+				else
+				for (i = 0; i < num_panels; i++) {
+					if (!strcmp(this_opt, known_lcd_panels[i].name)) {
+						panel_idx = i;
+						break;
+					}
+				}
+
+				if ((panel_idx < 0) || (panel_idx >= num_panels)) {
+						print_warn("Panel %s not supported!", this_opt);
+				}
+				else
+					panel_index = panel_idx;
+			}
+
+			else if (strncmp(this_opt, "nohwcursor", 10) == 0) {
+				nohwcursor = 1;
+			}
+
+			/* Unsupported option */
+			else {
+				print_warn("Unsupported option \"%s\"", this_opt);
+			}
+		}
+	} 
+}
+
+#ifdef CONFIG_PM
+int au1200fb_pm_callback(au1xxx_power_dev_t *dev, 
+		au1xxx_request_t request, void *data) {
+	int retval = -1;
+	unsigned int d = 0;
+	unsigned int brightness = 0;
+
+	if (request == AU1XXX_PM_SLEEP) {
+		board_au1200fb_panel_shutdown();
+	}
+	else if (request == AU1XXX_PM_WAKEUP) {
+		if(dev->prev_state == SLEEP_STATE)
+		{
+			int plane;
+			au1200_setpanel(panel);
+			for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane) 	{
+				struct au1200fb_device *fbdev;
+				fbdev = &_au1200fb_devices[plane];
+				au1200fb_fb_set_par(&fbdev->fb_info);
+			}
+		}
+
+		d = *((unsigned int*)data);
+		if(d <=10) brightness = 26;
+		else if(d<=20) brightness = 51;
+		else if(d<=30) brightness = 77;
+		else if(d<=40) brightness = 102;
+		else if(d<=50) brightness = 128;
+		else if(d<=60) brightness = 153;
+		else if(d<=70) brightness = 179;
+		else if(d<=80) brightness = 204;
+		else if(d<=90) brightness = 230;
+		else brightness = 255;
+		set_brightness(brightness);
+	}
+	else if (request == AU1XXX_PM_GETSTATUS) {
+		return dev->cur_state;
+	}
+	else if (request == AU1XXX_PM_ACCESS) {
+		if (dev->cur_state != SLEEP_STATE)
+			return retval;
+		else {
+			au1200_setpanel(panel);
+		}
+	}
+	else if (request == AU1XXX_PM_IDLE) {
+	}
+	else if (request == AU1XXX_PM_CLEANUP) {
+	}
+
+	return retval; 
+}
+#endif
+
+int __init au1200fb_init(void)
+{
+	print_info("" DRIVER_DESC "");
+	
+	/* Setup driver with options */
+	au1200fb_setup();
+
+	/* Point to the panel selected */
+	panel = &known_lcd_panels[panel_index];
+	win = &windows[window_index];
+
+	printk(DRIVER_NAME ": Panel %d %s\n", panel_index, panel->name);
+	printk(DRIVER_NAME ": Win %d %s\n", window_index, win->name);
+
+	/* Kickstart the panel, the framebuffers/windows come soon enough */
+	au1200_setpanel(panel);
+
+	#ifdef CONFIG_PM
+	LCD_pm_dev = new_au1xxx_power_device("LCD", &au1200fb_pm_callback, NULL);
+	if ( LCD_pm_dev == NULL)
+		printk(KERN_INFO "Unable to create a power management device entry for the au1200fb.\n");
+	else
+		printk(KERN_INFO "Power management device entry for the au1200fb loaded.\n");
+	#endif
+
+	return driver_register(&au1200fb_driver);
+}
+
+void __exit au1200fb_cleanup(void)
+{
+	driver_unregister(&au1200fb_driver);
+}
+
+module_init(au1200fb_init);
+module_exit(au1200fb_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/video/au1200fb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/video/au1200fb.h
@@ -0,0 +1,288 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Hardware definitions for the Au1200 LCD controller
+ *
+ * Copyright 2004 AMD
+ * Author:	AMD
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1200LCD_H
+#define _AU1200LCD_H
+
+/********************************************************************/
+#define AU1200_LCD_ADDR		0xB5000000
+
+#define uint8 unsigned char
+#define uint32 unsigned int
+
+typedef volatile struct
+{
+	uint32	reserved0;
+	uint32	screen;
+	uint32	backcolor;
+	uint32	horztiming;
+	uint32	verttiming;
+	uint32	clkcontrol;
+	uint32	pwmdiv;
+	uint32	pwmhi;
+	uint32	reserved1;
+	uint32	winenable;
+	uint32	colorkey;
+	uint32	colorkeymsk;
+	struct
+	{
+		uint32	cursorctrl;
+		uint32	cursorpos;
+		uint32	cursorcolor0;
+		uint32	cursorcolor1;
+		uint32	cursorcolor2;
+		uint32	cursorcolor3;
+	} hwc;
+	uint32	intstatus;
+	uint32	intenable;
+	uint32	outmask;
+	uint32	fifoctrl;
+	uint32	reserved2[(0x0100-0x0058)/4];
+	struct
+	{
+		uint32	winctrl0;
+		uint32	winctrl1;
+		uint32	winctrl2;
+		uint32	winbuf0;
+		uint32	winbuf1;
+		uint32	winbufctrl;
+		uint32	winreserved0;
+		uint32	winreserved1;
+	} window[4];
+
+	uint32	reserved3[(0x0400-0x0180)/4];
+
+	uint32	palette[(0x0800-0x0400)/4];
+
+	uint8	cursorpattern[256];
+
+} AU1200_LCD;
+
+/* lcd_screen */
+#define LCD_SCREEN_SEN		(1<<31)
+#define LCD_SCREEN_SX		(0x07FF<<19)
+#define LCD_SCREEN_SY		(0x07FF<< 8)
+#define LCD_SCREEN_SWP		(1<<7)
+#define LCD_SCREEN_SWD		(1<<6)
+#define LCD_SCREEN_PT		(7<<0)
+#define LCD_SCREEN_PT_TFT	(0<<0)
+#define LCD_SCREEN_SX_N(WIDTH)	((WIDTH-1)<<19)
+#define LCD_SCREEN_SY_N(HEIGHT)	((HEIGHT-1)<<8)
+#define LCD_SCREEN_PT_CSTN	(1<<0)
+#define LCD_SCREEN_PT_CDSTN	(2<<0)
+#define LCD_SCREEN_PT_M8STN	(3<<0)
+#define LCD_SCREEN_PT_M4STN	(4<<0)
+
+/* lcd_backcolor */
+#define LCD_BACKCOLOR_SBGR		(0xFF<<16)
+#define LCD_BACKCOLOR_SBGG		(0xFF<<8)
+#define LCD_BACKCOLOR_SBGB		(0xFF<<0)
+#define LCD_BACKCOLOR_SBGR_N(N)	((N)<<16)
+#define LCD_BACKCOLOR_SBGG_N(N)	((N)<<8)
+#define LCD_BACKCOLOR_SBGB_N(N)	((N)<<0)
+
+/* lcd_winenable */
+#define LCD_WINENABLE_WEN3		(1<<3)
+#define LCD_WINENABLE_WEN2		(1<<2)
+#define LCD_WINENABLE_WEN1		(1<<1)
+#define LCD_WINENABLE_WEN0		(1<<0)
+
+/* lcd_colorkey */
+#define LCD_COLORKEY_CKR		(0xFF<<16)
+#define LCD_COLORKEY_CKG		(0xFF<<8)
+#define LCD_COLORKEY_CKB		(0xFF<<0)
+#define LCD_COLORKEY_CKR_N(N)	((N)<<16)
+#define LCD_COLORKEY_CKG_N(N)	((N)<<8)
+#define LCD_COLORKEY_CKB_N(N)	((N)<<0)
+
+/* lcd_colorkeymsk */
+#define LCD_COLORKEYMSK_CKMR		(0xFF<<16)
+#define LCD_COLORKEYMSK_CKMG		(0xFF<<8)
+#define LCD_COLORKEYMSK_CKMB		(0xFF<<0)
+#define LCD_COLORKEYMSK_CKMR_N(N)	((N)<<16)
+#define LCD_COLORKEYMSK_CKMG_N(N)	((N)<<8)
+#define LCD_COLORKEYMSK_CKMB_N(N)	((N)<<0)
+
+/* lcd windows control 0 */
+#define LCD_WINCTRL0_OX		(0x07FF<<21)
+#define LCD_WINCTRL0_OY		(0x07FF<<10)
+#define LCD_WINCTRL0_A		(0x00FF<<2)
+#define LCD_WINCTRL0_AEN	(1<<1)
+#define LCD_WINCTRL0_OX_N(N) ((N)<<21)
+#define LCD_WINCTRL0_OY_N(N) ((N)<<10)
+#define LCD_WINCTRL0_A_N(N) ((N)<<2)
+
+/* lcd windows control 1 */
+#define LCD_WINCTRL1_PRI	(3<<30)
+#define LCD_WINCTRL1_PIPE	(1<<29)
+#define LCD_WINCTRL1_FRM	(0xF<<25)
+#define LCD_WINCTRL1_CCO	(1<<24)
+#define LCD_WINCTRL1_PO		(3<<22)
+#define LCD_WINCTRL1_SZX	(0x07FF<<11)
+#define LCD_WINCTRL1_SZY	(0x07FF<<0)
+#define LCD_WINCTRL1_FRM_1BPP	(0<<25)
+#define LCD_WINCTRL1_FRM_2BPP	(1<<25)
+#define LCD_WINCTRL1_FRM_4BPP	(2<<25)
+#define LCD_WINCTRL1_FRM_8BPP	(3<<25)
+#define LCD_WINCTRL1_FRM_12BPP	(4<<25)
+#define LCD_WINCTRL1_FRM_16BPP655	(5<<25)
+#define LCD_WINCTRL1_FRM_16BPP565	(6<<25)
+#define LCD_WINCTRL1_FRM_16BPP556	(7<<25)
+#define LCD_WINCTRL1_FRM_16BPPI1555	(8<<25)
+#define LCD_WINCTRL1_FRM_16BPPI5551	(9<<25)
+#define LCD_WINCTRL1_FRM_16BPPA1555	(10<<25)
+#define LCD_WINCTRL1_FRM_16BPPA5551	(11<<25)
+#define LCD_WINCTRL1_FRM_24BPP		(12<<25)
+#define LCD_WINCTRL1_FRM_32BPP		(13<<25)
+#define LCD_WINCTRL1_PRI_N(N)	((N)<<30)
+#define LCD_WINCTRL1_PO_00		(0<<22)
+#define LCD_WINCTRL1_PO_01		(1<<22)
+#define LCD_WINCTRL1_PO_10		(2<<22)
+#define LCD_WINCTRL1_PO_11		(3<<22)
+#define LCD_WINCTRL1_SZX_N(N)	((N-1)<<11)
+#define LCD_WINCTRL1_SZY_N(N)	((N-1)<<0)
+
+/* lcd windows control 2 */
+#define LCD_WINCTRL2_CKMODE		(3<<24)
+#define LCD_WINCTRL2_DBM		(1<<23)
+#define LCD_WINCTRL2_RAM		(3<<21)
+#define LCD_WINCTRL2_BX			(0x1FFF<<8)
+#define LCD_WINCTRL2_SCX		(0xF<<4)
+#define LCD_WINCTRL2_SCY		(0xF<<0)
+#define LCD_WINCTRL2_CKMODE_00		(0<<24)
+#define LCD_WINCTRL2_CKMODE_01		(1<<24)
+#define LCD_WINCTRL2_CKMODE_10		(2<<24)
+#define LCD_WINCTRL2_CKMODE_11		(3<<24)
+#define LCD_WINCTRL2_RAM_NONE		(0<<21)
+#define LCD_WINCTRL2_RAM_PALETTE	(1<<21)
+#define LCD_WINCTRL2_RAM_GAMMA		(2<<21)
+#define LCD_WINCTRL2_RAM_BUFFER		(3<<21)
+#define LCD_WINCTRL2_BX_N(N)	((N)<<8)
+#define LCD_WINCTRL2_SCX_1		(0<<4)
+#define LCD_WINCTRL2_SCX_2		(1<<4)
+#define LCD_WINCTRL2_SCX_4		(2<<4)
+#define LCD_WINCTRL2_SCY_1		(0<<0)
+#define LCD_WINCTRL2_SCY_2		(1<<0)
+#define LCD_WINCTRL2_SCY_4		(2<<0)
+
+/* lcd windows buffer control */
+#define LCD_WINBUFCTRL_DB		(1<<1)
+#define LCD_WINBUFCTRL_DBN		(1<<0)
+
+/* lcd_intstatus, lcd_intenable */
+#define LCD_INT_IFO				(0xF<<14)
+#define LCD_INT_IFU				(0xF<<10)
+#define LCD_INT_OFO				(1<<9)
+#define LCD_INT_OFU				(1<<8)
+#define LCD_INT_WAIT			(1<<3)
+#define LCD_INT_SD				(1<<2)
+#define LCD_INT_SA				(1<<1)
+#define LCD_INT_SS				(1<<0)
+
+/* lcd_horztiming */
+#define LCD_HORZTIMING_HND2		(0x1FF<<18)
+#define LCD_HORZTIMING_HND1		(0x1FF<<9)
+#define LCD_HORZTIMING_HPW		(0x1FF<<0)
+#define LCD_HORZTIMING_HND2_N(N)(((N)-1)<<18)
+#define LCD_HORZTIMING_HND1_N(N)(((N)-1)<<9)
+#define LCD_HORZTIMING_HPW_N(N)	(((N)-1)<<0)
+
+/* lcd_verttiming */
+#define LCD_VERTTIMING_VND2		(0x1FF<<18)
+#define LCD_VERTTIMING_VND1		(0x1FF<<9)
+#define LCD_VERTTIMING_VPW		(0x1FF<<0)
+#define LCD_VERTTIMING_VND2_N(N)(((N)-1)<<18)
+#define LCD_VERTTIMING_VND1_N(N)(((N)-1)<<9)
+#define LCD_VERTTIMING_VPW_N(N)	(((N)-1)<<0)
+
+/* lcd_clkcontrol */
+#define LCD_CLKCONTROL_EXT		(1<<22)
+#define LCD_CLKCONTROL_DELAY	(3<<20)
+#define LCD_CLKCONTROL_CDD		(1<<19)
+#define LCD_CLKCONTROL_IB		(1<<18)
+#define LCD_CLKCONTROL_IC		(1<<17)
+#define LCD_CLKCONTROL_IH		(1<<16)
+#define LCD_CLKCONTROL_IV		(1<<15)
+#define LCD_CLKCONTROL_BF		(0x1F<<10)
+#define LCD_CLKCONTROL_PCD		(0x3FF<<0)
+#define LCD_CLKCONTROL_BF_N(N)	(((N)-1)<<10)
+#define LCD_CLKCONTROL_PCD_N(N)	((N)<<0)
+
+/* lcd_pwmdiv */
+#define LCD_PWMDIV_EN			(1<<31)
+#define LCD_PWMDIV_PWMDIV		(0x1FFFF<<0)
+#define LCD_PWMDIV_PWMDIV_N(N)	((N)<<0)
+
+/* lcd_pwmhi */
+#define LCD_PWMHI_PWMHI1		(0xFFFF<<16)
+#define LCD_PWMHI_PWMHI0		(0xFFFF<<0)
+#define LCD_PWMHI_PWMHI1_N(N)	((N)<<16)
+#define LCD_PWMHI_PWMHI0_N(N)	((N)<<0)
+
+/* lcd_hwccon */
+#define LCD_HWCCON_EN			(1<<0)
+
+/* lcd_cursorpos */
+#define LCD_CURSORPOS_HWCXOFF		(0x1F<<27)
+#define LCD_CURSORPOS_HWCXPOS		(0x07FF<<16)
+#define LCD_CURSORPOS_HWCYOFF		(0x1F<<11)
+#define LCD_CURSORPOS_HWCYPOS		(0x07FF<<0)
+#define LCD_CURSORPOS_HWCXOFF_N(N)	((N)<<27)
+#define LCD_CURSORPOS_HWCXPOS_N(N)	((N)<<16)
+#define LCD_CURSORPOS_HWCYOFF_N(N)	((N)<<11)
+#define LCD_CURSORPOS_HWCYPOS_N(N)	((N)<<0)
+
+/* lcd_cursorcolor */
+#define LCD_CURSORCOLOR_HWCA		(0xFF<<24)
+#define LCD_CURSORCOLOR_HWCR		(0xFF<<16)
+#define LCD_CURSORCOLOR_HWCG		(0xFF<<8)
+#define LCD_CURSORCOLOR_HWCB		(0xFF<<0)
+#define LCD_CURSORCOLOR_HWCA_N(N)	((N)<<24)
+#define LCD_CURSORCOLOR_HWCR_N(N)	((N)<<16)
+#define LCD_CURSORCOLOR_HWCG_N(N)	((N)<<8)
+#define LCD_CURSORCOLOR_HWCB_N(N)	((N)<<0)
+
+/* lcd_fifoctrl */
+#define LCD_FIFOCTRL_F3IF		(1<<29)
+#define LCD_FIFOCTRL_F3REQ		(0x1F<<24)
+#define LCD_FIFOCTRL_F2IF		(1<<29)
+#define LCD_FIFOCTRL_F2REQ		(0x1F<<16)
+#define LCD_FIFOCTRL_F1IF		(1<<29)
+#define LCD_FIFOCTRL_F1REQ		(0x1F<<8)
+#define LCD_FIFOCTRL_F0IF		(1<<29)
+#define LCD_FIFOCTRL_F0REQ		(0x1F<<0)
+#define LCD_FIFOCTRL_F3REQ_N(N)	((N-1)<<24)
+#define LCD_FIFOCTRL_F2REQ_N(N)	((N-1)<<16)
+#define LCD_FIFOCTRL_F1REQ_N(N)	((N-1)<<8)
+#define LCD_FIFOCTRL_F0REQ_N(N)	((N-1)<<0)
+
+/* lcd_outmask */
+#define LCD_OUTMASK_MASK		(0x00FFFFFF)
+
+/********************************************************************/
+#endif /* _AU1200LCD_H */
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -173,9 +173,12 @@
 #define  MACH_PB1000		0	/* Au1000-based eval board */
 #define  MACH_PB1100		1	/* Au1100-based eval board */
 #define  MACH_PB1500		2	/* Au1500-based eval board */
+#define  MACH_PB1200		10	/* Au1200-based eval board */
+#define  MACH_DB1200		11	/* Au1200-based eval board */
 #define  MACH_DB1000		3       /* Au1000-based eval board */
 #define  MACH_DB1100		4       /* Au1100-based eval board */
 #define  MACH_DB1500		5       /* Au1500-based eval board */
+
 #define  MACH_XXS1500		6       /* Au1500-based eval board */
 #define  MACH_MTX1		7       /* 4G MTX-1 Au1500-based board */
 #define  MACH_PB1550		8       /* Au1550-based eval board */
Index: linux-2.6.10/include/asm-mips/cpu.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cpu.h
+++ linux-2.6.10/include/asm-mips/cpu.h
@@ -179,6 +179,7 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
+#define CPU_AU1200		59
 #define CPU_PR4450		60
 #define CPU_LAST		60
 
Index: linux-2.6.10/include/asm-mips/mach-au1x00/au1000.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/mach-au1x00/au1000.h
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1000.h
@@ -37,6 +37,7 @@
 
 #ifndef _LANGUAGE_ASSEMBLY
 
+#include <linux/config.h>
 #include <linux/delay.h>
 #include <asm/io.h>
 
@@ -58,17 +59,17 @@ void static inline au_sync_delay(int ms)
 	mdelay(ms);
 }
 
-void static inline au_writeb(u8 val, int reg)
+void static inline au_writeb(u8 val, unsigned long reg)
 {
 	*(volatile u8 *)(reg) = val;
 }
 
-void static inline au_writew(u16 val, int reg)
+void static inline au_writew(u16 val, unsigned long reg)
 {
 	*(volatile u16 *)(reg) = val;
 }
 
-void static inline au_writel(u32 val, int reg)
+void static inline au_writel(u32 val, unsigned long reg)
 {
 	*(volatile u32 *)(reg) = val;
 }
@@ -182,6 +183,34 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define MEM_SDSMCKE                0xB4000034
 #endif
 
+#ifdef CONFIG_SOC_AU1200
+#define MEM_PHYS_ADDR           0x14000000
+#define STATIC_MEM_PHYS_ADDR    0x14001000
+#define AES_PHYS_ADDR           0x10300000
+#define CIM_PHYS_ADDR           0x14004000
+#define IC0_PHYS_ADDR           0x10400000
+#define IC1_PHYS_ADDR           0x11800000
+#define USBM_PHYS_ADDR          0xB4020000
+#define USBH_PHYS_ADDR          0xB4020100
+#define UART0_PHYS_ADDR         0x11100000
+#define UART1_PHYS_ADDR         0x11200000
+#define GPIO2_PHYS_ADDR         0x11700000
+#define SYS_PHYS_ADDR           0x11900000
+#define DDMA_PHYS_ADDR          0x14002000
+#define PSC0_PHYS_ADDR          0x11A00000
+#define PSC1_PHYS_ADDR          0x11B00000
+#define SD0_PHYS_ADDR           0x10600000
+#define SD1_PHYS_ADDR           0x10680000
+#define LCD_PHYS_ADDR           0x15000000
+#define SWCNT_PHYS_ADDR         0x1110010C
+#define MAEFE_PHYS_ADDR         0x14012000
+#define MAEBE_PHYS_ADDR         0x14010000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
 #define MEM_STTIME0                0xB4001004
@@ -438,7 +467,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_MAC0_ENABLE       0xB1520000
 #define AU1500_MAC1_ENABLE       0xB1520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1500
+#endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
@@ -494,7 +523,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1100_ETH0_BASE	  0xB0500000
 #define AU1100_MAC0_ENABLE       0xB0520000
 #define NUM_ETH_INTERFACES 1
-#endif // CONFIG_SOC_AU1100
+#endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
 #define AU1550_UART0_INT          0
@@ -573,7 +602,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1550_MAC0_ENABLE       0xB0520000
 #define AU1550_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1550
+#endif /* CONFIG_SOC_AU1550 */
 
 #ifdef CONFIG_SOC_AU1200
 #define AU1200_UART0_INT          0
@@ -590,7 +619,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1200_PSC1_INT           11
 #define AU1200_AES_INT            12
 #define AU1200_CAMERA_INT         13
-#define AU1200_TOY_INT			  14
+#define AU1200_TOY_INT		  14
 #define AU1200_TOY_MATCH0_INT     15
 #define AU1200_TOY_MATCH1_INT     16
 #define AU1200_TOY_MATCH2_INT     17
@@ -605,6 +634,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1200_GPIO_207           27
 #define AU1200_GPIO_208_215       28 // Logical OR of 208:215
 #define AU1200_USB_INT            29
+#define AU1000_USB_HOST_INT	  AU1200_USB_INT
 #define AU1200_LCD_INT            30
 #define AU1200_MAE_BOTH_INT       31
 #define AU1000_GPIO_0             32
@@ -643,18 +673,34 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_UOC_BASE              0xB4020020
+#define USB_UOC_LEN               0x20
+#define USB_OHCI_BASE		  0xB4020000
+#define USB_OHCI_LEN		  0x100
+#define USB_EHCI_BASE		  0x14020200
+#define USB_EHCI_LEN		  0x100
+#define USB_UDC_BASE		  0x14022000
+#define USB_UDC_LEN		  0x2000
+
+#define USB_MSR_BASE		  0xB4020000
+#define USB_MSR_MCFG		  4
+#define USBMSRMCFG_OMEMEN	  0
 
 // these are here for prototyping on au1550 (do not exist on au1200)
-#define AU1200_ETH0_BASE      0xB0500000
-#define AU1200_ETH1_BASE      0xB0510000
+#define AU1200_ETH0_BASE	 0xB0500000
+#define AU1200_ETH1_BASE	 0xB0510000
 #define AU1200_MAC0_ENABLE       0xB0520000
 #define AU1200_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
+
+#define AU1200_MAC0_DMA_INT	  28
+#define USB_HOST_CONFIG		  0xB017fffc
+
 #endif // CONFIG_SOC_AU1200
 
 #define AU1000_LAST_INTC0_INT     31
+#define AU1000_LAST_INTC1_INT     63
+
 #define AU1000_MAX_INTR           63
 
 
@@ -728,6 +774,8 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define I2S_CONTROL_D         (1<<1)
   #define I2S_CONTROL_CE        (1<<0)
 
+#ifndef CONFIG_SOC_AU1200
+
 /* USB Host Controller */
 #define USB_OHCI_LEN              0x00100000
 
@@ -773,6 +821,8 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define USBDEV_ENABLE (1<<1)
   #define USBDEV_CE     (1<<0)
 
+#endif /* !CONFIG_SOC_AU1200 */
+
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
Index: linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx.h
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1XXX_H_
+#define _AU1XXX_H_
+
+#include <asm/mach-au1x00/au1000.h>
+
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
+#include <asm/mach-db1x00/db1x00.h>
+
+#elif defined(CONFIG_MIPS_PB1550)
+#include <asm/mach-pb1x00/pb1550.h>
+
+#elif defined(CONFIG_MIPS_PB1200)
+#include <asm/mach-pb1x00/pb1200.h>
+
+#elif defined(CONFIG_MIPS_DB1200)
+#include <asm/mach-db1x00/db1200.h>
+
+#endif
+
+#endif /* _AU1XXX_H_ */
Index: linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx_ide.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-au1x00/au1xxx_ide.h
@@ -0,0 +1,303 @@
+/*
+ * include/asm-mips/mach-au1x00/au1xxx_ide.h  version 01.30.00   Aug. 02 2005
+ *
+ * BRIEF MODULE DESCRIPTION
+ * AMD Alchemy Au1xxx IDE interface routines over the Static Bus
+ *
+ * Copyright (c) 2003-2005 AMD, Personal Connectivity Solutions
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
+ *       Interface and Linux Device Driver" Application Note.
+ */
+#ifndef AUTOCONF_INCLUDED
+        #include <linux/autoconf.h>
+#endif
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        #define DMA_WAIT_TIMEOUT        100
+        #define NUM_DESCRIPTORS         PRD_ENTRIES
+#else /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
+        #define NUM_DESCRIPTORS         2
+#endif
+
+#ifndef AU1XXX_ATA_RQSIZE
+        #define AU1XXX_ATA_RQSIZE       128
+#endif
+
+/* Disable Burstable-Support for DBDMA */
+#ifndef CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+        #define CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON  0
+#endif
+
+#ifdef CONFIG_PM
+/*
+* This will enable the device to be powered up when write() or read()
+* is called. If this is not defined, the driver will return -EBUSY.
+*/
+#define WAKE_ON_ACCESS 1
+
+typedef struct
+{
+        raw_spinlock_t         lock;       /* Used to block on state transitions */
+        au1xxx_power_dev_t *dev;       /* Power Managers device structure */
+        unsigned	   stopped;    /* USed to signaling device is stopped */
+} pm_state;
+#endif
+
+
+typedef struct
+{
+        u32                     tx_dev_id, rx_dev_id, target_dev_id;
+        u32                     tx_chan, rx_chan;
+        void                    *tx_desc_head, *rx_desc_head;
+        ide_hwif_t              *hwif;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        ide_drive_t             *drive;
+        u8                      white_list, black_list;
+        struct dbdma_cmd        *dma_table_cpu;
+        dma_addr_t              dma_table_dma;
+        struct scatterlist      *sg_table;
+        int                     sg_nents;
+        int                     sg_dma_direction;
+#endif
+        struct device           *dev;
+	int			irq;
+	u32			regbase;
+#ifdef CONFIG_PM
+        pm_state                pm;
+#endif
+} _auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+struct drive_list_entry {
+        const char * id_model;
+        const char * id_firmware;
+};
+
+/* HD white list */
+static const struct drive_list_entry dma_white_list [] = {
+/*
+ * Hitachi
+ */
+        { "HITACHI_DK14FA-20"    ,       "ALL"           },
+        { "HTS726060M9AT00"      ,       "ALL"           },
+/*
+ * Maxtor
+ */
+        { "Maxtor 6E040L0"      ,       "ALL"           },
+        { "Maxtor 6Y080P0"      ,       "ALL"           },
+        { "Maxtor 6Y160P0"      ,       "ALL"           },
+/*
+ * Seagate
+ */
+        { "ST3120026A"          ,       "ALL"           },
+        { "ST320014A"           ,       "ALL"           },
+        { "ST94011A"            ,       "ALL"           },
+        { "ST340016A"           ,       "ALL"           },
+/*
+ * Western Digital
+ */
+        { "WDC WD400UE-00HCT0"  ,       "ALL"           },
+        { "WDC WD400JB-00JJC0"  ,       "ALL"           },
+        { NULL                  ,       NULL            }
+};
+
+/* HD black list */
+static const struct drive_list_entry dma_black_list [] = {
+/*
+ * Western Digital
+ */
+        { "WDC WD100EB-00CGH0"  ,       "ALL"           },
+        { "WDC WD200BB-00AUA1"  ,       "ALL"           },
+        { "WDC AC24300L"        ,       "ALL"           },
+        { NULL                  ,       NULL            }
+};
+#endif
+
+/* function prototyping */
+u8 auide_inb(unsigned long port);
+u16 auide_inw(unsigned long port);
+u32 auide_inl(unsigned long port);
+void auide_insw(unsigned long port, void *addr, u32 count);
+void auide_insl(unsigned long port, void *addr, u32 count);
+void auide_outb(u8 addr, unsigned long port);
+void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port);
+void auide_outw(u16 addr, unsigned long port);
+void auide_outl(u32 addr, unsigned long port);
+void auide_outsw(unsigned long port, void *addr, u32 count);
+void auide_outsl(unsigned long port, void *addr, u32 count);
+static void auide_tune_drive(ide_drive_t *drive, byte pio);
+static int auide_tune_chipset (ide_drive_t *drive, u8 speed);
+static int auide_ddma_init( _auide_hwif *auide );
+static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif);
+int __init auide_probe(void);
+
+#ifdef CONFIG_PM
+        int au1200ide_pm_callback( au1xxx_power_dev_t *dev,
+                                   au1xxx_request_t request, void *data);
+        static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_access( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev );
+#endif
+
+
+/*
+ * Multi-Word DMA + DbDMA functions
+ */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+
+        static int in_drive_list(struct hd_driveid *id, 
+                                 const struct drive_list_entry *drive_table);
+        static int auide_build_sglist(ide_drive_t *drive,  struct request *rq);
+        static int auide_build_dmatable(ide_drive_t *drive);
+        static int auide_dma_end(ide_drive_t *drive);
+        static void auide_dma_start(ide_drive_t *drive );
+        ide_startstop_t auide_dma_intr (ide_drive_t *drive);
+        static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command);
+        static int auide_dma_setup(ide_drive_t *drive);
+        static int auide_dma_check(ide_drive_t *drive);
+        static int auide_dma_test_irq(ide_drive_t *drive);
+        static int auide_dma_host_off(ide_drive_t *drive);
+        static int auide_dma_host_on(ide_drive_t *drive);
+        static int auide_dma_lostirq(ide_drive_t *drive);
+        static int auide_dma_on(ide_drive_t *drive);
+        static void auide_ddma_tx_callback(int irq, void *param,
+                                           struct pt_regs *regs);
+        static void auide_ddma_rx_callback(int irq, void *param,
+                                           struct pt_regs *regs);
+        static int auide_dma_off_quietly(ide_drive_t *drive);
+        static int auide_dma_timeout(ide_drive_t *drive);
+
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+/*******************************************************************************
+* PIO Mode timing calculation :                                                *
+*                                                                              *
+* Static Bus Spec   ATA Spec                                                   *
+*      Tcsoe      =   t1                                                       *
+*      Toecs      =   t9                                                       *
+*      Twcs       =   t9                                                       *
+*      Tcsh       =   t2i | t2                                                 *
+*      Tcsoff     =   t2i | t2                                                 *
+*      Twp        =   t2                                                       *
+*      Tcsw       =   t1                                                       *
+*      Tpm        =   0                                                        *
+*      Ta         =   t1+t2                                                    *
+*******************************************************************************/
+
+#define TCSOE_MASK            (0x07<<29)
+#define TOECS_MASK            (0x07<<26)
+#define TWCS_MASK             (0x07<<28)
+#define TCSH_MASK             (0x0F<<24)
+#define TCSOFF_MASK           (0x07<<20)
+#define TWP_MASK              (0x3F<<14)
+#define TCSW_MASK             (0x0F<<10)
+#define TPM_MASK              (0x0F<<6)
+#define TA_MASK               (0x3F<<0)
+#define TS_MASK               (1<<8)
+
+/* Timing parameters PIO mode 0 */
+#define SBC_IDE_PIO0_TCSOE    (0x04<<29)
+#define SBC_IDE_PIO0_TOECS    (0x01<<26)
+#define SBC_IDE_PIO0_TWCS     (0x02<<28)
+#define SBC_IDE_PIO0_TCSH     (0x08<<24)
+#define SBC_IDE_PIO0_TCSOFF   (0x07<<20)
+#define SBC_IDE_PIO0_TWP      (0x10<<14)
+#define SBC_IDE_PIO0_TCSW     (0x04<<10)
+#define SBC_IDE_PIO0_TPM      (0x0<<6)
+#define SBC_IDE_PIO0_TA       (0x15<<0)
+/* Timing parameters PIO mode 1 */
+#define SBC_IDE_PIO1_TCSOE    (0x03<<29)
+#define SBC_IDE_PIO1_TOECS    (0x01<<26)
+#define SBC_IDE_PIO1_TWCS     (0x01<<28)
+#define SBC_IDE_PIO1_TCSH     (0x06<<24)
+#define SBC_IDE_PIO1_TCSOFF   (0x06<<20)
+#define SBC_IDE_PIO1_TWP      (0x08<<14)
+#define SBC_IDE_PIO1_TCSW     (0x03<<10)
+#define SBC_IDE_PIO1_TPM      (0x00<<6)
+#define SBC_IDE_PIO1_TA       (0x0B<<0)
+/* Timing parameters PIO mode 2 */
+#define SBC_IDE_PIO2_TCSOE    (0x05<<29)
+#define SBC_IDE_PIO2_TOECS    (0x01<<26)
+#define SBC_IDE_PIO2_TWCS     (0x01<<28)
+#define SBC_IDE_PIO2_TCSH     (0x07<<24)
+#define SBC_IDE_PIO2_TCSOFF   (0x07<<20)
+#define SBC_IDE_PIO2_TWP      (0x1F<<14)
+#define SBC_IDE_PIO2_TCSW     (0x05<<10)
+#define SBC_IDE_PIO2_TPM      (0x00<<6)
+#define SBC_IDE_PIO2_TA       (0x22<<0)
+/* Timing parameters PIO mode 3 */
+#define SBC_IDE_PIO3_TCSOE    (0x05<<29)
+#define SBC_IDE_PIO3_TOECS    (0x01<<26)
+#define SBC_IDE_PIO3_TWCS     (0x01<<28)
+#define SBC_IDE_PIO3_TCSH     (0x0D<<24)
+#define SBC_IDE_PIO3_TCSOFF   (0x0D<<20)
+#define SBC_IDE_PIO3_TWP      (0x15<<14)
+#define SBC_IDE_PIO3_TCSW     (0x05<<10)
+#define SBC_IDE_PIO3_TPM      (0x00<<6)
+#define SBC_IDE_PIO3_TA       (0x1A<<0)
+/* Timing parameters PIO mode 4 */
+#define SBC_IDE_PIO4_TCSOE    (0x04<<29)
+#define SBC_IDE_PIO4_TOECS    (0x01<<26)
+#define SBC_IDE_PIO4_TWCS     (0x01<<28)
+#define SBC_IDE_PIO4_TCSH     (0x04<<24)
+#define SBC_IDE_PIO4_TCSOFF   (0x04<<20)
+#define SBC_IDE_PIO4_TWP      (0x0D<<14)
+#define SBC_IDE_PIO4_TCSW     (0x03<<10)
+#define SBC_IDE_PIO4_TPM      (0x00<<6)
+#define SBC_IDE_PIO4_TA       (0x12<<0)
+/* Timing parameters MDMA mode 0 */
+#define SBC_IDE_MDMA0_TCSOE   (0x03<<29)
+#define SBC_IDE_MDMA0_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA0_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA0_TCSH    (0x07<<24)
+#define SBC_IDE_MDMA0_TCSOFF  (0x07<<20)
+#define SBC_IDE_MDMA0_TWP     (0x0C<<14)
+#define SBC_IDE_MDMA0_TCSW    (0x03<<10)
+#define SBC_IDE_MDMA0_TPM     (0x00<<6)
+#define SBC_IDE_MDMA0_TA      (0x0F<<0)
+/* Timing parameters MDMA mode 1 */
+#define SBC_IDE_MDMA1_TCSOE   (0x05<<29)
+#define SBC_IDE_MDMA1_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA1_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA1_TCSH    (0x05<<24)
+#define SBC_IDE_MDMA1_TCSOFF  (0x05<<20)
+#define SBC_IDE_MDMA1_TWP     (0x0F<<14)
+#define SBC_IDE_MDMA1_TCSW    (0x05<<10)
+#define SBC_IDE_MDMA1_TPM     (0x00<<6)
+#define SBC_IDE_MDMA1_TA      (0x15<<0)
+/* Timing parameters MDMA mode 2 */
+#define SBC_IDE_MDMA2_TCSOE   (0x04<<29)
+#define SBC_IDE_MDMA2_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA2_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA2_TCSH    (0x04<<24)
+#define SBC_IDE_MDMA2_TCSOFF  (0x04<<20)
+#define SBC_IDE_MDMA2_TWP     (0x0D<<14)
+#define SBC_IDE_MDMA2_TCSW    (0x04<<10)
+#define SBC_IDE_MDMA2_TPM     (0x00<<6)
+#define SBC_IDE_MDMA2_TA      (0x12<<0)
+
Index: linux-2.6.10/include/asm-mips/mach-au1x00/ioremap.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-au1x00/ioremap.h
@@ -0,0 +1,31 @@
+/*
+ *	include/asm-mips/mach-au1x00/ioremap.h
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MACH_AU1X00_IOREMAP_H
+#define __ASM_MACH_AU1X00_IOREMAP_H
+
+#include <linux/types.h>
+
+#ifdef CONFIG_64BIT_PHYS_ADDR
+extern phys_t __fixup_bigphys_addr(phys_t, phys_t);
+#else
+static inline phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+#endif
+
+/*
+ * Allow physical addresses to be fixed up to help 36-bit peripherals.
+ */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return __fixup_bigphys_addr(phys_addr, size);
+}
+
+#endif /* __ASM_MACH_AU1X00_IOREMAP_H */
Index: linux-2.6.10/include/asm-mips/mach-db1x00/db1200.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-db1x00/db1200.h
@@ -0,0 +1,227 @@
+/*
+ * AMD Alchemy DB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_DB1200_H
+#define __ASM_DB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xB9800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+#define BCSR_RESETS_TV		0x0010
+/* not resets but in the same register */
+#define BCSR_RESETS_PWMR1mUX 0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+
+#define BCSR_LEDS_DECIMALS	0x0003
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x19000300)
+#define AU1XXX_SMC91111_IRQ			DB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x18800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			DB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x20000000
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the DB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define DB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define DB1200_IDE_INT			(DB1200_INT_BEGIN + 0)
+#define DB1200_ETH_INT			(DB1200_INT_BEGIN + 1)
+#define DB1200_PC0_INT			(DB1200_INT_BEGIN + 2)
+#define DB1200_PC0_STSCHG_INT	(DB1200_INT_BEGIN + 3)
+#define DB1200_PC1_INT			(DB1200_INT_BEGIN + 4)
+#define DB1200_PC1_STSCHG_INT	(DB1200_INT_BEGIN + 5)
+#define DB1200_DC_INT			(DB1200_INT_BEGIN + 6)
+#define DB1200_FLASHBUSY_INT	(DB1200_INT_BEGIN + 7)
+#define DB1200_PC0_INSERT_INT	(DB1200_INT_BEGIN + 8)
+#define DB1200_PC0_EJECT_INT	(DB1200_INT_BEGIN + 9)
+#define DB1200_PC1_INSERT_INT	(DB1200_INT_BEGIN + 10)
+#define DB1200_PC1_EJECT_INT	(DB1200_INT_BEGIN + 11)
+#define DB1200_SD0_INSERT_INT	(DB1200_INT_BEGIN + 12)
+#define DB1200_SD0_EJECT_INT	(DB1200_INT_BEGIN + 13)
+
+#define DB1200_INT_END			(DB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+
+/* PCMCIA Db1x00 specific defines */
+
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+#define BOARD_PC0_INT DB1200_PC0_INT
+#define BOARD_PC1_INT DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+/* Nand chip select */
+#define NAND_CS 1
+
+#endif /* __ASM_DB1200_H */
+
Index: linux-2.6.10/include/asm-mips/mach-db1x00/db1x00.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/mach-db1x00/db1x00.h
+++ linux-2.6.10/include/asm-mips/mach-db1x00/db1x00.h
@@ -198,5 +198,12 @@ typedef volatile struct
 			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
 			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
 
+#define NAND_CS 1
+
+/* should be done by yamon */
+#define NAND_STCFG  0x00400005 /* 8-bit NAND */
+#define NAND_STTIME 0x00007774 /* valid for 396MHz SD=2 only */
+#define NAND_STADDR 0x12000FFF /* physical address 0x20000000 */
+
 #endif /* __ASM_DB1X00_H */
 
Index: linux-2.6.10/include/asm-mips/mach-pb1x00/pb1200.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pb1x00/pb1200.h
@@ -0,0 +1,255 @@
+/*
+ * AMD Alchemy PB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1200_H
+#define __ASM_PB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xAD800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_SD1WP		0x0800
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+/* not resets but in the same register */
+#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_SD1MUX  0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+#define BCSR_BOARD_SD1PWR	0x0080
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+#define BCSR_INT_SD1INSERT	0x4000
+#define BCSR_INT_SD1EJECT	0x8000
+
+/* PCMCIA Db1x00 specific defines */
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0D000300)
+#define AU1XXX_SMC91111_IRQ			PB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			PB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x1C000000
+
+/* Timing values as described in databook, * ns value stripped of
+ * lower 2 bits.
+ * These defines are here rather than an SOC1200 generic file because
+ * the parts chosen on another board may be different and may require
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the PB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define PB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define PB1200_IDE_INT			(PB1200_INT_BEGIN + 0)
+#define PB1200_ETH_INT			(PB1200_INT_BEGIN + 1)
+#define PB1200_PC0_INT			(PB1200_INT_BEGIN + 2)
+#define PB1200_PC0_STSCHG_INT	(PB1200_INT_BEGIN + 3)
+#define PB1200_PC1_INT			(PB1200_INT_BEGIN + 4)
+#define PB1200_PC1_STSCHG_INT	(PB1200_INT_BEGIN + 5)
+#define PB1200_DC_INT			(PB1200_INT_BEGIN + 6)
+#define PB1200_FLASHBUSY_INT	(PB1200_INT_BEGIN + 7)
+#define PB1200_PC0_INSERT_INT	(PB1200_INT_BEGIN + 8)
+#define PB1200_PC0_EJECT_INT	(PB1200_INT_BEGIN + 9)
+#define PB1200_PC1_INSERT_INT	(PB1200_INT_BEGIN + 10)
+#define PB1200_PC1_EJECT_INT	(PB1200_INT_BEGIN + 11)
+#define PB1200_SD0_INSERT_INT	(PB1200_INT_BEGIN + 12)
+#define PB1200_SD0_EJECT_INT	(PB1200_INT_BEGIN + 13)
+#define PB1200_SD1_INSERT_INT	(PB1200_INT_BEGIN + 14)
+#define PB1200_SD1_EJECT_INT	(PB1200_INT_BEGIN + 15)
+
+#define PB1200_INT_END			(PB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT PB1200_PC0_INT
+#define BOARD_PC1_INT PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+/* Nand chip select */
+#define NAND_CS 1
+
+#endif /* __ASM_PB1200_H */
+
Index: linux-2.6.10/include/linux/ide.h
===================================================================
--- linux-2.6.10.orig/include/linux/ide.h
+++ linux-2.6.10/include/linux/ide.h
@@ -223,7 +223,7 @@ typedef enum {	ide_unknown,	ide_generic,
 		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_etrax100,	ide_acorn,
-		ide_tx4939,
+		ide_tx4939,	ide_au1xxx,
 		ide_forced
 } hwif_chipset_t;
 
Index: linux-2.6.10/mvl_patches/pro-0430.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0430.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(430);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

