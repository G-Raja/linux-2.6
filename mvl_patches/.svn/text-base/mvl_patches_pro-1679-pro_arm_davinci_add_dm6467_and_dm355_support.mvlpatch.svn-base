#! /usr/bin/env bash
# Patch: -pro_arm_davinci_add_dm6467_and_dm355_support
# Date: Mon Jan 21 23:06:14 2008
# Source: MontaVista Software, Inc. and Texas Instruments Inc.
# MR: 23536
# Type: Enhancement
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
# Add support for DM6467 and DM355 to the existing Davinci source
# files.  Please note that this patch does not include updates
# to DMA (dma.c/edma.h) and  sound (mcbsp.[ch]).
# 
# Also please note the following updates
# arch/arm/mach-davinci/Kconfig update include
#  +choice
#  +       prompt "DaVinci ARCH type"
#  +       default ARCH_DAVINCI_DM644x
#  +       
#  ... 
#  +config ARCH_DAVINCI_DM646x
#  +       bool "DaVinci 646x based system"
#  +endchoice 
#  
# include/asm-arm/arch-davinci/debug-macro.S
#  -               strb    \rd, [\rx]
#  +               str     \rd, [\rx]
# This update is due to hardware issue for Davinci HD.  The kernel
# locks up when doing byte access (instead of word access) to any device
# on the vbus. This test has been tested on DaVinci and DM355 with no
# ill affects.
# 
# The reason is that the sound driver currently does not work for the
# combined binary.  This selection is to prevent user from building binary
# with known sound problem.  This selection should be removed once sound
# and other drivers are ready for single binary.
# 
# Adjust white space and line number of the following patches so they
# can be applied.
# pro_arm_davinci_4457-2-GPIO-support.patch
# pro_arm_davinci_vlynq.patch
# pro_arm_davinci_new_pinmux_layer.patch
# 
# Remove reference to arch/arm/mach-davinci files found in this patch.
# p070-ti-feedback.patch
# p081-davinci-nor-flash-driver-fix.patch
# pro_arm_davinci_cpu_id_update.patch
# pro_arm_davinci_davinci-serial-kgdb.patch
# pro_arm_davinci-dm355-core.patch
# pro_arm_davinci_dm355_gpio_fixes.patch
# pro_arm_davinci_dm355-mmc.patch
# pro_arm_davinci_mach-board-sync.patch
# pro_arm_davinci_mach-dm64xx.patch
# pro_arm_davinci_mach_sync_083107.patch
# pro_arm_davinci-nand-dual-chip-select-dm700.patch
# pro_arm_davinci_mach_i2c_expander_op.patch
# pro_arm_davinci_mach-misc-sync.patch
# pro_arm_davinci_misc.patch
# 
# Following patch are obsolete.
# pro_arm_davinci_board-evm.patch
# pro_arm_davinci_tsif_gpio_lpsc.patch
# pro_arm_davinci_mach-clock-sync.patch
# pro_arm_davinci_read-pll1-postdiv-ratio.patch
# pro_arm_davinci_dm6467-remove-line-in-i2c-client-c-file.patch
# pro_arm_davinci_mach-i2c_client_sync.patch
# pro_arm_davinci_dm355_time_fix.patch
# pro_arm_davinci_dm355_irq_unify_fix.patch
# pro_arm_davinci_arch_config.patch
# pro_arm_davinci_include-sync-100507.patch
# 

PATCHNUM=1679
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. and Texas Instruments Inc.
MR: 23536
Type: Enhancement
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:
Add support for DM6467 and DM355 to the existing Davinci source
files.  Please note that this patch does not include updates
to DMA (dma.c/edma.h) and  sound (mcbsp.[ch]).

Also please note the following updates
arch/arm/mach-davinci/Kconfig update include
 +choice
 +       prompt "DaVinci ARCH type"
 +       default ARCH_DAVINCI_DM644x
 +       
 ... 
 +config ARCH_DAVINCI_DM646x
 +       bool "DaVinci 646x based system"
 +endchoice 
 
include/asm-arm/arch-davinci/debug-macro.S
 -               strb    \rd, [\rx]
 +               str     \rd, [\rx]
This update is due to hardware issue for Davinci HD.  The kernel
locks up when doing byte access (instead of word access) to any device
on the vbus. This test has been tested on DaVinci and DM355 with no
ill affects.

The reason is that the sound driver currently does not work for the
combined binary.  This selection is to prevent user from building binary
with known sound problem.  This selection should be removed once sound
and other drivers are ready for single binary.

Adjust white space and line number of the following patches so they
can be applied.
pro_arm_davinci_4457-2-GPIO-support.patch
pro_arm_davinci_vlynq.patch
pro_arm_davinci_new_pinmux_layer.patch

Remove reference to arch/arm/mach-davinci files found in this patch.
p070-ti-feedback.patch
p081-davinci-nor-flash-driver-fix.patch
pro_arm_davinci_cpu_id_update.patch
pro_arm_davinci_davinci-serial-kgdb.patch
pro_arm_davinci-dm355-core.patch
pro_arm_davinci_dm355_gpio_fixes.patch
pro_arm_davinci_dm355-mmc.patch
pro_arm_davinci_mach-board-sync.patch
pro_arm_davinci_mach-dm64xx.patch
pro_arm_davinci_mach_sync_083107.patch
pro_arm_davinci-nand-dual-chip-select-dm700.patch
pro_arm_davinci_mach_i2c_expander_op.patch
pro_arm_davinci_mach-misc-sync.patch
pro_arm_davinci_misc.patch

Following patch are obsolete.
pro_arm_davinci_board-evm.patch
pro_arm_davinci_tsif_gpio_lpsc.patch
pro_arm_davinci_mach-clock-sync.patch
pro_arm_davinci_read-pll1-postdiv-ratio.patch
pro_arm_davinci_dm6467-remove-line-in-i2c-client-c-file.patch
pro_arm_davinci_mach-i2c_client_sync.patch
pro_arm_davinci_dm355_time_fix.patch
pro_arm_davinci_dm355_irq_unify_fix.patch
pro_arm_davinci_arch_config.patch
pro_arm_davinci_include-sync-100507.patch

Index: linux-2.6.10/arch/arm/mach-davinci/board-evm.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/board-evm.c
+++ linux-2.6.10/arch/arm/mach-davinci/board-evm.c
@@ -36,9 +36,6 @@
 #include <linux/major.h>
 #include <linux/root_dev.h>
 #include <linux/dma-mapping.h>
-#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
-#include <linux/usb_musb.h>
-#endif
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/serial.h>
@@ -56,158 +53,114 @@
 #include <asm/mach/flash.h>
 #include <asm/arch/irqs.h>
 #include <asm/arch/hardware.h>
+#include <asm/arch/edma.h>
+#include <linux/kgdb.h>
+#include <asm/arch/cpu.h>
 #include "clock.h"
 
 /**************************************************************************
  * Definitions
  **************************************************************************/
+#define DAVINCI_UART_CLK		27000000
 
-/**************************************************************************
- * Public Functions
- **************************************************************************/
-int cpu_type(void)
-{
-	return MACH_TYPE_DAVINCI_EVM;
-}
-
-extern void davinci_serial_init(void);
-extern void davinci_clk_init(void);
-
-/*
- * USB
- */
-#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
-
-static struct musb_hdrc_platform_data usb_data = {
-#if     defined(CONFIG_USB_MUSB_OTG)
-        /* OTG requires a Mini-AB connector */
-        .mode           = MUSB_OTG,
-#elif   defined(CONFIG_USB_MUSB_PERIPHERAL)
-        .mode           = MUSB_PERIPHERAL,
-#elif   defined(CONFIG_USB_MUSB_HOST)
-        .mode           = MUSB_HOST,
-#endif
-        /* irlml6401 switches 5V */
-        .power          = 255,          /* sustains 3.0+ Amps (!) */
-        .potpgt         = 4,            /* ~8 msec */
-
-        /* REVISIT multipoint is a _chip_ capability; not board specific */
-        .multipoint     = 1,
-};
-
-static struct resource usb_resources [] = {
+static struct plat_serial8250_port serial_platform_data[] = {
 	{
-		/* physical address */
-		.start          = DAVINCI_USB_OTG_BASE,
-		.end            = DAVINCI_USB_OTG_BASE + 0x5ff,
-		.flags          = IORESOURCE_MEM,
+		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
+		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.irq		= IRQ_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= DAVINCI_UART_CLK,
 	},
 	{
-		.start          = IRQ_USBINT,
-		.flags          = IORESOURCE_IRQ,
+		.flags	= 0,
 	},
 };
 
-static u64 usb_dmamask = DMA_32BIT_MASK;
-
-static struct platform_device usb_dev = {
-        .name           = "musb_hdrc",
-        .id             = -1,
-        .dev = {
-                .platform_data  = &usb_data,
-                .dma_mask               = &usb_dmamask,
-                .coherent_dma_mask      = DMA_32BIT_MASK,
-        },
-        .resource       = usb_resources,
-        .num_resources  = ARRAY_SIZE(usb_resources),
+static struct platform_device serial_device	= {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= serial_platform_data,
+	},
 };
 
-static inline void setup_usb(void)
+/**************************************************************************
+ * Public Functions
+ **************************************************************************/
+int cpu_type(void)
 {
-        /* REVISIT:  everything except platform_data setup should be
-         * shared between all DaVinci boards using the same core.
-         */
-        int status;
-
-        status = platform_device_register(&usb_dev);
-        if (status != 0)
-                pr_debug("setup_usb --> %d\n", status);
-        else
-                board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_USB, 1);
+	return MACH_TYPE_DAVINCI_EVM;
 }
 
-#else
-static inline void setup_usb(void)
-{
-        /* NOP */
-}
-#endif  /* CONFIG_USB_MUSB_HDRC */
+extern void davinci_serial_init(struct platform_device *pdev);
 
 #if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
 static struct mtd_partition nand_partitions[] = {
 	/* bootloader (U-Boot, etc) in first sector */
 	{
-	      .name		= "bootloader",
-	      .offset		= 0,
-	      .size		= SZ_256K,
-	      .mask_flags	= MTD_WRITEABLE, /* force read-only */
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= SZ_256K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
 	},
 	/* bootloader params in the next sector */
 	{
-	      .name		= "params",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= SZ_128K,
-	      .mask_flags	= MTD_WRITEABLE, /* force read-only */
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_128K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
 	},
 	/* kernel */
 	{
-	      .name		= "kernel",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= SZ_4M,
-	      .mask_flags	= 0
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags	= 0,
 	},
 	/* file system */
 	{
-	      .name		= "filesystem",
-	      .offset		= MTDPART_OFS_APPEND,
-	      .size		= MTDPART_SIZ_FULL,
-	      .mask_flags	= 0
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0,
 	}
 };
 
 static struct nand_davinci_platform_data nand_data = {
-	.options	= 0,
-	.eccmode	= NAND_ECC_HW3_512,
-	.cle_mask	= 0x10,
-	.ale_mask	= 0x08,
-	.bbt_td		= NULL,
-	.bbt_md		= NULL,
-	.parts		= nand_partitions,
-	.nr_parts	= ARRAY_SIZE(nand_partitions),
+	.options		= 0,
+	.eccmode		= NAND_ECC_HW3_512,
+	.cle_mask		= 0x10,
+	.ale_mask		= 0x08,
+	.bbt_td			= NULL,
+	.bbt_md			= NULL,
+	.parts			= nand_partitions,
+	.nr_parts		= ARRAY_SIZE(nand_partitions),
 };
 
-static struct resource nand_resources[] = {
+static struct resource nand_resources[]		= {
 	[0] = {		/* First memory resource is AEMIF control registers */
-		.start	= DM644X_ASYNC_EMIF_CNTRL_BASE,
-		.end	= DM644X_ASYNC_EMIF_CNTRL_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
+		.start		= DM644X_ASYNC_EMIF_CNTRL_BASE,
+		.end		= DM644X_ASYNC_EMIF_CNTRL_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
 	},
 	[1] = {		/* Second memory resource is NAND I/O window */
-		.start	= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
-		.end	= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16K - 1,
-		.flags	= IORESOURCE_MEM,
+		.start		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
+		.end		= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
 	},
 };
 
 static struct platform_device nand_device = {
-	.name		= "nand_davinci",
-	.id		= 0,
-	.dev		= {
-		.platform_data	= &nand_data
+	.name			= "nand_davinci",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= &nand_data,
 	},
 
-	.num_resources	= ARRAY_SIZE(nand_resources),
-	.resource	= nand_resources,
+	.num_resources		= ARRAY_SIZE(nand_resources),
+	.resource		= nand_resources,
 };
 #endif
 
@@ -215,70 +168,129 @@ static struct platform_device nand_devic
 static struct mtd_partition davinci_evm_nor_partitions[] = {
 	/* bootloader (U-Boot, etc) in first 4 sectors */
 	{
-	.name             = "bootloader",
-	.offset           = 0,
-	.size             = 4 * SZ_64K,
-	.mask_flags       = MTD_WRITEABLE, /* force read-only */
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 4 * SZ_64K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
 	},
 	/* bootloader params in the next 1 sector */
 	{
-	.name             = "params",
-	.offset           = MTDPART_OFS_APPEND,
-	.size             = SZ_64K,
-	.mask_flags	= MTD_WRITEABLE, /* force read-only */
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_64K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
 	},
 	/* kernel */
 	{
-	.name             = "kernel",
-	.offset           = MTDPART_OFS_APPEND,
-	.size             = SZ_2M,
-	.mask_flags       = 0
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_2M,
+		.mask_flags	= 0,
 	},
 	/* file system */
 	{
-	.name             = "filesystem",
-	.offset           = MTDPART_OFS_APPEND,
-	.size             = MTDPART_SIZ_FULL,
-	.mask_flags       = 0
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0,
 	}
 };
 
 static struct flash_platform_data davinci_evm_flash_data = {
-	.map_name       = "cfi_probe",
-	.width          = 2,
-	.parts          = davinci_evm_nor_partitions,
-	.nr_parts       = ARRAY_SIZE(davinci_evm_nor_partitions),
-	};
+	.map_name		= "cfi_probe",
+	.width			= 2,
+	.parts			= davinci_evm_nor_partitions,
+	.nr_parts		= ARRAY_SIZE(davinci_evm_nor_partitions),
+};
 
+/* NOTE: CFI probe will correctly detect flash part as 32M, but EMIF
+ * limits addresses to 16M, so using addresses past 16M will wrap */
 static struct resource davinci_evm_flash_resource = {
-	.start          = DAVINCI_CS0_PHYS,
-	.end            = DAVINCI_CS0_PHYS + SZ_16M -1 ,
-	.flags          = IORESOURCE_MEM,
+	.start			= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
+	.end			= DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16M - 1,
+	.flags			= IORESOURCE_MEM,
 };
 
 static struct platform_device davinci_evm_flash_device = {
-	.name           = "davinciflash",
-	.id             = 0,
-	.dev            = {
-		.platform_data  = &davinci_evm_flash_data,
-		},
-	.num_resources  = 1,
-	.resource       = &davinci_evm_flash_resource,
+	.name			= "davinciflash",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= &davinci_evm_flash_data,
+	},
+
+	.num_resources		= 1,
+	.resource		= &davinci_evm_flash_resource,
 };
 #endif
 
-static struct platform_device *davinci_evm_devices[] __initdata =
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+static struct resource mmc0_resources[] = {
+	[0] = {			/* registers */
+		.start		= DAVINCI_MMC_SD_BASE,
+		.end		= DAVINCI_MMC_SD_BASE + SZ_1K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {			/* interrupt */
+		.start		= IRQ_MMCINT,
+		.end		= IRQ_MMCINT,
+		.flags		= IORESOURCE_IRQ,
+	},
+	[2] = {			/* dma rx */
+		.start		= DAVINCI_DMA_MMCRXEVT,
+		.end		= DAVINCI_DMA_MMCRXEVT,
+		.flags		= IORESOURCE_DMA,
+	},
+	[3] = {			/* dma tx */
+		.start		= DAVINCI_DMA_MMCTXEVT,
+		.end		= DAVINCI_DMA_MMCTXEVT,
+		.flags		= IORESOURCE_DMA,
+	},
+};
+
+static struct davinci_mmc_platform_data mmc0_platform_data = {
+	.mmc_clk		= "MMCSDCLK0",
+	.rw_threshold		= 32,
+	.use_4bit_mode		= 1,
+};
+
+static struct platform_device mmc0_device = {
+	.name			= "mmc",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= &mmc0_platform_data,
+	},
+
+	.num_resources		= ARRAY_SIZE(mmc0_resources),
+	.resource		= mmc0_resources,
+};
+
+static void setup_mmc(void)
 {
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD0, 1);
+}
+#else
+#define setup_mmc()
+#endif
+
+static struct platform_device *davinci_evm_devices[] __initdata = {
+	&serial_device,
 #if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
 	&nand_device,
 #endif
+
 #if defined (CONFIG_MTD_DAVINCI_NOR) || defined(CONFIG_MTD_DAVINCI_NOR_MODULE)
 	&davinci_evm_flash_device,
 #endif
+
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+	&mmc0_device,
+#endif
 };
 
 static void board_init(void)
 {
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VLYNQ, 1);
+
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSMSTR, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSSLV, 1);
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPCC, 1);
@@ -288,34 +300,127 @@ static void board_init(void)
 
 	/* Turn on WatchDog timer LPSC.  Needed for RESET to work */
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
-	davinci_serial_init();
 
-	/* Initialize the clock configurations */
-	davinci_clk_init();
+	davinci_serial_init(&serial_device);
+}
+
+static void dm644x_setup_pinmux(unsigned int id)
+{
+	switch (id) {
+	case DAVINCI_LPSC_ATA:
+		PINMUX0 |= (1 << 17) | (1 << 16);
+		break;
+	case DAVINCI_LPSC_MMC_SD0:
+		/* VDD power manipulations are done in U-Boot for CPMAC
+		* so applies to MMC as well
+		*/
+		/*Set up the pull register for MMC */
+		DAVINCI_VDD3P3V_PWDN = 0x0;
+		PINMUX1 &= (~(1 << 9));
+		break;
+	case DAVINCI_LPSC_I2C:
+		PINMUX1 |= (1 << 7);
+		break;
+	case DAVINCI_LPSC_McBSP0:
+		PINMUX1 |= (1 << 10);
+		break;
+	case DAVINCI_LPSC_PWM0:
+		PINMUX1 |= (1 << 4);
+		break;
+	case DAVINCI_LPSC_PWM1:
+		PINMUX1 |= (1 << 5);
+		break;
+	case DAVINCI_LPSC_PWM2:
+		PINMUX1 |= (1 << 6);
+		break;
+	case DAVINCI_LPSC_VLYNQ:
+		PINMUX0 |= (3 << 12) | (1 << 15);
+		break;
+	default:
+		break;
+
+	}
 }
 
-static void __init
-davinci_map_io(void)
+static void __init davinci_map_io(void)
 {
+	davinci_pinmux_setup = dm644x_setup_pinmux;
 	davinci_map_common_io();
 
+#ifdef CONFIG_KGDB_8250
+	early_serial_setup((struct uart_port *)
+			   &serial_platform_data[kgdb8250_ttyS]);
+	kgdb8250_add_platform_port(kgdb8250_ttyS,
+				   &serial_platform_data[kgdb8250_ttyS]);
+#endif
 	/* Initialize the DaVinci EVM board settigs */
 	board_init ();
 }
 
+int __init davinci_gpio_irq_setup(void);
+
+void davinci_msp430_deep_sleep(void)
+{
+	unsigned int icstr = DAVINCI_I2C_BASE + 0x08;
+	unsigned int icsar = DAVINCI_I2C_BASE + 0x1C;
+	unsigned int iccnt = DAVINCI_I2C_BASE + 0x14;
+	unsigned int icdxr = DAVINCI_I2C_BASE + 0x20;
+	unsigned int icmdr = DAVINCI_I2C_BASE + 0x24;
+	u32 cnt = 0, buflen = 2;
+	char rtcdata[2] = { 2, 8 };
+	char *buffer = rtcdata;
+
+	/* check for bus busy */
+	while (readl(icstr) & 0x1000) ;
+
+	/* configure the count register */
+	writel(2, iccnt);
+
+	/* set the salve address */
+	writel(0x23, icsar);
+
+	/* Take I2C out of reset, configure it as master,
+	 * set the start bit, stop bit and enable the
+	 * transmitter */
+	writel(0x2e20, icmdr);
+
+	while (cnt < buflen) {
+		if ((readl(icstr) & 0x0010) != 0) {
+			writel(*buffer, icdxr);
+			++buffer;
+			++cnt;
+		}
+	}
+}
+
 
 static __init void evm_init(void)
 {
-#if defined(CONFIG_BLK_DEV_DAVINCI) || defined(CONFIG_BLK_DEV_DAVINCI_MODULE)
 #if defined (CONFIG_MTD_DAVINCI_NOR) || defined(CONFIG_MTD_DAVINCI_NOR_MODULE)
-        printk(KERN_WARNING "WARNING: both IDE and NOR flash are enabled, "
-	               "but are pin-muxed.\n\t Disable IDE for NOR support.\n");
+#if defined(CONFIG_BLK_DEV_DAVINCI) || defined(CONFIG_BLK_DEV_DAVINCI_MODULE)
+#warning IDE and NOR flash are are pin-muxed. Disable IDE or NOR.
+	printk(KERN_WARNING "WARNING: both IDE and NOR flash are enabled, "
+		      "but are pin-muxed.\n\t Disable IDE or NOR support.\n");
 #endif
+#if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+#warning NAND and NOR flash are are pin-muxed. Disable NAND or NOR.
+	printk(KERN_WARNING "WARNING: both NAND and NOR flash are enabled, "
+		      "but are pin-muxed.\n\t Disable NAND or NOR support.\n");
+#endif
+#endif
+
+#if defined(CONFIG_BLK_DEV_DAVINCI) || defined(CONFIG_BLK_DEV_DAVINCI_MODULE)
+#if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+#warning IDE and NAND flash are are pin-muxed. Disable IDE or NAND.
+	printk(KERN_WARNING "WARNING: both IDE and NAND flash are enabled, "
+		      "but are pin-muxed.\n\t Disable IDE or NAND support.\n");
 #endif
+#endif
+	pm_power_off = davinci_msp430_deep_sleep;
+	setup_mmc();
+	davinci_gpio_irq_setup();
 	platform_add_devices(davinci_evm_devices,
 		ARRAY_SIZE(davinci_evm_devices));
-
-        setup_usb();
 }
 
 
Index: linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/board-dm355-evm.c
+++ linux-2.6.10/arch/arm/mach-davinci/board-dm355-evm.c
@@ -396,11 +396,53 @@ static void board_init(void)
 	/* Turn on WatchDog timer LPSC.  Needed for RESET to work */
 	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
 	davinci_serial_init(&serial_device);
+	davinci_writel(0x56837210, DAVINCI_VPSS_REGS_BASE + 0x810);
+	davinci_writel(0x7b3c0004, DAVINCI_VPSS_REGS_BASE + 0x814);
+}
+
+static void dm355_setup_pinmux(unsigned int id)
+{
+	switch (id) {
+	case DAVINCI_LPSC_ATA:
+		/* DAVINCI_LPSC_PWM3 */
+		PINMUX1 |= 0x3ca000;
+		PINMUX1 &= ~0x005000;
+		break;
+	case DAVINCI_LPSC_MMC_SD0:
+		PINMUX4 &= (~(1 << 2));
+		break;
+	case DAVINCI_LPSC_MMC_SD1:
+		PINMUX3 &= ~0x0000ff00;
+		PINMUX3 |= 0x000055c0;
+		break;
+	case DAVINCI_LPSC_I2C:
+		PINMUX3 |= (1 << 19);
+		PINMUX3 |= (1 << 20);
+		break;
+	case DAVINCI_LPSC_McBSP0:
+		PINMUX3 |= 0x3F;
+		break;
+	case DAVINCI_LPSC_PWM0:
+		PINMUX1 |= 0x2;
+		PINMUX1 &= ~0x1;
+		break;
+	case DAVINCI_LPSC_PWM1:
+		PINMUX1 |= 0x8;
+		PINMUX1 &= ~0x4;
+		break;
+	case DAVINCI_LPSC_PWM2:
+		PINMUX1 |= 0xaa0;
+		PINMUX1 &= ~0x550;
+		break;
+	default:
+		break;
+	}
 }
 
 static void __init
 davinci_map_io(void)
 {
+	davinci_pinmux_setup = dm355_setup_pinmux;
 	davinci_map_common_io();
 
 #ifdef CONFIG_KGDB_8250
Index: linux-2.6.10/arch/arm/mach-davinci/board-dm6467-evm.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/arm/mach-davinci/board-dm6467-evm.c
@@ -0,0 +1,309 @@
+/*
+ * TI DaVinci DM6467 EVM board
+ *
+ * Derived from: arch/arm/mach-davinci/board-evm.c
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ */
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/serial.h>
+#include <linux/mtd/nand.h>
+#include <linux/serial_8250.h>
+#include <linux/nand_davinci.h>
+
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/edma.h>
+#include <linux/kgdb.h>
+#include <asm/arch/cpu.h>
+#include "clock.h"
+
+/**************************************************************************
+ * Definitions
+ **************************************************************************/
+#define DAVINCI_DM646X_UART_CLK		24000000
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
+		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.irq		= IRQ_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= DAVINCI_DM646X_UART_CLK,
+	},
+	{
+		.membase	= (char *)IO_ADDRESS(DAVINCI_UART1_BASE),
+		.mapbase	= (unsigned long)DAVINCI_UART1_BASE,
+		.irq		= IRQ_UARTINT1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= DAVINCI_DM646X_UART_CLK,
+	},
+	{
+		.membase	= (char *)IO_ADDRESS(DM644X_UART2_BASE),
+		.mapbase	= (unsigned long)DM644X_UART2_BASE,
+		.irq		= IRQ_UARTINT2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= DAVINCI_DM646X_UART_CLK,
+	},
+	{
+		.flags	= 0,
+	},
+};
+
+static struct platform_device serial_device	= {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= serial_platform_data,
+	},
+};
+
+/**************************************************************************
+ * Public Functions
+ **************************************************************************/
+extern void davinci_serial_init(struct platform_device *pdev);
+
+#if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+static struct mtd_partition dm646x_nand_partitions[] = {
+	/* bootloader (U-Boot, etc) in first sector */
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= SZ_512K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	/* bootloader params in the next sector */
+	{
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_128K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	/* kernel */
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags		= 0,
+	},
+	/* file system */
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags		= 0,
+	}
+};
+
+static struct nand_davinci_platform_data dm646x_nand_data = {
+	.options		= 0,
+	.eccmode		= NAND_ECC_HW3_512,
+	.cle_mask		= 0x80000,
+	.ale_mask		= 0x40000,
+	.parts			= dm646x_nand_partitions,
+	.nr_parts		= ARRAY_SIZE(dm646x_nand_partitions),
+};
+
+static struct resource dm646x_nand_resources[] = {
+	[0] = {		/* First memory resource is AEMIF control registers */
+		.start		= DAVINCI_DM646X_ASYNC_EMIF_CNTRL_BASE,
+		.end		= DAVINCI_DM646X_ASYNC_EMIF_CNTRL_BASE +
+					SZ_16K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {		/* Second memory resource is NAND I/O window */
+		.start		= DAVINCI_DM646X_ASYNC_EMIF_DATA_CE0_BASE,
+		.end		= DAVINCI_DM646X_ASYNC_EMIF_DATA_CE0_BASE +
+					SZ_512K + 2 * SZ_1K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device nand_device = {
+	.name			= "nand_davinci",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= &dm646x_nand_data,
+	},
+
+	.num_resources		= ARRAY_SIZE(dm646x_nand_resources),
+	.resource		= dm646x_nand_resources,
+};
+#endif
+
+#if defined (CONFIG_MTD_CFI_INTELEXT) || defined(CONFIG_MTD_AMDSTD)
+static struct mtd_partition davinci_evm_nor_partitions[] = {
+	/* bootloader (U-Boot, etc) in first 4 sectors */
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 2 * SZ_64K,
+		.mask_flags	= 0,
+	},
+	/* bootloader params in the next 1 sector */
+	{
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 2 * SZ_64K,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	/* kernel */
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags	= 0,
+	},
+	/* file system */
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0,
+	}
+};
+
+static struct flash_platform_data davinci_evm_flash_data = {
+	.parts			= davinci_evm_nor_partitions,
+	.nr_parts		= ARRAY_SIZE(davinci_evm_nor_partitions),
+};
+
+static struct resource davinci_evm_flash_resource = {
+	.start			= DAVINCI_DM646X_ASYNC_EMIF_DATA_CE0_BASE,
+	.end			= DAVINCI_DM646X_ASYNC_EMIF_DATA_CE0_BASE +
+					SZ_64K - 1,
+	.flags			= IORESOURCE_MEM,
+};
+
+static struct platform_device davinci_evm_flash_device = {
+	.name			= "nor_davinci",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= &davinci_evm_flash_data,
+	},
+
+	.num_resources		= 1,
+	.resource		= &davinci_evm_flash_resource,
+};
+#endif
+
+static struct platform_device *davinci_evm_devices[] __initdata = {
+	&serial_device,
+#if defined (CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+	&nand_device,
+#endif
+
+#if defined (CONFIG_MTD_CFI_INTELEXT) || defined(CONFIG_MTD_AMDSTD)
+	&davinci_evm_flash_device,
+#endif
+};
+
+static void board_init(void)
+{
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VLYNQ, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_HDVICP0, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_HDVICP1, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_SPI, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TPCC, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TPTC0, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TPTC1, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TPTC2, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TPTC3, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_AEMIF, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_GPIO, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TSIF0, 1);
+	board_setup_psc(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_DM646X_LPSC_TSIF1, 1);
+
+	davinci_serial_init(&serial_device);
+}
+
+static void dm646x_setup_pinmux(unsigned int id)
+{
+	switch (id) {
+	case DAVINCI_LPSC_ATA:
+		PINMUX0 |= 1;
+		break;
+	case DAVINCI_LPSC_USB:
+		PINMUX0 &= 0x7FFFFFFF;
+		DAVINCI_VDD3P3V_PWDN &= 0xEFFFFFFF;
+		break;
+	case DAVINCI_DM646X_LPSC_I2C:
+		break;
+	case DAVINCI_DM646X_LPSC_PWM0:
+		break;
+	case DAVINCI_DM646X_LPSC_PWM1:
+		break;
+	default:
+		break;
+	}
+}
+
+static void __init davinci_map_io(void)
+{
+	davinci_pinmux_setup = dm646x_setup_pinmux;
+	davinci_map_common_io();
+
+#ifdef CONFIG_KGDB_8250
+	early_serial_setup((struct uart_port *)
+			   &serial_platform_data[kgdb8250_ttyS]);
+	kgdb8250_add_platform_port(kgdb8250_ttyS,
+				   &serial_platform_data[kgdb8250_ttyS]);
+#endif
+	/* Initialize the DaVinci EVM board settigs */
+	board_init();
+}
+
+int __init davinci_gpio_irq_setup(void);
+
+static __init void evm_init(void)
+{
+	davinci_gpio_irq_setup();
+
+	platform_add_devices(davinci_evm_devices,
+		ARRAY_SIZE(davinci_evm_devices));
+}
+
+extern void davinci_irq_init(void);
+extern struct sys_timer davinci_timer;
+
+MACHINE_START(DAVINCI_EVM, "DaVinci DM6467 EVM")
+    MAINTAINER("Texas Instruments, PSP Team")
+    BOOT_MEM(DAVINCI_DDR_BASE, IO_PHYS, IO_VIRT)
+    BOOT_PARAMS(0x80000100)
+    MAPIO(davinci_map_io)
+    INITIRQ(davinci_irq_init)
+    .timer = &davinci_timer,
+    INIT_MACHINE(evm_init)
+    MACHINE_END
Index: linux-2.6.10/arch/arm/mach-davinci/clock.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/clock.c
+++ linux-2.6.10/arch/arm/mach-davinci/clock.c
@@ -46,10 +46,9 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/hardware.h>
+#include <asm/arch/cpu.h>
 #include "clock.h"
 
-#define DAVINCI_MAX_CLK 12
-
 #define PLL1_PLLM   __REG(0x01c40910)
 #define PLL2_PLLM   __REG(0x01c40D10)
 #define PTCMD       __REG(0x01C41120)
@@ -64,13 +63,20 @@
 
 #define PINMUX0     __REG(0x01c40000)
 #define PINMUX1     __REG(0x01c40004)
+#define PINMUX3     __REG(0x01C4000C)
+#define PINMUX4     __REG(0x01c40010)
 
 static LIST_HEAD(clocks);
 static DECLARE_MUTEX(clocks_sem);
 static DEFINE_RAW_SPINLOCK(clockfw_lock);
 static unsigned int commonrate;
+static unsigned int div_by_four;
+static unsigned int div_by_six;
+static unsigned int div_by_eight;
 static unsigned int armrate;
-static unsigned int fixedrate = 27000000;	/* 27 MHZ */
+static unsigned int fixedrate;
+
+void (*davinci_pinmux_setup)(unsigned int id);
 
 /**************************************
  Routine: board_setup_psc
@@ -107,39 +113,6 @@ void board_setup_psc(unsigned int domain
 	}
 }
 
-static int board_setup_peripheral(unsigned int id)
-{
-	switch (id) {
-	case DAVINCI_LPSC_ATA:
-		PINMUX0 |= (1 << 17) | (1 << 16);
-		break;
-	case DAVINCI_LPSC_MMC_SD:
-		/* VDD power manupulations are done in U-Boot for CPMAC
-		 * so applies to MMC as well
-		 */
-		/*Set up the pull regiter for MMC */
-		VDD3P3V_PWDN = 0x0;
-		PINMUX1 &= (~(1 << 9));
-		break;
-	case DAVINCI_LPSC_I2C:
-		PINMUX1 |= (1 << 7);
-		break;
-	case DAVINCI_LPSC_McBSP:
-		PINMUX1 |= (1 << 10);
-		break;
-	case DAVINCI_LPSC_PWM0:
-		PINMUX1 |= (1 << 4);
-		break;
-	case DAVINCI_LPSC_PWM1:
-		PINMUX1 |= (1 << 5);
-		break;
-	case DAVINCI_LPSC_PWM2:
-		PINMUX1 |= (1 << 6);
-		break;
-	default:
-		break;
-	}
-}
 struct clk *clk_get(struct device *dev, const char *id)
 {
 	struct clk *p, *clk = ERR_PTR(-ENOENT);
@@ -208,7 +181,11 @@ int clk_enable(struct clk *clk)
 	spin_lock_irqsave(&clockfw_lock, flags);
 	ret = __clk_enable(clk);
 	spin_unlock_irqrestore(&clockfw_lock, flags);
-	board_setup_peripheral(clk->lpsc);
+	if (davinci_pinmux_setup)
+		davinci_pinmux_setup(clk->lpsc);
+	else
+		printk (KERN_WARNING "WARNING davinci_pinmux_setup "
+			"uninitialized\n");
 	return ret;
 }
 
@@ -275,7 +252,7 @@ void clk_unregister(struct clk *clk)
 
 EXPORT_SYMBOL(clk_unregister);
 
-static struct clk davinci_clks[DAVINCI_MAX_CLK] = {
+static struct clk davinci_dm644x_clks[] = {
 	{
 		.name = "ARMCLK",
 		.rate = &armrate,
@@ -283,7 +260,7 @@ static struct clk davinci_clks[DAVINCI_M
 		.flags = ALWAYS_ENABLED,
 	},
 	{
-		.name = "UART",
+		.name = "UART0",
 		.rate = &fixedrate,
 		.lpsc = DAVINCI_LPSC_UART0,
 		.usecount = 1,
@@ -304,14 +281,14 @@ static struct clk davinci_clks[DAVINCI_M
 		.lpsc = DAVINCI_LPSC_ATA,
 	},
 	{
-		.name = "McBSPCLK",
+		.name = "McBSPCLK0",
 		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_McBSP,
+		.lpsc = DAVINCI_LPSC_McBSP0,
 	},
 	{
-		.name = "MMCSDCLK",
+		.name = "MMCSDCLK0",
 		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_MMC_SD,
+		.lpsc = DAVINCI_LPSC_MMC_SD0,
 	},
 	{
 		.name = "SPICLK",
@@ -325,31 +302,252 @@ static struct clk davinci_clks[DAVINCI_M
 		.usecount = 1,
 	},
 	{
-                .name = "PWM0_CLK",
-                .rate = &fixedrate,
-                .lpsc = DAVINCI_LPSC_PWM0,
-        },
-	{
-                .name = "PWM1_CLK",
-                .rate = &fixedrate,
-                .lpsc = DAVINCI_LPSC_PWM1,
-        },
-	{
-                .name = "PWM2_CLK",
-                .rate = &fixedrate,
-                .lpsc = DAVINCI_LPSC_PWM2,
-        }
+		.name = "PWM0_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM1,
+	},
+	{
+		.name = "PWM2_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM2,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
+};
+static struct clk davinci_dm6467_clks[] = {
+	{
+		.name = "ARMCLK",
+		.rate = &armrate,
+		.lpsc = -1,
+		.flags = ALWAYS_ENABLED,
+	},
+	{
+		.name = "UART0",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART0,
+		.usecount = 1,
+	},
+	{
+		.name = "UART1",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART1,
+		.usecount = 1,
+	},
+	{
+		.name = "UART2",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART2,
+		.usecount = 1,
+	},
+	{
+		.name = "EMACCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_EMAC,
+	},
+	{
+		.name = "I2CCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_I2C,
+	},
+	{
+		.name = "IDECLK",
+		.rate = &div_by_six,
+		.lpsc = DAVINCI_LPSC_ATA,
+	},
+	{
+		.name = "McASPCLK0",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_McASP0,
+	},
+	{
+		.name = "McASPCLK1",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_McASP1,
+	},
+	{
+		.name = "SPICLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_SPI,
+	},
+	{
+		.name = "AEMIFCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_AEMIF,
+		.usecount = 1,
+	},
+	{
+		.name = "PWM0_CLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_PWM1,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
+};
+static struct clk davinci_dm355_clks[] = {
+	{
+		.name = "ARMCLK",
+		.rate = &armrate,
+		.lpsc = -1,
+		.flags = ALWAYS_ENABLED,
+	},
+	{
+		.name = "UART0",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART0,
+		.usecount = 1,
+	},
+	{
+		.name = "UART1",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART1,
+		.usecount = 1,
+	},
+	{
+		.name = "UART2",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART2,
+		.usecount = 1,
+	},
+	{
+		.name = "EMACCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_EMAC_WRAPPER,
+	},
+	{
+		.name = "I2CCLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_I2C,
+	},
+	{
+		.name = "IDECLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_ATA,
+	},
+	{
+		.name = "McBSPCLK0",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_McBSP0,
+	},
+	{
+		.name = "McBSPCLK1",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_McBSP1,
+	},
+	{
+		.name = "MMCSDCLK0",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_MMC_SD0,
+	},
+	{
+		.name = "MMCSDCLK1",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_MMC_SD1,
+	},
+	{
+		.name = "SPICLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_SPI,
+	},
+	{
+		.name = "gpio",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_GPIO,
+	},
+	{
+		.name = "AEMIFCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_AEMIF,
+		.usecount = 1,
+	},
+	{
+		.name = "PWM0_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM1,
+	},
+	{
+		.name = "PWM2_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM2,
+	},
+	{
+		.name = "PWM3_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM3,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
 };
 
 void davinci_clk_init(void)
 {
 	struct clk *clkp;
-	int count = 0;
+	static struct clk *board_clks;
+	int count = 0, num_clks;
+
+	if (cpu_is_davinci_dm355()) {
+		/*
+		 * FIXME
+		 * We're assuming a 24MHz reference, but the DM355 also
+		 * supports a 36MHz reference.
+		 */
+		unsigned long postdiv;
+
+		/*
+		 * Read the PLL1 POSTDIV register to determine if the post
+		 * divider is /1 or /2
+		 */
+		postdiv = (davinci_readl(DAVINCI_PLL_CNTRL0_BASE + 0x128)
+			& 0x1f) + 1;
 
-	commonrate = ((PLL1_PLLM + 1) * 27000000) / 6;
-	armrate = ((PLL1_PLLM + 1) * 27000000) / 2;
+		fixedrate = 24000000;
+		armrate = (PLL1_PLLM + 1) * (fixedrate / (16 * postdiv));
+		commonrate = armrate / 2;
+
+		board_clks = davinci_dm355_clks;
+		num_clks = ARRAY_SIZE(davinci_dm355_clks);
+	} else if (cpu_is_davinci_dm6467()) {
+		fixedrate = 24000000;
+		div_by_four = ((PLL1_PLLM + 1) * 27000000) / 4;
+		div_by_six = ((PLL1_PLLM + 1) * 27000000) / 6;
+		div_by_eight = ((PLL1_PLLM + 1) * 27000000) / 8;
+		armrate = ((PLL1_PLLM + 1) * 27000000) / 2;
+
+		board_clks = davinci_dm6467_clks;
+		num_clks = ARRAY_SIZE(davinci_dm6467_clks);
+	} else {
+		fixedrate = 27000000;
+		armrate = (PLL1_PLLM + 1) * (fixedrate / 2);
+		commonrate = armrate / 3;
+
+		board_clks = davinci_dm644x_clks;
+		num_clks = ARRAY_SIZE(davinci_dm644x_clks);
+	}
 
-	for (clkp = davinci_clks; count < DAVINCI_MAX_CLK; count++, clkp++) {
+	for (clkp = board_clks; count < num_clks; count++, clkp++) {
 		clk_register(clkp);
 
 		/* Turn on clocks that have been enabled in the
Index: linux-2.6.10/arch/arm/mach-davinci/i2c-client.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/i2c-client.c
+++ linux-2.6.10/arch/arm/mach-davinci/i2c-client.c
@@ -29,6 +29,9 @@
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <asm/arch/i2c-client.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <asm/arch/mux.h>
 
 static unsigned long initialized;
 static struct semaphore expander_sema;
@@ -122,71 +125,145 @@ int davinci_i2c_expander_op(u16 client_a
 
 	down(&expander_sema);
 
-	err = davinci_i2c_read(1, &data_to_u35, 0x3A);
+	if (!cpu_is_davinci_dm6467()) {
+		err = davinci_i2c_read(1, &data_to_u35, 0x3A);
 
-	if (client_addr == 0x3A) {
-		switch (pin) {
-		case USB_DRVVBUS:
-			if (val)
-				data_to_u35 |= val;
-			else {
-				data_to_u35 &= (val | 0xFE);
+		if (client_addr == 0x3A) {
+			switch (pin) {
+			case USB_DRVVBUS:
+				if (val)
+					data_to_u35 |= val;
+				else {
+					data_to_u35 &= (val | 0xFE);
+				}
+				break;
+			case VDDIMX_EN:
+				if (val)
+					data_to_u35 |= (val << 1);
+				else {
+					data_to_u35 &= (val | 0xFD);
+				}
+				break;
+			case VLYNQ_ON:
+				if (val)
+					data_to_u35 |= (val << 2);
+				else {
+					data_to_u35 &= (val | 0xFB);
+				}
+				break;
+			case CF_RESET:
+				if (val)
+					data_to_u35 |= (val << 3);
+				else {
+					data_to_u35 &= (val | 0xF7);
+				}
+				break;
+			case WLAN_RESET:
+				if (val)
+					data_to_u35 |= (val << 5);
+				else {
+					data_to_u35 &= (val | 0xDF);
+				}
+				break;
+			case ATA_SEL:
+				if (val)
+					data_to_u35 |= (val << 6);
+				else {
+					data_to_u35 &= (val | 0xBF);
+				}
+				break;
+			case CF_SEL:
+				davinci_i2c_write(4, cmd, 0x23);
+				if (val)
+					data_to_u35 |= (val << 7);
+				else {
+					data_to_u35 &= (val | 0x7F);
+				}
+				break;
+			default:
+				break;
 			}
-			break;
-		case VDDIMX_EN:
-			if (val)
-				data_to_u35 |= (val << 1);
-			else {
-				data_to_u35 &= (val | 0xFD);
-			}
-			break;
-		case VLYNQ_ON:
-			if (val)
-				data_to_u35 |= (val << 2);
-			else {
-				data_to_u35 &= (val | 0xFB);
-			}
-			break;
-		case CF_RESET:
-			if (val)
-				data_to_u35 |= (val << 3);
-			else {
-				data_to_u35 &= (val | 0xF7);
-			}
-			break;
-		case WLAN_RESET:
-			if (val)
-				data_to_u35 |= (val << 5);
-			else {
-				data_to_u35 &= (val | 0xDF);
-			}
-			break;
-		case ATA_SEL:
-			if (val)
-				data_to_u35 |= (val << 6);
-			else {
-				data_to_u35 &= (val | 0xBF);
-			}
-			break;
-		case CF_SEL:
-			davinci_i2c_write(4, cmd, 0x23);
-			if (val)
-				data_to_u35 |= (val << 7);
-			else {
-				data_to_u35 &= (val | 0x7F);
-			}
-			break;
-		default:
-			break;
+		} else {
+			printk(KERN_WARNING "Only IO Expander at address 0x3A "
+			       "is supported\n");
+			up(&expander_sema);
+			return -1;
 		}
+
+		err = davinci_i2c_write(1, &data_to_u35, 0x3A);
 	} else {
-		printk("Only IO Expander at address 0x3A is suuported\n");
-		up(&expander_sema);
-		return -1;
-	}
+		err = davinci_i2c_read(1, &data_to_u35, 0x3A);
 
-	err = davinci_i2c_write(1, &data_to_u35, 0x3A);
+		if (client_addr == 0x3A) {
+			switch (pin) {
+			case ATA_SEL_DM646X:
+				if (val)
+					data_to_u35 |= val;
+				else {
+					data_to_u35 &= (val | 0xFE);
+				}
+				break;
+			case ATA_PWD_DM646X:
+				if (val)
+					data_to_u35 |= (val << 1);
+				else {
+					data_to_u35 &= (val | 0xFD);
+				}
+				break;
+			case VSCALE_ON_DM646X:
+				if (val)
+					data_to_u35 |= (val << 2);
+				else {
+					data_to_u35 &= (val | 0xFB);
+				}
+				break;
+			case VLYNQ_RESET_DM646X:
+				if (val)
+					data_to_u35 |= (val << 3);
+				else {
+					data_to_u35 &= (val | 0xF7);
+				}
+				break;
+			case I2C_INT_DM646X:
+				if (val)
+					data_to_u35 |= (val << 6);
+				else {
+					data_to_u35 &= (val | 0xBF);
+				}
+				break;
+			case USB_FB_DM646X:
+				if (val)
+					data_to_u35 |= (val << 7);
+				else {
+					data_to_u35 &= (val | 0x7F);
+				}
+				break;
+			case CIR_MOD_DM646X:
+				if (val)
+					data_to_u35 |= (val << 5);
+				else {
+					data_to_u35 &= (val | 0xDF);
+				}
+				break;
+			case CIR_DEMOD_DM646X:
+				if (val)
+					data_to_u35 |= (val << 4);
+				else {
+					data_to_u35 &= (val | 0xEF);
+				}
+				break;
+			default:
+				break;
+			}
+		} else {
+			printk(KERN_WARNING "Only IO Expander at address 0x3A "
+			       "is supported\n");
+			up(&expander_sema);
+			return -1;
+		}
 
+		err = davinci_i2c_write(1, &data_to_u35, 0x3A);
+	}
 	up(&expander_sema);
 
 	return err;
@@ -246,7 +323,7 @@ static int davinci_i2c_client_init(void)
 		return 0;
 	initialized = 1;
 
-	init_MUTEX (&expander_sema);
+	init_MUTEX(&expander_sema);
 
 	driver->owner = THIS_MODULE;
 	strlcpy(driver->name, "Davinci I2C driver", sizeof(driver->name));
@@ -273,3 +350,4 @@ static void davinci_i2c_client_cleanup(v
 }
 
 module_init(davinci_i2c_client_init);
+module_exit(davinci_i2c_client_cleanup);
Index: linux-2.6.10/arch/arm/mach-davinci/io.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/io.c
+++ linux-2.6.10/arch/arm/mach-davinci/io.c
@@ -19,9 +19,11 @@
 
 #include <asm/mach/map.h>
 #include <asm/arch/memory.h>
+#include <asm/arch/cpu.h>
 
 extern int davinci_clk_init(void);
 extern void davinci_check_revision(void);
+unsigned int davinci_cpu_index = DM644X_CPU_IDX;
 
 /*
  * The machine specific code may provide the extra mapping besides the
@@ -32,13 +34,35 @@ static struct map_desc davinci_io_desc[]
 		.virtual	= IO_VIRT,
 		.physical	= IO_PHYS,
 		.length		= IO_SIZE,
-		.type		= MT_DEVICE
+		.type		= MT_DEVICE,
 	},
+};
+static struct map_desc dm644x_io_desc[] __initdata = {
 	{
 		.virtual	= DAVINCI_IRAM_VIRT,
 		.physical	= DAVINCI_IRAM_BASE,
+		.length		= DAVINCI_IRAM_SIZE,
+		.type		= MT_DEVICE,
+	},
+};
+static struct map_desc dm646x_io_desc[] __initdata = {
+	{
+		.virtual	= DM646X_IO_VIRT,
+		.physical	= DM646X_IO_PHYS,
+		.length		= DM646X_IO_SIZE,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= DAVINCI_IRAM_VIRT,
+		.physical	= DM646X_IRAM_BASE,
+		.length		= DAVINCI_IRAM_SIZE,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= EMIF_CNTRL_VIRT,
+		.physical	= DAVINCI_DM646X_ASYNC_EMIF_CNTRL_BASE,
 		.length		= SZ_16K,
-		.type		= MT_DEVICE
+		.type		= MT_DEVICE,
 	},
 };
 
@@ -46,6 +70,20 @@ void __init davinci_map_common_io(void)
 {
 	iotable_init(davinci_io_desc, ARRAY_SIZE(davinci_io_desc));
 
+	/* We want to check CPU revision early for cpu_is_davinci_xxxx() macros.
+	 * IO space mapping must be initialized before we can do that.
+	 */
+	davinci_check_revision();
+
+	if (cpu_is_davinci_dm644x()) {
+		iotable_init(dm644x_io_desc, ARRAY_SIZE(dm644x_io_desc));
+	} else if (cpu_is_davinci_dm6467()) {
+		davinci_cpu_index = DM6467_CPU_IDX;
+		iotable_init(dm646x_io_desc, ARRAY_SIZE(dm646x_io_desc));
+	} else if (cpu_is_davinci_dm355()) {
+		davinci_cpu_index = DM355_CPU_IDX;
+	}
+
 	/* Normally devicemaps_init() would flush caches and tlb after
 	 * mdesc->map_io(), but we must also do it here because of the CPU
 	 * revision check below.
@@ -53,13 +91,5 @@ void __init davinci_map_common_io(void)
 	flush_tlb_all();
 	flush_cache_all();
 
-	/* We want to check CPU revision early for cpu_is_omapxxxx() macros.
-	 * IO space mapping must be initialized before we can do that.
-	 */
-	davinci_check_revision();
-}
-
-void __init davinci_init_common_hw(void)
-{
 	davinci_clk_init();
 }
Index: linux-2.6.10/arch/arm/mach-davinci/serial.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/serial.c
+++ linux-2.6.10/arch/arm/mach-davinci/serial.c
@@ -26,37 +26,102 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/tty.h>
-#include <linux/ioport.h>
+#include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/console.h>
-#include <linux/serial_core.h>
-#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/hardware.h>
+#include <asm/hardware/clock.h>
 #include <asm/serial.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/irqs.h>
+#include <asm/arch/cpu.h>
 
-static struct uart_port serial_platform_data = {
-	.membase  = (unsigned char __iomem *)IO_ADDRESS(DAVINCI_UART0_BASE),
-	.mapbase  = (unsigned long)DAVINCI_UART0_BASE,
-	.iotype   = UPIO_MEM,
-	.irq      = IRQ_UARTINT0,
-	.uartclk  = 27000000,
-	.regshift = 2,
-	.flags    = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-};
+#define UART_DAVINCI_PWREMU 0x0c
 
+static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
+					     int offset)
+{
+	offset <<= up->regshift;
+	return (unsigned int)__raw_readb(up->membase + offset);
+}
+
+static inline void davinci_serial_outp(struct plat_serial8250_port *p,
+				       int offset, int value)
+{
+	offset <<= p->regshift;
+	__raw_writeb(value, p->membase + offset);
+}
+
+static void __init davinci_serial_reset(struct plat_serial8250_port *p)
+{
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	unsigned int pwremu = 0;
+
+	davinci_serial_outp(p, UART_IER, 0);	/* disable all interrupts */
+
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	mdelay(10);
+
+	pwremu |= (0x3 << 13);
+	pwremu |= 0x1;
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+}
+
+#define UART_DM6467_SCR		__REG(DAVINCI_UART0_BASE + 0x40)
 /*
- * Just setup the initial console rest is taken care by the
- * Linux 8250 serial driver
+ * Internal UARTs need to be initialized for the 8250 autoconfig to work
+ * properly. Note that the TX watermark initialization may not be needed
+ * once the 8250.c watermark handling code is merged.
  */
-void davinci_serial_init(void)
+static int __init dm646x_serial_reset(void)
 {
-#ifdef CONFIG_SERIAL_8250
-	early_serial_setup(&serial_platform_data);
-#endif
+	UART_DM6467_SCR = 0x08;
+
+	return 0;
 }
+
+void __init davinci_serial_init(struct platform_device *pdev)
+{
+	struct clk *uart_clk;
+	struct device *dev = &pdev->dev;
+	struct plat_serial8250_port *p;
+	int uart;
+	char uart_name[6];
+
+	memset(uart_name, 0, sizeof(uart_name));
+	for (p = dev->platform_data; p && p->flags; p++) {
+		switch (p->mapbase) {
+		case DAVINCI_UART0_BASE:
+			uart = 0;
+			break;
+		case DAVINCI_UART1_BASE:
+			uart = 1;
+			break;
+		case DM644X_UART2_BASE:
+		case DM355_UART2_BASE:
+			uart = 2;
+			break;
+		default:
+			dev_err(dev,
+				"Unknown UART base address 0x%08lx\n",
+				p->mapbase);
+			continue;
+		}
+		sprintf(uart_name, "UART%i", uart);
+		uart_clk = clk_get(dev, uart_name);
+		if (IS_ERR(uart_clk))
+			dev_err(dev, "failed to get %s clock\n", uart_name);
+		else
+			clk_enable(uart_clk);
+
+		if (cpu_is_davinci_dm355())
+			davinci_serial_reset(p);
+	}
+}
+
+late_initcall(dm646x_serial_reset);
Index: linux-2.6.10/arch/arm/mach-davinci/time.c
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/time.c
+++ linux-2.6.10/arch/arm/mach-davinci/time.c
@@ -32,22 +32,40 @@
 #include <asm/arch/timex.h>
 #include <asm/arch/irqs.h>
 #include <asm/errno.h>
-#include <asm/hrtime.h> /* for cycles-to-nsec macros */
+#include <linux/hrtime.h>		/* for cycles-to-nsec macros */
+#include <asm/arch/cpu.h>
 
+/* T0 and T1 can be divided into 2 - 32 bit timer; however, T2 (watchdog
+timer) can only be used as a single 64-bit timer */
 enum {
-	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, NUM_TIMERS,
+	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, T2_WDT, MAX_TIMERS,
 };
-#define IS_TIMER1(id)    (id & 0x2)
-#define IS_TIMER0(id)    (!IS_TIMER1(id))
+static int NUM_TIMERS;
+
 #define IS_TIMER_TOP(id) ((id & 0x1))
 #define IS_TIMER_BOT(id) (!IS_TIMER_TOP(id))
 
-int timer_irqs[NUM_TIMERS] = {
+const unsigned int davinci_ck_rate[] = {
+	DM644X_CLOCK_TICK_RATE,
+	DM646X_CLOCK_TICK_RATE,
+	DM355_CLOCK_TICK_RATE
+};
+
+static int dm646x_timer_irqs[] = {
+	IRQ_TINT0_TINT12,
+	IRQ_TINT0_TINT34,
+	IRQ_TINT1_TINT12,
+	IRQ_TINT1_TINT34,
+	IRQ_DM646X_WDINT,
+};
+
+static int davinci_timer_irqs[] = {
 	IRQ_TINT0_TINT12,
 	IRQ_TINT0_TINT34,
 	IRQ_TINT1_TINT12,
 	IRQ_TINT1_TINT34,
 };
+static int *timer_irqs;
 
 /*
  * This driver configures the 2 64-bit DaVinci timers as 4 independent
@@ -58,12 +76,12 @@ int timer_irqs[NUM_TIMERS] = {
  * T1_BOT: Timer 1, bottom:  reserved for DSP
  * T1_TOP: Timer 1, top   :  Linux system tick
  */
-#define TID_SYSTEM  T1_TOP
-#define TID_FREERUN T0_BOT
-#define TID_HRT     T0_TOP
+static int tid_system = T1_TOP;
+static int tid_freerun = T0_BOT;
+static int tid_hrt = T0_TOP;
 
 /* timer regs */
-typedef struct davinci_timer_regs_s {
+typedef volatile struct davinci_timer_regs_s {
 	unsigned int pid12;		/* 0x0 */
 	unsigned int emumgt_clksped;	/* 0x4 */
 	unsigned int gpint_en;		/* 0x8 */
@@ -87,20 +105,30 @@ typedef struct davinci_timer_s {
 	davinci_timer_regs_t *regs;
 	struct irqaction irqaction;
 } davinci_timer_t;
-static davinci_timer_t davinci_timers[];
+
+static davinci_timer_t *davinci_timers[MAX_TIMERS];
 
 /* values for 'opts' field of davinci_timer_t */
 #define TIMER_DISABLED   0x00
 #define TIMER_ONE_SHOT   0x01
 #define TIMER_CONTINUOUS 0x02
 
+davinci_timer_regs_t *davinci_timer_base_index[] = {
+	(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_TIMER0_BASE),
+	(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_TIMER0_BASE),
+	(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_TIMER1_BASE),
+	(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_TIMER1_BASE),
+	(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_WDOG_BASE),
+};
+
 #define davinci_timer_base(id) \
-  (IS_TIMER1(id) ? \
-   (volatile davinci_timer_regs_t*)IO_ADDRESS(DAVINCI_TIMER1_BASE) :  \
-   (volatile davinci_timer_regs_t*)IO_ADDRESS(DAVINCI_TIMER0_BASE))
+  ((id >= 0) && (id < MAX_TIMERS) ?  \
+	davinci_timer_base_index[id] :  \
+	davinci_timer_base_index[0])
 
-static int davinci_timer32_config(davinci_timer_t *t) {
-	volatile davinci_timer_regs_t *regs = t->regs;
+static int davinci_timer32_config(davinci_timer_t *t)
+{
+	davinci_timer_regs_t *regs = t->regs;
 	u32 enamode_shift, reset_shift;
 	int ret = 0;
 
@@ -108,8 +136,7 @@ static int davinci_timer32_config(davinc
 		regs->prd12 = t->period;
 		enamode_shift = 6;
 		reset_shift = 0;
-	}
-	else {
+	} else {
 		regs->prd34 = t->period;
 		enamode_shift = 22;
 		reset_shift = 1;
@@ -126,11 +153,9 @@ static int davinci_timer32_config(davinc
 	/* Set enable mode */
 	if (t->opts & TIMER_ONE_SHOT) {
 		regs->tcr |= 0x1 << enamode_shift;
-	}
-	else if (t->opts & TIMER_CONTINUOUS) {
+	} else if (t->opts & TIMER_CONTINUOUS) {
 		regs->tcr |= 0x2 << enamode_shift;
-	}
-	else { /* TIMER_DISABLED */
+	} else {		/* TIMER_DISABLED */
 		regs->tcr &= ~(0x3 << enamode_shift);
 	}
 
@@ -140,13 +165,14 @@ static int davinci_timer32_config(davinc
 	return ret;
 }
 
-static inline u32 davinci_timer32_read(davinci_timer_t *t) {
-	volatile davinci_timer_regs_t *regs = t->regs;
+static inline u32 davinci_timer32_read(davinci_timer_t *t)
+{
+	davinci_timer_regs_t *regs = t->regs;
 
-	if IS_TIMER_TOP(t->id) {
+	if IS_TIMER_TOP
+		(t->id) {
 		return regs->tim34;
-	}
-	else {
+	} else {
 		return regs->tim12;
 	}
 }
@@ -155,13 +181,14 @@ static inline u32 davinci_timer32_read(d
  * Last processed system timer interrupt
  */
 static unsigned long davinci_timer32_last = 0;
-static irqreturn_t system_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t system_timer_interrupt(int irq, void *dev_id,
+					  struct pt_regs *regs)
 {
 	unsigned long now, latency;
 
 	write_seqlock(&xtime_lock);
-	now = davinci_timer32_read(&davinci_timers[TID_FREERUN]);
-	latency = davinci_timer32_read(&davinci_timers[TID_SYSTEM]);
+	now = davinci_timer32_read(davinci_timers[tid_freerun]);
+	latency = davinci_timer32_read(davinci_timers[tid_system]);
 	davinci_timer32_last = now - latency;
 
 	/* Do the Linux timer operations */
@@ -175,28 +202,30 @@ unsigned long davinci_gettimeoffset(void
 {
 	unsigned long now, elapsed, nsec;
 
-	now = davinci_timer32_read(&davinci_timers[TID_FREERUN]);
+	now = davinci_timer32_read(davinci_timers[tid_freerun]);
 	elapsed = now - davinci_timer32_last;
 
 	nsec = arch_cycle_to_nsec(elapsed);
 	return nsec / 1000;
 }
 
-static irqreturn_t freerun_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+static irqreturn_t freerun_interrupt(int irq, void *dev_id,
+				     struct pt_regs *regs)
+{
 	/* TODO: keep track of roll-overs for 64-bit cycle-count */
 	return IRQ_HANDLED;
 }
 
-cycles_t davinci_get_cycles(void) {
-	return davinci_timer32_read(&davinci_timers[TID_FREERUN]);
+cycles_t davinci_get_cycles(void)
+{
+	return davinci_timer32_read(davinci_timers[tid_freerun]);
 }
 
 #ifdef CONFIG_HIGH_RES_TIMERS
-int
-schedule_hr_timer_int(unsigned long ref_jiffies, int ref_cycles)
+int schedule_hr_timer_int(unsigned long ref_jiffies, int ref_cycles)
 {
 	unsigned long temp_cycles, jiffies_f = jiffies;
-	davinci_timer_t *t = &davinci_timers[TID_HRT];
+	davinci_timer_t *t = davinci_timers[tid_hrt];
 
 	BUG_ON(ref_cycles < 0);
 
@@ -206,18 +235,17 @@ schedule_hr_timer_int(unsigned long ref_
 	temp_cycles = (ref_jiffies - jiffies_f) * arch_cycles_per_jiffy +
 	    ref_cycles - get_arch_cycles(jiffies_f);
 
-	if ((long) (ref_jiffies - jiffies_f) <= 0 && (long) temp_cycles < 0)
+	if ((long)(ref_jiffies - jiffies_f) <= 0 && (long)temp_cycles < 0)
 		return -ETIME;
 
 	t->period = temp_cycles;
-	t->opts   = TIMER_ONE_SHOT;
+	t->opts = TIMER_ONE_SHOT;
 	davinci_timer32_config(t);
 
 	return 0;
 }
 
-int
-get_arch_cycles(unsigned long ref_jiffies)
+int get_arch_cycles(unsigned long ref_jiffies)
 {
 	extern unsigned long do_getmachinecycles(void);
 	int ret;
@@ -231,7 +259,7 @@ get_arch_cycles(unsigned long ref_jiffie
 		barrier();
 
 		/* calculate cycles since the current jiffy */
-		now = davinci_timer32_read(&davinci_timers[TID_FREERUN]);
+		now = davinci_timer32_read(davinci_timers[tid_freerun]);
 		ret = now - davinci_timer32_last;
 
 		/* compensate for ref_jiffies in the past */
@@ -253,8 +281,7 @@ hr_timer_interrupt(int irq, void *dev_id
 	return IRQ_HANDLED;
 }
 
-static int
-hr_timer_init(void)
+static int hr_timer_init(void)
 {
 	int ret = 0;
 
@@ -264,45 +291,91 @@ hr_timer_init(void)
 }
 
 __initcall(hr_timer_init);
-#endif /* CONFIG_HIGH_RES_TIMERS */
+#endif				/* CONFIG_HIGH_RES_TIMERS */
+
+static davinci_timer_t davinci_system_timer = {
+	.name = "system tick",
+	.period = ((DM644X_CLOCK_TICK_RATE / HZ) - 1),
+	.opts = TIMER_CONTINUOUS,
+	.irqaction = {
+		      .flags = SA_INTERRUPT | SA_NODELAY,
+		      .handler = system_timer_interrupt,
+		      }
+};
+static davinci_timer_t davinci_freerun_timer = {
+	.name = "free-run counter",
+	.period = 0xffffffff,
+	.opts = TIMER_CONTINUOUS,
+	.irqaction = {
+		      .flags = SA_INTERRUPT,
+		      .handler = freerun_interrupt,
+		      }
+};
 
-static davinci_timer_t davinci_timers[NUM_TIMERS] = {
-	[TID_SYSTEM] = {
-		.name      = "system tick",
-		.period    = ((CLOCK_TICK_RATE / HZ) - 1),
-		.opts      = TIMER_CONTINUOUS,
-		.irqaction = {
-			.flags   = SA_INTERRUPT | SA_NODELAY,
-			.handler = system_timer_interrupt,
-		}
-	},
-	[TID_FREERUN] = {
-		.name       = "free-run counter",
-		.period     = 0xffffffff,
-		.opts       = TIMER_CONTINUOUS,
-		.irqaction = {
-			.flags   = SA_INTERRUPT,
-			.handler = freerun_interrupt,
-		}
-	},
 #ifdef CONFIG_HIGH_RES_TIMERS
-	[TID_HRT] = {
-		.name       = "high-res timer",
-		.opts       = TIMER_DISABLED,
-		.period     = 0,
-		.irqaction = {
-			.flags = SA_INTERRUPT | SA_NODELAY,
-			.handler = hr_timer_interrupt,
-		}
-	},
+static davinci_timer_t davinci_hrt_timer = {
+	.name = "high-res timer",
+	.opts = TIMER_DISABLED,
+	.period = 0,
+	.irqaction = {
+		      .flags = SA_INTERRUPT | SA_NODELAY,
+		      .handler = hr_timer_interrupt,
+		      }
+};
 #endif
+static davinci_timer_t davinci_default_timer = {
+	.name = NULL,
 };
 
 void __init davinci_timer_init(void)
 {
-	volatile davinci_timer_regs_t *t0 = davinci_timer_base(T0_BOT);
-	volatile davinci_timer_regs_t *t1 = davinci_timer_base(T1_BOT);
 	int i;
+	davinci_timer_regs_t *t0 = davinci_timer_base(T0_BOT);
+	davinci_timer_regs_t *t1 = davinci_timer_base(T1_BOT);
+	davinci_timer_regs_t *t2 = davinci_timer_base(T2_WDT);
+
+	if (cpu_is_davinci_dm6467()) {
+		davinci_system_timer.period = (DM646X_CLOCK_TICK_RATE / HZ) - 1;
+		timer_irqs = dm646x_timer_irqs;
+		NUM_TIMERS = ARRAY_SIZE(dm646x_timer_irqs);
+		/*
+		 * T0_BOT: Timer 0, bottom:  AV Sync
+		 * T0_TOP: Timer 0, top:  free-running counter,
+		 used for cycle counter
+		 * T1_BOT: Timer 1, bottom:  reserved for DSP
+		 * T1_TOP: Timer 1, top   :  Linux system tick
+		 * T2_WDT: Timer 2,       :  high-res timer programmable timer
+		 */
+		tid_system = T1_TOP;
+		tid_freerun = T0_TOP;
+		tid_hrt = T2_WDT;
+	} else {
+		if (cpu_is_davinci_dm355())
+			davinci_system_timer.period =
+			    (DM355_CLOCK_TICK_RATE / HZ) - 1;
+
+		timer_irqs = davinci_timer_irqs;
+		NUM_TIMERS = ARRAY_SIZE(davinci_timer_irqs);
+		/*
+		 * T0_BOT: Timer 0, bottom:  free-running counter,
+		 used for cycle counter
+		 * T0_TOP: Timer 0, top   :  high-res timer programmable timer
+		 * T1_BOT: Timer 1, bottom:  reserved for DSP
+		 * T1_TOP: Timer 1, top   :  Linux system tick
+		 */
+		tid_system = T1_TOP;
+		tid_freerun = T0_BOT;
+		tid_hrt = T0_TOP;
+	}
+	for (i = 0; i < NUM_TIMERS; i++)
+		davinci_timers[i] = &davinci_default_timer;
+
+	davinci_timers[tid_system] = &davinci_system_timer;
+	davinci_timers[tid_freerun] = &davinci_freerun_timer;
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+	davinci_timers[tid_hrt] = &davinci_hrt_timer;
+#endif
 
 	/* Disabled, Internal clock source */
 	t0->tcr = 0x0;
@@ -326,54 +399,67 @@ void __init davinci_timer_init(void)
 	t1->tim12 = 0;
 	t1->tim34 = 0;
 
-	for(i=0; i<sizeof(davinci_timers)/sizeof(davinci_timer_t); i++) {
-		davinci_timer_t *t = &davinci_timers[i];
+	/* do the same thing for timer 2 if cpu is dm6467 */
+	if (cpu_is_davinci_dm6467()) {
+		t2->tcr = 0x0;
+		t2->tgcr = 0;
+
+		/*  T2 can only operate as a single 64-bit timer
+		 * t2->tgcr |= 0x4; */
+		t2->tgcr |= 0x3;
+		t2->tim12 = 0;
+		t2->tim34 = 0;
+	}
+
+	for (i = 0; i < NUM_TIMERS; i++) {
+		davinci_timer_t *t = davinci_timers[i];
 
 		if (t->name) {
 			t->id = i;
 			t->regs =
-			    (davinci_timer_regs_t *)davinci_timer_base(t->id);
+			    (davinci_timer_regs_t *) davinci_timer_base(t->id);
 			t->irqaction.name = t->name;
 			t->irqaction.dev_id = (void *)t;
 
-			davinci_timer32_config(&davinci_timers[i]);
+			davinci_timer32_config(t);
 		}
 	}
 }
 
 struct sys_timer davinci_timer = {
-	.init   = davinci_timer_init,
+	.init = davinci_timer_init,
 	.offset = davinci_gettimeoffset,
 };
 
-
-void davinci_watchdog_reset(void) {
-	volatile davinci_timer_regs_t *davinci_wdt = 
-		(volatile davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_WDOG_BASE);
+void davinci_watchdog_reset(void)
+{
+	davinci_timer_regs_t *davinci_wdt =
+		(davinci_timer_regs_t *)IO_ADDRESS(DAVINCI_WDOG_BASE);
 
 	davinci_wdt->tcr = 0x0;		/* disable timer */
 	davinci_wdt->tgcr = 0x0;	/* reset timer */
-        davinci_wdt->tgcr = 0x8;	/* configure timer2 as 64-bit */
-        davinci_wdt->tgcr |= 0x3;	/* release timer from reset */
+	davinci_wdt->tgcr = 0x8;	/* configure timer2 as 64-bit */
+	davinci_wdt->tgcr |= 0x3;	/* release timer from reset */
 	davinci_wdt->tim12 = 0;		/* clear counter and period regs */
 	davinci_wdt->tim34 = 0;
-	davinci_wdt->prd12 =  0;
-	davinci_wdt->prd34 =  0;
+	davinci_wdt->prd12 = 0;
+	davinci_wdt->prd34 = 0;
 	davinci_wdt->wdtcr |= 0x4000;	/* enable watchdog timer */
 
 	/* put watchdog in pre-active state */
 	davinci_wdt->wdtcr = 0xA5C64000;
 
 	/* put watchdog in active state */
-	davinci_wdt->wdtcr = 0xDA7E4000;	
+	davinci_wdt->wdtcr = 0xDA7E4000;
 
 	/* write an invalid value to the WDKEY field to trigger 
 	 * a watchdog reset */
 	davinci_wdt->wdtcr = 0x00004000;
 }
 
-u32 davinci_timer_read(int clock_id) {
-	davinci_timer_t *t = &davinci_timers[clock_id];
+u32 davinci_timer_read(int clock_id)
+{
+	davinci_timer_t *t = davinci_timers[clock_id];
 
 	return davinci_timer32_read(t);
 }
Index: linux-2.6.10/arch/arm/mach-davinci/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/Kconfig
+++ linux-2.6.10/arch/arm/mach-davinci/Kconfig
@@ -4,20 +4,26 @@ menu "TI DaVinci Implementations"
 
 comment "DaVinci Core Type"
 
-config ARCH_DAVINCI644x
-	default y
+choice
+	prompt "DaVinci ARCH type"
+	default ARCH_DAVINCI_DM644x
+
+config ARCH_DAVINCI_DM644x
 	bool "DaVinci 644x based system"
 
 config ARCH_DAVINCI_DM355
-	default n
 	bool "DaVinci DM355 based system"
 
+config ARCH_DAVINCI_DM646x
+	bool "DaVinci 646x based system"
+endchoice
+
 comment "DaVinci Board Type"
 
 config MACH_DAVINCI_EVM
 	bool "TI DaVinci EVM"
 	default y
-	depends on ARCH_DAVINCI644x
+	depends on ARCH_DAVINCI_DM644x
 	help
 	  Configure this option to specify the whether the board used
 	  for development is a DaVinci EVM
@@ -30,10 +36,18 @@ config MACH_DAVINCI_DM355_EVM
 	  Configure this option to specify the whether the board used
 	  for development is a DM355 EVM
 
+config MACH_DAVINCI_HD_EVM
+	bool "TI DaVinci HD EVM"
+	default n
+	depends on ARCH_DAVINCI_DM646x && !ARCH_DAVINCI_DM644x
+	help
+	  Configure this option to specify the whether the board used
+	  for development is a DaVinci HD EVM
+
 config DAVINCI_I2C_EXPANDER
 	bool "TI DaVinci I2C Expander"
 	default y
-	depends on ARCH_DAVINCI644x
+	depends on ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM646x || ARCH_DAVINCI_DM355
 	select I2C_DAVINCI
 	help
 	  Configure this option to specify whether the board used
@@ -41,12 +55,18 @@ config DAVINCI_I2C_EXPANDER
 
 config DAVINCI_MCBSP
 	bool
-        prompt "DaVinci McBSP Driver" if SOUND_DAVINCI=n
+	prompt "DaVinci McBSP Driver" if SOUND_DAVINCI=n && ARCH_DAVINCI_DM646x=n
 	depends on ARCH_DAVINCI
 	default SOUND_DAVINCI
 	---help---
 	DaVinci McBSP driver.  Auto-enabled by DaVinci sound driver.
 
+config DAVINCI_MCASP
+	bool "DaVinci HD McASP Driver"
+	depends on ARCH_DAVINCI_DM646x
+	---help---
+	DaVinci HD McASP driver.  Auto-enabled by DaVinci HD sound driver.
+
 comment "DaVinci Options"
 
 config DAVINCI_BLK_DEV_CF
@@ -69,6 +89,13 @@ config DM355_NAND_256KB_BLOCKS
 	has 256KB blocks.  Answer N here if the NAND chip (e.g. a 4 Gigabit
 	Micron MT29F4G08AAA) installed on your board has 128KB blocks.
 
+config DAVINCI_SPI
+	bool "TI DAVINCI SPI device"
+	default y
+	help
+	Configure this option to specify whether the board used
+	has SPI device.
+
 choice
 	prompt "Low-level debug console UART"
 	default DAVINCI_LL_DEBUG_UART0
Index: linux-2.6.10/arch/arm/mach-davinci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/Makefile
+++ linux-2.6.10/arch/arm/mach-davinci/Makefile
@@ -9,10 +9,14 @@
 
 
 # Board specific
- obj-$(CONFIG_MACH_DAVINCI_EVM)                += board-evm.o i2c-emac.o
- obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)  += board-dm355-evm.o
- obj-$(CONFIG_DAVINCI_MCBSP)          += mcbsp.o
- obj-$(CONFIG_DAVINCI_I2C_EXPANDER)    += i2c-client.o
+obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o i2c-emac.o
+obj-$(CONFIG_MACH_DAVINCI_HD_EVM)  += board-dm6467-evm.o i2c-emac.o \
+					video_hdevm.o
+obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= board-dm355-evm.o
+obj-$(CONFIG_DAVINCI_MCBSP)	+= mcbsp.o
+obj-$(CONFIG_DAVINCI_MCASP)	+= mcasp.o
+obj-$(CONFIG_I2C_DAVINCI)       += i2c-client.o
+obj-$(CONFIG_DAVINCI_SPI)       += davinci_spi_platform.o
 
 
 ifeq ($(CONFIG_LEDS),y)
Index: linux-2.6.10/include/asm-arm/arch-davinci/cpu.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/cpu.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/cpu.h
@@ -15,6 +15,11 @@
 #define _ASM_ARCH_CPU_H
 
 extern unsigned int system_rev;
+extern unsigned int davinci_cpu_index;	/* defined and init in io.c */
+
+#define DM644X_CPU_IDX	0
+#define DM6467_CPU_IDX	1
+#define DM355_CPU_IDX	2
 
 #define GET_DAVINCI_CPU_TYPE	((system_rev >> 16) & 0xffff)
 
Index: linux-2.6.10/include/asm-arm/arch-davinci/debug-macro.S
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/debug-macro.S
+++ linux-2.6.10/include/asm-arm/arch-davinci/debug-macro.S
@@ -23,11 +23,11 @@
 		.endm
 
 		.macro	senduart,rd,rx
-		strb	\rd, [\rx]
+		str	\rd, [\rx]
 		.endm
 
 		.macro	busyuart,rd,rx
-1001:		ldrb	\rd, [\rx, #(0x5 << 2)]
+1001:		ldr	\rd, [\rx, #(0x5 << 2)]
 		and	\rd, \rd, #0x60
 		teq	\rd, #0x60
 		bne	1001b
Index: linux-2.6.10/include/asm-arm/arch-davinci/frd.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/frd.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/frd.h
@@ -23,7 +23,7 @@
 extern u32 davinci_timer_read(int);
 
 #define FRD_MPU_TIMER   3
-#define FRD_TIMER_INIT	(CLOCK_TICK_RATE / HZ) - 1
+#define FRD_TIMER_INIT	(DAVINCI_CLOCK_TICK_RATE / HZ) - 1
 #define FRD_TIMER_LATCH	davinci_timer_read(FRD_MPU_TIMER)
 
 #define FRD_SCALE_ABS_TICKS 	1
Index: linux-2.6.10/include/asm-arm/arch-davinci/hardware.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/hardware.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/hardware.h
@@ -37,97 +37,228 @@
 #include <asm/arch/io.h>
 
 /*
- * Base register addresses
+ * DaVinci (DM644X) Base register addresses
  */
-#define DAVINCI_DMA_3PCC_BASE              (0x01C00000)
-#define DAVINCI_DMA_3PTC0_BASE             (0x01C10000)
-#define DAVINCI_DMA_3PTC1_BASE             (0x01C10400)
-#define DAVINCI_UART0_BASE                 (0x01C20000)
-#define DAVINCI_UART1_BASE                 (0x01C20400)
-#define DAVINCI_UART2_BASE                 (0x01C20800)
-#define DAVINCI_I2C_BASE                   (0x01C21000)
-#define DAVINCI_TIMER0_BASE                (0x01C21400)
-#define DAVINCI_TIMER1_BASE                (0x01C21800)
-#define DAVINCI_WDOG_BASE                  (0x01C21C00)
-#define DAVINCI_PWM0_BASE                  (0x01C22000)
-#define DAVINCI_PWM1_BASE                  (0x01C22400)
-#define DAVINCI_PWM2_BASE                  (0x01C22800)
-#define DAVINCI_SYSTEM_MODULE_BASE         (0x01C40000)
-#define DAVINCI_PLL_CNTRL0_BASE            (0x01C40800)
-#define DAVINCI_PLL_CNTRL1_BASE            (0x01C40C00)
-#define DAVINCI_PWR_SLEEP_CNTRL_BASE       (0x01C41000)
-#define DAVINCI_SYSTEM_DFT_BASE            (0x01C42000)
-#define DAVINCI_ARM_INTC_BASE              (0x01C48000)
-#define DAVINCI_IEEE1394_BASE              (0x01C60000)
-#define DAVINCI_USB_OTG_BASE               (0x01C64000)
-#define DAVINCI_CFC_ATA_BASE               (0x01C66000)
-#define DAVINCI_SPI_BASE                   (0x01C66800)
-#define DAVINCI_GPIO_BASE                  (0x01C67000)
-#define DAVINCI_UHPI_BASE                  (0x01C67800)
-#define DAVINCI_VPSS_REGS_BASE             (0x01C70000)
-#define DAVINCI_EMAC_CNTRL_REGS_BASE       (0x01C80000)
-#define DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE   (0x01C81000)
-#define DAVINCI_EMAC_WRAPPER_RAM_BASE      (0x01C82000)
-#define DAVINCI_MDIO_CNTRL_REGS_BASE       (0x01C84000)
-#define DAVINCI_IMCOP_BASE                 (0x01CC0000)
-#define DAVINCI_ASYNC_EMIF_CNTRL_BASE      (0x01E00000)
-#define DAVINCI_VLYNQ_BASE                 (0x01E01000)
-#define DAVINCI_MCBSP_BASE                 (0x01E02000)
-#define DAVINCI_MMC_SD_BASE                (0x01E10000)
-#define DAVINCI_MS_BASE                    (0x01E20000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE   (0x02000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE   (0x04000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE   (0x06000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE   (0x08000000)
-#define DAVINCI_VLYNQ_REMOTE_BASE          (0x0C000000)
+#define DAVINCI_DMA_3PCC_BASE			(0x01C00000)
+#define DAVINCI_DMA_3PTC0_BASE			(0x01C10000)
+#define DAVINCI_DMA_3PTC1_BASE			(0x01C10400)
+#define DAVINCI_UART0_BASE			(0x01C20000)
+#define DAVINCI_UART1_BASE			(0x01C20400)
+#define DAVINCI_I2C_BASE			(0x01C21000)
+#define DAVINCI_TIMER0_BASE			(0x01C21400)
+#define DAVINCI_TIMER1_BASE			(0x01C21800)
+#define DAVINCI_WDOG_BASE			(0x01C21C00)
+#define DAVINCI_PWM0_BASE			(0x01C22000)
+#define DAVINCI_PWM1_BASE			(0x01C22400)
+#define DAVINCI_PWM2_BASE			(0x01C22800)
+#define DAVINCI_SYSTEM_MODULE_BASE		(0x01C40000)
+#define DAVINCI_PLL_CNTRL0_BASE			(0x01C40800)
+#define DAVINCI_PLL_CNTRL1_BASE			(0x01C40C00)
+#define DAVINCI_PWR_SLEEP_CNTRL_BASE		(0x01C41000)
+#define DAVINCI_SYSTEM_DFT_BASE			(0x01C42000)
+#define DAVINCI_ARM_INTC_BASE			(0x01C48000)
+#define DAVINCI_IEEE1394_BASE			(0x01C60000)
+#define DAVINCI_USB_OTG_BASE			(0x01C64000)
+#define DAVINCI_CFC_ATA_BASE			(0x01C66000)
+#define DAVINCI_SPI_BASE			(0x01C66800)
+#define DAVINCI_GPIO_BASE			(0x01C67000)
+#define DAVINCI_UHPI_BASE			(0x01C67800)
+#define DAVINCI_VPSS_REGS_BASE			(0x01C70000)
+#define DAVINCI_EMAC_CNTRL_REGS_BASE		(0x01C80000)
+#define DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE	(0x01C81000)
+#define DAVINCI_EMAC_WRAPPER_RAM_BASE		(0x01C82000)
+#define DAVINCI_MDIO_CNTRL_REGS_BASE		(0x01C84000)
+#define DAVINCI_IMCOP_BASE			(0x01CC0000)
+#define DAVINCI_VLYNQ_BASE			(0x01E01000)
+#define DAVINCI_MCBSP_BASE			(0x01E02000)
+#define DAVINCI_MCBSP_RX_DMA_PORT		DAVINCI_MCBSP_BASE
+#define DAVINCI_MCBSP_TX_DMA_PORT		(DAVINCI_MCBSP_BASE + 4)
+#define DAVINCI_MCBSP0_BASE			DAVINCI_MCBSP_BASE
+#define DAVINCI_MCBSP1_BASE			(0x01E04000)
+#define DAVINCI_MMC_SD_BASE			(0x01E10000)
+#define DAVINCI_MS_BASE				(0x01E20000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE	(0x02000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE	(0x04000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE	(0x06000000)
+#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE	(0x08000000)
+#define DAVINCI_VLYNQ_REMOTE_BASE		(0x0C000000)
+
+#define DM644X_ASYNC_EMIF_CNTRL_BASE		(0x01E00000)
+#define DM644X_UART2_BASE			(0x01C20800)
+
+#define DM355_MMC1_BASE				(0x01E00000)
+#define DM355_UART2_BASE			(0x01E06000)
+#define DM355_ASYNC_EMIF_CNTRL_BASE		(0x01E10000)
+#define DM355_MMC0_BASE				(0x01E11000)
+
 
 /* Power and Sleep Controller (PSC) Domains */
 #define DAVINCI_GPSC_ARMDOMAIN      0
 #define DAVINCI_GPSC_DSPDOMAIN      1
 
-#define DAVINCI_LPSC_VPSSMSTR       0       // VPSS Master LPSC
-#define DAVINCI_LPSC_VPSSSLV        1       // VPSS Slave LPSC
-#define DAVINCI_LPSC_TPCC           2       // TPCC LPSC
-#define DAVINCI_LPSC_TPTC0          3       // TPTC0 LPSC
-#define DAVINCI_LPSC_TPTC1          4       // TPTC1 LPSC
-#define DAVINCI_LPSC_EMAC           5       // EMAC LPSC
-#define DAVINCI_LPSC_EMAC_WRAPPER   6       // EMAC WRAPPER LPSC
-#define DAVINCI_LPSC_MDIO           7       // MDIO LPSC
-#define DAVINCI_LPSC_IEEE1394       8       // IEEE1394 LPSC
-#define DAVINCI_LPSC_USB            9       // USB LPSC
-#define DAVINCI_LPSC_ATA            10      // ATA LPSC
-#define DAVINCI_LPSC_VLYNQ          11      // VLYNQ LPSC
-#define DAVINCI_LPSC_UHPI           12      // UHPI LPSC
-#define DAVINCI_LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
-#define DAVINCI_LPSC_AEMIF          14      // AEMIF LPSC
-#define DAVINCI_LPSC_MMC_SD         15      // MMC_SD LPSC
-#define DAVINCI_LPSC_MEMSTICK       16      // MEMSTICK LPSC
-#define DAVINCI_LPSC_McBSP          17      // McBSP LPSC
-#define DAVINCI_LPSC_I2C            18      // I2C LPSC
-#define DAVINCI_LPSC_UART0          19      // UART0 LPSC
-#define DAVINCI_LPSC_UART1          20      // UART1 LPSC
-#define DAVINCI_LPSC_UART2          21      // UART2 LPSC
-#define DAVINCI_LPSC_SPI            22      // SPI LPSC
-#define DAVINCI_LPSC_PWM0           23      // PWM0 LPSC
-#define DAVINCI_LPSC_PWM1           24      // PWM1 LPSC
-#define DAVINCI_LPSC_PWM2           25      // PWM2 LPSC
-#define DAVINCI_LPSC_GPIO           26      // GPIO LPSC
-#define DAVINCI_LPSC_TIMER0         27      // TIMER0 LPSC
-#define DAVINCI_LPSC_TIMER1         28      // TIMER1 LPSC
-#define DAVINCI_LPSC_TIMER2         29      // TIMER2 LPSC
-#define DAVINCI_LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
-#define DAVINCI_LPSC_ARM            31      // ARM LPSC
-#define DAVINCI_LPSC_SCR2           32      // SCR2 LPSC
-#define DAVINCI_LPSC_SCR3           33      // SCR3 LPSC
-#define DAVINCI_LPSC_SCR4           34      // SCR4 LPSC
-#define DAVINCI_LPSC_CROSSBAR       35      // CROSSBAR LPSC
-#define DAVINCI_LPSC_CFG27          36      // CFG27 LPSC
-#define DAVINCI_LPSC_CFG3           37      // CFG3 LPSC
-#define DAVINCI_LPSC_CFG5           38      // CFG5 LPSC
-#define DAVINCI_LPSC_GEM            39      // GEM LPSC
-#define DAVINCI_LPSC_IMCOP          40      // IMCOP LPSC
+/*
+ * LPSC Assignments
+ */
+#define DAVINCI_LPSC_VPSSMSTR       0       /* VPSS Master LPSC */
+#define DAVINCI_LPSC_VPSSSLV        1       /* VPSS Slave LPSC */
+#define DAVINCI_LPSC_TPCC           2       /* TPCC LPSC */
+#define DAVINCI_LPSC_TPTC0          3       /* TPTC0 LPSC */
+#define DAVINCI_LPSC_TPTC1          4       /* TPTC1 LPSC */
+#define DAVINCI_LPSC_EMAC           5       /* EMAC LPSC */
+#define DAVINCI_LPSC_EMAC_WRAPPER   6       /* EMAC WRAPPER LPSC */
+#define DAVINCI_LPSC_MDIO           7       /* MDIO LPSC */
+#define DAVINCI_LPSC_MMC_SD1        7
+#define DAVINCI_LPSC_IEEE1394       8       /* IEEE1394 LPSC */
+#define DAVINCI_LPSC_McBSP1         8       /* McBSP1 LPSC */
+#define DAVINCI_LPSC_USB            9       /* USB LPSC */
+#define DAVINCI_LPSC_ATA            10      /* ATA LPSC */
+#define DAVINCI_LPSC_PWM3           10      /* PWM3 LPSC */
+#define DAVINCI_LPSC_VLYNQ          11      /* VLYNQ LPSC */
+#define DAVINCI_LPSC_UHPI           12      /* UHPI LPSC */
+#define DAVINCI_LPSC_DDR_EMIF       13      /* DDR_EMIF LPSC */
+#define DAVINCI_LPSC_AEMIF          14      /* AEMIF LPSC */
+#define DAVINCI_LPSC_MMC_SD0        15      /* MMC_SD0 LPSC */
+#define DAVINCI_LPSC_MEMSTICK       16      /* MEMSTICK LPSC */
+#define DAVINCI_LPSC_McBSP0         17      /* McBSP0 LPSC */
+#define DAVINCI_LPSC_I2C            18      /* I2C LPSC */
+#define DAVINCI_LPSC_UART0          19      /* UART0 LPSC */
+#define DAVINCI_LPSC_UART1          20      /* UART1 LPSC */
+#define DAVINCI_LPSC_UART2          21      /* UART2 LPSC */
+#define DAVINCI_LPSC_SPI            22      /* SPI LPSC */
+#define DAVINCI_LPSC_PWM0           23      /* PWM0 LPSC */
+#define DAVINCI_LPSC_PWM1           24      /* PWM1 LPSC */
+#define DAVINCI_LPSC_PWM2           25      /* PWM2 LPSC */
+#define DAVINCI_LPSC_GPIO           26      /* GPIO LPSC */
+#define DAVINCI_LPSC_TIMER0         27      /* TIMER0 LPSC */
+#define DAVINCI_LPSC_TIMER1         28      /* TIMER1 LPSC */
+#define DAVINCI_LPSC_TIMER2         29      /* TIMER2 LPSC */
+#define DAVINCI_LPSC_SYSTEM_SUBSYS  30      /* SYSTEM SUBSYSTEM LPSC */
+#define DAVINCI_LPSC_ARM            31      /* ARM LPSC */
+#define DAVINCI_LPSC_SCR2           32      /* SCR2 LPSC */
+#define DAVINCI_LPSC_SCR3           33      /* SCR3 LPSC */
+#define DAVINCI_LPSC_SCR4           34      /* SCR4 LPSC */
+#define DAVINCI_LPSC_CROSSBAR       35      /* CROSSBAR LPSC */
+#define DAVINCI_LPSC_CFG27          36      /* CFG27 LPSC */
+#define DAVINCI_LPSC_CFG3           37      /* CFG3 LPSC */
+#define DAVINCI_LPSC_CFG5           38      /* CFG5 LPSC */
+#define DAVINCI_LPSC_GEM            39      /* GEM LPSC */
+#define DAVINCI_LPSC_IMCOP          40      /* IMCOP LPSC */
+
+/*
+ * DM6467 base register addresses different from origina DaVinci
+ */
+#define DAVINCI_DM646X_DMA_3PTC2_BASE             (0x01C10800)
+#define DAVINCI_DM646X_DMA_3PTC3_BASE             (0x01C10C00)
+#define DAVINCI_DM646X_VIDEO_PORT_BASE            (0x01C12000)
+#define DAVINCI_DM646X_VDCE_BASE                  (0x01C12800)
+#define DAVINCI_DM646X_TSIF0_BASE                 (0x01C13000)
+#define DAVINCI_DM646X_TSIF1_BASE                 (0x01C13400)
+#define DAVINCI_DM646X_PCI_CTL_BASE               (0x01C1A000)
+#define DAVINCI_DM646X_CRGEN0_BASE                (0x01C26000)
+#define DAVINCI_DM646X_CRGEN1_BASE                (0x01C26400)
+#define DAVINCI_DM646X_SEC_CONTROLLER_BASE        (0x01C40400)
+#define DAVINCI_DM646X_MCASP0_REG_BASE            (0x01D01000)
+#define DAVINCI_DM646X_MCASP0_DATA_PORT_BASE      (0x01D01400)
+#define DAVINCI_DM646X_MCASP1_REG_BASE            (0x01D01800)
+#define DAVINCI_DM646X_MCASP1_DATA_PORT_BASE      (0x01D01C00)
+#define DAVINCI_DM646X_HDVICP0_BASE               (0x02000000)
+#define DAVINCI_DM646X_HDVICP1_BASE               (0x02200000)
+#define DAVINCI_DM646X_ASYNC_EMIF_CNTRL_BASE      (0x20008000)
+#define DAVINCI_DM646X_VLYNQ_BASE                 (0x20010000)
+#define DAVINCI_DM646X_ASYNC_EMIF_DATA_CE0_BASE   (0x42000000)
+#define DAVINCI_DM646X_ASYNC_EMIF_DATA_CE1_BASE   (0x44000000)
+#define DAVINCI_DM646X_ASYNC_EMIF_DATA_CE2_BASE   (0x46000000)
+#define DAVINCI_DM646X_ASYNC_EMIF_DATA_CE3_BASE   (0x48000000)
+#define DAVINCI_DM646X_VLYNQ_REMOTE_BASE          (0x4C000000)
+
+/*
+ * LPSC Assignments
+ */
+#define DAVINCI_DM646X_LPSC_RESERVED       0       /* Reserved */
+#define DAVINCI_DM646X_LPSC_C64X_CPU       1       /* C64x + CPU */
+#define DAVINCI_DM646X_LPSC_HDVICP0        2       /* HDVICP0 */
+#define DAVINCI_DM646X_LPSC_HDVICP1        3       /* HDVICP1 */
+#define DAVINCI_DM646X_LPSC_TPCC           4       /* TPCC LPSC */
+#define DAVINCI_DM646X_LPSC_TPTC0          5       /* TPTC0 LPSC */
+#define DAVINCI_DM646X_LPSC_TPTC1          6       /* TPTC1 LPSC */
+#define DAVINCI_DM646X_LPSC_TPTC2          7       /* TPTC2 LPSC */
+#define DAVINCI_DM646X_LPSC_TPTC3          8       /* TPTC3 LPSC */
+#define DAVINCI_DM646X_LPSC_PCI            13      /* PCI LPSC */
+#define DAVINCI_DM646X_LPSC_EMAC           14      /* EMAC LPSC */
+#define DAVINCI_DM646X_LPSC_VDCE           15      /* VDCE LPSC */
+#define DAVINCI_DM646X_LPSC_VPSSMSTR       16      /* VPSS Master LPSC */
+#define DAVINCI_DM646X_LPSC_VPSSSLV        17      /* VPSS Slave LPSC */
+#define DAVINCI_DM646X_LPSC_TSIF0          18      /* TSIF0 LPSC */
+#define DAVINCI_DM646X_LPSC_TSIF1          19      /* TSIF1 LPSC */
+#define DAVINCI_DM646X_LPSC_DDR_EMIF       20      /* DDR_EMIF LPSC */
+#define DAVINCI_DM646X_LPSC_AEMIF          21      /* AEMIF LPSC */
+#define DAVINCI_DM646X_LPSC_McASP0         22      /* McASP0 LPSC */
+#define DAVINCI_DM646X_LPSC_McASP1         23      /* McASP1 LPSC */
+#define DAVINCI_DM646X_LPSC_CRGEN0         24      /* CRGEN0 LPSC */
+#define DAVINCI_DM646X_LPSC_CRGEN1         25      /* CRGEN1 LPSC */
+#define DAVINCI_DM646X_LPSC_UART0          26      /* UART0 LPSC */
+#define DAVINCI_DM646X_LPSC_UART1          27      /* UART1 LPSC */
+#define DAVINCI_DM646X_LPSC_UART2          28      /* UART2 LPSC */
+#define DAVINCI_DM646X_LPSC_PWM0           29      /* PWM0 LPSC */
+#define DAVINCI_DM646X_LPSC_PWM1           30      /* PWM1 LPSC */
+#define DAVINCI_DM646X_LPSC_I2C            31      /* I2C LPSC */
+#define DAVINCI_DM646X_LPSC_SPI            32      /* SPI LPSC */
+#define DAVINCI_DM646X_LPSC_GPIO           33      /* GPIO LPSC */
+#define DAVINCI_DM646X_LPSC_TIMER0         34      /* TIMER0 LPSC */
+#define DAVINCI_DM646X_LPSC_TIMER1         35      /* TIMER1 LPSC */
+#define DAVINCI_DM646X_LPSC_ARM_INTC       45      /* ARM INTC LPSC */
+
+/*
+ * DM355 base register addresses different from origina DaVinci
+ */
+#define DAVINCI_DM355_TIMER2_BASE                (0x01C20800)
+#define DAVINCI_DM355_REALTIME_BASE              (0x01C20C00)
+#define DAVINCI_DM355_PWM3_BASE                  (0x01C22C00)
+#define DAVINCI_DM355_SPI_BASE                   (0x01C66000)
+#define DAVINCI_DM355_SPI0_BASE                  DAVINCI_DM355_SPI_BASE
+#define DAVINCI_DM355_SPI1_BASE                  (0x01C66800)
+#define DAVINCI_DM355_SPI2_BASE                  (0x01C67800)
+#define DAVINCI_DM355_VPSS_CLK_BASE              DAVINCI_VPSS_REGS_BASE
+#define DAVINCI_DM355_VPSS_HW3A_BASE             (0x01C70080)
+#define DAVINCI_DM355_VPSS_IPIPE0_BASE           (0x01C70100)
+#define DAVINCI_DM355_VPSS_OSD_BASE              (0x01C70200)
+#define DAVINCI_DM355_VPSS_HSSIF_BASE            (0x01C70300)
+#define DAVINCI_DM355_VPSS_VENC_BASE             (0x01C70400)
+#define DAVINCI_DM355_VPSS_CCDC_BASE             (0x01C70600)
+#define DAVINCI_DM355_VPSS_BL_BASE               (0x01C70800)
+#define DAVINCI_DM355_VPSS_CFA_LD_BASE           (0x01C70900)
+#define DAVINCI_DM355_VPSS_IPIPE1_BASE           (0x01C71000)
+#define DAVINCI_DM355_IMX_BASE                   (0x01CD0000)
+#define DAVINCI_DM355_IMX_CTL_BASE               (0x01CD0380)
+#define DAVINCI_DM355_IMCOP_CTL_BASE             (0x01CDF400)
+#define DAVINCI_DM355_IMCOP_SEQ_BASE             (0x01CDFF00)
+#define DAVINCI_DM355_MMC_SD1_BASE               (0x01E00000)
+#define DAVINCI_DM355_MCBSP0_BASE                DAVINCI_MCBSP_BASE
+#define DAVINCI_DM355_MCBSP1_BASE                (0x01E04000)
+#define DAVINCI_DM355_MCBSP1_RX_DMA_PORT         DAVINCI_DM355_MCBSP1_BASE
+#define DAVINCI_DM355_MCBSP1_TX_DMA_PORT         (DAVINCI_DM355_MCBSP1_BASE + 4)
+#define DAVINCI_DM355_UART2_BASE                 (0x01E06000)
+#define DAVINCI_DM355_ASYNC_EMIF_CNTRL_BASE      (0x01E10000)
+
+#define DAVINCI_DM355_MMC_SD_BASE                (0x01E11000)
+#define DAVINCI_DM355_MMC_SD0_BASE               DAVINCI_DM355_MMC_SD_BASE
+#define DAVINCI_MMC_SD0_BASE                     DAVINCI_DM355_MMC_SD_BASE
+
+/*
+ * Macro to access device power control
+ */
+#define DAVINCI_VDD3P3V_PWDN		__REG(DAVINCI_SYSTEM_MODULE_BASE + 0x48)
+
+/*
+ * We can have multiple VLYNQ IPs in our system.
+ * Define 'LOW_VLYNQ_CONTROL_BASE' with the VLYNQ
+ * IP having lowest base address.
+ * Define 'HIGH_VLYNQ_CONTROL_BASE' with the VLYNQ
+ * IP having highest base address.
+ * In case of only one VLYNQ IP, define only the
+ * 'LOW_VLYNQ_CONTROL_BASE'.
+ */
+#define LOW_VLYNQ_CONTROL_BASE		DAVINCI_VLYNQ_BASE
 
-/* NOR Flash base address set to CS0 by default */
-#define DAVINCI_CS0_PHYS	0x02000000
 
 #endif /* __ASM_ARCH_HARDWARE_H */
Index: linux-2.6.10/include/asm-arm/arch-davinci/hrtime.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/hrtime.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/hrtime.h
@@ -20,10 +20,10 @@
 #define SC_NSEC2ARCH	32
 
 #define scaled_nsec_per_arch_cycle	\
-	(SC_n(SC_ARCH2NSEC, NSEC_PER_SEC) / CLOCK_TICK_RATE)
+	(SC_n(SC_ARCH2NSEC, NSEC_PER_SEC) / (DAVINCI_CLOCK_TICK_RATE))
 
 #define scaled_arch_cycles_per_nsec	\
-	(SC_n(SC_NSEC2ARCH, CLOCK_TICK_RATE) / NSEC_PER_SEC)
+	(SC_n(SC_NSEC2ARCH, DAVINCI_CLOCK_TICK_RATE) / NSEC_PER_SEC)
 
 #define arch_cycle_to_nsec(cycles)	\
 	mpy_sc_n(SC_ARCH2NSEC, (cycles), scaled_nsec_per_arch_cycle)
@@ -39,7 +39,7 @@ int get_arch_cycles(unsigned long);
 #define hrtimer_use		1
 
 #define hr_time_resolution	1000	/* (NSEC_PER_SEC / CLOCK_TICK_RATE) */
-#define arch_cycles_per_jiffy	(long)(CLOCK_TICK_RATE / HZ)
+#define arch_cycles_per_jiffy	(long)(DAVINCI_CLOCK_TICK_RATE / HZ)
 #define schedule_jiffies_int(x)	(get_arch_cycles(x) >= arch_cycles_per_jiffy)
 
 #endif				/* CONFIG_HIGH_RES_TIMERS */
Index: linux-2.6.10/include/asm-arm/arch-davinci/i2c-client.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/i2c-client.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/i2c-client.h
@@ -26,7 +26,17 @@ typedef enum {
         CF_RESET = 3,
         WLAN_RESET = 4,
         ATA_SEL = 5,
-        CF_SEL = 6
+	CF_SEL = 6,
+
+	/* DM646X expanders */
+	ATA_SEL_DM646X = 0,
+	ATA_PWD_DM646X = 1,
+	VSCALE_ON_DM646X = 2,
+	VLYNQ_RESET_DM646X = 3,
+	I2C_INT_DM646X = 4,
+	USB_FB_DM646X = 5,
+	CIR_MOD_DM646X = 6,
+	CIR_DEMOD_DM646X = 7,
 } u35_expander_ops;
 
 int davinci_i2c_expander_op (u16 client_addr, u35_expander_ops pin, u8 val);
Index: linux-2.6.10/include/asm-arm/arch-davinci/io.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/io.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/io.h
@@ -28,6 +28,7 @@
 #ifndef __ASM_ARCH_IO_H
 #define __ASM_ARCH_IO_H
 
+#include <asm/arch/hardware.h>
 #include <asm/types.h>
 
 #define IO_SPACE_LIMIT 0xffffffff
@@ -37,11 +38,53 @@
  * I/O mapping
  * ----------------------------------------------------------------------------
  */
-#define IO_PHYS	     0x01c00000
-#define IO_VIRT	     0xe1000000
-#define IO_SIZE	     0x00400000
-#define io_p2v(pa)   (((pa) & (IO_SIZE-1)) + IO_VIRT)
-#define io_v2p(va)   (((va) & (IO_SIZE-1)) + IO_PHYS)
+#define IO_PHYS		0x01c00000
+#define IO_VIRT		0xe1000000
+#define IO_SIZE		SZ_4M
+
+/* DM646X need to map 0x02000000-0x02400000  to 0x01e400000-0x0e1800000*/
+/* This is put in the generic section so IRAM is mapped the same between
+   DaVinci and DM646X - Note that this will leave a hole for DaVinci */
+#define DM646X_IO_PHYS		0x02000000
+#define DM646X_IO_VIRT		(IO_VIRT + IO_SIZE)
+#define DM646X_IO_SIZE		SZ_4M
+
+#define DAVINCI_IRAM_VIRT		(DM646X_IO_VIRT + DM646X_IO_SIZE)
+					/* after 4M of IO space */
+#define DAVINCI_IRAM_SIZE		SZ_16K
+
+/*
+ * DM644X specific mappings
+ */
+/* DaVinci IRAM mapping */
+#define DAVINCI_IRAM_BASE	0x00008000 /* ARM Internal RAM (Data) */
+
+/* handle VLYNQ remap */
+#define VLYNQ_REMOTE_PHYS		0x0C000000
+#define VLYNQ_REMOTE_VIRT		DAVINCI_IRAM_VIRT + DAVINCI_IRAM_SIZE
+#define VLYNQ_REMOTE_SIZE		SZ_64M
+
+#define VLYNQ_PHYS_TO_VIRT(addr)	((addr) - (VLYNQ_REMOTE_PHYS) + \
+						(VLYNQ_REMOTE_VIRT))
+#define VLYNQ_VIRT_TO_PHYS(addr)	((addr) + (VLYNQ_REMOTE_PHYS) - \
+						(VLYNQ_REMOTE_VIRT))
+
+/*
+ * DM646X specific mappings
+ */
+/* IRAM mappings */
+#define DM646X_IRAM_BASE        0x00010000 /* ARM Internal RAM (Data) */
+
+/* handle DM646X EMIF remap */
+#define EMIF_CNTRL_VIRT		(DAVINCI_IRAM_VIRT + DAVINCI_IRAM_SIZE)
+#define EMIF_P2V(addr)		((emifregsovly)		\
+	((addr) - (DAVINCI_DM646X_ASYNC_EMIF_CNTRL_BASE) + (EMIF_CNTRL_VIRT)))
+
+/*
+ * cconversion functions
+ */
+#define io_p2v(pa)   (((pa) - (IO_PHYS)) + IO_VIRT)
+#define io_v2p(va)   (((va) - (IO_VIRT)) + IO_PHYS)
 #define IO_ADDRESS(x) io_p2v(x)
 
 /*
@@ -91,6 +134,7 @@ typedef struct { volatile u32 offset[409
 #define __REG(paddr)		__REGV32(io_p2v(paddr))
 
 extern void davinci_map_common_io(void);
+extern void davinci_init_common_hw(void);
 #else
 
 #define __REG(x)        (*((volatile unsigned long *)io_p2v(x)))
Index: linux-2.6.10/include/asm-arm/arch-davinci/irq.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/irq.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/irq.h
@@ -55,10 +55,10 @@ typedef struct intc_registers_t {
 	unsigned int intpri1;	/* 0x34 */
 	unsigned int intpri2;	/* 0x38 */
 	unsigned int intpri3;	/* 0x3C */
-	unsigned int intpri4;	/* 0x30 */
-	unsigned int intpri5;	/* 0x34 */
-	unsigned int intpri6;	/* 0x38 */
-	unsigned int intpri7;	/* 0x3C */
+	unsigned int intpri4;	/* 0x40 */
+	unsigned int intpri5;	/* 0x44 */
+	unsigned int intpri6;	/* 0x48 */
+	unsigned int intpri7;	/* 0x4C */
 } intc_registers;
 
 /****************************************************
Index: linux-2.6.10/include/asm-arm/arch-davinci/irqs.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/irqs.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/irqs.h
@@ -36,19 +36,22 @@
  * Definitions
  **************************************************************************/
 
-/* These interrupt definitions are common to all DaVinci variants */
+/* These interrupt definitions are common for DaVinci and DM355 */
 #define IRQ_ASQINT		9
 #define IRQ_IMXINT		10
 #define IRQ_USBINT		12
+#define IRQ_PSCINT		20
+#define IRQ_MBXINT		24
+#define IRQ_MBRINT		25
+#define IRQ_MMCINT		26
+#define IRQ_PWMINT2		38
+
+/* These interrupt definitions are common to all DaVinci variants */
 #define IRQ_CCINT0		16
 #define IRQ_CCERRINT		17
 #define IRQ_TCERRINT0		18
 #define IRQ_TCERRINT		19
 #define IRQ_TCERRINT1		19
-#define IRQ_PSCINT		20
-#define IRQ_MBXINT		24
-#define IRQ_MBRINT		25
-#define IRQ_MMCINT		26
 #define IRQ_DDRINT		29
 #define IRQ_AEMIFINT		30
 #define IRQ_TINT0		32
@@ -61,7 +64,6 @@
 #define IRQ_TINT1_TINT34	35
 #define IRQ_PWMINT0		36
 #define IRQ_PWMINT1		37
-#define IRQ_PWMINT2		38
 #define IRQ_I2C			39
 #define IRQ_UARTINT0		40
 #define IRQ_UARTINT1		41
@@ -145,15 +147,15 @@
 #define IRQ_DM644X_GPIOBNK4	60
 
 /* DaVinci DM355-specific Interrupts */
-#define IRQ_DM355_VPSSINT0	0
-#define IRQ_DM355_VPSSINT1	1
-#define IRQ_DM355_VPSSINT2	2
-#define IRQ_DM355_VPSSINT3	3
-#define IRQ_DM355_VPSSINT4	4
-#define IRQ_DM355_VPSSINT5	5
-#define IRQ_DM355_VPSSINT6	6
-#define IRQ_DM355_VPSSINT7	7
-#define IRQ_DM355_VPSSINT8	8
+#define IRQ_DM355_CCDC_VDINT0	0
+#define IRQ_DM355_CCDC_VDINT1	1
+#define IRQ_DM355_CCDC_VDINT2	2
+#define IRQ_DM355_IPIPE_HST 	3	
+#define IRQ_DM355_H3AINT	4
+#define IRQ_DM355_IPIPE_SDR 	5	
+#define IRQ_DM355_IPIPEIFINT	6
+#define IRQ_DM355_OSDINT        7	
+#define IRQ_DM355_VENCINT       8	
 #define IRQ_DM355_IMCOPINT	11
 #define IRQ_DM355_RTOINT	13
 #define IRQ_DM355_TINT4		13
@@ -195,6 +197,56 @@
 #define IRQ_DM355_GPIOBNK5	59
 #define IRQ_DM355_GPIOBNK6	60
 
+/* DaVinci DM6467-specific Interrupts */
+#define IRQ_DM646X_VP_VERTINT0	0
+#define IRQ_DM646X_VP_VERTINT1	1
+#define IRQ_DM646X_VP_VERTINT2	2
+#define IRQ_DM646X_VP_VERTINT3	3
+#define IRQ_DM646X_VP_ERRINT	4
+#define IRQ_DM646X_RESERVED_1	5
+#define IRQ_DM646X_RESERVED_2	6
+#define IRQ_DM646X_WDINT	7
+#define IRQ_DM646X_CRGENINT0	8
+#define IRQ_DM646X_CRGENINT1	9
+#define IRQ_DM646X_TSIFINT0	10
+#define IRQ_DM646X_TSIFINT1	11
+#define IRQ_DM646X_VDCEINT	12
+#define IRQ_DM646X_USBINT	13
+#define IRQ_DM646X_USBDMAINT	14
+#define IRQ_DM646X_PCIINT	15
+#define IRQ_DM646X_TCERRINT2	20
+#define IRQ_DM646X_TCERRINT3	21
+#define IRQ_DM646X_IDE		22
+#define IRQ_DM646X_HPIINT	23
+#define IRQ_DM646X_EMACRXTHINT	24
+#define IRQ_DM646X_EMACRXINT	25
+#define IRQ_DM646X_EMACTXINT	26
+#define IRQ_DM646X_EMACMISCINT	27
+#define IRQ_DM646X_MCASP0TXINT	28
+#define IRQ_DM646X_MCASP0RXINT	29
+#define IRQ_DM646X_RESERVED_3	31
+#define IRQ_DM646X_MCASP1TXINT	32
+#define IRQ_DM646X_VLQINT	38
+#define IRQ_DM646X_UARTINT2	42
+#define IRQ_DM646X_SPINT0	43
+#define IRQ_DM646X_SPINT1	44
+#define IRQ_DM646X_DSP2ARMINT	45
+#define IRQ_DM646X_RESERVED_4	46
+#define IRQ_DM646X_PSCINT	47
+#define IRQ_DM646X_GPIO0	48
+#define IRQ_DM646X_GPIO1	49
+#define IRQ_DM646X_GPIO2	50
+#define IRQ_DM646X_GPIO3	51
+#define IRQ_DM646X_GPIO4	52
+#define IRQ_DM646X_GPIO5	53
+#define IRQ_DM646X_GPIO6	54
+#define IRQ_DM646X_GPIO7	55
+#define IRQ_DM646X_GPIOBNK0	56
+#define IRQ_DM646X_GPIOBNK1	57
+#define IRQ_DM646X_GPIOBNK2	58
+#define IRQ_DM646X_DDRINT	59
+#define IRQ_DM646X_AEMIFINT	60
+
 #define DAVINCI_MAXIRQNUM	63
 #define NR_IRQS			(DAVINCI_MAXIRQNUM + 1)
 #define DAVINCI_MAXSWINUM	DAVINCI_MAXIRQNUM
Index: linux-2.6.10/include/asm-arm/arch-davinci/memory.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/memory.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/memory.h
@@ -45,9 +45,6 @@
  **************************************************************************/
 #define DAVINCI_DDR_BASE    0x80000000
 
-#define DAVINCI_IRAM_BASE   0x00008000 /* ARM Internal RAM (Data) */
-#define DAVINCI_IRAM_VIRT   0xe1400000 /* after 4M of IO space (io.h) */
-
 /* Linux Memory Pool */
 
 /* The start of physical memory available to the kernel. This value
Index: linux-2.6.10/include/asm-arm/arch-davinci/timex.h
===================================================================
--- linux-2.6.10.orig/include/asm-arm/arch-davinci/timex.h
+++ linux-2.6.10/include/asm-arm/arch-davinci/timex.h
@@ -31,8 +31,18 @@
 #ifndef __ASM_ARCH_TIMEX_H
 #define __ASM_ARCH_TIMEX_H
 
+
+#include <asm/arch/cpu.h>
+
 /* The source frequency for the timers is the 27MHz MXI clock */
-#define CLOCK_TICK_RATE	        27000000
+#define CLOCK_TICK_RATE				24000000
+#define DM644X_CLOCK_TICK_RATE			27000000
+#define DM646X_CLOCK_TICK_RATE			148500000
+#define DM355_CLOCK_TICK_RATE			24000000
+
+#define DAVINCI_CLOCK_TICK_RATE ((cpu_is_davinci_dm6467()) ?          \
+		DM646X_CLOCK_TICK_RATE : ((cpu_is_davinci_dm644x()) ?   \
+		DM644X_CLOCK_TICK_RATE : DM355_CLOCK_TICK_RATE))
 
 extern void davinci_watchdog_reset(void);
 extern cycles_t davinci_get_cycles(void);
Index: linux-2.6.10/arch/arm/mach-davinci/clock.h
===================================================================
--- linux-2.6.10.orig/arch/arm/mach-davinci/clock.h
+++ linux-2.6.10/arch/arm/mach-davinci/clock.h
@@ -57,4 +57,7 @@ int clk_register(struct clk *clk);
 void clk_unregister(struct clk *clk);
 int clk_init(void);
 void board_setup_psc(unsigned int domain, unsigned int id, char enable);
+
+extern void (*davinci_pinmux_setup)(unsigned int id);
+
 #endif
Index: linux-2.6.10/mvl_patches/pro-1679.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1679.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1679);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

