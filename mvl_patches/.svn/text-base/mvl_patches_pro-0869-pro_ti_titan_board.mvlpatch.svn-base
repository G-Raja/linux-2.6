#! /usr/bin/env bash
# Patch: -pro_ti_titan_board
# Date: Wed Aug 16 10:57:52 2006
# Source: Texas Instruments Inc., modified by MontaVista Software Inc.
# MR: 18281
# Type: Enhancement
# Disposition: needs submitting to linux-mips.org
# Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
# Description:
# 
# [PATCH 1/4]: Board Support patch for TI TITAN
# 
#  arch/mips/Kconfig                                                       |   19 
#  arch/mips/Makefile                                                      |    6 
#  arch/mips/configs/titan_defconfig                                       |  876 +++++
#  arch/mips/kernel/traps.c                                                |   10 
#  arch/mips/mips-boards/generic/init.c                                    |   25 
#  arch/mips/mips-boards/generic/memory.c                                  |   39 
#  arch/mips/mips-boards/generic/mipsIRQ.S                                 |    2 
#  arch/mips/mips-boards/generic/printf.c                                  |   34 
#  arch/mips/mips-boards/generic/reset.c                                   |   39 
#  arch/mips/mips-boards/generic/time.c                                    |   50 
#  arch/mips/mips-boards/ti_avalanche/Kconfig                              |   83 
#  arch/mips/mips-boards/ti_avalanche/Makefile                             |   20 
#  arch/mips/mips-boards/ti_avalanche/ti_generic/Makefile                  |   21 
#  arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_generic_setup.c |  183 +
#  arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_intc.c          |  581 +++
#  arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_misc.c          |  234 +
#  arch/mips/mips-boards/ti_avalanche/ti_titan/Kconfig                     |   71 
#  arch/mips/mips-boards/ti_avalanche/ti_titan/Makefile                    |    6 
#  arch/mips/mips-boards/ti_avalanche/ti_titan/env.c                       |  886 +++++
#  arch/mips/mips-boards/ti_avalanche/ti_titan/flashop.h                   |  166 +
#  arch/mips/mips-boards/ti_avalanche/ti_titan/flashop_linux.c             |  201 +
#  arch/mips/mips-boards/ti_avalanche/ti_titan/rtc_ds1338.c                |   48 
#  arch/mips/mips-boards/ti_avalanche/ti_titan/ssp_hal.c                   | 1483 ++++++++++
#  arch/mips/mips-boards/ti_avalanche/ti_titan/titan_board_setup.c         |   95 
#  arch/mips/mips-boards/ti_avalanche/ti_titan/titan_clk_cntl.c            |  998 ++++++
#  include/asm-mips/mach-avalanche/avalanche_intc.h                        |   85 
#  include/asm-mips/mach-avalanche/cpu-feature-overrides.h                 |   44 
#  include/asm-mips/mach-avalanche/env.h                                   |   31 
#  include/asm-mips/mach-avalanche/ioctl_api.h                             |  116 
#  include/asm-mips/mach-avalanche/pal.h                                   |  116 
#  include/asm-mips/mach-avalanche/pal_defs.h                              |  187 +
#  include/asm-mips/mach-avalanche/soc.h                                   |   99 
#  include/asm-mips/mach-avalanche/ssp_hal.h                               |  105 
#  include/asm-mips/mach-avalanche/titan.h                                 |  249 +
#  include/asm-mips/serial.h                                               |   20 
#  35 files changed, 7221 insertions(+), 7 deletions(-)
# 
# 

PATCHNUM=869
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments Inc., modified by MontaVista Software Inc.
MR: 18281
Type: Enhancement
Disposition: needs submitting to linux-mips.org
Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
Description:

[PATCH 1/4]: Board Support patch for TI TITAN

 arch/mips/Kconfig                                                       |   19 
 arch/mips/Makefile                                                      |    6 
 arch/mips/configs/titan_defconfig                                       |  876 +++++
 arch/mips/kernel/traps.c                                                |   10 
 arch/mips/mips-boards/generic/init.c                                    |   25 
 arch/mips/mips-boards/generic/memory.c                                  |   39 
 arch/mips/mips-boards/generic/mipsIRQ.S                                 |    2 
 arch/mips/mips-boards/generic/printf.c                                  |   34 
 arch/mips/mips-boards/generic/reset.c                                   |   39 
 arch/mips/mips-boards/generic/time.c                                    |   50 
 arch/mips/mips-boards/ti_avalanche/Kconfig                              |   83 
 arch/mips/mips-boards/ti_avalanche/Makefile                             |   20 
 arch/mips/mips-boards/ti_avalanche/ti_generic/Makefile                  |   21 
 arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_generic_setup.c |  183 +
 arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_intc.c          |  581 +++
 arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_misc.c          |  234 +
 arch/mips/mips-boards/ti_avalanche/ti_titan/Kconfig                     |   71 
 arch/mips/mips-boards/ti_avalanche/ti_titan/Makefile                    |    6 
 arch/mips/mips-boards/ti_avalanche/ti_titan/env.c                       |  886 +++++
 arch/mips/mips-boards/ti_avalanche/ti_titan/flashop.h                   |  166 +
 arch/mips/mips-boards/ti_avalanche/ti_titan/flashop_linux.c             |  201 +
 arch/mips/mips-boards/ti_avalanche/ti_titan/rtc_ds1338.c                |   48 
 arch/mips/mips-boards/ti_avalanche/ti_titan/ssp_hal.c                   | 1483 ++++++++++
 arch/mips/mips-boards/ti_avalanche/ti_titan/titan_board_setup.c         |   95 
 arch/mips/mips-boards/ti_avalanche/ti_titan/titan_clk_cntl.c            |  998 ++++++
 include/asm-mips/mach-avalanche/avalanche_intc.h                        |   85 
 include/asm-mips/mach-avalanche/cpu-feature-overrides.h                 |   44 
 include/asm-mips/mach-avalanche/env.h                                   |   31 
 include/asm-mips/mach-avalanche/ioctl_api.h                             |  116 
 include/asm-mips/mach-avalanche/pal.h                                   |  116 
 include/asm-mips/mach-avalanche/pal_defs.h                              |  187 +
 include/asm-mips/mach-avalanche/soc.h                                   |   99 
 include/asm-mips/mach-avalanche/ssp_hal.h                               |  105 
 include/asm-mips/mach-avalanche/titan.h                                 |  249 +
 include/asm-mips/serial.h                                               |   20 
 mvl_patches/pro-0869.c                                                  |   16 
 36 files changed, 7237 insertions(+), 7 deletions(-)


Index: linux-2.6.10/arch/mips/configs/titan_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/configs/titan_defconfig
@@ -0,0 +1,876 @@
+#
+CONFIG_MIPS=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
+CONFIG_MIPS32=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SEMMNI=128
+CONFIG_SYSVIPC_SEMMSL=250
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_SHMEM is not set
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_LTT_MAX_HANDLES=128
+# CONFIG_BOOT_FLIGHT_RECORDER is not set
+CONFIG_LOCKLESS=y
+CONFIG_BOOT_FLIGHT_BUFFERS=4
+CONFIG_BOOT_FLIGHT_SIZE=524288
+CONFIG_FLIGHT_PROC_BUFFERS=8
+CONFIG_FLIGHT_PROC_SIZE=8192
+CONFIG_NEWEV=y
+CONFIG_CSTM=y
+CONFIG_TINY_SHMEM=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Machine selection
+#
+CONFIG_MIPS_AVALANCHE_SOC=y
+
+#
+# Avalanche SoC Common Options
+#
+CONFIG_CPU_FREQUENCY_AVALANCHE=125
+CONFIG_MEMORY_START=0x14000000
+CONFIG_MIPS_AVALANCHE_LOAD_ADDRESS=0xFFFFFFFF94020000
+CONFIG_MIPS_AVALANCHE_PSPBOOT=y
+# CONFIG_MIPS_AVALANCHE_FREE_BOOTMEM is not set
+CONFIG_MIPS_AVALANCHE_INTC=y
+CONFIG_MIPS_TITAN=y
+
+#
+# TI Titan (TNETV1050) Configuration
+#
+# CONFIG_MIPS_TNETV1050RDB is not set
+CONFIG_MIPS_TNETV1050SDB=y
+CONFIG_MIPS_AVALANCHE_CPMAC=y
+CONFIG_MIPS_CPMAC_PORTS=2
+CONFIG_AVALANCHE_LOW_CPMAC=y
+CONFIG_AVALANCHE_HIGH_CPMAC=y
+CONFIG_MIPS_CPMAC_INIT_BUF_MALLOC=y
+CONFIG_MIPS_AVALANCHE_SSP=y
+CONFIG_AVALANCHE_NUM_SER_PORTS=1
+CONFIG_AVALANCHE_CONSOLE_PORT=0
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_BRCM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_VR5701_SG2 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SOC_AU1X00 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_TOSHIBA_RBTX4939 is not set
+# CONFIG_CAVIUM_OCTEON_EBT3000 is not set
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT_DESKTOP=y
+# CONFIG_PREEMPT_RT is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_SOFTIRQS=y
+CONFIG_PREEMPT_HARDIRQS=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_SPINLOCK_BKL is not set
+CONFIG_PREEMPT_BKL=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ASM_SEMAPHORES=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_MIPS_BOARDS_GEN=y
+CONFIG_SWAP_IO_SPACE=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R5500 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+# CONFIG_CPU_CAVIUM_OCTEON is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_VTAG_ICACHE is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+# CONFIG_HIGH_RES_TIMERS is not set
+# CONFIG_CPU_TIMER is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_MULTI_PHYSMAP is not set
+CONFIG_MTD_AVALANCHE=y
+CONFIG_MTD_AVALANCHE_CHIP0_START=0x10000000
+CONFIG_MTD_AVALANCHE_CHIP0_LEN=0x400000
+CONFIG_MTD_AVALANCHE_CHIP0_BUSWIDTH=2
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_RAMTD is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_USE_POLICY_FWD=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_ENHANCEMENT is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_SMC91X is not set
+
+#
+# Broadcom network devices
+#
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=0
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_BLOCKER is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+# CONFIG_I2C_ALGO_SGI is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_OMAP is not set
+CONFIG_AVALANCHE_SSP_I2C=y
+
+#
+# Hardware Sensors Chip support
+#
+CONFIG_I2C_SENSOR=y
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_DS1374 is not set
+CONFIG_SENSORS_DS1338=y
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# Synchronous Serial Interfaces (SSI)
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS_XATTR=y
+# CONFIG_DEVPTS_FS_SECURITY is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+# CONFIG_YAFFS1_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# MontaVista System tools
+#
+# CONFIG_ILATENCY is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_WAKEUP_TIMING is not set
+CONFIG_PREEMPT_TRACE=y
+# CONFIG_CRITICAL_PREEMPT_TIMING is not set
+# CONFIG_CRITICAL_IRQSOFF_TIMING is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="ip=bootp root=/dev/nfs"
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Fast Real-Time Domain
+#
+# CONFIG_FRD is not set
+
+#
+# Fast Real-Time Domain Advanced Options
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -27,6 +27,21 @@ source "init/Kconfig"
 
 menu "Machine selection"
 
+config MIPS_AVALANCHE_SOC
+       bool "Support for MIPS based Avalanche Series TI BroadBand Processor(s)"
+    select DMA_NONCOHERENT
+    select SWAP_IO_SPACE
+       help
+      Select this option if you intend to run on any of the Avalanche Series
+      of the BroadBand Processor(s) by TI.
+      Selecting Y will further probe the specific SoC type you want to run on.
+      If in doubt say Y.
+
+if MIPS_AVALANCHE_SOC
+    source "arch/mips/mips-boards/ti_avalanche/Kconfig"
+endif
+
+
 config MACH_JAZZ
 	bool "Support for the Jazz family of machines"
 	select ARC
@@ -1093,7 +1108,7 @@ config MIPS_DISABLE_OBSOLETE_IDE
 
 config CPU_LITTLE_ENDIAN
 	bool "Generate little endian code"
-	default y if ACER_PICA_61 || CASIO_E55 || DDB5074 || DDB5476 || DDB5477 || MACH_DECSTATION || IBM_WORKPAD || LASAT || MIPS_COBALT || MIPS_ITE8172 || MIPS_IVR || SOC_AU1X00 || NEC_OSPREY || OLIVETTI_M700 || SNI_RM200_PCI || VICTOR_MPC30X || ZAO_CAPCELLA
+	default y if ACER_PICA_61 || CASIO_E55 || DDB5074 || DDB5476 || DDB5477 || MACH_DECSTATION || IBM_WORKPAD || LASAT || MIPS_COBALT || MIPS_ITE8172 || MIPS_IVR || SOC_AU1X00 || NEC_OSPREY || OLIVETTI_M700 || SNI_RM200_PCI || VICTOR_MPC30X || ZAO_CAPCELLA || MIPS_AVALANCHE_SOC
 	default n if MIPS_EV64120 || MIPS_EV96100 || MOMENCO_OCELOT || MOMENCO_OCELOT_G || SGI_IP22 || SGI_IP27 || SGI_IP32 || TOSHIBA_JMR3927 || MARKEINS
 	help
 	  Some MIPS machines can be configured for either little or big endian
@@ -1119,7 +1134,7 @@ config DDB5XXX_COMMON
 
 config MIPS_BOARDS_GEN
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA || MIPS_SEAD
+	depends on MIPS_ATLAS || MIPS_MALTA || MIPS_SEAD || MIPS_AVALANCHE_SOC
 	default y
 
 config MIPS_GT64111
Index: linux-2.6.10/arch/mips/kernel/traps.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/traps.c
+++ linux-2.6.10/arch/mips/kernel/traps.c
@@ -933,9 +933,19 @@ void *set_except_vector(int n, void *add
 
 	exception_handlers[n] = handler;
 	if (n == 0 && cpu_has_divec) {
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+		*(volatile u32 *)(CAC_BASE + 0x200) = 0x3c1a0000 |
+							(handler >> 16);
+		*(volatile u32 *)(CAC_BASE + 0x204) = 0x375a0000 |
+							(handler & 0xFFFF);
+		*(volatile u32 *)(CAC_BASE + 0x208) = 0x03400008;
+
+		flush_icache_range(CAC_BASE + 0x200, CAC_BASE + 0x20C);
+#else
 		*(volatile u32 *)(CAC_BASE + 0x200) = 0x08000000 |
 		                                 (0x03ffffff & (handler >> 2));
 		flush_icache_range(CAC_BASE + 0x200, CAC_BASE + 0x204);
+#endif
 	}
 	return (void *)old_handler;
 }
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -392,6 +392,12 @@ load-$(CONFIG_MIPS_ITE8172)	+= 0xfffffff
 # For all MIPS, Inc. eval boards
 #
 core-$(CONFIG_MIPS_BOARDS_GEN)	+= arch/mips/mips-boards/generic/
+#
+# Texas Instruments Avalanche Series SoCs (MIPS based)
+#
+core-$(CONFIG_MIPS_AVALANCHE_SOC)      += arch/mips/mips-boards/ti_avalanche/
+cflags-$(CONFIG_MIPS_AVALANCHE_SOC)    += -Iinclude/asm-mips/mach-avalanche
+load-$(CONFIG_MIPS_AVALANCHE_SOC)      += CONFIG_MIPS_AVALANCHE_LOAD_ADDRESS
 
 #
 # MIPS Atlas board
Index: linux-2.6.10/arch/mips/mips-boards/generic/init.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/init.c
+++ linux-2.6.10/arch/mips/mips-boards/generic/init.c
@@ -35,6 +35,10 @@
 #include <asm/mips-boards/malta.h>
 #endif
 
+#ifdef CONFIG_MIPS_AVALANCHE_PSPBOOT
+#include <asm/mach-avalanche/env.h>
+#endif
+
 int prom_argc;
 int *_prom_argv, *_prom_envp;
 
@@ -60,6 +64,15 @@ unsigned long _pcictrl_msc;
 
 char *prom_getenv(char *envname)
 {
+#if defined (CONFIG_MIPS_AVALANCHE_PSPBOOT) /* PSP Boot related code. */
+	int index;
+        for (index = 0; index < sizeof(env_adam2_alias)/sizeof(env_adam2_alias[0]); index++) {
+                if (strcmp(env_adam2_alias[index].nm, envname) == 0) {
+                        return sys_getenv(env_adam2_alias[index].new_nm);
+                }
+        }
+	return sys_getenv(envname);
+#else		
 	/*
 	 * Return a pointer to the given environment variable.
 	 * In 64-bit mode: we're using 64-bit pointers, but all pointers
@@ -78,6 +91,7 @@ char *prom_getenv(char *envname)
 	}
 
 	return NULL;
+#endif
 }
 
 static inline unsigned char str2hexnum(unsigned char c)
@@ -167,6 +181,11 @@ void __init prom_init(void)
 	_prom_argv = (int *) fw_arg1;
 	_prom_envp = (int *) fw_arg2;
 
+#if defined(CONFIG_MIPS_AVALANCHE_PSPBOOT)
+    sys_initenv();
+#endif
+
+#if !defined(CONFIG_MIPS_AVALANCHE_SOC)
 	mips_display_message("LINUX");
 
 #ifdef CONFIG_MIPS_SEAD
@@ -272,6 +291,12 @@ void __init prom_init(void)
 		while(1);   /* We die here... */
 	}
 #endif
+#endif
+
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+    set_io_port_base(0);
+	setup_prom_printf(0);
+#endif /* CONFIG_MIPS_AVALANCHE_SOC */
 	prom_printf("\nLINUX started...\n");
 	prom_init_cmdline();
 	prom_meminit();
Index: linux-2.6.10/arch/mips/mips-boards/generic/memory.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/memory.c
+++ linux-2.6.10/arch/mips/mips-boards/generic/memory.c
@@ -28,6 +28,10 @@
 
 #include <asm/mips-boards/prom.h>
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+#include <asm/mach-avalanche/pal.h>
+#endif
+
 /*#define DEBUG*/
 
 enum yamon_memtypes {
@@ -58,8 +62,13 @@ struct prom_pmemblock * __init prom_getm
 
 	memsize_str = prom_getenv("memsize");
 	if (!memsize_str) {
+#ifdef CONFIG_MIPS_AVALANCHE_SOC
+		prom_printf("memsize not set in boot prom, set to default (64Mb)\n");
+		memsize = 0x04000000;
+#else
 		prom_printf("memsize not set in boot prom, set to default (32Mb)\n");
 		memsize = 0x02000000;
+#endif
 	} else {
 #ifdef DEBUG
 		prom_printf("prom_memsize = %s\n", memsize_str);
@@ -69,6 +78,35 @@ struct prom_pmemblock * __init prom_getm
 
 	memset(mdesc, 0, sizeof(mdesc));
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+
+#define PREV_MDESC(x)  ((x) - 1)
+    {
+        struct prom_pmemblock *p_mdesc = &mdesc[0];
+	p_mdesc->type = yamon_dontuse;	
+	p_mdesc->base = 0x00000000;
+	p_mdesc->size = AVALANCHE_SDRAM_BASE;
+
+	p_mdesc++;
+	p_mdesc->type = yamon_prom;
+	p_mdesc->base = PREV_MDESC(p_mdesc)->base + PREV_MDESC(p_mdesc)->size;
+	p_mdesc->size = PAGE_SIZE;
+
+	p_mdesc++;
+	p_mdesc->type = yamon_prom;    
+	p_mdesc->base = PREV_MDESC(p_mdesc)->base + PREV_MDESC(p_mdesc)->size;
+	p_mdesc->size = (CONFIG_MIPS_AVALANCHE_LOAD_ADDRESS - KSEG0ADDR(AVALANCHE_SDRAM_BASE)) - PAGE_SIZE;
+
+	p_mdesc++;
+	p_mdesc->type = yamon_dontuse;
+	p_mdesc->base = PREV_MDESC(p_mdesc)->base + PREV_MDESC(p_mdesc)->size;
+	p_mdesc->size = CPHYSADDR(PFN_ALIGN(&_end)) - p_mdesc->base;
+	p_mdesc++;
+	p_mdesc->type = yamon_free;
+	p_mdesc->base = PREV_MDESC(p_mdesc)->base + PREV_MDESC(p_mdesc)->size;
+	p_mdesc->size = memsize - (CPHYSADDR(PFN_ALIGN(&_end)) - AVALANCHE_SDRAM_BASE);
+    }
+#else 
 	mdesc[0].type = yamon_dontuse;
 	mdesc[0].base = 0x00000000;
 	mdesc[0].size = 0x00001000;
@@ -101,6 +139,7 @@ struct prom_pmemblock * __init prom_getm
 	mdesc[4].type = yamon_free;
 	mdesc[4].base = CPHYSADDR(PFN_ALIGN(&_end));
 	mdesc[4].size = memsize - mdesc[4].base;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC */	
 
 	return &mdesc[0];
 }
Index: linux-2.6.10/arch/mips/mips-boards/generic/mipsIRQ.S
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/mipsIRQ.S
+++ linux-2.6.10/arch/mips/mips-boards/generic/mipsIRQ.S
@@ -111,6 +111,8 @@
 	jal	malta_hw0_irqdispatch
 #elif defined(CONFIG_MIPS_SEAD)
 	jal	sead_hw0_irqdispatch
+#elif defined(CONFIG_MIPS_AVALANCHE_SOC)
+        jal     avalanche_hw0_irqdispatch
 #else
 #error "MIPS board not supported\n"
 #endif
Index: linux-2.6.10/arch/mips/mips-boards/generic/printf.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/printf.c
+++ linux-2.6.10/arch/mips/mips-boards/generic/printf.c
@@ -24,6 +24,38 @@
 #include <linux/spinlock.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+#include <asm/addrspace.h>
+#include <asm/mach-avalanche/pal.h>
+
+static char ppbuf[1024];
+
+void (*prom_print_str)(unsigned int out, char *s, int len);
+
+void setup_prom_printf(void) __init;
+void setup_prom_printf(void)
+{
+        prom_print_str = (void *)*(unsigned int *)AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR;
+}
+
+void prom_printf(char *fmt, ...) __init;
+void prom_printf(char *fmt, ...)
+{
+  va_list args;
+  int len;
+
+  va_start(args, fmt);
+  vsprintf(ppbuf, fmt, args);
+  len = strlen(ppbuf);
+
+  prom_print_str(1, ppbuf, len);
+
+  va_end(args);
+  return;
+
+}
+#else  /* !CONFIG_MIPS_AVALANCHE_SOC */
+
 #ifdef CONFIG_MIPS_ATLAS
 #include <asm/mips-boards/atlas.h>
 
@@ -76,4 +108,4 @@ char prom_getchar(void)
 
 	return serial_in(UART_RX);
 }
-
+#endif /* CONFIG_MIPS_AVALANCHE_SOC */
Index: linux-2.6.10/arch/mips/mips-boards/generic/reset.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/reset.c
+++ linux-2.6.10/arch/mips/mips-boards/generic/reset.c
@@ -31,6 +31,17 @@
 #include <asm/mips-boards/atlas.h>
 #endif
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+#include <asm/mach-avalanche/pal.h>
+
+#define AVALANCHE_RST_SWRCR (1<<0)  /* System software reset */
+#define AVALANCHE_GO_RESET   1
+#define AVALANCHE_GO_IDLE    1
+#define AVALANCHE_GO_STBY    2
+#define AVALANCHE_GO_HALT    3
+
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
+
 static void mips_machine_restart(char *command);
 static void mips_machine_halt(void);
 #if defined(CONFIG_MIPS_ATLAS)
@@ -39,16 +50,34 @@ static void atlas_machine_power_off(void
 
 static void mips_machine_restart(char *command)
 {
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+        avalanche_reset_ctrl(AVALANCHE_GO_RESET);
+        {
+                __asm__ __volatile(
+                        ".set noreorder\n\t"
+                        ".set mips3\n\t"
+                        "li $2,0xbfc00000\n\t"
+                        "jr $2\n\t"
+                        "nop\n\t"
+                        ".set mips0\n\t"
+                        ".set reorder\n\t");
+        }
+#else /* !CONFIG_MIPS_AVALANCHE_SOC  */
         volatile unsigned int *softres_reg = (unsigned int *)ioremap (SOFTRES_REG, sizeof(unsigned int));
 
 	*softres_reg = GORESET;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
 }
 
 static void mips_machine_halt(void)
 {
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+        avalanche_set_global_powermode(AVALANCHE_GO_HALT);
+#else
         volatile unsigned int *softres_reg = (unsigned int *)ioremap (SOFTRES_REG, sizeof(unsigned int));
 
 	*softres_reg = GORESET;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
 }
 
 #if defined(CONFIG_MIPS_ATLAS)
@@ -60,6 +89,13 @@ static void atlas_machine_power_off(void
 }
 #endif
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+static void avalanche_machine_power_off(void)
+{
+    avalanche_set_global_powermode(AVALANCHE_GO_STBY);
+}
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
+
 void mips_reboot_setup(void)
 {
 	_machine_restart = mips_machine_restart;
@@ -70,4 +106,7 @@ void mips_reboot_setup(void)
 #if defined(CONFIG_MIPS_MALTA) || defined(CONFIG_MIPS_SEAD)
 	_machine_power_off = mips_machine_halt;
 #endif
+#if defined(CONFIG_MIPS_AVALANCHE_SOC)
+	_machine_power_off = avalanche_machine_power_off;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
 }
Index: linux-2.6.10/arch/mips/mips-boards/generic/time.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mips-boards/generic/time.c
+++ linux-2.6.10/arch/mips/mips-boards/generic/time.c
@@ -39,6 +39,21 @@
 #include <asm/mips-boards/generic.h>
 #include <asm/mips-boards/prom.h>
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC )
+#include <asm/mach-avalanche/pal.h>
+                                                                                                
+/* AVALANCHE 7-segment display variables */
+unsigned long av_heartbeat_count;
+                                                                                                
+/* AVALANCHE Global cpu frequency variable */
+unsigned long cpu_freq;
+unsigned int mips_counter_frequency = 0;
+                                                                                                
+#else
+                                                                                                
+static long last_rtc_update = 0;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC  */
+
 unsigned long cpu_khz;
 
 #if defined(CONFIG_MIPS_SEAD)
@@ -56,22 +71,31 @@ static char display_string[] = "        
 #if defined(CONFIG_MIPS_SEAD)
 static char display_string[] = "        LINUX ON SEAD       ";
 #endif
+
+#if !defined(CONFIG_MIPS_AVALANCHE_SOC)
 static unsigned int display_count = 0;
 #define MAX_DISPLAY_COUNT (sizeof(display_string) - 8)
+static unsigned int timer_tick_count=0;
+#endif /* CONFIG_MIPS_AVALANCHE_SOC */
 
-#define MIPS_CPU_TIMER_IRQ (NR_IRQS-1)
+#define MAX_DISPLAY_COUNT (sizeof(display_string) - 8)
 
-static unsigned int timer_tick_count=0;
+#if defined(CONFIG_MIPS_AVALANCHE_SOC )
+#define MIPS_CPU_TIMER_IRQ 7
+#else
+#define MIPS_CPU_TIMER_IRQ (NR_IRQS-1)
+#endif
 
 void mips_timer_interrupt(struct pt_regs *regs)
 {
+#if !defined(CONFIG_MIPS_AVALANCHE_SOC)		
 	if ((timer_tick_count++ % HZ) == 0) {
 		mips_display_message(&display_string[display_count++]);
 		if (display_count == MAX_DISPLAY_COUNT)
 		        display_count = 0;
 
 	}
-
+#endif
 	ll_timer_interrupt(MIPS_CPU_TIMER_IRQ, regs);
 }
 
@@ -118,6 +142,23 @@ static unsigned int __init estimate_cpu_
 	local_irq_restore(flags);
 #endif
 
+#if defined(CONFIG_MIPS_AVALANCHE_SOC) 		
+	{
+		char *cpu_freq_ptr;
+    		cpu_freq_ptr = prom_getenv("cpufrequency");
+    		if(!cpu_freq_ptr)
+    		{
+    			cpu_freq = CONFIG_CPU_FREQUENCY_AVALANCHE * 1000000 ;
+    		} else {
+        		cpu_freq = simple_strtol(cpu_freq_ptr,NULL,0);
+    		}
+#ifdef CONFIG_HIGH_RES_TIMERS
+		count = cpu_freq;
+#else
+		count = cpu_freq/2;
+#endif
+	}
+#endif
 	mips_hpt_frequency = count;
 	if ((prid != (PRID_COMP_MIPS | PRID_IMP_20KC)) &&
 	    (prid != (PRID_COMP_MIPS | PRID_IMP_25KF)))
@@ -144,6 +185,9 @@ void __init mips_time_init(void)
         /* Set Data mode - binary. */
         CMOS_WRITE(CMOS_READ(RTC_CONTROL) | RTC_DM_BINARY, RTC_CONTROL);
 #endif
+#ifdef CONFIG_SENSORS_DS1338
+    ds1338_time_init();
+#endif
 
 	est_freq = estimate_cpu_frequency ();
 
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/Kconfig
@@ -0,0 +1,83 @@
+
+menu "Avalanche SoC Common Options"
+
+#
+# Configuration options common to all avalanche series processors come here.
+#
+config CPU_FREQUENCY_AVALANCHE
+	depends on MIPS_AVALANCHE_SOC
+	int "Avalanche SoC CPU frequency (MHz)"
+	default 125
+	help
+      Choose the default value here. The correct value will be read from
+      the bootloader environment variables.
+
+config MEMORY_START
+	depends on MIPS_AVALANCHE_SOC
+	hex "Avalanche SoC SDRAM start" 
+	default 0x14000000
+	help
+      Choose the default value here. Unless you really know what you are
+      doing.
+
+config MIPS_AVALANCHE_LOAD_ADDRESS
+	depends on MIPS_AVALANCHE_SOC
+	hex "Avalanche SoC Linux Load address" 
+	default 0xFFFFFFFF94020000
+	help
+      The default value should be good for most cases. Choose a value
+      higher than the default if you are using more memory at the bottom
+      than what the bootloader uses. Choosing a lesser value than the 
+      default is strictly discouraged. You will most likely mess with
+      the boot process. 
+
+config MIPS_AVALANCHE_PSPBOOT
+	depends on MIPS_AVALANCHE_SOC
+	bool "Avalanche SoC PSPBoot Support" 
+	default y
+	help
+      Choose Y here if PSPBoot is your bootloader. If you are using Adam2
+      or any other bootloader, choose N. If unsure, contact your software
+      vendor.
+
+config MIPS_AVALANCHE_FREE_BOOTMEM
+	depends on MIPS_AVALANCHE_SOC
+	def_bool n if MIPS_AVALANCHE_ADAM2_JMP_TBL    
+	bool "Free the memory occupied by bootloader"  if MIPS_AVALANCHE_PSPBOOT
+	default y
+	help
+      Saying yes here will free-up the memory from (SDRAM base + 4K) to
+      the start of linux text section. 
+    
+config AVALANCHE_SERIAL_AUTOFLOW 
+	depends on MIPS_AVALANCHE_S0C
+	bool "Avalanche Serial autoflow"
+	default y
+	help
+      Choose Y here if you want to enable Auto flow control on Avalanche
+      serial device. In unsure choose Y.
+
+config MIPS_AVALANCHE_INTC 
+	def_bool MIPS_AVALANCHE_SOC
+
+#
+# Get to know which specific SoC type the user wants to compile for.
+#
+choice
+	prompt "TI BroadBand SOC Type (Avalanche Series)"
+	depends on MIPS_AVALANCHE_SOC
+	help
+      Select the TI BoardBand SoC Type that you want the kernel port for. If
+      unsure, contact your software vendor.
+ 
+config MIPS_TITAN
+	bool "TI MIPS TITAN (aka TNETV1050 or TNETV1060)"
+
+
+endchoice
+
+if MIPS_TITAN
+    source "arch/mips/mips-boards/ti_avalanche/ti_titan/Kconfig"   
+endif
+
+endmenu
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/Makefile
@@ -0,0 +1,20 @@
+#
+# Carsten Langgaard, carstenl@mips.com
+# Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+#
+# This program is free software; you can distribute it and/or modify it
+# under the terms of the GNU General Public License (Version 2) as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+#
+
+obj-y                                           += ti_generic/
+obj-$(CONFIG_MIPS_TITAN)		                += ti_titan/
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_generic_setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_generic_setup.c
@@ -0,0 +1,183 @@
+/*
+ * Jeff Harrell, jharrell@ti.com
+ * Copyright (C) 2001 Texas Instruments, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Texas Instruments generic avalanche setup.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/mc146818rtc.h>
+#include <linux/ioport.h>
+#include <asm/time.h>
+
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/mips-boards/generic.h>
+#include <asm/mips-boards/prom.h>
+
+#include <linux/proc_fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/mach-avalanche/pal.h>
+
+#ifdef CONFIG_SERIAL_8250
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+extern int early_serial_setup(struct uart_port *port);
+#endif /* CONFIG_SERIAL_8250 */
+
+extern void mips_time_init(void);
+extern void mips_timer_setup(struct irqaction *irq);
+extern void avalanche_soc_platform_init(void);
+extern void mips_reboot_setup(void);
+extern unsigned int cpu_freq;
+extern void sangam_reset_init(void);
+irqreturn_t avalanche_unified_secondary_irq_handler( int unified_sec_irq,
+					void * dev_id, struct pt_regs *regs);
+
+
+#define PSP_NAME    "BasePSP"
+#define PSP_VERSION "8.0.0.3"
+
+static int avalanche_p_read_base_psp_version(char* buf, char **start, off_t offset, 
+                                             int count, int *eof, void *data)
+{
+    int len   = 0;
+    int limit = count - 80;
+    char *cache_mode[4] = {"cached, write through, no write allocate", \
+                           "cached, write through, write allocate", \
+                           "uncached", \
+                           "cached, write back, write allocate"};
+
+
+    int cache_index = read_c0_config() & 0x7;
+ 
+    if(cache_index == 7) cache_index = 2;
+    if((cache_index > 3) && (cache_index <= 6)) cache_index = 3;
+
+    if(len<=limit)
+        len+= sprintf(buf+len, "\nLinux OS %s version %s\n"\
+			       "Avalanche SOC Version: 0x%x operating in %s mode\n"\
+			       "Cpu Frequency: %u MHZ\nSystem Bus frequency: %u MHZ\n\n", 
+					PSP_NAME, PSP_VERSION, 
+					avalanche_get_chip_version_info(), cache_mode[cache_index],
+					cpu_freq/1000000, 2*avalanche_get_vbus_freq()/1000000);
+    
+    return (len);
+}
+
+
+int avalanche_proc_init(void)
+{
+    struct proc_dir_entry *avalanche_proc_root;
+
+    avalanche_proc_root = proc_mkdir("avalanche",NULL);
+    if(!avalanche_proc_root)
+        return -ENOMEM;
+
+    create_proc_read_entry("avalanche/base_psp_version", 0, NULL, avalanche_p_read_base_psp_version, NULL);
+
+   /* Create other proc entries */
+    return (0);
+}
+fs_initcall(avalanche_proc_init);
+
+int setup_unified_secondary_interrupt(void)
+{
+    if (request_irq(LNXINTNUM(AVALANCHE_UNIFIED_SECONDARY_INT), 
+                            avalanche_unified_secondary_irq_handler, 
+                            SA_INTERRUPT, "Avalanche Unified Secondary",
+                            NULL) != 0)
+    {
+        printk(KERN_ERR "Failed to setup handler for unified secondary interrupt\n");
+        return -1; 
+    }
+    return 0;
+}
+late_initcall(setup_unified_secondary_interrupt);
+
+const char *get_system_type(void)
+{
+	return "Texas Instruments BroadBand SoC";
+}
+
+struct serial_port_dfns 
+{
+    unsigned int irq;
+    unsigned int iomem_base;
+};
+
+static struct serial_port_dfns serial_port_dfns[] = {
+	    SERIAL_PORT_DFNS /* defined in asm/serial.h */
+};
+
+int __init ti_avalanche_setup(void)
+{
+	struct uart_port av_serial[CONFIG_AVALANCHE_NUM_SER_PORTS];
+    struct uart_port *console_port = NULL;
+    int i;
+
+
+	board_time_init = mips_time_init;		 
+	board_timer_setup = mips_timer_setup;
+	
+	/* Initialize the platform first up */
+    avalanche_soc_platform_init();
+
+#ifdef CONFIG_SERIAL_8250
+
+	memset(&av_serial, 0, sizeof(av_serial));
+
+    for ( i = 0; i < CONFIG_AVALANCHE_NUM_SER_PORTS; i++)
+    {
+	    av_serial[i].line		= i;
+	    av_serial[i].irq		= LNXINTNUM(serial_port_dfns[i].irq);
+	    av_serial[i].flags		= STD_COM_FLAGS;
+	    av_serial[i].uartclk	= avalanche_get_vbus_freq();
+	    av_serial[i].iotype	    = 4; /* default to "unknown". This works best */
+	    av_serial[i].iobase	    = serial_port_dfns[i].iomem_base;
+	    av_serial[i].regshift	= 2;
+        av_serial[i].type       = PORT_16550A;
+   
+        /* skip if this is the console port */ 
+        if(CONFIG_AVALANCHE_CONSOLE_PORT == i)
+        {
+            console_port = &av_serial[i];            
+            continue;
+        }
+        		
+	    if (early_serial_setup(&av_serial[i]) != 0) 
+	    {
+	        printk(KERN_ERR"call to early_serial_setup on port %d failed.\n", i);		
+	    }
+    }
+	if (early_serial_setup(console_port) != 0) 
+	{
+	    printk(KERN_ERR"call to early_serial_setup on port %d failed.\n", i);
+    }
+
+#endif
+    mips_reboot_setup();
+	return 0;
+}
+
+early_initcall(ti_avalanche_setup);
+
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_intc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_intc.c
@@ -0,0 +1,581 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/proc_fs.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/mach-avalanche/avalanche_intc.h>
+#include <asm/mach-avalanche/pal.h>
+#include <asm/gdb-stub.h>
+
+extern irq_desc_t irq_desc [NR_IRQS];
+
+struct avalanche_ictrl_regs         *avalanche_hw0_icregs;  
+struct avalanche_exctrl_regs        *avalanche_hw0_ecregs;  
+struct avalanche_ipace_regs         *avalanche_hw0_ipaceregs;
+struct avalanche_channel_int_number *avalanche_hw0_chregs;  
+
+extern asmlinkage void mipsIRQ(void);
+
+#define INTERRUPT_PANIC(irq) \
+        printk("whee, invalid irq_nr %d at %s line %d\n", \
+                                            (irq), __FILE__, __LINE__);\
+        panic("IRQ, you lose...");
+
+typedef void (*AV_VLYNQ_DISABLE_IRQ_FN)(unsigned int);
+typedef void (*AV_VLYNQ_EN_IRQ_FN)(unsigned int);
+typedef int  (*AV_VLYNQ_SET_IRQ_POL_FN)(unsigned int, unsigned int);
+typedef int  (*AV_VLYNQ_GET_IRQ_POL_FN)(unsigned int);
+typedef int  (*AV_VLYNQ_SET_IRQ_TYPE_FN)(unsigned int, unsigned int);
+typedef int  (*AV_VLYNQ_GET_IRQ_TYPE_FN)(unsigned int);
+typedef int  (*AV_VLYNQ_REQ_IRQ_FN)(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		                   unsigned long irqflags, const char*, void*);
+typedef void (*AV_VLYNQ_FREE_IRQ_FN)(unsigned int, void*);
+typedef int  (*AV_VLYNQ_IRQ_LIST_FN)(char*);
+
+static AV_VLYNQ_SET_IRQ_POL_FN  p_av_vlynq_set_irq_pol_fn  = NULL;
+static AV_VLYNQ_GET_IRQ_POL_FN  p_av_vlynq_get_irq_pol_fn  = NULL;
+static AV_VLYNQ_REQ_IRQ_FN      p_av_vlynq_req_irq_fn      = NULL;
+static AV_VLYNQ_FREE_IRQ_FN     p_av_vlynq_free_irq_fn     = NULL;
+static AV_VLYNQ_SET_IRQ_TYPE_FN p_av_vlynq_set_irq_type_fn = NULL;
+static AV_VLYNQ_GET_IRQ_TYPE_FN p_av_vlynq_get_irq_type_fn = NULL;
+
+static unsigned long line_to_channel[AVINTNUM(AVALANCHE_INT_END_PRIMARY)];
+
+static void disable_mips_irq(unsigned int irq_nr)
+{
+    unsigned long flags;
+    unsigned long int_bit=0;
+
+    if(unlikely((irq_nr < 0) || (irq_nr >= MIPS_EXCEPTION_OFFSET)))
+    {
+        INTERRUPT_PANIC(irq_nr);
+    }
+
+    save_and_cli(flags);
+
+    int_bit = read_c0_status() & ~(1 << (8+irq_nr)); 
+    change_c0_status(ST0_IM, int_bit);
+    
+    restore_flags(flags);
+}
+
+static inline void disable_avalanche_intc_irq(unsigned int irq_nr)
+{
+    unsigned long flags;
+    unsigned long chan_nr=0;
+
+    save_and_cli(flags);
+
+    irq_nr = AVINTNUM(irq_nr);
+
+    if(irq_nr >= AVALANCHE_INT_END_PRIMARY_REG2) {
+        chan_nr = irq_nr;
+    } else {
+        chan_nr = line_to_channel[irq_nr];
+    }
+
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
+        avalanche_hw0_icregs->intecr1 = (1 << chan_nr);
+    } /* primary interrupt #'s 32-39 */
+    else if ((chan_nr <  AVALANCHE_INT_END_PRIMARY_REG2) &&
+         (chan_nr >= AVALANCHE_INT_END_PRIMARY_REG1))
+    {
+        avalanche_hw0_icregs->intecr2 = 
+                (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+    } else  {/* secondary interrupt #'s 0-31 */
+        avalanche_hw0_ecregs->exiecr = 
+                (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG2));
+    }
+
+    restore_flags(flags);
+}
+
+static void enable_mips_irq(unsigned int irq_nr)
+{
+    unsigned long flags;
+    unsigned long int_bit=0;
+
+    if((irq_nr < 0) || irq_nr >= MIPS_EXCEPTION_OFFSET) {
+       INTERRUPT_PANIC(irq_nr); 
+    }
+
+    save_and_cli(flags);
+
+    int_bit = read_c0_status();
+    change_c0_status(ST0_IM, int_bit | (1<<(8+irq_nr))); 
+
+    restore_flags(flags);
+}
+
+static inline void enable_avalanche_intc_irq(unsigned int irq_nr)
+{
+    unsigned int flags;
+    unsigned long chan_nr=0;
+
+    save_and_cli(flags);
+
+    irq_nr = AVINTNUM(irq_nr);
+
+    if(irq_nr >= AVALANCHE_INT_END_PRIMARY_REG2)
+        chan_nr = irq_nr;
+    else
+        chan_nr = line_to_channel[irq_nr];
+
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1)    
+    {
+        avalanche_hw0_icregs->intesr1 = 1 << chan_nr;
+    } /* primary interrupt #'s 32 throuth 39 */
+    else if ((chan_nr < AVALANCHE_INT_END_PRIMARY_REG2) &&
+        (chan_nr >= AVALANCHE_INT_END_PRIMARY_REG1))
+    {
+        avalanche_hw0_icregs->intesr2 = 
+            (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+    } 
+    else /* secondary interrupt #'s 0-31 */ 
+    {
+        avalanche_hw0_ecregs->exiesr = 
+            (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG2));
+    }
+
+    restore_flags(flags);
+}
+
+static void end_avalanche_intc_irq(unsigned int irq) \
+{   
+    if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+        enable_avalanche_intc_irq(irq);
+}
+
+static void end_mips_irq(unsigned int irq) \
+{   
+    if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+        enable_mips_irq(irq);
+}
+
+static unsigned int startup_avalanche_intc_irq(unsigned int irq)
+{
+    enable_avalanche_intc_irq(irq);
+    return 0; 
+}
+
+static unsigned int startup_mips_irq(unsigned int irq)
+{
+    enable_mips_irq(irq);
+    return 0; 
+}
+
+#define startup_avalanche_primary_irq       startup_avalanche_intc_irq
+#define shutdown_avalanche_primary_irq      disable_avalanche_intc_irq
+#define enable_avalanche_primary_irq        enable_avalanche_intc_irq
+#define disable_avalanche_primary_irq       disable_avalanche_intc_irq
+#define mask_and_ack_avalanche_primary_irq  disable_avalanche_intc_irq
+#define end_avalanche_primary_irq           end_avalanche_intc_irq
+
+static struct hw_interrupt_type avalanche_primary_irq_type = {
+    "[INTC Primary]",
+    startup_avalanche_primary_irq,
+    shutdown_avalanche_primary_irq,
+    enable_avalanche_primary_irq,
+    disable_avalanche_primary_irq,
+    mask_and_ack_avalanche_primary_irq,
+    end_avalanche_primary_irq,
+    NULL
+};
+
+#define shutdown_mips_irq      disable_mips_irq
+#define mask_and_ack_mips_irq  disable_mips_irq
+
+static struct hw_interrupt_type mips_irq_type = {
+    "[MIPS]",
+    startup_mips_irq,
+    shutdown_mips_irq,
+    enable_mips_irq,
+    disable_mips_irq,
+    mask_and_ack_mips_irq,
+    end_mips_irq,
+    NULL
+};
+
+#define startup_avalanche_secondary_irq       startup_avalanche_intc_irq
+#define shutdown_avalanche_secondary_irq      disable_avalanche_intc_irq
+#define enable_avalanche_secondary_irq        enable_avalanche_intc_irq
+#define disable_avalanche_secondary_irq       disable_avalanche_intc_irq
+#define mask_and_ack_avalanche_secondary_irq  disable_avalanche_intc_irq
+#define end_avalanche_secondary_irq           end_avalanche_intc_irq
+
+static struct hw_interrupt_type avalanche_secondary_irq_type = {
+    "[INTC Secondary]",
+    startup_avalanche_secondary_irq,
+    shutdown_avalanche_secondary_irq,
+    enable_avalanche_secondary_irq,
+    disable_avalanche_secondary_irq,
+    mask_and_ack_avalanche_secondary_irq,
+    end_avalanche_secondary_irq,
+    NULL
+};
+
+void arch_free_irq_hook(unsigned int irq, void *dev_id)
+{
+    if(irq >= AVALANCHE_INTC_END) {
+        if(p_av_vlynq_free_irq_fn) {
+            p_av_vlynq_free_irq_fn(irq, dev_id);
+        }    
+    }
+}
+
+int arch_req_irq_hook(unsigned int irq, 
+        irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		unsigned long irqflags, const char * devname, void *dev_id)
+{
+    if(irq >= AVALANCHE_INTC_END) {
+        if(p_av_vlynq_req_irq_fn) {
+           return p_av_vlynq_req_irq_fn(irq, handler, irqflags, devname, dev_id);
+        }    
+    }
+    return 0;
+}
+
+
+irqreturn_t avalanche_unified_secondary_irq_handler
+(
+    int unified_sec_irq,
+    void * dev_id,
+    struct pt_regs *regs
+)
+{
+    int irq = AVALANCHE_INT_END_PRIMARY;
+    unsigned int status = avalanche_hw0_ecregs->exsr;
+
+    /* clear secondary interrupt */
+    avalanche_hw0_ecregs->excr = status;
+
+    /* service all the secondary interrupts one-by-one */
+    while(status)
+    {
+        if(status & 0x1)
+        {
+            do_IRQ(irq, regs);
+        }
+        status >>= 1;
+        irq++;
+    }
+
+    return IRQ_RETVAL(1);
+}
+
+static inline void __init avalanche_init_intc_hw(void)
+{
+    avalanche_hw0_icregs = 
+        (struct avalanche_ictrl_regs *)AVALANCHE_ICTRL_REGS_BASE;
+    avalanche_hw0_ecregs = 
+        (struct avalanche_exctrl_regs *)AVALANCHE_ECTRL_REGS_BASE;
+    avalanche_hw0_chregs = 
+        (struct avalanche_channel_int_number *)AVALANCHE_CHCTRL_REGS_BASE;
+
+    avalanche_hw0_icregs->intecr1 = 0xffffffff;    
+    avalanche_hw0_icregs->intcr1  = 0xffffffff;
+    avalanche_hw0_icregs->intecr2 = 0xff;
+    avalanche_hw0_icregs->intcr2  = 0xff;          
+    avalanche_hw0_ecregs->exiecr  = 0xffffffff;    
+    avalanche_hw0_ecregs->excr    = 0xffffffff;    
+}
+
+void __init arch_init_irq(void)
+{
+    int i,j;
+
+    avalanche_init_intc_hw();
+    for(i = MIPS_EXCEPTION_OFFSET, j = 0; 
+        i < AVALANCHE_INT_END_PRIMARY; i++, j++)
+    {
+        avalanche_int_set(j,i);
+    }
+
+    set_except_vector(0, mipsIRQ);
+
+    for (i = 0; i < AVALANCHE_INT_END; i++)
+    {
+        irq_desc[i].status    = IRQ_DISABLED | IRQ_PER_CPU;
+        irq_desc[i].action    = 0;
+        irq_desc[i].depth    = 1;
+    
+        if(i < MIPS_EXCEPTION_OFFSET) {
+            irq_desc[i].handler    = &mips_irq_type;
+        } else if (i < AVALANCHE_INT_END_PRIMARY) {
+            irq_desc[i].handler    = &avalanche_primary_irq_type;
+        } else if (i < AVALANCHE_INT_END_SECONDARY) {
+            irq_desc[i].handler    = &avalanche_secondary_irq_type;
+        }
+    }
+}
+
+void avalanche_hw0_irqdispatch(struct pt_regs *regs)
+{
+    int chan_nr=0, irq=0;
+    unsigned int priority_irq_info = avalanche_hw0_icregs->pintir;
+
+    irq     = (priority_irq_info >> 16) & 0x3F;
+    chan_nr = priority_irq_info & 0x3F;
+
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1) {
+        avalanche_hw0_icregs->intcr1 = (1 << chan_nr);
+    } else if (chan_nr < AVALANCHE_INT_END_PRIMARY_REG2 ) {
+            avalanche_hw0_icregs->intcr2 = 1 << 
+                            (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1);
+    } else {
+        return;
+    }
+    do_IRQ(LNXINTNUM(irq), regs);
+
+    return;
+}
+
+void avalanche_int_set(int channel, int line)
+{
+    if(line <  MIPS_EXCEPTION_OFFSET ||
+       line >= AVALANCHE_INT_END_PRIMARY ||
+       line == LNXINTNUM(AVALANCHE_UNIFIED_SECONDARY_INT)||
+       channel == 0)        
+        return;
+
+  line = AVINTNUM(line);
+
+
+  avalanche_hw0_chregs->cintnr[channel] = line;  
+  line_to_channel[line] = channel; 
+}
+
+int avalanche_intr_polarity_set(unsigned int irq_nr, unsigned long polarity_val)
+{
+    unsigned long flags;
+    unsigned long chan_nr=0;
+
+    if(irq_nr  <  MIPS_EXCEPTION_OFFSET ||
+        irq_nr  >= AVALANCHE_INT_END ||
+        (irq_nr >= AVALANCHE_INT_END_PRIMARY && 
+        irq_nr <  AVALANCHE_INT_END_SECONDARY))
+    {
+        printk("whee, invalid irq_nr %d\n", irq_nr);
+        printk("Not one of the primary avalanche interrupts\n");
+        panic("IRQ, you lose...");
+        return(-1);
+    }
+
+    if(polarity_val > 1)
+    {
+        printk("Not a valid polarity value.\n");
+        return(-1);
+    }
+
+
+    if(irq_nr >= AVALANCHE_INTC_END)
+    {
+        if(p_av_vlynq_set_irq_pol_fn)
+            p_av_vlynq_set_irq_pol_fn(irq_nr, polarity_val);
+	    goto ret_from_set_polarity;
+    }
+
+    irq_nr = AVINTNUM(irq_nr);
+
+    chan_nr = line_to_channel[irq_nr];
+
+    save_and_cli(flags);
+
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1)
+    {
+        if(polarity_val)
+            avalanche_hw0_icregs->intpolr1 |=  (1 << chan_nr);
+        else
+        avalanche_hw0_icregs->intpolr1 &= ~(1 << chan_nr);
+    }
+    else
+    {
+        if(polarity_val)
+            avalanche_hw0_icregs->intpolr2 |=
+            (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+        else
+            avalanche_hw0_icregs->intpolr2 &=
+            ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+    }
+
+    restore_flags(flags);
+
+ret_from_set_polarity:
+    return(0);
+}
+
+
+int avalanche_intr_polarity_get(unsigned int irq_nr)
+{
+    unsigned long flags;
+    unsigned long chan_nr=0;
+    int           value = 0; 
+
+    if(irq_nr  <  MIPS_EXCEPTION_OFFSET ||
+       irq_nr  >= AVALANCHE_INT_END ||
+       (irq_nr >= AVALANCHE_INT_END_PRIMARY && 
+    irq_nr <  AVALANCHE_INT_END_SECONDARY))
+    {
+        printk("whee, invalid irq_nr %d\n", irq_nr);
+        printk("Not one of the primary avalanche interrupts\n");
+        panic("IRQ, you lose...");
+        return(-1);
+    }
+
+    if(irq_nr >= AVALANCHE_INTC_END)
+    {
+        if(p_av_vlynq_get_irq_pol_fn)
+            value = p_av_vlynq_get_irq_pol_fn(irq_nr);
+
+    	goto ret_from_get_polarity;
+    }
+
+    irq_nr = AVINTNUM(irq_nr);
+
+    chan_nr = line_to_channel[irq_nr];
+
+    save_and_cli(flags);
+
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1)
+    {
+        value = avalanche_hw0_icregs->intpolr1;
+        value = (value >> chan_nr) & 0x1;
+    }
+    else
+    {
+        value = avalanche_hw0_icregs->intpolr2;
+        value = (value >> (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1)) & 0x1;
+    }
+
+    restore_flags(flags);
+
+ret_from_get_polarity:
+    return(value);
+}
+
+int avalanche_intr_type_set(unsigned int irq_nr, unsigned long type_val)
+{
+    unsigned long flags;
+    unsigned long chan_nr=0;
+                                                                                               
+    if(irq_nr  <  MIPS_EXCEPTION_OFFSET ||
+       irq_nr  >= AVALANCHE_INT_END ||
+       (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
+    irq_nr <  AVALANCHE_INT_END_SECONDARY))
+    {
+        printk("whee, invalid irq_nr %d\n", irq_nr);
+    panic("IRQ, you lose...");
+    return(-1);
+    }
+                                                                                               
+    if(type_val > 1)
+    {
+        printk("Not a valid polarity value.\n");
+    return(-1);
+    }
+    if(irq_nr >= AVALANCHE_INTC_END)
+    {
+        if(p_av_vlynq_set_irq_type_fn)
+            p_av_vlynq_set_irq_type_fn(irq_nr, type_val);
+                                                                                               
+        goto ret_from_set_type;
+    }
+                                                                                               
+    irq_nr = AVINTNUM(irq_nr);
+                                                                                               
+    chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+                                                                                               
+    save_and_cli(flags);
+                                                                                               
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1)
+    {
+        if(type_val)
+            avalanche_hw0_icregs->inttypr1 |=  (1 << chan_nr);
+        else
+        avalanche_hw0_icregs->inttypr1 &= ~(1 << chan_nr);
+    }
+    else
+    {
+    if(type_val)
+        avalanche_hw0_icregs->inttypr2 |=
+        (1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+    else
+        avalanche_hw0_icregs->inttypr2 &=
+        ~(1 << (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1));
+    }
+                                                                                               
+    restore_flags(flags);
+                                                                                               
+ret_from_set_type:
+    return(0);
+}
+
+int avalanche_intr_type_get(unsigned int irq_nr)
+{
+	unsigned long flags;
+	unsigned long chan_nr=0;
+	int value = 0;
+                                                                                               
+    if(irq_nr  <  MIPS_EXCEPTION_OFFSET ||
+       irq_nr  >= AVALANCHE_INT_END ||
+       (irq_nr >= AVALANCHE_INT_END_PRIMARY &&
+    irq_nr <  AVALANCHE_INT_END_SECONDARY))
+    {
+        printk("whee, invalid irq_nr %d\n", irq_nr);
+    panic("IRQ, you lose...");
+    return(-1);
+    }
+                                                                                               
+    if(irq_nr >= AVALANCHE_INTC_END)
+    {
+        if(p_av_vlynq_get_irq_type_fn)
+            value = p_av_vlynq_get_irq_type_fn(irq_nr);
+            goto ret_from_get_type;
+    }
+                                                                                               
+    irq_nr = AVINTNUM(irq_nr);
+                                                                                               
+    chan_nr = line_to_channel[AVINTNUM(irq_nr)];
+                                                                                               
+    save_and_cli(flags);
+                                                                                               
+    if(chan_nr < AVALANCHE_INT_END_PRIMARY_REG1)
+    {
+        value = avalanche_hw0_icregs->inttypr1;
+        value = (value >> chan_nr) & 0x1;
+    }
+    else
+    {
+        value = avalanche_hw0_icregs->inttypr2;
+        value = (value >> (chan_nr - AVALANCHE_INT_END_PRIMARY_REG1)) & 0x1;
+    }
+                                                                                               
+    restore_flags(flags);
+                                                                                               
+ret_from_get_type:
+return value;
+}
+
+EXPORT_SYMBOL(avalanche_intr_polarity_set);
+EXPORT_SYMBOL(avalanche_intr_polarity_get);
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_misc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/avalanche_misc.c
@@ -0,0 +1,234 @@
+#include <asm/mach-avalanche/pal.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+static unsigned int avalanche_vbus_freq;
+
+void avalanche_set_vbus_freq(unsigned int new_vbus_freq)
+{
+    avalanche_vbus_freq = new_vbus_freq;
+}
+
+unsigned int avalanche_get_vbus_freq(void)
+{
+    return(avalanche_vbus_freq);
+}
+
+unsigned int avalanche_get_chip_version_info(void)
+{
+    return(*(volatile unsigned int*)AVALANCHE_CVR);
+}
+
+int avalanche_is_cpmac_on_vbus(void)
+{
+    if(0x00b != (*((volatile unsigned int*)AVALANCHE_CVR) & 0xffff))
+        return (1); /* The SoC which does not have cpmac on Vbus is Apex */
+    else 
+        return (0);
+}
+
+unsigned int avalanche_chip_version_info(void)
+{
+    return (*(volatile unsigned int*)AVALANCHE_CVR);
+}
+
+AVALANCHE_CPU_TYPE_T avalanche_get_cpu_type(void)
+{
+    volatile unsigned int cvr;
+    volatile unsigned int cvr2;
+    AVALANCHE_CPU_TYPE_T cpu_type;
+   
+    cpu_type =  CPU_UNIDENT;
+   
+    cvr =  avalanche_chip_version_info() & 0xffff;
+   
+    REG32_WRITE(AVALANCHE_CVR, 0xffff);
+   
+    cvr2 = (REG32_DATA(AVALANCHE_CVR) & 0xffff);
+   
+    if(cvr == cvr2)
+    {
+        switch(cvr)
+        {
+            case CPU_AVALANCHE_I:
+            case 0xffff:   /* This is because of the Avalanche I errata */
+                cpu_type = CPU_AVALANCHE_I;
+            break;
+            
+            case CPU_AVALANCHE_D:
+            case CPU_PUMA:
+            case CPU_PUMAS:
+            case CPU_SANGAM:
+            case CPU_TITAN:
+            case CPU_APEX:
+                cpu_type = cvr;
+            break;
+         
+            default:
+                cpu_type = CPU_UNIDENT;
+        }
+    }
+    else
+    {
+        cpu_type = CPU_AVALANCHE_I;
+    }
+   
+    return cpu_type;    
+}
+
+const char* avalanche_get_cpu_name(AVALANCHE_CPU_TYPE_T cpu_type)
+{
+    char* name = NULL;
+    static char* cpu_name[]=
+    {
+       "Unknown"    ,   /* 0 */ 
+       "Avalanche I",   /* 1 */ 
+       "Avalanche D",   /* 2 */ 
+       "Puma"       ,   /* 3 */ 
+       "Puma S"     ,   /* 4 */
+       "Sangam"     ,   /* 5 */
+       "Titan"      ,   /* 6 */
+       "Apex"       ,   /* 7 */
+       
+       /* TODO: Add more CPUs here */
+       0
+    };
+    
+    switch(cpu_type)
+    {
+        case CPU_AVALANCHE_I: 
+            name = cpu_name[1];  
+        break;
+
+        case CPU_AVALANCHE_D: 
+            name = cpu_name[2];  
+        break;
+
+        case CPU_PUMA : 
+            name = cpu_name[3];
+        break;
+
+        case CPU_PUMAS: 
+            name = cpu_name[4];  
+        break;
+
+        case CPU_SANGAM: 
+            name = cpu_name[5];  
+        break;        
+        
+        case CPU_TITAN: 
+            name = cpu_name[6];  
+        break;               
+        
+        case CPU_APEX: 
+            name = cpu_name[7];  
+        break;                       
+
+        case CPU_UNIDENT:
+        default:        
+            name = cpu_name[0];
+    }
+    
+    return name;
+}
+
+SET_MDIX_ON_CHIP_FN_T p_set_mdix_on_chip_fn = NULL;
+int avalanche_set_mdix_on_chip(unsigned int base_addr, unsigned int operation)
+{
+    if(p_set_mdix_on_chip_fn)
+        return (p_set_mdix_on_chip_fn(base_addr, operation));
+    else
+        return (-1);
+}
+
+unsigned int avalanche_is_mdix_on_chip(void)
+{
+    return (p_set_mdix_on_chip_fn ? 1:0);
+}
+
+int avalanche_sysprobe_and_prep (unsigned int version, unsigned int base_addr, void *param)
+{
+        int i = 0;
+        BOARD_ID board_variant = avalanche_get_board_variant();
+        MOD_INFO_T *p = &(soc[board_variant].modules[0]);
+
+        for(i = 0; i < MAX_MODULES; i++, p++)
+        {
+            if ((version == p->version) && (base_addr == p->base_addr))
+            {
+                version = p->version;
+                avalanche_device_prepare(version, base_addr, board_variant, param);
+                return 0;
+            }
+        }
+
+        return (-1);
+}
+
+#define AVALANCHE_GLOBAL_POWER_DOWN_MASK	0x3FFFFFFF /* bit 31, 30 masked */
+#define AVALANCHE_GLOBAL_POWER_DOWN_BIT		30         /* shift to bit 30, 31 */
+
+REMOTE_VLYNQ_DEV_RESET_CTRL_FN p_remote_vlynq_dev_reset_ctrl = NULL;
+
+void avalanche_set_global_powermode(PAL_SYS_SYSTEM_POWER_MODE_T power_mode)
+{
+	volatile unsigned int *power_status_reg = (unsigned int*)AVALANCHE_POWER_CTRL_PDCR;
+                                                                                                
+	*power_status_reg &= AVALANCHE_GLOBAL_POWER_DOWN_MASK;
+	*power_status_reg |= ( power_mode << AVALANCHE_GLOBAL_POWER_DOWN_BIT);
+}
+
+void avalanche_reset_ctrl(unsigned int module_reset_bit, PAL_SYS_RESET_CTRL_T reset_ctrl)
+{
+    volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+
+    if(module_reset_bit >= 32 && module_reset_bit < 64)
+	{
+        return;
+	}
+
+    if(module_reset_bit >= 64)
+    {
+        if(p_remote_vlynq_dev_reset_ctrl)
+		{
+            return(p_remote_vlynq_dev_reset_ctrl(module_reset_bit - 64, reset_ctrl));
+		}
+		else
+		{
+            return;
+		}
+    }
+    
+    if(reset_ctrl == OUT_OF_RESET)
+	{
+        *reset_reg |= 1 << module_reset_bit;
+	}
+    else
+	{
+        *reset_reg &= ~(1 << module_reset_bit);
+	}
+}
+
+PAL_SYS_RESET_CTRL_T avalanche_get_reset_status(unsigned int module_reset_bit)
+{
+    volatile unsigned int *reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_PRCR;
+
+    return (((*reset_reg) & (1 << module_reset_bit)) ? OUT_OF_RESET : IN_RESET );
+}
+
+
+void avalanche_system_reset(PAL_SYS_SYSTEM_RST_MODE_T mode)
+{
+    volatile unsigned int *sw_reset_reg = (unsigned int*) AVALANCHE_RST_CTRL_SWRCR;
+    *sw_reset_reg =  mode;
+}
+
+#define AVALANCHE_RST_CTRL_RSR_MASK 0x3
+
+PAL_SYS_SYSTEM_RESET_STATUS_T avalanche_get_last_reset_status()
+{
+    volatile unsigned int *sys_reset_status = (unsigned int*) AVALANCHE_RST_CTRL_RSR;
+
+    return ( (PAL_SYS_SYSTEM_RESET_STATUS_T) (*sys_reset_status & AVALANCHE_RST_CTRL_RSR_MASK) );
+}
+
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_generic/Makefile
@@ -0,0 +1,21 @@
+#
+# Carsten Langgaard, carstenl@mips.com
+# Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+#
+# This program is free software; you can distribute it and/or modify it
+# under the terms of the GNU General Public License (Version 2) as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+#
+
+EXTRA_CFLAGS += -I$(TOPDIR)/include/asm/mach-avalanche/generic
+
+obj-y := avalanche_generic_setup.o avalanche_misc.o avalanche_intc.o
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/env.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/env.c
@@ -0,0 +1,886 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ * Copyright (C) 2006 Montavista Software Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+	
+#include "flashop.h"     
+
+#define MAX_ENV_ENTRY 			(block_size/FLASH_ENV_ENTRY_SIZE)
+	
+unsigned int strlen(const char *str);
+int strcmp(const char *A, const char *B);
+char *strcpy(char *DST, const char *SRC);
+int  EnvInit(void);
+char *env_get_base(unsigned int *block_size);
+int  sys_unsetenv(const char *);
+int  sys_setenv(const char *, const char *);
+char *sys_getenv(const char *);
+void sh_printenv(void);
+void init_env(void);
+int sys_defragenv(void);
+int sys_initenv(void);
+char* sys_getienv(int var_num);
+char* sys_getivar (int var_num);
+int get_envstring(int index, char *buffer);
+	
+typedef struct t_env_var {
+	char      var;
+	char  *   val;
+}t_env_var;
+	
+#ifdef FTP_SERVER_SUPPORT
+#ifndef ENV_SPACE_SIZE /* Should be defined by bootcfg.mak file */
+#define ENV_SPACE_SIZE      (10 * 1024)
+#endif
+#endif
+	
+#define AUTO_DEFRAG_ENVIRONMENT     1
+	
+typedef enum ENV_VARS {
+	env_vars_start = 0,
+	CPUFREQ,
+	MEMSZ,
+	FLASHSZ,
+	MODETTY0,
+	MODETTY1,
+	PROMPT,
+	BOOTCFG,
+	HWA_0,
+#if !defined (AVALANCHE) || defined(TNETC401B)     
+	HWA_1,
+#endif        
+#if !defined(TNETV1020_BOARD)        
+	HWA_RNDIS,
+#endif    
+#if defined (TNETD73XX_BOARD)    
+	HWA_3,
+#endif    
+	IPA,
+	IPA_SVR,
+	BLINE_MAC0,
+#if !defined (AVALANCHE) || defined(TNETC401B)         
+	BLINE_MAC1,
+#endif    
+#if !defined(TNETV1020_BOARD)        
+	BLINE_RNDIS,
+#endif    
+#if defined (TNETD73XX_BOARD)    
+	BLINE_ATM,
+#endif
+#if !defined(TNETV1020_BOARD)            
+	USB_PID,
+	USB_VID,
+	USB_EPPOLLI,
+#endif    
+	IPA_GATEWAY,
+	SUBNET_MASK,
+#if defined (TNETV1050_BOARD)    
+	BLINE_ESWITCH,
+#endif    
+#if !defined(TNETV1020_BOARD)            
+	USB_SERIAL,
+	HWA_HRNDIS,      /* Host (PC) side RNDIS address */
+#endif    
+	REMOTE_USER,
+	REMOTE_PASS,
+	REMOTE_DIR,
+	SYSFREQ,
+	LINK_TIMEOUT,
+#ifndef AVALANCHE     /* Avalanche boards use only one mac port */
+	MAC_PORT,
+#endif    
+	PATH,
+	HOSTNAME,
+#ifdef WLAN
+	 HW_REV_MAJOR,
+	 HW_REV_MINOR,
+	 HW_PATCH,
+	 SW_PATCH,
+	 SERIAL_NUMBER,
+#endif
+	TFTPCFG,
+#if defined (TNETV1050_BOARD)    
+	HWA_ESWITCH,
+#endif
+	BUILD_OPS,
+	TFTP_FO_FNAME,
+	TFTP_FO_PORTS,
+	CONSOLE_STATE,
+	MIPSFREQ,
+	/*
+	 * Add new env variables here.
+	 * NOTE: New environment variables should always be placed at the end, ie 
+	 *       just before env_vars_end.
+	 */
+		
+	env_vars_end
+} ENV_VARS;
+	
+typedef struct ENVDESC {
+	ENV_VARS   idx;
+	const char      *nm;
+	char      *alias;
+} ENVDESC;
+	
+#define ENVSTR(x)         #x
+#define _ENV_ENTRY(x)  {x, ENVSTR(x), 0}
+ENVDESC env_ns[] = {
+	_ENV_ENTRY(env_vars_start), /* start. */
+	_ENV_ENTRY(CPUFREQ),
+	_ENV_ENTRY(MEMSZ),
+	_ENV_ENTRY(FLASHSZ),
+	_ENV_ENTRY(MODETTY0),
+	_ENV_ENTRY(MODETTY1),
+	_ENV_ENTRY(PROMPT),
+	_ENV_ENTRY(BOOTCFG),
+	_ENV_ENTRY(HWA_0),
+#if !defined (AVALANCHE) || defined(TNETC401B)    
+	_ENV_ENTRY(HWA_1),
+#endif
+#if !defined(TNETV1020_BOARD)        
+	_ENV_ENTRY(HWA_RNDIS),
+#endif    
+#if defined (TNETD73XX_BOARD)    
+	_ENV_ENTRY(HWA_3),
+#endif    
+	_ENV_ENTRY(IPA),
+	_ENV_ENTRY(IPA_SVR),
+	_ENV_ENTRY(IPA_GATEWAY),
+	_ENV_ENTRY(SUBNET_MASK),
+	_ENV_ENTRY(BLINE_MAC0),
+#if !defined (AVALANCHE) || defined(TNETC401B)    
+	_ENV_ENTRY(BLINE_MAC1),
+#endif
+#if !defined(TNETV1020_BOARD)    
+	_ENV_ENTRY(BLINE_RNDIS),
+#endif
+#if defined (TNETD73XX_BOARD)    
+	_ENV_ENTRY(BLINE_ATM),
+#endif
+#if !defined(TNETV1020_BOARD)            
+	_ENV_ENTRY(USB_PID),
+	_ENV_ENTRY(USB_VID),
+	_ENV_ENTRY(USB_EPPOLLI),
+#endif
+#if defined (TNETV1050_BOARD)    
+	_ENV_ENTRY(BLINE_ESWITCH),
+#endif
+#if !defined(TNETV1020_BOARD)            
+	_ENV_ENTRY(USB_SERIAL),
+	_ENV_ENTRY(HWA_HRNDIS),
+#endif    
+	_ENV_ENTRY(REMOTE_USER),
+	_ENV_ENTRY(REMOTE_PASS),
+	_ENV_ENTRY(REMOTE_DIR),
+	_ENV_ENTRY(SYSFREQ),
+	_ENV_ENTRY(LINK_TIMEOUT),
+#ifndef AVALANCHE       /* Avalanche boards use only one mac port */
+	_ENV_ENTRY(MAC_PORT),
+#endif    
+	_ENV_ENTRY(PATH),
+	_ENV_ENTRY(HOSTNAME),
+#ifdef WLAN
+	_ENV_ENTRY(HW_REV_MAJOR),
+	_ENV_ENTRY(HW_REV_MINOR),
+	_ENV_ENTRY(HW_PATCH),
+	_ENV_ENTRY(SW_PATCH),
+	_ENV_ENTRY(SERIAL_NUMBER),
+#endif
+	_ENV_ENTRY(TFTPCFG),
+#if defined (TNETV1050_BOARD)    
+	_ENV_ENTRY(HWA_ESWITCH),    
+#endif
+	_ENV_ENTRY(BUILD_OPS),
+	_ENV_ENTRY(TFTP_FO_FNAME),
+	_ENV_ENTRY(TFTP_FO_PORTS),
+	_ENV_ENTRY(CONSOLE_STATE),
+	_ENV_ENTRY(MIPSFREQ),   
+	/*
+	 * Add new entries below this.
+	 */
+	/* Adam2 environment name alias. Temporary. */
+	{IPA,     "my_ipaddress"},
+	{CPUFREQ, "cpufrequency"},    
+	{SYSFREQ, "sysfrequency"}, 
+	{HWA_0,   "maca"},
+#ifndef AVALANCHE    
+	{HWA_1,   "macb"},
+#endif
+	{MEMSZ,   "memsize"},
+	
+	_ENV_ENTRY(env_vars_end) /* delimiter. */
+};
+	
+static unsigned int env_size;
+static unsigned int env_base;
+	
+/* TODO: remove this */
+t_env_var env_vars[10];
+	
+static const char envVersion[] = { "TIENV0.8" };  
+	
+static const char envErrReadOnly[] = { "Env: %s is read-only.\n" };
+	
+#define ENV_CELL_SIZE           16
+	
+/* control field decode */
+#define ENV_GARBAGE_BIT			0x01    /* Env is garbage if this bit is off */
+#define ENV_DYNAMIC_BIT			0x02    /* Env is dynamic if this bit is off */
+#define ENV_PERM_BIT            0x04    /* Env is a backup of a permanent value */
+	
+typedef struct ENV_VAR_t {
+	unsigned char   varNum;
+	unsigned char   ctrl;
+	unsigned short  chksum;
+	unsigned char   numCells;
+	unsigned char   data[ENV_CELL_SIZE - 5];    
+	/* The data section starts 
+	 * here, continues for
+	 * numCells.
+	 */
+}ENV_VAR;
+	
+	
+static unsigned int MaxEnvVarsNum;     
+static PSBL_REC* psbl_rec =  (PSBL_REC*)0x94000300;
+	
+/* Internal functions */
+int IsReadOnlyVar( const char* env_nm );
+static int IsPreDefinedVar(const char* var); 
+static ENVDESC* GetEnvDescForEnvVar(const char* var);
+static int __sys_setenv( const char *env_nm, const char *env_val, unsigned char perm );
+	
+/* Internal macros */
+#define IsEnvGarbage(var)       (((var)->ctrl & ENV_GARBAGE_BIT) == 0)
+#define IsEnvDynamic(var)       (((var)->ctrl & ENV_DYNAMIC_BIT) == 0)
+#define IsEnvPerm(var)          (((var)->ctrl & ENV_PERM_BIT) == 0)
+#define EnvGetNextBlock(var)    ((ENV_VAR*)( (char*)(var) + (var)->numCells * ENV_CELL_SIZE))
+	
+static int EnvMakeGarbage(ENV_VAR* pVar)
+{
+	int status;
+	
+	status = FWBOpen((int)&((pVar)->ctrl));
+	FWBWriteByte((int)&((pVar)->ctrl), (pVar)->ctrl & ~ENV_GARBAGE_BIT);
+	FWBClose();
+	
+	return (status == 0);
+}
+	
+char* GetEnvBaseAndSize(unsigned int* size)
+{
+	if(size != 0)
+	{
+		*size = env_size;
+	
+#ifdef ENV_SPACE_SIZE
+		if(*size > ENV_SPACE_SIZE){
+			*size = ENV_SPACE_SIZE;
+		}    
+#endif
+	}
+	
+	return( (char *) env_base);	
+}
+	
+/* returns the variable number if pre-defined, else return 0 */
+static int IsPreDefinedVar(const char* var)
+{
+	ENVDESC* env;
+	
+	if((env = GetEnvDescForEnvVar(var)) != 0) 
+		return env->idx;
+	
+	return 0;  
+}
+	
+static ENVDESC* GetEnvDescForEnvVar(const char* var)
+{
+	int ii;        
+	/* go over the list of pre-defined environment variables */
+	for (ii = env_vars_start; env_ns[ii].idx != env_vars_end; ii++) {   
+		if (strcmp(env_ns[ii].nm, var) == 0) 
+		{
+			return  &env_ns[ii];
+		}
+	
+		if(env_ns[ii].alias != 0) {
+			if (strcmp(env_ns[ii].alias, var) == 0)
+			{
+				return &env_ns[ii];
+			}			
+		}
+	}
+	return 0;
+}
+	
+static char* GetPreDefinedVarName(int index) 
+{
+	int ii;
+	
+	if ( index >= env_vars_end || index <= env_vars_start) {
+		return 0;
+	}
+	for(ii = env_vars_start; env_ns[ii].idx != env_vars_end; ii++) {
+		if(env_ns[ii].idx == index) {
+			if(env_ns[ii].alias != 0) {
+				return env_ns[ii].alias;
+			} else {                        
+				return ( char *)env_ns[ii].nm;
+			}
+		}
+	}
+	return 0;
+}
+	
+/* Gives the nth non-garbage environment block. Indexed starting ZERO */
+static ENV_VAR* GetEnvBlockByNumber(int index) 
+{
+	ENV_VAR* pVar;
+	int count = 0; 
+	unsigned int end_address, size;
+	
+	pVar = (ENV_VAR*)GetEnvBaseAndSize(&size);
+	end_address = ( int ) pVar + size;
+	
+	/* skip first block */
+	pVar++;	
+	
+	for(;( ( int )pVar < end_address ) && pVar->varNum!=0xFF; pVar = EnvGetNextBlock(pVar))
+	{
+		if(!IsEnvGarbage(pVar)) {
+			if(count == index){
+				return pVar; 
+			}
+			else count++;
+		}
+	}    
+	
+	return 0;
+}
+
+/*
+ * Gets the name and value from a given environment block. Also checks the 
+ * checksum while doing so. If it finds that the checksum is invalid, it 
+ * marks the environment as garbage, and returns 0 for the name and value.
+ */
+static void GetNameAndValueFromEnvVar(ENV_VAR* pVar, char** ppName, char** ppValue)
+{
+	unsigned short chksum = 0;
+	int i;
+	
+	chksum += (pVar->varNum + pVar->ctrl + pVar->numCells);        
+	
+	if(IsEnvDynamic(pVar)) {
+		*ppName  = pVar->data;
+		*ppValue = pVar->data + strlen(pVar->data) + 1;
+	} else {
+		*ppName  = GetPreDefinedVarName(pVar->varNum);
+		*ppValue = pVar->data;                
+	}        
+	
+	for(i = 0; i < strlen(*ppValue); i++) {
+		chksum += (unsigned char) (*ppValue)[i];
+	}
+	
+	if(IsEnvDynamic(pVar)) {
+		for(i = 0; i < strlen(*ppName); i++) {
+			chksum += (unsigned char) (*ppName)[i];
+		}
+	}    
+	
+	chksum += pVar->chksum;
+	
+	chksum  = ~(chksum);
+	
+	/* bad checksum */
+	if(chksum != 0) {
+		*ppName = *ppValue = 0;            
+		EnvMakeGarbage(pVar);
+	}                
+	
+	return;
+}
+	
+/* returns the non-garbage block corresponding to the asked var. */
+static ENV_VAR* GetEnvBlockByName(const char *var) 
+{
+	ENV_VAR* pVar;
+	int index = IsPreDefinedVar(var);
+	int i;
+	
+	for(i = 0; i < MaxEnvVarsNum; i++) {
+		if( !(pVar = GetEnvBlockByNumber(i)) ) 
+			return 0;
+		if( (index) || !IsEnvDynamic( pVar ) ) { 
+			if(pVar->varNum == index) {
+				return pVar;           
+			}
+		} else {    /* Dynamic environment variables */
+			if(!strcmp(var, pVar->data)) {
+				return pVar;
+			}
+		}        
+	}
+	return 0;
+}
+	
+static int FormatEnvBlock(void) 
+{
+	unsigned int size, i;
+	unsigned char* pFlash = GetEnvBaseAndSize(&size);
+	
+#ifdef ENV_SPACE_SIZE
+	char *pExtraSpace;
+	
+	if(!(pExtraSpace = vmalloc(env_size - size))) {
+		return -1;
+	}
+	
+	memset(pExtraSpace, 0xFF, env_size - size);
+	memcpy(pExtraSpace, (char*)env_base + ENV_SPACE_SIZE, 
+	env_size - size);    
+#endif    
+	
+	/* If Erase returns 0 => Flash has gone bad. Return error */
+	if(FWBErase((unsigned int)pFlash, size, 0) == 0) {
+		return -1;
+	}
+	
+	FWBOpen((int)pFlash);
+	
+	for (i = 0; i <= strlen(envVersion) ;i++) {
+	    FWBWriteByte( (int)(pFlash++), envVersion[i]);
+	}
+	
+#ifdef ENV_SPACE_SIZE
+	pFlash = (char*)env_base + ENV_SPACE_SIZE;
+	for (i = 0; i < env_size - size ;i++) {
+		FWBWriteByte( (int)(pFlash++), pExtraSpace[i]);
+	}
+	vfree(pExtraSpace); 
+#endif    
+	
+	FWBClose();	
+	
+return 0;
+}
+	
+int EnvInit(void)
+{
+	static char after_init = 0;
+	
+	if (after_init)
+		return 0;
+	else
+		after_init = 1;  
+	
+	env_size = psbl_rec->env_size;
+	env_base = psbl_rec->env_base;
+	
+	MaxEnvVarsNum = (env_size)/(ENV_CELL_SIZE) - 1; /* Ignore the header */
+	
+	if(strcmp(( char *)env_base, envVersion) != 0) {
+		FormatEnvBlock();            
+	} 
+	
+	return 0;        
+}
+	
+int sys_setenv(const char *env_nm, const char *env_val) 
+{   
+	if( ( !env_nm ) || ( !env_val ) )
+		return -1;
+	
+	if( IsReadOnlyVar( env_nm ) )
+	{
+		printk(envErrReadOnly, env_nm);
+		return 0;       
+	}
+	return __sys_setenv(env_nm, env_val, 0);
+}
+	
+static int __sys_setenv( const char *env_nm, const char *env_val, unsigned char perm )
+{
+	ENV_VAR *pVar, new, *pBase, *pOldEnv = 0;
+	unsigned int size, i, newsize, end_address;
+	char *pTmp;
+#if (AUTO_DEFRAG_ENVIRONMENT == 1)
+	int IsGarbagePresent = 0;
+#endif
+	/* Check for pre-existance of the variable */
+	if((pTmp = sys_getenv( (char *)env_nm))) 
+	{
+		/* Env Exists. See if the value to be set is same as old one */
+		if(!strcmp(pTmp, env_val)) {
+			return 0;
+		}
+		/* Env Exists but is a different value. Make old one garbage */ 
+		pOldEnv = GetEnvBlockByName( (char *)env_nm);
+#if (AUTO_DEFRAG_ENVIRONMENT == 1)
+		IsGarbagePresent = 1;
+#endif
+	
+		if( IsEnvPerm( pOldEnv ) ) {
+			printk(envErrReadOnly, env_nm);
+			return 0;       
+		}  
+	}
+	
+	pBase = pVar = (ENV_VAR*)GetEnvBaseAndSize(&size);
+	end_address = ( unsigned int ) pVar + size;
+	
+	/* skip first block */
+	pVar++;    
+	
+	/* Go to the end of Available Flash space */
+	for( ;( ( int )pVar < end_address ) && pVar->varNum!=0xFF; pVar = EnvGetNextBlock(pVar)) {
+#if (AUTO_DEFRAG_ENVIRONMENT == 1)
+		if(IsEnvGarbage(pVar)) {
+			IsGarbagePresent = 1;
+		}
+#endif        
+	}
+	
+	memset((char*)&new, 0xFF, sizeof(new));
+	new.chksum = 0;                
+	
+	if(!(new.varNum = IsPreDefinedVar(env_nm))) {       
+		/* Dynamic variable */
+		new.ctrl &= ~(ENV_DYNAMIC_BIT);
+	}
+	
+#ifdef PERMANENT_VARIABLES
+	if( perm )
+	new.ctrl &= ~( ENV_PERM_BIT );
+#endif
+	
+	new.chksum += (new.varNum + new.ctrl);
+	
+	newsize = sizeof(ENV_VAR) - sizeof(new.data) + strlen(env_val) + 1;
+	
+	if(IsEnvDynamic(&new)) {
+		newsize  += strlen(env_nm) + 1;
+		for(i=0; i < strlen(env_nm); i++) {
+			new.chksum += (unsigned char) env_nm[i];
+		}
+	}
+	
+	new.numCells = ((newsize)/ENV_CELL_SIZE)+((newsize%ENV_CELL_SIZE)?1:0);
+	new.chksum += new.numCells;
+	
+	for(i = 0; i <= strlen(env_val); i++) {
+		new.chksum += (unsigned char) env_val[i];            
+	}            
+	
+	new.chksum = ~(new.chksum);
+	
+	/* Check if enough space is available to store the env variable */
+	if(((char*)pVar + (new.numCells*ENV_CELL_SIZE)) > ((char*)pBase + size)) {
+#if (AUTO_DEFRAG_ENVIRONMENT == 1)
+		if(IsGarbagePresent){
+			if (sys_defragenv() == 0) {
+				return __sys_setenv(env_nm, env_val, perm );
+			}
+		}
+#endif        
+		printk("Error: Out of Environment space\n");
+		return -2;
+	}
+	
+	/* Write to flash */
+	FWBOpen((int)pVar);
+	
+	for(i = 0; i < sizeof(ENV_VAR) - sizeof(new.data); i++) {
+		FWBWriteByte(((int)pVar)++, ((char*)&new)[i]);
+	}
+	
+	if(IsEnvDynamic(&new)) {
+		for(i = 0; i <= strlen(env_nm); i++) {
+			FWBWriteByte(((int)pVar)++, env_nm[i]);
+		}
+	}
+	
+	for(i = 0; i <= strlen(env_val); i++) {
+		FWBWriteByte(((int)pVar)++, env_val[i]);
+	}        
+	
+	FWBClose();
+	
+	if(pOldEnv) {
+		EnvMakeGarbage(pOldEnv);
+	}
+	
+	
+	return 0;
+}
+	
+int sys_unsetenv(const char *env_nm)
+{
+	ENV_VAR* pVar;        
+	
+	if( IsReadOnlyVar( env_nm ) )
+		goto fail;
+	
+	if( !(pVar = GetEnvBlockByName(env_nm)) ) 
+		return -1;
+	
+#ifdef PERMANENT_VARIABLES
+	if( !IsEnvPerm( pVar ) )
+#endif
+	{   
+		EnvMakeGarbage(pVar); 
+		return 0;  
+	}  
+	
+fail:    
+	printk(envErrReadOnly, env_nm);	
+	return -1;       
+}
+	
+void echo(int argc, char **argv)
+{
+	int ii;
+	if (argc == 1) 
+	{
+		sh_printenv();
+	} 
+	else 
+	{
+		if (strcmp(argv[1], "envlist") == 0) 
+		{
+			printk("Pre-defined Variable list:\n\n");                
+	
+			for ( ii = env_vars_start + 1; ii < env_vars_end; ii++) 
+			{
+				printk("%-13s\n", GetPreDefinedVarName(ii));
+			}
+		}
+		else 
+			/* user gave some unsupported echo request */
+			sh_printenv();
+	}
+}
+	
+int FWBGet_flash_type(void);
+int sys_initenv(void)
+{
+	static char after_init = 0;
+	
+	if( after_init )
+		return 1;
+	else
+		after_init = 1;  
+	
+	env_size = psbl_rec->env_size;
+	env_base = psbl_rec->env_base;
+	
+	FWBGet_flash_type();
+	
+	MaxEnvVarsNum = (env_size)/(ENV_CELL_SIZE) - 1; /* Ignore the header */
+	return 1;
+}
+	
+void sh_printenv(void)
+{
+	ENV_VAR* pVar;
+	int i;
+	char *pName, *pValue;
+	
+	
+	for(i = 0; i < MaxEnvVarsNum; i++) {
+	
+	if( !(pVar = GetEnvBlockByNumber(i)) ) goto out;
+		GetNameAndValueFromEnvVar(pVar, &pName, &pValue);
+		if(pName == 0) continue;
+			printk("\n%-13s\t%s", pName, pValue);
+	}	
+out:    
+	printk("\n");
+	return;        
+}
+	
+char* sys_getenv(const char *var)
+{
+	ENV_VAR* pVar;
+	char *pName, *pValue;
+	
+	if( !(pVar = GetEnvBlockByName(var)) ) 
+		return 0;
+	
+	GetNameAndValueFromEnvVar(pVar, &pName, &pValue);
+	
+	return pValue;
+}
+	
+int sys_defragenv(void)
+{
+	char **ppRamStore = 0;
+	char *pName, *pValue;
+#ifdef PERMANENT_VARIABLES
+	char *IsPerm = 0;
+#endif
+	unsigned int i;
+	ENV_VAR* pVar;
+	int defragFail=0;
+	
+	if( !(ppRamStore = (char**)vmalloc(sizeof(char*)*MaxEnvVarsNum)) ) {
+		defragFail = 1;                
+		goto defragerror;            
+	}
+#ifdef PERMANENT_VARIABLES
+	if( !(IsPerm = (char*)vmalloc( MaxEnvVarsNum )) ) {
+		defragFail = 1;                
+		goto defragerror;            
+	}
+#endif
+	
+	memset ((char*)ppRamStore, 0, sizeof(char*)*MaxEnvVarsNum);
+#ifdef PERMANENT_VARIABLES
+	memset (IsPerm, 0, MaxEnvVarsNum );
+#endif
+	for(i = 0; i < MaxEnvVarsNum; i++) {
+		if( !(pVar = GetEnvBlockByNumber(i)) ) 
+			break;  
+
+			GetNameAndValueFromEnvVar(pVar, &pName, &pValue);        
+	
+			if(pName == 0) 
+				continue;
+	
+		if( !(ppRamStore[i] = vmalloc(strlen(pName) + strlen(pValue) + 2)) ) {
+			defragFail = 1;                
+			goto defragerror;            
+		}
+	
+		/* store name and value in RAM */
+		memcpy((char*)ppRamStore[i], pName, strlen(pName) + 1);
+		memcpy((char*)ppRamStore[i] + strlen(pName) + 1, 
+		pValue,strlen(pValue) + 1);
+#ifdef PERMANENT_VARIABLES
+		IsPerm[ i ] = IsEnvPerm( pVar );                 
+#endif
+	}
+	
+	if(FormatEnvBlock() != 0) {
+		defragFail = 1;
+	}
+	
+	defragerror:
+	if(ppRamStore) {
+		for(i = 0; i < MaxEnvVarsNum; i++) {
+			if(ppRamStore[i]) {
+#ifdef PERMANENT_VARIABLES
+				__sys_setenv(ppRamStore[i], 
+				ppRamStore[i]+strlen(ppRamStore[i]) + 1, IsPerm[ i ] );
+#else
+				__sys_setenv(ppRamStore[i], 
+				ppRamStore[i]+strlen(ppRamStore[i]) + 1, 0 );
+#endif
+				vfree(ppRamStore[i]);
+			}
+		}
+		vfree(ppRamStore);
+	}
+	
+#ifdef PERMANENT_VARIABLES
+	if( IsPerm )
+		vfree(IsPerm);
+#endif
+	
+	if(defragFail) {
+		printk("Out of memory. Defragment aborted.\n");
+		return -2;
+	} 
+	
+	return 0;
+}
+	
+int get_envstring(int index, char *buffer)
+{        
+	ENV_VAR* pVar;
+	
+	if( !(pVar = GetEnvBlockByNumber(index)) ) 	
+		return 0;
+	
+	return sprintf(buffer, "%-13s\t%s\n", 
+	sys_getivar(index), sys_getienv(index));
+}
+	
+char* sys_getienv(int var_num)
+	{
+	ENV_VAR* pVar;
+	char* pName, *pValue;
+	
+	if( !(pVar = GetEnvBlockByNumber(var_num)) ) 
+		return 0;
+	
+	GetNameAndValueFromEnvVar(pVar, &pName, &pValue);
+	
+	return pValue;
+}
+	
+char* sys_getivar (int var_num) 
+{
+	ENV_VAR* pVar;
+	char* pName, *pValue;
+	
+	if( !(pVar = GetEnvBlockByNumber(var_num)) ) 
+		return 0;
+	
+	GetNameAndValueFromEnvVar(pVar, &pName, &pValue);
+	
+	return pName;
+}
+	
+int EnvAddAlias(const char* orig, char* alias)
+{
+	ENVDESC* env;
+	
+	if((env = GetEnvDescForEnvVar(orig)) != 0)
+	{
+		env->alias = alias;
+		return 0;
+	}
+	return -1;
+}
+	
+char* GetResolvedEnvName(const char *envName)
+{
+	ENVDESC* env;
+	
+	if((env = GetEnvDescForEnvVar(envName)) != 0)
+	{
+		if(env->alias != 0) {
+			return env->alias;
+		} else {
+			return ( char *)env->nm;
+		}
+	}
+	return 0;
+}
+	
+int IsReadOnlyVar( const char* env_nm )
+{
+	if( (strcmp("CPUFREQ", env_nm) == 0) || 
+		( strcmp("SYSFREQ", env_nm) == 0 ) || (strcmp("BUILD_OPS", env_nm) == 0) 
+		|| (strcmp("MIPSFREQ", env_nm) == 0) )
+			return 1;
+	
+	return 0;
+}
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/flashop.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/flashop.h
@@ -0,0 +1,166 @@
+#ifndef	_FLASHOP_H_
+#define	_FLASHOP_H_
+	
+#include "stddef.h"
+	
+typedef int (*procref1)(unsigned int base);
+typedef int (*procref2)(unsigned int base,int size);
+typedef int (*procref3)(unsigned int base);
+typedef int (*procref4)(unsigned int adr, char cVal);
+typedef int (*procref5)(void);
+typedef int (*procref6)(unsigned int base,int size,int verbose);
+typedef unsigned int (*procref7)(unsigned int base);
+	
+typedef struct _Adam2Flash 
+{
+	procref1 FWBGetBlockSize; /* called to get block size */
+	procref6 FWBErase;        /* called to erase blocks */
+	procref3 FWBOpen;         /* called to open block writes */
+	procref4 FWBWriteByte;    /* called to write block byte */
+	procref5 FWBClose;        /* called to close block writes */
+	procref2 FWBUnLock;       /* called to close block writes */
+	procref2 FWBLock;         /* called to close block writes */
+	procref7 FWBGetNextBlock;  /* called to get base of the next blk */
+}Adam2Flash;
+	
+int FWBGetBlockSize(unsigned int base);           /*Get Flash Block Size            */
+int FWBErase(unsigned int base,int size,int verbose); /*Erase flash                     */
+int FWBOpen(unsigned int base);                   /*Prepare for flash writes        */
+int FWBWriteByte(unsigned int adr, char cVal);    /*Write byte to flash             */
+int FWBClose(void);                         /*Write any pending data to flash */
+int FWBUnLock(unsigned int adr,int size);       /*Unlock Flash block(s)           */
+int FWBLock(unsigned int from,int size);        /*Lock Flash block(s)             */
+
+int FWBGet_flash_type(void); /* Valid for dual flash boards */
+	
+unsigned int FWBGetNextBlock(unsigned int base);  /* Get base addr of next block    */
+	
+void fix_vector_for_linux(void);
+void AppCopyVectors(void);
+void init_env(void);
+void ShellAddPathToFileName(char *OutBuf,char *InBuf,char *Path);
+unsigned int dm(int argc,char *argv[]);
+int BadAddress(unsigned int adr);
+int boot(void);
+int fmt_extrn_dev_str(void);
+	
+#define SH_CMD_LEN      150
+#define SH_ARGC_MAX     10
+#define SH_PROMPT_SZ    24
+#define PATH_COUNT_MAX  3
+#define PRIV_ROOT  1
+#define PRIV_USER  0
+	
+typedef int (*FUNC_PTR)(int, char**);
+	
+typedef struct SH_PATH {
+	char     nm[50];
+	char     sz;
+} SH_PATH;
+	
+typedef struct sh_CB {
+	char   cmd[SH_CMD_LEN];
+	int    argc;
+	char  *argv[SH_ARGC_MAX];
+	char   path_count;
+	SH_PATH  *path;
+	char   prompt[SH_PROMPT_SZ + 1];
+	unsigned char   priv_state;
+} sh_CB;
+	
+typedef struct PSBL_REC_t {
+	unsigned int psbl_size;
+	unsigned int env_base;
+	unsigned int env_size;
+	unsigned int ffs_base;
+	unsigned int ffs_size;
+	struct sh_CB sh_cb;
+	unsigned int ffs2_base;
+	unsigned int ffs2_size;
+}PSBL_REC;
+	
+typedef struct sh_cmd {
+	const char      *name;
+	FUNC_PTR        app_entry_pt;
+	unsigned char   privilige;
+	const char      *help;
+} sh_cmd;
+	
+typedef enum fs_dev {
+	e_Flash = 0,
+	e_Sio,
+} fs_dev;
+	
+typedef struct memwindow {
+	unsigned int  base;
+	unsigned int    end;
+} memwindow;
+	
+void shell(void);
+void sh_init(void);
+	
+#define EMIF_SDRAM_BASE           0x94000000
+#define EMIF_SDRAM_MAX_SIZE       0x08000000 /*0x08000000 or 0x01000000*/
+#define ASCII_DISP_BASE           0xbc4001c3
+#define ASCII_DISP_OFFSET         8
+#define SIO_OFFSET     4
+#define SIO1_BASE     0xa8610f00
+#define SIO1_RSTMASK  0x42
+#define SIO0_BASE     0xa8610e00
+#define SIO0_RSTMASK  0x01
+#define CS0_BASE 0xb0000000
+#define CS0_SIZE CONF_FLASH_SZ
+#define CS1_BASE 0xb4000000
+#define CS1_SIZE CONF_SDRAM_SZ        
+#define CS3_BASE 0xbc000000
+#define CS3_SIZE (16*1024*1024)
+#define CS4_BASE 0xbd000000
+
+#ifdef DUAL_FLASH
+#define CS4_SIZE CS0_SIZE
+#else
+#define CS4_SIZE (16*1024*1024)
+#endif
+	
+#define CS5_BASE 0xbe000000
+#define CS5_SIZE (16*1024*1024)
+
+#define EMIF_BASE        0xA8610800
+#define EMIF_REV        (*(volatile unsigned int*)(EMIF_BASE+0x00))
+#define EMIF_GASYNC     (*(volatile unsigned int*)(EMIF_BASE+0x04))
+#define EMIF_DRAMCTL    (*(volatile unsigned int*)(EMIF_BASE+0x08))
+#define EMIF_REFRESH    (*(volatile unsigned int*)(EMIF_BASE+0x0c))
+#define EMIF_ASYNC_CS0  (*(volatile unsigned int*)(EMIF_BASE+0x10))
+#define EMIF_ASYNC_CS3  (*(volatile unsigned int*)(EMIF_BASE+0x14))
+#define EMIF_ASYNC_CS4  (*(volatile unsigned int*)(EMIF_BASE+0x18))
+#define EMIF_ASYNC_CS5  (*(volatile unsigned int*)(EMIF_BASE+0x1c))
+
+#define GPIO_BASE     0xa8610900
+#ifdef TNETV1050_BOARD
+/* These defines are for GPIO EN,OUT and DAT 0 */
+#define GPIO_EN         (*(volatile unsigned int *)(GPIO_BASE+0x18))
+#define GPIO_OUT   		(*(volatile unsigned int *)(GPIO_BASE+0x8))
+#define GPIO_DIR   		(*(volatile unsigned int *)(GPIO_BASE+0x10)) 
+#else
+#define GPIO_EN         (*(volatile unsigned int *)(GPIO_BASE+0xc))
+#define GPIO_OUT   		(*(volatile unsigned int *)(GPIO_BASE+0x4))
+#define GPIO_DIR   		(*(volatile unsigned int *)(GPIO_BASE+0x8)) 
+#endif
+
+#define RESET_BASE 	0xa8611600
+#define RESET_REG       (*(volatile unsigned *)(RESET_BASE+0x00))
+#define RESET_STATUS    (*(volatile unsigned *)(RESET_BASE+0x08))
+
+#define BOOTCR 		0xa8611a00
+	
+#ifdef DUAL_FLASH
+#define SEC_FLASH_BASE          CS4_BASE
+#define SEC_FLASH_SIZE          CS4_SIZE
+#define _SEC_FLASH_SIZE         CONF_FLASH_SZ
+#endif
+	
+#if defined (TNETD73XX_BOARD)
+#define IS_OHIO_CHIP() (( (REG32_R( 0xA8610914,15,0 ) == 0x2b) || (REG32_R( 0xA8610914,15,0 ) == 0x18)) ? 1:0)
+#define AVALANCHE_MII_SEL_REG         (0xa8611A08)
+#endif
+#endif /* _HW_H_ */
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/flashop_linux.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/flashop_linux.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ * Copyright (C) 2006 Montavista Software Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+	
+#include "flashop.h"
+	
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/mtd/mtd.h>
+#include <linux/ctype.h>
+#include <linux/module.h>
+	
+int    FWBopen=0;
+	
+/* This function returns back a 0 if failure - no valid flash detected */
+int FWBGet_flash_type()
+{
+	return(1);
+}
+	
+int FWBUnLock(unsigned int adr,int size)
+{
+	struct mtd_info * mtd;
+	int ret;
+	
+	mtd = get_mtd_device(0, 3);
+	if(!mtd) {
+		printk(KERN_ERR "Failed to access the environment variable region:  mtd3\n");
+		return 0;
+	}
+	ret = mtd->unlock(mtd, 0, mtd->erasesize);
+	
+	put_mtd_device(mtd);
+	
+	if (ret)
+		printk ("Flash Unlock Block operation Failed: ret=%08x\n", ret);
+	
+	return(ret==0);
+}
+	
+	
+int FWBLock(unsigned int from,int size)
+{
+	struct mtd_info * mtd;
+	int ret;
+	
+	if (size == 0) 
+		return(1);
+	
+	mtd = get_mtd_device(0, 3);
+	
+	if(!mtd) {
+		printk(KERN_ERR "Failed to access the environment variable region:  mtd3\n");
+		return 0;
+	}
+	ret = mtd->lock(mtd, 0, mtd->erasesize);
+	
+	put_mtd_device(mtd);
+	
+	if (ret)
+		printk ("Flash Lock Block operation Failed: ret=%08x\n", ret);
+	
+	return(ret==0);
+}
+
+static int  flash_mtd_erase_callback (struct erase_info * instr)
+{
+	wake_up((wait_queue_head_t *)instr->priv); 
+	
+	return 1;
+}
+	
+	
+int FWBErase(unsigned int base,int size, int verbose)
+{
+	struct erase_info * instr; 
+	struct mtd_info * mtd;
+	int ret=0;
+	DECLARE_WAITQUEUE(wait,current);
+	wait_queue_head_t wait_q;    
+	
+	base -= GetEnvBaseAndSize(0);
+	
+	if (!FWBopen)
+		return(0);
+	
+	mtd=get_mtd_device(0, 3);
+	if(!mtd) {
+		printk(KERN_ERR "Failed to access the environment variable region: mtd3\n");
+		return 0;
+	}
+	
+	init_waitqueue_head(&wait_q);
+	
+	instr=kmalloc(sizeof(struct erase_info), GFP_KERNEL);
+	if (!instr) 
+		return -ENOMEM;
+	memset(instr,0,sizeof(struct erase_info));
+	
+	instr->mtd=mtd;
+	instr->addr=base;
+	instr->len=size;
+	instr->priv=(u_long)&wait_q;
+	instr->callback=flash_mtd_erase_callback;
+	
+	mtd->unlock(mtd, 0, mtd->erasesize);
+	
+	ret=mtd->erase(mtd, instr);
+	
+	mtd->lock(mtd, 0, mtd->erasesize);
+	
+	if( !ret ) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue( &wait_q, &wait);
+		if( instr->state!=MTD_ERASE_DONE &&
+			instr->state!=MTD_ERASE_FAILED) {
+			schedule();
+		}
+	
+		remove_wait_queue(&wait_q, &wait);
+		set_current_state(TASK_RUNNING);
+	
+		ret=(instr->state==MTD_ERASE_FAILED)?-EIO:0;
+	} else {
+		printk(KERN_ERR "Failed to erase mtd, region [0x%x,0x%x]\n",
+		instr->addr,instr->len);
+	}
+	
+	put_mtd_device(mtd);
+	
+	if (ret)
+		printk ("Flash Erase Block operation Failed: ret=%08x\n", ret);
+	
+	kfree(instr);
+	return(ret==0);
+}
+	
+int FWBOpen(unsigned int base)
+{
+	FWBopen=1;
+	return(1);
+}
+	
+int FWBWriteByte(unsigned int adr, char cVal)
+{
+	struct mtd_info * mtd;
+		int ret,ret1,ret2, num = 1 ;
+	off_t   offset;
+	char  new;
+	
+	if (!FWBopen)
+	return(0);
+	
+	mtd=get_mtd_device(0, 3);
+	if(!mtd) {
+		printk(KERN_ERR "Failed to access the environment variable region: mtd3\n");
+		return 0;
+	}
+	offset = adr - GetEnvBaseAndSize(0);
+	mtd->unlock(mtd, 0, mtd->erasesize);
+	
+	ret1 = MTD_WRITE(mtd, offset, num, &ret, &cVal);
+	
+	/* Dummy read operation */
+	MTD_READ(mtd, offset, num, &ret2, &new);
+	
+	put_mtd_device(mtd);
+	if (num != ret)
+		printk ("Flash Write Byte operation Failed: ret=%08x\n", ret);
+	
+	return(ret1==0);
+}
+	
+int FWBClose(void)
+{
+	if (!FWBopen) 
+		return(0);
+	
+	FWBopen=0;
+	return 1;
+}
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/Kconfig
@@ -0,0 +1,71 @@
+menu "TI Titan (TNETV1050) Configuration"
+
+choice
+	prompt "Titan reference board type"
+	depends on MIPS_TITAN
+	help
+      Select the Titan Ref. Design Board that you are using. If you are not 
+      using any of these, choose the one closest to your design and make 
+      modifications to the kernel as required.
+
+config MIPS_TNETV1050RDB
+	depends on MIPS_TITAN
+	bool "Titan RDB Board"
+
+config MIPS_TNETV1050SDB
+	depends on MIPS_TITAN
+	bool "Titan SDB Board"
+
+endchoice
+
+config MIPS_AVALANCHE_CPMAC
+	tristate "Texas Instruments Avalanche CPMAC support"       
+    default m
+    help
+      Choose y/m, to compile the TI Avalanche CPMAC driver.
+
+config MIPS_CPMAC_PORTS
+    int
+	range 1 2
+    depends on MIPS_AVALANCHE_CPMAC
+	default 2 if MIPS_TNETV1050SDB || MIPS_TNETV1050RDB 
+
+config AVALANCHE_LOW_CPMAC	
+	bool
+    depends on MIPS_AVALANCHE_CPMAC
+    default y if MIPS_TNETV1050SDB || MIPS_TNETV1050RDB
+
+config AVALANCHE_HIGH_CPMAC
+	bool
+    depends on MIPS_AVALANCHE_CPMAC
+	default y if MIPS_TNETV1050SDB || MIPS_TNETV1050RDB
+
+config MIPS_CPMAC_INIT_BUF_MALLOC
+        bool "CPMAC Init Buffer Malloc"
+        depends on MIPS_AVALANCHE_CPMAC
+        default y
+
+config MIPS_AVALANCHE_SSP
+	bool "Avalanche SSP support"
+	default y
+	help
+	 Choose y to compile the Avalanche SSP driver.
+
+config AVALANCHE_NUM_SER_PORTS
+	depends on MIPS_AVALANCHE_SOC
+	int
+	default 1
+	help
+      Choose the correct number of serial ports on your soc here. If unsure
+      consult the SoC specification from your vendor, but do not put a 
+      wrong value here.
+
+config AVALANCHE_CONSOLE_PORT
+	depends on MIPS_AVALANCHE_SOC
+    int
+	default 0
+	help
+      Choose the Avalanche serial port number functioning as the ttyS0 (console)
+      port. The valid values range from 0 through AVALANCHE_NUM_SER_PORTS - 1.
+
+endmenu
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/Makefile
@@ -0,0 +1,6 @@
+EXTRA_CFLAGS += -I$(TOPDIR)/include/asm/mach-avalanche
+
+obj-y := env.o flashop_linux.o titan_clk_cntl.o titan_board_setup.o ssp_hal.o
+
+obj-$(CONFIG_SENSORS_DS1338) += rtc_ds1338.o
+
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/rtc_ds1338.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/rtc_ds1338.c
@@ -0,0 +1,48 @@
+/*
+ * low level RTC hook up functions for Dallas Semiconductor 1338 chip 
+ * This depends on the ds1338 driver to be compiled into the kernel.
+ * 
+ * Author: Sekhar Nori, nsekhar@ti.com 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+	
+#include <linux/time.h>
+#include <asm/time.h>
+	
+#define DS1338_GET_DATE		0
+#define DS1338_SET_DATE		1
+	
+int ds1338_do_command(int id, int cmd, void *arg);
+	
+static unsigned long rtc_ds1338_get_time(void)
+{
+	struct rtc_time date;        
+	
+	if(ds1338_do_command(0, DS1338_GET_DATE, &date) == -ENODEV)
+		return mktime(2000, 1, 1, 0, 0, 0);
+	
+	return mktime(date.tm_year, date.tm_mon + 1, date.tm_mday, date.tm_hour, date.tm_min, date.tm_sec);
+}
+	
+static int rtc_ds1338_set_time(unsigned long t)
+{
+	struct rtc_time tm;
+
+	to_tm(t, &tm);
+	
+	if(ds1338_do_command(0, DS1338_SET_DATE, &tm) == -ENODEV)
+		return -ENODEV;             
+	
+	return 0;
+}
+	
+void ds1338_time_init(void)
+{
+	rtc_get_time = rtc_ds1338_get_time;
+	rtc_set_time = rtc_ds1338_set_time;
+	rtc_set_mmss = rtc_set_time;
+}
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/ssp_hal.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/ssp_hal.c
@@ -0,0 +1,1483 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ * Copyright (C) 2006 Montavista Software Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+	
+#include <ssp_hal.h>
+#include <pal.h>
+	
+struct semaphore ssp_drvp_module_in_use;
+	
+ssp_hal_i2c_info_t* ssp_i2c_open( void );
+	
+ssp_hal_i2c_info_t ssp_i2c_static_config = {
+	1, 0, 0x00, SSP_I2C_OUTPUT_CLK_FREQ, SSP_HAL_MODE_INTR
+};
+	
+ssp_hal_spi_info_t ssp_spi_static_config = {
+	0, 0, 1, 2, SSP_SPI_OUTPUT_CLK_FREQ, SSP_HAL_MODE_INTR
+};
+	
+int __init ssp_dev_init(void)
+{
+	int error_num; 
+	
+	if((error_num = avalanche_sysprobe_and_prep(AVALANCHE_SSP_HW_MODULE_REV, AVALANCHE_SSP_BASE, NULL)) < 0) {
+		printk("SSP: avalanche_sysprobe_and_prep failed\n");
+		return -EINVAL;
+	}
+	
+	avalanche_reset_ctrl(AVALANCHE_SSP_RESET_BIT, OUT_OF_RESET);
+	sema_init( &ssp_drvp_module_in_use,1 );
+	if( ssp_hal_init( AVALANCHE_SSP_BASE, avalanche_clkc_getfreq( CLKC_VBUS ) ) != SSP_DRV_OK )
+		return SSP_DRV_ERROR;   
+	
+	return SSP_DRV_OK;
+}
+	
+ssp_hal_i2c_info_t* ssp_i2c_open( void )
+{
+	ssp_hal_i2c_info_t  info;
+	
+	memcpy(&info, &ssp_i2c_static_config, sizeof(ssp_hal_i2c_info_t));
+	
+	if (down_interruptible(&ssp_drvp_module_in_use))
+		return NULL; 
+	
+	return ssp_hal_i2c_open(info);
+}
+	
+int ssp_i2c_close(ssp_hal_i2c_info_t *     id)
+{
+	ssp_hal_i2c_close(id);
+	
+	up(&ssp_drvp_module_in_use);
+	
+	return 0;
+}
+	
+int ssp_i2c_read( ssp_hal_i2c_info_t  *info, unsigned char    *buffer, unsigned int   len)
+{
+	return ssp_hal_i2c_read(info, buffer, len);
+}
+	
+int ssp_i2c_write( ssp_hal_i2c_info_t  *info, unsigned char    *buffer, unsigned int   len)
+{
+	return ssp_hal_i2c_write(info, buffer, len);
+}
+	
+void __exit ssp_dev_exit(void)
+{
+	return;
+}
+	
+module_init(ssp_dev_init);
+module_exit(ssp_dev_exit);
+	
+#define SSP_HAL_PT0_SEQ_RAM_LOW                         0x100
+#define SSP_HAL_PT1_SEQ_RAM_LOW                         0x180
+#define SSP_HAL_IOSEL_PT0_USE_EXTENDED_RAM              0x00008000
+#define SSP_HAL_PORT0_INT_ENABLE                        0x00000001
+#define SSP_HAL_PORT1_INT_ENABLE                        0x00000002
+#define SSP_HAL_PT0_CLK_DIV_MASK                        0x0000000F
+#define SSP_HAL_PT0_RAM_WRITE_ENABLE                    0x00000010
+#define SSP_HAL_PT0_RAM_READ_ENABLE                     0x00000020
+#define SSP_HAL_PT0_16BIT_DATA_REG                      0x00000040
+#define SSP_HAL_PT0_AUTO_XFR_START                      0x00000080
+#define SSP_HAL_PT0_SOFT_RESET                          0x00000100
+#define SSP_HAL_DIRECT_INPUT                             0x00
+#define SSP_HAL_DIRECT_OUTPUT                            0x04
+#define SSP_HAL_PT0_DATA_OUTPUT                          0x01
+#define SSP_HAL_PT0_CLK                                  0x02
+#define SSP_HAL_PT0_CS                                   0x03
+#define SSP_HAL_PIN0_DIRECT_OUT_HIGH                     0x00000040
+#define SSP_HAL_PIN1_DIRECT_OUT_HIGH                     0x00000080
+#define SSP_HAL_PIN2_DIRECT_OUT_HIGH                     0x00000100
+#define SSP_HAL_PIN3_DIRECT_OUT_HIGH                     0x00000200
+#define SSP_HAL_PIN4_DIRECT_OUT_HIGH                     0x00000400
+#define SSP_HAL_IOSEL_PIN0_MASK                          0x00000007
+#define SSP_HAL_IOSEL_PIN1_MASK                          0x00000038
+#define SSP_HAL_IOSEL_PIN2_MASK                          0x000001C0
+#define SSP_HAL_IOSEL_PIN3_MASK                          0x00000E00
+#define SSP_HAL_IOSEL_PIN4_MASK                          0x00007000
+#define SSP_HAL_IOSEL_PT0_USE_EXTENDED_RAM               0x00008000
+#define SSP_HAL_IOSEL_PIN0_BIT_POS                       0
+#define SSP_HAL_IOSEL_PIN1_BIT_POS                       3
+#define SSP_HAL_IOSEL_PIN2_BIT_POS                       6
+#define SSP_HAL_IOSEL_PIN3_BIT_POS                       9
+#define SSP_HAL_IOSEL_PIN4_BIT_POS                       12
+#define SSP_HAL_PT0_STATE_STOP_ADDR_MASK                0x0000003F         
+#define SSP_HAL_CLK_PRE_DIV_MASK                         0x000000FF
+#define SSP_HAL_PT0_START_ADDR_MASK                      0x0000003F
+#define SSP_HAL_PT0_START_ADDR_VALID_MASK                0x00000080
+#define SSP_HAL_PT0_EARLY_DATA_IN_MASK                   0x00000100
+#define SSP_HAL_PT0_DELAY_DATA_OUT_MASK                  0x00000200
+#define SSP_HAL_PT0_STATE_BUSY_MASK                      0x00000400
+#define SSP_HAL_PT0_CLEAR_DATA_REG_MASK                  0x00000800
+#define SSP_HAL_PT0_SHIFT_ADDR_LSB_FIRST                 0x00001000
+#define SSP_HAL_PT0_SHIFT_DATA_LSB_FIRST                 0x00002000
+#define SSP_HAL_PT0_START_SERIAL_TRANSFER                0x00008000
+	
+#define SSP_HAL_SPI_SERIAL_DATA_MASK                    0x000000FF
+#define SSP_HAL_I2C_SERIAL_DATA_MASK                    0x000000FF
+#define SSP_HAL_I2C_READ_ENABLE_BIT                     0x00000100
+#define SSP_HAL_I2C_ADDR_MASK                           0x0000FE00
+#define SSP_HAL_I2C_ADDR_SHIFT_AMT                      9
+#define SSP_HAL_SEQMAP_I2C_STOP_ADDR                    0x15
+#define SSP_HAL_SEQMAP_I2C_READ_BYTE_ADDR               0x09
+#define SSP_HAL_SEQMAP_I2C_READ_START_ADDR              0x04
+#define SSP_HAL_SEQMAP_I2C_READ_ADDR_PAUSE              0x08
+#define SSP_HAL_SEQMAP_I2C_READ_BYTE_PAUSE              0x0B
+#define SSP_HAL_SEQMAP_I2C_WRITE_BYTE_ADDR              0x11
+#define SSP_HAL_SEQMAP_I2C_WRITE_START_ADDR             0x0C
+#define SSP_HAL_SEQMAP_I2C_WRITE_ADDR_PAUSE             0x10
+#define SSP_HAL_SEQMAP_I2C_WRITE_BYTE_PAUSE             0x14
+#define SSP_HAL_CLK_HIGH                                (1 << 0)
+#define SSP_HAL_CLK_LOW                                 (0 << 0)
+#define SSP_HAL_DATA_HIGH                               (1 << 1)
+#define SSP_HAL_DATA_LOW                                (0 << 1)
+#define SSP_HAL_CS_HIGH                                 (1 << 2)
+#define SSP_HAL_CS_LOW                                  (0 << 2)
+#define SSP_HAL_INPUT_MODE                              (0 << 3)                        
+#define SSP_HAL_OUTPUT_MODE                             (1 << 3)                        
+#define SSP_HAL_DATA_REG                                (1 << 4)
+#define SSP_HAL_ADDR_REG                                (0 << 4)
+#define SSP_HAL_OPCODE_DIRECT                           ((0x0) << 5)
+#define SSP_HAL_OPCODE_TOGGLE                           ((0x1) << 5)
+#define SSP_HAL_OPCODE_SHIFT                            ((0x2) << 5)
+#define SSP_HAL_OPCODE_BRANCH0                          ((0x4) << 5)
+#define SSP_HAL_OPCODE_BRANCH1                          ((0x5) << 5)
+#define SSP_HAL_OPCODE_BRANCH                           ((0x6) << 5)
+#define SSP_HAL_OPCODE_STOP                             ((0x7) << 5)
+#define SSP_HAL_NOT_APPLICABLE                          0
+#define SSP_HAL_BRANCH_ADDR_BIT_POS                     8
+#define SSP_HAL_CNT_VALUE_BIT_POS                       8
+#define SSP_HAL_BRANCH(addr)             ((addr)<<SSP_HAL_BRANCH_ADDR_BIT_POS)
+#define SSP_HAL_COUNT(cycles)            ((cycles)<<SSP_HAL_CNT_VALUE_BIT_POS)
+#define SSP_HAL_SEQ_SIZE                                32
+#define SSP_HAL_I2C_READ_ENABLE                       0x02
+#define SSP_HAL_WRITE_ADDR_WRITE                         1 
+#define SSP_HAL_WRITE_DATA                               0 
+#define SSP_HAL_WRITE_DATA_LAST                          2
+#define SSP_HAL_READ_ADDR_WRITE                          4
+#define SSP_HAL_READ_DATA_LAST                           5
+#define SSP_HAL_OUTPUT_SAMPLE_RATE                      50
+	
+typedef struct SSP_HAL_REG_tag
+{
+	unsigned int revision_control;
+	unsigned int iosel_control_1;
+	unsigned int iosel_control_2;
+	unsigned int clk_pre_divider;
+	unsigned int interrupt_status;
+	unsigned int interrupt_enable;
+	unsigned int test_control;
+	unsigned int pad1[9];
+	unsigned int port0_config_2;
+	unsigned int port0_address;
+	unsigned int port0_data;    
+	unsigned int port0_config_1;
+	unsigned int port0_state;    
+	unsigned int pad2[11];
+	unsigned int port1_config_2;
+	unsigned int port1_address;
+	unsigned int port1_data;    
+	unsigned int port1_config_1;
+	unsigned int port1_state;    
+}SSP_HAL_REG_T;
+	
+	
+typedef struct 
+{
+	void* reentrantLock;
+	void* completionSem;
+	signed char completionSemAllocated;
+	signed char reentrantLockAllocated;
+}SSP_HAL_DEV;
+
+SSP_HAL_DEV        ssp_dev;
+typedef void *     SspHandle;
+	
+struct semaphore ssp_drvp_xfr_complete;
+	
+typedef struct  SSP_HAL_OBJ_tag
+{    
+	unsigned int base_addr;
+	unsigned int input_freq;
+	
+}SSP_HAL_OBJ_T;
+	
+static volatile SSP_HAL_REG_T *ssp_halp_p_regs;
+	
+static SSP_HAL_OBJ_T ssp_halp_obj;
+	
+static volatile unsigned int *ssp_halp_p_pt0_ram;
+static volatile unsigned int *ssp_halp_p_pt1_ram;
+extern unsigned int ssp_halp_spi_read_seq_map[];
+extern unsigned int ssp_halp_spi_write_seq_map[];
+extern unsigned int ssp_halp_spi_stop_seq_map[];
+extern unsigned int ssp_halp_i2c_engine0_write_seq_map[];
+extern unsigned int ssp_halp_i2c_engine0_read_seq_map[];
+extern unsigned int ssp_halp_i2c_engine1_seq_map[];
+static inline unsigned int ssp_hal_i2c_start(void);
+static unsigned int ssp_halp_load_seq_ram (unsigned int* p_seq_map, 
+unsigned int map_size, 
+unsigned int start_address);
+	
+	
+static unsigned int ssp_halp_load_seq_ram1 (unsigned int* p_seq_map,
+unsigned int map_size,
+unsigned int start_address);
+void ssp_isr(void)
+{
+	up( &ssp_drvp_xfr_complete );
+}
+	
+static inline void ssp_wait_for_xfr_done(void)
+{
+	down( &ssp_drvp_xfr_complete );
+}
+	
+unsigned int ssp_hal_init
+(
+	unsigned int base_address,
+	unsigned int module_input_freq
+)
+{
+	ssp_halp_obj.base_addr = base_address;
+	ssp_halp_obj.input_freq = module_input_freq;
+	ssp_halp_p_regs    = (volatile SSP_HAL_REG_T*)base_address;
+	ssp_halp_p_pt0_ram = (volatile unsigned int*)(base_address + \
+	SSP_HAL_PT0_SEQ_RAM_LOW);
+	
+	ssp_halp_p_pt1_ram = (volatile unsigned int*)(base_address + \
+	SSP_HAL_PT1_SEQ_RAM_LOW);
+	
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_SOFT_RESET;
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_SOFT_RESET;
+	ssp_halp_p_regs->port0_config_2 |= SSP_HAL_PT0_16BIT_DATA_REG;
+	ssp_halp_p_regs->port1_config_2 |= SSP_HAL_PT0_16BIT_DATA_REG;
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_AUTO_XFR_START;
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_AUTO_XFR_START;
+	ssp_halp_p_regs->port0_config_1 &=~SSP_HAL_PT0_SHIFT_ADDR_LSB_FIRST;
+	ssp_halp_p_regs->port0_config_1 &=~SSP_HAL_PT0_SHIFT_DATA_LSB_FIRST;
+	ssp_halp_p_regs->port1_config_1 &=~SSP_HAL_PT0_SHIFT_ADDR_LSB_FIRST;
+	ssp_halp_p_regs->port1_config_1 &=~SSP_HAL_PT0_SHIFT_DATA_LSB_FIRST;
+	ssp_halp_p_regs->iosel_control_1 &= ~SSP_HAL_IOSEL_PT0_USE_EXTENDED_RAM;
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_START_ADDR_VALID_MASK;
+	ssp_halp_p_regs->port1_config_1 |= SSP_HAL_PT0_START_ADDR_VALID_MASK;
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_RAM_READ_ENABLE;
+	
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_RAM_READ_ENABLE;
+	
+	sema_init( &ssp_drvp_xfr_complete, 0);    
+	
+	return SSP_HAL_OK;
+}
+	
+ssp_hal_i2c_info_t* ssp_hal_i2c_open
+(
+	ssp_hal_i2c_info_t info 
+)
+{
+	unsigned int divisor;
+	unsigned int sample_freq;
+	ssp_hal_i2c_info_t* ret;
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map, SSP_HAL_SEQ_SIZE,  \
+	(unsigned int)ssp_halp_p_pt0_ram);
+	
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_write_seq_map, SSP_HAL_SEQ_SIZE,
+	(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_p_regs->port0_config_2 |= SSP_HAL_PT0_SOFT_RESET;
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_SOFT_RESET;
+	
+	
+	ssp_halp_p_regs->iosel_control_2 &= ~0x3F;
+	ssp_halp_p_regs->iosel_control_1 &= ~0x7FFF;    
+	ssp_halp_p_regs->iosel_control_1 &= 0;  
+	
+	ssp_halp_p_regs->iosel_control_1 |= (0x1 << (3 * info.clock_pin));
+	ssp_halp_p_regs->iosel_control_2 |= 0x0 << (3 * info.clock_pin);
+	ssp_halp_p_regs->iosel_control_1 |= (0x5 << (3 * info.data_pin)) ;
+	ssp_halp_p_regs->iosel_control_2 |= (1 << (3 * info.data_pin));
+	sample_freq = (info.bus_speed) * SSP_HAL_OUTPUT_SAMPLE_RATE;
+	divisor = (unsigned int)((ssp_halp_obj.input_freq/sample_freq) - 1);
+	ssp_halp_p_regs->clk_pre_divider = divisor;
+	ssp_halp_p_regs->port0_config_2 &= ~0xF;
+	ssp_halp_p_regs->port1_config_2 &= ~0xF;   
+	
+	if(info.mode == SSP_HAL_MODE_INTR) {
+		ssp_halp_p_regs->interrupt_enable |= SSP_HAL_PORT1_INT_ENABLE;        
+	} else {
+		ssp_halp_p_regs->interrupt_enable &= ~SSP_HAL_PORT0_INT_ENABLE;
+		ssp_halp_p_regs->interrupt_enable &= ~SSP_HAL_PORT1_INT_ENABLE;
+	}
+	
+	if(avalanche_memalloc(sizeof(ssp_hal_i2c_info_t),( void *)&ret) != 0) {
+		return NULL;
+	} 
+	
+	ret->data_pin  = info.data_pin;
+	ret->clock_pin = info.clock_pin;
+	ret->addr      = info.addr;
+	
+	ret->bus_speed = info.bus_speed;
+	ret->mode      = info.mode;
+	
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_DELAY_DATA_OUT_MASK; 
+	
+	return ret;
+}
+	
+unsigned int ssp_hal_i2c_close
+(
+	ssp_hal_i2c_info_t* info
+) 
+{  
+	avalanche_memfree(( void *)info);
+	
+	return SSP_HAL_OK;
+}
+	
+static unsigned int ssp_hal_update_seq_ram
+(
+	unsigned int      start_address,
+	unsigned int      data,
+	unsigned int      seq_id
+)
+{
+	volatile unsigned int *p_ssp_ram = (volatile unsigned int*)start_address; 
+	unsigned int           count;
+	unsigned int           tempVal = data;
+	unsigned char            startOffset = 0;
+	
+	ssp_halp_p_regs->port1_config_2 |= SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+	if (seq_id == SSP_HAL_WRITE_DATA_LAST)
+		startOffset = 4;
+	if (seq_id == SSP_HAL_WRITE_ADDR_WRITE)
+		startOffset = 3;
+	if (seq_id == SSP_HAL_WRITE_DATA)
+		startOffset = 4;
+	if (seq_id == SSP_HAL_READ_ADDR_WRITE)
+		startOffset = 3;
+	
+	if (seq_id == SSP_HAL_READ_DATA_LAST) {
+		p_ssp_ram[18] = ((0x25 <<8) |SSP_HAL_OPCODE_TOGGLE |SSP_HAL_ADDR_REG 
+				|SSP_HAL_OUTPUT_MODE |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW |SSP_HAL_CLK_LOW);
+	
+	
+		p_ssp_ram[19] = ((0x01 <<8) |SSP_HAL_OPCODE_TOGGLE |SSP_HAL_DATA_REG 
+				|SSP_HAL_OUTPUT_MODE |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW |SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[20] = ((0x00 <<8) |SSP_HAL_OPCODE_STOP |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_OUTPUT_MODE |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW |SSP_HAL_CLK_LOW);
+	
+		ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+		return SSP_HAL_OK;                  
+	}    
+	
+	tempVal &= 0x1;
+	
+	for (count = 11; count > startOffset ; count--){
+		data = data >> 1;
+	
+		if(data & 0x1)
+			p_ssp_ram[count] = ((0x31 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_ADDR_REG 
+						|SSP_HAL_OUTPUT_MODE | SSP_HAL_CS_LOW 
+						|SSP_HAL_DATA_HIGH |SSP_HAL_CLK_LOW);
+	
+		else
+			p_ssp_ram[count] = ((0x31 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_ADDR_REG 
+						|SSP_HAL_OUTPUT_MODE |SSP_HAL_CS_LOW 
+						|SSP_HAL_DATA_LOW |SSP_HAL_CLK_LOW);        
+	}
+	
+	if (seq_id == SSP_HAL_READ_ADDR_WRITE){
+		p_ssp_ram[0] =  ((0x00 <<8)|SSP_HAL_OPCODE_STOP   |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_INPUT_MODE    |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[15] = ((0x16 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_DATA_REG 
+				|SSP_HAL_INPUT_MODE    |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_HIGH     |SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[16] = ((0x01 <<8)|SSP_HAL_OPCODE_SHIFT  |SSP_HAL_DATA_REG 
+				|SSP_HAL_INPUT_MODE    |SSP_HAL_CS_LOW 
+				|SSP_HAL_NOT_APPLICABLE|SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[17] = ((0x00 <<8)|SSP_HAL_OPCODE_BRANCH |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_INPUT_MODE    |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW); 
+	}
+	
+	if (seq_id == SSP_HAL_WRITE_DATA_LAST){
+		p_ssp_ram[15] = ((0x31 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_ADDR_REG 
+				|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);  
+	
+		p_ssp_ram[16] = ((0x11 <<8)|SSP_HAL_OPCODE_BRANCH |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[18] = ((0x31 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);
+	
+		p_ssp_ram[19] = ((0x00 <<8)|SSP_HAL_OPCODE_STOP   |SSP_HAL_NOT_APPLICABLE     
+				|SSP_HAL_INPUT_MODE   |SSP_HAL_CS_LOW 
+				|SSP_HAL_DATA_HIGH     |SSP_HAL_CLK_LOW);   
+	}
+	
+	if ((seq_id == SSP_HAL_WRITE_ADDR_WRITE) || (seq_id == SSP_HAL_WRITE_DATA)) {
+		if(tempVal & 0x1){
+			p_ssp_ram[15] = ((0x30 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_NOT_APPLICABLE     
+					|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+					|SSP_HAL_DATA_HIGH      |SSP_HAL_CLK_LOW);
+	
+			p_ssp_ram[16] = ((0x00 <<8)|SSP_HAL_OPCODE_BRANCH |SSP_HAL_NOT_APPLICABLE     
+					|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+					|SSP_HAL_DATA_HIGH     |SSP_HAL_CLK_LOW);   
+		} else {
+			p_ssp_ram[15] = ((0x19 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_NOT_APPLICABLE     
+					|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+					|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);
+	
+			p_ssp_ram[16] = ((0x19 <<8)|SSP_HAL_OPCODE_TOGGLE |SSP_HAL_NOT_APPLICABLE     
+					|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+					|SSP_HAL_DATA_LOW      |SSP_HAL_CLK_LOW);
+	
+			p_ssp_ram[17] = ((0x00 <<8)|SSP_HAL_OPCODE_STOP   |SSP_HAL_NOT_APPLICABLE     
+					|SSP_HAL_OUTPUT_MODE   |SSP_HAL_CS_LOW 
+					|SSP_HAL_DATA_LOW     |SSP_HAL_CLK_HIGH);   
+		}        
+	}
+	
+	/* disable RAM reads/writes again */
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+	return SSP_HAL_OK;
+}
+	
+static inline unsigned int ssp_hal_i2c_start()
+{
+	for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+
+	for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	ssp_halp_p_regs->port1_config_1 |= SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	
+	return 0;
+}
+	
+unsigned int ssp_hal_i2c_wait_for_free(ssp_hal_i2c_info_t  *info)
+{
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x19 & 
+	SSP_HAL_PT0_START_ADDR_MASK);
+	
+	/* Trigger device address write by writing to ST bit */
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	
+	for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	
+	if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) !=
+		0x1b) {
+		return 1;
+	}
+	return 0;    
+}
+	
+unsigned int ssp_hal_i2c_write(ssp_hal_i2c_info_t  *info,unsigned char *buffer, unsigned int len)
+{
+	unsigned int count = 0;
+	unsigned int  data;
+	unsigned char bitState;
+	
+	if(!buffer) {
+		return SSP_HAL_ERROR;            
+	}
+	
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_write_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt0_ram);        
+	
+	bitState = ((buffer[0] & 0x80) >> 7);
+	
+	data = (info->addr << 2)| bitState;
+	data &= ~SSP_HAL_I2C_READ_ENABLE;
+	
+	ssp_hal_update_seq_ram((unsigned int)ssp_halp_p_pt1_ram, data, 
+				SSP_HAL_WRITE_ADDR_WRITE);
+	
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x01 & 
+				SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x03 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_hal_i2c_start();
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {        
+		for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);                  
+		for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	if((ssp_halp_p_regs->port1_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) == 0x14) {
+		goto writeerr;
+	}
+	
+	if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+		goto writeerr;
+	}
+	ssp_hal_i2c_wait_for_free(info);
+	ssp_isr();
+	
+	for(count = 0; count < len - 1; count++) {
+		if(info->mode == SSP_HAL_MODE_POLL) {
+			for(;ssp_halp_p_regs->port0_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+			for(;ssp_halp_p_regs->port1_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;); 
+		}	 
+	
+		data = (buffer[count] & 0x7F) <<  1;
+		bitState = ((buffer[count + 1] & 0x80) >> 7);
+		data = data | bitState;
+	
+		ssp_hal_update_seq_ram((unsigned int)ssp_halp_p_pt1_ram, data, SSP_HAL_WRITE_DATA);
+		ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+		ssp_halp_p_regs->port1_config_1 |= ( 0x05 
+						& SSP_HAL_PT0_START_ADDR_MASK); 
+
+		ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+		ssp_halp_p_regs->port0_config_1 |= ( 0x04 
+						& SSP_HAL_PT0_START_ADDR_MASK);
+	
+		ssp_hal_i2c_start();
+	
+		if(info->mode == SSP_HAL_MODE_POLL) {        
+			for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);                  
+			for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+		} else {
+			ssp_wait_for_xfr_done();
+		}
+	
+		if((ssp_halp_p_regs->port1_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) == 0x14) {
+			goto writeerr;
+		}
+	
+		if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+			goto writeerr;
+		}
+		ssp_hal_i2c_wait_for_free(info);
+	}
+	ssp_isr();	
+	if(info->mode == SSP_HAL_MODE_POLL) {
+		for(;ssp_halp_p_regs->port0_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+		for(;ssp_halp_p_regs->port1_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);        
+	} 
+	
+	data = (buffer[count] & 0x7F) <<  1;
+	
+	ssp_hal_update_seq_ram((unsigned int)ssp_halp_p_pt1_ram, data, SSP_HAL_WRITE_DATA_LAST);
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x05 & SSP_HAL_PT0_START_ADDR_MASK);                   
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x06 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_hal_i2c_start();
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {        
+		for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;); 
+		for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	if((ssp_halp_p_regs->port1_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) == 0x14) {
+		goto writeerr;
+	}
+	
+	if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+		goto writeerr;
+	}
+	ssp_hal_i2c_wait_for_free(info);    
+	
+	count++;
+	
+	writeerr:
+	ssp_isr();
+	
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_write_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt0_ram);        
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x11 & SSP_HAL_PT0_START_ADDR_MASK);                   
+	
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x16 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_hal_i2c_start();
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {        
+		for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;); 
+		for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	return (count);
+	
+}
+	
+unsigned int ssp_hal_i2c_read(ssp_hal_i2c_info_t  *info,unsigned char *buffer,unsigned int len)
+{
+	unsigned int count = 0;
+	unsigned int data;
+	unsigned int tempVal  = 0;
+	unsigned int tempVal1 = 0;
+	
+	
+	if(!buffer) {
+		return SSP_HAL_ERROR;            
+	}
+	
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_write_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt0_ram);        
+	
+	data = (info->addr << 2);
+	
+	data |= SSP_HAL_I2C_READ_ENABLE;
+	
+	ssp_hal_update_seq_ram((unsigned int)ssp_halp_p_pt1_ram, data, SSP_HAL_READ_ADDR_WRITE);  
+	
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x01 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x03 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_CLEAR_DATA_REG_MASK;
+	
+	ssp_hal_i2c_start();
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {        
+		for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+		for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+		goto readerr;
+	}
+	ssp_isr();
+	tempVal = (ssp_halp_p_regs->port1_data & 0x01);
+	
+	ssp_hal_i2c_wait_for_free(info);
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_read_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map, SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt0_ram);        
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_CLEAR_DATA_REG_MASK;
+	
+	for(count = 0; count < (len - 1); count++) {
+		/* Make the sequence map start at the right address */
+		ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+		ssp_halp_p_regs->port0_config_1 |= (0x04 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+		ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+		ssp_halp_p_regs->port1_config_1 |= (0x02 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+		ssp_hal_i2c_start();
+		
+		if(info->mode == SSP_HAL_MODE_POLL) {
+			for(;ssp_halp_p_regs->port0_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+			for(;ssp_halp_p_regs->port1_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+		} else {
+			ssp_wait_for_xfr_done();
+		}
+	
+		if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+			goto readerr;              
+		}
+		ssp_hal_i2c_wait_for_free(info);
+	
+		tempVal1 = (ssp_halp_p_regs->port1_data);
+	
+		buffer[count] = ((tempVal1 >> 1) & SSP_HAL_I2C_SERIAL_DATA_MASK) | (tempVal << 7); 
+	
+		tempVal = tempVal1 & 0x01;
+	
+		ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_CLEAR_DATA_REG_MASK;
+	}    
+	
+	ssp_hal_update_seq_ram((unsigned int)ssp_halp_p_pt1_ram, data, SSP_HAL_READ_DATA_LAST);  
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x06 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x02 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_hal_i2c_start();
+	ssp_isr();
+		
+	if(info->mode == SSP_HAL_MODE_POLL) {
+		for(;ssp_halp_p_regs->port0_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+		for(;ssp_halp_p_regs->port1_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	if((ssp_halp_p_regs->port0_state & SSP_HAL_PT0_STATE_STOP_ADDR_MASK) != 0x15) {
+		goto readerr;              
+	}
+	
+	ssp_hal_i2c_wait_for_free(info);
+	
+	buffer[count] = (ssp_halp_p_regs->port1_data & SSP_HAL_I2C_SERIAL_DATA_MASK) | (tempVal << 7); 
+	
+	count++;
+	
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_CLEAR_DATA_REG_MASK;
+	
+	readerr:   
+	ssp_isr();
+	ssp_halp_load_seq_ram1(ssp_halp_i2c_engine0_write_seq_map,SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt1_ram);
+	
+	ssp_halp_load_seq_ram(ssp_halp_i2c_engine1_seq_map,SSP_HAL_SEQ_SIZE,
+				(unsigned int)ssp_halp_p_pt0_ram);        
+	
+	ssp_halp_p_regs->port1_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port1_config_1 |= (0x11 & SSP_HAL_PT0_START_ADDR_MASK);                   
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	ssp_halp_p_regs->port0_config_1 |= (0x16 & SSP_HAL_PT0_START_ADDR_MASK);
+	
+	ssp_hal_i2c_start();
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {        
+		for(;ssp_halp_p_regs->port1_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+		for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	return count;
+}
+	
+ssp_hal_spi_info_t* ssp_hal_spi_open(ssp_hal_spi_info_t info)
+{
+	unsigned int pre_div;
+	
+	ssp_hal_spi_info_t* ret;
+	
+	ssp_halp_p_regs->iosel_control_1 = SSP_HAL_IOSEL_PT0_USE_EXTENDED_RAM;
+	ssp_halp_p_regs->iosel_control_2 = 0;
+	
+	ssp_halp_p_regs->iosel_control_1 |= (0x1 << (3*info.data_out_pin)) ;
+	ssp_halp_p_regs->iosel_control_2 |= info.data_in_pin;
+	
+	ssp_halp_p_regs->iosel_control_1 |= (0x2 << (3*info.clock_pin)) ;
+	
+	ssp_halp_p_regs->iosel_control_1 |= (0x3 << (3*info.cs_pin)) ;
+	
+	ssp_halp_p_regs->port0_config_2 &= ~0xF;
+	
+	pre_div = ssp_halp_obj.input_freq/(info.clock_speed * 2) + 
+			((ssp_halp_obj.input_freq % (info.clock_speed * 2)) != 0);
+	
+	ssp_halp_p_regs->clk_pre_divider = (pre_div == 0)? 0: (pre_div - 1);  
+	
+	ssp_halp_p_regs->port0_config_1 &= ~SSP_HAL_PT0_DELAY_DATA_OUT_MASK; 
+	
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_EARLY_DATA_IN_MASK;
+	
+	if(info.mode == SSP_HAL_MODE_INTR) {
+		ssp_halp_p_regs->interrupt_enable |= SSP_HAL_PORT0_INT_ENABLE;
+	} else {
+		ssp_halp_p_regs->interrupt_enable &= ~SSP_HAL_PORT0_INT_ENABLE;
+	}
+	
+	if(avalanche_memalloc(sizeof(ssp_hal_spi_info_t), ( void *)&ret) != 0) {
+		return NULL;    
+	}
+	
+	ret->data_in_pin  = info.data_in_pin;
+	ret->data_out_pin = info.data_out_pin;
+	ret->clock_pin    = info.clock_pin;
+	ret->cs_pin       = info.cs_pin;
+	ret->clock_speed  = ssp_halp_obj.input_freq/
+				(((ssp_halp_p_regs->port0_config_2 & 0xF) + 1)*2);
+	ret->clock_speed  = ret->clock_speed/(ssp_halp_p_regs->clk_pre_divider + 1);
+	ret->mode         = info.mode;
+	
+	return ret;
+}
+	
+unsigned int ssp_hal_spi_close(ssp_hal_spi_info_t* info)
+{
+	avalanche_memfree(( void *)info);
+	return SSP_HAL_OK;
+}
+	
+unsigned int ssp_hal_spi_write_read (ssp_hal_spi_info_t *info,unsigned char *write_buf,unsigned int write_len,unsigned char *read_buf,unsigned int read_len)
+{
+	unsigned int count = 0, ret;
+	
+	if((!read_buf) && (!write_buf)) {
+		return SSP_HAL_ERROR;            
+	}
+	
+	ssp_halp_p_regs->port0_config_1 &= (~SSP_HAL_PT0_START_ADDR_MASK);
+	
+	if((write_buf) && (write_len > 0)) {
+		ssp_halp_load_seq_ram(ssp_halp_spi_write_seq_map, 2, 
+			(unsigned int)ssp_halp_p_pt0_ram);
+	
+		for(count = 0; count < write_len; count++) {
+			ssp_halp_p_regs->port0_address = (write_buf[count] & 0xFF) <<  8;
+	
+			for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+	
+			ssp_halp_p_regs->port0_config_1|=SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	
+			if(info->mode == SSP_HAL_MODE_POLL) {
+				for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+			} else {	
+				ssp_wait_for_xfr_done();
+			}        
+		}                    
+	}	 
+	
+	ret = count;
+	ssp_isr();
+	
+	if((read_buf) && (read_len > 0)) {
+		ssp_halp_load_seq_ram(ssp_halp_spi_read_seq_map, 2, 
+				(unsigned int)ssp_halp_p_pt0_ram);
+		for(count = 0; count < read_len; count++) {
+			ssp_halp_p_regs->port0_address = 0;
+	
+			for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+			ssp_halp_p_regs->port0_config_1|=SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	
+			if(info->mode == SSP_HAL_MODE_POLL) {
+				for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);
+			} else {
+				ssp_wait_for_xfr_done();
+			}        
+	
+			read_buf[count] = ssp_halp_p_regs->port0_address &= 
+					SSP_HAL_SPI_SERIAL_DATA_MASK;
+		}
+	}        
+	
+	ret += count;
+	ssp_isr();
+	
+	ssp_halp_load_seq_ram(ssp_halp_spi_stop_seq_map, 1, (unsigned int)ssp_halp_p_pt0_ram);
+	
+	for(;ssp_halp_p_regs->port0_config_1 & SSP_HAL_PT0_STATE_BUSY_MASK;);    
+	ssp_halp_p_regs->port0_config_1 |= SSP_HAL_PT0_START_SERIAL_TRANSFER;
+	
+	if(info->mode == SSP_HAL_MODE_POLL) {
+		for(;ssp_halp_p_regs->port0_config_1&SSP_HAL_PT0_STATE_BUSY_MASK;);
+	} else {
+		ssp_wait_for_xfr_done();
+	}
+	
+	return ret;
+}
+	
+static unsigned int ssp_halp_load_seq_ram(unsigned int *p_seq_map,unsigned int map_size,unsigned int start_address)
+{
+	volatile unsigned int *p_ssp_ram = (volatile unsigned int*)start_address; 
+	unsigned int  i ; 
+	
+	ssp_halp_p_regs->port0_config_2 |= SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	for(i = 0 ; i < map_size; i++)
+	{
+		p_ssp_ram[i]  = p_seq_map[i];
+	}
+	
+	ssp_halp_p_regs->port0_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+	return SSP_HAL_OK;
+}
+	
+static unsigned int ssp_halp_load_seq_ram1(unsigned int *p_seq_map,unsigned int      map_size,unsigned int start_address)
+{
+	volatile unsigned int *p_ssp_ram = (volatile unsigned int*)start_address; 
+	unsigned int  i ; 
+	
+	ssp_halp_p_regs->port1_config_2 |= SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+	for(i = 0 ; i < map_size; i++)
+	{
+		p_ssp_ram[i]  = p_seq_map[i];
+	}
+	
+	ssp_halp_p_regs->port1_config_2 &= ~SSP_HAL_PT0_RAM_WRITE_ENABLE;
+	
+	return SSP_HAL_OK;
+}
+	
+unsigned int ssp_hal_intr_ctrl(unsigned int action)
+{
+	switch (action) {
+	case SSP_HAL_INTR_ACK:
+		ssp_halp_p_regs->interrupt_status |= 0x3;
+		break;
+	case SSP_HAL_INTR_DISABLE:
+		ssp_halp_p_regs->interrupt_enable &= ~SSP_HAL_PORT1_INT_ENABLE;
+		break;
+	case SSP_HAL_INTR_ENABLE:
+		ssp_halp_p_regs->interrupt_enable |= SSP_HAL_PORT1_INT_ENABLE;
+		break;
+	default:
+		return SSP_HAL_ERROR;
+	}
+
+	return SSP_HAL_OK;
+}
+#define SSP_HAL_CLK_HIGH                                 (1 << 0)
+#define SSP_HAL_CLK_LOW                                  (0 << 0)
+#define SSP_HAL_DATA_HIGH                                (1 << 1)
+#define SSP_HAL_DATA_LOW                                 (0 << 1)
+#define SSP_HAL_CS_HIGH                                  (1 << 2)
+#define SSP_HAL_CS_LOW                                   (0 << 2)
+#define SSP_HAL_INPUT_MODE                               (0 << 3)                        
+#define SSP_HAL_OUTPUT_MODE                              (1 << 3)                        
+#define SSP_HAL_DATA_REG                                 (1 << 4)
+#define SSP_HAL_ADDR_REG                                 (0 << 4)
+#define SSP_HAL_OPCODE_DIRECT                            ((0x0) << 5)
+#define SSP_HAL_OPCODE_TOGGLE                            ((0x1) << 5)
+#define SSP_HAL_OPCODE_SHIFT                             ((0x2) << 5)
+#define SSP_HAL_OPCODE_BRANCH0                           ((0x4) << 5)
+#define SSP_HAL_OPCODE_BRANCH1                           ((0x5) << 5)
+#define SSP_HAL_OPCODE_BRANCH                            ((0x6) << 5)
+#define SSP_HAL_OPCODE_STOP                              ((0x7) << 5)
+#define SSP_HAL_NOT_APPLICABLE                           0
+	
+#define SSP_HAL_BRANCH_ADDR_BIT_POS                      8
+#define SSP_HAL_CNT_VALUE_BIT_POS                        8
+#define SSP_HAL_BRANCH(addr)             ((addr)<<SSP_HAL_BRANCH_ADDR_BIT_POS)
+#define SSP_HAL_COUNT(cycles)            ((cycles)<<SSP_HAL_CNT_VALUE_BIT_POS)
+	
+unsigned int ssp_halp_spi_write_seq_map[] = 
+{
+	(SSP_HAL_COUNT(15)      |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_ADDR_REG
+		|SSP_HAL_OUTPUT_MODE         |SSP_HAL_CS_LOW
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_NOT_APPLICABLE
+	), 
+	
+	(SSP_HAL_NOT_APPLICABLE |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE
+		|SSP_HAL_OUTPUT_MODE         |SSP_HAL_CS_LOW
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW
+	),
+		0,0,0,0,0,0,0
+};
+	
+unsigned int ssp_halp_spi_read_seq_map[] = 
+	{
+	(SSP_HAL_COUNT(15)      |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_ADDR_REG
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_NOT_APPLICABLE
+	),  
+	
+	(SSP_HAL_NOT_APPLICABLE |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE
+		|SSP_HAL_OUTPUT_MODE         |SSP_HAL_CS_LOW
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW
+	),
+	0,0,0,0,0,0,0
+};
+	
+unsigned int ssp_halp_spi_stop_seq_map[] = 
+{
+	(SSP_HAL_NOT_APPLICABLE |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE
+		|SSP_HAL_OUTPUT_MODE         |SSP_HAL_CS_HIGH
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW
+	),
+	0,0,0,0,0,0
+}; 
+unsigned int ssp_halp_i2c_engine0_write_seq_map[] ={
+	
+/* 0x00 I2C pause */
+	( (0x00 << 8)           |SSP_HAL_OPCODE_STOP      |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE      |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH        |SSP_HAL_CLK_LOW       
+	),   
+	
+	/* 0x01 I2C pause */
+	( (0x00 << 8)           |SSP_HAL_OPCODE_STOP      |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE      |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH        |SSP_HAL_CLK_LOW       
+	),   
+	
+	/* 0x02 Initial state */
+	( (0x18 << 8)           |SSP_HAL_OPCODE_TOGGLE    |SSP_HAL_ADDR_REG   
+		|SSP_HAL_OUTPUT_MODE      |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH        |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x03 I2C start */
+	( (0x31 << 8)           |SSP_HAL_OPCODE_TOGGLE    |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE      |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW         |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x04 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x05 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x06 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x07 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x08 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x09 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0a I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0b I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0c I2C data */
+	( (0x17 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0d Branch on no Ack */
+	( (0x14 <<8)            |SSP_HAL_OPCODE_BRANCH1       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE           |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE       |SSP_HAL_CLK_HIGH     
+	),
+	
+	/* 0x0e I2C data */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0f I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x10 Pause with Ack */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP          |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW             |SSP_HAL_CLK_LOW     
+	),
+	
+	/* 0x11 I2C data */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x12 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x13 Pause with Ack */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP          |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW     
+	),
+	
+	/* 0x14 I2C pause */
+	( (0x00 << 8)           |SSP_HAL_OPCODE_STOP      |SSP_HAL_NOT_APPLICABLE
+		|SSP_HAL_OUTPUT_MODE      |SSP_HAL_CS_LOW
+		|SSP_HAL_DATA_HIGH        |SSP_HAL_CLK_LOW
+	)
+	
+	
+	};
+	
+	unsigned int ssp_halp_i2c_engine0_read_seq_map[] ={
+	
+	/* 0x00 I2C pause */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),   
+	
+	/* 0x01 I2C pause */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),   
+	
+	/* 0x02 i2c start */
+	( (0x1a <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x03 write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x04 i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x05 write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x06 i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x07 write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x08 i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x09 write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0a i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x0b write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0c i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x0d write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0e i2c start */
+	( (0x30 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x0f write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x10 i2c start */
+	( (0x14 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x11 i2c start */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),
+	
+	/* 0x12 i2c start */
+	( (0x14 <<8)            |SSP_HAL_OPCODE_TOGGLE       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW      
+	),  
+	
+	/* 0x13 write device address byte */
+	( (0x01 <<8)            |SSP_HAL_OPCODE_SHIFT        |SSP_HAL_DATA_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_NOT_APPLICABLE      |SSP_HAL_CLK_LOW       
+	),      
+	
+	/* 0x14 i2c start */
+	( (0x25 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_INPUT_MODE           |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW
+	),
+	
+	/* 0x15 i2c start */                                    
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP          |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE           |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH             |SSP_HAL_CLK_LOW
+	),                                                
+	
+	/* 0x16 i2c BR to stop */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_DIRECT       |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE         |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	)
+	};
+	
+	unsigned int ssp_halp_i2c_engine1_seq_map[] ={
+	
+	/* 0x00 I2C pause */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_DIRECT        |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),   
+	
+	/* 0x01 I2C start */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG  
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x02 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW             |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x03 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x04 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x05 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x06 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x07 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x08 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x09 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0a toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0b toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0c toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0d toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0e toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x0f toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x10 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x11 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x12 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x13 toggle */    
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x14 toggle */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x15 normal stop  */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP         |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE         |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH           |SSP_HAL_CLK_HIGH      
+	),
+	
+	/* 0x16 I2C data */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x17 I2C data */
+	( (0x31 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x18 Pause with Ack */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP          |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_OUTPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW     
+	),
+	
+	
+	/* 0x19 I2C data */
+	( (0x18 <<8)            |SSP_HAL_OPCODE_TOGGLE        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_LOW            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x1a branch */
+	( (0x19 <<8)            |SSP_HAL_OPCODE_BRANCH0        |SSP_HAL_ADDR_REG 
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW       
+	),  
+	
+	/* 0x1b Pause */
+	( (0x00 <<8)            |SSP_HAL_OPCODE_STOP          |SSP_HAL_NOT_APPLICABLE     
+		|SSP_HAL_INPUT_MODE          |SSP_HAL_CS_LOW 
+		|SSP_HAL_DATA_HIGH            |SSP_HAL_CLK_LOW     
+	)
+	
+	};
+	
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/titan_board_setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/titan_board_setup.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ * Copyright (C) 2006 Montavista Software Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+	
+#include <linux/config.h>
+#include <pal.h>
+	
+void avalanche_set_vbus_freq(unsigned int new_vbus_freq);
+void vlynq_dev_init(void);
+	
+static void avalanche_display_titan_variant( int titan_variant )
+{
+	char    *type_str;    
+	
+	/* Display Titan variant */
+	switch(titan_variant)
+	{
+	case TITAN_1050:
+		type_str = "TNETV1050";
+		break;
+	
+	case TITAN_1055:
+		type_str = "TNETV1055";
+		break;
+	
+	case TITAN_1056:
+		type_str = "TNETV1056";
+		break;
+	
+	case TITAN_1060:
+		type_str = "TNETV1060";
+		break;
+	
+	default:
+		type_str = "Unknown";
+		printk("titan_type val is 0x%x\n",titan_variant);
+	}
+	
+	printk("%s Communication Processor detected\n", type_str );
+}
+	
+void avalanche_soc_platform_init(void)
+{
+	volatile PIN_SEL_REG_ARRAY_T *pin_sel_array = 
+				(PIN_SEL_REG_ARRAY_T*) AVALANCHE_PIN_SEL_BASE;
+	volatile unsigned int *eswitch_control_reg  = 
+				(unsigned int*) AVALANCHE_ESWITCH_CONTROL;
+	PAL_SYS_Tnetv1050Init clkc;
+	
+	/* Get entities on the board out of reset. */
+	avalanche_reset_ctrl( AVALANCHE_ESWITCH_RESET_BIT, OUT_OF_RESET ); 
+	avalanche_reset_ctrl( AVALANCHE_LOW_EPHY_RESET_BIT, OUT_OF_RESET );
+	avalanche_reset_ctrl( AVALANCHE_HIGH_EPHY_RESET_BIT, OUT_OF_RESET );
+	
+	avalanche_gpio_init();
+	
+	avalanche_display_titan_variant( avalanche_get_board_variant() );    
+	
+	pin_sel_array->reg[3] &= ~0xff000000;  /* Gpio bits:    b 1111 1111 xxxx xxxx xxxx xxxx xxxx xxxx */
+	pin_sel_array->reg[3] |=  0x55000000;  /* Bit setting:  b 0101 0101 xxxx xxxx xxxx xxxx xxxx xxxx */  
+	
+	pin_sel_array->reg[4] &= ~0x00003fc0;  /* Gpio bits:    b xxxx xxxx xxxx xxxx xx11 1111 11xx xxxx */
+	pin_sel_array->reg[4] |=  0x00001540;  /* Bit setting:  b xxxx xxxx xxxx xxxx xx01 0101 01xx xxxx */
+	
+	pin_sel_array->reg[9] &= ~0xf03f0000;  /* Eth LED bits: b 1111 xxxx xx11 1111 xxxx xxxx xxxx xxxx */
+	pin_sel_array->reg[9] |=  0x50150000;  /* Bit setting:  b 0101 xxxx xx01 0101 xxxx xxxx xxxx xxxx */
+	
+	pin_sel_array->reg[10] &= ~0x0000003f;  /* Eth LED bits: b xxxx xxxx xxxx xxxx xxxx xxxx xx11 1111 */
+	pin_sel_array->reg[10] |=  0x00000015;  /* Bit setting:  b xxxx xxxx xxxx xxxx xxxx xxxx xx01 0101 */ 
+	
+	clkc.audclk = AUDCLK_FREQ;
+	clkc.refclk = REFCLK_FREQ;
+	clkc.altclk = ALTCLK_FREQ;
+	avalanche_clkc_init(&clkc);
+	
+	avalanche_set_vbus_freq(avalanche_clkc_getfreq(CLKC_VBUS));
+	
+	*eswitch_control_reg = 0x010000ce;    
+}
Index: linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/titan_clk_cntl.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/mips-boards/ti_avalanche/ti_titan/titan_clk_cntl.c
@@ -0,0 +1,998 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc.
+ *
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ * Copyright (C) 2006 Montavista Software Inc.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+	
+#include <asm/mach-avalanche/pal.h>
+	
+#define MIN(x,y)               ( ((x) <  (y)) ? (x) : (y) )
+#define MAX(x,y)               ( ((x) >  (y)) ? (x) : (y) )
+#define ABS(x)                 ( ((signed)(x) > 0) ? (x) : (-(x)) )
+#define QUOTIENT(x,y)              ( ((x) + (y) / 2) / (y) )
+	
+#define CLKC_NUM               6
+	
+#define CLKC_PRE_DIVIDER        0x001F0000
+#define CLKC_POST_DIVIDER       0x0000001F
+	
+#define CLKC_PLL_STATUS         0x1
+#define CLKC_PLL_FACTOR         0x0000F000
+	
+#define BOOTCR_PLL_BYPASS       (1 << 5)
+#define BOOTCR_MIPS_ASYNC_MODE  (1 << 25)
+#define BOOTCR_VBUS_MUXSEL      (1 << 27)
+	
+#define MIPS_PLL_SELECT         0x01800000
+#define VBUS_PLL_SELECT         0x0000C000
+#define USB_PLL_SELECT          0x00030000
+#define ETH_INPUT_SELECT        0x000C0000
+#define DSP_INPUT_SELECT        0x00300000
+	
+#define USB_MODE_SELECT         0x00400000
+#define VBUS_MUX_SELECT         0x08000000
+	
+#define MIPS_AUDCLKI_SELECT     0x00000000
+#define MIPS_REFCLKI_SELECT     0x00800000
+#define MIPS_ALTIN_SELECT       0x01000000
+	
+#define VBUS_AUDCLKI_SELECT   0x00000000
+#define VBUS_REFCLKI_SELECT   0x00004000
+#define VBUS_ALTIN_SELECT     0x00008000
+#define VBUS_MIPSPLL_SELECT   0x0000C000
+	
+#define USB_AUDCLKI_SELECT      0x00000000
+#define USB_REFCLKI_SELECT      0x00010000
+#define USB_ALTIN_SELECT        0x00020000
+#define USB_MIPSPLL_SELECT      0x00030000
+	
+#define  SYS_MAX                CLK_MHZ(150)
+#define  SYS_MIN                CLK_MHZ(1)
+	
+#define VBUS_MAX                SYS_MAX/2
+#define VBUS_MIN                SYS_MIN
+	
+#define  MIPS_SYNC_MAX          SYS_MAX
+#define  MIPS_ASYNC_MAX         CLK_MHZ(165)
+#define  MIPS_MIN               CLK_MHZ(1)
+	
+#define  USB_MAX                CLK_MHZ(100)
+#define  USB_MIN                CLK_MHZ(1)
+	
+#define  LCD_MAX                CLK_MHZ(100)
+#define  LCD_MIN                CLK_MHZ(1)
+	
+#define  PLL_MUL_MAXFACTOR      15
+#define  MAX_DIV_VALUE          32
+#define  MIN_DIV_VALUE          1
+	
+#define  MIN_PLL_INP_FREQ       CLK_MHZ(8)
+#define  MAX_PLL_INP_FREQ       CLK_MHZ(100)
+	
+#define  DIVIDER_LOCK_TIME      (10100)
+#define  PLL_LOCK_TIME          (10100 * 75)
+	
+typedef struct CLKC_STRUCT_tag
+{
+	unsigned int clkcr_reg;
+	unsigned int reserved1[3];
+	unsigned int clkpllcr_reg;
+	unsigned int reserved2[3];
+} CLKC_STRUCT_T;
+	
+	
+typedef struct PAL_SYS_CLKC_STRUCT_tag
+{
+	CLKC_STRUCT_T clk[CLKC_NUM];
+} PAL_SYS_CLKC_STRUCT_T;
+	
+static volatile PAL_SYS_CLKC_STRUCT_T *pclk_regs;
+static volatile int  *bootcr_reg;
+static unsigned int *clk_pll_src[CLKC_NUM];
+static unsigned int clk_to_pll[CLKC_NUM];
+static unsigned int mips_pll_out;
+static unsigned int audclk_inp;
+static unsigned int refclk_inp;
+static unsigned int alt_inp;
+static unsigned int present_min;
+static unsigned int present_max;
+	
+static unsigned int find_gcd(unsigned int min, unsigned int max);
+static unsigned int compute_prediv( unsigned int divider, unsigned int min, unsigned int max);
+static void get_val(unsigned int base_freq, unsigned int output_freq,unsigned int *multiplier, unsigned int *divider);
+static unsigned int get_base_frequency(PAL_SYS_CLKC_ID_T clk_id);
+static void find_approx(unsigned int *,unsigned int *,unsigned int);
+static int validate_arg(PAL_SYS_CLKC_ID_T clk_id,int output_freq);
+static void usb_clk_check(void);
+static int set_pll_div(PAL_SYS_CLKC_ID_T clk_id, unsigned int output_freq);
+static unsigned int get_pll_div(PAL_SYS_CLKC_ID_T clk_id);
+	
+void avalanche_clkc_init(void* param)
+{
+	unsigned int choice;               
+	
+	PAL_SYS_Tnetv1050Init* ptr = (PAL_SYS_Tnetv1050Init *)param;                                   
+	audclk_inp = ptr->audclk;                                          
+	refclk_inp = ptr->refclk;                                        
+	alt_inp 	= ptr->altclk;                                          
+	
+	pclk_regs = (volatile PAL_SYS_CLKC_STRUCT_T *)(AVALANCHE_CLOCK_CONTROL_BASE + 0x20); 
+	bootcr_reg = (volatile int *)AVALANCHE_DCL_BOOTCR;
+	
+	choice = (*bootcr_reg) & MIPS_PLL_SELECT;
+	switch(choice)
+	{
+	case MIPS_AUDCLKI_SELECT:
+		clk_pll_src[CLKC_MIPS] = &audclk_inp;
+		break;
+	
+	case MIPS_REFCLKI_SELECT:
+		clk_pll_src[CLKC_MIPS] = &refclk_inp;
+		break;
+	
+	case MIPS_ALTIN_SELECT:
+		clk_pll_src[CLKC_MIPS] = &alt_inp;
+		break;
+	
+	default :
+		clk_pll_src[CLKC_MIPS] = 0;
+	
+	}
+	choice = (*bootcr_reg) & VBUS_PLL_SELECT;
+	switch(choice)
+	{
+	case VBUS_AUDCLKI_SELECT:
+		clk_pll_src[CLKC_VBUS] = &audclk_inp;
+		break;
+	
+	case VBUS_REFCLKI_SELECT:
+		clk_pll_src[CLKC_VBUS] = &refclk_inp;
+		break;
+	
+	case VBUS_ALTIN_SELECT:
+		clk_pll_src[CLKC_VBUS] = &alt_inp;
+		break;
+	
+	case VBUS_MIPSPLL_SELECT:
+		clk_pll_src[CLKC_VBUS] = &mips_pll_out;
+		break;
+	
+	default :
+		clk_pll_src[CLKC_VBUS] = 0;
+	
+	}
+	
+	choice = (*bootcr_reg) & USB_PLL_SELECT;
+	switch(choice)
+	{
+	case USB_AUDCLKI_SELECT:
+		clk_pll_src[CLKC_USB] = &audclk_inp;
+		break;
+	
+	case USB_REFCLKI_SELECT:
+		clk_pll_src[CLKC_USB] = &refclk_inp;
+		break;
+	
+	case USB_ALTIN_SELECT:
+		clk_pll_src[CLKC_USB] = &alt_inp;
+		break;
+	
+	case USB_MIPSPLL_SELECT:
+		clk_pll_src[CLKC_USB] = &mips_pll_out;
+		break;
+	
+	default :
+		clk_pll_src[CLKC_USB] = 0;
+	
+	}
+	
+	clk_to_pll[CLKC_VBUS] =   \
+	(BOOTCR_VBUS_MUXSEL & (*bootcr_reg)) ? CLKC_MIPS: CLKC_VBUS; 
+	
+	clk_to_pll[CLKC_MIPS] =   \
+	(BOOTCR_MIPS_ASYNC_MODE & (*bootcr_reg)) ? CLKC_MIPS: CLKC_VBUS; 
+	
+	clk_to_pll[CLKC_USB] = CLKC_USB;
+	clk_to_pll[CLKC_LCD] = CLKC_VBUS;
+	clk_to_pll[CLKC_VBUSP] = CLKC_VBUS;
+}
+	
+int avalanche_clk_setfreq(PAL_SYS_CLKC_ID_T clk_id, unsigned int output_freq)
+{
+	int pll_id;
+	
+	if(CLKC_SYS == clk_id)
+		clk_id = CLKC_VBUSP;
+	
+	if(clk_id >= CLKC_NUM)
+		return -1;
+
+	pll_id = clk_to_pll[clk_id];
+	
+	if(pll_id == CLKC_VBUS)
+	return -1;
+	
+	if( (clk_id == CLKC_USB) && (CLK_MHZ(48) == output_freq) )
+		usb_clk_check();  
+	
+	return set_pll_div(pll_id,output_freq);
+}
+	
+int avalanche_clkc_getfreq(PAL_SYS_CLKC_ID_T clk_id)
+{
+	int pll_id;
+	int output_freq;
+	
+	if(clk_id >= CLKC_NUM)
+		return -1;
+	
+	if(CLKC_SYS == clk_id)
+		clk_id = CLKC_VBUSP;
+	
+	pll_id = clk_to_pll[clk_id];
+	
+	output_freq = get_pll_div(pll_id);
+	
+	if(clk_id == CLKC_VBUS)
+		output_freq >>= 1;
+	
+	return output_freq;
+	
+}
+	
+static int set_pll_div(PAL_SYS_CLKC_ID_T clk_id,unsigned int output_freq)
+{
+	unsigned int base_freq;
+	unsigned int multiplier;
+	unsigned int divider;
+	unsigned int min_prediv;
+	unsigned int max_prediv;
+	unsigned int prediv;
+	unsigned int postdiv;
+	int ret =0;
+	volatile unsigned int temp;
+	
+	if( validate_arg(clk_id,output_freq) == -1)
+		return -1;
+	
+	
+	if( (clk_id == CLKC_USB) && (CLK_MHZ(48) == output_freq) )
+		usb_clk_check();  
+	
+	base_freq = get_base_frequency(clk_id);
+	
+	if( base_freq < MIN_PLL_INP_FREQ)
+	{
+		return -1;
+	}
+	
+	get_val(output_freq, base_freq, &multiplier, &divider);
+	
+	if( (multiplier  > PLL_MUL_MAXFACTOR) || (multiplier <= 0) )
+	{
+		return -1;
+	}
+	
+	if( divider == 0 )
+	{
+		return -1;
+	}
+	
+	min_prediv = MAX(base_freq / MAX_PLL_INP_FREQ + 1, divider / MAX_DIV_VALUE + 1);
+	max_prediv = MIN(base_freq / MIN_PLL_INP_FREQ, MAX_DIV_VALUE);
+	
+	if (divider < min_prediv)
+	{
+		temp = QUOTIENT(min_prediv, divider);
+		if ((temp * multiplier) > PLL_MUL_MAXFACTOR)
+		{
+			return -1  ;
+		}
+		else
+		{
+			multiplier = temp * multiplier;
+			divider = min_prediv;
+		}
+	}
+	
+	prediv = compute_prediv (divider, min_prediv, max_prediv);
+	postdiv = QUOTIENT(divider,prediv);
+	
+	if(postdiv > MAX_DIV_VALUE)
+	{
+		return -1;
+	}
+	
+	if( (base_freq * multiplier) != (output_freq * prediv * postdiv))
+		ret = 1; /* Approximate frequency value  is set */
+	
+	pclk_regs->clk[clk_id].clkcr_reg = ( ((prediv -1) & 0x1F) << 16) |
+	((postdiv -1) & 0x1F);
+	
+	
+	for(temp =0; temp < DIVIDER_LOCK_TIME; temp++);
+	
+	pclk_regs->clk[clk_id].clkpllcr_reg = 0x4;
+	multiplier = (((multiplier - 1) & 0xf) << 12)| ((255 <<3) | 0x0e);
+	while((pclk_regs->clk[clk_id].clkpllcr_reg) & CLKC_PLL_STATUS)
+		/*nothing*/;
+	
+	pclk_regs->clk[clk_id].clkpllcr_reg = multiplier;
+	
+	while(!((pclk_regs->clk[clk_id].clkpllcr_reg) & CLKC_PLL_STATUS))
+		/*nothing*/;
+	
+	for(temp =0; temp < PLL_LOCK_TIME; temp++);
+	
+	return ret;
+}
+	
+static unsigned int get_pll_div(PAL_SYS_CLKC_ID_T clk_id)
+{
+	unsigned int  clk_ctrl_register;
+	unsigned int  clk_pll_setting;
+	unsigned int  clk_predivider;
+	unsigned int  clk_postdivider;
+	unsigned short  pll_factor;
+	unsigned int  base_freq;
+	unsigned int  divider;
+	
+	base_freq = get_base_frequency(clk_id);
+	
+	clk_ctrl_register = pclk_regs->clk[clk_id].clkcr_reg;
+	clk_postdivider = (CLKC_POST_DIVIDER & clk_ctrl_register) + 1;
+	clk_predivider = ((CLKC_PRE_DIVIDER & clk_ctrl_register) >> 16) + 1;
+	
+	divider =  clk_predivider * clk_postdivider;
+	
+	if( ((*bootcr_reg) & BOOTCR_PLL_BYPASS))
+	{
+		return (QUOTIENT(base_freq, divider));  /* PLLs bypassed.*/
+	}
+	else
+	{
+		clk_pll_setting = pclk_regs->clk[clk_id].clkpllcr_reg;
+	
+		pll_factor = ((clk_pll_setting & CLKC_PLL_FACTOR) >> 12) + 1;
+	
+		if((clk_pll_setting & 0x1)   == 0)
+		{
+			if(pll_factor <  0x10)
+				return (QUOTIENT(base_freq >> 1, divider));
+			else
+				return (QUOTIENT(base_freq >> 2, divider));
+		}
+	
+		else     /* We're in PLL mode */
+		{
+			if((clk_pll_setting & 0x0800) && (clk_pll_setting & 0x2))
+			{
+				if( pll_factor & 0x1 )
+				{
+					return(QUOTIENT((base_freq * pll_factor) >> 1, divider));
+				}
+				else
+				{
+					return(QUOTIENT((base_freq * (pll_factor - 1)) >>2, divider));
+				}
+			}
+			else
+			{
+				if(pll_factor < 0x10)
+				{
+					return(QUOTIENT(base_freq * pll_factor, divider));
+				}
+				else
+				{
+					return(QUOTIENT(base_freq, divider));
+				}
+			}
+		}
+		
+		return(0); /* Should never reach here */
+	}
+}
+	
+static unsigned int get_base_frequency(PAL_SYS_CLKC_ID_T clk_id)
+{
+	if ( clk_pll_src[clk_id] == &mips_pll_out)
+	{
+		*clk_pll_src[clk_id] = get_pll_div(CLKC_MIPS);
+	}
+	
+	return (*clk_pll_src[clk_id]);
+}
+	
+static unsigned int find_gcd(unsigned int min,unsigned int max)
+{
+	if (max % min == 0)
+	{
+		return min;
+	}
+	else
+	{
+		return find_gcd(max % min, min);
+	}
+}
+	
+static unsigned int compute_prediv(unsigned int divider, unsigned int min, unsigned int max)
+{
+	unsigned short prediv;
+	if (min <= divider && divider <= max)
+	{
+		return divider;
+	}
+	
+	for (prediv = max; prediv >= min ; prediv--)
+	{
+		if ( (divider % prediv) == 0 )
+		{
+			return prediv;
+		}
+	}
+	
+	return min;
+}
+	
+static void get_val(unsigned int output_freq, unsigned int base_freq, unsigned int *multiplier, unsigned int *divider)
+{
+	unsigned int temp_mul;
+	unsigned int temp_div;
+	unsigned int gcd;
+	unsigned int min_freq;
+	unsigned int max_freq;
+	
+	min_freq = (base_freq < output_freq) ? base_freq : output_freq;
+	max_freq = (base_freq > output_freq) ? base_freq : output_freq;
+	gcd = find_gcd(min_freq , max_freq);
+	
+	if(gcd == 0)
+		return;  /* ERROR */
+	
+	temp_mul = output_freq / gcd;
+	temp_div = base_freq / gcd;
+	
+	if( temp_mul > PLL_MUL_MAXFACTOR )
+	{
+		if((temp_mul / temp_div) > PLL_MUL_MAXFACTOR)
+			return;
+	
+		find_approx(&temp_mul,&temp_div,base_freq);
+	}
+	
+	*multiplier = temp_mul;
+	*divider    = temp_div;
+}
+	
+static void find_approx(unsigned int *num, unsigned int *denom, unsigned int base_freq)
+{
+	unsigned int num1;
+	unsigned int denom1;
+	unsigned int num2;
+	unsigned int denom2;
+	int closest;
+	int prev_closest;
+	unsigned int temp_num;
+	unsigned int temp_denom;
+	unsigned int normalize;
+	unsigned int gcd;
+	unsigned int output_freq;
+	
+	num1 = *num;
+	denom1 = *denom;
+	
+	prev_closest = 0x7fffffff; /* maximum possible value */
+	num2 = num1;
+	denom2 = denom1;
+	
+	for(temp_num = 15; temp_num >=1; temp_num--)
+	{
+		temp_denom = QUOTIENT(temp_num * denom1, num1);
+		output_freq = (temp_num * base_freq) / temp_denom;
+	
+		if(temp_denom < 1)
+		{
+			break;
+		}
+		else
+		{
+			normalize = QUOTIENT(num1,temp_num);
+			closest = (ABS((num1 * (temp_denom) ) - (temp_num * denom1)))  * normalize;
+			if(closest < prev_closest && output_freq > present_min && output_freq <present_max)
+			{
+				prev_closest = closest;
+				num2 = temp_num;
+				denom2 = temp_denom;
+			}
+		}
+	}
+	
+	gcd = find_gcd(num2,denom2);
+	num2 = num2 / gcd;
+	denom2 = denom2 /gcd;
+	
+	*num      = num2;
+	*denom    = denom2;
+}
+	
+static int validate_arg(PAL_SYS_CLKC_ID_T clk_id,int output_freq)
+{
+	if((*bootcr_reg)  & BOOTCR_PLL_BYPASS)
+	{
+		return -1;
+	}
+	
+	switch( clk_id )
+	{
+	case CLKC_VBUS:
+		if((output_freq < VBUS_MIN) ||
+			(output_freq > ((*bootcr_reg) & BOOTCR_VBUS_MUXSEL) ? (MIPS_ASYNC_MAX/2): (MIPS_SYNC_MAX/2)))
+		{
+			return -1;
+		}
+		present_min = VBUS_MIN;
+		present_max = ( (*bootcr_reg) & BOOTCR_VBUS_MUXSEL) ? (MIPS_ASYNC_MAX/2):(MIPS_SYNC_MAX/2);
+		break;
+	
+	case CLKC_MIPS:
+		if((output_freq < MIPS_MIN) ||
+			(output_freq > ( (*bootcr_reg) & BOOTCR_MIPS_ASYNC_MODE) ? MIPS_ASYNC_MAX: MIPS_SYNC_MAX))
+		{
+			return -1;
+		}
+		present_min = MIPS_MIN;
+		present_max = ((*bootcr_reg) & BOOTCR_MIPS_ASYNC_MODE) ? MIPS_ASYNC_MAX: MIPS_SYNC_MAX;
+		break;
+	
+	case CLKC_USB:
+		if( (output_freq < USB_MIN) || (output_freq > USB_MAX))
+		{
+			return -1;
+		}
+		present_min = USB_MIN;
+		present_max = USB_MAX;
+		break;
+	
+	case CLKC_LCD:
+		if( (output_freq < LCD_MIN) || (output_freq > LCD_MAX))
+		{
+			return -1;
+		}
+		break;
+	
+	case CLKC_VBUSP:
+		if( (output_freq < SYS_MIN) || (output_freq > SYS_MAX))
+		{
+			return -1;
+		}
+		present_min = SYS_MIN;
+		present_max = SYS_MAX;
+		break;
+	
+	default:
+		return -1;
+	}
+	return 0;
+}
+	
+static void usb_clk_check(void)
+{
+	if(clk_pll_src[CLKC_USB] == &mips_pll_out)
+	{
+		if(!( (*bootcr_reg) & BOOTCR_MIPS_ASYNC_MODE) )
+		{
+			if(get_base_frequency(CLKC_MIPS) == CLK_MHZ(25)) 
+				set_pll_div(CLKC_MIPS,CLK_MHZ(150));
+		}
+	}
+}
+	
+#define    IOMUX_GPIO      0    /* GPIO */
+#define    IOMUX_LCD       1    /* LCD */
+#define    IOMUX_KEYPAD    2    /* Keypad */
+#define    IOMUX_PHY       3    /* PHY */
+#define    IOMUX_SSP       4    /* SSP */
+#define    IOMUX_MARVEL    5    /* MARVEL */
+	
+static void avalanche_iomux_enable(unsigned int module)
+{
+	volatile PIN_SEL_REG_ARRAY_T *pin_sel_array = (PIN_SEL_REG_ARRAY_T*) AVALANCHE_PIN_SEL_BASE;
+	
+	switch (module)
+	{
+	case IOMUX_GPIO:
+		pin_sel_array->reg[3] &= ~0xff000000;  
+		pin_sel_array->reg[3] |=  0x55000000;  
+	
+		pin_sel_array->reg[4] &= ~0x00003fc0;  
+		pin_sel_array->reg[4] |=  0x00001540;  
+		break;
+	
+	case IOMUX_LCD:
+		pin_sel_array->reg[7] &= ~0xcc000000;  
+		pin_sel_array->reg[7] |=  0x44000000;  
+		
+		pin_sel_array->reg[8] &= ~0xff3cff3f;  
+		pin_sel_array->reg[8] |=  0x55145515;  
+	
+		pin_sel_array->reg[9] &= ~0x0000ff0f;  
+		pin_sel_array->reg[9] |=  0x00005505;  
+		break;
+	
+	case IOMUX_KEYPAD:
+		pin_sel_array->reg[6] &= ~0xfcffc000;  
+		pin_sel_array->reg[6] |=  0x54554000;  
+	
+		pin_sel_array->reg[7] &= ~0x003fcc3f;  
+		pin_sel_array->reg[7] |=  0x00154415;  
+		break;
+	
+	case IOMUX_PHY:
+		pin_sel_array->reg[9]  &= ~0xf03f0000;  
+		pin_sel_array->reg[9]  |=  0x50150000;  
+	
+		pin_sel_array->reg[10] &= ~0x0000003f;  
+		pin_sel_array->reg[10] |=  0x00000015;  
+		break;
+	
+	case IOMUX_SSP:
+		pin_sel_array->reg[0] &= ~0x000ff000;  
+		pin_sel_array->reg[0] |=  0x00055000;  
+	
+		pin_sel_array->reg[4] |=  0x00000300;
+		break;
+	
+	case IOMUX_MARVEL:
+		pin_sel_array->reg[4] &= ~0x00000c00;  
+		pin_sel_array->reg[4] |=  0x00000400;
+	
+		pin_sel_array->reg[8] &= ~0xff3cff3f;
+		pin_sel_array->reg[8] |=  0xaa28aa28;
+	
+		pin_sel_array->reg[9] &= ~0x0000ff0f;
+		pin_sel_array->reg[9] |=  0x0000aa0a; 
+		break;
+	}
+	
+	return;
+}
+	
+BOARD_INFO_T soc[] = 
+{
+	/* 1050 */
+	{ 
+	{
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_LOW_CPMAC_BASE},
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_HIGH_CPMAC_BASE},
+	{AVALANCHE_USB_1_1_DEVICE_HW_MODULE_REV,  AVALANCHE_USB_SLAVE_CONTROL_BASE},
+	{AVALANCHE_USB_1_1_HOST_HW_MODULE_REV,    AVALANCHE_USB_MASTER_CONTROL_BASE},
+	{AVALANCHE_LCD_HW_MODULE_REV,             AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_GLCD_HW_MODULE_REV,            AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_KEYPAD_HW_MODULE_REV,          AVALANCHE_KEYPAD_CONTROL_BASE},
+	{AVALANCHE_INT_ESWITCH_HW_MODULE_REV,     AVALANCHE_ESWITCH_BASE},
+	{AVALANCHE_SSP_HW_MODULE_REV,             AVALANCHE_SSP_BASE},
+	{0, 0}
+	}
+	},
+	/* 1055 */
+	{ 
+	{
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_LOW_CPMAC_BASE},
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_HIGH_CPMAC_BASE},
+	{AVALANCHE_LCD_HW_MODULE_REV,             AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_GLCD_HW_MODULE_REV,            AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_KEYPAD_HW_MODULE_REV,          AVALANCHE_KEYPAD_CONTROL_BASE},
+	{AVALANCHE_INT_ESWITCH_HW_MODULE_REV,     AVALANCHE_ESWITCH_BASE},
+	{AVALANCHE_SSP_HW_MODULE_REV,             AVALANCHE_SSP_BASE},
+	{0, 0},
+	{0, 0},
+	{0, 0}
+	}
+	},
+	
+	/* 1056 */
+	{ 
+	{
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_LOW_CPMAC_BASE},
+	{AVALANCHE_LCD_HW_MODULE_REV,             AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_GLCD_HW_MODULE_REV,            AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_KEYPAD_HW_MODULE_REV,          AVALANCHE_KEYPAD_CONTROL_BASE},
+	{AVALANCHE_SSP_HW_MODULE_REV,             AVALANCHE_SSP_BASE},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0}
+	}
+	},
+	
+	/* 1060 */ /* NOTE: This list is not valid and will change */
+	{ 
+	{
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_LOW_CPMAC_BASE},
+	{AVALANCHE_CPMAC_HW_MODULE_REV,           AVALANCHE_HIGH_CPMAC_BASE},
+	{AVALANCHE_USB_1_1_DEVICE_HW_MODULE_REV,  AVALANCHE_USB_SLAVE_CONTROL_BASE},
+	{AVALANCHE_USB_1_1_HOST_HW_MODULE_REV,    AVALANCHE_USB_MASTER_CONTROL_BASE},
+	{AVALANCHE_LCD_HW_MODULE_REV,             AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_GLCD_HW_MODULE_REV,            AVALANCHE_LCD_CONTROL_BASE},
+	{AVALANCHE_KEYPAD_HW_MODULE_REV,          AVALANCHE_KEYPAD_CONTROL_BASE},
+	{AVALANCHE_SSP_HW_MODULE_REV,             AVALANCHE_SSP_BASE},
+	{0, 0},
+	{0, 0}
+	}
+	}
+};
+	
+static int avalanche_titan_variant( void )
+{
+	volatile PIN_SEL_REG_ARRAY_T *pin_sel_array = (PIN_SEL_REG_ARRAY_T*) AVALANCHE_PIN_SEL_BASE;
+	unsigned int new_val;
+	
+	pin_sel_array->reg[12] &= ~0xff000000;    /*Board settings : b 1111 1111 xxxx xxxx xxxx xxxx xxxx xxxx */
+	pin_sel_array->reg[12] |=  0xff000000;    /*bit setting    : b 1111 1111 xxxx xxxx xxxx xxxx xxxx xxxx */
+	
+	/* set GPIO 44 - 47 as input */
+	avalanche_gpio_ctrl(44, GPIO_PIN, GPIO_INPUT_PIN);
+	avalanche_gpio_ctrl(45, GPIO_PIN, GPIO_INPUT_PIN);
+	avalanche_gpio_ctrl(46, GPIO_PIN, GPIO_INPUT_PIN);
+	avalanche_gpio_ctrl(47, GPIO_PIN, GPIO_INPUT_PIN);
+	
+	/* read GPIO to get Titan variant type */
+	avalanche_gpio_invalue( &new_val, 1 );
+	
+	new_val >>= 12;
+	new_val &= 0x0f;
+	
+	switch ( new_val )
+	{
+	case TITAN_TYPE_1050:
+		return TITAN_1050;
+	
+	case TITAN_TYPE_1055:
+		return TITAN_1055;
+	
+	case TITAN_TYPE_1056:
+		return TITAN_1056;
+	
+	case TITAN_TYPE_1060:
+		return TITAN_1060;
+	
+	default:
+		break;
+	}
+	
+	return TITAN_1050;
+}
+	
+int avalanche_get_board_variant( void )
+{
+	static int init = 0;
+	static int board_type;
+	
+	if ( !init )
+	{
+		board_type = avalanche_titan_variant();
+		init = 1;
+	}
+	
+	return board_type;
+}
+	
+int avalanche_device_prepare(unsigned int module_id, unsigned int base_addr, BOARD_ID board_variant, void *param)
+{
+	switch (module_id)
+	{
+	case AVALANCHE_CPMAC_HW_MODULE_REV:
+		break;
+	
+	case AVALANCHE_SSP_HW_MODULE_REV:
+		avalanche_iomux_enable(IOMUX_SSP);
+		break;
+	
+	default:
+		return -1;
+	};
+
+	return 0;
+}
+
+typedef struct 
+{
+	int pinSelReg;
+	int shift;
+	int func;
+} GPIO_CFG;
+	
+GPIO_CFG gptable[]= {
+		      /* PIN_SEL_REG, START_BIT, GPIO_CFG_MUX_VALUE */
+		              {4,24,1},
+			      {4,26,1},
+			      {4,28,1},
+			      {4,30,1},
+			      {5,6,1},
+			      {5,8,1},
+			      {5,10,1},
+			      {5,12,1},
+			      {7,14,3},
+			      {7,16,3},
+			      {7,18,3},
+			      {7,20,3},
+			      {7,22,3},
+			      {7,26,3},
+			      {7,28,3},
+			      {7,30,3},
+			      {8,0,3},
+			      {8,2,3},
+			      {8,4,3},
+			      {8,10,3},
+			      {8,14,3},
+			      {8,16,3},
+			      {8,18,3},
+			      {8,20,3},
+			      {9,8,3},
+			      {9,10,3},
+			      {9,12,3},
+			      {9,14,3},
+			      {9,18,3},
+			      {9,20,3},
+			      {9,24,3},
+			      {9,26,3},
+			      {9,28,3},
+			      {9,30,3},
+			      {10,0,3},
+			      {10,2,3},
+			      {10,8,3},
+			      {10,10,3},
+			      {10,12,3},
+			      {10,14,3},
+			      {13,12,3},
+			      {13,14,3},
+			      {13,16,3},
+			      {13,18,3},
+			      {13,24,3},
+			      {13,26,3},
+			      {13,28,3},
+			      {13,30,3},
+			      {14,2,3},
+			      {14,6,3},
+			      {14,8,3},
+			      {14,12,3}
+};
+			      
+void avalanche_gpio_init(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	avalanche_reset_ctrl( AVALANCHE_GPIO_RESET_BIT, OUT_OF_RESET );
+	local_irq_restore(flags);
+}
+	
+int avalanche_gpio_ctrl(unsigned int gpio_pin, PAL_SYS_GPIO_PIN_MODE_T pin_mode,
+				PAL_SYS_GPIO_PIN_DIRECTION_T pin_direction)
+{
+	int reg_index = 0;
+	int mux_status;
+	GPIO_CFG  gpio_cfg;
+	volatile PIN_SEL_REG_ARRAY_T *pin_sel_array = (PIN_SEL_REG_ARRAY_T*) AVALANCHE_PIN_SEL_BASE;
+	volatile TITAN_GPIO_CONTROL_T   *gpio_cntl     = (TITAN_GPIO_CONTROL_T*) TITAN_GPIO_DATA_IN_0;
+		
+	if (gpio_pin > 51 )
+		return(-1);
+	
+	gpio_cfg = gptable[gpio_pin];
+	mux_status = (pin_sel_array->reg[gpio_cfg.pinSelReg - 1] >> gpio_cfg.shift) & 0x3;
+	
+	if(!((mux_status == 0 /* tri-stated */ ) || (mux_status == gpio_cfg.func /*GPIO functionality*/)))
+	{
+		return(-1); /* Pin have been configured for non GPIO funcs. */
+	}
+	
+	/* Set the pin to be used as GPIO. */
+	pin_sel_array->reg[gpio_cfg.pinSelReg - 1] |= ((gpio_cfg.func & 0x3) << gpio_cfg.shift);
+	
+	/* Check whether gpio refers to the first GPIO reg or second. */
+	if(gpio_pin > 31)
+	{
+		reg_index = 1;
+		gpio_pin -= 32;
+	}
+	
+	if(pin_mode)
+		gpio_cntl->enable[reg_index] |=  (1 << gpio_pin); /* Enable */
+	else
+		gpio_cntl->enable[reg_index] &= ~(1 << gpio_pin);
+	
+	if(pin_direction)
+		gpio_cntl->dir[reg_index] |=  (1 << gpio_pin); /* Input */
+	else
+		gpio_cntl->dir[reg_index] &= ~(1 << gpio_pin);
+	
+	return(0);
+	
+}/* end of function gpio_ctrl */
+	
+int PAL_sysGpioOutBit(unsigned int gpio_pin, int value)
+{
+	volatile TITAN_GPIO_CONTROL_T   *gpio_cntl     = (TITAN_GPIO_CONTROL_T*) TITAN_GPIO_DATA_IN_0;
+	unsigned int reg_index = 0;
+	
+	if(gpio_pin > 51)
+		return (-1);
+	
+	if(gpio_pin > 31)
+	{
+		gpio_pin -= 32;
+		reg_index = 1;
+	}	
+	
+	if(value)
+		gpio_cntl->data_out[reg_index] |=  (1 << gpio_pin);
+	else
+		gpio_cntl->data_out[reg_index] &=  ~(1 << gpio_pin);
+	
+	return (0);
+}/* end of function gpio_out */
+	
+	
+	//int PAL_sysGpioInBit(unsigned int gpio_pin)
+int avalanche_gpio_inbit(unsigned int gpio_pin)
+{
+	volatile TITAN_GPIO_CONTROL_T *gpio_cntl = 
+			(TITAN_GPIO_CONTROL_T*) TITAN_GPIO_DATA_IN_0;
+	unsigned int reg_index = 0;
+	
+	if(gpio_pin > 51)
+		return (-1);
+	
+	if(gpio_pin > 31)
+	{
+		gpio_pin -= 32;
+		reg_index = 1;
+	}	
+	
+	return ((gpio_cntl->data_in[reg_index] >> gpio_pin) & 0x1);
+	
+}/* end of function gpio_in */
+	
+	
+int avalanche_gpio_outvalue(unsigned int out_val, unsigned int out_mask, unsigned int reg_index)
+{
+	volatile TITAN_GPIO_CONTROL_T *gpio_cntl = 
+			(TITAN_GPIO_CONTROL_T*) TITAN_GPIO_DATA_IN_0;
+	
+	if(reg_index > 1)
+		return (-1);
+	
+	gpio_cntl->data_out[reg_index] &= ~out_mask;
+	gpio_cntl->data_out[reg_index] |= out_val & out_mask;
+		
+	return (-1);	    
+}
+	
+int avalanche_gpio_invalue(unsigned int *in_val, unsigned int reg_index)
+{
+	volatile TITAN_GPIO_CONTROL_T *gpio_cntl = 
+			(TITAN_GPIO_CONTROL_T*) TITAN_GPIO_DATA_IN_0;
+	
+	if(reg_index > 1)
+		return (-1);
+	
+	*in_val = gpio_cntl->data_in[reg_index];
+	
+	return (0);
+}
Index: linux-2.6.10/include/asm-mips/mach-avalanche/avalanche_intc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/avalanche_intc.h
@@ -0,0 +1,85 @@
+#ifndef _AVALANCHE_INTC_H
+#define _AVALANCHE_INTC_H
+
+#define MIPS_EXCEPTION_OFFSET 8
+
+#include <asm/mach-avalanche/pal.h>
+
+#define AVINTNUM(x) ((x) - MIPS_EXCEPTION_OFFSET)
+#define LNXINTNUM(x)((x) + MIPS_EXCEPTION_OFFSET)
+
+#define AVALANCHE_INT_END_PRIMARY      (40 + MIPS_EXCEPTION_OFFSET)
+#define AVALANCHE_INT_END_SECONDARY    (32 + AVALANCHE_INT_END_PRIMARY)
+
+#define AVALANCHE_INT_END_PRIMARY_REG1 32
+#define AVALANCHE_INT_END_PRIMARY_REG2 40
+
+#define AVALANCHE_INTC_END AVALANCHE_INT_END_SECONDARY
+#define AVALANCHE_INT_END             AVALANCHE_INTC_END
+#define AVALANCHE_ICTRL_REGS_BASE  AVALANCHE_INTC_BASE
+#define AVALANCHE_ECTRL_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0x80)
+#define AVALANCHE_IPACE_REGS_BASE  (AVALANCHE_ICTRL_REGS_BASE + 0xA0)
+#define AVALANCHE_CHCTRL_REGS_BASE (AVALANCHE_ICTRL_REGS_BASE + 0x200)
+
+struct avalanche_ictrl_regs 
+{
+  volatile unsigned long intsr1;    /* Interrupt Status/Set Register 1   0x00 */
+  volatile unsigned long intsr2;    /* Interrupt Status/Set Register 2   0x04 */
+  volatile unsigned long unused1;                                      /*0x08 */
+  volatile unsigned long unused2;                                      /*0x0C */
+  volatile unsigned long intcr1;    /* Interrupt Clear Register 1        0x10 */
+  volatile unsigned long intcr2;    /* Interrupt Clear Register 2        0x14 */
+  volatile unsigned long unused3;                                      /*0x18 */
+  volatile unsigned long unused4;                                      /*0x1C */
+  volatile unsigned long intesr1;   /* Interrupt Enable (Set) Register 1 0x20 */
+  volatile unsigned long intesr2;   /* Interrupt Enable (Set) Register 2 0x24 */
+  volatile unsigned long unused5;                                      /*0x28 */
+  volatile unsigned long unused6;                                      /*0x2C */
+  volatile unsigned long intecr1;   /* Interrupt Enable Clear Register 1 0x30 */
+  volatile unsigned long intecr2;   /* Interrupt Enable Clear Register 2 0x34 */
+  volatile unsigned long unused7;                                     /* 0x38 */
+  volatile unsigned long unused8;                                     /* 0x3c */
+  volatile unsigned long pintir;    /* Priority Interrupt Index Register 0x40 */
+  volatile unsigned long intmsr;    /* Priority Interrupt Mask Index Reg 0x44 */
+  volatile unsigned long unused9;                                     /* 0x48 */
+  volatile unsigned long unused10;                                    /* 0x4C */
+  volatile unsigned long intpolr1;  /* Interrupt Polarity Mask register 10x50 */
+  volatile unsigned long intpolr2;  /* Interrupt Polarity Mask register 20x54 */
+  volatile unsigned long unused11;                                    /* 0x58 */
+  volatile unsigned long unused12;                                   /*0x5C */
+  volatile unsigned long inttypr1;  /* Interrupt Type     Mask register 10x60 */
+  volatile unsigned long inttypr2;  /* Interrupt Type     Mask register 20x64 */
+};
+
+struct avalanche_exctrl_regs   /* Avalanche Exception control registers */
+{
+  volatile unsigned long exsr;      /* Exceptions Status/Set register    0x80 */
+  volatile unsigned long reserved;                                     /*0x84 */
+  volatile unsigned long excr;      /* Exceptions Clear Register         0x88 */
+  volatile unsigned long reserved1;                                    /*0x8c */
+  volatile unsigned long exiesr;    /* Exceptions Interrupt Enable (set) 0x90 */
+  volatile unsigned long reserved2;                                    /*0x94 */
+  volatile unsigned long exiecr;    /* Exceptions Interrupt Enable(clear)0x98 */
+};
+struct avalanche_ipace_regs
+{
+
+  volatile unsigned long ipacep;    /* Interrupt pacing register         0xa0 */
+  volatile unsigned long ipacemap;  /*Interrupt Pacing Map Register      0xa4 */
+  volatile unsigned long ipacemax;  /*Interrupt Pacing Max Register      0xa8 */
+};
+struct avalanche_channel_int_number
+{
+  volatile unsigned long cintnr[40];   /* Channel Interrupt Number Registers */
+};
+
+struct avalanche_interrupt_line_to_channel
+{
+  unsigned long int_line[40];    /* Start of primary interrupts */
+};
+
+extern void avalanche_int_set(int channel, int line);
+int avalanche_intr_polarity_set(unsigned int irq_nr, unsigned long type_val);
+int avalanche_intr_polarity_get(unsigned int irq_nr);
+
+#endif /* _AVALANCHE_INTC_H */
Index: linux-2.6.10/include/asm-mips/mach-avalanche/cpu-feature-overrides.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/cpu-feature-overrides.h
@@ -0,0 +1,44 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Sekhar Nori
+ */
+#ifndef __ASM_MACH_AVALANCHE_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_AVALANCHE_CPU_FEATURE_OVERRIDES_H
+
+/* Setting to cache line size of 4kc. Still a grey area for me. This just works
+ */
+
+#ifndef PLAT_TRAMPOLINE_STUFF_LINE
+#define PLAT_TRAMPOLINE_STUFF_LINE	16UL
+#endif
+
+/* These lines are just copied from MIPS32 part of mach-mips. Should be good. */
+
+#define cpu_has_tlb		    1
+#define cpu_has_4kex		1
+#define cpu_has_4ktlb		1
+#define cpu_has_fpu		    0 
+#define cpu_has_32fpr	    0
+#define cpu_has_counter		1
+#define cpu_has_watch	    1 /* Guess this is not used by linux */ 
+#define cpu_has_divec		1
+#define cpu_has_vce		    0
+#define cpu_has_cache_cdex_p    0
+#define cpu_has_cache_cdex_s	0
+#define cpu_has_prefetch	1
+#define cpu_has_mcheck		1
+#define cpu_has_ejtag	1
+#define cpu_has_llsc		1
+#define cpu_has_vtag_icache	0
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+#define cpu_has_64bits	    0
+#define cpu_has_64bit_zero_reg 0
+#define cpu_has_subset_pcaches 0
+
+
+#endif /* __ASM_MACH_AVALANCHE_CPU_FEATURE_OVERRIDES_H */
Index: linux-2.6.10/include/asm-mips/mach-avalanche/env.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/env.h
@@ -0,0 +1,31 @@
+typedef struct ADAM2ENVDESC {
+        char        *new_nm;
+        char        *nm;
+} ADAM2ENVDESC;
+ADAM2ENVDESC env_adam2_alias[] = {
+        {"CPUFREQ",      "cpufrequency",        },
+        {"MEMSZ",        "memsize",             },
+        {"FLASHSZ",      "flashsize",           },
+        {"MODETTY0",     "modetty0",            },
+        {"MODETTY1",     "modetty1",            },
+        {"PROMPT",       "prompt",              },
+        {"BOOTCFG",      "bootcfg",              },
+        {"HWA_0",        "maca",                },
+        {"HWA_1",        "macb",                },
+        {"HWA_RNDIS",    "usb_board_mac",       },
+        {"HWA_3",        "macc",                },
+        {"IPA",          "my_ipaddress",        },
+        {"IPA_SVR",      "remote_ipaddress",    },
+        {"IPA_GATEWAY",  "ipa_gateway",         },
+        {"SUBNET_MASK",  "subnet_mask",         },
+        {"BLINE_MAC0",   "bootline1",           },
+        {"BLINE_MAC1",   "bootline2",           },
+        {"BLINE_RNDIS",  "rndisbootline",       },
+        {"BLINE_ATM",    "atmbootline",         },
+        {"USB_PID",      "usb_prod_id",         },
+        {"USB_VID",      "usb_vend_id",         },
+        {"USB_EPPOLLI",  "usb_ep_poll",         },
+    {"USB_SERIAL",   "usb_serial",          },
+        {"HWA_HRNDIS",   "usb_rndis_mac",      }
+};
+
Index: linux-2.6.10/include/asm-mips/mach-avalanche/ioctl_api.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/ioctl_api.h
@@ -0,0 +1,116 @@
+#ifndef _IOCTL_API_H_
+#define _IOCTL_API_H_
+
+#define MIB2_TRUTH_VALUE_TRUE  		1
+#define MIB2_TRUTH_VALUE_FALSE  	2
+#define MIB2_STATUS_UP     	   1
+#define MIB2_STATUS_DOWN   	   2
+#define MIB2_STATUS_TEST   	   3
+#define MIB2_STATUS_UNKNOWN	   4
+#define MIB2_STATUS_DORMANT	   5
+
+#ifndef OS_IOCTL_OFFSET 
+#define OS_IOCTL_OFFSET 0
+#endif
+
+#define TI_SIOCGINTFCOUNTERS     (OS_IOCTL_OFFSET) + 0x01 /* Get Interface counters */
+#define TI_SIOCGINTFPARAMS       (OS_IOCTL_OFFSET) + 0x02 /* Get Interface parameters */
+#define TI_SIOCSINTFADMINSTATUS  (OS_IOCTL_OFFSET) + 0x03 /* Set Interface Admin. status */
+#define TI_SIOCGETHERCOUNTERS     (OS_IOCTL_OFFSET) +0x04 /* Get Emac PHY counters */
+#define TI_SIOCGETHERPARAMS       (OS_IOCTL_OFFSET) +0x05 /* Get Emac PHY parameters */
+
+struct mib2_ifCounters
+{
+   unsigned long inBytesLow;          /* low 32-bit of total octets received from media */
+   unsigned long inBytesHigh;         /* high 32-bit of total octets received from media */
+   unsigned long inUnicastPktsLow;    /* low 32-bit of unicast packets delivered above */
+   unsigned long inUnicastPktsHigh;   /* high 32-bit of unicast packets delivered above */
+   unsigned long inMulticastPktsLow;  /* low 32-bit of muticast pkts delivered above */
+   unsigned long inMulticastPktsHigh; /* high 32-bit of muticast pkts delivered above */
+   unsigned long inBroadcastPktsLow;  /* low 32-bit of broadcast pkts delivered above */
+   unsigned long inBroadcastPktsHigh; /* high 32-bit of broadcast pkts delivered above */
+   unsigned long inDiscardPkts;       /* packets discarded due to resource limit */
+   unsigned long inErrorPkts;         /* packets discarded due to format errors */
+   unsigned long inUnknownProtPkts;   /* packets for unknown protocols */
+   unsigned long outBytesLow;         /* low 32-bit of total octets sent on the media */
+   unsigned long outBytesHigh;        /* high 32-bit of total octets sent on the media */
+   unsigned long outUnicastPktsLow;   /* low 32-bit of unicast packets from above */
+   unsigned long outUnicastPktsHigh;  /* high 32-bit of unicast packets from above */
+   unsigned long outMulticastPktsLow; /* low 32-bit of multicast packets from above */
+   unsigned long outMulticastPktsHigh;/* high 32-bit of multicast packets from above */
+   unsigned long outBroadcastPktsLow; /* low 32-bit of broadcast packets from above */
+   unsigned long outBroadcastPktsHigh;/* high 32-bit of broadcast packets from above */
+   unsigned long outDiscardPkts;      /* packets discarded due to resource limit */
+   unsigned long outErrorPkts;        /* packets discarded due to format errors */
+
+};
+struct mib2_ifHCCounters
+{
+   struct mib2_ifCounters Mib2IfCounter;
+   unsigned long long inBytesHC;
+   unsigned long long inUnicastPktsHC;
+   unsigned long long inMulticastPktsHC;
+   unsigned long long inBroadcastPktsHC;
+   unsigned long long outBytesHC;
+   unsigned long long outUnicastPktsHC;
+   unsigned long long outMulticastPktsHC;   
+   unsigned long long outBroadcastPktsHC;   
+   unsigned long long inBytes;
+   unsigned long long inUnicastPkts;
+   unsigned long long inMulticastPkts;
+   unsigned long long inBroadcastPkts;
+   unsigned long long outBytes;
+   unsigned long long outUnicastPkts;
+   unsigned long long outMulticastPkts;   
+   unsigned long long outBroadcastPkts;   	
+};
+
+struct mib2_ifParams
+{
+    unsigned long ifSpeed;            /* speed of the interface in bits per second */
+    unsigned long ifHighSpeed;        /* speed of the interface in mega-bits per second */
+    long          ifOperStatus;       /* current operational status */
+    long          ifPromiscuousMode;  /* promiscuous mode interface status */
+};
+
+struct mib2_ifCommand
+{
+    long   ifAdminStatus;               /* desired interface state */
+};
+
+#define	MIB2_UNKNOWN_DUPLEX     1
+#define	MIB2_HALF_DUPLEX 	2
+#define	MIB2_FULL_DUPLEX	3
+
+struct mib2_phyCounters
+{
+   unsigned long ethAlignmentErrors;
+   unsigned long ethFCSErrors;
+   unsigned long ethSingleCollisions;
+   unsigned long ethMultipleCollisions;
+   unsigned long ethSQETestErrors;
+   unsigned long ethDeferredTxFrames;
+   unsigned long ethLateCollisions;
+   unsigned long ethExcessiveCollisions;
+   unsigned long ethInternalMacTxErrors;
+   unsigned long ethCarrierSenseErrors;
+   unsigned long ethTooLongRxFrames;
+   unsigned long ethInternalMacRxErrors;
+   unsigned long ethSymbolErrors;
+};
+
+struct mib2_ethParams
+{
+  long           ethDuplexStatus;        /* current Emac duplex status */
+};
+
+typedef struct
+{
+    unsigned long cmd;
+    unsigned long port;
+    void *data;
+} TI_SNMP_CMD_T;
+
+#define SIOTIMIB2   SIOCDEVPRIVATE + 1
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-avalanche/pal_defs.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/pal_defs.h
@@ -0,0 +1,187 @@
+#ifndef __PAL_DEFS_H__
+#define __PAL_DEFS_H__
+
+typedef enum
+{
+	False = 0,
+	True = 1
+} Bool;
+
+#define PAL_DIM(array)  (sizeof(array)/sizeof(array[0]))
+
+#define PAL_MK_UINT16(high8,low8)                               \
+    ((unsigned short)( ((unsigned short)(high8) << 8) | (unsigned short)(low8) ))
+
+#define PAL_UINT16_LOW8(a)                                      \
+    ((unsigned char)((a) & 0x00FF))
+
+#define PAL_UINT16_HIGH8(a)                                     \
+    ((unsigned char)(((a) >> 8) & 0x00FF))
+
+#define PAL_MK_UINT32(high16,low16)                             \
+    ((unsigned int)( ((unsigned int)(high16) << 16) | (unsigned int)(low16) ))
+
+#define PAL_MK_UINT32_FROM8S(high8,med_high8,med_low8,low8)     \
+    PAL_MK_UINT32(PAL_MK_UINT16(high8,med_high8), PAL_MK_UINT16(med_low8, low8))
+
+#define PAL_UINT32_LOW16(u32)                                   \
+    ((unsigned short)((u32) & 0xFFFF))
+
+#define PAL_UINT32_HIGH16(u32)                                  \
+    ((unsigned short)(((u32) >> 16) & 0xFFFF))
+
+#define PAL_UINT32_LOW8(u32)                                    \
+    ((unsigned char)((u32) & 0x00FF))
+
+#define PAL_UINT32_MED_LOW8(u32)                                \
+    ((unsigned char)(((u32) >> 8) & 0xFF))
+
+#define PAL_UINT32_MED_HIGH8(u32)                               \
+    ((unsigned char)(((u32) >> 16) & 0xFF))
+
+#define PAL_UINT32_HIGH8(u32)                                   \
+    ((unsigned char)(((u32) >> 24) & 0xFF))
+
+#define PAL_SWAP_UINT16(w)      \
+    (PAL_MK_UINT16(unsigned short_LOW8(w), PAL_UINT16_HIGH8(w)))
+
+#define PAL_SWAP_UINT32(u32)                \
+    (PAL_MK_UINT32_FROM8S(                  \
+        PAL_UINT32_LOW8(u32),               \
+        PAL_UINT32_MED_LOW8(u32),           \
+        PAL_UINT32_MED_HIGH8(u32),          \
+        PAL_UINT32_HIGH8(u32)))
+
+#ifdef PAL_NATIVE_ENDIAN_BIG
+#define PAL_UINT16_LE(w)    PAL_SWAP_UINT16(w)
+#define PAL_UINT16_BE(w)    (w)
+#define PAL_UINT32_LE(d)    PAL_SWAP_UINT32(d)
+#define PAL_UINT32_BE(d)    (d)
+
+#else
+#define PAL_UINT16_LE(w)    (w)
+#define PAL_UINT16_BE(w)    PAL_SWAP_UINT16(w)
+#define PAL_UINT32_LE(d)    (d)
+#define PAL_UINT32_BE(d)    PAL_SWAP_UINT32(d)
+
+#endif /* Endian switch */
+
+#define PAL_INFO                (0)
+#define PAL_WARNING             (1)
+#define PAL_MINOR_ERROR         (2)
+#define PAL_MAJOR_ERROR         (3)
+#define PAL_CRITICAL_ERROR      (4)
+#define PAL_ERROR_SRC_CSL       (0)
+#define PAL_ERROR_SRC_DRV       (1)
+#define PAL_ERROR_SRC_PAL       (2)
+#define PAL_ERROR_SRC_SRV       (3)
+#define PAL_ERROR_FLAG          (0x80000000)    /**< PAL Error occured sentinel flag */
+#define PAL_SOK                 (0x0)
+#define PAL_ERROR_SEVERITY_SHIFT    (28)
+#define PAL_ERROR_SEVERITY_MASK     (0x70000000)
+#define PAL_ERROR_SRC_SHIFT         (24)
+#define PAL_ERROR_SRC_MASK          (0x0F000000)
+#define PAL_ERROR_QUAL_SHIFT        16
+#define PAL_ERROR_QUAL_MASK         (0x00FF0000)
+#define PAL_ERROR_NUM_SHIFT         (0)
+#define PAL_ERROR_NUM_MASK          (0x0000FFFF)
+
+#define PAL_ERROR(severity, src, qual, num) \
+    ( PAL_ERROR_FLAG | \
+      (PAL_ERROR_SEVERITY_MASK & (severity << PAL_ERROR_SEVERITY_SHIFT)) | \
+    (PAL_ERROR_SRC_MASK & (src << PAL_ERROR_SRC_SHIFT)) | \
+    (PAL_ERROR_QUAL_MASK & (qual << PAL_ERROR_QUAL_SHIFT)) | \
+    (PAL_ERROR_NUM_MASK & (num << PAL_ERROR_NUM_SHIFT)))
+
+#define PAL_ERROR_NUM(code)         ((code & PAL_ERROR_NUM_MASK) >> PAL_ERROR_NUM_SHIFT)
+#define PAL_ERROR_QUAL(code)        ((code & PAL_ERROR_QUAL_MASK) >> PAL_ERROR_QUAL_SHIFT)
+#define PAL_ERROR_SRC(code)         ((code & PAL_ERROR_SRC_MASK) >> PAL_ERROR_SRC_SHIFT)
+#define PAL_ERROR_SEVERITY(code)    ((code & PAL_ERROR_SEVERITY_MASK) >> PAL_ERROR_SEVERITY_SHIFT)
+
+#define PAL_ERROR_CSLSTATUS(cslerr) \
+    PAL_ERROR(PAL_MAJOR_ERROR, PAL_ERROR_SRC_CSL, 0, (cslerr & 0x7F))
+
+#define CSL_IOCTL_SHIFT     (0)
+#define CSL_IOCTL_MASK      (0xFF)
+#define CSL_IOCTL(ioctl) ((ioctl & CSL_IOCTL_MASK) >> CSL_IOCTL_SHIFT)
+
+typedef void *      CSL_ResHandle;  /**< arbitrary resource handle */
+typedef short       CSL_ModuleId;   /**< numeric identifier of CSL module */
+typedef unsigned short      CSL_BitMask16;  /**< 16bit binary mask */
+typedef unsigned int      CSL_BitMask32;  /**< 32bit binary mask */
+typedef volatile unsigned short CSL_Reg16;      /* 16bit register */
+typedef volatile unsigned int CSL_Reg32;      /* 32bit register */
+typedef short       CSL_Status;     /* CSL API execution status or result */
+typedef short       CSL_InstNum;    /* numeric instance number of the device */
+typedef short       CSL_ChaNum;     /* numeric channel number, local to a device instance */
+
+typedef enum 
+{
+  CSL_FAIL = 0,
+  CSL_PASS = 1
+} CSL_Test;
+
+typedef short  CSL_Uid; /* CSL unique identifier for peripheral resources */
+typedef unsigned int CSL_Xio; /* SoC pin multiplex mask */
+
+typedef struct 
+{
+    CSL_Uid uid;
+    CSL_Xio xio;
+} CSL_ResAttrs;
+
+#define CSL_FMK(PER_REG_FIELD, val) \
+    (((val) << CSL_##PER_REG_FIELD##_SHIFT) & CSL_##PER_REG_FIELD##_MASK)
+
+#define CSL_FMKT(PER_REG_FIELD, TOKEN) \
+    CSL_FMK(PER_REG_FIELD, CSL_##PER_REG_FIELD##_##TOKEN)
+
+#define CSL_FMKR(msb, lsb, val) \
+    (((val) & ((1 << ((msb) - (lsb) + 1)) - 1)) << (lsb))
+
+#define CSL_FEXT(reg, PER_REG_FIELD) \
+    (((reg) & CSL_##PER_REG_FIELD##_MASK) >> CSL_##PER_REG_FIELD##_SHIFT)
+
+#define CSL_FEXTR(reg, msb, lsb) \
+    (((reg) >> (lsb)) & ((1 << ((msb) - (lsb) + 1)) - 1))
+
+#define CSL_FINS(reg, PER_REG_FIELD, val) \
+    ((reg) = ((reg) & ~CSL_##PER_REG_FIELD##_MASK)\
+    | CSL_FMK(PER_REG_FIELD, val))
+
+#define CSL_FINST(reg, PER_REG_FIELD, TOKEN)\
+    CSL_FINS((reg), PER_REG_FIELD, CSL_##PER_REG_FIELD##_##TOKEN)
+
+#define CSL_FINSR(reg, msb, lsb, val)\
+    ((reg) = ((reg) &~ (((1 << ((msb) - (lsb) + 1)) - 1) << (lsb)))\
+    | CSL_FMKR(msb, lsb, val))
+
+
+#define CSL_SOK                 (1)     /* Success */
+#define CSL_ESYS_FAIL           (-1)    /* Generic failure */
+#define CSL_ESYS_INUSE          (-2)    /* Peripheral resource is already in use */
+#define CSL_ESYS_XIO            (-3)    /* Encountered a shared I/O(XIO) pin conflict */
+#define CSL_ESYS_OVFL           (-4)    /* Encoutered CSL system resource overflow */
+#define CSL_ESYS_BADHANDLE      (-5)    /* Handle passed to CSL was invalid */
+#define CSL_ESYS_INVPARAMS      (-6)    /* invalid parameters */
+#define CSL_ESYS_INVCMD         (-7)    /* invalid command */
+#define CSL_ESYS_INVQUERY       (-8)    /* invalid query */
+#define CSL_ESYS_NOTSUPPORTED   (-9)    /* action not supported */
+#define CSL_ESYS_LAST           (-32)   /* Sentinel error code, end of sys range */
+
+#define PAL_OS_COMMON_ERR   (0)
+#define PAL_OSMEM_ERR       (1)
+#define PAL_OSBUF_ERR       (2)
+#define PAL_OSSEM_ERR       (3)
+#define PAL_OSMUTEX_ERR     (4)
+#define PAL_OSWAIT_ERR      (5)
+#define PAL_OSLIST_ERR      (6)
+#define PAL_OSPROTECT_ERR   (7)
+#define PAL_OS_COMMON_ERROR_CREATE(x)   (PAL_ERROR(PAL_CRITICAL_ERROR, PAL_OS_COMMON_ERR, 0, (x)))
+#define PAL_OS_ERROR_INVALID_PARAM      (PAL_OS_COMMON_ERROR_CREATE(1))
+#define PAL_OS_ERROR_NOT_SUPPORTED      (PAL_OS_COMMON_ERROR_CREATE(2))
+#define PAL_OS_ERROR_NO_RESOURCES       (PAL_OS_COMMON_ERROR_CREATE(3))
+#define PAL_OS_ERROR_OS_SPECIFIC        (PAL_OS_COMMON_ERROR_CREATE(4))
+#define PAL_OSMEM_DEFAULT_SEGID         0
+
+#endif /* _CSL_DEFS_H_ */
Index: linux-2.6.10/include/asm-mips/mach-avalanche/pal.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/pal.h
@@ -0,0 +1,116 @@
+#ifndef __PAL_SYS_H__
+#define __PAL_SYS_H__
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <asm/mach-avalanche/soc.h>
+#include <asm/mach-avalanche/titan.h>
+#include <asm/mach-avalanche/avalanche_intc.h>
+
+#include "pal_defs.h" 
+                                                                                                 
+#define MIPS_4KEC
+#define BOARD_TYPE_UNKNOWN 0xFF
+typedef enum PAL_SYS_RESET_CTRL_tag
+{
+    IN_RESET        = 0,
+    OUT_OF_RESET
+} PAL_SYS_RESET_CTRL_T;
+
+typedef enum PAL_SYS_SYSTEM_RST_MODE_tag
+{
+    RESET_SOC_WITH_MEMCTRL      = 1,    /* SW0 bit in SWRCR register */
+    RESET_SOC_WITHOUT_MEMCTRL   = 2     /* SW1 bit in SWRCR register */
+} PAL_SYS_SYSTEM_RST_MODE_T;
+
+typedef enum PAL_SYS_SYSTEM_RESET_STATUS_tag
+{
+    HARDWARE_RESET = 0,
+    SOFTWARE_RESET0,            /* Caused by writing 1 to SW0 bit in SWRCR register */
+    WATCHDOG_RESET,
+    SOFTWARE_RESET1             /* Caused by writing 1 to SW1 bit in SWRCR register */
+} PAL_SYS_SYSTEM_RESET_STATUS_T;
+
+typedef void (*REMOTE_VLYNQ_DEV_RESET_CTRL_FN)(unsigned int reset_module, 
+                                               PAL_SYS_RESET_CTRL_T reset_ctrl);
+
+typedef enum PAL_SYS_POWER_CTRL_tag
+{
+    POWER_CTRL_POWER_UP = 0,
+    POWER_CTRL_POWER_DOWN
+} PAL_SYS_POWER_CTRL_T;
+
+typedef enum PAL_SYS_SYSTEM_POWER_MODE_tag
+{
+    GLOBAL_POWER_MODE_RUN       = 0,    /* All system is up */
+    GLOBAL_POWER_MODE_IDLE,             /* MIPS is power down, all peripherals working */
+    GLOBAL_POWER_MODE_STANDBY,          /* Chip in power down, but clock to ADSKL subsystem is running */
+    GLOBAL_POWER_MODE_POWER_DOWN        /* Total chip is powered down */
+} PAL_SYS_SYSTEM_POWER_MODE_T;
+
+
+typedef enum PAL_SYS_WAKEUP_INTERRUPT_tag
+{
+    WAKEUP_INT0 = 1,
+    WAKEUP_INT1 = 2,
+    WAKEUP_INT2 = 4,
+    WAKEUP_INT3 = 8
+} PAL_SYS_WAKEUP_INTERRUPT_T;
+
+typedef enum PAL_SYS_WAKEUP_CTRL_tag
+{
+    WAKEUP_DISABLED = 0,
+    WAKEUP_ENABLED
+} PAL_SYS_WAKEUP_CTRL_T;
+
+typedef enum PAL_SYS_WAKEUP_POLARITY_tag
+{
+    WAKEUP_ACTIVE_HIGH = 0,
+    WAKEUP_ACTIVE_LOW
+} PAL_SYS_WAKEUP_POLARITY_T;
+
+typedef enum PAL_SYS_GPIO_PIN_MODE_tag
+{
+    FUNCTIONAL_PIN = 0,
+    GPIO_PIN = 1
+} PAL_SYS_GPIO_PIN_MODE_T;
+
+typedef enum PAL_SYS_GPIO_PIN_DIRECTION_tag
+{
+    GPIO_OUTPUT_PIN = 0,
+    GPIO_INPUT_PIN = 1
+} PAL_SYS_GPIO_PIN_DIRECTION_T;
+
+typedef enum { GPIO_FALSE, GPIO_TRUE } PAL_SYS_GPIO_BOOL_T;
+
+typedef struct module_info {
+        unsigned int version;
+        unsigned int base_addr;
+} MOD_INFO_T;
+
+typedef struct board_info {
+        MOD_INFO_T modules[MAX_MODULES];
+}BOARD_INFO_T;
+
+extern BOARD_INFO_T soc[];
+
+int avalanche_device_prepare(unsigned int module_id, unsigned int base_addr, BOARD_ID board_variant, void *param);
+
+static inline int avalanche_memalloc (unsigned int numBytes,void** memAddr)
+{
+    *memAddr = kmalloc(numBytes, GFP_KERNEL);
+     if(*memAddr == NULL)
+     {
+        return PAL_OS_ERROR_NO_RESOURCES;
+     }
+                                                                                              
+     return 0;
+}
+
+static inline int avalanche_memfree (void* memAddr)
+{
+    kfree(memAddr);
+    return 0;
+}
+
+#endif /* _PAL_H_ */
Index: linux-2.6.10/include/asm-mips/mach-avalanche/soc.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/soc.h
@@ -0,0 +1,99 @@
+#ifndef __SOC_H__
+#define __SOC_H__
+
+#define REG8_ADDR(addr)             (volatile UINT8 *)(KSEG1ADDR(addr))
+#define REG8_DATA(addr)             (*(volatile UINT8 *)(KSEG1ADDR(addr)))
+#define REG8_WRITE(addr, data)      REG8_DATA(addr) = data;
+#define REG8_READ(addr, data)       data = (UINT8) REG8_DATA(addr);
+
+#define REG16_ADDR(addr)            (volatile UINT16 *)(KSEG1ADDR(addr))
+#define REG16_DATA(addr)            (*(volatile UINT16 *)(KSEG1ADDR(addr)))
+#define REG16_WRITE(addr, data)     REG16_DATA(addr) = data;
+#define REG16_READ(addr, data)      data = (UINT16) REG16_DATA(addr);
+
+#define REG32_ADDR(addr)            (volatile unsigned int *)(KSEG1ADDR(addr))
+#define REG32_DATA(addr)            (*(volatile unsigned int *)(KSEG1ADDR(addr)))
+#define REG32_WRITE(addr, data)     REG32_DATA(addr) = data;
+#define REG32_READ(addr, data)      data = (unsigned int) REG32_DATA(addr);
+
+#ifdef  _LINK_KSEG0_                /* Application is linked into KSEG0 space */
+#define VIRT_ADDR(addr)             PHYS_TO_K0(PHYS_ADDR(addr))
+#endif
+
+#ifdef  _LINK_KSEG1_                /* Application is linked into KSEG1 space */
+#define VIRT_ADDR(addr)             KSEG1ADDR(PHYS_ADDR(addr))
+#endif
+
+/* These ugly macros are to access the -1 registers, like config1 */
+#define MFC0_SEL1_OPCODE(dst, src)\
+        .word (0x40000000 | ((dst)<<16) | ((src)<<11) | 1);\
+        nop; \
+        nop; \
+        nop
+
+#define MTC0_SEL1_OPCODE(dst, src)\
+        .word (0x40800000 | ((dst)<<16) | ((src)<<11) | 1);\
+        nop; \
+        nop; \
+        nop
+
+#define CFG0_4K_IL_MASK         0x00380000
+#define CFG0_4K_IL_SHIFT        19
+#define CFG0_4K_IA_MASK         0x00070000
+#define CFG0_4K_IA_SHIFT        16
+#define CFG0_4K_IS_MASK         0x01c00000
+#define CFG0_4K_IS_SHIFT        22
+#define CFG0_4K_DL_MASK         0x00001c00
+#define CFG0_4K_DL_SHIFT        10
+#define CFG0_4K_DA_MASK         0x00000380
+#define CFG0_4K_DA_SHIFT        7
+#define CFG0_4K_DS_MASK         0x0000E000
+#define CFG0_4K_DS_SHIFT        13
+
+#define FREQ_1MHZ               1000000
+
+#if !defined(_ASMLANGUAGE)
+        
+typedef enum AVALANCHE_CPU_TYPE_tag
+{
+    CPU_AVALANCHE_I         = 0,    
+    CPU_AVALANCHE_D         = 2,
+    CPU_PUMA                = 4,
+    CPU_PUMAS               = 0x0104,
+    CPU_SANGAM              = 0x5,
+    CPU_TITAN               = 0x7,
+    CPU_APEX                = 0xb,
+    CPU_PUMA3               = 0x0204,
+    CPU_UNIDENT             = 0xFF
+    
+}AVALANCHE_CPU_TYPE_T;
+        
+AVALANCHE_CPU_TYPE_T avalanche_get_cpu_type(void);
+const char * avalanche_get_cpu_name(AVALANCHE_CPU_TYPE_T cpu_type);
+
+typedef int (*SET_MDIX_ON_CHIP_FN_T)(unsigned int base_addr, unsigned int operation);
+int avalanche_set_mdix_on_chip(unsigned int base_addr, unsigned int operation);
+unsigned int avalanche_is_mdix_on_chip(void);
+
+unsigned int avalanche_get_chip_version_info(void);
+
+unsigned int avalanche_get_vbus_freq(void);
+void         avalanche_set_vbus_freq(unsigned int);
+
+
+extern unsigned int avalanche_mips_freq;
+extern unsigned int avalanche_vbus_freq;
+
+#define AVALANCHE_MIPS_FREQ     (avalanche_mips_freq)
+#define AVALANCHE_VBUS_FREQ     (avalanche_vbus_freq)
+
+#ifdef SEAD2_EMLN
+#define AVALANCHE_UART_FREQ     3686400
+#else
+#define AVALANCHE_UART_FREQ     AVALANCHE_VBUS_FREQ
+#endif
+
+#endif /* !defined(_ASMLANGUAGE) */
+
+#endif /* __SOC_H__ */
+
Index: linux-2.6.10/include/asm-mips/mach-avalanche/ssp_hal.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/ssp_hal.h
@@ -0,0 +1,105 @@
+#ifndef __SSP_HAL__
+#define __SSP_HAL__
+
+#define SSP_HAL_OK                      0
+#define SSP_HAL_ERROR                  -1
+#define SSP_HAL_MODE_POLL               0
+#define SSP_HAL_MODE_INTR               1
+#define SSP_HAL_INTR_ACK                0
+#define SSP_HAL_INTR_DISABLE            1
+#define SSP_HAL_INTR_ENABLE             2
+
+typedef struct ssp_hal_i2c_info_tag
+{
+    unsigned int   data_pin;  
+    unsigned int   clock_pin; 
+    unsigned char	 addr;      
+    unsigned int	 bus_speed; 
+    unsigned int   mode;      
+    
+}ssp_hal_i2c_info_t;
+
+typedef struct ssp_hal_spi_info_tag
+{
+    unsigned int  data_in_pin;  
+    unsigned int  data_out_pin; 
+    unsigned int  clock_pin;   
+    unsigned int  cs_pin;     
+    unsigned int	clock_speed; 
+    unsigned int  mode; 
+    
+}ssp_hal_spi_info_t;
+
+void sspIsr (void);
+
+unsigned int ssp_hal_init
+(
+    unsigned int base_address,
+    unsigned int module_input_freq
+);
+
+ssp_hal_i2c_info_t* ssp_hal_i2c_open
+(
+    ssp_hal_i2c_info_t info
+);
+
+unsigned int ssp_hal_i2c_close
+(
+    ssp_hal_i2c_info_t* info
+);
+
+unsigned int ssp_hal_i2c_write 
+(
+    ssp_hal_i2c_info_t  *info,
+    unsigned char               *buffer, 
+    unsigned int              len
+);
+
+unsigned int ssp_hal_i2c_read
+(
+    ssp_hal_i2c_info_t  *info,
+    unsigned char               *buffer,
+    unsigned int              len
+);
+
+ssp_hal_spi_info_t* ssp_hal_spi_open
+(
+    ssp_hal_spi_info_t info
+);
+
+unsigned int ssp_hal_spi_close
+(
+    ssp_hal_spi_info_t* info
+);
+
+unsigned int ssp_hal_spi_write_read 
+(
+    ssp_hal_spi_info_t  *info,
+    unsigned char               *write_buf, 
+    unsigned int              write_len,
+    unsigned char               *read_buf, 
+    unsigned int              read_len
+);
+
+unsigned int ssp_hal_intr_ctrl
+(
+    unsigned int action
+);
+
+void ssp_drv_cbk_wait_for_xfr_done( void );
+
+#define SSP_DRV_OK          SSP_HAL_OK
+#define SSP_DRV_ERROR       SSP_HAL_ERROR
+typedef void* ssp_drv_desc_t;
+#define SSP_DRIVER_MAGIC           0xD1
+#define I2C_MAX_BUF_SIZE       100
+#define I2C_SET_ADDR            _IOW( SSP_DRIVER_MAGIC, 1, unsigned char )
+ssp_hal_i2c_info_t* ssp_i2c_open( void );
+int ssp_i2c_close(ssp_hal_i2c_info_t *     id);
+int ssp_i2c_read( ssp_hal_i2c_info_t  *info, unsigned char    *buffer, unsigned int   len);
+int ssp_i2c_write( ssp_hal_i2c_info_t  *info, unsigned char    *buffer, unsigned int   len);
+#define SSP_I2C_OUTPUT_CLK_FREQ                 400000    /* 400 KHz */
+#define SSP_SPI_OUTPUT_CLK_FREQ                 2000000   /* 2 MHz */
+#define SSP_UW_OUTPUT_CLK_FREQ                  1000000   /* 1 MHz */
+
+#endif /* ifndef  __SSP_HAL__*/
Index: linux-2.6.10/include/asm-mips/mach-avalanche/titan.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-avalanche/titan.h
@@ -0,0 +1,249 @@
+#ifndef _TITAN_H
+#define _TITAN_H
+
+#define AVALANCHE_USB_SLAVE_BASE              (KSEG1ADDR(0x03400000)) /* AVALANCHE USB SLAVE */
+#define AVALANCHE_DSP_SUBSYSTEM_MEM_BASE      (KSEG1ADDR(0x04000000)) /* AVALANCHE DSP Mem Base */
+#define AVALANCHE_EMIF_CONTROL_BASE           (KSEG1ADDR(0x08610800)) /* AVALANCHE EMIF */
+#define AVALANCHE_GPIO_BASE                   (KSEG1ADDR(0x08610900)) /* AVALANCHE GPIO */
+#define AVALANCHE_CLOCK_CONTROL_BASE          (KSEG1ADDR(0x08610A00)) /* AVALANCHE Clock Control */
+#define AVALANCHE_WATCHDOG_TIMER_BASE         (KSEG1ADDR(0x08610B00)) /* AVALANCHE Watch Dog Timer */  
+#define AVALANCHE_TIMER0_BASE                 (KSEG1ADDR(0x08610C00)) /* AVALANCHE Timer 1 */  
+#define AVALANCHE_TIMER1_BASE                 (KSEG1ADDR(0x08610D00)) /* AVALANCHE Timer 2 */  
+#define AVALANCHE_UART0_REGS_BASE             (KSEG1ADDR(0x08610E00)) /* AVALANCHE UART 0 */
+#define AVALANCHE_SSP_BASE                    (KSEG1ADDR(0x08611000)) /* AVALANCHE I2C */
+#define AVALANCHE_USB_SLAVE_CONTROL_BASE      (KSEG1ADDR(0x08611200)) /* AVALANCHE USB DMA */
+#define AVALANCHE_HIGH_VLYNQ_CONTROL_BASE     (KSEG1ADDR(0x08611300)) /* AVALANCHE VLYNQ1 Control */
+#define AVALANCHE_MCDMA0_CTRL_BASE            (KSEG1ADDR(0x08611400)) /* AVALANCHE MC DMA 0 (channels 0-3) */
+#define AVALANCHE_RESET_CONTROL_BASE          (KSEG1ADDR(0x08611600)) /* AVALANCHE Reset Control */
+#define AVALANCHE_DSP_SUBSYSTEM_CONTROL_BASE  (KSEG1ADDR(0x08611700)) /* AVALANCHE BIST */
+#define AVALANCHE_DEVICE_CONFIG_LATCH_BASE    (KSEG1ADDR(0x08611A00)) /* AVALANCHE Device Config Latch */
+#define AVALANCHE_LOW_VLYNQ_CONTROL_BASE      (KSEG1ADDR(0x08611C00)) /* AVALANCHE VLYNQ0 Control */
+#define AVALANCHE_USB_MASTER_CONTROL_BASE     (KSEG1ADDR(0x08612100)) /* AVALANCHE USB Master Control */        
+#define AVALANCHE_KEYPAD_CONTROL_BASE         (KSEG1ADDR(0x08612200)) /* AVALANCHE Keypad Control */
+#define AVALANCHE_LCD_CONTROL_BASE            (KSEG1ADDR(0x08612300)) /* AVALANCHE LCD Control */
+#define AVALANCHE_INTC_BASE                   (KSEG1ADDR(0x08612400)) /* AVALANCHE INTC  */
+#define AVALANCHE_ESWITCH_BASE                (KSEG1ADDR(0x08640000)) /* AVALANCHE Eswitch base */
+#define AVALANCHE_LOW_VLYNQ_MEM_MAP_BASE      (KSEG1ADDR(0x0C000000)) /* AVALANCHE VLYNQ 0 Mem map */
+#define AVALANCHE_HIGH_VLYNQ_MEM_MAP_BASE     (KSEG1ADDR(0x40000000)) /* AVALANCHE VLYNQ 1 Mem map */
+
+#define AVALANCHE_SDRAM_BASE                  0x14000000UL
+
+#define AVALANCHE_LOW_CPMAC_BASE              (AVALANCHE_ESWITCH_BASE + 0)         /* AVALANCHE CPMAC 0 */
+#define AVALANCHE_HIGH_CPMAC_BASE             (AVALANCHE_ESWITCH_BASE + 0x00800)   /* AVALANCHE CPMAC 1 */
+#define AVALANCHE_ESWITCH_HDMA_BASE           (AVALANCHE_ESWITCH_BASE + 0x01000)   /* AVALANCHE HDMA    */
+#define AVALANCHE_MDIO_BASE                   (AVALANCHE_ESWITCH_BASE + 0x02000)   /* AVALANCHE MDIO    */
+#define AVALANCHE_ESWITCH_CONTROL             (AVALANCHE_ESWITCH_BASE + 0x02800)   /* AVALANCHE ESWITCH Control */
+#define AVALANCHE_PDSP_INSTRUCTION_MEM        (AVALANCHE_ESWITCH_BASE + 0x08000)   /* AVALANCHE PDSP Intruction mem */
+#define AVALANCHE_ETHERNET_PACKET_MEM         (AVALANCHE_ESWITCH_BASE + 0x10000)   /* AVALANCHE Eswitch packet mem */
+
+#define AVALANCHE_UNIFIED_SECONDARY_INT            0
+#define AVALANCHE_EXT_INT_0                        1
+#define AVALANCHE_EXT_INT_1                        2
+#define AVALANCHE_EXT_INT_2                        3
+#define AVALANCHE_EXT_INT_3                        4
+#define AVALANCHE_TIMER_0_INT                      5
+#define AVALANCHE_TIMER_1_INT                      6
+#define AVALANCHE_UART0_INT                        7
+#define AVALANCHE_DMA_INT0                         9
+#define AVALANCHE_DMA_INT1                        10
+#define AVALANCHE_LOW_CPMAC_INT                   19
+#define AVALANCHE_DSP_GPIO_OUT_INT                21
+#define AVALANCHE_DSP_SW_RESET_STATUS_INT         22
+#define AVALANCHE_DSP_CODEC_INT                   23
+#define AVALANCHE_USB_SLAVE_INT                   24
+#define AVALANCHE_LOW_VLYNQ_INT                   25
+#define AVALANCHE_HIGH_VLYNQ_INT                  26
+#define AVALANCHE_SWITCH_HOST_DMA_INT             27
+#define AVALANCHE_UNIFIED_PHY_INT                 28
+#define AVALANCHE_SSP_INT                         29
+#define AVALANCHE_DMA_INT2                        30
+#define AVALANCHE_DMA_INT3                        31
+#define AVALANCHE_DSP_CODEC_XFER_INT              32
+#define AVALANCHE_HIGH_CPMAC_INT                  33
+#define AVALANCHE_USB_MASTER_INT                  35
+#define AVALANCHE_LCD_INT                         36
+#define AVALANCHE_KPAD_CNTL_INT                   37
+#define AVALANCHE_EMIF_INT                        46
+#define AVALANCHE_DSP_WATCH_DOG_INT               47
+#define AVALANCHE_UART0_RESET_BIT                  0
+#define AVALANCHE_SSP_RESET_BIT                    2
+#define AVALANCHE_TIMER0_RESET_BIT                 3
+#define AVALANCHE_TIMER1_RESET_BIT                 4
+#define AVALANCHE_GPIO_RESET_BIT                   6
+#define AVALANCHE_ADSL_SS_RESET_BIT                7
+#define AVALANCHE_USB_SLAVE_RESET_BIT              8
+#define AVALANCHE_HDMA_RESET_BIT                  13
+#define AVALANCHE_USB_MASTER_RESET_BIT            14
+#define AVALANCHE_LOW_VLYNQ_RESET_BIT             15
+#define AVALANCHE_HIGH_VLYNQ_RESET_BIT            16
+#define AVALANCHE_LOW_CPMAC_RESET_BIT             17
+#define AVALANCHE_MCDMA_RESET_BIT                 18
+#define AVALANCHE_DSP_SUBSYSTEM_RESET_BIT         20
+#define AVALANCHE_HIGH_CPMAC_RESET_BIT            21
+#define AVALANCHE_MDIO_RESET_BIT                  22
+#define AVALANCHE_LCD_CTRL_RESET_BIT              24
+#define AVALANCHE_KEYPAD_CTRL_RESET_BIT           25
+#define AVALANCHE_LOW_EPHY_RESET_BIT              26
+#define AVALANCHE_ESWITCH_RESET_BIT               27
+#define AVALANCHE_HIGH_EPHY_RESET_BIT             28
+#define AVALANCHE_POWER_MODULE_USBSP               0 
+#define AVALANCHE_POWER_MODULE_WDTP                1 
+#define AVALANCHE_POWER_MODULE_UT0P                2 
+#define AVALANCHE_POWER_MODULE_UT1P                3 
+#define AVALANCHE_POWER_MODULE_VDMAP               5 
+#define AVALANCHE_POWER_MODULE_GPIOP               6 
+#define AVALANCHE_POWER_MODULE_VLYNQ1P             7 
+#define AVALANCHE_POWER_MODULE_EMIFP              10 
+#define AVALANCHE_POWER_MODULE_ADSPP              12 
+#define AVALANCHE_POWER_MODULE_RAMP               13 
+#define AVALANCHE_POWER_MODULE_ROMP               14 
+#define AVALANCHE_POWER_MODULE_DMAP               15 
+#define AVALANCHE_POWER_MODULE_BISTP              16 
+#define AVALANCHE_POWER_MODULE_TIMER0P            18 
+#define AVALANCHE_POWER_MODULE_TIMER1P            19 
+#define AVALANCHE_POWER_MODULE_EMAC0P             20 
+#define AVALANCHE_POWER_MODULE_EMAC1P             22 
+#define AVALANCHE_POWER_MODULE_VLYNQ0P            27 
+#define AVALANCHE_VECS       (KSEG1ADDR(AVALANCHE_SDRAM_BASE))
+#define AVALANCHE_VECS_KSEG0 (KSEG0ADDR(AVALANCHE_SDRAM_BASE))
+#define AVALANCHE_DCL_BOOTCR          (KSEG1ADDR(0x08611A00))
+#define AVALANCHE_EMIF_SDRAM_CFG      (AVALANCHE_EMIF_CONTROL_BASE + 0x8)
+#define AVALANCHE_RST_CTRL_PRCR       (KSEG1ADDR(0x08611600))
+#define AVALANCHE_RST_CTRL_SWRCR      (KSEG1ADDR(0x08611604))
+#define AVALANCHE_RST_CTRL_RSR        (KSEG1ADDR(0x08611608))
+#define AVALANCHE_POWER_CTRL_PDCR     (KSEG1ADDR(0x08610A00))
+#define AVALANCHE_WAKEUP_CTRL_WKCR    (KSEG1ADDR(0x08610A0C))
+#define AVALANCHE_CVR                 (KSEG1ADDR(0x08610924))
+#define TITAN_GPIO_DATA_IN_0          (AVALANCHE_GPIO_BASE +  0x0)
+#define TITAN_GPIO_DATA_IN_1          (AVALANCHE_GPIO_BASE +  0x4)
+#define TITAN_GPIO_DATA_OUT_0         (AVALANCHE_GPIO_BASE +  0x8)
+#define TITAN_GPIO_DATA_OUT_1         (AVALANCHE_GPIO_BASE +  0xc)
+#define TITAN_GPIO_DIR_0              (AVALANCHE_GPIO_BASE + 0x10)    
+#define TITAN_GPIO_DIR_1              (AVALANCHE_GPIO_BASE + 0x14)
+#define TITAN_GPIO_ENBL_0             (AVALANCHE_GPIO_BASE + 0x18)
+#define TITAN_GPIO_ENBL_1             (AVALANCHE_GPIO_BASE + 0x1c)    
+#define TITAN_IOMUX_PIN_SEL_1	   (AVALANCHE_RESET_CONTROL_BASE + 0x0C)
+#define TITAN_IOMUX_PIN_SEL_2	   (AVALANCHE_RESET_CONTROL_BASE + 0x10)
+#define TITAN_IOMUX_PIN_SEL_3	   (AVALANCHE_RESET_CONTROL_BASE + 0x14)
+#define TITAN_IOMUX_PIN_SEL_4	   (AVALANCHE_RESET_CONTROL_BASE + 0x18)
+#define TITAN_IOMUX_PIN_SEL_5	   (AVALANCHE_RESET_CONTROL_BASE + 0x1C)
+#define TITAN_IOMUX_PIN_SEL_6	   (AVALANCHE_RESET_CONTROL_BASE + 0x20)
+#define TITAN_IOMUX_PIN_SEL_7	   (AVALANCHE_RESET_CONTROL_BASE + 0x24)
+#define TITAN_IOMUX_PIN_SEL_8	   (AVALANCHE_RESET_CONTROL_BASE + 0x28)
+#define TITAN_IOMUX_PIN_SEL_9	   (AVALANCHE_RESET_CONTROL_BASE + 0x2C)
+#define TITAN_IOMUX_PIN_SEL_10	   (AVALANCHE_RESET_CONTROL_BASE + 0x30)
+#define TITAN_IOMUX_PIN_SEL_11	   (AVALANCHE_RESET_CONTROL_BASE + 0x34)
+#define TITAN_IOMUX_PIN_SEL_12	   (AVALANCHE_RESET_CONTROL_BASE + 0x38)
+#define TITAN_IOMUX_PIN_SEL_13	   (AVALANCHE_RESET_CONTROL_BASE + 0x3C)
+#define TITAN_IOMUX_PIN_SEL_14	   (AVALANCHE_RESET_CONTROL_BASE + 0x40)
+#define TITAN_IOMUX_PIN_SEL_15	   (AVALANCHE_RESET_CONTROL_BASE + 0x44)
+#define TITAN_IOMUX_PIN_SEL_16	   (AVALANCHE_RESET_CONTROL_BASE + 0x48)
+#define TITAN_IOMUX_PIN_SEL_17	   (AVALANCHE_RESET_CONTROL_BASE + 0x4C)
+#define TITAN_IOMUX_PIN_SEL_18	   (AVALANCHE_RESET_CONTROL_BASE + 0x50)
+#define TITAN_IOMUX_PIN_SEL_19	   (AVALANCHE_RESET_CONTROL_BASE + 0x54)
+#define TITAN_IOMUX_PIN_SEL_20	   (AVALANCHE_RESET_CONTROL_BASE + 0x58)
+#define TITAN_IOMUX_PIN_SEL_21	   (AVALANCHE_RESET_CONTROL_BASE + 0x5C)
+
+typedef struct
+{
+    volatile unsigned int reg[21];
+}
+PIN_SEL_REG_ARRAY_T;
+
+typedef struct
+{
+    unsigned int data_in [2];
+    unsigned int data_out[2];
+    unsigned int dir[2];
+    unsigned int enable[2];
+
+} TITAN_GPIO_CONTROL_T;
+
+#define AVALANCHE_PIN_SEL_BASE        0xA861160C
+
+#define AVALANCHE_YAMON_FUNCTION_BASE             (KSEG1ADDR(0x10000500))
+#define AVALANCHE_YAMON_PROM_PRINT_COUNT_ADDR     (AVALANCHE_YAMON_FUNCTION_BASE + 0x4)  /* print_count function */
+#define AVALANCHE_YAMON_PROM_PRINT_ADDR           (AVALANCHE_YAMON_FUNCTION_BASE + 0x34)
+#define AVALANCHE_BASE_BAUD               ( 3686400 / 16 )
+#define  AVALANCHE_GPIO_PIN_COUNT         32
+#define  AVALANCHE_GPIO_OFF_MAP           {0x00000000}
+#define AVALANCHE_MIPS_FREQ_DEFAULT     125000000
+#define AVALANCHE_VBUS_FREQ_DEFAULT     125000000
+#define AVALANCHE_CPMAC_HW_MODULE_REV               0x00040100
+#define AVALANCHE_USB_1_1_HOST_HW_MODULE_REV        0x00090000
+#define AVALANCHE_USB_1_1_DEVICE_HW_MODULE_REV      0x000A0000
+#define AVALANCHE_USB_2_0_DEVICE_HW_MODULE_REV      0x000B0000
+#define AVALANCHE_SSP_HW_MODULE_REV             0x80010000
+#define AVALANCHE_I2C_HW_MODULE_REV             0x80020000
+#define AVALANCHE_LCD_HW_MODULE_REV             0x80030000
+#define AVALANCHE_GLCD_HW_MODULE_REV            0x80040000
+#define AVALANCHE_INT_ESWITCH_HW_MODULE_REV     0x80050000
+#define AVALANCHE_KEYPAD_HW_MODULE_REV          0x80060000
+
+#define CLK_MHZ(x)    ( (x) * 1000000 )
+typedef enum PAL_SYS_CLKC_ID_tag
+{
+    CLKC_VBUS = 0,  /* Clock driving VBUS */
+    CLKC_MIPS,      /* Clock to MIPS */
+    CLKC_USB,       /* Clock to USB slave */
+    CLKC_LCD,       /* Clock to LCD controller */
+    CLKC_VBUSP,      /* Clock to VBUSP */
+    CLKC_SYS        /* Clock to SYS */
+} PAL_SYS_CLKC_ID_T;
+                                                                                                 
+typedef struct PAL_SYS_Tnetv1050Init_tag
+{
+    unsigned int audclk;
+    unsigned int refclk;
+    unsigned int altclk;
+                                                                                                 
+} PAL_SYS_Tnetv1050Init;
+
+
+#if defined(CONFIG_MIPS_TITAN) || defined(TNETV1050SDB) || defined(TNETV1060SDB_WR)
+
+#define AUDCLK_FREQ                                  8192000
+#define REFCLK_FREQ                                 25000000
+#define ALTCLK_FREQ                                 12000000
+#define AVALANCHE_LOW_CPMAC_PHY_MASK                0x40000000 
+#define AVALANCHE_HIGH_CPMAC_PHY_MASK               0x80000000 
+#define VLYNQ0_RESET_GPIO_NUM                       0x7
+
+#if defined(TNETV1060SDB_WR) || defined(CONFIG_MIPS_TNETV1060SDB_WR)
+#define AVALANCHE_LOW_CPMAC_HAS_EXT_SWITCH          1
+
+#define VLYNQ_ACX111_MEM_OFFSET 					0xC0000000  /* Physical address of ACX111 memory       */
+#define VLYNQ_ACX111_MEM_SIZE   					0x00040000  /* Total size of the ACX111 memory         */
+#define VLYNQ_ACX111_REG_OFFSET 					0xF0000000  /* PHYS_ADDR of ACX111 control registers   */
+#define VLYNQ_ACX111_REG_SIZE   					0x00022000  /* Size of ACX111 registers area, MAC+PHY  */
+#define ACX111_VL1_REMOTE_SIZE  					0x04000000  /* Rx Address Map Size register            */ 
+
+#define AVALANCHE_NUM_VLYNQ_HOPS_PER_ROOT           1
+
+#else
+#define AVALANCHE_LOW_CPMAC_HAS_EXT_SWITCH          0
+#endif
+#define AVALANCHE_HIGH_CPMAC_HAS_EXT_SWITCH         0
+
+#endif
+
+#define TITAN_TYPE_UNKNOWN  0
+#define TITAN_TYPE_1050     0x0f
+#define TITAN_TYPE_1055     0x0e
+#define TITAN_TYPE_1056     0x0d
+#define TITAN_TYPE_1060     0x07
+
+typedef enum {
+        TITAN_1050 = 0,
+        TITAN_1055,
+        TITAN_1056,
+        TITAN_1060,
+
+        MAX_BOARDS /* For count */
+} BOARD_ID;
+
+int avalanche_get_board_variant( void );
+
+#define MAX_MODULES 10
+
+#endif /* _TITAN_BOARDS_H */
Index: linux-2.6.10/include/asm-mips/serial.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/serial.h
+++ linux-2.6.10/include/asm-mips/serial.h
@@ -438,6 +438,23 @@
 #define IP32_SERIAL_PORT_DEFNS
 #endif /* CONFIG_SGI_IP32 */
 
+#ifdef CONFIG_MIPS_AVALANCHE_SOC
+#include <asm/mach-avalanche/pal.h>
+#define AVALANCHE_SERIAL_PORT0_DEFN \
+		{.irq = AVALANCHE_UART0_INT, .iomem_base = AVALANCHE_UART0_REGS_BASE}
+#if (CONFIG_AVALANCHE_NUM_SER_PORTS > 1)
+#define AVALANCHE_SERIAL_PORT1_DEFN \
+	{.irq = AVALANCHE_UART1_INT, .iomem_base = AVALANCHE_UART1_REGS_BASE}
+#else
+#define AVALANCHE_SERIAL_PORT1_DEFN
+#endif
+#define AVALANCHE_SERIAL_PORT_DEFNS AVALANCHE_SERIAL_PORT0_DEFN, \
+		AVALANCHE_SERIAL_PORT1_DEFN
+#else
+#define AVALANCHE_SERIAL_PORT_DEFNS
+#endif
+
+
 #define SERIAL_PORT_DFNS				\
 	COBALT_SERIAL_PORT_DEFNS			\
 	DDB5477_SERIAL_PORT_DEFNS			\
@@ -455,6 +472,7 @@
 	MOMENCO_OCELOT_3_SERIAL_PORT_DEFNS		\
 	TXX927_SERIAL_PORT_DEFNS                        \
 	AU1000_SERIAL_PORT_DEFNS                        \
-	VR5701_SG2_SERIAL_PORT_DEFNS
+	VR5701_SG2_SERIAL_PORT_DEFNS			\
+	AVALANCHE_SERIAL_PORT_DEFNS
 
 #endif /* _ASM_SERIAL_H */
Index: linux-2.6.10/mvl_patches/pro-0869.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0869.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(869);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

