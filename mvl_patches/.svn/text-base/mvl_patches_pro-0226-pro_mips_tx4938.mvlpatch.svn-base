#! /usr/bin/env bash
# Patch: -pro_mips_tx4938
# Date: Wed Dec 28 15:02:09 2005
#  Source: MontaVista Software, Inc. | http://source.mvista.com | Manish Lachwani <mlachwani@mvista.com>
#  MR:10574 
#  Type: Enhancement
#  Disposition: Needs submitting to linux-mips.org
#  Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
#  Description:
#         Support for TX4938 in 2.6. Support for PCI and onboard fast
#          ethernet.
# 
#  arch/mips/Kconfig                              |   15 
#  arch/mips/Makefile                             |    7 
#  arch/mips/pci/Makefile                         |    1 
#  arch/mips/pci/fixup-tx4938.c                   |   95 ++
#  arch/mips/pci/ops-tx4938.c                     |  204 ++++
#  arch/mips/tx4938/common/Makefile               |    9 
#  arch/mips/tx4938/common/irq.c                  |  399 ++++++++
#  arch/mips/tx4938/common/irq_handler.S          |   85 +
#  arch/mips/tx4938/common/prom.c                 |  117 ++
#  arch/mips/tx4938/common/rtc_rx5c348.c          |  199 ++++
#  arch/mips/tx4938/common/setup.c                |   89 +
#  arch/mips/tx4938/toshiba_rbtx4938/Makefile     |    9 
#  arch/mips/tx4938/toshiba_rbtx4938/irq.c        |  233 ++++
#  arch/mips/tx4938/toshiba_rbtx4938/prom.c       |   78 +
#  arch/mips/tx4938/toshiba_rbtx4938/setup.c      | 1136 ++++++++++++++++++++++++
#  arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c |  216 ++++
#  arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c   |  166 +++
#  drivers/char/Kconfig                           |    8 
#  drivers/char/Makefile                          |    1 
#  drivers/net/ne.c                               |   15 
#  drivers/serial/Kconfig                         |   17 
#  drivers/serial/Makefile                        |    1 
#  drivers/serial/serial_txx9.c                   | 1172 +++++++++++++++++++++++++
#  include/asm-mips/bootinfo.h                    |    1 
#  include/asm-mips/tx4938/rbtx4938.h             |  206 ++++
#  include/asm-mips/tx4938/spi.h                  |   78 +
#  include/asm-mips/tx4938/tx4938.h               |  701 ++++++++++++++
#  include/asm-mips/tx4938/tx4938_mips.h          |   54 +
#  include/linux/pci_ids.h                        |    1 
#  include/linux/serial_core.h                    |    3 
#  30 files changed, 5307 insertions(+), 9 deletions(-)
# 

PATCHNUM=226
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
 Source: MontaVista Software, Inc. | http://source.mvista.com | Manish Lachwani <mlachwani@mvista.com>
 MR:10574 
 Type: Enhancement
 Disposition: Needs submitting to linux-mips.org
 Signed-off-by: Manish Lachwani <mlachwani@mvista.com>
 Description:
        Support for TX4938 in 2.6. Support for PCI and onboard fast
         ethernet.

 arch/mips/Kconfig                              |   15 
 arch/mips/Makefile                             |    7 
 arch/mips/pci/Makefile                         |    1 
 arch/mips/pci/fixup-tx4938.c                   |   95 ++
 arch/mips/pci/ops-tx4938.c                     |  204 ++++
 arch/mips/tx4938/common/Makefile               |    9 
 arch/mips/tx4938/common/irq.c                  |  399 ++++++++
 arch/mips/tx4938/common/irq_handler.S          |   85 +
 arch/mips/tx4938/common/prom.c                 |  117 ++
 arch/mips/tx4938/common/rtc_rx5c348.c          |  199 ++++
 arch/mips/tx4938/common/setup.c                |   89 +
 arch/mips/tx4938/toshiba_rbtx4938/Makefile     |    9 
 arch/mips/tx4938/toshiba_rbtx4938/irq.c        |  233 ++++
 arch/mips/tx4938/toshiba_rbtx4938/prom.c       |   78 +
 arch/mips/tx4938/toshiba_rbtx4938/setup.c      | 1136 ++++++++++++++++++++++++
 arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c |  216 ++++
 arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c   |  166 +++
 drivers/char/Kconfig                           |    8 
 drivers/char/Makefile                          |    1 
 drivers/net/ne.c                               |   15 
 drivers/serial/Kconfig                         |   17 
 drivers/serial/Makefile                        |    1 
 drivers/serial/serial_txx9.c                   | 1172 +++++++++++++++++++++++++
 include/asm-mips/bootinfo.h                    |    1 
 include/asm-mips/tx4938/rbtx4938.h             |  206 ++++
 include/asm-mips/tx4938/spi.h                  |   78 +
 include/asm-mips/tx4938/tx4938.h               |  701 ++++++++++++++
 include/asm-mips/tx4938/tx4938_mips.h          |   54 +
 include/linux/pci_ids.h                        |    1 
 include/linux/serial_core.h                    |    3 
 mvl_patches/pro-0226.c                         |   16 
 31 files changed, 5323 insertions(+), 9 deletions(-)

Index: linux-2.6.10/arch/mips/tx4938/common/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for common code for Toshiba TX4938 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= prom.o setup.o irq.o irq_handler.o rtc_rx5c348.o 
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -658,6 +658,13 @@ core-$(CONFIG_TOSHIBA_RBTX4927)	+= arch/
 core-$(CONFIG_TOSHIBA_RBTX4927)	+= arch/mips/tx4927/common/
 load-$(CONFIG_TOSHIBA_RBTX4927)	+= 0xffffffff80020000
 
+#
+# Toshiba RBTX4938 board
+#
+core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/toshiba_rbtx4938/
+core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/common/
+load-$(CONFIG_TOSHIBA_RBTX4938) += 0xffffffff80100000
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
Index: linux-2.6.10/include/linux/pci_ids.h
===================================================================
--- linux-2.6.10.orig/include/linux/pci_ids.h
+++ linux-2.6.10/include/linux/pci_ids.h
@@ -1454,6 +1454,7 @@
 #define PCI_DEVICE_ID_TOSHIBA_TX3927	0x000a
 #define PCI_DEVICE_ID_TOSHIBA_TC35815CF	0x0030
 #define PCI_DEVICE_ID_TOSHIBA_TX4927	0x0180
+#define PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC	0x0108
 
 #define PCI_VENDOR_ID_RICOH		0x1180
 #define PCI_DEVICE_ID_RICOH_RL5C465	0x0465
Index: linux-2.6.10/drivers/serial/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/serial/Kconfig
+++ linux-2.6.10/drivers/serial/Kconfig
@@ -793,4 +793,21 @@ config SERIAL_M32R_PLDSIO
 	  If you use an M3T-M32700UT or an OPSPUT platform,
 	  please say Y.
 
+config SERIAL_TXX9
+	bool "TMPTX39XX/49XX SIO support"
+	depends HAS_TXX9_SERIAL
+	select SERIAL_CORE
+	default y
+
+config HAS_TXX9_SERIAL
+	bool
+
+config SERIAL_TXX9_CONSOLE
+	bool "TMPTX39XX/49XX SIO Console support"
+	depends on SERIAL_TXX9=y
+	select SERIAL_CORE_CONSOLE
+
+config SERIAL_TXX9_STDSERIAL
+	bool "TX39XX/49XX SIO act as standard serial"
+	depends on !SERIAL_8250 && SERIAL_TXX9
 endmenu
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/prom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/prom.c
@@ -0,0 +1,78 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/prom.c
+ *
+ * rbtx4938 specific prom routines
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/tx4938.h>
+
+void __init prom_init_cmdline(void)
+{
+	int argc = (int)fw_arg0;
+	char **argv = (char **)fw_arg1;
+	int i;
+
+	/* ignore all built-in args if any f/w args given */
+	if (argc > 1) {
+		*arcs_cmdline = '\0';
+	}
+
+	for (i = 1; i < argc; i++) {
+		if (i != 1) {
+			strcat(arcs_cmdline, " ");
+		}
+		strcat(arcs_cmdline, argv[i]);
+	}
+}
+
+void __init prom_init(void)
+{
+	extern int tx4938_get_mem_size(void);
+	int msize;
+
+	prom_init_cmdline();
+
+	mips_machgroup = MACH_GROUP_TOSHIBA;
+	mips_machtype = MACH_TOSHIBA_RBTX4938;
+
+	msize = tx4938_get_mem_size();
+	add_memory_region(0, msize << 20, BOOT_MEM_RAM);
+
+	return;
+}
+
+unsigned long __init prom_free_prom_memory(void)
+{
+	return 0;
+}
+
+void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
+{
+	return;
+}
+
+const char *get_system_type(void)
+{
+	return "Toshiba RBTX4938";
+}
+
+char *__init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for common code for Toshiba TX4938 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= prom.o setup.o irq.o spi_eeprom.o spi_txx9.o
Index: linux-2.6.10/include/asm-mips/tx4938/spi.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4938/spi.h
@@ -0,0 +1,78 @@
+/*
+ * linux/include/asm-mips/tx4938/spi.h
+ * Definitions for TX4937/TX4938 SPI
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_TX4938_SPI_H
+#define __ASM_TX_BOARDS_TX4938_SPI_H
+
+/* SPI */
+struct spi_dev_desc {
+	unsigned int baud;
+	unsigned short tcss, tcsh, tcsr;	/* CS setup/hold/recovery time */
+	unsigned int byteorder:1;	/* 0:LSB-First, 1:MSB-First */
+	unsigned int polarity:1;	/* 0:High-Active */
+	unsigned int phase:1;	/* 0:Sample-Then-Shift */
+};
+
+extern void txx9_spi_init(unsigned long base,
+			  int (*cs_func) (int chipid, int on)) __init;
+extern void txx9_spi_irqinit(int irc_irq) __init;
+extern int txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+		       unsigned char **inbufs, unsigned int *incounts,
+		       unsigned char **outbufs, unsigned int *outcounts,
+		       int cansleep);
+extern int spi_eeprom_write_enable(int chipid, int enable);
+extern int spi_eeprom_read_status(int chipid);
+extern int spi_eeprom_read(int chipid, int address, unsigned char *buf,
+			   int len);
+extern int spi_eeprom_write(int chipid, int address, unsigned char *buf,
+			    int len);
+extern void spi_eeprom_proc_create(struct proc_dir_entry *dir,
+				   int chipid) __init;
+
+#define TXX9_IMCLK     (txx9_gbus_clock / 2)
+
+/*
+* SPI
+*/
+
+/* SPMCR : SPI Master Control */
+#define TXx9_SPMCR_OPMODE	0xc0
+#define TXx9_SPMCR_CONFIG	0x40
+#define TXx9_SPMCR_ACTIVE	0x80
+#define TXx9_SPMCR_SPSTP	0x02
+#define TXx9_SPMCR_BCLR	0x01
+
+/* SPCR0 : SPI Status */
+#define TXx9_SPCR0_TXIFL_MASK	0xc000
+#define TXx9_SPCR0_RXIFL_MASK	0x3000
+#define TXx9_SPCR0_SIDIE	0x0800
+#define TXx9_SPCR0_SOEIE	0x0400
+#define TXx9_SPCR0_RBSIE	0x0200
+#define TXx9_SPCR0_TBSIE	0x0100
+#define TXx9_SPCR0_IFSPSE	0x0010
+#define TXx9_SPCR0_SBOS	0x0004
+#define TXx9_SPCR0_SPHA	0x0002
+#define TXx9_SPCR0_SPOL	0x0001
+
+/* SPSR : SPI Status */
+#define TXx9_SPSR_TBSI	0x8000
+#define TXx9_SPSR_RBSI	0x4000
+#define TXx9_SPSR_TBS_MASK	0x3800
+#define TXx9_SPSR_RBS_MASK	0x0700
+#define TXx9_SPSR_SPOE	0x0080
+#define TXx9_SPSR_IFSD	0x0008
+#define TXx9_SPSR_SIDLE	0x0004
+#define TXx9_SPSR_STRDY	0x0002
+#define TXx9_SPSR_SRRDY	0x0001
+
+#endif				/* __ASM_TX_BOARDS_TX4938_SPI_H */
Index: linux-2.6.10/drivers/serial/serial_txx9.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/serial/serial_txx9.c
@@ -0,0 +1,1172 @@
+/*
+ *  drivers/serial/serial_txx9.c
+ *
+ * Derived from many drivers using generic_serial interface,
+ * especially serial_tx3912.c by Steven J. Hill and r39xx_serial.c
+ * (was in Linux/VR tree) by Jim Pick.
+ *
+ *  Copyright (C) 1999 Harald Koerfgen
+ *  Copyright (C) 2000 Jim Pick <jim@jimpick.com>
+ *  Copyright (C) 2001 Steven J. Hill (sjhill@realitydiluted.com)
+ *  Copyright (C) 2000-2002 Toshiba Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Serial driver for TX3927/TX4927/TX4925/TX4938 internal SIO controller
+ *
+ *  Revision History:
+ *	0.30	Initial revision. (Renamed from serial_txx927.c)
+ *	0.31	Use save_flags instead of local_irq_save.
+ *	0.32	Support SCLK.
+ *	0.33	Switch TXX9_TTY_NAME by CONFIG_SERIAL_TXX9_STDSERIAL.
+ *		Support TIOCSERGETLSR.
+ *	0.34	Support slow baudrate.
+ *	0.40	Merge codes from mainstream kernel (2.4.22).
+ *	0.41	Fix console checking in rs_shutdown_port().
+ *		Disable flow-control in serial_console_write().
+ *	0.42	Fix minor compiler warning.
+ *	1.00	Kernel 2.6.  Converted to new serial core (based on 8250.c).
+ *	1.01	Set fifosize to make tx_empry called properly.
+ *		Use standard uart_get_divisor.
+ *	1.02	Cleanup. (import 8250.c changes)
+ */
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_TXX9_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+static char *serial_version = "1.02";
+static char *serial_name = "TX39/49 Serial driver";
+
+#define PASS_LIMIT	256
+
+#if !defined(CONFIG_SERIAL_TXX9_STDSERIAL)
+/* "ttyS" is used for standard serial driver */
+#define TXX9_TTY_NAME "ttyTX"
+#define TXX9_TTY_DEVFS_NAME "tttx/"
+#define TXX9_TTY_MINOR_START	(64 + 64)	/* ttyTX0(128), ttyTX1(129) */
+#else
+/* acts like standard serial driver */
+#define TXX9_TTY_NAME "ttyS"
+#define TXX9_TTY_DEVFS_NAME "tts/"
+#define TXX9_TTY_MINOR_START	64
+#endif
+#define TXX9_TTY_MAJOR	TTY_MAJOR
+
+/* flag aliases */
+#define UPF_TXX9_HAVE_CTS_LINE	UPF_BUGGY_UART
+#define UPF_TXX9_USE_SCLK	UPF_MAGIC_MULTIPLIER
+
+#ifdef CONFIG_PCI
+/* support for Toshiba TC86C001 SIO */
+#define ENABLE_SERIAL_TXX9_PCI
+#endif
+
+/*
+ * Number of serial ports
+ */
+#ifdef ENABLE_SERIAL_TXX9_PCI
+#define NR_PCI_BOARDS	4
+#define UART_NR  (2 + NR_PCI_BOARDS)
+#else
+#define UART_NR  2
+#endif
+
+struct uart_txx9_port {
+	struct uart_port	port;
+
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+#define TXX9_REGION_SIZE	0x24
+
+/* TXX9 Serial Registers */
+#define TXX9_SILCR	0x00
+#define TXX9_SIDICR	0x04
+#define TXX9_SIDISR	0x08
+#define TXX9_SICISR	0x0c
+#define TXX9_SIFCR	0x10
+#define TXX9_SIFLCR	0x14
+#define TXX9_SIBGR	0x18
+#define TXX9_SITFIFO	0x1c
+#define TXX9_SIRFIFO	0x20
+
+/* SILCR : Line Control */
+#define TXX9_SILCR_SCS_MASK	0x00000060
+#define TXX9_SILCR_SCS_IMCLK	0x00000000
+#define TXX9_SILCR_SCS_IMCLK_BG	0x00000020
+#define TXX9_SILCR_SCS_SCLK	0x00000040
+#define TXX9_SILCR_SCS_SCLK_BG	0x00000060
+#define TXX9_SILCR_UEPS	0x00000010
+#define TXX9_SILCR_UPEN	0x00000008
+#define TXX9_SILCR_USBL_MASK	0x00000004
+#define TXX9_SILCR_USBL_1BIT	0x00000000
+#define TXX9_SILCR_USBL_2BIT	0x00000004
+#define TXX9_SILCR_UMODE_MASK	0x00000003
+#define TXX9_SILCR_UMODE_8BIT	0x00000000
+#define TXX9_SILCR_UMODE_7BIT	0x00000001
+
+/* SIDICR : DMA/Int. Control */
+#define TXX9_SIDICR_TDE	0x00008000
+#define TXX9_SIDICR_RDE	0x00004000
+#define TXX9_SIDICR_TIE	0x00002000
+#define TXX9_SIDICR_RIE	0x00001000
+#define TXX9_SIDICR_SPIE	0x00000800
+#define TXX9_SIDICR_CTSAC	0x00000600
+#define TXX9_SIDICR_STIE_MASK	0x0000003f
+#define TXX9_SIDICR_STIE_OERS		0x00000020
+#define TXX9_SIDICR_STIE_CTSS		0x00000010
+#define TXX9_SIDICR_STIE_RBRKD	0x00000008
+#define TXX9_SIDICR_STIE_TRDY		0x00000004
+#define TXX9_SIDICR_STIE_TXALS	0x00000002
+#define TXX9_SIDICR_STIE_UBRKD	0x00000001
+
+/* SIDISR : DMA/Int. Status */
+#define TXX9_SIDISR_UBRK	0x00008000
+#define TXX9_SIDISR_UVALID	0x00004000
+#define TXX9_SIDISR_UFER	0x00002000
+#define TXX9_SIDISR_UPER	0x00001000
+#define TXX9_SIDISR_UOER	0x00000800
+#define TXX9_SIDISR_ERI	0x00000400
+#define TXX9_SIDISR_TOUT	0x00000200
+#define TXX9_SIDISR_TDIS	0x00000100
+#define TXX9_SIDISR_RDIS	0x00000080
+#define TXX9_SIDISR_STIS	0x00000040
+#define TXX9_SIDISR_RFDN_MASK	0x0000001f
+
+/* SICISR : Change Int. Status */
+#define TXX9_SICISR_OERS	0x00000020
+#define TXX9_SICISR_CTSS	0x00000010
+#define TXX9_SICISR_RBRKD	0x00000008
+#define TXX9_SICISR_TRDY	0x00000004
+#define TXX9_SICISR_TXALS	0x00000002
+#define TXX9_SICISR_UBRKD	0x00000001
+
+/* SIFCR : FIFO Control */
+#define TXX9_SIFCR_SWRST	0x00008000
+#define TXX9_SIFCR_RDIL_MASK	0x00000180
+#define TXX9_SIFCR_RDIL_1	0x00000000
+#define TXX9_SIFCR_RDIL_4	0x00000080
+#define TXX9_SIFCR_RDIL_8	0x00000100
+#define TXX9_SIFCR_RDIL_12	0x00000180
+#define TXX9_SIFCR_RDIL_MAX	0x00000180
+#define TXX9_SIFCR_TDIL_MASK	0x00000018
+#define TXX9_SIFCR_TDIL_MASK	0x00000018
+#define TXX9_SIFCR_TDIL_1	0x00000000
+#define TXX9_SIFCR_TDIL_4	0x00000001
+#define TXX9_SIFCR_TDIL_8	0x00000010
+#define TXX9_SIFCR_TDIL_MAX	0x00000010
+#define TXX9_SIFCR_TFRST	0x00000004
+#define TXX9_SIFCR_RFRST	0x00000002
+#define TXX9_SIFCR_FRSTE	0x00000001
+#define TXX9_SIO_TX_FIFO	8
+#define TXX9_SIO_RX_FIFO	16
+
+/* SIFLCR : Flow Control */
+#define TXX9_SIFLCR_RCS	0x00001000
+#define TXX9_SIFLCR_TES	0x00000800
+#define TXX9_SIFLCR_RTSSC	0x00000200
+#define TXX9_SIFLCR_RSDE	0x00000100
+#define TXX9_SIFLCR_TSDE	0x00000080
+#define TXX9_SIFLCR_RTSTL_MASK	0x0000001e
+#define TXX9_SIFLCR_RTSTL_MAX	0x0000001e
+#define TXX9_SIFLCR_TBRK	0x00000001
+
+/* SIBGR : Baudrate Control */
+#define TXX9_SIBGR_BCLK_MASK	0x00000300
+#define TXX9_SIBGR_BCLK_T0	0x00000000
+#define TXX9_SIBGR_BCLK_T2	0x00000100
+#define TXX9_SIBGR_BCLK_T4	0x00000200
+#define TXX9_SIBGR_BCLK_T6	0x00000300
+#define TXX9_SIBGR_BRD_MASK	0x000000ff
+
+static inline unsigned int sio_in(struct uart_txx9_port *up, int offset)
+{
+	switch (up->port.iotype) {
+	default:
+		return *(volatile u32 *)(up->port.membase + offset);
+	case UPIO_PORT:
+		return inl(up->port.iobase + offset);
+	}
+}
+
+static inline void
+sio_out(struct uart_txx9_port *up, int offset, int value)
+{
+	switch (up->port.iotype) {
+	default:
+		*(volatile u32 *)(up->port.membase + offset) = value;
+		break;
+	case UPIO_PORT:
+		outl(value, up->port.iobase + offset);
+		break;
+	}
+}
+
+static inline void
+sio_mask(struct uart_txx9_port *up, int offset, unsigned int value)
+{
+	sio_out(up, offset, sio_in(up, offset) & ~value);
+}
+static inline void
+sio_set(struct uart_txx9_port *up, int offset, unsigned int value)
+{
+	sio_out(up, offset, sio_in(up, offset) | value);
+}
+
+static inline void
+sio_quot_set(struct uart_txx9_port *up, int quot)
+{
+	quot >>= 1;
+	if (quot < 256)
+		sio_out(up, TXX9_SIBGR, quot | TXX9_SIBGR_BCLK_T0);
+	else if (quot < (256 << 2))
+		sio_out(up, TXX9_SIBGR, (quot >> 2) | TXX9_SIBGR_BCLK_T2);
+	else if (quot < (256 << 4))
+		sio_out(up, TXX9_SIBGR, (quot >> 4) | TXX9_SIBGR_BCLK_T4);
+	else if (quot < (256 << 6))
+		sio_out(up, TXX9_SIBGR, (quot >> 6) | TXX9_SIBGR_BCLK_T6);
+	else
+		sio_out(up, TXX9_SIBGR, 0xff | TXX9_SIBGR_BCLK_T6);
+}
+
+static void serial_txx9_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	sio_mask(up, TXX9_SIDICR, TXX9_SIDICR_TIE);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	sio_set(up, TXX9_SIDICR, TXX9_SIDICR_TIE);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_stop_rx(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->port.read_status_mask &= ~TXX9_SIDISR_RDIS;
+#if 0
+	sio_mask(up, TXX9_SIDICR, TXX9_SIDICR_RIE);
+#endif
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_enable_ms(struct uart_port *port)
+{
+	/* TXX9-SIO can not control DTR... */
+}
+
+static inline void
+receive_chars(struct uart_txx9_port *up, unsigned int *status, struct pt_regs *regs)
+{
+	struct tty_struct *tty = up->port.info->tty;
+	unsigned char ch;
+	unsigned int disr = *status;
+	int max_count = 256;
+	char flag;
+
+	do {
+		/* The following is not allowed by the tty layer and
+		   unsafe. It should be fixed ASAP */
+		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
+			if(tty->low_latency)
+				tty_flip_buffer_push(tty);
+			/* If this failed then we will throw away the
+			   bytes but must do so to clear interrupts */
+		}
+		ch = sio_in(up, TXX9_SIRFIFO);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(disr & (TXX9_SIDISR_UBRK | TXX9_SIDISR_UPER |
+				     TXX9_SIDISR_UFER | TXX9_SIDISR_UOER))) {
+			/*
+			 * For statistics only
+			 */
+			if (disr & TXX9_SIDISR_UBRK) {
+				disr &= ~(TXX9_SIDISR_UFER | TXX9_SIDISR_UPER);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char;
+			} else if (disr & TXX9_SIDISR_UPER)
+				up->port.icount.parity++;
+			else if (disr & TXX9_SIDISR_UFER)
+				up->port.icount.frame++;
+			if (disr & TXX9_SIDISR_UOER)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ingored.
+			 */
+			disr &= up->port.read_status_mask;
+
+			if (disr & TXX9_SIDISR_UBRK) {
+				flag = TTY_BREAK;
+			} else if (disr & TXX9_SIDISR_UPER)
+				flag = TTY_PARITY;
+			else if (disr & TXX9_SIDISR_UFER)
+				flag = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(&up->port, ch, regs))
+			goto ignore_char;
+		if ((disr & up->port.ignore_status_mask) == 0) {
+			tty_insert_flip_char(tty, ch, flag);
+		}
+		if ((disr & TXX9_SIDISR_UOER) &&
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character.
+			 */
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
+	ignore_char:
+		disr = sio_in(up, TXX9_SIDISR);
+	} while (!(disr & TXX9_SIDISR_UVALID) && (max_count-- > 0));
+	tty_flip_buffer_push(tty);
+	*status = disr;
+}
+
+static inline void transmit_chars(struct uart_txx9_port *up)
+{
+	struct circ_buf *xmit = &up->port.info->xmit;
+	int count;
+
+	if (up->port.x_char) {
+		sio_out(up, TXX9_SITFIFO, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		serial_txx9_stop_tx(&up->port, 0);
+		return;
+	}
+
+	count = TXX9_SIO_TX_FIFO;
+	do {
+		sio_out(up, TXX9_SITFIFO, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		serial_txx9_stop_tx(&up->port, 0);
+}
+
+static irqreturn_t serial_txx9_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int pass_counter = 0;
+	struct uart_txx9_port *up = dev_id;
+	unsigned int status;
+
+	while (1) {
+		spin_lock(&up->port.lock);
+		status = sio_in(up, TXX9_SIDISR);
+		if (!(sio_in(up, TXX9_SIDICR) & TXX9_SIDICR_TIE))
+			status &= ~TXX9_SIDISR_TDIS;
+		if (!(status & (TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |
+				TXX9_SIDISR_TOUT))) {
+			spin_unlock(&up->port.lock);
+			break;
+		}
+
+		if (status & TXX9_SIDISR_RDIS)
+			receive_chars(up, &status, regs);
+		if (status & TXX9_SIDISR_TDIS)
+			transmit_chars(up);
+		/* Clear TX/RX Int. Status */
+		sio_mask(up, TXX9_SIDISR,
+			 TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS |
+			 TXX9_SIDISR_TOUT);
+		spin_unlock(&up->port.lock);
+
+		if (pass_counter++ > PASS_LIMIT)
+			break;
+	}
+
+	return pass_counter ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static unsigned int serial_txx9_tx_empty(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret = (sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS) ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static unsigned int serial_txx9_get_mctrl(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret =  ((sio_in(up, TXX9_SIFLCR) & TXX9_SIFLCR_RTSSC) ? 0 : TIOCM_RTS)
+		| ((sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS) ? 0 : TIOCM_CTS);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static void serial_txx9_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (mctrl & TIOCM_RTS)
+		sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);
+	else
+		sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSSC);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void serial_txx9_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+	else
+		sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int serial_txx9_startup(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	int retval;
+
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reeanbled in set_termios())
+	 */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	/* clear reset */
+	sio_mask(up, TXX9_SIFCR,
+		 TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	sio_out(up, TXX9_SIDICR, 0);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	sio_out(up, TXX9_SIDISR, 0);
+
+	retval = request_irq(up->port.irq, serial_txx9_interrupt,
+			     SA_SHIRQ, "serial_txx9", up);
+	if (retval)
+		return retval;
+
+	/*
+	 * Now, initialize the UART
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/* Enable RX/TX */
+	sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);
+
+	/*
+	 * Finally, enable interrupts.
+	 */
+	sio_set(up, TXX9_SIDICR, TXX9_SIDICR_RIE);
+
+	return 0;
+}
+
+static void serial_txx9_shutdown(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	sio_out(up, TXX9_SIDICR, 0);	/* disable all intrs */
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Disable break condition
+	 */
+	sio_mask(up, TXX9_SIFLCR, TXX9_SIFLCR_TBRK);
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	if (up->port.cons && up->port.line == up->port.cons->index) {
+		free_irq(up->port.irq, up);
+		return;
+	}
+#endif
+	/* reset FIFOs */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+	/* clear reset */
+	sio_mask(up, TXX9_SIFCR,
+		 TXX9_SIFCR_TFRST | TXX9_SIFCR_RFRST | TXX9_SIFCR_FRSTE);
+
+	/* Disable RX/TX */
+	sio_set(up, TXX9_SIFLCR, TXX9_SIFLCR_RSDE | TXX9_SIFLCR_TSDE);
+
+	free_irq(up->port.irq, up);
+}
+
+static void
+serial_txx9_set_termios(struct uart_port *port, struct termios *termios,
+		       struct termios *old)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned int cval, fcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	cval = sio_in(up, TXX9_SILCR);
+	/* byte size and parity */
+	cval &= ~TXX9_SILCR_UMODE_MASK;
+	switch (termios->c_cflag & CSIZE) {
+	case CS7:
+		cval |= TXX9_SILCR_UMODE_7BIT;
+		break;
+	default:
+	case CS5:	/* not supported */
+	case CS6:	/* not supported */
+	case CS8:
+		cval |= TXX9_SILCR_UMODE_8BIT;
+		break;
+	}
+
+	cval &= ~TXX9_SILCR_USBL_MASK;
+	if (termios->c_cflag & CSTOPB)
+		cval |= TXX9_SILCR_USBL_2BIT;
+	else
+		cval |= TXX9_SILCR_USBL_1BIT;
+	cval &= ~(TXX9_SILCR_UPEN | TXX9_SILCR_UEPS);
+	if (termios->c_cflag & PARENB)
+		cval |= TXX9_SILCR_UPEN;
+	if (!(termios->c_cflag & PARODD))
+		cval |= TXX9_SILCR_UEPS;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16/2);
+	quot = uart_get_divisor(port, baud);
+
+	/* Set up FIFOs */
+	/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+	fcr = TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = TXX9_SIDISR_UOER |
+		TXX9_SIDISR_TDIS | TXX9_SIDISR_RDIS;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= TXX9_SIDISR_UFER | TXX9_SIDISR_UPER;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= TXX9_SIDISR_UBRK;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= TXX9_SIDISR_UPER | TXX9_SIDISR_UFER;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= TXX9_SIDISR_UBRK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= TXX9_SIDISR_UOER;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= TXX9_SIDISR_RDIS;
+
+	/* CTS flow control flag */
+	if ((termios->c_cflag & CRTSCTS) &&
+	    (up->port.flags & UPF_TXX9_HAVE_CTS_LINE)) {
+		sio_set(up, TXX9_SIFLCR,
+			TXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);
+	} else {
+		sio_mask(up, TXX9_SIFLCR,
+			 TXX9_SIFLCR_RCS | TXX9_SIFLCR_TES);
+	}
+
+	sio_out(up, TXX9_SILCR, cval);
+	sio_quot_set(up, quot);
+	sio_out(up, TXX9_SIFCR, fcr);
+
+	serial_txx9_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void
+serial_txx9_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	if (state) {
+		/* sleep */
+
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	} else {
+		/* wake */
+
+		if (up->pm)
+			up->pm(port, state, oldstate);
+	}
+}
+
+static int serial_txx9_request_resource(struct uart_txx9_port *up)
+{
+	unsigned int size = TXX9_REGION_SIZE;
+	int ret = 0;
+
+	switch (up->port.iotype) {
+	default:
+		if (!up->port.mapbase)
+			break;
+
+		if (!request_mem_region(up->port.mapbase, size, "serial_txx9")) {
+			ret = -EBUSY;
+			break;
+		}
+
+		if (up->port.flags & UPF_IOREMAP) {
+			up->port.membase = ioremap(up->port.mapbase, size);
+			if (!up->port.membase) {
+				release_mem_region(up->port.mapbase, size);
+				ret = -ENOMEM;
+			}
+		}
+		break;
+
+	case UPIO_PORT:
+		if (!request_region(up->port.iobase, size, "serial_txx9"))
+			ret = -EBUSY;
+		break;
+	}
+	return ret;
+}
+
+static void serial_txx9_release_resource(struct uart_txx9_port *up)
+{
+	unsigned int size = TXX9_REGION_SIZE;
+
+	switch (up->port.iotype) {
+	default:
+		if (!up->port.mapbase)
+			break;
+
+		if (up->port.flags & UPF_IOREMAP) {
+			iounmap(up->port.membase);
+			up->port.membase = NULL;
+		}
+
+		release_mem_region(up->port.mapbase, size);
+		break;
+
+	case UPIO_PORT:
+		release_region(up->port.iobase, size);
+		break;
+	}
+}
+
+static void serial_txx9_release_port(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	serial_txx9_release_resource(up);
+}
+
+static int serial_txx9_request_port(struct uart_port *port)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	return serial_txx9_request_resource(up);
+}
+
+static void serial_txx9_config_port(struct uart_port *port, int uflags)
+{
+	struct uart_txx9_port *up = (struct uart_txx9_port *)port;
+	unsigned long flags;
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = serial_txx9_request_resource(up);
+	if (ret < 0)
+		return;
+	port->type = PORT_TXX9;
+	up->port.fifosize = TXX9_SIO_TX_FIFO;
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	if (up->port.line == up->port.cons->index)
+		return;
+#endif
+	spin_lock_irqsave(&up->port.lock, flags);
+	/*
+	 * Reset the UART.
+	 */
+	sio_out(up, TXX9_SIFCR, TXX9_SIFCR_SWRST);
+#ifdef CONFIG_CPU_TX49XX
+	/* TX4925 BUG WORKAROUND.  Accessing SIOC register
+	 * immediately after soft reset causes bus error. */
+	iob();
+	udelay(1);
+#endif
+	while (sio_in(up, TXX9_SIFCR) & TXX9_SIFCR_SWRST)
+		;
+	/* TX Int by FIFO Empty, RX Int by Receiving 1 char. */
+	sio_set(up, TXX9_SIFCR,
+		TXX9_SIFCR_TDIL_MAX | TXX9_SIFCR_RDIL_1);
+	/* initial settings */
+	sio_out(up, TXX9_SILCR,
+		TXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |
+		((up->port.flags & UPF_TXX9_USE_SCLK) ?
+		 TXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));
+	sio_quot_set(up, uart_get_divisor(port, 9600));
+	sio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX /* 15 */);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int
+serial_txx9_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->irq < 0 ||
+	    ser->baud_base < 9600 || ser->type != PORT_TXX9)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+serial_txx9_type(struct uart_port *port)
+{
+	return "txx9";
+}
+
+static struct uart_ops serial_txx9_pops = {
+	.tx_empty	= serial_txx9_tx_empty,
+	.set_mctrl	= serial_txx9_set_mctrl,
+	.get_mctrl	= serial_txx9_get_mctrl,
+	.stop_tx	= serial_txx9_stop_tx,
+	.start_tx	= serial_txx9_start_tx,
+	.stop_rx	= serial_txx9_stop_rx,
+	.enable_ms	= serial_txx9_enable_ms,
+	.break_ctl	= serial_txx9_break_ctl,
+	.startup	= serial_txx9_startup,
+	.shutdown	= serial_txx9_shutdown,
+	.set_termios	= serial_txx9_set_termios,
+	.pm		= serial_txx9_pm,
+	.type		= serial_txx9_type,
+	.release_port	= serial_txx9_release_port,
+	.request_port	= serial_txx9_request_port,
+	.config_port	= serial_txx9_config_port,
+	.verify_port	= serial_txx9_verify_port,
+};
+
+static struct uart_txx9_port serial_txx9_ports[UART_NR];
+
+static void __init serial_txx9_register_ports(struct uart_driver *drv)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_txx9_port *up = &serial_txx9_ports[i];
+
+		up->port.line = i;
+		up->port.ops = &serial_txx9_pops;
+		uart_add_one_port(drv, &up->port);
+	}
+}
+
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct uart_txx9_port *up)
+{
+	unsigned int tmout = 10000;
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	while (--tmout &&
+	       !(sio_in(up, TXX9_SICISR) & TXX9_SICISR_TXALS))
+		udelay(1);
+
+	/* Wait up to 1s for flow control if necessary */
+	if (up->port.flags & UPF_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+		       (sio_in(up, TXX9_SICISR) & TXX9_SICISR_CTSS))
+			udelay(1);
+	}
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+serial_txx9_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_txx9_port *up = &serial_txx9_ports[co->index];
+	unsigned int ier, flcr;
+	int i;
+
+	/*
+	 *	First save the UER then disable the interrupts
+	 */
+	ier = sio_in(up, TXX9_SIDICR);
+	sio_out(up, TXX9_SIDICR, 0);
+	/*
+	 *	Disable flow-control if enabled (and unnecessary)
+	 */
+	flcr = sio_in(up, TXX9_SIFLCR);
+	if (!(up->port.flags & UPF_CONS_FLOW) && (flcr & TXX9_SIFLCR_TES))
+		sio_out(up, TXX9_SIFLCR, flcr & ~TXX9_SIFLCR_TES);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		wait_for_xmitr(up);
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		sio_out(up, TXX9_SITFIFO, *s);
+		if (*s == 10) {
+			wait_for_xmitr(up);
+			sio_out(up, TXX9_SITFIFO, 13);
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(up);
+	sio_out(up, TXX9_SIFLCR, flcr);
+	sio_out(up, TXX9_SIDICR, ier);
+}
+
+static int serial_txx9_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	struct uart_txx9_port *up;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	up = &serial_txx9_ports[co->index];
+	port = &up->port;
+	if (!port->ops)
+		return -ENODEV;
+
+	/*
+	 * Temporary fix.
+	 */
+	spin_lock_init(&port->lock);
+
+	/*
+	 *	Disable UART interrupts, set DTR and RTS high
+	 *	and set speed.
+	 */
+	sio_out(up, TXX9_SIDICR, 0);
+	/* initial settings */
+	sio_out(up, TXX9_SILCR,
+		TXX9_SILCR_UMODE_8BIT | TXX9_SILCR_USBL_1BIT |
+		((port->flags & UPF_TXX9_USE_SCLK) ?
+		 TXX9_SILCR_SCS_SCLK_BG : TXX9_SILCR_SCS_IMCLK_BG));
+	sio_out(up, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX /* 15 */);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver serial_txx9_reg;
+static struct console serial_txx9_console = {
+	.name		= TXX9_TTY_NAME,
+	.write		= serial_txx9_console_write,
+	.device		= uart_console_device,
+	.setup		= serial_txx9_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial_txx9_reg,
+};
+
+static int __init serial_txx9_console_init(void)
+{
+	register_console(&serial_txx9_console);
+	return 0;
+}
+console_initcall(serial_txx9_console_init);
+
+static int __init serial_txx9_late_console_init(void)
+{
+	if (!(serial_txx9_console.flags & CON_ENABLED))
+		register_console(&serial_txx9_console);
+	return 0;
+}
+late_initcall(serial_txx9_late_console_init);
+
+#define SERIAL_TXX9_CONSOLE	&serial_txx9_console
+#else
+#define SERIAL_TXX9_CONSOLE	NULL
+#endif
+
+static struct uart_driver serial_txx9_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial_txx9",
+	.devfs_name		= TXX9_TTY_DEVFS_NAME,
+	.dev_name		= TXX9_TTY_NAME,
+	.major			= TXX9_TTY_MAJOR,
+	.minor			= TXX9_TTY_MINOR_START,
+	.nr			= UART_NR,
+	.cons			= SERIAL_TXX9_CONSOLE,
+};
+
+int __init early_serial_txx9_setup(struct uart_port *port)
+{
+	if (port->line >= ARRAY_SIZE(serial_txx9_ports))
+		return -ENODEV;
+
+	serial_txx9_ports[port->line].port = *port;
+	serial_txx9_ports[port->line].port.ops = &serial_txx9_pops;
+	serial_txx9_ports[port->line].port.flags |= UPF_BOOT_AUTOCONF;
+	return 0;
+}
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+/**
+ *	serial_txx9_suspend_port - suspend one serial port
+ *	@line:  serial line number
+ *      @level: the level of port suspension, as per uart_suspend_port
+ *
+ *	Suspend one serial port.
+ */
+static void serial_txx9_suspend_port(int line)
+{
+	uart_suspend_port(&serial_txx9_reg, &serial_txx9_ports[line].port);
+}
+
+/**
+ *	serial_txx9_resume_port - resume one serial port
+ *	@line:  serial line number
+ *      @level: the level of port resumption, as per uart_resume_port
+ *
+ *	Resume one serial port.
+ */
+static void serial_txx9_resume_port(int line)
+{
+	uart_resume_port(&serial_txx9_reg, &serial_txx9_ports[line].port);
+}
+
+/*
+ * Probe one serial board.  Unfortunately, there is no rhyme nor reason
+ * to the arrangement of serial ports on a PCI card.
+ */
+static int __devinit
+pciserial_txx9_init_one(struct pci_dev *dev, const struct pci_device_id *ent)
+{
+	struct uart_port port;
+	int line;
+	int rc;
+
+	rc = pci_enable_device(dev);
+	if (rc)
+		return rc;
+
+	memset(&port, 0, sizeof(port));
+	port.ops = &serial_txx9_pops;
+	port.flags |= UPF_BOOT_AUTOCONF; /* uart_ops.config_port will be called */
+	port.flags |= UPF_TXX9_HAVE_CTS_LINE;
+	port.uartclk = 66670000;
+	port.irq = dev->irq;
+	port.iotype = UPIO_PORT;
+	port.iobase = pci_resource_start(dev, 1);
+	line = uart_register_port(&serial_txx9_reg, &port);
+	if (line < 0) {
+		printk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), line);
+	}
+	pci_set_drvdata(dev, (void *)(long)line);
+
+	return 0;
+}
+
+static void __devexit pciserial_txx9_remove_one(struct pci_dev *dev)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	pci_set_drvdata(dev, NULL);
+
+	if (line) {
+		uart_unregister_port(&serial_txx9_reg, line);
+		pci_disable_device(dev);
+	}
+}
+
+static int pciserial_txx9_suspend_one(struct pci_dev *dev, u32 state)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	if (line)
+		serial_txx9_suspend_port(line);
+	return 0;
+}
+
+static int pciserial_txx9_resume_one(struct pci_dev *dev)
+{
+	int line = (int)(long)pci_get_drvdata(dev);
+
+	if (line)
+		serial_txx9_resume_port(line);
+	return 0;
+}
+
+static struct pci_device_id serial_txx9_pci_tbl[] = {
+	{	PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 0 },
+	{ 0, }
+};
+
+static struct pci_driver serial_txx9_pci_driver = {
+	.name		= "serial_txx9",
+	.probe		= pciserial_txx9_init_one,
+	.remove		= __devexit_p(pciserial_txx9_remove_one),
+	.suspend	= pciserial_txx9_suspend_one,
+	.resume		= pciserial_txx9_resume_one,
+	.id_table	= serial_txx9_pci_tbl,
+};
+
+MODULE_DEVICE_TABLE(pci, serial_txx9_pci_tbl);
+#endif /* ENABLE_SERIAL_TXX9_PCI */
+
+static int __init serial_txx9_init(void)
+{
+	int ret;
+
+ 	printk(KERN_INFO "%s version %s\n", serial_name, serial_version);
+
+	ret = uart_register_driver(&serial_txx9_reg);
+	if (ret >= 0) {
+		serial_txx9_register_ports(&serial_txx9_reg);
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+		ret = pci_module_init(&serial_txx9_pci_driver);
+#endif
+	}
+	return ret;
+}
+
+static void __exit serial_txx9_exit(void)
+{
+	int i;
+
+#ifdef ENABLE_SERIAL_TXX9_PCI
+	pci_unregister_driver(&serial_txx9_pci_driver);
+#endif
+	for (i = 0; i < UART_NR; i++)
+		uart_remove_one_port(&serial_txx9_reg, &serial_txx9_ports[i].port);
+
+	uart_unregister_driver(&serial_txx9_reg);
+}
+
+module_init(serial_txx9_init);
+module_exit(serial_txx9_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TX39/49 serial driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TXX9_TTY_MAJOR);
Index: linux-2.6.10/arch/mips/tx4938/common/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/setup.c
@@ -0,0 +1,89 @@
+/*
+ * linux/arch/mips/tx4938/common/setup.c
+ *
+ * common tx4938 setup routines
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/irq.h>
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/time.h>
+#include <asm/time.h>
+#include <asm/tx4938/rbtx4938.h>
+
+void __init tx4938_time_init(void);
+void __init tx4938_timer_setup(struct irqaction *irq);
+void dump_cp0(char *key);
+
+void (*__wbflush) (void);
+
+static void tx4938_write_buffer_flush(void)
+{
+	mmiowb();
+
+	__asm__ __volatile__(".set	push\n\t" 
+			     ".set	noreorder\n\t" 
+			     "lw	$0,%0\n\t" 
+			     "nop\n\t" 
+			     ".set	pop"
+			     :	/* no output */
+			     :"m"(*(int *)KSEG1)
+			     :"memory");
+}
+
+static int __init tx4938_setup(void)
+{
+	board_time_init = tx4938_time_init;
+	board_timer_setup = tx4938_timer_setup;
+	__wbflush = tx4938_write_buffer_flush;
+	{
+		extern void toshiba_rbtx4938_setup(void);
+		toshiba_rbtx4938_setup();
+	}
+	return 0;
+}
+
+early_initcall(tx4938_setup);
+
+void __init tx4938_time_init(void)
+{
+	extern void rbtx4938_time_init(void);
+	rbtx4938_time_init();
+}
+
+void __init tx4938_timer_setup(struct irqaction *irq)
+{
+	u32 count;
+	u32 c1;
+	u32 c2;
+
+	setup_irq(TX4938_IRQ_CPU_TIMER, irq);
+
+	c1 = read_c0_count();
+	count = c1 + (mips_hpt_frequency / HZ);
+	write_c0_compare(count);
+	c2 = read_c0_count();
+}
Index: linux-2.6.10/include/asm-mips/tx4938/rbtx4938.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4938/rbtx4938.h
@@ -0,0 +1,206 @@
+/*
+ * linux/include/asm-mips/tx4938/rbtx4938.h
+ * Definitions for TX4937/TX4938
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_RBTX4938_H
+#define __ASM_TX_BOARDS_RBTX4938_H
+
+#include <asm/addrspace.h>
+#include <asm/tx4938/tx4938.h>
+
+/* CS */
+#define RBTX4938_CE0	0x1c000000	/* 64M */
+#define RBTX4938_CE2	0x17f00000	/* 1M */
+
+/* Address map */
+#define RBTX4938_FPGA_REG_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000000)
+#define RBTX4938_FPGA_REV_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000002)
+#define RBTX4938_CONFIG1_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000004)
+#define RBTX4938_CONFIG2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000006)
+#define RBTX4938_CONFIG3_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000008)
+#define RBTX4938_LED_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001000)
+#define RBTX4938_DIPSW_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001002)
+#define RBTX4938_BDIPSW_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001004)
+#define RBTX4938_IMASK_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002000)
+#define RBTX4938_IMASK2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002002)
+#define RBTX4938_INTPOL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002004)
+#define RBTX4938_ISTAT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002006)
+#define RBTX4938_ISTAT2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002008)
+#define RBTX4938_IMSTAT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000200a)
+#define RBTX4938_IMSTAT2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000200c)
+#define RBTX4938_SOFTINT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00003000)
+#define RBTX4938_PIOSEL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005000)
+#define RBTX4938_SPICS_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005002)
+#define RBTX4938_SFPWR_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005008)
+#define RBTX4938_SFVOL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000500a)
+#define RBTX4938_SOFTRESET_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007000)
+#define RBTX4938_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007002)
+#define RBTX4938_PCIRESET_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007004)
+#define RBTX4938_ETHER_BASE	(KSEG1 + RBTX4938_CE2 + 0x00020000)
+
+/* Ethernet port address (Jumperless Mode (W12:Open)) */
+#define RBTX4938_ETHER_ADDR	(RBTX4938_ETHER_BASE + 0x280)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4938_INTB_PCID	0
+#define RBTX4938_INTB_PCIC	1
+#define RBTX4938_INTB_PCIB	2
+#define RBTX4938_INTB_PCIA	3
+#define RBTX4938_INTB_RTC	4
+#define RBTX4938_INTB_ATA	5
+#define RBTX4938_INTB_MODEM	6
+#define RBTX4938_INTB_SWINT	7
+#define RBTX4938_INTF_PCID	(1 << RBTX4938_INTB_PCID)
+#define RBTX4938_INTF_PCIC	(1 << RBTX4938_INTB_PCIC)
+#define RBTX4938_INTF_PCIB	(1 << RBTX4938_INTB_PCIB)
+#define RBTX4938_INTF_PCIA	(1 << RBTX4938_INTB_PCIA)
+#define RBTX4938_INTF_RTC	(1 << RBTX4938_INTB_RTC)
+#define RBTX4938_INTF_ATA	(1 << RBTX4938_INTB_ATA)
+#define RBTX4938_INTF_MODEM	(1 << RBTX4938_INTB_MODEM)
+#define RBTX4938_INTF_SWINT	(1 << RBTX4938_INTB_SWINT)
+
+#define rbtx4938_fpga_rev_ptr	\
+	((unsigned char *)RBTX4938_FPGA_REV_ADDR)
+#define rbtx4938_led_ptr	\
+	((unsigned char *)RBTX4938_LED_ADDR)
+#define rbtx4938_dipsw_ptr	\
+	((unsigned char *)RBTX4938_DIPSW_ADDR)
+#define rbtx4938_bdipsw_ptr	\
+	((unsigned char *)RBTX4938_BDIPSW_ADDR)
+#define rbtx4938_imask_ptr	\
+	((unsigned char *)RBTX4938_IMASK_ADDR)
+#define rbtx4938_imask2_ptr	\
+	((unsigned char *)RBTX4938_IMASK2_ADDR)
+#define rbtx4938_intpol_ptr	\
+	((unsigned char *)RBTX4938_INTPOL_ADDR)
+#define rbtx4938_istat_ptr	\
+	((unsigned char *)RBTX4938_ISTAT_ADDR)
+#define rbtx4938_istat2_ptr	\
+	((unsigned char *)RBTX4938_ISTAT2_ADDR)
+#define rbtx4938_imstat_ptr	\
+	((unsigned char *)RBTX4938_IMSTAT_ADDR)
+#define rbtx4938_imstat2_ptr	\
+	((unsigned char *)RBTX4938_IMSTAT2_ADDR)
+#define rbtx4938_softint_ptr	\
+	((unsigned char *)RBTX4938_SOFTINT_ADDR)
+#define rbtx4938_piosel_ptr	\
+	((unsigned char *)RBTX4938_PIOSEL_ADDR)
+#define rbtx4938_spics_ptr	\
+	((unsigned char *)RBTX4938_SPICS_ADDR)
+#define rbtx4938_sfpwr_ptr	\
+	((unsigned char *)RBTX4938_SFPWR_ADDR)
+#define rbtx4938_sfvol_ptr	\
+	((unsigned char *)RBTX4938_SFVOL_ADDR)
+#define rbtx4938_softreset_ptr	\
+	((unsigned char *)RBTX4938_SOFTRESET_ADDR)
+#define rbtx4938_softresetlock_ptr	\
+	((unsigned char *)RBTX4938_SOFTRESETLOCK_ADDR)
+#define rbtx4938_pcireset_ptr	\
+	((unsigned char *)RBTX4938_PCIRESET_ADDR)
+
+/* SPI */
+#define RBTX4938_SEEPROM1_CHIPID	0
+#define RBTX4938_SEEPROM2_CHIPID	1
+#define RBTX4938_SEEPROM3_CHIPID	2
+#define RBTX4938_SRTC_CHIPID	3
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4938_SOFT_INT0	0	/* not used */
+#define RBTX4938_SOFT_INT1	1	/* not used */
+#define RBTX4938_IRC_INT	2
+#define RBTX4938_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4938 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4938_NR_IRQ_LOCAL	8
+#define RBTX4938_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4938_NR_IRQ_IOC	8
+
+#define MI8259_IRQ_ISA_RAW_BEG   0	/* optional backplane i8259 */
+#define MI8259_IRQ_ISA_RAW_END  15
+#define TX4938_IRQ_CP0_RAW_BEG   0	/* tx4938 cpu built-in cp0 */
+#define TX4938_IRQ_CP0_RAW_END   7
+#define TX4938_IRQ_PIC_RAW_BEG   0	/* tx4938 cpu build-in pic */
+#define TX4938_IRQ_PIC_RAW_END  31
+
+#define MI8259_IRQ_ISA_BEG                          MI8259_IRQ_ISA_RAW_BEG	/*  0 */
+#define MI8259_IRQ_ISA_END                          MI8259_IRQ_ISA_RAW_END	/* 15 */
+
+#define TX4938_IRQ_CP0_BEG  ((MI8259_IRQ_ISA_END+1)+TX4938_IRQ_CP0_RAW_BEG)	/* 16 */
+#define TX4938_IRQ_CP0_END  ((MI8259_IRQ_ISA_END+1)+TX4938_IRQ_CP0_RAW_END)	/* 23 */
+
+#define TX4938_IRQ_PIC_BEG  ((TX4938_IRQ_CP0_END+1)+TX4938_IRQ_PIC_RAW_BEG)	/* 24 */
+#define TX4938_IRQ_PIC_END  ((TX4938_IRQ_CP0_END+1)+TX4938_IRQ_PIC_RAW_END)	/* 55 */
+#define TX4938_IRQ_NEST_EXT_ON_PIC  (TX4938_IRQ_PIC_BEG+2)
+#define TX4938_IRQ_NEST_PIC_ON_CP0  (TX4938_IRQ_CP0_BEG+2)
+#define TX4938_IRQ_USER0            (TX4938_IRQ_CP0_BEG+0)
+#define TX4938_IRQ_USER1            (TX4938_IRQ_CP0_BEG+1)
+#define TX4938_IRQ_CPU_TIMER        (TX4938_IRQ_CP0_BEG+7)
+
+#define TOSHIBA_RBTX4938_IRQ_IOC_RAW_BEG   0
+#define TOSHIBA_RBTX4938_IRQ_IOC_RAW_END   7
+
+#define TOSHIBA_RBTX4938_IRQ_IOC_BEG  ((TX4938_IRQ_PIC_END+1)+TOSHIBA_RBTX4938_IRQ_IOC_RAW_BEG)	/* 56 */
+#define TOSHIBA_RBTX4938_IRQ_IOC_END  ((TX4938_IRQ_PIC_END+1)+TOSHIBA_RBTX4938_IRQ_IOC_RAW_END)	/* 63 */
+#define RBTX4938_IRQ_LOCAL	TX4938_IRQ_CP0_BEG
+#define RBTX4938_IRQ_IRC	(RBTX4938_IRQ_LOCAL + RBTX4938_NR_IRQ_LOCAL)
+#define RBTX4938_IRQ_IOC	(RBTX4938_IRQ_IRC + RBTX4938_NR_IRQ_IRC)
+#define RBTX4938_IRQ_END	(RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC)
+
+#define RBTX4938_IRQ_LOCAL_SOFT0	(RBTX4938_IRQ_LOCAL + RBTX4938_SOFT_INT0)
+#define RBTX4938_IRQ_LOCAL_SOFT1	(RBTX4938_IRQ_LOCAL + RBTX4938_SOFT_INT1)
+#define RBTX4938_IRQ_LOCAL_IRC	(RBTX4938_IRQ_LOCAL + RBTX4938_IRC_INT)
+#define RBTX4938_IRQ_LOCAL_TIMER	(RBTX4938_IRQ_LOCAL + RBTX4938_TIMER_INT)
+#define RBTX4938_IRQ_IRC_ECCERR	(RBTX4938_IRQ_IRC + TX4938_IR_ECCERR)
+#define RBTX4938_IRQ_IRC_WTOERR	(RBTX4938_IRQ_IRC + TX4938_IR_WTOERR)
+#define RBTX4938_IRQ_IRC_INT(n)	(RBTX4938_IRQ_IRC + TX4938_IR_INT(n))
+#define RBTX4938_IRQ_IRC_SIO(n)	(RBTX4938_IRQ_IRC + TX4938_IR_SIO(n))
+#define RBTX4938_IRQ_IRC_DMA(ch,n)	(RBTX4938_IRQ_IRC + TX4938_IR_DMA(ch,n))
+#define RBTX4938_IRQ_IRC_PIO	(RBTX4938_IRQ_IRC + TX4938_IR_PIO)
+#define RBTX4938_IRQ_IRC_PDMAC	(RBTX4938_IRQ_IRC + TX4938_IR_PDMAC)
+#define RBTX4938_IRQ_IRC_PCIC	(RBTX4938_IRQ_IRC + TX4938_IR_PCIC)
+#define RBTX4938_IRQ_IRC_TMR(n)	(RBTX4938_IRQ_IRC + TX4938_IR_TMR(n))
+#define RBTX4938_IRQ_IRC_NDFMC	(RBTX4938_IRQ_IRC + TX4938_IR_NDFMC)
+#define RBTX4938_IRQ_IRC_PCIERR	(RBTX4938_IRQ_IRC + TX4938_IR_PCIERR)
+#define RBTX4938_IRQ_IRC_PCIPME	(RBTX4938_IRQ_IRC + TX4938_IR_PCIPME)
+#define RBTX4938_IRQ_IRC_ACLC	(RBTX4938_IRQ_IRC + TX4938_IR_ACLC)
+#define RBTX4938_IRQ_IRC_ACLCPME	(RBTX4938_IRQ_IRC + TX4938_IR_ACLCPME)
+#define RBTX4938_IRQ_IRC_PCIC1	(RBTX4938_IRQ_IRC + TX4938_IR_PCIC1)
+#define RBTX4938_IRQ_IRC_SPI	(RBTX4938_IRQ_IRC + TX4938_IR_SPI)
+#define RBTX4938_IRQ_IOC_PCID	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCID)
+#define RBTX4938_IRQ_IOC_PCIC	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIC)
+#define RBTX4938_IRQ_IOC_PCIB	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIB)
+#define RBTX4938_IRQ_IOC_PCIA	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIA)
+#define RBTX4938_IRQ_IOC_RTC	(RBTX4938_IRQ_IOC + RBTX4938_INTB_RTC)
+#define RBTX4938_IRQ_IOC_ATA	(RBTX4938_IRQ_IOC + RBTX4938_INTB_ATA)
+#define RBTX4938_IRQ_IOC_MODEM	(RBTX4938_IRQ_IOC + RBTX4938_INTB_MODEM)
+#define RBTX4938_IRQ_IOC_SWINT	(RBTX4938_IRQ_IOC + RBTX4938_INTB_SWINT)
+
+/* IOC (PCI, etc) */
+#define RBTX4938_IRQ_IOCINT	(TX4938_IRQ_NEST_EXT_ON_PIC)
+/* Onboard 10M Ether */
+#define RBTX4938_IRQ_ETHER	(TX4938_IRQ_NEST_EXT_ON_PIC + 1)
+
+#define RBTX4938_RTL_8019_BASE (RBTX4938_ETHER_ADDR - mips_io_port_base)
+#define RBTX4938_RTL_8019_IRQ  (RBTX4938_IRQ_ETHER)
+
+/* IRCR : Int. Control */
+#define TX4938_IRCR_LOW  0x00000000
+#define TX4938_IRCR_HIGH 0x00000001
+#define TX4938_IRCR_DOWN 0x00000002
+#define TX4938_IRCR_UP   0x00000003
+
+#endif				/* __ASM_TX_BOARDS_RBTX4938_H */
Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -925,6 +925,21 @@ config TOSHIBA_FPCIB0
 	bool "FPCIB0 Backplane Support"
 	depends on TOSHIBA_RBTX4927
 
+config TOSHIBA_RBTX4938
+	bool "Support for Toshiba RBTX4938 board"
+	select HAVE_STD_PC_SERIAL_PORT
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
+	select HW_HAS_PCI
+	select HAS_TXX9_SERIAL
+	select I8259
+	select ISA
+	select SWAP_IO_SPACE
+	select TOSHIBA_BOARDS
+	help
+	  This Toshiba board is based on the TX4938 processor. Say Y here to
+	  support this machine type
+
 source "lib/Kconfig.RT"
 
 config RWSEM_GENERIC_SPINLOCK
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -159,6 +159,7 @@
 #define  MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
 #define  MACH_TOSHIBA_RBTX4927	4
 #define  MACH_TOSHIBA_RBTX4937	5
+#define  MACH_TOSHIBA_RBTX4938	6
 
 #define GROUP_TOSHIBA_NAMES	{ "Pallas", "TopasCE", "JMR", "JMR TX3927", \
 				  "RBTX4927", "RBTX4937" }
Index: linux-2.6.10/drivers/net/ne.c
===================================================================
--- linux-2.6.10.orig/drivers/net/ne.c
+++ linux-2.6.10/drivers/net/ne.c
@@ -54,6 +54,10 @@ static const char version2[] =
 #include <asm/system.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+#include <asm/tx4938/rbtx4938.h>
+#endif
+
 #include "8390.h"
 
 #define DRV_NAME "ne"
@@ -111,6 +115,9 @@ bad_clone_list[] __initdata = {
     {"E-LAN100", "E-LAN200", {0x00, 0x00, 0x5d}}, /* Broken ne1000 clones */
     {"PCM-4823", "PCM-4823", {0x00, 0xc0, 0x6c}}, /* Broken Advantech MoBo */
     {"REALTEK", "RTL8019", {0x00, 0x00, 0xe8}}, /* no-name with Realtek chip */
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+    {"RBHMA4X00-RTL8019", "RBHMA4X00/RTL8019", {0x00, 0x60, 0x0a}},  /* Toshiba built-in */
+#endif
     {"LCS-8834", "LCS-8836", {0x04, 0x04, 0x37}}, /* ShinyNet (SET) */
     {NULL,}
 };
@@ -226,6 +233,10 @@ struct net_device * __init ne_probe(int 
 	sprintf(dev->name, "eth%d", unit);
 	netdev_boot_setup_check(dev);
 
+#ifdef CONFIG_TOSHIBA_RBTX4938
+	dev->base_addr = 0x07f20280;
+	dev->irq = RBTX4938_RTL_8019_IRQ;
+#endif
 	err = do_ne_probe(dev);
 	if (err)
 		goto out;
@@ -511,6 +522,10 @@ static int __init ne_probe1(struct net_d
 	ei_status.name = name;
 	ei_status.tx_start_page = start_page;
 	ei_status.stop_page = stop_page;
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+	wordlength = 1;
+#endif
+
 #ifdef CONFIG_PLAT_OAKS32R
 	ei_status.word16 = 0;
 #else
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/irq.c
@@ -0,0 +1,233 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/irq.c
+ *
+ * Toshiba RBTX4938 specific interrupt handlers
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+/*
+IRQ  Device  
+
+16   TX4938-CP0/00 Software 0
+17   TX4938-CP0/01 Software 1
+18   TX4938-CP0/02 Cascade TX4938-CP0
+19   TX4938-CP0/03 Multiplexed -- do not use 
+20   TX4938-CP0/04 Multiplexed -- do not use 
+21   TX4938-CP0/05 Multiplexed -- do not use 
+22   TX4938-CP0/06 Multiplexed -- do not use 
+23   TX4938-CP0/07 CPU TIMER
+
+24   TX4938-PIC/00 
+25   TX4938-PIC/01 
+26   TX4938-PIC/02 Cascade RBTX4938-IOC
+27   TX4938-PIC/03 RBTX4938 RTL-8019AS Ethernet 
+28   TX4938-PIC/04 
+29   TX4938-PIC/05 TX4938 ETH1
+30   TX4938-PIC/06 TX4938 ETH0
+31   TX4938-PIC/07 
+32   TX4938-PIC/08 TX4938 SIO 0
+33   TX4938-PIC/09 TX4938 SIO 1
+34   TX4938-PIC/10 TX4938 DMA0
+35   TX4938-PIC/11 TX4938 DMA1
+36   TX4938-PIC/12 TX4938 DMA2
+37   TX4938-PIC/13 TX4938 DMA3
+38   TX4938-PIC/14
+39   TX4938-PIC/15
+40   TX4938-PIC/16 TX4938 PCIC
+41   TX4938-PIC/17 TX4938 TMR0
+42   TX4938-PIC/18 TX4938 TMR1
+43   TX4938-PIC/19 TX4938 TMR2
+44   TX4938-PIC/20
+45   TX4938-PIC/21
+46   TX4938-PIC/22 TX4938 PCIERR
+47   TX4938-PIC/23
+48   TX4938-PIC/24
+49   TX4938-PIC/25
+50   TX4938-PIC/26
+51   TX4938-PIC/27
+52   TX4938-PIC/28
+53   TX4938-PIC/29
+54   TX4938-PIC/30
+55   TX4938-PIC/31 TX4938 SPI
+
+56 RBTX4938-IOC/00 PCI-D
+57 RBTX4938-IOC/01 PCI-C
+58 RBTX4938-IOC/02 PCI-B
+59 RBTX4938-IOC/03 PCI-A
+60 RBTX4938-IOC/04 RTC
+61 RBTX4938-IOC/05 ATA
+62 RBTX4938-IOC/06 MODEM
+63 RBTX4938-IOC/07 SWINT
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/timex.h>
+#include <asm/page.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/processor.h>
+#include <asm/ptrace.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <linux/version.h>
+#include <linux/bootmem.h>
+#include <asm/tx4938/rbtx4938.h>
+
+static unsigned int toshiba_rbtx4938_irq_ioc_startup(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_shutdown(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_disable(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_mask_and_ack(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_end(unsigned int irq);
+
+DEFINE_SPINLOCK(toshiba_rbtx4938_ioc_lock);
+
+#define TOSHIBA_RBTX4938_IOC_NAME "RBTX4938-IOC"
+static struct hw_interrupt_type toshiba_rbtx4938_irq_ioc_type = {
+	.typename = TOSHIBA_RBTX4938_IOC_NAME,
+	.startup = toshiba_rbtx4938_irq_ioc_startup,
+	.shutdown = toshiba_rbtx4938_irq_ioc_shutdown,
+	.enable = toshiba_rbtx4938_irq_ioc_enable,
+	.disable = toshiba_rbtx4938_irq_ioc_disable,
+	.ack = toshiba_rbtx4938_irq_ioc_mask_and_ack,
+	.end = toshiba_rbtx4938_irq_ioc_end,
+	.set_affinity = NULL
+};
+
+#define TOSHIBA_RBTX4938_IOC_INTR_ENAB 0xb7f02000
+#define TOSHIBA_RBTX4938_IOC_INTR_STAT 0xb7f0200a
+
+int toshiba_rbtx4938_irq_nested(int sw_irq)
+{
+	u8 level3;
+
+	level3 = TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_STAT) & 0xff;
+	if (level3) {
+		/* must use last_bit2num so onboard ATA has priority */
+		sw_irq = TOSHIBA_RBTX4938_IRQ_IOC_BEG + fls(level3) - 1;
+	}
+
+	wbflush();
+	return sw_irq;
+}
+
+static struct irqaction toshiba_rbtx4938_irq_ioc_action =
+	{ no_action, 0, CPU_MASK_NONE, TOSHIBA_RBTX4938_IOC_NAME, NULL, NULL };
+
+/**********************************************************************************/
+/* Functions for ioc                                                              */
+/**********************************************************************************/
+static void __init toshiba_rbtx4938_irq_ioc_init(void)
+{
+	int i;
+
+	for (i = TOSHIBA_RBTX4938_IRQ_IOC_BEG;
+	     i <= TOSHIBA_RBTX4938_IRQ_IOC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 3;
+		irq_desc[i].handler = &toshiba_rbtx4938_irq_ioc_type;
+	}
+
+	setup_irq(RBTX4938_IRQ_IOCINT, &toshiba_rbtx4938_irq_ioc_action);
+}
+
+static unsigned int toshiba_rbtx4938_irq_ioc_startup(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_enable(irq);
+
+	return 0;
+}
+
+static void toshiba_rbtx4938_irq_ioc_shutdown(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_disable(irq);
+}
+
+static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq)
+{
+	unsigned long flags;
+	volatile unsigned char v;
+
+	spin_lock_irqsave(&toshiba_rbtx4938_ioc_lock, flags);
+
+	v = TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+	v |= (1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	TX4938_WR08(TOSHIBA_RBTX4938_IOC_INTR_ENAB, v);
+	mmiowb();
+	TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+
+	spin_unlock_irqrestore(&toshiba_rbtx4938_ioc_lock, flags);
+}
+
+static void toshiba_rbtx4938_irq_ioc_disable(unsigned int irq)
+{
+	unsigned long flags;
+	volatile unsigned char v;
+
+	spin_lock_irqsave(&toshiba_rbtx4938_ioc_lock, flags);
+
+	v = TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+	v &= ~(1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	TX4938_WR08(TOSHIBA_RBTX4938_IOC_INTR_ENAB, v);
+	mmiowb();
+	TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+
+	spin_unlock_irqrestore(&toshiba_rbtx4938_ioc_lock, flags);
+}
+
+static void toshiba_rbtx4938_irq_ioc_mask_and_ack(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_disable(irq);
+}
+
+static void toshiba_rbtx4938_irq_ioc_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		toshiba_rbtx4938_irq_ioc_enable(irq);
+	}
+}
+
+extern void __init txx9_spi_irqinit(int irc_irq);
+
+void __init arch_init_irq(void)
+{
+	extern void tx4938_irq_init(void);
+
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	/* mask all IOC interrupts */
+	TX4938_WR(rbtx4938_imask_ptr, 0);
+
+	/* clear SoftInt interrupts */
+	TX4938_WR(rbtx4938_softint_ptr, 0);
+	tx4938_irq_init();
+	toshiba_rbtx4938_irq_ioc_init();
+	/* Onboard 10M Ether: High Active */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM0), 0x00000040);
+
+	if (TX4938_RD64(&tx4938_ccfgptr->pcfg) & TX4938_PCFG_SPI_SEL) {
+		txx9_spi_irqinit(RBTX4938_IRQ_IRC_SPI);
+	}
+
+	wbflush();
+}
Index: linux-2.6.10/arch/mips/pci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/pci/Makefile
+++ linux-2.6.10/arch/mips/pci/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
 obj-$(CONFIG_TOSHIBA_JMR3927)	+= fixup-jmr3927.o pci-jmr3927.o
 obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o ops-tx4927.o
+obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-tx4938.o ops-tx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_VR5701_SG2)	+= pci-vr5701_sg2.o ops-vr5701_sg2.o
Index: linux-2.6.10/arch/mips/pci/ops-tx4938.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/ops-tx4938.c
@@ -0,0 +1,204 @@
+/*
+ * Define the pci_ops for the Toshiba rbtx4938
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/config.h>
+
+#include <asm/addrspace.h>
+#include <asm/tx4938/rbtx4938.h>
+
+/* initialize in setup */
+struct resource pci_io_resource = {
+	.name	= "pci IO space",
+	.start	= 0,
+	.end	= 0,
+	.flags	= IORESOURCE_IO
+};
+
+/* initialize in setup */
+struct resource pci_mem_resource = {
+	.name	= "pci memory space",
+	.start	= 0,
+	.end	= 0,
+	.flags	= IORESOURCE_MEM
+};
+
+struct resource tx4938_pcic1_pci_io_resource = {
+       	.name	= "PCI1 IO",
+       	.start	= 0,
+       	.end	= 0,
+       	.flags	= IORESOURCE_IO
+};
+struct resource tx4938_pcic1_pci_mem_resource = {
+       	.name	= "PCI1 mem",
+       	.start	= 0,
+       	.end	= 0,
+       	.flags	= IORESOURCE_MEM
+};
+
+static int mkaddr(int bus, int dev_fn, int where, int *flagsp) 
+{
+	unsigned long l;
+
+	if (bus > 0) {
+		/* Type 1 configuration */
+		TX4938_WR(&tx4938_pcicptr->g2pcfgadrs, ((bus & 0xff) << 0x10) |
+			  ((dev_fn & 0xff) << 0x08) | (where & 0xfc) | 1);
+	} else {
+		if (dev_fn >= PCI_DEVFN(TX4938_PCIC_MAX_DEVNU, 0))
+			return -1;
+
+		/* Type 0 configuration */
+		TX4938_WR(&tx4938_pcicptr->g2pcfgadrs, ((bus & 0xff) << 0x10) |
+			  ((dev_fn & 0xff) << 0x08) | (where & 0xfc));
+	}
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	TX4938_WR(&tx4938_pcicptr->pcistatus,
+		  (TX4938_RD(&tx4938_pcicptr->pcistatus) & 0x0000ffff) |
+		  (PCI_STATUS_REC_MASTER_ABORT << 16));
+	
+	l = TX4938_RD(&tx4938_pcicptr->pcimask);
+	TX4938_WR(&tx4938_pcicptr->pcimask, l & ~PCI_STATUS_REC_MASTER_ABORT);
+
+	return 0;
+}
+
+static int check_abort(int flags)
+{
+	int code = PCIBIOS_SUCCESSFUL;
+	unsigned long l;
+	/* wait write cycle completion before checking error status */
+	while (TX4938_RD(&tx4938_pcicptr->pcicstatus) & TX4938_PCIC_PCICSTATUS_IWB)
+		;         
+	if (TX4938_RD(&tx4938_pcicptr->pcistatus) & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		TX4938_WR(&tx4938_pcicptr->pcistatus,
+			  (TX4938_RD(&tx4938_pcicptr->pcistatus) & 0x0000ffff) | 
+			  (PCI_STATUS_REC_MASTER_ABORT << 16));
+		l = TX4938_RD(&tx4938_pcicptr->pcimask);
+		TX4938_WR(&tx4938_pcicptr->pcimask, l|PCI_STATUS_REC_MASTER_ABORT);
+		code = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return code;
+}
+
+static int tx4938_pcibios_read_config(struct pci_bus *bus, unsigned int devfn, 
+					int where, int size, u32 * val)
+{
+	int flags, retval, dev, busno, func;
+	
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) 
+		busno = bus->number;
+	else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*val = *(volatile u8 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			      ((where & 3) ^ 3));
+#else
+			      (where & 3));
+#endif
+		break;
+	case 2:
+		*val = *(volatile u16 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+				((where & 3) ^ 2));
+#else
+				(where & 3));
+#endif
+		break;
+	case 4:
+		*val = TX4938_RD(&tx4938_pcicptr->g2pcfgdata);
+		break;
+	}
+	
+	retval = check_abort(flags);
+	if (retval == PCIBIOS_DEVICE_NOT_FOUND)
+		*val = 0xffffffff;
+
+	return retval;
+}
+
+static int tx4938_pcibios_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+						int size, u32 val)
+{
+	int flags, dev, busno, func;
+
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		busno = bus->number;
+	} else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*(volatile u8 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			  ((where & 3) ^ 3)) = val;
+#else
+			  (where & 3)) = val;
+#endif
+		break;
+	case 2:
+		*(volatile u16 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			((where & 0x3) ^ 0x2)) = val;
+#else
+			(where & 3)) = val;
+#endif
+		break;
+	case 4:
+		TX4938_WR(&tx4938_pcicptr->g2pcfgdata, val);
+		break;
+	}
+
+	return check_abort(flags);
+}
+
+struct pci_ops tx4938_pci_ops = {
+	tx4938_pcibios_read_config,
+	tx4938_pcibios_write_config
+};
+
+struct pci_controller tx4938_pci_controller[] = {
+	/* h/w only supports devices 0x00 to 0x14 */
+	{
+		.pci_ops        = &tx4938_pci_ops,
+		.io_resource    = &pci_io_resource,
+		.mem_resource   = &pci_mem_resource,
+	},
+	/* h/w only supports devices 0x00 to 0x14 */
+	{       
+		.pci_ops        = &tx4938_pci_ops,
+		.io_resource    = &tx4938_pcic1_pci_io_resource,
+		.mem_resource   = &tx4938_pcic1_pci_mem_resource,
+        }
+};
Index: linux-2.6.10/include/linux/serial_core.h
===================================================================
--- linux-2.6.10.orig/include/linux/serial_core.h
+++ linux-2.6.10/include/linux/serial_core.h
@@ -103,6 +103,9 @@
 /* Marvell MPSC */
 #define PORT_MPSC	63
 
+/* TXX9 type number */
+#define PORT_TXX9	64
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
Index: linux-2.6.10/include/asm-mips/tx4938/tx4938.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4938/tx4938.h
@@ -0,0 +1,701 @@
+/*
+ * linux/include/asm-mips/tx4938/tx4938.h
+ * Definitions for TX4937/TX4938
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_TX4938_H
+#define __ASM_TX_BOARDS_TX4938_H
+
+#include <asm/tx4938/tx4938_mips.h>
+
+#define tx4938_read_nfmc(addr) (*(volatile unsigned int *)(addr))
+#define tx4938_write_nfmc(b,addr) (*(volatile unsigned int *)(addr)) = (b)
+
+#define TX4938_NR_IRQ_LOCAL     TX4938_IRQ_PIC_BEG
+
+#define TX4938_IRQ_IRC_PCIC     (TX4938_NR_IRQ_LOCAL + TX4938_IR_PCIC)
+#define TX4938_IRQ_IRC_PCIERR   (TX4938_NR_IRQ_LOCAL + TX4938_IR_PCIERR)
+
+#define TX4938_PCIIO_0 0x10000000
+#define TX4938_PCIIO_1 0x01010000
+#define TX4938_PCIMEM_0 0x08000000
+#define TX4938_PCIMEM_1 0x11000000
+
+#define TX4938_PCIIO_SIZE_0 0x01000000
+#define TX4938_PCIIO_SIZE_1 0x00010000
+#define TX4938_PCIMEM_SIZE_0 0x08000000
+#define TX4938_PCIMEM_SIZE_1 0x00010000
+
+#define TX4938_REG_BASE	0xff1f0000	/* == TX4937_REG_BASE */
+#define TX4938_REG_SIZE	0x00010000	/* == TX4937_REG_SIZE */
+
+/* NDFMC, SRAMC, PCIC1, SPIC: TX4938 only */
+#define TX4938_NDFMC_REG	(TX4938_REG_BASE + 0x5000)
+#define TX4938_SRAMC_REG	(TX4938_REG_BASE + 0x6000)
+#define TX4938_PCIC1_REG	(TX4938_REG_BASE + 0x7000)
+#define TX4938_SDRAMC_REG	(TX4938_REG_BASE + 0x8000)
+#define TX4938_EBUSC_REG	(TX4938_REG_BASE + 0x9000)
+#define TX4938_DMA_REG(ch)	(TX4938_REG_BASE + 0xb000 + (ch) * 0x800)
+#define TX4938_PCIC_REG		(TX4938_REG_BASE + 0xd000)
+#define TX4938_CCFG_REG		(TX4938_REG_BASE + 0xe000)
+#define TX4938_NR_TMR	3
+#define TX4938_TMR_REG(ch)	((TX4938_REG_BASE + 0xf000) + (ch) * 0x100)
+#define TX4938_NR_SIO	2
+#define TX4938_SIO_REG(ch)	((TX4938_REG_BASE + 0xf300) + (ch) * 0x100)
+#define TX4938_PIO_REG		(TX4938_REG_BASE + 0xf500)
+#define TX4938_IRC_REG		(TX4938_REG_BASE + 0xf600)
+#define TX4938_ACLC_REG		(TX4938_REG_BASE + 0xf700)
+#define TX4938_SPI_REG		(TX4938_REG_BASE + 0xf800)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#include <asm/byteorder.h>
+
+#define TX4938_MKA(x) ((u32)( ((u32)(TX4938_REG_BASE)) | ((u32)(x)) ))
+
+#define TX4938_RD08( reg      )   (*(vu08*)(reg))
+#define TX4938_WR08( reg, val )  ((*(vu08*)(reg))=(val))
+
+#define TX4938_RD16( reg      )   (*(vu16*)(reg))
+#define TX4938_WR16( reg, val )  ((*(vu16*)(reg))=(val))
+
+#define TX4938_RD32( reg      )   (*(vu32*)(reg))
+#define TX4938_WR32( reg, val )  ((*(vu32*)(reg))=(val))
+
+#define TX4938_RD64( reg      )   (*(vu64*)(reg))
+#define TX4938_WR64( reg, val )  ((*(vu64*)(reg))=(val))
+
+#define TX4938_RD( reg      ) TX4938_RD32( reg )
+#define TX4938_WR( reg, val ) TX4938_WR32( reg, val )
+
+#endif				/* !__ASSEMBLY__ */
+
+#ifdef __ASSEMBLY__
+#define _CONST64(c)	c
+#else
+#define _CONST64(c)	c##ull
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+#define endian_def_l2(e1,e2)	\
+	unsigned long e1,e2
+#define endian_def_s2(e1,e2)	\
+	unsigned short e1,e2
+#define endian_def_sb2(e1,e2,e3)	\
+	unsigned short e1; unsigned char e2,e3
+#define endian_def_b2s(e1,e2,e3)	\
+	unsigned char e1,e2; unsigned short e3
+#define endian_def_b4(e1,e2,e3,e4)	\
+	unsigned char e1,e2,e3,e4
+#else
+#define endian_def_l2(e1,e2)	\
+	unsigned long e2,e1
+#define endian_def_s2(e1,e2)	\
+	unsigned short e2,e1
+#define endian_def_sb2(e1,e2,e3)	\
+	unsigned char e3,e2; unsigned short e1
+#define endian_def_b2s(e1,e2,e3)	\
+	unsigned short e3; unsigned char e2,e1
+#define endian_def_b4(e1,e2,e3,e4)	\
+	unsigned char e4,e3,e2,e1
+#endif
+
+struct tx4938_sdramc_reg {
+	unsigned long long cr[4];
+	unsigned long long unused0[4];
+	unsigned long long tr;
+	unsigned long long unused1[2];
+	unsigned long long cmd;
+	unsigned long long sfcmd;
+};
+
+struct tx4938_ebusc_reg {
+	unsigned long long cr[8];
+};
+
+struct tx4938_dma_reg {
+	struct tx4938_dma_ch_reg {
+		unsigned long long cha;
+		unsigned long long sar;
+		unsigned long long dar;
+		 endian_def_l2(unused0, cntr);
+		 endian_def_l2(unused1, sair);
+		 endian_def_l2(unused2, dair);
+		 endian_def_l2(unused3, ccr);
+		 endian_def_l2(unused4, csr);
+	} ch[4];
+	unsigned long long dbr[8];
+	unsigned long long tdhr;
+	unsigned long long midr;
+	 endian_def_l2(unused0, mcr);
+};
+
+struct tx4938_pcic_reg {
+	unsigned long pciid;
+	unsigned long pcistatus;
+	unsigned long pciccrev;
+	unsigned long pcicfg1;
+	unsigned long p2gm0plbase;	/* +10 */
+	unsigned long p2gm0pubase;
+	unsigned long p2gm1plbase;
+	unsigned long p2gm1pubase;
+	unsigned long p2gm2pbase;	/* +20 */
+	unsigned long p2giopbase;
+	unsigned long unused0;
+	unsigned long pcisid;
+	unsigned long unused1;	/* +30 */
+	unsigned long pcicapptr;
+	unsigned long unused2;
+	unsigned long pcicfg2;
+	unsigned long g2ptocnt;	/* +40 */
+	unsigned long unused3[15];
+	unsigned long g2pstatus;	/* +80 */
+	unsigned long g2pmask;
+	unsigned long pcisstatus;
+	unsigned long pcimask;
+	unsigned long p2gcfg;	/* +90 */
+	unsigned long p2gstatus;
+	unsigned long p2gmask;
+	unsigned long p2gccmd;
+	unsigned long unused4[24];	/* +a0 */
+	unsigned long pbareqport;	/* +100 */
+	unsigned long pbacfg;
+	unsigned long pbastatus;
+	unsigned long pbamask;
+	unsigned long pbabm;	/* +110 */
+	unsigned long pbacreq;
+	unsigned long pbacgnt;
+	unsigned long pbacstate;
+	unsigned long long g2pmgbase[3];	/* +120 */
+	unsigned long long g2piogbase;
+	unsigned long g2pmmask[3];	/* +140 */
+	unsigned long g2piomask;
+	unsigned long long g2pmpbase[3];	/* +150 */
+	unsigned long long g2piopbase;
+	unsigned long pciccfg;	/* +170 */
+	unsigned long pcicstatus;
+	unsigned long pcicmask;
+	unsigned long unused5;
+	unsigned long long p2gmgbase[3];	/* +180 */
+	unsigned long long p2giogbase;
+	unsigned long g2pcfgadrs;	/* +1a0 */
+	unsigned long g2pcfgdata;
+	unsigned long unused6[8];
+	unsigned long g2pintack;
+	unsigned long g2pspc;
+	unsigned long unused7[12];	/* +1d0 */
+	unsigned long long pdmca;	/* +200 */
+	unsigned long long pdmga;
+	unsigned long long pdmpa;
+	unsigned long long pdmctr;
+	unsigned long long pdmcfg;	/* +220 */
+	unsigned long long pdmsts;
+};
+
+struct tx4938_aclc_reg {
+	unsigned long acctlen;
+	unsigned long acctldis;
+	unsigned long acregacc;
+	unsigned long unused0;
+	unsigned long acintsts;
+	unsigned long acintmsts;
+	unsigned long acinten;
+	unsigned long acintdis;
+	unsigned long acsemaph;
+	unsigned long unused1[7];
+	unsigned long acgpidat;
+	unsigned long acgpodat;
+	unsigned long acslten;
+	unsigned long acsltdis;
+	unsigned long acfifosts;
+	unsigned long unused2[11];
+	unsigned long acdmasts;
+	unsigned long acdmasel;
+	unsigned long unused3[6];
+	unsigned long acaudodat;
+	unsigned long acsurrdat;
+	unsigned long accentdat;
+	unsigned long aclfedat;
+	unsigned long acaudiat;
+	unsigned long unused4;
+	unsigned long acmodoat;
+	unsigned long acmodidat;
+	unsigned long unused5[15];
+	unsigned long acrevid;
+};
+
+struct tx4938_tmr_reg {
+	unsigned long tcr;
+	unsigned long tisr;
+	unsigned long cpra;
+	unsigned long cprb;
+	unsigned long itmr;
+	unsigned long unused0[3];
+	unsigned long ccdr;
+	unsigned long unused1[3];
+	unsigned long pgmr;
+	unsigned long unused2[3];
+	unsigned long wtmr;
+	unsigned long unused3[43];
+	unsigned long trr;
+};
+
+struct tx4938_sio_reg {
+	unsigned long lcr;
+	unsigned long dicr;
+	unsigned long disr;
+	unsigned long cisr;
+	unsigned long fcr;
+	unsigned long flcr;
+	unsigned long bgr;
+	unsigned long tfifo;
+	unsigned long rfifo;
+};
+
+struct tx4938_pio_reg {
+	unsigned long dout;
+	unsigned long din;
+	unsigned long dir;
+	unsigned long od;
+	unsigned long flag[2];
+	unsigned long pol;
+	unsigned long intc;
+	unsigned long maskcpu;
+	unsigned long maskext;
+};
+struct tx4938_irc_reg {
+	unsigned long cer;
+	unsigned long cr[2];
+	unsigned long unused0;
+	unsigned long ilr[8];
+	unsigned long unused1[4];
+	unsigned long imr;
+	unsigned long unused2[7];
+	unsigned long scr;
+	unsigned long unused3[7];
+	unsigned long ssr;
+	unsigned long unused4[7];
+	unsigned long csr;
+};
+
+struct tx4938_ndfmc_reg {
+	endian_def_l2(unused0, dtr);
+	endian_def_l2(unused1, mcr);
+	endian_def_l2(unused2, sr);
+	endian_def_l2(unused3, isr);
+	endian_def_l2(unused4, imr);
+	endian_def_l2(unused5, spr);
+	endian_def_l2(unused6, rstr);
+};
+
+struct tx4938_spi_reg {
+	unsigned long mcr;
+	unsigned long cr0;
+	unsigned long cr1;
+	unsigned long fs;
+	unsigned long unused1;
+	unsigned long sr;
+	unsigned long dr;
+	unsigned long unused2;
+};
+
+struct tx4938_sramc_reg {
+	unsigned long long cr;
+};
+
+struct tx4938_ccfg_reg {
+	unsigned long long ccfg;
+	unsigned long long crir;
+	unsigned long long pcfg;
+	unsigned long long tear;
+	unsigned long long clkctr;
+	unsigned long long unused0;
+	unsigned long long garbc;
+	unsigned long long unused1;
+	unsigned long long unused2;
+	unsigned long long ramp;
+	unsigned long long unused3;
+	unsigned long long jmpadr;
+};
+
+#undef endian_def_l2
+#undef endian_def_s2
+#undef endian_def_sb2
+#undef endian_def_b2s
+#undef endian_def_b4
+
+#endif				/* __ASSEMBLY__ */
+
+/*
+ * NDFMC
+ */
+
+/* NDFMCR : NDFMC Mode Control */
+#define TX4938_NDFMCR_WE	0x80
+#define TX4938_NDFMCR_ECC_ALL	0x60
+#define TX4938_NDFMCR_ECC_RESET	0x60
+#define TX4938_NDFMCR_ECC_READ	0x40
+#define TX4938_NDFMCR_ECC_ON	0x20
+#define TX4938_NDFMCR_ECC_OFF	0x00
+#define TX4938_NDFMCR_CE	0x10
+#define TX4938_NDFMCR_BSPRT	0x04
+#define TX4938_NDFMCR_ALE	0x02
+#define TX4938_NDFMCR_CLE	0x01
+
+/* NDFMCR : NDFMC Status */
+#define TX4938_NDFSR_BUSY	0x80
+
+/* NDFMCR : NDFMC Reset */
+#define TX4938_NDFRSTR_RST	0x01
+
+/*
+ * IRC
+ */
+
+#define TX4938_IR_ECCERR	0
+#define TX4938_IR_WTOERR	1
+#define TX4938_NUM_IR_INT	6
+#define TX4938_IR_INT(n)	(2 + (n))
+#define TX4938_NUM_IR_SIO	2
+#define TX4938_IR_SIO(n)	(8 + (n))
+#define TX4938_NUM_IR_DMA	4
+#define TX4938_IR_DMA(ch,n)	((ch ? 27 : 10) + (n))	/* 10-13,27-30 */
+#define TX4938_IR_PIO	14
+#define TX4938_IR_PDMAC	15
+#define TX4938_IR_PCIC	16
+#define TX4938_NUM_IR_TMR	3
+#define TX4938_IR_TMR(n)	(17 + (n))
+#define TX4938_IR_NDFMC	21
+#define TX4938_IR_PCIERR	22
+#define TX4938_IR_PCIPME	23
+#define TX4938_IR_ACLC	24
+#define TX4938_IR_ACLCPME	25
+#define TX4938_IR_PCIC1	26
+#define TX4938_IR_SPI	31
+#define TX4938_NUM_IR	32
+/* multiplex */
+#define TX4938_IR_ETH0	TX4938_IR_INT(4)
+#define TX4938_IR_ETH1	TX4938_IR_INT(3)
+
+/*
+ * CCFG
+ */
+/* CCFG : Chip Configuration */
+#define TX4938_CCFG_WDRST	_CONST64(0x0000020000000000)
+#define TX4938_CCFG_WDREXEN	_CONST64(0x0000010000000000)
+#define TX4938_CCFG_BCFG_MASK	_CONST64(0x000000ff00000000)
+#define TX4938_CCFG_TINTDIS	0x01000000
+#define TX4938_CCFG_PCI66	0x00800000
+#define TX4938_CCFG_PCIMODE	0x00400000
+#define TX4938_CCFG_PCI1_66	0x00200000
+#define TX4938_CCFG_DIVMODE_MASK	0x001e0000
+#define TX4938_CCFG_DIVMODE_2	(0x4 << 17)
+#define TX4938_CCFG_DIVMODE_2_5	(0xf << 17)
+#define TX4938_CCFG_DIVMODE_3	(0x5 << 17)
+#define TX4938_CCFG_DIVMODE_4	(0x6 << 17)
+#define TX4938_CCFG_DIVMODE_4_5	(0xd << 17)
+#define TX4938_CCFG_DIVMODE_8	(0x0 << 17)
+#define TX4938_CCFG_DIVMODE_10	(0xb << 17)
+#define TX4938_CCFG_DIVMODE_12	(0x1 << 17)
+#define TX4938_CCFG_DIVMODE_16	(0x2 << 17)
+#define TX4938_CCFG_DIVMODE_18	(0x9 << 17)
+#define TX4938_CCFG_BEOW	0x00010000
+#define TX4938_CCFG_WR	0x00008000
+#define TX4938_CCFG_TOE	0x00004000
+#define TX4938_CCFG_PCIXARB	0x00002000
+#define TX4938_CCFG_PCIDIVMODE_MASK	0x00001c00
+#define TX4938_CCFG_PCIDIVMODE_4	(0x1 << 10)
+#define TX4938_CCFG_PCIDIVMODE_4_5	(0x3 << 10)
+#define TX4938_CCFG_PCIDIVMODE_5	(0x5 << 10)
+#define TX4938_CCFG_PCIDIVMODE_5_5	(0x7 << 10)
+#define TX4938_CCFG_PCIDIVMODE_8	(0x0 << 10)
+#define TX4938_CCFG_PCIDIVMODE_9	(0x2 << 10)
+#define TX4938_CCFG_PCIDIVMODE_10	(0x4 << 10)
+#define TX4938_CCFG_PCIDIVMODE_11	(0x6 << 10)
+#define TX4938_CCFG_PCI1DMD	0x00000100
+#define TX4938_CCFG_SYSSP_MASK	0x000000c0
+#define TX4938_CCFG_ENDIAN	0x00000004
+#define TX4938_CCFG_HALT	0x00000002
+#define TX4938_CCFG_ACEHOLD	0x00000001
+
+/* PCFG : Pin Configuration */
+#define TX4938_PCFG_ETH0_SEL	_CONST64(0x8000000000000000)
+#define TX4938_PCFG_ETH1_SEL	_CONST64(0x4000000000000000)
+#define TX4938_PCFG_ATA_SEL	_CONST64(0x2000000000000000)
+#define TX4938_PCFG_ISA_SEL	_CONST64(0x1000000000000000)
+#define TX4938_PCFG_SPI_SEL	_CONST64(0x0800000000000000)
+#define TX4938_PCFG_NDF_SEL	_CONST64(0x0400000000000000)
+#define TX4938_PCFG_SDCLKDLY_MASK	0x30000000
+#define TX4938_PCFG_SDCLKDLY(d)	((d)<<28)
+#define TX4938_PCFG_SYSCLKEN	0x08000000
+#define TX4938_PCFG_SDCLKEN_ALL	0x07800000
+#define TX4938_PCFG_SDCLKEN(ch)	(0x00800000<<(ch))
+#define TX4938_PCFG_PCICLKEN_ALL	0x003f0000
+#define TX4938_PCFG_PCICLKEN(ch)	(0x00010000<<(ch))
+#define TX4938_PCFG_SEL2	0x00000200
+#define TX4938_PCFG_SEL1	0x00000100
+#define TX4938_PCFG_DMASEL_ALL	0x0000000f
+#define TX4938_PCFG_DMASEL0_DRQ0	0x00000000
+#define TX4938_PCFG_DMASEL0_SIO1	0x00000001
+#define TX4938_PCFG_DMASEL1_DRQ1	0x00000000
+#define TX4938_PCFG_DMASEL1_SIO1	0x00000002
+#define TX4938_PCFG_DMASEL2_DRQ2	0x00000000
+#define TX4938_PCFG_DMASEL2_SIO0	0x00000004
+#define TX4938_PCFG_DMASEL3_DRQ3	0x00000000
+#define TX4938_PCFG_DMASEL3_SIO0	0x00000008
+
+/* CLKCTR : Clock Control */
+#define TX4938_CLKCTR_NDFCKD	_CONST64(0x0001000000000000)
+#define TX4938_CLKCTR_NDFRST	_CONST64(0x0000000100000000)
+#define TX4938_CLKCTR_ETH1CKD	0x80000000
+#define TX4938_CLKCTR_ETH0CKD	0x40000000
+#define TX4938_CLKCTR_SPICKD	0x20000000
+#define TX4938_CLKCTR_SRAMCKD	0x10000000
+#define TX4938_CLKCTR_PCIC1CKD	0x08000000
+#define TX4938_CLKCTR_DMA1CKD	0x04000000
+#define TX4938_CLKCTR_ACLCKD	0x02000000
+#define TX4938_CLKCTR_PIOCKD	0x01000000
+#define TX4938_CLKCTR_DMACKD	0x00800000
+#define TX4938_CLKCTR_PCICKD	0x00400000
+#define TX4938_CLKCTR_TM0CKD	0x00100000
+#define TX4938_CLKCTR_TM1CKD	0x00080000
+#define TX4938_CLKCTR_TM2CKD	0x00040000
+#define TX4938_CLKCTR_SIO0CKD	0x00020000
+#define TX4938_CLKCTR_SIO1CKD	0x00010000
+#define TX4938_CLKCTR_ETH1RST	0x00008000
+#define TX4938_CLKCTR_ETH0RST	0x00004000
+#define TX4938_CLKCTR_SPIRST	0x00002000
+#define TX4938_CLKCTR_SRAMRST	0x00001000
+#define TX4938_CLKCTR_PCIC1RST	0x00000800
+#define TX4938_CLKCTR_DMA1RST	0x00000400
+#define TX4938_CLKCTR_ACLRST	0x00000200
+#define TX4938_CLKCTR_PIORST	0x00000100
+#define TX4938_CLKCTR_DMARST	0x00000080
+#define TX4938_CLKCTR_PCIRST	0x00000040
+#define TX4938_CLKCTR_TM0RST	0x00000010
+#define TX4938_CLKCTR_TM1RST	0x00000008
+#define TX4938_CLKCTR_TM2RST	0x00000004
+#define TX4938_CLKCTR_SIO0RST	0x00000002
+#define TX4938_CLKCTR_SIO1RST	0x00000001
+
+/* bits for G2PSTATUS/G2PMASK */
+#define TX4938_PCIC_G2PSTATUS_ALL	0x00000003
+#define TX4938_PCIC_G2PSTATUS_TTOE	0x00000002
+#define TX4938_PCIC_G2PSTATUS_RTOE	0x00000001
+
+/* bits for PCIMASK (see also PCI_STATUS_XXX in linux/pci.h */
+#define TX4938_PCIC_PCISTATUS_ALL	0x0000f900
+
+/* bits for PBACFG */
+#define TX4938_PCIC_PBACFG_FIXPA	0x00000008
+#define TX4938_PCIC_PBACFG_RPBA	0x00000004
+#define TX4938_PCIC_PBACFG_PBAEN	0x00000002
+#define TX4938_PCIC_PBACFG_BMCEN	0x00000001
+
+/* bits for G2PMnGBASE */
+#define TX4938_PCIC_G2PMnGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_G2PMnGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for G2PIOGBASE */
+#define TX4938_PCIC_G2PIOGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_G2PIOGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for PCICSTATUS/PCICMASK */
+#define TX4938_PCIC_PCICSTATUS_ALL	0x000007b8
+#define TX4938_PCIC_PCICSTATUS_PME	0x00000400
+#define TX4938_PCIC_PCICSTATUS_TLB	0x00000200
+#define TX4938_PCIC_PCICSTATUS_NIB	0x00000100
+#define TX4938_PCIC_PCICSTATUS_ZIB	0x00000080
+#define TX4938_PCIC_PCICSTATUS_PERR	0x00000020
+#define TX4938_PCIC_PCICSTATUS_SERR	0x00000010
+#define TX4938_PCIC_PCICSTATUS_GBE	0x00000008
+#define TX4938_PCIC_PCICSTATUS_IWB	0x00000002
+#define TX4938_PCIC_PCICSTATUS_E2PDONE	0x00000001
+
+/* bits for PCICCFG */
+#define TX4938_PCIC_PCICCFG_GBWC_MASK	0x0fff0000
+#define TX4938_PCIC_PCICCFG_HRST	0x00000800
+#define TX4938_PCIC_PCICCFG_SRST	0x00000400
+#define TX4938_PCIC_PCICCFG_IRBER	0x00000200
+#define TX4938_PCIC_PCICCFG_G2PMEN(ch)	(0x00000100>>(ch))
+#define TX4938_PCIC_PCICCFG_G2PM0EN	0x00000100
+#define TX4938_PCIC_PCICCFG_G2PM1EN	0x00000080
+#define TX4938_PCIC_PCICCFG_G2PM2EN	0x00000040
+#define TX4938_PCIC_PCICCFG_G2PIOEN	0x00000020
+#define TX4938_PCIC_PCICCFG_TCAR	0x00000010
+#define TX4938_PCIC_PCICCFG_ICAEN	0x00000008
+
+/* bits for P2GMnGBASE */
+#define TX4938_PCIC_P2GMnGBASE_TMEMEN	_CONST64(0x0000004000000000)
+#define TX4938_PCIC_P2GMnGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_P2GMnGBASE_TECHG	_CONST64(0x0000001000000000)
+
+/* bits for P2GIOGBASE */
+#define TX4938_PCIC_P2GIOGBASE_TIOEN	_CONST64(0x0000004000000000)
+#define TX4938_PCIC_P2GIOGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_P2GIOGBASE_TECHG	_CONST64(0x0000001000000000)
+
+#define TX4938_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
+#define TX4938_PCIC_MAX_DEVNU	TX4938_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/* bits for PDMCFG */
+#define TX4938_PCIC_PDMCFG_RSTFIFO	0x00200000
+#define TX4938_PCIC_PDMCFG_EXFER	0x00100000
+#define TX4938_PCIC_PDMCFG_REQDLY_MASK	0x00003800
+#define TX4938_PCIC_PDMCFG_REQDLY_NONE	(0 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_16	(1 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_32	(2 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_64	(3 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_128	(4 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_256	(5 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_512	(6 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_1024	(7 << 11)
+#define TX4938_PCIC_PDMCFG_ERRIE	0x00000400
+#define TX4938_PCIC_PDMCFG_NCCMPIE	0x00000200
+#define TX4938_PCIC_PDMCFG_NTCMPIE	0x00000100
+#define TX4938_PCIC_PDMCFG_CHNEN	0x00000080
+#define TX4938_PCIC_PDMCFG_XFRACT	0x00000040
+#define TX4938_PCIC_PDMCFG_BSWAP	0x00000020
+#define TX4938_PCIC_PDMCFG_XFRSIZE_MASK	0x0000000c
+#define TX4938_PCIC_PDMCFG_XFRSIZE_1DW	0x00000000
+#define TX4938_PCIC_PDMCFG_XFRSIZE_1QW	0x00000004
+#define TX4938_PCIC_PDMCFG_XFRSIZE_4QW	0x00000008
+#define TX4938_PCIC_PDMCFG_XFRDIRC	0x00000002
+#define TX4938_PCIC_PDMCFG_CHRST	0x00000001
+
+/* bits for PDMSTS */
+#define TX4938_PCIC_PDMSTS_REQCNT_MASK	0x3f000000
+#define TX4938_PCIC_PDMSTS_FIFOCNT_MASK	0x00f00000
+#define TX4938_PCIC_PDMSTS_FIFOWP_MASK	0x000c0000
+#define TX4938_PCIC_PDMSTS_FIFORP_MASK	0x00030000
+#define TX4938_PCIC_PDMSTS_ERRINT	0x00000800
+#define TX4938_PCIC_PDMSTS_DONEINT	0x00000400
+#define TX4938_PCIC_PDMSTS_CHNEN	0x00000200
+#define TX4938_PCIC_PDMSTS_XFRACT	0x00000100
+#define TX4938_PCIC_PDMSTS_ACCMP	0x00000080
+#define TX4938_PCIC_PDMSTS_NCCMP	0x00000040
+#define TX4938_PCIC_PDMSTS_NTCMP	0x00000020
+#define TX4938_PCIC_PDMSTS_CFGERR	0x00000008
+#define TX4938_PCIC_PDMSTS_PCIERR	0x00000004
+#define TX4938_PCIC_PDMSTS_CHNERR	0x00000002
+#define TX4938_PCIC_PDMSTS_DATAERR	0x00000001
+#define TX4938_PCIC_PDMSTS_ALL_CMP	0x000000e0
+#define TX4938_PCIC_PDMSTS_ALL_ERR	0x0000000f
+
+/*
+ * DMA
+ */
+/* bits for MCR */
+#define TX4938_DMA_MCR_EIS(ch)	(0x10000000<<(ch))
+#define TX4938_DMA_MCR_DIS(ch)	(0x01000000<<(ch))
+#define TX4938_DMA_MCR_RSFIF	0x00000080
+#define TX4938_DMA_MCR_FIFUM(ch)	(0x00000008<<(ch))
+#define TX4938_DMA_MCR_RPRT	0x00000002
+#define TX4938_DMA_MCR_MSTEN	0x00000001
+
+/* bits for CCRn */
+#define TX4938_DMA_CCR_IMMCHN	0x20000000
+#define TX4938_DMA_CCR_USEXFSZ	0x10000000
+#define TX4938_DMA_CCR_LE	0x08000000
+#define TX4938_DMA_CCR_DBINH	0x04000000
+#define TX4938_DMA_CCR_SBINH	0x02000000
+#define TX4938_DMA_CCR_CHRST	0x01000000
+#define TX4938_DMA_CCR_RVBYTE	0x00800000
+#define TX4938_DMA_CCR_ACKPOL	0x00400000
+#define TX4938_DMA_CCR_REQPL	0x00200000
+#define TX4938_DMA_CCR_EGREQ	0x00100000
+#define TX4938_DMA_CCR_CHDN	0x00080000
+#define TX4938_DMA_CCR_DNCTL	0x00060000
+#define TX4938_DMA_CCR_EXTRQ	0x00010000
+#define TX4938_DMA_CCR_INTRQD	0x0000e000
+#define TX4938_DMA_CCR_INTENE	0x00001000
+#define TX4938_DMA_CCR_INTENC	0x00000800
+#define TX4938_DMA_CCR_INTENT	0x00000400
+#define TX4938_DMA_CCR_CHNEN	0x00000200
+#define TX4938_DMA_CCR_XFACT	0x00000100
+#define TX4938_DMA_CCR_SMPCHN	0x00000020
+#define TX4938_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TX4938_DMA_CCR_XFSZ_1W	TX4938_DMA_CCR_XFSZ(2)
+#define TX4938_DMA_CCR_XFSZ_2W	TX4938_DMA_CCR_XFSZ(3)
+#define TX4938_DMA_CCR_XFSZ_4W	TX4938_DMA_CCR_XFSZ(4)
+#define TX4938_DMA_CCR_XFSZ_8W	TX4938_DMA_CCR_XFSZ(5)
+#define TX4938_DMA_CCR_XFSZ_16W	TX4938_DMA_CCR_XFSZ(6)
+#define TX4938_DMA_CCR_XFSZ_32W	TX4938_DMA_CCR_XFSZ(7)
+#define TX4938_DMA_CCR_MEMIO	0x00000002
+#define TX4938_DMA_CCR_SNGAD	0x00000001
+
+/* bits for CSRn */
+#define TX4938_DMA_CSR_CHNEN	0x00000400
+#define TX4938_DMA_CSR_STLXFER	0x00000200
+#define TX4938_DMA_CSR_CHNACT	0x00000100
+#define TX4938_DMA_CSR_ABCHC	0x00000080
+#define TX4938_DMA_CSR_NCHNC	0x00000040
+#define TX4938_DMA_CSR_NTRNFC	0x00000020
+#define TX4938_DMA_CSR_EXTDN	0x00000010
+#define TX4938_DMA_CSR_CFERR	0x00000008
+#define TX4938_DMA_CSR_CHERR	0x00000004
+#define TX4938_DMA_CSR_DESERR	0x00000002
+#define TX4938_DMA_CSR_SORERR	0x00000001
+
+/* TX4938 Interrupt Controller (32-bit registers) */
+#define TX4938_IRC_BASE                 0xf510
+#define TX4938_IRC_IRFLAG0              0xf510
+#define TX4938_IRC_IRFLAG1              0xf514
+#define TX4938_IRC_IRPOL                0xf518
+#define TX4938_IRC_IRRCNT               0xf51c
+#define TX4938_IRC_IRMASKINT            0xf520
+#define TX4938_IRC_IRMASKEXT            0xf524
+#define TX4938_IRC_IRDEN                0xf600
+#define TX4938_IRC_IRDM0                0xf604
+#define TX4938_IRC_IRDM1                0xf608
+#define TX4938_IRC_IRLVL0               0xf610
+#define TX4938_IRC_IRLVL1               0xf614
+#define TX4938_IRC_IRLVL2               0xf618
+#define TX4938_IRC_IRLVL3               0xf61c
+#define TX4938_IRC_IRLVL4               0xf620
+#define TX4938_IRC_IRLVL5               0xf624
+#define TX4938_IRC_IRLVL6               0xf628
+#define TX4938_IRC_IRLVL7               0xf62c
+#define TX4938_IRC_IRMSK                0xf640
+#define TX4938_IRC_IREDC                0xf660
+#define TX4938_IRC_IRPND                0xf680
+#define TX4938_IRC_IRCS                 0xf6a0
+#define TX4938_IRC_LIMIT                0xf6ff
+
+#ifndef __ASSEMBLY__
+
+#define tx4938_sdramcptr	((struct tx4938_sdramc_reg *)TX4938_SDRAMC_REG)
+#define tx4938_ebuscptr         ((struct tx4938_ebusc_reg *)TX4938_EBUSC_REG)
+#define tx4938_dmaptr(ch)	((struct tx4938_dma_reg *)TX4938_DMA_REG(ch))
+#define tx4938_ndfmcptr		((struct tx4938_ndfmc_reg *)TX4938_NDFMC_REG)
+#define tx4938_ircptr		((struct tx4938_irc_reg *)TX4938_IRC_REG)
+#define tx4938_pcicptr		((struct tx4938_pcic_reg *)TX4938_PCIC_REG)
+#define tx4938_pcic1ptr		((struct tx4938_pcic_reg *)TX4938_PCIC1_REG)
+#define tx4938_ccfgptr		((struct tx4938_ccfg_reg *)TX4938_CCFG_REG)
+#define tx4938_tmrptr(ch)	((struct tx4938_tmr_reg *)TX4938_TMR_REG(ch))
+#define tx4938_sioptr(ch)	((struct tx4938_sio_reg *)TX4938_SIO_REG(ch))
+#define tx4938_pioptr		((struct tx4938_pio_reg *)TX4938_PIO_REG)
+#define tx4938_aclcptr		((struct tx4938_aclc_reg *)TX4938_ACLC_REG)
+#define tx4938_spiptr		((struct tx4938_spi_reg *)TX4938_SPI_REG)
+#define tx4938_sramcptr		((struct tx4938_sramc_reg *)TX4938_SRAMC_REG)
+
+#define TX4938_REV_MAJ_MIN()	((unsigned long)tx4938_ccfgptr->crir & 0x00ff)
+#define TX4938_REV_PCODE()	((unsigned long)tx4938_ccfgptr->crir >> 16)
+
+#define TX4938_SDRAMC_BA(ch)	((tx4938_sdramcptr->cr[ch] >> 49) << 21)
+#define TX4938_SDRAMC_SIZE(ch)	(((tx4938_sdramcptr->cr[ch] >> 33) + 1) << 21)
+
+#define TX4938_EBUSC_BA(ch)	((tx4938_ebuscptr->cr[ch] >> 48) << 20)
+#define TX4938_EBUSC_SIZE(ch)	\
+	(0x00100000 << ((unsigned long)(tx4938_ebuscptr->cr[ch] >> 8) & 0xf))
+
+#endif				/* !__ASSEMBLY__ */
+
+#endif
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/setup.c
@@ -0,0 +1,1136 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/setup.c
+ *
+ * Setup pointers to hardware-dependent routines.
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/pci.h>
+#include <asm/wbflush.h>
+#include <asm/reboot.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/rbtx4938.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
+
+extern char *prom_getcmdline(void);
+extern void rbtx4938_time_init(void) __init;
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr);
+
+/* These functions are used for rebooting or halting the machine*/
+extern void rbtx4938_machine_restart(char *command);
+extern void rbtx4938_machine_halt(void);
+extern void rbtx4938_machine_power_off(void);
+
+/* clocks */
+unsigned int txx9_master_clock;
+unsigned int txx9_cpu_clock;
+unsigned int txx9_gbus_clock;
+
+unsigned long rbtx4938_ce_base[8];
+unsigned long rbtx4938_ce_size[8];
+int txboard_pci66_mode;
+static int tx4938_ccfg_toeon = 1;
+static int tx4938_pcic_trdyto;	/* default: disabled */
+static int tx4938_pcic_retryto;	/* default: disabled */
+
+struct tx4938_pcic_reg *pcicptrs[4] = {
+	tx4938_pcicptr		/* default setting for TX4938 */
+};
+
+static struct {
+	unsigned long base;
+	unsigned long size;
+} phys_regions[16] __initdata;
+static int num_phys_regions __initdata;
+
+#define PHYS_REGION_MINSIZE	0x10000
+
+void rbtx4938_machine_halt(void)
+{
+	printk(KERN_NOTICE "System Halted\n");
+	local_irq_disable();
+
+	while (1)
+		__asm__(".set\tmips3\n\t" "wait\n\t" ".set\tmips0");
+}
+
+void rbtx4938_machine_power_off(void)
+{
+	rbtx4938_machine_halt();
+	/* no return */
+}
+
+void rbtx4938_machine_restart(char *command)
+{
+	local_irq_disable();
+
+	printk("Rebooting...");
+	TX4938_WR08(RBTX4938_SOFTRESETLOCK_ADDR, 1);
+	TX4938_WR08(RBTX4938_SFVOL_ADDR, 1);
+	TX4938_WR08(RBTX4938_SOFTRESET_ADDR, 1);
+	wbflush();
+
+	while (1) ;
+}
+
+void __init txboard_add_phys_region(unsigned long base, unsigned long size)
+{
+	if (num_phys_regions >= ARRAY_SIZE(phys_regions)) {
+		printk("phys_region overflow\n");
+		return;
+	}
+	phys_regions[num_phys_regions].base = base;
+	phys_regions[num_phys_regions].size = size;
+	num_phys_regions++;
+}
+unsigned long __init
+txboard_find_free_phys_region(unsigned long begin, unsigned long end,
+			      unsigned long size)
+{
+	unsigned long base;
+	int i;
+
+	for (base = begin / size * size; base < end; base += size) {
+		for (i = 0; i < num_phys_regions; i++) {
+			if (phys_regions[i].size &&
+			    base <=
+			    phys_regions[i].base + (phys_regions[i].size - 1)
+			    && base + (size - 1) >= phys_regions[i].base)
+				break;
+		}
+		if (i == num_phys_regions)
+			return base;
+	}
+	return 0;
+}
+unsigned long __init
+txboard_find_free_phys_region_shrink(unsigned long begin, unsigned long end,
+				     unsigned long *size)
+{
+	unsigned long sz, base;
+	for (sz = *size; sz >= PHYS_REGION_MINSIZE; sz /= 2) {
+		base = txboard_find_free_phys_region(begin, end, sz);
+		if (base) {
+			*size = sz;
+			return base;
+		}
+	}
+	return 0;
+}
+unsigned long __init
+txboard_request_phys_region_range(unsigned long begin, unsigned long end,
+				  unsigned long size)
+{
+	unsigned long base;
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init txboard_request_phys_region(unsigned long size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init txboard_request_phys_region_shrink(unsigned long *size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region_shrink(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, *size);
+	return base;
+}
+
+#ifdef CONFIG_PCI
+void __init
+tx4938_pcic_setup(struct tx4938_pcic_reg *pcicptr,
+		  struct pci_controller *channel,
+		  unsigned long pci_io_base, int extarb)
+{
+	int i;
+	int v;
+
+	/* Disable All Initiator Space */
+	v = TX4938_RD(&pcicptr->pciccfg);
+	TX4938_WR(&pcicptr->pciccfg, v & ~(TX4938_PCIC_PCICCFG_G2PMEN(0) |
+					   TX4938_PCIC_PCICCFG_G2PMEN(1) |
+					   TX4938_PCIC_PCICCFG_G2PMEN(2) |
+					   TX4938_PCIC_PCICCFG_G2PIOEN));
+
+	/* GB->PCI mappings */
+	TX4938_WR(&pcicptr->g2piomask,
+		  (channel->io_resource->end -
+		   channel->io_resource->start) >> 4);
+	TX4938_WR64(&pcicptr->g2piogbase, pci_io_base |
+#ifdef __BIG_ENDIAN
+		    TX4938_PCIC_G2PIOGBASE_ECHG
+#else
+		    TX4938_PCIC_G2PIOGBASE_BSDIS
+#endif
+	    );
+
+	TX4938_WR64(&pcicptr->g2piopbase, 0);
+	for (i = 0; i < 3; i++) {
+		TX4938_WR(&pcicptr->g2pmmask[i], 0);
+		TX4938_WR64(&pcicptr->g2pmgbase[i], 0);
+		TX4938_WR64(&pcicptr->g2pmpbase[i], 0);
+	}
+
+	if (channel->mem_resource->end) {
+		TX4938_WR(&pcicptr->g2pmmask[0],
+			  (channel->mem_resource->end -
+			   channel->mem_resource->start) >> 4);
+		TX4938_WR64(&pcicptr->g2pmgbase[0],
+			    channel->mem_resource->start |
+#ifdef __BIG_ENDIAN
+			    TX4938_PCIC_G2PMnGBASE_ECHG
+#else
+			    TX4938_PCIC_G2PMnGBASE_BSDIS
+#endif
+		    );
+		TX4938_WR64(&pcicptr->g2pmpbase[0],
+			    channel->mem_resource->start);
+	}
+	printk("%s(): %d\n", __FUNCTION__, __LINE__);
+	/* PCI->GB mappings (I/O 256B) */
+	TX4938_WR(&pcicptr->p2giopbase, 0);	/* 256B */
+	TX4938_WR64(&pcicptr->p2giogbase, 0);
+	/* PCI->GB mappings (MEM 512MB (64MB on R1.x)) */
+	TX4938_WR(&pcicptr->p2gm0plbase, 0);
+	TX4938_WR(&pcicptr->p2gm0pubase, 0);
+	TX4938_WR64(&pcicptr->p2gmgbase[0], TX4938_PCIC_P2GMnGBASE_TMEMEN |
+#ifdef __BIG_ENDIAN
+		    TX4938_PCIC_P2GMnGBASE_TECHG
+#else
+		    TX4938_PCIC_P2GMnGBASE_TBSDIS
+#endif
+	    );
+
+	/* PCI->GB mappings (MEM 16MB) */
+	TX4938_WR(&pcicptr->p2gm1plbase, 0xffffffff);
+	TX4938_WR(&pcicptr->p2gm1pubase, 0xffffffff);
+	TX4938_WR64(&pcicptr->p2gmgbase[1], 0);
+	/* PCI->GB mappings (MEM 1MB) */
+	TX4938_WR(&pcicptr->p2gm2pbase, 0xffffffff);	/* 1MB */
+	TX4938_WR64(&pcicptr->p2gmgbase[2], 0);
+
+	v = TX4938_RD(&pcicptr->pciccfg);
+	TX4938_WR(&pcicptr->pciccfg, v & TX4938_PCIC_PCICCFG_GBWC_MASK);
+	/* Enable Initiator Memory Space */
+	if (channel->mem_resource->end) {
+		v = TX4938_RD(&pcicptr->pciccfg);
+		TX4938_WR(&pcicptr->pciccfg, v | TX4938_PCIC_PCICCFG_G2PMEN(0));
+	}
+	/* Enable Initiator I/O Space */
+	if (channel->io_resource->end) {
+		v = TX4938_RD(&pcicptr->pciccfg);
+		TX4938_WR(&pcicptr->pciccfg, v | TX4938_PCIC_PCICCFG_G2PIOEN);
+	}
+	/* Enable Initiator Config */
+	v = TX4938_RD(&pcicptr->pciccfg);
+	TX4938_WR(&pcicptr->pciccfg,
+		  v | TX4938_PCIC_PCICCFG_ICAEN | TX4938_PCIC_PCICCFG_TCAR);
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	TX4938_WR(&pcicptr->pcicfg1, 0);
+
+	v = TX4938_RD(&pcicptr->g2ptocnt);
+	TX4938_WR(&pcicptr->g2ptocnt, v & ~0xffff);
+
+	if (tx4938_pcic_trdyto >= 0) {
+		v = TX4938_RD(&pcicptr->g2ptocnt);
+		TX4938_WR(&pcicptr->g2ptocnt, v & ~0xff);
+		TX4938_WR(&pcicptr->g2ptocnt, (tx4938_pcic_trdyto & 0xff));
+	}
+
+	if (tx4938_pcic_retryto >= 0) {
+		v = TX4938_RD(&pcicptr->g2ptocnt);
+		TX4938_WR(&pcicptr->g2ptocnt, v & ~0xff00);
+		TX4938_WR(&pcicptr->g2ptocnt,
+			  v | ((tx4938_pcic_retryto << 8) & 0xff00));
+	}
+
+	/* Clear All Local Bus Status */
+	TX4938_WR(&pcicptr->pcicstatus, TX4938_PCIC_PCICSTATUS_ALL);
+	/* Enable All Local Bus Interrupts */
+	TX4938_WR(&pcicptr->pcicmask, TX4938_PCIC_PCICSTATUS_ALL);
+
+	/* Clear All Initiator Status */
+	TX4938_WR(&pcicptr->g2pstatus, TX4938_PCIC_G2PSTATUS_ALL);
+
+	/* Enable All Initiator Interrupts */
+	TX4938_WR(&pcicptr->g2pmask, TX4938_PCIC_G2PSTATUS_ALL);
+	/* Clear All PCI Status Error */
+
+	v = TX4938_RD(&pcicptr->pcistatus) & 0x0000ffff;
+	TX4938_WR(&pcicptr->pcistatus, v | (TX4938_PCIC_PCISTATUS_ALL << 16));
+
+	/* Enable All PCI Status Error Interrupts */
+	TX4938_WR(&pcicptr->pcimask, TX4938_PCIC_PCISTATUS_ALL);
+
+	if (!extarb) {
+		/* Reset Bus Arbiter */
+		TX4938_WR(&pcicptr->pbacfg, TX4938_PCIC_PBACFG_RPBA);
+		TX4938_WR(&pcicptr->pbabm, 0);
+		/* Enable Bus Arbiter */
+		TX4938_WR(&pcicptr->pbacfg, TX4938_PCIC_PBACFG_PBAEN);
+	}
+
+	/* PCIC Int => IRC IRQ16 */
+	v = TX4938_RD(&pcicptr->pcicfg2) & 0xffffff00;
+	TX4938_WR(&pcicptr->pcicfg2, v | TX4938_IR_PCIC);
+
+	TX4938_WR(&pcicptr->pcistatus, PCI_COMMAND_MASTER |
+		  PCI_COMMAND_MEMORY | PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+}
+
+int __init tx4938_report_pciclk(void)
+{
+	unsigned long pcode = TX4938_REV_PCODE();
+	int pciclk = 0;
+	printk("TX%lx PCIC --%s PCICLK:",
+	       pcode,
+	       (TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI66) ?
+	       " PCI66" : "");
+	if (TX4938_RD64(&tx4938_ccfgptr->pcfg) & TX4938_PCFG_PCICLKEN_ALL) {
+
+		switch ((unsigned long)TX4938_RD64(&tx4938_ccfgptr->ccfg) &
+			TX4938_CCFG_PCIDIVMODE_MASK) {
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pciclk = txx9_cpu_clock / 4;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pciclk = txx9_cpu_clock * 2 / 9;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pciclk = txx9_cpu_clock / 5;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+			pciclk = txx9_cpu_clock * 2 / 11;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_8:
+			pciclk = txx9_cpu_clock / 8;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+			pciclk = txx9_cpu_clock / 9;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+			pciclk = txx9_cpu_clock / 10;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+			pciclk = txx9_cpu_clock / 11;
+			break;
+		}
+		printk("Internal(%dMHz)", pciclk / 1000000);
+	} else {
+		printk("External");
+		pciclk = -1;
+	}
+	printk("\n");
+	return pciclk;
+}
+
+void __init set_tx4938_pcicptr(int ch, struct tx4938_pcic_reg *pcicptr)
+{
+	pcicptrs[ch] = pcicptr;
+}
+
+struct tx4938_pcic_reg *get_tx4938_pcicptr(int ch)
+{
+	return pcicptrs[ch];
+}
+
+static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
+				    int top_bus, int busnr, int devfn)
+{
+	static struct pci_dev dev;
+	static struct pci_bus bus;
+
+	dev.sysdata = (void *)hose;
+	dev.devfn = devfn;
+	bus.number = busnr;
+	bus.ops = hose->pci_ops;
+	bus.parent = NULL;
+	dev.bus = &bus;
+
+	return &dev;
+}
+
+#define EARLY_PCI_OP(rw, size, type)                                    \
+static int early_##rw##_config_##size(struct pci_controller *hose,      \
+        int top_bus, int bus, int devfn, int offset, type value)        \
+{                                                                       \
+        return pci_##rw##_config_##size(                                \
+                fake_pci_dev(hose, top_bus, bus, devfn),                \
+                offset, value);                                         \
+}
+
+EARLY_PCI_OP(read, word, u16 *)
+
+int txboard_pci66_check(struct pci_controller *hose, int top_bus,
+			int current_bus)
+{
+	u32 pci_devfn;
+	unsigned short vid;
+	int devfn_start = 0;
+	int devfn_stop = 0xff;
+	int cap66 = -1;
+	u16 stat;
+
+	printk("PCI: Checking 66MHz capabilities...\n");
+
+	for (pci_devfn = devfn_start; pci_devfn < devfn_stop; pci_devfn++) {
+		early_read_config_word(hose, top_bus, current_bus, pci_devfn,
+				       PCI_VENDOR_ID, &vid);
+
+		if (vid == 0xffff)
+			continue;
+
+		/* check 66MHz capability */
+		if (cap66 < 0)
+			cap66 = 1;
+		if (cap66) {
+			early_read_config_word(hose, top_bus, current_bus,
+					       pci_devfn, PCI_STATUS, &stat);
+			if (!(stat & PCI_STATUS_66MHZ)) {
+				printk(KERN_DEBUG
+				       "PCI: %02x:%02x not 66MHz capable.\n",
+				       current_bus, pci_devfn);
+				cap66 = 0;
+				break;
+			}
+		}
+	}
+	return cap66 > 0;
+}
+
+int __init tx4938_pciclk66_setup(void)
+{
+	int pciclk;
+	unsigned long long v;
+	/* Assert M66EN */
+	v = TX4938_RD64(&tx4938_ccfgptr->ccfg);
+	TX4938_WR64(&tx4938_ccfgptr->ccfg, v | TX4938_CCFG_PCI66);
+	/* Double PCICLK (if possible) */
+	if (TX4938_RD64(&tx4938_ccfgptr->pcfg) & TX4938_PCFG_PCICLKEN_ALL) {
+		unsigned int pcidivmode = TX4938_RD64(&tx4938_ccfgptr->ccfg) 
+			& TX4938_CCFG_PCIDIVMODE_MASK;
+		switch (pcidivmode) {
+		case TX4938_CCFG_PCIDIVMODE_8:
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4;
+			pciclk = txx9_cpu_clock / 4;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4_5;
+			pciclk = txx9_cpu_clock * 2 / 9;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5;
+			pciclk = txx9_cpu_clock / 5;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+		default:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5_5;
+			pciclk = txx9_cpu_clock * 2 / 11;
+			break;
+		}
+		v = TX4938_RD64(&tx4938_ccfgptr->ccfg);
+		TX4938_WR64(&tx4938_ccfgptr->ccfg,
+			    (v & ~TX4938_CCFG_PCIDIVMODE_MASK)
+			    | pcidivmode);
+		printk(KERN_DEBUG "PCICLK: ccfg:%08lx\n",
+		       (unsigned long)TX4938_RD64(&tx4938_ccfgptr->ccfg));
+	} else {
+		pciclk = -1;
+	}
+	return pciclk;
+}
+
+extern struct pci_controller tx4938_pci_controller[];
+static int __init tx4938_pcibios_init(void)
+{
+	unsigned long long v;
+	unsigned long mem_base[2];
+	unsigned long mem_size[2] = { TX4938_PCIMEM_SIZE_0, TX4938_PCIMEM_SIZE_1 };	/* MAX 128M,64K */
+	unsigned long io_base[2];
+	unsigned long io_size[2] = { TX4938_PCIIO_SIZE_0, TX4938_PCIIO_SIZE_1 };	/* MAX 16M,64K */
+	/* TX4938 PCIC1: 64K MEM/IO is enough for ETH0,ETH1 */
+	int extarb =
+	    !(TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIXARB);
+
+	PCIBIOS_MIN_IO = 0x00001000UL;
+	PCIBIOS_MIN_MEM = 0x01000000UL;
+
+	mem_base[0] = txboard_request_phys_region_shrink(&mem_size[0]);
+	io_base[0] = txboard_request_phys_region_shrink(&io_size[0]);
+
+	printk("TX4938 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+	       (unsigned short)(TX4938_RD(&tx4938_pcicptr->pciid) >> 16),
+	       (unsigned short)(TX4938_RD(&tx4938_pcicptr->pciid) & 0xffff),
+	       (unsigned short)(TX4938_RD(&tx4938_pcicptr->pciccrev) & 0xff),
+	       extarb ? "External" : "Internal");
+
+	/* setup PCI area */
+	tx4938_pci_controller[0].io_resource->start = io_base[0];
+	tx4938_pci_controller[0].io_resource->end =
+	    (io_base[0] + io_size[0]) - 1;
+	tx4938_pci_controller[0].mem_resource->start = mem_base[0];
+	tx4938_pci_controller[0].mem_resource->end =
+	    mem_base[0] + mem_size[0] - 1;
+
+	set_tx4938_pcicptr(0, tx4938_pcicptr);
+
+	register_pci_controller(&tx4938_pci_controller[0]);
+
+	if (TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI66) {
+		printk("TX4938_CCFG_PCI66 already configured\n");
+		txboard_pci66_mode = -1;	/* already configured */
+	}
+
+	/* Reset PCI Bus */
+	TX4938_WR08(rbtx4938_pcireset_ptr, 0);
+	/* Reset PCIC */
+	v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+	TX4938_WR64(&tx4938_ccfgptr->clkctr, v | TX4938_CLKCTR_PCIRST);
+	if (txboard_pci66_mode > 0)
+		tx4938_pciclk66_setup();
+	mdelay(10);
+	/* clear PCIC reset */
+	v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+	TX4938_WR64(&tx4938_ccfgptr->clkctr, v & ~TX4938_CLKCTR_PCIRST);
+	TX4938_WR08(rbtx4938_pcireset_ptr, 1);
+	wbflush();
+	tx4938_report_pcic_status1(tx4938_pcicptr);
+
+	tx4938_report_pciclk();
+	tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0],
+			  extarb);
+	if (txboard_pci66_mode == 0
+	    && txboard_pci66_check(&tx4938_pci_controller[0], 0, 0)) {
+		/* Reset PCI Bus */
+		TX4938_WR08(rbtx4938_pcireset_ptr, 0);
+		/* Reset PCIC */
+		v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+		TX4938_WR64(&tx4938_ccfgptr->clkctr, v | TX4938_CLKCTR_PCIRST);
+		tx4938_pciclk66_setup();
+		mdelay(10);
+		/* clear PCIC reset */
+		v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+		TX4938_WR64(&tx4938_ccfgptr->clkctr, v & ~TX4938_CLKCTR_PCIRST);
+		TX4938_WR08(rbtx4938_pcireset_ptr, 1);
+		wbflush();
+		/* Reinitialize PCIC */
+		tx4938_report_pciclk();
+		tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0],
+				  io_base[0], extarb);
+	}
+
+	mem_base[1] = txboard_request_phys_region_shrink(&mem_size[1]);
+	io_base[1] = txboard_request_phys_region_shrink(&io_size[1]);
+	/* Reset PCIC1 */
+	v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+	TX4938_WR64(&tx4938_ccfgptr->clkctr, v |= TX4938_CLKCTR_PCIC1RST);
+	/* PCI1DMD==0 => PCI1CLK==GBUSCLK/2 => PCI66 */
+	if (!(TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI1DMD)) {
+		v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+		TX4938_WR64(&tx4938_ccfgptr->ccfg, v | TX4938_CCFG_PCI1_66);
+	} else {
+		v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+		TX4938_WR64(&tx4938_ccfgptr->ccfg, v & ~TX4938_CCFG_PCI1_66);
+	}
+	mdelay(10);
+	/* clear PCIC1 reset */
+	v = TX4938_RD64(&tx4938_ccfgptr->clkctr);
+	TX4938_WR64(&tx4938_ccfgptr->clkctr, v & ~TX4938_CLKCTR_PCIC1RST);
+	tx4938_report_pcic_status1(tx4938_pcic1ptr);
+
+	printk("TX4938 PCIC1 -- DID:%04x VID:%04x RID:%02x",
+	       (unsigned short)(TX4938_RD(&tx4938_pcic1ptr->pciid) >> 16),
+	       (unsigned short)(TX4938_RD(&tx4938_pcic1ptr->pciid) & 0xffff),
+	       (unsigned short)(TX4938_RD(&tx4938_pcic1ptr->pciccrev) & 0xff));
+	printk("%s PCICLK:%dMHz\n",
+	       (TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI1_66) ?
+	       " PCI66" : "",
+	       txx9_gbus_clock /
+	       ((TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI1DMD) ? 4 :
+		2) / 1000000);
+
+	/* assumption: CPHYSADDR(mips_io_port_base) == io_base[0] */
+	tx4938_pci_controller[1].io_resource->start = io_base[1] - io_base[0];
+	tx4938_pci_controller[1].io_resource->end =
+	    io_base[1] - io_base[0] + io_size[1] - 1;
+	tx4938_pci_controller[1].mem_resource->start = mem_base[1];
+	tx4938_pci_controller[1].mem_resource->end =
+	    mem_base[1] + mem_size[1] - 1;
+	set_tx4938_pcicptr(1, tx4938_pcic1ptr);
+
+	register_pci_controller(&tx4938_pci_controller[1]);
+
+	tx4938_pcic_setup(tx4938_pcic1ptr, &tx4938_pci_controller[1],
+			  io_base[1], extarb);
+
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1 + io_base[0]);
+
+	return 0;
+}
+
+arch_initcall(tx4938_pcibios_init);
+
+#endif				/* CONFIG_PCI */
+
+/* SPI support */
+
+/* chip select for SPI devices */
+#define	SEEPROM1_CS	7	/* PIO7 */
+#define	SEEPROM2_CS	0	/* IOC */
+#define	SEEPROM3_CS	1	/* IOC */
+#define	SRTC_CS	2		/* IOC */
+
+static int rbtx4938_spi_cs_func(int chipid, int on)
+{
+	unsigned long v;
+	unsigned char bit;
+	unsigned char c;
+
+	switch (chipid) {
+	case RBTX4938_SEEPROM1_CHIPID:
+		v = TX4938_RD(&tx4938_pioptr->dout);
+		if (on)
+			TX4938_WR(&tx4938_pioptr->dout,
+				  v & ~(1 << SEEPROM1_CS));
+		else
+			TX4938_WR(&tx4938_pioptr->dout, v | (1 << SEEPROM1_CS));
+		return 0;
+		break;
+	case RBTX4938_SEEPROM2_CHIPID:
+		bit = (1 << SEEPROM2_CS);
+		break;
+	case RBTX4938_SEEPROM3_CHIPID:
+		bit = (1 << SEEPROM3_CS);
+		break;
+	case RBTX4938_SRTC_CHIPID:
+		bit = (1 << SRTC_CS);
+		break;
+	default:
+		return -ENODEV;
+	}
+	/* bit1,2,4 are low active, bit3 is high active */
+	c = TX4938_RD08(rbtx4938_spics_ptr);
+
+	TX4938_WR08(rbtx4938_spics_ptr, (c & ~bit) |
+		    ((on ? (bit ^ 0x0b) : ~(bit ^ 0x0b)) & bit));
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+extern int spi_eeprom_read(int chipid, int address, unsigned char *buf,
+			   int len);
+
+int rbtx4938_get_tx4938_ethaddr(struct pci_dev *dev, unsigned char *addr)
+{
+	struct pci_controller *channel =
+	    (struct pci_controller *)dev->bus->sysdata;
+	static unsigned char dat[17];
+	static int read_dat = 0;
+	int ch = 0;
+
+	if (channel != &tx4938_pci_controller[1])
+		return -ENODEV;
+	/* TX4938 PCIC1 */
+	switch (PCI_SLOT(dev->devfn)) {
+	case TX4938_PCIC_IDSEL_AD_TO_SLOT(31):
+		ch = 0;
+		break;
+	case TX4938_PCIC_IDSEL_AD_TO_SLOT(30):
+		ch = 1;
+		break;
+	default:
+		return -ENODEV;
+	}
+	if (!read_dat) {
+		unsigned char sum;
+		int i;
+		read_dat = 1;
+		/* 0-3: "MAC\0", 4-9:eth0, 10-15:eth1, 16:sum */
+		if (spi_eeprom_read(RBTX4938_SEEPROM1_CHIPID,
+				    0, dat, sizeof(dat))) {
+			printk(KERN_ERR "seeprom: read error.\n");
+		} else {
+			if (strcmp(dat, "MAC") != 0)
+				printk(KERN_WARNING
+				       "seeprom: bad signature.\n");
+			for (i = 0, sum = 0; i < sizeof(dat); i++)
+				sum += dat[i];
+			if (sum)
+				printk(KERN_WARNING "seeprom: bad checksum.\n");
+		}
+	}
+	memcpy(addr, &dat[4 + 6 * ch], 6);
+	return 0;
+}
+#endif				/* CONFIG_PCI */
+
+extern void __init txx9_spi_init(unsigned long base,
+				 int (*cs_func) (int chipid, int on));
+static void __init rbtx4938_spi_setup(void)
+{
+	unsigned long long l;
+	unsigned long v;
+
+	/* set SPI_SEL */
+	l = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, l | TX4938_PCFG_SPI_SEL);
+
+	/* chip selects for SPI devices */
+	v = TX4938_RD(&tx4938_pioptr->dout);
+	TX4938_WR(&tx4938_pioptr->dout, v | (1 << SEEPROM1_CS));
+
+	v = TX4938_RD(&tx4938_pioptr->dir);
+	TX4938_WR(&tx4938_pioptr->dir, v | (1 << SEEPROM1_CS));
+
+	txx9_spi_init(TX4938_SPI_REG, rbtx4938_spi_cs_func);
+}
+
+static struct resource rbtx4938_fpga_resource;
+
+static char pcode_str[8];
+static struct resource tx4938_reg_resource = {
+	pcode_str, TX4938_REG_BASE, TX4938_REG_BASE + TX4938_REG_SIZE,
+	IORESOURCE_MEM
+};
+
+void __init tx4938_board_setup(void)
+{
+	int i;
+	unsigned long divmode;
+	int cpuclk = 0;
+	unsigned long pcode = TX4938_REV_PCODE();
+	unsigned long long v;
+
+	ioport_resource.start = 0x1000;
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.start = 0x1000;
+	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
+
+	sprintf(pcode_str, "TX%lx", pcode);
+	/* SDRAMC,EBUSC are configured by PROM */
+	for (i = 0; i < 8; i++) {
+		if (!(TX4938_RD64(&tx4938_ebuscptr->cr[i]) & 0x8))
+			continue;	/* disabled */
+		rbtx4938_ce_base[i] = (unsigned long)TX4938_EBUSC_BA(i);
+		txboard_add_phys_region(rbtx4938_ce_base[i],
+					TX4938_EBUSC_SIZE(i));
+	}
+
+	/* clocks */
+	if (txx9_master_clock) {
+		/* calculate gbus_clock and cpu_clock from master_clock */
+		divmode =
+		    (unsigned long)TX4938_RD64(&tx4938_ccfgptr->
+					       ccfg) & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = txx9_master_clock * 4;
+			break;
+		default:
+			txx9_gbus_clock = txx9_master_clock;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			cpuclk = txx9_gbus_clock * 2;
+			break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			cpuclk = txx9_gbus_clock * 5 / 2;
+			break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			cpuclk = txx9_gbus_clock * 3;
+			break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			cpuclk = txx9_gbus_clock * 4;
+			break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			cpuclk = txx9_gbus_clock * 9 / 2;
+			break;
+		}
+		txx9_cpu_clock = cpuclk;
+	} else {
+		if (txx9_cpu_clock == 0) {
+			txx9_cpu_clock = 300000000;	/* 300MHz */
+		}
+		/* calculate gbus_clock and master_clock from cpu_clock */
+		cpuclk = txx9_cpu_clock;
+		divmode =
+		    (unsigned long)TX4938_RD64(&tx4938_ccfgptr->
+					       ccfg) & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			txx9_gbus_clock = cpuclk / 2;
+			break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			txx9_gbus_clock = cpuclk * 2 / 5;
+			break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			txx9_gbus_clock = cpuclk / 3;
+			break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			txx9_gbus_clock = cpuclk / 4;
+			break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = cpuclk * 2 / 9;
+			break;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_master_clock = txx9_gbus_clock / 4;
+			break;
+		default:
+			txx9_master_clock = txx9_gbus_clock;
+		}
+	}
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
+	/* CCFG */
+	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
+	v = TX4938_RD64(&tx4938_ccfgptr->ccfg);
+	TX4938_WR64(&tx4938_ccfgptr->ccfg,
+		    v | TX4938_CCFG_WDRST | TX4938_CCFG_BEOW);
+	/* clear PCIC1 reset */
+	if ((v = TX4938_RD64(&tx4938_ccfgptr->clkctr)) & TX4938_CLKCTR_PCIC1RST) {
+		TX4938_WR64(&tx4938_ccfgptr->clkctr,
+			    v & ~TX4938_CLKCTR_PCIC1RST);
+	}
+
+	/* enable Timeout BusError */
+	if (tx4938_ccfg_toeon) {
+		v = TX4938_RD64(&tx4938_ccfgptr->ccfg);
+		TX4938_WR64(&tx4938_ccfgptr->ccfg, v | TX4938_CCFG_TOE);
+	}
+
+	/* DMA selection */
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, v & ~TX4938_PCFG_DMASEL_ALL);
+
+	/* Use external clock for external arbiter */
+	if (!(TX4938_RD64(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIXARB)) {
+		v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+		TX4938_WR(&tx4938_ccfgptr->pcfg, v & ~TX4938_PCFG_PCICLKEN_ALL);
+	}
+
+	printk("%s -- %dMHz(M%dMHz) CRIR:%08lx CCFG:%Lx PCFG:%Lx\n",
+	       pcode_str,
+	       cpuclk / 1000000, txx9_master_clock / 1000000,
+	       (unsigned long)TX4938_RD64(&tx4938_ccfgptr->crir),
+	       TX4938_RD64(&tx4938_ccfgptr->ccfg),
+	       TX4938_RD64(&tx4938_ccfgptr->pcfg));
+
+	printk("%s SDRAMC --", pcode_str);
+
+	for (i = 0; i < 4; i++) {
+		unsigned long long cr = TX4938_RD64(&tx4938_sdramcptr->cr[i]);
+		unsigned long ram_base, ram_size;
+		if (!((unsigned long)cr & 0x00000400))
+			continue;	/* disabled */
+		ram_base = (unsigned long)(cr >> 49) << 21;
+		ram_size = ((unsigned long)(cr >> 33) + 1) << 21;
+		if (ram_base >= 0x20000000)
+			continue;	/* high memory (ignore) */
+		printk(" CR%d:%016Lx", i, cr);
+		txboard_add_phys_region(ram_base, ram_size);
+	}
+	printk(" TR:%09Lx\n", TX4938_RD64(&tx4938_sdramcptr->tr));
+
+	/* SRAM */
+	if (pcode == 0x4938 && TX4938_RD64(&tx4938_sramcptr->cr) & 1) {
+		unsigned int size = 0x800;
+		unsigned long base =
+		    (TX4938_RD64(&tx4938_sramcptr->cr) >> (39 - 11)) & ~(size -
+									 1);
+		txboard_add_phys_region(base, size);
+	}
+
+	/* IRC */
+	/* disable interrupt control */
+	TX4938_WR(&tx4938_ircptr->cer, 0);
+
+	/* TMR */
+	/* disable all timers */
+	for (i = 0; i < TX4938_NR_TMR; i++) {
+		TX4938_WR(&tx4938_tmrptr(i)->tcr, 0x00000020);
+		TX4938_WR(&tx4938_tmrptr(i)->tisr, 0);
+		TX4938_WR(&tx4938_tmrptr(i)->cpra, 0xffffffff);
+		TX4938_WR(&tx4938_tmrptr(i)->itmr, 0);
+		TX4938_WR(&tx4938_tmrptr(i)->ccdr, 0);
+		TX4938_WR(&tx4938_tmrptr(i)->pgmr, 0);
+	}
+
+	/* enable DMA */
+	TX4938_WR64(0xff1fb150, TX4938_DMA_MCR_MSTEN);
+	TX4938_WR64(0xff1fb950, TX4938_DMA_MCR_MSTEN);
+
+	/* PIO */
+	TX4938_WR(&tx4938_pioptr->maskcpu, 0);
+	TX4938_WR(&tx4938_pioptr->maskext, 0);
+
+	/* TX4938 internal registers */
+	if (request_resource(&iomem_resource, &tx4938_reg_resource))
+		printk("request resource for internal registers failed\n");
+}
+
+#ifdef CONFIG_PCI
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr)
+{
+	unsigned short pcistatus =
+	    (unsigned short)(TX4938_RD(&pcicptr->pcistatus) >> 16);
+	unsigned long g2pstatus = TX4938_RD(&pcicptr->g2pstatus);
+	unsigned long pcicstatus = TX4938_RD(&pcicptr->pcicstatus);
+	static struct {
+		unsigned long flag;
+		const char *str;
+	} pcistat_tbl[] = {
+		{
+		PCI_STATUS_DETECTED_PARITY, "DetectedParityError"}, {
+		PCI_STATUS_SIG_SYSTEM_ERROR, "SignaledSystemError"}, {
+		PCI_STATUS_REC_MASTER_ABORT, "ReceivedMasterAbort"}, {
+		PCI_STATUS_REC_TARGET_ABORT, "ReceivedTargetAbort"}, {
+		PCI_STATUS_SIG_TARGET_ABORT, "SignaledTargetAbort"}, {
+	PCI_STATUS_PARITY, "MasterParityError"},}, g2pstat_tbl[] = {
+		{
+		TX4938_PCIC_G2PSTATUS_TTOE, "TIOE"}, {
+	TX4938_PCIC_G2PSTATUS_RTOE, "RTOE"},}, pcicstat_tbl[] = {
+		{
+		TX4938_PCIC_PCICSTATUS_PME, "PME"}, {
+		TX4938_PCIC_PCICSTATUS_TLB, "TLB"}, {
+		TX4938_PCIC_PCICSTATUS_NIB, "NIB"}, {
+		TX4938_PCIC_PCICSTATUS_ZIB, "ZIB"}, {
+		TX4938_PCIC_PCICSTATUS_PERR, "PERR"}, {
+		TX4938_PCIC_PCICSTATUS_SERR, "SERR"}, {
+		TX4938_PCIC_PCICSTATUS_GBE, "GBE"}, {
+	TX4938_PCIC_PCICSTATUS_IWB, "IWB"},};
+	int i;
+
+	printk("pcistat:%04x(", pcistatus);
+	for (i = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
+		if (pcistatus & pcistat_tbl[i].flag)
+			printk("%s ", pcistat_tbl[i].str);
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	for (i = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
+		if (g2pstatus & g2pstat_tbl[i].flag)
+			printk("%s ", g2pstat_tbl[i].str);
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	for (i = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
+		if (pcicstatus & pcicstat_tbl[i].flag)
+			printk("%s ", pcicstat_tbl[i].str);
+	printk(")\n");
+}
+
+void tx4938_report_pcic_status(void)
+{
+	int i;
+	struct tx4938_pcic_reg *pcicptr;
+	for (i = 0; (pcicptr = get_tx4938_pcicptr(i)) != NULL; i++)
+		tx4938_report_pcic_status1(pcicptr);
+}
+
+#endif				/* CONFIG_PCI */
+
+/* We use onchip r4k counter or TMR timer as our system wide timer
+ * interrupt running at 100HZ. */
+
+extern void __init rtc_rx5c348_init(int chipid);
+void __init rbtx4938_time_init(void)
+{
+	rtc_rx5c348_init(RBTX4938_SRTC_CHIPID);
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+}
+
+void __init toshiba_rbtx4938_setup(void)
+{
+	unsigned long long pcfg;
+	char *argptr;
+	unsigned char v;
+
+	iomem_resource.end = 0xffffffff;	/* 4GB */
+
+	if (txx9_master_clock == 0)
+		txx9_master_clock = 25000000;	/* 25MHz */
+	tx4938_board_setup();
+	/* setup irq stuff */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM0), 0x00000000);	/* irq trigger */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM1), 0x00000000);	/* irq trigger */
+	/* setup serial stuff */
+	TX4938_WR(0xff1ff314, 0x00000000);	/* h/w flow control off */
+	TX4938_WR(0xff1ff414, 0x00000000);	/* h/w flow control off */
+
+#ifndef CONFIG_PCI
+	set_io_port_base(RBTX4938_ETHER_BASE);
+#endif
+
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for (i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = 32 + i;
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE */ ;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	argptr = prom_getcmdline();
+	if (strstr(argptr, "console=") == NULL) {
+		strcat(argptr, " console=ttyS0,38400");
+	}
+#endif
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
+	printk("PIOSEL: disabling both ata and nand selection\n");
+	local_irq_disable();
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg,
+		    v & ~(TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL));
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
+	printk("PIOSEL: enabling nand selection\n");
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, v | TX4938_PCFG_NDF_SEL);
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, v & ~TX4938_PCFG_ATA_SEL);
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
+	printk("PIOSEL: enabling ata selection\n");
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, v | TX4938_PCFG_ATA_SEL);
+	v = TX4938_RD64(&tx4938_ccfgptr->pcfg);
+	TX4938_WR64(&tx4938_ccfgptr->pcfg, v & ~TX4938_PCFG_NDF_SEL);
+#endif
+
+#ifdef CONFIG_IP_PNP
+	argptr = prom_getcmdline();
+	if (strstr(argptr, "ip=") == NULL) {
+		strcat(argptr, " ip=any");
+	}
+#endif
+
+#ifdef CONFIG_FB
+	{
+		conswitchp = &dummy_con;
+	}
+#endif
+
+	rbtx4938_spi_setup();
+	pcfg = TX4938_RD64(&tx4938_ccfgptr->pcfg);	/* updated */
+	v = TX4938_RD08(rbtx4938_piosel_ptr);
+	/* fixup piosel */
+	if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+	    TX4938_PCFG_ATA_SEL)
+		TX4938_WR08(rbtx4938_piosel_ptr, (v & 0x03) | 0x04);
+	else if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+		 TX4938_PCFG_NDF_SEL)
+		TX4938_WR08(rbtx4938_piosel_ptr, (v & 0x03) | 0x08);
+	else
+		TX4938_WR08(rbtx4938_piosel_ptr, v & ~(0x08 | 0x04));
+
+	rbtx4938_fpga_resource.name = "FPGA Registers";
+	rbtx4938_fpga_resource.start = CPHYSADDR(RBTX4938_FPGA_REG_ADDR);
+	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
+	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &rbtx4938_fpga_resource))
+		printk("request resource for fpga failed\n");
+
+	/* disable all OnBoard I/O interrupts */
+	TX4938_WR08(RBTX4938_IMASK_ADDR, 0);
+
+	_machine_restart = rbtx4938_machine_restart;
+	_machine_halt = rbtx4938_machine_halt;
+	_machine_power_off = rbtx4938_machine_power_off;
+
+	TX4938_WR08(rbtx4938_led_ptr, 0xff);
+	printk("RBTX4938 --- FPGA(Rev %02x)",
+	       TX4938_RD08(rbtx4938_fpga_rev_ptr));
+	printk(" DIPSW:%02x,%02x\n", TX4938_RD08(rbtx4938_dipsw_ptr),
+	       TX4938_RD08(rbtx4938_bdipsw_ptr));
+}
+
+#ifdef CONFIG_PROC_FS
+extern void spi_eeprom_proc_create(struct proc_dir_entry *dir, int chipid);
+static int __init tx4938_spi_proc_setup(void)
+{
+	struct proc_dir_entry *tx4938_spi_eeprom_dir;
+
+	tx4938_spi_eeprom_dir = proc_mkdir("spi_eeprom", 0);
+
+	if (!tx4938_spi_eeprom_dir)
+		return -ENOMEM;
+
+	/* don't allow user access to RBTX4938_SEEPROM1_CHIPID
+	 * as it contains eth0 and eth1 MAC addresses
+	 */
+	spi_eeprom_proc_create(tx4938_spi_eeprom_dir, RBTX4938_SEEPROM2_CHIPID);
+	spi_eeprom_proc_create(tx4938_spi_eeprom_dir, RBTX4938_SEEPROM3_CHIPID);
+
+	return 0;
+}
+
+__initcall(tx4938_spi_proc_setup);
+#endif
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c
@@ -0,0 +1,166 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <asm/tx4938/spi.h>
+#include <asm/tx4938/tx4938.h>
+
+static int (*txx9_spi_cs_func) (int chipid, int on);
+static spinlock_t txx9_spi_lock = SPIN_LOCK_UNLOCKED;
+
+extern unsigned int txx9_gbus_clock;
+
+#define SPI_FIFO_SIZE	4
+
+void __init txx9_spi_init(unsigned long base,
+			  int (*cs_func) (int chipid, int on))
+{
+	txx9_spi_cs_func = cs_func;
+	/* enter config mode */
+	TX4938_WR(&tx4938_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(txx9_spi_wait);
+static irqreturn_t txx9_spi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long v;
+	/* disable rx intr */
+	v = TX4938_RD(&tx4938_spiptr->cr0);
+	TX4938_WR(&tx4938_spiptr->cr0, v & ~TXx9_SPCR0_RBSIE);
+	wake_up(&txx9_spi_wait);
+
+	return IRQ_HANDLED;
+}
+static struct irqaction txx9_spi_action = {
+	txx9_spi_interrupt, 0, CPU_MASK_NONE, "spi", NULL, NULL,
+};
+
+void __init txx9_spi_irqinit(int irc_irq)
+{
+	setup_irq(irc_irq, &txx9_spi_action);
+}
+
+int txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+		unsigned char **inbufs, unsigned int *incounts,
+		unsigned char **outbufs, unsigned int *outcounts, int cansleep)
+{
+	unsigned int incount, outcount;
+	unsigned char *inp, *outp;
+	int ret;
+	unsigned long flags;
+	unsigned long v;
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	if ((TX4938_RD(&tx4938_spiptr->mcr) & TXx9_SPMCR_OPMODE) ==
+	    TXx9_SPMCR_ACTIVE) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return -EBUSY;
+	}
+	/* enter config mode */
+	TX4938_WR(&tx4938_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+	TX4938_WR(&tx4938_spiptr->cr0,
+		  (desc->byteorder ? TXx9_SPCR0_SBOS : 0) |
+		  (desc->polarity ? TXx9_SPCR0_SPOL : 0) |
+		  (desc->phase ? TXx9_SPCR0_SPHA : 0) | 0x08);
+	TX4938_WR(&tx4938_spiptr->cr1,
+		  (((TXX9_IMCLK + desc->baud) / (2 * desc->baud) - 1) << 8) |
+		  0x08) /* 8 bit only */ ;
+	/* enter active mode */
+	TX4938_WR(&tx4938_spiptr->mcr, TXx9_SPMCR_ACTIVE);
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	/* CS ON */
+	if ((ret = txx9_spi_cs_func(chipid, 1)) < 0) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return ret;
+	}
+	udelay(desc->tcss);
+
+	/* do scatter IO */
+	inp = inbufs ? *inbufs : NULL;
+	outp = outbufs ? *outbufs : NULL;
+	incount = 0;
+	outcount = 0;
+	while (1) {
+		unsigned char data;
+		unsigned int count;
+		int i;
+		if (!incount) {
+			incount = incounts ? *incounts++ : 0;
+			inp = (incount && inbufs) ? *inbufs++ : NULL;
+		}
+		if (!outcount) {
+			outcount = outcounts ? *outcounts++ : 0;
+			outp = (outcount && outbufs) ? *outbufs++ : NULL;
+		}
+		if (!inp && !outp)
+			break;
+		count = SPI_FIFO_SIZE;
+		if (incount)
+			count = min(count, incount);
+		if (outcount)
+			count = min(count, outcount);
+
+		/* now tx must be idle... */
+		while (!(TX4938_RD(&tx4938_spiptr->sr) & TXx9_SPSR_SIDLE)) ;
+
+		v = TX4938_RD(&tx4938_spiptr->cr0);
+		TX4938_WR(&tx4938_spiptr->cr0,
+			  (v & ~TXx9_SPCR0_RXIFL_MASK) | ((count - 1) << 12));
+		if (cansleep) {
+			/* enable rx intr */
+			v = TX4938_RD(&tx4938_spiptr->cr0);
+			TX4938_WR(&tx4938_spiptr->cr0, v | TXx9_SPCR0_RBSIE);
+		}
+		/* send */
+		for (i = 0; i < count; i++)
+			TX4938_WR(&tx4938_spiptr->dr, inp ? *inp++ : 0);
+		/* wait all rx data */
+		if (cansleep) {
+			wait_event(txx9_spi_wait,
+				   TX4938_RD(&tx4938_spiptr->
+					     sr) & TXx9_SPSR_SRRDY);
+		} else {
+			while (!
+			       (TX4938_RD(&tx4938_spiptr->sr) &
+				TXx9_SPSR_RBSI)) ;
+		}
+		/* receive */
+		for (i = 0; i < count; i++) {
+			data = TX4938_RD(&tx4938_spiptr->dr);
+			if (outp)
+				*outp++ = data;
+		}
+		if (incount)
+			incount -= count;
+		if (outcount)
+			outcount -= count;
+	}
+
+	/* CS OFF */
+	udelay(desc->tcsh);
+	txx9_spi_cs_func(chipid, 0);
+	udelay(desc->tcsr);
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	/* enter config mode */
+	TX4938_WR(&tx4938_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	return 0;
+}
Index: linux-2.6.10/arch/mips/tx4938/common/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/irq.c
@@ -0,0 +1,399 @@
+/*
+ * linux/arch/mps/tx4938/common/irq.c
+ *
+ * Common tx4938 irq handler
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/irq.h>
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/tx4938/rbtx4938.h>
+
+/**********************************************************************************/
+/* Forwad definitions for all pic's                                               */
+/**********************************************************************************/
+
+static unsigned int tx4938_irq_cp0_startup(unsigned int irq);
+static void tx4938_irq_cp0_shutdown(unsigned int irq);
+static void tx4938_irq_cp0_enable(unsigned int irq);
+static void tx4938_irq_cp0_disable(unsigned int irq);
+static void tx4938_irq_cp0_mask_and_ack(unsigned int irq);
+static void tx4938_irq_cp0_end(unsigned int irq);
+
+static unsigned int tx4938_irq_pic_startup(unsigned int irq);
+static void tx4938_irq_pic_shutdown(unsigned int irq);
+static void tx4938_irq_pic_enable(unsigned int irq);
+static void tx4938_irq_pic_disable(unsigned int irq);
+static void tx4938_irq_pic_mask_and_ack(unsigned int irq);
+static void tx4938_irq_pic_end(unsigned int irq);
+
+/**********************************************************************************/
+/* Kernel structs for all pic's                                                   */
+/**********************************************************************************/
+DEFINE_SPINLOCK(tx4938_cp0_lock);
+DEFINE_SPINLOCK(tx4938_pic_lock);
+
+#define TX4938_CP0_NAME "TX4938-CP0"
+static struct hw_interrupt_type tx4938_irq_cp0_type = {
+	.typename = TX4938_CP0_NAME,
+	.startup = tx4938_irq_cp0_startup,
+	.shutdown = tx4938_irq_cp0_shutdown,
+	.enable = tx4938_irq_cp0_enable,
+	.disable = tx4938_irq_cp0_disable,
+	.ack = tx4938_irq_cp0_mask_and_ack,
+	.end = tx4938_irq_cp0_end,
+	.set_affinity = NULL
+};
+
+#define TX4938_PIC_NAME "TX4938-PIC"
+static struct hw_interrupt_type tx4938_irq_pic_type = {
+	.typename = TX4938_PIC_NAME,
+	.startup = tx4938_irq_pic_startup,
+	.shutdown = tx4938_irq_pic_shutdown,
+	.enable = tx4938_irq_pic_enable,
+	.disable = tx4938_irq_pic_disable,
+	.ack = tx4938_irq_pic_mask_and_ack,
+	.end = tx4938_irq_pic_end,
+	.set_affinity = NULL
+};
+
+static struct irqaction tx4938_irq_pic_action = {
+	.handler = no_action,
+	.flags = 0,
+	.mask = CPU_MASK_NONE,
+	.name = TX4938_PIC_NAME
+};
+
+/**********************************************************************************/
+/* Functions for cp0                                                              */
+/**********************************************************************************/
+
+#define tx4938_irq_cp0_mask(irq) ( 1 << ( irq-TX4938_IRQ_CP0_BEG+8 ) )
+
+static void __init tx4938_irq_cp0_init(void)
+{
+	int i;
+
+	for (i = TX4938_IRQ_CP0_BEG; i <= TX4938_IRQ_CP0_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx4938_irq_cp0_type;
+	}
+
+	return;
+}
+
+static unsigned int tx4938_irq_cp0_startup(unsigned int irq)
+{
+	tx4938_irq_cp0_enable(irq);
+
+	return (0);
+}
+
+static void tx4938_irq_cp0_shutdown(unsigned int irq)
+{
+	tx4938_irq_cp0_disable(irq);
+
+	return;
+}
+
+static void tx4938_irq_cp0_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_cp0_lock, flags);
+
+	set_c0_status(tx4938_irq_cp0_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_cp0_lock, flags);
+
+	return;
+}
+
+static void tx4938_irq_cp0_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_cp0_lock, flags);
+
+	clear_c0_status(tx4938_irq_cp0_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_cp0_lock, flags);
+
+	return;
+}
+
+static void tx4938_irq_cp0_mask_and_ack(unsigned int irq)
+{
+	tx4938_irq_cp0_disable(irq);
+
+	return;
+}
+
+static void tx4938_irq_cp0_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		tx4938_irq_cp0_enable(irq);
+	}
+
+	return;
+}
+
+/**********************************************************************************/
+/* Functions for pic                                                              */
+/**********************************************************************************/
+
+u32 tx4938_irq_pic_addr(int irq)
+{
+	/* MVMCP -- need to formulize this */
+	irq -= TX4938_IRQ_PIC_BEG;
+
+	switch (irq) {
+	case 17:
+	case 16:
+	case 1:
+	case 0:
+		return (TX4938_MKA(TX4938_IRC_IRLVL0));
+	case 19:
+	case 18:
+	case 3:
+	case 2:
+		return (TX4938_MKA(TX4938_IRC_IRLVL1));
+	case 21:
+	case 20:
+	case 5:
+	case 4:
+		return (TX4938_MKA(TX4938_IRC_IRLVL2));
+	case 23:
+	case 22:
+	case 7:
+	case 6:
+		return (TX4938_MKA(TX4938_IRC_IRLVL3));
+	case 25:
+	case 24:
+	case 9:
+	case 8:
+		return (TX4938_MKA(TX4938_IRC_IRLVL4));
+	case 27:
+	case 26:
+	case 11:
+	case 10:
+		return (TX4938_MKA(TX4938_IRC_IRLVL5));
+	case 29:
+	case 28:
+	case 13:
+	case 12:
+		return (TX4938_MKA(TX4938_IRC_IRLVL6));
+	case 31:
+	case 30:
+	case 15:
+	case 14:
+		return (TX4938_MKA(TX4938_IRC_IRLVL7));
+	}
+
+	return (0);
+}
+
+u32 tx4938_irq_pic_mask(int irq)
+{
+	/* MVMCP -- need to formulize this */
+	irq -= TX4938_IRQ_PIC_BEG;
+
+	switch (irq) {
+	case 31:
+	case 29:
+	case 27:
+	case 25:
+	case 23:
+	case 21:
+	case 19:
+	case 17:
+		return (0x07000000);
+	case 30:
+	case 28:
+	case 26:
+	case 24:
+	case 22:
+	case 20:
+	case 18:
+	case 16:
+		return (0x00070000);
+	case 15:
+	case 13:
+	case 11:
+	case 9:
+	case 7:
+	case 5:
+	case 3:
+	case 1:
+		return (0x00000700);
+	case 14:
+	case 12:
+	case 10:
+	case 8:
+	case 6:
+	case 4:
+	case 2:
+	case 0:
+		return (0x00000007);
+	}
+	return (0x00000000);
+}
+
+static void
+tx4938_irq_pic_modify(unsigned pic_reg, unsigned clr_bits, unsigned set_bits)
+{
+	unsigned long val = 0;
+
+	val = TX4938_RD(pic_reg);
+	val &= (~clr_bits);
+	val |= (set_bits);
+	TX4938_WR(pic_reg, val);
+	mmiowb();
+	TX4938_RD(pic_reg);
+
+	return;
+}
+
+static void __init tx4938_irq_pic_init(void)
+{
+	unsigned long flags;
+	int i;
+
+	for (i = TX4938_IRQ_PIC_BEG; i <= TX4938_IRQ_PIC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 2;
+		irq_desc[i].handler = &tx4938_irq_pic_type;
+	}
+
+	setup_irq(TX4938_IRQ_NEST_PIC_ON_CP0, &tx4938_irq_pic_action);
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	TX4938_WR(0xff1ff640, 0x6);	/* irq level mask -- only accept hightest */
+	TX4938_WR(0xff1ff600, TX4938_RD(0xff1ff600) | 0x1);	/* irq enable */
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static unsigned int tx4938_irq_pic_startup(unsigned int irq)
+{
+	tx4938_irq_pic_enable(irq);
+
+	return (0);
+}
+
+static void tx4938_irq_pic_shutdown(unsigned int irq)
+{
+	tx4938_irq_pic_disable(irq);
+
+	return;
+}
+
+static void tx4938_irq_pic_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	tx4938_irq_pic_modify(tx4938_irq_pic_addr(irq), 0,
+			      tx4938_irq_pic_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static void tx4938_irq_pic_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	tx4938_irq_pic_modify(tx4938_irq_pic_addr(irq),
+			      tx4938_irq_pic_mask(irq), 0);
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static void tx4938_irq_pic_mask_and_ack(unsigned int irq)
+{
+	tx4938_irq_pic_disable(irq);
+
+	return;
+}
+
+static void tx4938_irq_pic_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		tx4938_irq_pic_enable(irq);
+	}
+
+	return;
+}
+
+/**********************************************************************************/
+/* Main init functions                                                            */
+/**********************************************************************************/
+
+void __init tx4938_irq_init(void)
+{
+	extern asmlinkage void tx4938_irq_handler(void);
+
+	tx4938_irq_cp0_init();
+	tx4938_irq_pic_init();
+	set_except_vector(0, tx4938_irq_handler);
+
+	return;
+}
+
+int tx4938_irq_nested(void)
+{
+	int sw_irq = 0;
+	u32 level2;
+
+	level2 = TX4938_RD(0xff1ff6a0);
+	if ((level2 & 0x10000) == 0) {
+		level2 &= 0x1f;
+		sw_irq = TX4938_IRQ_PIC_BEG + level2;
+		if (sw_irq == 26) {
+			{
+				extern int toshiba_rbtx4938_irq_nested(int
+								       sw_irq);
+				sw_irq = toshiba_rbtx4938_irq_nested(sw_irq);
+			}
+		}
+	}
+
+	wbflush();
+	return (sw_irq);
+}
Index: linux-2.6.10/drivers/serial/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/serial/Makefile
+++ linux-2.6.10/drivers/serial/Makefile
@@ -48,5 +48,6 @@ obj-$(CONFIG_SERIAL_ICOM) += icom.o
 obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
 obj-$(CONFIG_SERIAL_MPSC) += mpsc.o
 obj-$(CONFIG_ETRAX_SERIAL) += crisv10.o
+obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
 obj-$(CONFIG_KGDB_8250) += kgdb_8250.o
 obj-$(CONFIG_KGDB_MPSC) += kgdb_mpsc.o
Index: linux-2.6.10/arch/mips/tx4938/common/rtc_rx5c348.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/rtc_rx5c348.c
@@ -0,0 +1,199 @@
+/*
+ * RTC routines for RICOH Rx5C348 SPI chip.
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include <asm/time.h>
+#include <asm/tx4938/spi.h>
+
+#define	EPOCH		2000
+
+/* registers */
+#define Rx5C348_REG_SECOND	0
+#define Rx5C348_REG_MINUTE	1
+#define Rx5C348_REG_HOUR	2
+#define Rx5C348_REG_WEEK	3
+#define Rx5C348_REG_DAY	4
+#define Rx5C348_REG_MONTH	5
+#define Rx5C348_REG_YEAR	6
+#define Rx5C348_REG_ADJUST	7
+#define Rx5C348_REG_ALARM_W_MIN	8
+#define Rx5C348_REG_ALARM_W_HOUR	9
+#define Rx5C348_REG_ALARM_W_WEEK	10
+#define Rx5C348_REG_ALARM_D_MIN	11
+#define Rx5C348_REG_ALARM_D_HOUR	12
+#define Rx5C348_REG_CTL1	14
+#define Rx5C348_REG_CTL2	15
+
+/* register bits */
+#define Rx5C348_BIT_PM	0x20	/* REG_HOUR */
+#define Rx5C348_BIT_Y2K	0x80	/* REG_MONTH */
+#define Rx5C348_BIT_24H	0x20	/* REG_CTL1 */
+#define Rx5C348_BIT_XSTP	0x10	/* REG_CTL2 */
+
+/* commands */
+#define Rx5C348_CMD_W(addr)	(((addr) << 4) | 0x08)	/* single write */
+#define Rx5C348_CMD_R(addr)	(((addr) << 4) | 0x0c)	/* single read */
+#define Rx5C348_CMD_MW(addr)	(((addr) << 4) | 0x00)	/* burst write */
+#define Rx5C348_CMD_MR(addr)	(((addr) << 4) | 0x04)	/* burst read */
+
+static struct spi_dev_desc srtc_dev_desc = {
+	.baud = 1000000,	/* 1.0Mbps @ Vdd 2.0V */
+	.tcss = 31,
+	.tcsh = 1,
+	.tcsr = 62,
+	/* 31us for Tcss (62us for Tcsr) is required for carry operation) */
+	.byteorder = 1,		/* MSB-First */
+	.polarity = 0,		/* High-Active */
+	.phase = 1,		/* Shift-Then-Sample */
+
+};
+static int srtc_chipid;
+static int srtc_24h;
+
+static inline int
+spi_rtc_io(unsigned char *inbuf, unsigned char *outbuf, unsigned int count)
+{
+	unsigned char *inbufs[1], *outbufs[1];
+	unsigned int incounts[2], outcounts[2];
+	inbufs[0] = inbuf;
+	incounts[0] = count;
+	incounts[1] = 0;
+	outbufs[0] = outbuf;
+	outcounts[0] = count;
+	outcounts[1] = 0;
+	return txx9_spi_io(srtc_chipid, &srtc_dev_desc,
+			   inbufs, incounts, outbufs, outcounts, 0);
+}
+
+/*
+ * Conversion between binary and BCD.
+ */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+/* RTC-dependent code for time.c */
+
+static int rtc_rx5c348_set_time(unsigned long t)
+{
+	unsigned char inbuf[8];
+	struct rtc_time tm;
+	u8 year, month, day, hour, minute, second, century;
+
+	/* convert */
+	to_tm(t, &tm);
+
+	year = tm.tm_year % 100;
+	month = tm.tm_mon + 1;	/* tm_mon starts from 0 to 11 */
+	day = tm.tm_mday;
+	hour = tm.tm_hour;
+	minute = tm.tm_min;
+	second = tm.tm_sec;
+	century = tm.tm_year / 100;
+
+	inbuf[0] = Rx5C348_CMD_MW(Rx5C348_REG_SECOND);
+	BIN_TO_BCD(second);
+	inbuf[1] = second;
+	BIN_TO_BCD(minute);
+	inbuf[2] = minute;
+
+	if (srtc_24h) {
+		BIN_TO_BCD(hour);
+		inbuf[3] = hour;
+	} else {
+		/* hour 0 is AM12, noon is PM12 */
+		inbuf[3] = 0;
+		if (hour >= 12)
+			inbuf[3] = Rx5C348_BIT_PM;
+		hour = (hour + 11) % 12 + 1;
+		BIN_TO_BCD(hour);
+		inbuf[3] |= hour;
+	}
+	inbuf[4] = 0;		/* ignore week */
+	BIN_TO_BCD(day);
+	inbuf[5] = day;
+	BIN_TO_BCD(month);
+	inbuf[6] = month;
+	if (century >= 20)
+		inbuf[6] |= Rx5C348_BIT_Y2K;
+	BIN_TO_BCD(year);
+	inbuf[7] = year;
+	/* write in one transfer to avoid data inconsistency */
+	return spi_rtc_io(inbuf, NULL, 8);
+}
+
+static unsigned long rtc_rx5c348_get_time(void)
+{
+	unsigned char inbuf[8], outbuf[8];
+	unsigned int year, month, day, hour, minute, second;
+
+	inbuf[0] = Rx5C348_CMD_MR(Rx5C348_REG_SECOND);
+	memset(inbuf + 1, 0, 7);
+	/* read in one transfer to avoid data inconsistency */
+	if (spi_rtc_io(inbuf, outbuf, 8))
+		return 0;
+	second = outbuf[1];
+	BCD_TO_BIN(second);
+	minute = outbuf[2];
+	BCD_TO_BIN(minute);
+	if (srtc_24h) {
+		hour = outbuf[3];
+		BCD_TO_BIN(hour);
+	} else {
+		hour = outbuf[3] & ~Rx5C348_BIT_PM;
+		BCD_TO_BIN(hour);
+		hour %= 12;
+		if (outbuf[3] & Rx5C348_BIT_PM)
+			hour += 12;
+	}
+	day = outbuf[5];
+	BCD_TO_BIN(day);
+	month = outbuf[6] & ~Rx5C348_BIT_Y2K;
+	BCD_TO_BIN(month);
+	year = outbuf[7];
+	BCD_TO_BIN(year);
+	year += EPOCH;
+
+	return mktime(year, month, day, hour, minute, second);
+}
+
+void __init rtc_rx5c348_init(int chipid)
+{
+	unsigned char inbuf[2], outbuf[2];
+	srtc_chipid = chipid;
+	/* turn on RTC if it is not on */
+	inbuf[0] = Rx5C348_CMD_R(Rx5C348_REG_CTL2);
+	inbuf[1] = 0;
+	spi_rtc_io(inbuf, outbuf, 2);
+	if (outbuf[1] & Rx5C348_BIT_XSTP) {
+		inbuf[0] = Rx5C348_CMD_W(Rx5C348_REG_CTL2);
+		inbuf[1] = 0;
+		spi_rtc_io(inbuf, NULL, 2);
+	}
+
+	inbuf[0] = Rx5C348_CMD_R(Rx5C348_REG_CTL1);
+	inbuf[1] = 0;
+	spi_rtc_io(inbuf, outbuf, 2);
+	if (outbuf[1] & Rx5C348_BIT_24H)
+		srtc_24h = 1;
+
+	/* set the function pointers */
+	rtc_get_time = rtc_rx5c348_get_time;
+	rtc_set_time = rtc_rx5c348_set_time;
+}
Index: linux-2.6.10/arch/mips/pci/fixup-tx4938.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/fixup-tx4938.c
@@ -0,0 +1,95 @@
+/*
+ * Toshiba rbtx4938 pci routines
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/config.h>
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/tx4938/rbtx4938.h>
+
+extern struct pci_controller tx4938_pci_controller[];
+
+int pci_get_irq(struct pci_dev *dev, int pin)
+{
+	int irq = pin;
+	u8 slot = PCI_SLOT(dev->devfn);
+	struct pci_controller *controller = (struct pci_controller *)dev->sysdata;
+
+	if (controller == &tx4938_pci_controller[1]) {
+		/* TX4938 PCIC1 */
+		switch (slot) {
+		case TX4938_PCIC_IDSEL_AD_TO_SLOT(31):
+			if (TX4938_RD64(&tx4938_ccfgptr->pcfg) & TX4938_PCFG_ETH0_SEL) 
+				return RBTX4938_IRQ_IRC + TX4938_IR_ETH0;
+			break;
+		case TX4938_PCIC_IDSEL_AD_TO_SLOT(30):
+			if (TX4938_RD64(&tx4938_ccfgptr->pcfg) & TX4938_PCFG_ETH1_SEL) 
+				return RBTX4938_IRQ_IRC + TX4938_IR_ETH1;
+			break;
+		}
+		return 0;
+	}
+
+	/* IRQ rotation */
+	irq--;	/* 0-3 */
+	if (dev->bus->parent == NULL &&
+	    (slot == TX4938_PCIC_IDSEL_AD_TO_SLOT(23))) {
+		/* PCI CardSlot (IDSEL=A23) */
+		/* PCIA => PCIA (IDSEL=A23) */
+		irq = (irq + 0 + slot) % 4;
+	} else {
+		/* PCI Backplane */
+		irq = (irq + 33 - slot) % 4;
+	}
+	irq++;	/* 1-4 */
+
+	switch (irq) {
+	case 1:
+		irq = RBTX4938_IRQ_IOC_PCIA;
+		break;
+	case 2:
+		irq = RBTX4938_IRQ_IOC_PCIB;
+		break;
+	case 3:
+		irq = RBTX4938_IRQ_IOC_PCIC;
+		break;
+	case 4:
+		irq = RBTX4938_IRQ_IOC_PCID;
+		break;
+	}
+	return irq;
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	unsigned char irq = 0;
+
+	irq = pci_get_irq(dev, pin);
+
+	printk(KERN_INFO "PCI: 0x%02x:0x%02x(0x%02x,0x%02x) IRQ=%d\n",
+	       dev->bus->number, dev->devfn, PCI_SLOT(dev->devfn),
+	       PCI_FUNC(dev->devfn), irq);
+
+	return irq;
+}
+
+/* 
+ * Do platform specific device initialization at pci_enable_device() time 
+ */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
Index: linux-2.6.10/drivers/char/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/char/Makefile
+++ linux-2.6.10/drivers/char/Makefile
@@ -21,7 +21,6 @@ obj-$(CONFIG_MVME147_SCC)	+= generic_ser
 obj-$(CONFIG_MVME162_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_BVME6000_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_SERIAL_TX3912)	+= generic_serial.o serial_tx3912.o
-obj-$(CONFIG_SERIAL_TXX9)	+= generic_serial.o serial_txx9.o
 obj-$(CONFIG_ROCKETPORT)	+= rocket.o
 obj-$(CONFIG_SERIAL167)		+= serial167.o
 obj-$(CONFIG_CYCLADES)		+= cyclades.o
Index: linux-2.6.10/drivers/char/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/char/Kconfig
+++ linux-2.6.10/drivers/char/Kconfig
@@ -388,14 +388,6 @@ config TXX927_SERIAL_CONSOLE
 	bool "TXx927 SIO Console support"
 	depends on TXX927_SERIAL
 
-config SERIAL_TXX9
-	bool "TMPTX39XX/49XX SIO support"
-	depends on MIPS && TOSHIBA_BOARDS=y
-
-config SERIAL_TXX9_CONSOLE
-	bool "TMPTX39XX/49XX SIO Console support"
-	depends on SERIAL_TXX9
-
 config SIBYTE_SB1250_DUART
 	bool "Support for BCM1xxx onchip DUART"
 	depends on MIPS && SIBYTE_SB1xxx_SOC=y
Index: linux-2.6.10/arch/mips/tx4938/common/irq_handler.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/irq_handler.S
@@ -0,0 +1,85 @@
+/*
+ * linux/arch/mips/tx4938/common/handler.S
+ *
+ * Primary interrupt handler for tx4938 based systems
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/tx4938/rbtx4938.h>
+
+
+		.align	5
+		NESTED(tx4938_irq_handler, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+
+		mfc0	t0, CP0_CAUSE  
+		mfc0	t1, CP0_STATUS
+		and	t0, t1
+        
+		andi	t1, t0, STATUSF_IP7	/* cpu timer */
+		bnez	t1, ll_ip7
+		
+		/* IP6..IP3 multiplexed -- do not use */
+
+		andi	t1, t0, STATUSF_IP2	/* tx4938 pic */
+		bnez	t1, ll_ip2
+
+		andi	t1, t0, STATUSF_IP1	/* user line 1 */
+		bnez	t1, ll_ip1
+
+		andi	t1, t0, STATUSF_IP0	/* user line 0 */
+		bnez	t1, ll_ip0
+
+		.set	reorder
+
+		nop
+		END(tx4938_irq_handler)
+
+		.align	5
+
+
+ll_ip7:
+		li	a0, TX4938_IRQ_CPU_TIMER
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+
+ll_ip2:
+		jal	tx4938_irq_nested
+		nop
+		beqz	v0, goto_spurious_interrupt
+		nop
+		move	a0, v0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+goto_spurious_interrupt:
+		j	ret_from_irq
+
+ll_ip1:
+		li	a0, TX4938_IRQ_USER1
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+ll_ip0:
+		li	a0, TX4938_IRQ_USER0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
Index: linux-2.6.10/include/asm-mips/tx4938/tx4938_mips.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4938/tx4938_mips.h
@@ -0,0 +1,54 @@
+/*
+ * linux/include/asm-mips/tx4938/tx4938_bitmask.h
+ * Generic bitmask definitions
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#ifndef TX4938_TX4938_MIPS_H
+#define TX4938_TX4938_MIPS_H
+#ifndef __ASSEMBLY__
+
+#define reg_rd08(r)    ((u8 )(*((vu8 *)(r))))
+#define reg_rd16(r)    ((u16)(*((vu16*)(r))))
+#define reg_rd32(r)    ((u32)(*((vu32*)(r))))
+#define reg_rd64(r)    ((u64)(*((vu64*)(r))))
+
+#define reg_wr08(r,v)  ((*((vu8 *)(r)))=((u8 )(v)))
+#define reg_wr16(r,v)  ((*((vu16*)(r)))=((u16)(v)))
+#define reg_wr32(r,v)  ((*((vu32*)(r)))=((u32)(v)))
+#define reg_wr64(r,v)  ((*((vu64*)(r)))=((u64)(v)))
+
+typedef volatile __signed char vs8;
+typedef volatile unsigned char vu8;
+
+typedef volatile __signed short vs16;
+typedef volatile unsigned short vu16;
+
+typedef volatile __signed int vs32;
+typedef volatile unsigned int vu32;
+
+typedef s8 s08;
+typedef vs8 vs08;
+
+typedef u8 u08;
+typedef vu8 vu08;
+
+#if (_MIPS_SZLONG == 64)
+
+typedef volatile __signed__ long vs64;
+typedef volatile unsigned long vu64;
+
+#else
+
+typedef volatile __signed__ long long vs64;
+typedef volatile unsigned long long vu64;
+
+#endif
+#endif
+#endif
Index: linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c
@@ -0,0 +1,216 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/tx4938/spi.h>
+#include <asm/tx4938/tx4938.h>
+
+/* ATMEL 250x0 instructions */
+#define	ATMEL_WREN	0x06
+#define	ATMEL_WRDI	0x04
+#define ATMEL_RDSR	0x05
+#define ATMEL_WRSR	0x01
+#define	ATMEL_READ	0x03
+#define	ATMEL_WRITE	0x02
+
+#define ATMEL_SR_BSY	0x01
+#define ATMEL_SR_WEN	0x02
+#define ATMEL_SR_BP0	0x04
+#define ATMEL_SR_BP1	0x08
+
+DEFINE_SPINLOCK(spi_eeprom_lock);
+
+static struct spi_dev_desc seeprom_dev_desc = {
+	.baud = 1500000,	/* 1.5Mbps */
+	.tcss = 1,
+	.tcsh = 1,
+	.tcsr = 1,
+	.byteorder = 1,		/* MSB-First */
+};
+static inline int
+spi_eeprom_io(int chipid,
+	      unsigned char **inbufs, unsigned int *incounts,
+	      unsigned char **outbufs, unsigned int *outcounts)
+{
+	return txx9_spi_io(chipid, &seeprom_dev_desc,
+			   inbufs, incounts, outbufs, outcounts, 0);
+}
+
+int spi_eeprom_write_enable(int chipid, int enable)
+{
+	unsigned char inbuf[1];
+	unsigned char *inbufs[1];
+	unsigned int incounts[2];
+	unsigned long flags;
+	int stat;
+	inbuf[0] = enable ? ATMEL_WREN : ATMEL_WRDI;
+	inbufs[0] = inbuf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, NULL, NULL);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+static int spi_eeprom_read_status_nolock(int chipid)
+{
+	unsigned char inbuf[2], outbuf[2];
+	unsigned char *inbufs[1], *outbufs[1];
+	unsigned int incounts[2], outcounts[2];
+	int stat;
+	inbuf[0] = ATMEL_RDSR;
+	inbuf[1] = 0;
+	inbufs[0] = inbuf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	outbufs[0] = outbuf;
+	outcounts[0] = sizeof(outbuf);
+	outcounts[1] = 0;
+	stat = spi_eeprom_io(chipid, inbufs, incounts, outbufs, outcounts);
+	if (stat < 0)
+		return stat;
+	return outbuf[1];
+}
+
+int spi_eeprom_read_status(int chipid)
+{
+	unsigned long flags;
+	int stat;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_read_status_nolock(chipid);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+int spi_eeprom_read(int chipid, int address, unsigned char *buf, int len)
+{
+	unsigned char inbuf[2];
+	unsigned char *inbufs[2], *outbufs[2];
+	unsigned int incounts[2], outcounts[3];
+	unsigned long flags;
+	int stat;
+	inbuf[0] = ATMEL_READ;
+	inbuf[1] = address;
+	inbufs[0] = inbuf;
+	inbufs[1] = NULL;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	outbufs[0] = NULL;
+	outbufs[1] = buf;
+	outcounts[0] = 2;
+	outcounts[1] = len;
+	outcounts[2] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, outbufs, outcounts);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+int spi_eeprom_write(int chipid, int address, unsigned char *buf, int len)
+{
+	unsigned char inbuf[2];
+	unsigned char *inbufs[2];
+	unsigned int incounts[3];
+	unsigned long flags;
+	int i, stat;
+
+	if (address / 8 != (address + len - 1) / 8)
+		return -EINVAL;
+	stat = spi_eeprom_write_enable(chipid, 1);
+	if (stat < 0)
+		return stat;
+	stat = spi_eeprom_read_status(chipid);
+	if (stat < 0)
+		return stat;
+	if (!(stat & ATMEL_SR_WEN))
+		return -EPERM;
+
+	inbuf[0] = ATMEL_WRITE;
+	inbuf[1] = address;
+	inbufs[0] = inbuf;
+	inbufs[1] = buf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = len;
+	incounts[2] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, NULL, NULL);
+	if (stat < 0)
+		goto unlock_return;
+
+	/* write start.  max 10ms */
+	for (i = 10; i > 0; i--) {
+		int stat = spi_eeprom_read_status_nolock(chipid);
+		if (stat < 0)
+			goto unlock_return;
+		if (!(stat & ATMEL_SR_BSY))
+			break;
+		mdelay(1);
+	}
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	if (i == 0)
+		return -EIO;
+	return len;
+      unlock_return:
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+#ifdef CONFIG_PROC_FS
+#define MAX_SIZE	0x80	/* for ATMEL 25010 */
+static int spi_eeprom_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	unsigned int size = MAX_SIZE;
+	if (spi_eeprom_read((int)data, 0, (unsigned char *)page, size) < 0)
+		size = 0;
+	return size;
+}
+
+static int spi_eeprom_write_proc(struct file *file, const char *buffer,
+				 unsigned long count, void *data)
+{
+	unsigned int size = MAX_SIZE;
+	int i;
+	if (file->f_pos >= size)
+		return -EIO;
+	if (file->f_pos + count > size)
+		count = size - file->f_pos;
+	for (i = 0; i < count; i += 8) {
+		int len = count - i < 8 ? count - i : 8;
+		if (spi_eeprom_write((int)data, file->f_pos,
+				     (unsigned char *)buffer, len) < 0) {
+			count = -EIO;
+			break;
+		}
+		buffer += len;
+		file->f_pos += len;
+	}
+	return count;
+}
+
+__init void spi_eeprom_proc_create(struct proc_dir_entry *dir, int chipid)
+{
+	struct proc_dir_entry *entry;
+	char name[128];
+	sprintf(name, "seeprom-%d", chipid);
+	entry = create_proc_entry(name, 0600, dir);
+	if (entry) {
+		entry->read_proc = spi_eeprom_read_proc;
+		entry->write_proc = spi_eeprom_write_proc;
+		entry->data = (void *)chipid;
+	}
+}
+#endif				/* CONFIG_PROC_FS */
Index: linux-2.6.10/arch/mips/tx4938/common/prom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4938/common/prom.c
@@ -0,0 +1,117 @@
+/*
+ * linux/arch/mips/tx4938/common/prom.c
+ *
+ * common tx4938 memory interface
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/tx4938.h>
+
+static unsigned int __init tx4938_process_sdccr(u64 * addr)
+{
+	u64 val;
+	unsigned int sdccr_ce;
+	unsigned int sdccr_rs;
+	unsigned int sdccr_cs;
+	unsigned int sdccr_mw;
+	unsigned int rs = 0;
+	unsigned int cs = 0;
+	unsigned int mw = 0;
+	unsigned int bc = 4;
+	unsigned int msize = 0;
+
+	val = (*((vu64 *) (addr)));
+
+	/* MVMCP -- need #defs for these bits masks */
+	sdccr_ce = ((val & (1 << 10)) >> 10);
+	sdccr_rs = ((val & (3 << 5)) >> 5);
+	sdccr_cs = ((val & (7 << 2)) >> 2);
+	sdccr_mw = ((val & (1 << 0)) >> 0);
+
+	if (sdccr_ce) {
+		switch (sdccr_rs) {
+		case 0:
+			rs = 2048;
+			break;
+		case 1:
+			rs = 4096;
+			break;
+		case 2:
+			rs = 8192;
+			break;
+		default:
+			rs = 0;
+			break;
+		}
+		switch (sdccr_cs) {
+		case 0:
+			cs = 256;
+			break;
+		case 1:
+			cs = 512;
+			break;
+		case 2:
+			cs = 1024;
+			break;
+		case 3:
+			cs = 2048;
+			break;
+		case 4:
+			cs = 4096;
+			break;
+		default:
+			cs = 0;
+			break;
+		}
+		switch (sdccr_mw) {
+		case 0:
+			mw = 8;
+			break;
+			/* 8 bytes = 64 bits */
+		case 1:
+			mw = 4;
+			break;
+			/* 4 bytes = 32 bits */
+		}
+	}
+
+	/*           bytes per chip    MB per chip          bank count */
+	msize = (((rs * cs * mw) / (1024 * 1024)) * (bc));
+
+	/* MVMCP -- bc hard coded to 4 from table 9.3.1     */
+	/*          boad supports bc=2 but no way to detect */
+
+	return (msize);
+}
+
+unsigned int __init tx4938_get_mem_size(void)
+{
+	unsigned int c0;
+	unsigned int c1;
+	unsigned int c2;
+	unsigned int c3;
+	unsigned int total;
+
+	/* MVMCP -- need #defs for these registers */
+	c0 = tx4938_process_sdccr((u64 *) 0xff1f8000);
+	c1 = tx4938_process_sdccr((u64 *) 0xff1f8008);
+	c2 = tx4938_process_sdccr((u64 *) 0xff1f8010);
+	c3 = tx4938_process_sdccr((u64 *) 0xff1f8018);
+	total = c0 + c1 + c2 + c3;
+
+	return (total);
+}
Index: linux-2.6.10/mvl_patches/pro-0226.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0226.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(226);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

