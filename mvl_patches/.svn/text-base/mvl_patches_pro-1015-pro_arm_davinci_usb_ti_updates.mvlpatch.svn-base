#! /usr/bin/env bash
# Patch: -pro_arm_davinci_usb_ti_updates
# Date: Wed Jan  3 19:10:23 2007
# Source: Texas Instruments, Inc.
# MR: 20446
# Type: Enhancement
# Disposition: merged from TI
# Signed-off-by: Kevin Hilman <khilman@mvista.com>
# Description:
# Verbose description from TI:
# 
# ti_davinci_mv_1_0_usb_fix_004

PATCHNUM=1015
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: Texas Instruments, Inc.
MR: 20446
Type: Enhancement
Disposition: merged from TI
Signed-off-by: Kevin Hilman <khilman@mvista.com>
Description:
Verbose description from TI:

ti_davinci_mv_1_0_usb_fix_004
=============================
drivers/usb/musb/cppi_dma.c:

1. Changed the variables to signed data type

Reason for change: In complete preemption gadget mode, the expression
in a conditional statement was sometimes giving -ve results, but
because of unsigned variables it resulted in wrong condition
evaluation.

2. Removed the "write - read back - correct write" logic for the RX
CPPI BUFCNT register. Just wrote it once with correct value.

Reason for change: In Complete Preemption gadget mode, the RX DMA
sometimes misbehaves and the device gets reset after sometime.

3. Call the completion routine even for host mode driver.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

drivers/usb/musb/g_ep0.c:

1. Added extra if condition for req->wLength = 0 & USB_DIR_IN

Reason for change: The www.linux-usb.org/usbtest 'test 14' fails with
error for zero length request. If the SETUP packet requests ZERO
length data from device-to-host, the TXPKTRDY bit needs to be set in
TXCSR otherwise the STATUS stage of control transfer will never
complete.

drivers/usb/musb/musb_gadget.c:

1. Added lock / unlock calls and replaced nuke() by
musb_gadget_disable() call for IN endpoint.

Reason for change: Resolves the Complete preemption "rmmod" issue.

2. Added lock / unlock calls and replaced nuke() by
musb_gadget_disable() call for IN & OUT endpoints.

Reason for change: Resolves the Complete preemption "rmmod" issue.

drivers/usb/musb/musb_host.c:
1. Added defines and globals used by Host TX DMA completion solution.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

2. Use DMAMODE = '1' for TX endpoint in host mode.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

3. Added functions (thread/tasklet) used by Host TX DMA completion
solution.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

4. Forward the completion request to the Host TX DMA completion
solution (thread/tasklet).

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

5. Return for TX end points as the Host TX DMA completion solution
(thread/tasklet) will take care of further action.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

6. Do not disable endpoint interrupt because Host TX DMA uses DMAMODE
= '1'.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

drivers/usb/musb/musb_host.h:

1. Added defines and globals used by Host TX DMA completion solution.

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

drivers/usb/musb/plat_uds.c:

1. Notify the thread handling to the Host TX DMA completion.  

Reason for change: Host mode TX DMA does not function, stops with
urb_unlink.

2. Initialize the globals for the Host TX DMA completion solution
(thread/tasklet).

Reason for change: Host mode TX DMA does not function, stops with urb_unlink.

drivers/usb/musb/virthub.c:

1. Commented lock / unlock calls 

Reason for change: Resolves the RT preemption issue. Linux Kernel
Image was not booting in Complete Pre-emption mode.

Apart from the above specific fixes the following issues were also addressed:
1. PIO and DMA mode issues are fixed.
2. Fix for musb_g_giveback() early call.
3. Fix for CPPI RX program active control
4. Enables RNDIS DMA for RX channel if requested by upper layer.

Index: linux-2.6.10/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.10/drivers/usb/musb/cppi_dma.c
@@ -507,6 +507,7 @@ cppi_next_tx_segment(struct musb *musb, 
 	unsigned		n_bds;
 	unsigned		i;
 	struct cppi_tx_stateram	*txState = tx->stateRam;
+	u32			tmp;
 
 	/* TX can use the CPPI "rndis" mode, where we can probably fit this
 	 * transfer in one BD and one IRQ; though some common cases (like
@@ -529,6 +530,14 @@ cppi_next_tx_segment(struct musb *musb, 
 		maxpacket = length;
 		n_bds = 1;
 	} else {
+		/* Disable endpoint interrupt for peripheral TX DMAReqMode '0' */
+		if (is_peripheral_active(musb) && length >= (maxpacket * 4)) {
+			MGC_SelectEnd(musb->ctrl_base, tx->chNo + 1);
+			tmp = 1 << (tx->chNo + 1 + DAVINCI_USB_TXINT_SHIFT);
+			musb_writel((musb->ctrl_base + DAVINCI_BASE_OFFSET),
+				    DAVINCI_USB_INT_MASK_CLR_REG,
+				    (tmp & DAVINCI_USB_TX_ENDPTS_MASK));
+		}
 		n_bds = length / maxpacket;
 		if (length % maxpacket)
 			n_bds++;
@@ -678,9 +687,10 @@ cppi_next_rx_segment(struct musb *musb, 
 	dma_addr_t		addr = rx->startAddr + rx->currOffset;
 	size_t			length = rx->transferSize - rx->currOffset;
 	struct cppi_descriptor	*bd, *tail;
-	unsigned		n_bds;
-	unsigned		i;
+	signed			n_bds;
+	signed			i;
 	void			*__iomem tibase = musb->ctrl_base;
+	u8			rndis;
 
 	/*printk("st=%d off=%d sz=%d len=%d 1=%d",rx->startAddr,rx->currOffset,rx->transferSize,length,onepacket);*/
 
@@ -698,9 +708,19 @@ cppi_next_rx_segment(struct musb *musb, 
 		if (n_bds == 1)
 			onepacket = 1;
 		else
-			n_bds = min(n_bds, (unsigned) NUM_RXCHAN_BD);
+			n_bds = min(n_bds, (signed) NUM_RXCHAN_BD);
 	}
 
+	if ((onepacket && ((length > 0xffff) || (length <= maxpacket) ||
+			   ((maxpacket & 0x3f) != 0) || ((length & 0x3f) != 0)))
+	    || (onepacket == 0)) {
+		rndis = 0;
+	} else {
+		rndis = 1;
+		maxpacket = length;
+	}
+	cppi_rndis_update(rx, 1, musb->ctrl_base, rndis);
+
 	/* In host mode, autorequest logic can generate some IN tokens; it's
 	 * tricky since we can't leave REQPKT set in RXCSR after the transfer
 	 * finishes. So:  multipacket transfers involve two or more segments.
@@ -810,24 +830,11 @@ cppi_next_rx_segment(struct musb *musb, 
 			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
 			& 0xffff;
 
-	if (!i)
-		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
-			n_bds + 2);
-	else if (n_bds > (i - 3))
-		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
-			n_bds - (i - 3));
-
-	i = musb_readl(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
-			& 0xffff;
-	if (i < (2 + n_bds)) {
-		DBG(2, "bufcnt%d underrun - %d (for %d)\n",
-					rx->chNo, i, n_bds);
+	if (n_bds > (i - 2))
+	{
 		musb_writel(tibase,
 			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
-			n_bds + 2);
+			n_bds - i + 2);
 	}
 
 	cppi_dump_rx(4, rx, "/S");
@@ -1038,6 +1045,7 @@ void cppi_completion(struct musb *pThis,
 	struct cppi		*cppi;
 	struct cppi_descriptor	*bdPtr;
 	struct musb_hw_ep	*pEnd = NULL;
+	u32			tmp;
 
 	cppi = container_of(pThis->pDmaController, struct cppi, Controller);
 
@@ -1103,6 +1111,22 @@ void cppi_completion(struct musb *pThis,
 				 */
 //				if ((bdPtr->hOptions & CPPI_EOQ_MASK))
 					txState->completionPtr = bdPtr->dma;
+				if (is_peripheral_active(cppi->musb)
+				    && (txChannel->transferSize -
+					txChannel->actualLen)
+				    == (2 * txChannel->pktSize)) {
+					MGC_SelectEnd(regBase +
+						      DAVINCI_BASE_OFFSET,
+						      txChannel->chNo + 1);
+					/* Enable endpoint interrupt */
+					tmp =
+					    1 << (txChannel->chNo + 1 +
+						  DAVINCI_USB_TXINT_SHIFT);
+					musb_writel(regBase,
+						    DAVINCI_USB_INT_MASK_SET_REG,
+						    (tmp &
+						     DAVINCI_USB_TX_ENDPTS_MASK));
+				}
 
 				/* stop scanning on end-of-segment */
 				if (bdPtr->hNext == 0)
@@ -1132,7 +1156,9 @@ void cppi_completion(struct musb *pThis,
 					 * to empty (TXPKTRDY irq) before going
 					 * to the next queued bulk transfer.
 					 */
+#ifndef HOST_TX_DMA_SOLUTION
 					if (is_peripheral_active(cppi->musb))
+#endif
 						cppi->dma_completed(pThis,
 							      chanNum + 1, 1);
 
@@ -1319,22 +1345,18 @@ static int cppi_channel_abort(struct dma
 		} while (0xFFFFFFFC != regVal);
 		txState->completionPtr = 0xFFFFFFFC;
 
+		musb_writel(regBase, DAVINCI_CPPI_EOI_REG, 0);
+
 		/* FIXME clean up the transfer state ... here?
 		 * the completion routine should get called with
 		 * an appropriate status code.
 		 */
 
 		regVal = MGC_ReadCsr16(mbase, MGC_O_HDRC_TXCSR, chNum + 1);
-		regVal &= ~MGC_M_TXCSR_DMAENAB;
 		regVal |= MGC_M_TXCSR_FLUSHFIFO;
 		MGC_WriteCsr16(mbase, MGC_O_HDRC_TXCSR, chNum + 1, regVal);
 		MGC_WriteCsr16(mbase, MGC_O_HDRC_TXCSR, chNum + 1, regVal);
 
-		/* re-enable interrupt */
-		if (enabled)
-			musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
-					(1 << otgCh->chNo));
-
 		txState->headPtr = 0;
 		txState->sopDescPtr = 0;
 		txState->currBuffPtr = 0;
@@ -1358,6 +1380,11 @@ static int cppi_channel_abort(struct dma
 		/* compare mode, write back zero now */
 		txState->completionPtr = 0;
 
+		/* re-enable interrupt */
+		if (enabled)
+			musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
+					(1 << otgCh->chNo));
+
 		cppi_dump_tx(5, otgCh, " (done teardown)");
 
 		/* REVISIT tx side _should_ clean up the same way
@@ -1428,6 +1455,10 @@ static int cppi_channel_abort(struct dma
 		cppi_bd_free(otgCh, otgCh->lastHwBDProcessed);
 		otgCh->lastHwBDProcessed = NULL;
 
+		/* cppi_rx_scan changes the activeQueueHead, read it again */
+		if (otgCh->activeQueueHead)
+			queue = otgCh->activeQueueHead;
+
 		while (queue) {
 			struct cppi_descriptor	*tmp = queue->next;
 			cppi_bd_free(otgCh, queue);
Index: linux-2.6.10/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.10/drivers/usb/musb/g_ep0.c
@@ -561,7 +561,12 @@ musb_read_setup(struct musb *pThis, stru
 	 */
 	pThis->bSetAddress = FALSE;
 	pThis->ackpend = MGC_M_CSR0_P_SVDRXPKTRDY;
-	if (req->wLength == 0)
+	if(req->wLength == 0 && (req->bRequestType & USB_DIR_IN))
+	{
+		pThis->ackpend |= MGC_M_CSR0_TXPKTRDY;
+		pThis->ep0_state = MGC_END0_STAGE_ACKWAIT;
+	}
+	else if (req->wLength == 0)
 		pThis->ep0_state = MGC_END0_STAGE_ACKWAIT;
 	else if (req->bRequestType & USB_DIR_IN) {
 		pThis->ep0_state = MGC_END0_STAGE_TX;
@@ -672,6 +677,8 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 				musb_write_fifo(&pThis->aLocalEnd[0],
 						 sizeof(musb_test_packet),
 						 musb_test_packet);
+				MGC_WriteCsr16(pBase, MGC_O_HDRC_CSR0, 0,
+					       wCsrVal | MGC_M_CSR0_TXPKTRDY);
 			}
 
 			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
Index: linux-2.6.10/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.10/drivers/usb/musb/musb_gadget.c
@@ -102,7 +102,6 @@ __acquires(ep->musb->Lock)
 {
 	struct musb_request	*req;
 	struct musb		*musb;
-	int			busy = ep->busy;
 
 	req = to_musb_request(pRequest);
 
@@ -111,7 +110,6 @@ __acquires(ep->musb->Lock)
 		req->request.status = status;
 	musb = req->musb;
 
-	ep->busy = 1;
 	spin_unlock(&musb->Lock);
 	if (is_dma_capable() && req->mapped) {
 		dma_unmap_single(musb->controller,
@@ -134,7 +132,7 @@ __acquires(ep->musb->Lock)
 				pRequest->status);
 	req->request.complete(&req->ep->end_point, &req->request);
 	spin_lock(&musb->Lock);
-	ep->busy = busy;
+	ep->busy = 0;
 }
 
 /* ----------------------------------------------------------------------- */
@@ -163,6 +161,7 @@ static void nuke(struct musb_ep *ep, con
 		req = container_of(ep->req_list.next, struct musb_request,
 				request.list);
 		musb_g_giveback(ep, &req->request, status);
+		ep->busy = 1;
 	}
 }
 
@@ -233,6 +232,9 @@ static void txstate(struct musb *pThis, 
 		return;
 	}
 
+	/* update the endpoint busy/free status */
+	pEnd->busy = 1;
+
 	if (is_dma_capable() && pEnd->dma) {
 		struct dma_controller	*c;
 
@@ -307,7 +309,7 @@ static void txstate(struct musb *pThis, 
  * FIFO state update (e.g. data ready).
  * Called from IRQ,  with controller locked.
  */
-void musb_g_tx(struct musb *pThis, u8 bEnd)
+void musb_g_tx(struct musb *pThis, u8 bEnd, u8 is_ep_intr)
 {
 	u16			wCsrVal;
 	struct usb_request	*pRequest;
@@ -392,11 +394,9 @@ void musb_g_tx(struct musb *pThis, u8 bE
 
 					MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR,
 						       bEnd, wCsrVal);
+					break;
 				}
 
-				/* ... or if not, then complete it */
-				musb_g_giveback(pEnd, pRequest, 0);
-
 				/* kickstart next transfer if appropriate;
 				 * the packet that just completed might not
 				 * be transmitted for hours or days.
@@ -406,7 +406,11 @@ void musb_g_tx(struct musb *pThis, u8 bE
 				MGC_SelectEnd(pBase, bEnd);
 				wCsrVal = MGC_ReadCsr16(pBase,
 						MGC_O_HDRC_TXCSR, bEnd);
-				if (wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY)
+				if (is_ep_intr
+				    || ((wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY) ==
+					0))
+					musb_g_giveback(pEnd, pRequest, 0);
+				else
 					break;
 				pRequest = pEnd->desc
 						? next_request(pEnd)
@@ -440,6 +444,9 @@ static void rxstate(struct musb *pThis, 
 
 	wCsrVal = MGC_ReadCsr16(pBase, MGC_O_HDRC_RXCSR, bEnd);
 
+	/* update the endpoint busy/free status */
+	pEnd->busy = 1;
+
 #ifdef	CONFIG_USB_TI_CPPI_DMA
 	if (is_dma_capable() && pEnd->dma) {
 		struct dma_controller	*c = pThis->pDmaController;
@@ -1568,12 +1575,12 @@ stop_activity(struct musb *musb, struct 
                                musb_gadget_disable(&hw_ep->ep_in.end_point);
                                spin_lock(&musb->Lock);
 			} else {
-				if (hw_ep->wMaxPacketSizeTx) {
+				if (hw_ep->wMaxPacketSizeTx){
 					spin_unlock(&musb->Lock);
 					musb_gadget_disable(&hw_ep->ep_in.end_point);
                                        spin_lock(&musb->Lock);
 				}
-				if (hw_ep->wMaxPacketSizeRx) {
+				if (hw_ep->wMaxPacketSizeRx){
 					spin_unlock(&musb->Lock);
                                        musb_gadget_disable(&hw_ep->ep_out.end_point);
                                        spin_lock(&musb->Lock);
Index: linux-2.6.10/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.10/drivers/usb/musb/musb_host.c
@@ -48,6 +48,58 @@
 #include "musbdefs.h"
 #include "musb_host.h"
 
+#ifdef HOST_TX_DMA_SOLUTION
+
+struct host_tx_completion_req
+{
+	struct list_head  node;	  /* Completion request list node */
+
+	struct urb        *pUrb;  /* URB for completion */
+	struct musb_hw_ep *pEnd;  /* Endpoint */
+	int		  status; /* Status at time of completion */
+	int		  isBusy; /* Completion request list node status:
+				     1 => in use / busy
+				     0 => not in use / available */
+};
+
+/* Globals and function prototypes */
+
+/* Static pool of tx completion request structures */
+#define HOST_TX_REQ_POOL_SIZE	64
+static struct host_tx_completion_req host_tx_req_pool[HOST_TX_REQ_POOL_SIZE];
+struct list_head	tx_completion_list;
+
+#ifndef CONFIG_PREEMPT_RT
+static spinlock_t		txReqListLock;
+#else
+struct semaphore		txReqListLock;
+#endif
+
+#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
+
+DECLARE_MUTEX_LOCKED(semTxListEmpty);
+struct completion	hostTxThreadNotify;
+
+/* Host TX DMA Completion kernel thread routine */
+static int musb_host_tx_completion_thread(void *);
+
+#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
+
+static int reSchedCount = 0;		/* Tasklet reschedule count */
+#define	MAX_TASKLET_REG_POLL_COUNT	32767
+#define MAX_TASKLET_RESCHED_COUNT	256
+
+/* Host TX DMA Completion kernel thread routine */
+static void musb_host_tx_completion_tasklet(unsigned long);
+
+/* Declare and initialize the tasklet */
+static DECLARE_TASKLET(host_tx_completion_tasklet,
+		       musb_host_tx_completion_tasklet, 0);
+#endif
+
+static struct host_tx_completion_req *get_free_tx_req_pool_entry(void);
+
+#endif /* HOST_TX_DMA_SOLUTION */
 
 /* MUSB HOST status 9-mar-2006
  *
@@ -135,6 +187,9 @@ void MGC_HdrcEnableTXDMA(struct musb *pT
 	MGC_SelectEnd(pBase, bEnd);
 	txCsr = MGC_ReadCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd);
 	txCsr |= MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_H_WZC_BITS;
+#ifdef HOST_TX_DMA_SOLUTION
+	txCsr |= MGC_M_TXCSR_DMAMODE;
+#endif
 	MGC_WriteCsr16(pBase, MGC_O_HDRC_TXCSR, bEnd, txCsr);
 }
 
@@ -327,12 +382,16 @@ __musb_giveback(struct urb *urb, int sta
 	 * FIXME: make this use hcd framework giveback, so we don't use
 	 * the usbcore-internal wakeup queue...
 	 */
-	usb_put_dev(urb->dev);
-	urb->complete(urb, hw_ep->musb->int_regs);
-	atomic_dec(&urb->use_count);
-	if (urb->reject)
-		wake_up(&usb_kill_urb_queue);
-	usb_put_urb(urb);
+	if(urb->dev) {
+		usb_put_dev(urb->dev);
+		urb->complete(urb, hw_ep->musb->int_regs);
+		atomic_dec(&urb->use_count);
+		if (urb->reject)
+			wake_up(&usb_kill_urb_queue);
+		usb_put_urb(urb);
+	} else {
+		DBG(4, "NULL device pointer\n");
+	}
 }
 
 /* for non-iso endpoints only */
@@ -343,6 +402,7 @@ static inline void musb_save_toggle(stru
 	void __iomem		*hw = ep->musb->pRegs;
 
 	ep->bIsReady = FALSE;
+	if (!udev) return;
 	if (usb_pipeout(urb->pipe)) {
 		csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR,
 				ep->bLocalEnd);
@@ -358,6 +418,302 @@ static inline void musb_save_toggle(stru
 	}
 }
 
+#ifdef HOST_TX_DMA_SOLUTION
+
+/* get the free entry from static pool of host tx completion request */
+static struct host_tx_completion_req *get_free_tx_req_pool_entry(void)
+{
+	/* NOTE: This function assumes caller owns the global
+	 *       host tx completion request list lock. */
+	struct host_tx_completion_req *pHostTxReqEntry = NULL;
+	int idx;
+
+	pHostTxReqEntry = &host_tx_req_pool[0];
+	for(idx = 0; idx < HOST_TX_REQ_POOL_SIZE; idx++)
+	{
+		pHostTxReqEntry = &host_tx_req_pool[idx];
+		if(pHostTxReqEntry->isBusy == 0)
+			break;
+	}
+	if(idx < HOST_TX_REQ_POOL_SIZE)
+	{
+		pHostTxReqEntry->isBusy = 1;
+	}
+	else
+		pHostTxReqEntry = NULL;
+
+	return pHostTxReqEntry;
+}
+
+#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
+
+int musb_host_tx_completion_thread(void *pVoid)
+{
+	struct host_tx_thread_req *pHostTxReq = NULL;
+
+	struct musb *pThis      = NULL;
+	struct urb  *pUrb       = NULL;
+	struct musb_hw_ep *pEnd = NULL;
+
+	int status;
+	u8  busy;
+	u8  type;
+
+	u16 csr;
+	void __iomem *hw;
+
+	unsigned long flags;
+
+	/* wait for thread startup notification */
+	wait_for_completion(&hostTxThreadNotify);
+	init_completion(&hostTxThreadNotify);
+
+	/* TODO: Need to implement thread exit condition */
+	while(1)
+	{
+		ACQUIRE_TX_REQ_LIST_LOCK();
+		if(list_empty(&tx_completion_list))
+		{
+			RELEASE_TX_REQ_LIST_LOCK();
+
+			if(down_interruptible(&semTxListEmpty))
+			{
+				/* TODO: Handle empty list wait INTERRUPTED */
+				break;
+			}
+			ACQUIRE_TX_REQ_LIST_LOCK();
+		}
+
+		/* get the request list head entry */
+		pHostTxReq = list_entry(tx_completion_list.next,
+								struct host_tx_thread_req, node);
+		if(pHostTxReq == NULL || &pHostTxReq->node == &tx_completion_list)
+		{
+			/* The list is actually empty, observed this condition for
+			 * thread based solution.
+			 */
+			RELEASE_TX_REQ_LIST_LOCK();
+			cpu_relax();
+			continue;
+		}
+
+		pUrb   = pHostTxReq->pUrb;
+		pEnd   = pHostTxReq->pEnd;
+		status = pHostTxReq->status;
+
+		/* update the static tx request pool entry status to free */
+		pHostTxReq->isBusy = 0;
+
+		list_del_init(&pHostTxReq->node); /* delete request entry from list */
+
+		RELEASE_TX_REQ_LIST_LOCK();
+
+		pThis  = pEnd->musb;
+		hw     = pThis->pRegs;
+		pHostTxReq = NULL;
+
+		/* NOTE: copied the code segment from musb_giveback() */
+		spin_lock_irqsave(&pThis->Lock, flags);
+		type = pEnd->out_traffic_type;
+		/* save toggle eagerly, for paranoia */
+		switch (type)
+		{
+		case PIPE_BULK:
+		case PIPE_INTERRUPT:
+			/* Poll FIFONOTEMPTY & TXPKTRDY before saving DATATOGGLE status */
+			do
+			{
+				csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR, pEnd->bLocalEnd);
+			} while((csr & MGC_M_TXCSR_FIFONOTEMPTY)
+					|| (csr & MGC_M_TXCSR_TXPKTRDY));
+			/* save the data toggle status */
+			musb_save_toggle(pEnd, pUrb);
+		}
+
+		busy = pEnd->out_busy;
+		pEnd->out_busy = 1;
+
+		spin_unlock_irqrestore(&pThis->Lock, flags);
+
+		__musb_giveback(pUrb, status);
+
+		spin_lock_irqsave(&pThis->Lock, flags);
+
+		pEnd->out_busy = busy;
+
+		/* reclaim resources (and bandwidth) ASAP */
+		if (list_empty(&pEnd->urb_list))
+		{
+			switch (type)
+			{
+			case PIPE_ISOCHRONOUS:
+			case PIPE_INTERRUPT:
+				/* this is where periodic bandwidth should be
+				 * de-allocated if its tracked and allocated.
+				 */
+				pEnd->bIsClaimed = FALSE;
+				pEnd->bIsReady = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			/* NOTE: This is from musb_advance_urb_queue() */
+			musb_start_urb(pThis, pEnd);
+		}
+		spin_unlock_irqrestore(&pThis->Lock, flags);
+	}
+
+	/* exit thread with notification */
+	complete_and_exit(&hostTxThreadNotify, 0);
+}
+
+#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
+
+/* Tasklet routine to handle the host tx completion request list.
+ * Before the scheduled tasklet comes in execution if we see another
+ * interrupt, there could be more than one completion requests pending.
+ * TODO: The pending requests may be maximum 2, but need to make
+ * sure this.
+ */
+void musb_host_tx_completion_tasklet(unsigned long unused)
+{
+	struct host_tx_completion_req *pHostTxReq = NULL;
+
+	struct musb *pThis      = NULL;
+	struct urb  *pUrb       = NULL;
+	struct musb_hw_ep *pEnd = NULL;
+
+	int status;
+	u8  busy;
+	u8  type;
+
+	unsigned long flags;
+
+	u16 pollCount;
+	u16 csr;
+	void __iomem *hw;
+
+	ACQUIRE_TX_REQ_LIST_LOCK();
+	while(!list_empty(&tx_completion_list))
+	{
+		/* get the request list head entry */
+		pHostTxReq = list_entry(tx_completion_list.next,
+					struct host_tx_completion_req, node);
+		if(pHostTxReq == NULL ||
+		   &pHostTxReq->node == &tx_completion_list)
+		{
+			/* The list is actually empty, observed this condition
+			 * for thread based solution. */
+			break;
+		}
+
+		pUrb   = pHostTxReq->pUrb;
+		spin_lock(&pUrb->lock);
+		status = pUrb->status;
+		spin_unlock(&pUrb->lock);
+		if (status != -EINPROGRESS && status != 0) {
+			pHostTxReq->isBusy = 0;
+			list_del_init(&pHostTxReq->node);
+			DBG(1, "URB %p -> status %d changed after queued to tasklet\n", pUrb, status);
+			continue;
+		}
+
+		pEnd   = pHostTxReq->pEnd;
+		status = pHostTxReq->status;
+
+		pThis  = pEnd->musb;
+		hw     = pThis->pRegs;
+
+		/* NOTE: copied the code segment from musb_giveback() */
+		spin_lock_irqsave(&pThis->Lock, flags);
+		type = pEnd->out_traffic_type;
+		/* save toggle eagerly, for paranoia */
+		switch (type)
+		{
+		case PIPE_BULK:
+		case PIPE_INTERRUPT:
+			/* Poll FIFONOTEMPTY & TXPKTRDY before saving
+			 * DATATOGGLE status */
+			csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR,
+					    pEnd->bLocalEnd);
+			for (pollCount = 0;
+			     pollCount < MAX_TASKLET_REG_POLL_COUNT &&
+				     ((csr & MGC_M_TXCSR_FIFONOTEMPTY) ||
+				      (csr & MGC_M_TXCSR_TXPKTRDY));
+			     pollCount++) {
+ 				csr = MGC_ReadCsr16(hw, MGC_O_HDRC_TXCSR,
+						    pEnd->bLocalEnd);
+			}
+			if (pollCount == MAX_TASKLET_REG_POLL_COUNT) {
+				if(reSchedCount >= MAX_TASKLET_RESCHED_COUNT) {
+					status = -ETIMEDOUT;
+					WARN("Tasklet reSchedCount = %d for urb %p\n", reSchedCount, pUrb);
+					break;
+				}
+
+				spin_unlock_irqrestore(&pThis->Lock, flags);
+				RELEASE_TX_REQ_LIST_LOCK();
+
+				reSchedCount++;
+
+				/* re-schedule the tasklet */
+				tasklet_schedule(&host_tx_completion_tasklet);
+				return;
+			}
+			/* save the data toggle status */
+			musb_save_toggle(pEnd, pUrb);
+		}
+		/* update the static tx request pool entry status to free */
+		pHostTxReq->isBusy = 0;
+		list_del_init(&pHostTxReq->node);
+		pHostTxReq = NULL;
+
+		RELEASE_TX_REQ_LIST_LOCK();
+
+		reSchedCount = 0;
+
+		busy = pEnd->out_busy;
+		pEnd->out_busy = 1;
+
+		spin_unlock_irqrestore(&pThis->Lock, flags);
+
+		__musb_giveback(pUrb, status);
+
+		spin_lock_irqsave(&pThis->Lock, flags);
+
+		pEnd->out_busy = busy;
+
+		/* reclaim resources (and bandwidth) ASAP */
+		if (list_empty(&pEnd->urb_list))
+		{
+			switch (type)
+			{
+			case PIPE_ISOCHRONOUS:
+			case PIPE_INTERRUPT:
+				/* this is where periodic bandwidth should be
+				 * de-allocated if its tracked and allocated.
+				 */
+				pEnd->bIsClaimed = FALSE;
+				pEnd->bIsReady = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			/* NOTE: This is from musb_advance_urb_queue() */
+			musb_start_urb(pThis, pEnd);
+		}
+		spin_unlock_irqrestore(&pThis->Lock, flags);
+
+		ACQUIRE_TX_REQ_LIST_LOCK();
+	}
+	RELEASE_TX_REQ_LIST_LOCK();
+}
+#endif
+
+#endif /* HOST_TX_DMA_SOLUTION */
+
 // REVISIT need to handle both rx and tx paths for each hw_ep...
 
 /* caller owns controller lock, irqs are blocked */
@@ -368,13 +724,89 @@ __acquires(ep->musb->Lock)
 	int			is_in;
 	u8			busy;
 	u8			type;
-
+#ifdef HOST_TX_DMA_SOLUTION
+#if HOST_TX_DMA_SOLUTION == 1
+	u8 			listEmpty = 0;
+#elif HOST_TX_DMA_SOLUTION == 2
+	int			urbStatus = 0;
+#endif
+	struct host_tx_completion_req *pHostTxReq = NULL;
+#endif
 	if (ep->bIsSharedFifo)
 		is_in = 1;
 	else
 		is_in = usb_pipein(urb->pipe);
 	type = is_in ? ep->in_traffic_type : ep->out_traffic_type;
 
+#ifdef HOST_TX_DMA_SOLUTION
+
+	/* TODO: How do we handle already pending TX completion events when we get
+	 * TX completion for same end point with any error code in 'status'?
+	 */
+#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
+	if(!is_in && status == 0)
+	{
+		ACQUIRE_TX_REQ_LIST_LOCK();
+
+		pHostTxReq = get_free_tx_req_pool_entry();
+		if(pHostTxReq == NULL)
+		{
+			/* NOTE: SHOULD NEVER COME HERE */
+			WARN("ERR: get_free_tx_req_pool_entry() - no free entries available\n");
+		}
+
+		pHostTxReq->pUrb	= urb;
+		pHostTxReq->pEnd	= ep;
+		pHostTxReq->status = status;
+
+		if(list_empty(&tx_completion_list))	/* check if list is empty */
+			listEmpty = 1;
+
+		/* add the request in list at the end */
+		list_add_tail(&pHostTxReq->node, &tx_completion_list);
+
+		RELEASE_TX_REQ_LIST_LOCK();
+
+		/* notify the thread if the entry was added in empty list */
+		if(listEmpty)
+			up(&semTxListEmpty);
+		return;
+	}
+
+#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
+	spin_lock(&urb->lock);
+	urbStatus = urb->status;
+	spin_unlock(&urb->lock);
+
+	if(!is_in && status == 0 && ep->bLocalEnd && (urbStatus == -EINPROGRESS || urbStatus == 0))
+	{
+		ACQUIRE_TX_REQ_LIST_LOCK();
+
+		pHostTxReq = get_free_tx_req_pool_entry();
+		if(pHostTxReq == NULL)
+		{
+			/* NOTE: SHOULD NEVER COME HERE */
+			WARN("ERR: get_free_tx_req_pool_entry() - no free entries available\n");
+		}
+
+		pHostTxReq->pUrb	= urb;
+		pHostTxReq->pEnd	= ep;
+		pHostTxReq->status = status;
+
+		/* add the request in list at the end */
+		list_add_tail(&pHostTxReq->node, &tx_completion_list);
+
+		/* schedule the tasklet */
+		tasklet_schedule(&host_tx_completion_tasklet);
+
+		RELEASE_TX_REQ_LIST_LOCK();
+
+		return;
+	}
+#endif
+
+#endif /* HOST_TX_DMA_SOLUTION */
+
 	/* save toggle eagerly, for paranoia */
 	switch (type) {
 	case PIPE_BULK:
@@ -426,8 +858,19 @@ static void
 musb_advance_urb_queue(struct musb *pThis, struct urb *urb,
 		struct musb_hw_ep *pEnd, int is_in)
 {
+#if HOST_TX_DMA_SOLUTION == 2
+	int urbStatus = 0;
+#endif
 	if (urb)
+	{
 		musb_giveback(pEnd, urb, 0);
+#ifdef HOST_TX_DMA_SOLUTION
+		spin_lock(&urb->lock);
+		urbStatus = urb->status;
+		spin_unlock(&urb->lock);
+		if(!is_in && pEnd->bLocalEnd && (urbStatus == -EINPROGRESS || urbStatus == 0)) return;
+#endif /* HOST_TX_DMA_SOLUTION */
+	}
 	if (!list_empty(&pEnd->urb_list)) {
 		DBG(4, "... next ep%d %cX urb %p\n",
 				pEnd->bLocalEnd, is_in ? 'R' : 'T',
@@ -523,7 +966,10 @@ static void musb_ep_program(struct musb 
 			       struct urb *pUrb, unsigned int is_out,
 			       u8 * pBuffer, u32 dwLength)
 {
-	u16 wCsr, wLoadCount, wIntrTxE;
+	u16 wCsr, wLoadCount;
+#ifndef HOST_TX_DMA_SOLUTION
+	u16 wIntrTxE;
+#endif
 	struct usb_device *pParent;
 #ifndef	CONFIG_USB_INVENTRA_FIFO
 	struct dma_controller *pDmaController;
@@ -679,9 +1125,11 @@ static void musb_ep_program(struct musb 
 	/* OUT/transmit or IN/receive? */
 	if (is_out) {
 		/* transmit */
+#ifndef HOST_TX_DMA_SOLUTION
 		/* disable interrupt in case we flush */
 		wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << bEnd));
+#endif
 		if (bEnd) {
 
 			// REVISIT assert(bIsReady) earlier
@@ -847,8 +1295,10 @@ static void musb_ep_program(struct musb 
 
 		}
 
+#ifndef HOST_TX_DMA_SOLUTION
 		/* re-enable interrupt */
 		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
+#endif
 
 	/* IN/receive */
 	} else {
@@ -1226,7 +1676,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 
 		/* start next URB that might be queued for it */
 		musb_advance_urb_queue(pThis, pUrb, pEnd,
-				usb_pipein(pUrb->pipe));
+				USB_DIR_IN);
 		goto done;
 	}
 
@@ -1331,7 +1781,6 @@ void musb_host_tx(struct musb *pThis, u8
 // SCRUB (TX)
 		wTxCsrVal &= ~(MGC_M_TXCSR_FIFONOTEMPTY
 				| MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAENAB
 				| MGC_M_TXCSR_H_ERROR
 				| MGC_M_TXCSR_H_RXSTALL
 				| MGC_M_TXCSR_H_NAKTIMEOUT
@@ -1905,7 +2354,6 @@ static int musb_cleanup_urb(struct urb *
 		csr &= ~( MGC_M_RXCSR_AUTOCLEAR
 			| MGC_M_RXCSR_H_AUTOREQ
 			| MGC_M_RXCSR_H_REQPKT
-			| MGC_M_RXCSR_DMAENAB
 			| MGC_M_RXCSR_H_RXSTALL
 			| MGC_M_RXCSR_DATAERROR
 			| MGC_M_RXCSR_H_ERROR
@@ -1918,7 +2366,6 @@ static int musb_cleanup_urb(struct urb *
 // SCRUB (TX)
 		csr = MGC_ReadCsr16(regs, MGC_O_HDRC_TXCSR, hw_end);
 		csr &= ~( MGC_M_TXCSR_AUTOSET
-			| MGC_M_TXCSR_DMAENAB
 			| MGC_M_TXCSR_H_RXSTALL
 			| MGC_M_TXCSR_H_NAKTIMEOUT
 			| MGC_M_TXCSR_H_ERROR
Index: linux-2.6.10/drivers/usb/musb/musb_host.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_host.h
+++ linux-2.6.10/drivers/usb/musb/musb_host.h
@@ -80,6 +80,47 @@ struct musb_sched_node {
 	struct musb_sched_node	*next;		/* for periodic tree */
 };
 
+#if defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA)
+#define	HOST_TX_DMA_SOLUTION 2	/* Host TX DMA completion solution: tasklet */
+
+extern struct list_head 	tx_completion_list;
+
+#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
+
+#ifndef CONFIG_PREEMPT_RT
+extern spinlock_t			txReqListLock;
+
+#define	ACQUIRE_TX_REQ_LIST_LOCK()	spin_lock(&txReqListLock)
+#define	RELEASE_TX_REQ_LIST_LOCK()	spin_unlock(&txReqListLock)
+
+#else
+extern struct semaphore		txReqListLock;
+
+#define	ACQUIRE_TX_REQ_LIST_LOCK()	down(&txReqListLock)
+#define	RELEASE_TX_REQ_LIST_LOCK()	up(&txReqListLock)
+
+#endif /* CONFIG_PREEMPT_RT */
+
+extern struct completion	hostTxThreadNotify;
+
+#elif HOST_TX_DMA_SOLUTION == 2	/* Tasklet based solution */
+
+#ifndef CONFIG_PREEMPT_RT
+extern spinlock_t			txReqListLock;
+
+#define	ACQUIRE_TX_REQ_LIST_LOCK()	spin_lock_irq(&txReqListLock)
+#define	RELEASE_TX_REQ_LIST_LOCK()	spin_unlock_irq(&txReqListLock)
+
+#else
+extern struct semaphore		txReqListLock;
+
+#define	ACQUIRE_TX_REQ_LIST_LOCK()	down(&txReqListLock)
+#define	RELEASE_TX_REQ_LIST_LOCK()	up(&txReqListLock)
+
+#endif /* CONFIG_PREEMPT_RT */
+
+#endif
+#endif /* defined(CONFIG_USB_MUSB_HDRC_HCD) && defined(CONFIG_USB_TI_CPPI_DMA) */
 
 extern void MGC_HdrcStartTx(struct musb *, u8 bEnd);
 
Index: linux-2.6.10/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.10/drivers/usb/musb/musbdefs.h
@@ -102,7 +102,7 @@ struct musb_ep;
 #define	is_peripheral_capable()	(1)
 
 extern irqreturn_t musb_g_ep0_irq(struct musb *);
-extern void musb_g_tx(struct musb *, u8);
+extern void musb_g_tx(struct musb *, u8, u8);
 extern void musb_g_rx(struct musb *, u8);
 extern void musb_g_reset(struct musb *);
 extern void musb_g_suspend(struct musb *);
@@ -114,7 +114,7 @@ extern void musb_g_disconnect(struct mus
 #define	is_peripheral_capable()	(0)
 
 static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_g_tx(struct musb *m, u8 e) {}
+static inline void musb_g_tx(struct musb *m, u8 e, u8 i) {}
 static inline void musb_g_rx(struct musb *m, u8 e) {}
 static inline void musb_g_reset(struct musb *m) {}
 static inline void musb_g_suspend(struct musb *m) {}
@@ -425,6 +425,7 @@ struct musb {
 #endif
 
 	struct dma_controller	*pDmaController;
+	u64			*old_dma_mask; /* added for use_dma module param */
 
 	struct device		*controller;
 	void __iomem		*ctrl_base;
Index: linux-2.6.10/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.10/drivers/usb/musb/plat_uds.c
@@ -620,8 +620,9 @@ void musb_start(struct musb * pThis)
 	musb_writeb(pBase, MGC_O_HDRC_TESTMODE, 0);
 
 	/* enable high-speed/low-power and start session */
+	/* also set MGC_M_POWER_ENSUSPEND, fix the USB attach issue */
 	musb_writeb(pBase, MGC_O_HDRC_POWER,
-		   MGC_M_POWER_SOFTCONN | MGC_M_POWER_HSENAB);
+		   MGC_M_POWER_SOFTCONN | MGC_M_POWER_HSENAB | MGC_M_POWER_ENSUSPEND);
 
 	switch (pThis->board_mode) {
 	case MUSB_HOST:
@@ -1377,7 +1378,7 @@ irqreturn_t musb_interrupt(struct musb *
 			if (devctl & MGC_M_DEVCTL_HM)
 				musb_host_tx(musb, ep_num);
 			else
-				musb_g_tx(musb, ep_num);
+				musb_g_tx(musb, ep_num, 1);
 		}
 		reg >>= 1;
 		ep_num++;
@@ -1426,7 +1427,7 @@ static int musb_dma_completion(void *pPr
 			if (devctl & MGC_M_DEVCTL_HM)
 				musb_host_tx(pThis, bLocalEnd);
 			else
-				musb_g_tx(pThis, bLocalEnd);
+				musb_g_tx(pThis, bLocalEnd, 0);
 		} else {
 			/* receive */
 			if (devctl & MGC_M_DEVCTL_HM)
@@ -1600,6 +1601,10 @@ musb_init_controller(struct device *dev,
 	}
 
 
+	/* Hack for now and save the value here
+	   so that we can use the use_dma module param */
+	pThis->old_dma_mask = dev->dma_mask;
+
 	/* ideally this would be abstracted in platform setup */
 	if (!is_dma_capable() || !pThis->pDmaController)
 		dev->dma_mask = NULL;
@@ -1724,6 +1729,9 @@ musb_init_controller(struct device *dev,
 			(musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
 					& MGC_M_DEVCTL_BDEVICE
 				? 'B' : 'A'));
+#if HOST_TX_DMA_SOLUTION == 1
+		complete(&hostTxThreadNotify);
+#endif
 		break;
 #endif
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -1792,6 +1800,10 @@ static int __exit musb_remove(struct dev
 	 *  - Peripheral mode: peripheral is deactivated (or never-activated)
 	 *  - OTG mode: both roles are deactivated (or never-activated)
 	 */
+
+	// restore old value of dma_mask
+	dev->dma_mask = musb->old_dma_mask;
+
 	musb_shutdown(musb->controller);
 	musb_debug_delete("driver/musb_hdrc", musb);
 	musb_free(musb);
@@ -1894,6 +1906,27 @@ static int __init musb_init(void)
 #endif
 	       " [debug=%d]\n",
 	       musb_driver_name, MGC_GetDebugLevel());
+
+#ifdef HOST_TX_DMA_SOLUTION
+
+	/* Initialize the host tx completion list head */
+	INIT_LIST_HEAD(&tx_completion_list);
+#ifdef CONFIG_PREEMPT_RT
+	sema_init(&txReqListLock, 1); /* semaphore is available initially */
+#endif
+
+#if HOST_TX_DMA_SOLUTION == 1	/* Kernel thread based solution */
+
+	init_completion(&hostTxThreadNotify);
+
+	/* start the kernel thread to process host tx completion */
+	if (kernel_thread(musb_host_tx_completion_thread, NULL, CLONE_KERNEL) < 0)
+		return 0;
+
+#endif
+
+#endif
+
 	return driver_register(&musb_driver);
 }
 
Index: linux-2.6.10/drivers/usb/musb/virthub.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/virthub.c
+++ linux-2.6.10/drivers/usb/musb/virthub.c
@@ -655,9 +655,9 @@ fakeit:
 /* Implementation */
 int MGC_VirtualHubUnlinkUrb(struct virtual_root *pHub, struct urb *pUrb)
 {
-	unsigned long	flags;
+	//unsigned long	flags;
 
-	spin_lock_irqsave(&pHub->Lock, flags);
+	//spin_lock_irqsave(&pHub->Lock, flags);
 	if (pUrb && (pHub->pUrb == pUrb) && (pUrb->hcpriv == pHub)) {
 		/* NOTE:  this path should support usb_kill_urb()... */
 		pUrb->status = -ECONNRESET;
@@ -667,7 +667,7 @@ int MGC_VirtualHubUnlinkUrb(struct virtu
 		usb_put_urb(pUrb);
 	}
 
-	spin_unlock_irqrestore(&pHub->Lock, flags);
+	//spin_unlock_irqrestore(&pHub->Lock, flags);
 	return 0;
 }
 
@@ -695,6 +695,10 @@ static inline void musb_port_speed(struc
 
 static void musb_port_reset_done(struct virtual_root *pHub, u8 bHubSpeed)
 {
+	//unsigned long	flags;
+
+	//spin_lock_irqsave(&pHub->Lock, flags);
+
 	DBG(4, "port %d reset complete\n", 0);
 	musb_port_speed(pHub, bHubSpeed);
 
@@ -704,6 +708,8 @@ static void musb_port_reset_done(struct 
 		USB_PORT_STAT_ENABLE;
 	pHub->aPortStatusChange[0].wChange =
 		USB_PORT_STAT_C_RESET | USB_PORT_STAT_C_ENABLE;
+
+	//spin_unlock_irqrestore(&pHub->Lock, flags);
 }
 
 /*
Index: linux-2.6.10/drivers/usb/musb/musb_gadget.h
===================================================================
--- linux-2.6.10.orig/drivers/usb/musb/musb_gadget.h
+++ linux-2.6.10/drivers/usb/musb/musb_gadget.h
@@ -91,7 +91,7 @@ static inline struct usb_request *next_r
 	return container_of(queue->next, struct usb_request, list);
 }
 
-extern void musb_g_tx(struct musb *pThis, u8 bEnd);
+extern void musb_g_tx(struct musb *pThis, u8 bEnd, u8 is_ep_intr);
 extern void musb_g_rx(struct musb *pThis, u8 bEnd);
 
 extern struct usb_ep_ops musb_g_ep0_ops;
Index: linux-2.6.10/mvl_patches/pro-1015.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1015.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1015);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

