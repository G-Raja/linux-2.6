#! /usr/bin/env bash
# Patch: -pro_arm_davinci_spi_driver
# Date: Mon Jan 21 23:04:43 2008
# Source: MontaVista Software, Inc. and Texas Instruments Inc.
# MR: 25639
# Type: Enhancement
# Disposition: local
# Signed-off-by: Steve Chen <schen@mvista.com>
# Description:
# 
# Add in SPI support for DM355 and DM6467.  This SPI driver include both 
# bitbang and DMA modes (DM6467 only as DM355 does not have SPI DMA 
# capabilities).  Also, there is an SPI EEPROM attached in the SPI bus.  
# The SPI EEPROM slave driver is at at25xxA_eeprom.c.  The implementation
# should be generic enough to extend to other SPI EEPROM.
# 
# Generic files include:
# 
# drivers/spi/Makefile
# drivers/spi/Kconfig
# drivers/mtd/devices/Makefile
# include/linux/spi/spi.h
# 
# 
# DaVinci specific files include:
# drivers/spi/davinci_spi_bitbang.c
# drivers/spi/davinci_spi_master.c
# drivers/spi/loopback_spi.c
# drivers/spi/loopback_spi.h
# include/linux/spi/at25xxA_eeprom.h
# include/linux/spi/davinci_spi_bitbang.h
# include/linux/spi/davinci_spi.h
# include/linux/spi/davinci_spi_master.h
# include/linux/spi/eeprom.h
# drivers/mtd/devices/at25xxA_eeprom.c
# arch/arm/mach-davinci/davinci_spi_platform.c
# 
# Please note that arch/arm/mach-davinci/Makefile is not in this patch.
# The Makefile will be in the arch specific update for DM6467.
# 
# Lastly, this patch combines all the SPI code change into a single patch.  
# It contains the sum total of all the bug fixes, variable name and file name 
# changes of all the SPI patches Jerry sent out.  The patches obsolete are
# 
# pro_arm_davinci_dm355-spi.patch
# pro_arm_davinci_spi.patch
# pro_arm_davinci_spi_dma_fix.patch
# pro_arm_davinci_dm355_spi_unify_fix.patch
# pro_arm_davinci_spi_change_dm355_to_davinci.patch
# pro_arm_davinci_mach-spi-sync.patch
# pro_arm_davinci_drivers-spi-sync-100407.patch
# p080-gem-blocking-fix.patch
# 

PATCHNUM=1663
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. and Texas Instruments Inc.
MR: 25639
Type: Enhancement
Disposition: local
Signed-off-by: Steve Chen <schen@mvista.com>
Description:

Add in SPI support for DM355 and DM6467.  This SPI driver include both 
bitbang and DMA modes (DM6467 only as DM355 does not have SPI DMA 
capabilities).  Also, there is an SPI EEPROM attached in the SPI bus.  
The SPI EEPROM slave driver is at at25xxA_eeprom.c.  The implementation
should be generic enough to extend to other SPI EEPROM.

Generic files include:

drivers/spi/Makefile
drivers/spi/Kconfig
drivers/mtd/devices/Makefile
include/linux/spi/spi.h


DaVinci specific files include:
drivers/spi/davinci_spi_bitbang.c
drivers/spi/davinci_spi_master.c
drivers/spi/loopback_spi.c
drivers/spi/loopback_spi.h
include/linux/spi/at25xxA_eeprom.h
include/linux/spi/davinci_spi_bitbang.h
include/linux/spi/davinci_spi.h
include/linux/spi/davinci_spi_master.h
include/linux/spi/eeprom.h
drivers/mtd/devices/at25xxA_eeprom.c
arch/arm/mach-davinci/davinci_spi_platform.c

Please note that arch/arm/mach-davinci/Makefile is not in this patch.
The Makefile will be in the arch specific update for DM6467.

Lastly, this patch combines all the SPI code change into a single patch.  
It contains the sum total of all the bug fixes, variable name and file name 
changes of all the SPI patches Jerry sent out.  The patches obsolete are

pro_arm_davinci_dm355-spi.patch
pro_arm_davinci_spi.patch
pro_arm_davinci_spi_dma_fix.patch
pro_arm_davinci_dm355_spi_unify_fix.patch
pro_arm_davinci_spi_change_dm355_to_davinci.patch
pro_arm_davinci_mach-spi-sync.patch
pro_arm_davinci_drivers-spi-sync-100407.patch
p080-gem-blocking-fix.patch

Index: linux-2.6.10/drivers/spi/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/spi/Makefile
+++ linux-2.6.10/drivers/spi/Makefile
@@ -11,6 +11,9 @@ endif
 obj-$(CONFIG_SPI_MASTER)		+= spi.o
 
 # SPI master controller drivers (bus)
+obj-$(CONFIG_SPI_DAVINCI)               += davinci_spi_master.o
+obj-$(CONFIG_SPI_DAVINCI_BITBANG)       += davinci_spi_bitbang.o
+
 obj-$(CONFIG_SPI_BITBANG)		+= spi_bitbang.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
 obj-$(CONFIG_SPI_VR)			+= vr_spi.o
Index: linux-2.6.10/drivers/spi/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/spi/Kconfig
+++ linux-2.6.10/drivers/spi/Kconfig
@@ -51,6 +51,29 @@ config SPI_MASTER
 comment "SPI Master Controller Drivers"
 	depends on SPI_MASTER
 
+config SPI_DAVINCI_BITBANG
+	tristate "SPI bitbang driver for DaVinci SoC"
+	depends on SPI_MASTER && (ARCH_DAVINCI_DM646x || ARCH_DAVINCI_DM355)
+        default y
+        help
+          SPI bitbang driver for DaVinci MibSPI modules.
+
+config SPI_DAVINCI
+        tristate "SPI controller driver for DaVinci SoC"
+	depends on SPI_MASTER && (ARCH_DAVINCI_DM646x || ARCH_DAVINCI_DM355)
+        default y
+        help
+	  SPI master controller for DaVinci MibSPI modules.  Currently,
+	  SPI is only officially supported for DM646x and DM355.
+
+config SPI_DAVINCI_DMA
+        bool "Set DaVinci SPI to DMA mode"
+	depends on SPI_DAVINCI
+	default y
+        help
+          Select this option to set DaVinci SPI to DMA mode, deselect
+	  to put in PIO mode.
+
 config SPI_BITBANG
 	tristate "Bitbanging SPI master"
 	depends on SPI_MASTER && EXPERIMENTAL
@@ -86,6 +109,13 @@ config SPI_VR
 # Add new SPI master controllers in alphabetical order above this line
 #
 
+config DAVINCI_SPI_EEPROM
+        tristate "DaVinci SPI EEPROM"
+        depends on SPI_DAVINCI
+        default y
+        help
+          This enables the SPI EEPROM client for TI DaVinci
+
 
 #
 # There are lots of SPI device types, with sensors and memory
Index: linux-2.6.10/drivers/mtd/devices/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/devices/Makefile
+++ linux-2.6.10/drivers/mtd/devices/Makefile
@@ -25,3 +25,5 @@ obj-$(CONFIG_MTD_BLKMTD)	+= blkmtd.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_RAMTD)		+= ramtd.o
 obj-$(CONFIG_MTD_ICH7_SPI_FLASH)+= ich7_spi_flash.o
+obj-$(CONFIG_DAVINCI_SPI_EEPROM)+= at25xxA_eeprom.o
+
Index: linux-2.6.10/include/linux/spi/spi.h
===================================================================
--- linux-2.6.10.orig/include/linux/spi/spi.h
+++ linux-2.6.10/include/linux/spi/spi.h
@@ -65,6 +65,7 @@ struct spi_device {
 #define	SPI_MODE_2	(SPI_CPOL|0)
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
+#define	SPI_LSB_FIRST   0x08		/* per-word bits-on-wire */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
@@ -323,7 +324,9 @@ struct spi_transfer {
 	dma_addr_t	rx_dma;
 
 	unsigned	cs_change:1;
+	u8		bits_per_word;
 	u16		delay_usecs;
+	u32		speed_hz;
 
 	struct list_head transfer_list;
 };
@@ -639,6 +642,8 @@ struct spi_board_info {
 	u16		bus_num;
 	u16		chip_select;
 
+	u8		mode;
+
 	/* ... may need additional spi_device chip config data here.
 	 * avoid stuff protocol drivers can set; but include stuff
 	 * needed to behave without being bound to a driver:
Index: linux-2.6.10/drivers/spi/davinci_spi_bitbang.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/spi/davinci_spi_bitbang.c
@@ -0,0 +1,527 @@
+/*
+ * polling/bitbanging TI davinci SPI master controller driver utilities
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+
+#include <linux/device.h>
+
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/davinci_spi_bitbang.h>
+
+#if defined(CONFIG_SPI_DEBUG)
+#define DEBUG_BB(fmt, arg...)  printk(KERN_EMERG fmt , ##arg);
+#else
+#define DEBUG_BB(fmt, arg...)
+#endif
+
+#define ENTER DEBUG_BB("[Ei %s-%d] \n", __FUNCTION__, __LINE__);
+#define EXIT  DEBUG_BB("[Ex %s-%d] \n", __FUNCTION__, __LINE__);
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * FIRST PART (OPTIONAL):  word-at-a-time spi_transfer support.
+ * Use this for GPIO or shift-register level hardware APIs.
+ *
+ * spi_bitbang_cs is in spi_device->controller_state, which is unavailable
+ * to glue code.  These bitbang setup() and cleanup() routines are always
+ * used, though maybe they're called from controller-aware code.
+ *
+ * chipselect() and friends may use use spi_device->controller_data and
+ * controller registers as appropriate.
+ *
+ *
+ * NOTE:  SPI controller pins can often be used as GPIO pins instead,
+ * which means you could use a bitbang driver either to get hardware
+ * working quickly, or testing for differences that aren't speed related.
+ */
+
+struct spi_bitbang_cs {
+	unsigned nsecs;		/* (clock cycle time)/2 */
+	 u32(*txrx_word) (struct spi_device *spi, unsigned nsecs,
+			  u32 word, u8 bits);
+	unsigned (*txrx_bufs) (struct spi_device *,
+			       u32(*txrx_word) (struct spi_device *spi,
+						unsigned nsecs,
+						u32 word, u8 bits),
+			       unsigned, struct spi_transfer *);
+};
+
+static unsigned bitbang_txrx_8(struct spi_device *spi,
+			       u32(*txrx_word) (struct spi_device *spi,
+						unsigned nsecs,
+						u32 word, u8 bits),
+			       unsigned ns, struct spi_transfer *t)
+{
+	unsigned bits = spi->bits_per_word;
+	unsigned count = t->len;
+	const u8 *tx = t->tx_buf;
+	u8 *rx = t->rx_buf;
+
+	while (likely(count > 0)) {
+		u8 word = 0;
+
+		if (tx)
+			word = *tx++;
+		word = txrx_word(spi, ns, word, bits);
+		if (rx)
+			*rx++ = word;
+		count -= 1;
+	}
+	return t->len - count;
+}
+
+static unsigned bitbang_txrx_16(struct spi_device *spi,
+				u32(*txrx_word) (struct spi_device *spi,
+						 unsigned nsecs,
+						 u32 word, u8 bits),
+				unsigned ns, struct spi_transfer *t)
+{
+	unsigned bits = spi->bits_per_word;
+	unsigned count = t->len;
+	const u16 *tx = t->tx_buf;
+	u16 *rx = t->rx_buf;
+
+	while (likely(count > 1)) {
+		u16 word = 0;
+
+		if (tx)
+			word = *tx++;
+		word = txrx_word(spi, ns, word, bits);
+		if (rx)
+			*rx++ = word;
+		count -= 2;
+	}
+	return t->len - count;
+}
+
+int davinci_spi_bitbang_setup_transfer(struct spi_device *spi,
+				       struct spi_transfer *t)
+{
+	struct spi_bitbang_cs *cs = spi->controller_state;
+	u8 bits_per_word;
+	u32 hz;
+
+	ENTER
+	if (t) {
+		bits_per_word = t->bits_per_word;
+		hz = t->speed_hz;
+	} else {
+		bits_per_word = 0;
+		hz = 0;
+	}
+
+	/* spi_transfer level calls that work per-word */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+	if (bits_per_word <= 8 && bits_per_word >= 2) {
+		cs->txrx_bufs = bitbang_txrx_8;
+		DEBUG_BB("word = %d\n", bits_per_word);
+	} else if (bits_per_word <= 16 && bits_per_word >= 2) {
+		cs->txrx_bufs = bitbang_txrx_16;
+		DEBUG_BB("word = %d\n", bits_per_word);
+	}
+	/*else if (bits_per_word <= 32)
+	   cs->txrx_bufs = bitbang_txrx_32; */
+	else
+		return -EINVAL;
+
+	/* nsecs = (clock period)/2 */
+	if (!hz)
+		hz = spi->max_speed_hz;
+	if (hz) {
+		cs->nsecs = (1000000000 / 2) / hz;
+		if (cs->nsecs > (MAX_UDELAY_MS * 1000 * 1000))
+			return -EINVAL;
+	}
+	EXIT
+	return 0;
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_setup_transfer);
+
+/**
+ * davinci_spi_bitbang_setup - default setup for per-word I/O loops
+ */
+int davinci_spi_bitbang_setup(struct spi_device *spi)
+{
+	struct spi_bitbang_cs *cs = spi->controller_state;
+	struct spi_bitbang *bitbang;
+	int retval;
+
+	bitbang = spi_master_get_devdata(spi->master);
+
+	/* REVISIT: some systems will want to support devices using lsb-first
+	 * bit encodings on the wire.  In pure software that would be trivial,
+	 * just bitbang_txrx_le_cphaX() routines shifting the other way, and
+	 * some hardware controllers also have this support.
+	 */
+	if ((spi->mode & SPI_LSB_FIRST) != 0)
+		return -EINVAL;
+
+	if (!cs) {
+		cs = kzalloc(sizeof *cs, SLAB_KERNEL);
+		if (!cs)
+			return -ENOMEM;
+		spi->controller_state = cs;
+	}
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	/* per-word shift register access, in hardware or bitbanging */
+	cs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL | SPI_CPHA)];
+	if (!cs->txrx_word)
+		return -EINVAL;
+
+	retval = davinci_spi_bitbang_setup_transfer(spi, NULL);
+	if (retval < 0)
+		return retval;
+
+	dev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u nsec/bit\n",
+		__FUNCTION__, spi->mode & (SPI_CPOL | SPI_CPHA),
+		spi->bits_per_word, 2 * cs->nsecs);
+
+	/* NOTE we _need_ to call chipselect() early, ideally with adapter
+	 * setup, unless the hardware defaults cooperate to avoid confusion
+	 * between normal (active low) and inverted chipselects.
+	 */
+
+	/* deselect chip (low or high) */
+	spin_lock(&bitbang->lock);
+	if (!bitbang->busy) {
+		bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
+		ndelay(cs->nsecs);
+	}
+	spin_unlock(&bitbang->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_setup);
+
+/**
+ * davinci_spi_bitbang_cleanup - default cleanup for per-word I/O loops
+ */
+void davinci_spi_bitbang_cleanup(const struct spi_device *spi)
+{
+	kfree(spi->controller_state);
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_cleanup);
+
+static int davinci_spi_bitbang_bufs(struct spi_device *spi,
+				    struct spi_transfer *t)
+{
+	struct spi_bitbang_cs *cs = spi->controller_state;
+	unsigned nsecs = cs->nsecs;
+
+	return cs->txrx_bufs(spi, cs->txrx_word, nsecs, t);
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * SECOND PART ... simple transfer queue runner.
+ *
+ * This costs a task context per controller, running the queue by
+ * performing each transfer in sequence.  Smarter hardware can queue
+ * several DMA transfers at once, and process several controller queues
+ * in parallel; this driver doesn't match such hardware very well.
+ *
+ * Drivers can provide word-at-a-time i/o primitives, or provide
+ * transfer-at-a-time ones to leverage dma or fifo hardware.
+ */
+static void davinci_bitbang_work(void *_bitbang)
+{
+	struct spi_bitbang *bitbang = _bitbang;
+	unsigned long flags;
+
+	ENTER
+	spin_lock_irqsave(&bitbang->lock, flags);
+	bitbang->busy = 1;
+	while (!list_empty(&bitbang->queue)) {
+		struct spi_message *m;
+		struct spi_device *spi;
+		unsigned nsecs;
+		struct spi_transfer *t = NULL;
+		unsigned tmp;
+		unsigned cs_change;
+		int status;
+		int (*setup_transfer) (struct spi_device *,
+				       struct spi_transfer *);
+
+		m = container_of(bitbang->queue.next, struct spi_message,
+				 queue);
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&bitbang->lock, flags);
+
+		/* FIXME this is made-up ... the correct value is known to
+		 * word-at-a-time bitbang code, and presumably chipselect()
+		 * should enforce these requirements too?
+		 */
+		nsecs = 100;
+
+		spi = m->spi;
+		tmp = 0;
+		cs_change = 1;
+		status = 0;
+		setup_transfer = NULL;
+
+		list_for_each_entry(t, &m->transfers, transfer_list) {
+			if (bitbang->shutdown) {
+				status = -ESHUTDOWN;
+				break;
+			}
+
+			/* override or restore speed and wordsize */
+			if (t->speed_hz || t->bits_per_word) {
+				setup_transfer = bitbang->setup_transfer;
+				if (!setup_transfer) {
+					status = -ENOPROTOOPT;
+					break;
+				}
+			}
+			if (setup_transfer) {
+				DEBUG_BB("setup_transfer is being called\n");
+				status = setup_transfer(spi, t);
+				if (status < 0)
+					break;
+			}
+
+			/* set up default clock polarity, and activate chip;
+			 * this implicitly updates clock and spi modes as
+			 * previously recorded for this device via setup().
+			 * (and also deselects any other chip that might be
+			 * selected ...)
+			 */
+			if (cs_change) {
+				bitbang->chipselect(spi, BITBANG_CS_ACTIVE);
+				ndelay(nsecs);
+			}
+			cs_change = t->cs_change;
+			if (!t->tx_buf && !t->rx_buf && t->len) {
+				status = -EINVAL;
+				break;
+			}
+
+			/* transfer data.  the lower level code handles any
+			 * new dma mappings it needs. our caller always gave
+			 * us dma-safe buffers.
+			 */
+			if (t->len) {
+				/* REVISIT dma API still needs a designated
+				 * DMA_ADDR_INVALID; ~0 might be better.
+				 */
+				if (!m->is_dma_mapped)
+					t->rx_dma = t->tx_dma = 0;
+				DEBUG_BB("bitbang->txrx_bufs called\n");
+				status = bitbang->txrx_bufs(spi, t);
+			}
+			if (status != t->len) {
+				if (status > 0)
+					status = -EMSGSIZE;
+				break;
+			}
+			m->actual_length += status;
+			status = 0;
+
+			/* protocol tweaks before next transfer */
+			if (t->delay_usecs)
+				udelay(t->delay_usecs);
+
+			if (!cs_change)
+				continue;
+			if (t->transfer_list.next == &m->transfers)
+				break;
+
+			/* sometimes a short mid-message deselect of the chip
+			 * may be needed to terminate a mode or command
+			 */
+			ndelay(nsecs);
+			bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
+			ndelay(nsecs);
+		}
+
+		m->status = status;
+		m->complete(m->context);
+
+		/* restore speed and wordsize */
+		if (setup_transfer)
+			setup_transfer(spi, NULL);
+
+		/* normally deactivate chipselect ... unless no error and
+		 * cs_change has hinted that the next message will probably
+		 * be for this chip too.
+		 */
+		if (!(status == 0 && cs_change)) {
+			ndelay(nsecs);
+			bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
+			ndelay(nsecs);
+		}
+
+		spin_lock_irqsave(&bitbang->lock, flags);
+	}
+	bitbang->busy = 0;
+	spin_unlock_irqrestore(&bitbang->lock, flags);
+}
+
+/**
+ * davinci_spi_bitbang_transfer - default submit to transfer queue
+ */
+int davinci_spi_bitbang_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_bitbang *bitbang;
+	unsigned long flags;
+	int status = 0;
+
+	ENTER
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	bitbang = spi_master_get_devdata(spi->master);
+	if (bitbang->shutdown)
+		return -ESHUTDOWN;
+
+	spin_lock_irqsave(&bitbang->lock, flags);
+	if (!spi->max_speed_hz)
+		status = -ENETDOWN;
+	else {
+		list_add_tail(&m->queue, &bitbang->queue);
+		queue_work(bitbang->workqueue, &bitbang->work);
+	}
+	spin_unlock_irqrestore(&bitbang->lock, flags);
+
+	EXIT
+	return status;
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_transfer);
+
+/*----------------------------------------------------------------------*/
+
+/**
+ * davinci_spi_bitbang_start - start up a polled/bitbanging SPI master driver
+ * @bitbang: driver handle
+ *
+ * Caller should have zero-initialized all parts of the structure, and then
+ * provided callbacks for chip selection and I/O loops.  If the master has
+ * a transfer method, its final step should call spi_bitbang_transfer; or,
+ * that's the default if the transfer routine is not initialized.  It should
+ * also set up the bus number and number of chipselects.
+ *
+ * For i/o loops, provide callbacks either per-word (for bitbanging, or for
+ * hardware that basically exposes a shift register) or per-spi_transfer
+ * (which takes better advantage of hardware like fifos or DMA engines).
+ *
+ * Drivers using per-word I/O loops should use (or call) spi_bitbang_setup and
+ * spi_bitbang_cleanup to handle those spi master methods.  Those methods are
+ * the defaults if the bitbang->txrx_bufs routine isn't initialized.
+ *
+ * This routine registers the spi_master, which will process requests in a
+ * dedicated task, keeping IRQs unblocked most of the time.  To stop
+ * processing those requests, call spi_bitbang_stop().
+ */
+int davinci_spi_bitbang_start(struct spi_bitbang *bitbang)
+{
+	int status;
+
+	if (!bitbang->master || !bitbang->chipselect)
+		return -EINVAL;
+
+	INIT_WORK(&bitbang->work, davinci_bitbang_work, bitbang);
+	spin_lock_init(&bitbang->lock);
+	INIT_LIST_HEAD(&bitbang->queue);
+
+	if (!bitbang->master->transfer)
+		bitbang->master->transfer = davinci_spi_bitbang_transfer;
+	if (!bitbang->txrx_bufs) {
+		bitbang->use_dma = 0;
+		bitbang->txrx_bufs = davinci_spi_bitbang_bufs;
+		if (!bitbang->master->setup) {
+			if (!bitbang->setup_transfer)
+				bitbang->setup_transfer =
+				    davinci_spi_bitbang_setup_transfer;
+			bitbang->master->setup = davinci_spi_bitbang_setup;
+			bitbang->master->cleanup = davinci_spi_bitbang_cleanup;
+		}
+	} else if (!bitbang->master->setup)
+		return -EINVAL;
+
+	/* this task is the only thing to touch the SPI bits */
+	bitbang->busy = 0;
+
+	DEBUG_BB("bus_id = %s\n", bitbang->master->cdev.dev->bus_id);
+
+	bitbang->workqueue =
+	    create_singlethread_workqueue(bitbang->master->cdev.dev->bus_id);
+	if (bitbang->workqueue == NULL) {
+		status = -EBUSY;
+		goto err1;
+	}
+
+	/* driver may get busy before register() returns, especially
+	 * if someone registered boardinfo for devices
+	 */
+	status = spi_register_master(bitbang->master);
+	if (status < 0)
+		goto err2;
+
+	return status;
+
+err2:
+	destroy_workqueue(bitbang->workqueue);
+err1:
+	return status;
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_start);
+
+/**
+ * spi_bitbang_stop - stops the task providing spi communication
+ */
+int davinci_spi_bitbang_stop(struct spi_bitbang *bitbang)
+{
+	unsigned limit = 500;
+
+	spin_lock_irq(&bitbang->lock);
+	bitbang->shutdown = 0;
+	while (!list_empty(&bitbang->queue) && limit--) {
+		spin_unlock_irq(&bitbang->lock);
+
+		dev_dbg(bitbang->master->cdev.dev, "wait for queue\n");
+		msleep(10);
+
+		spin_lock_irq(&bitbang->lock);
+	}
+	spin_unlock_irq(&bitbang->lock);
+	if (!list_empty(&bitbang->queue)) {
+		dev_err(bitbang->master->cdev.dev, "queue didn't empty\n");
+		return -EBUSY;
+	}
+
+	destroy_workqueue(bitbang->workqueue);
+
+	spi_unregister_master(bitbang->master);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(davinci_spi_bitbang_stop);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/spi/davinci_spi_master.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/spi/davinci_spi_master.c
@@ -0,0 +1,1254 @@
+/*
+ * controller driver with Interrupt.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <linux/spi/davinci_spi_master.h>
+#include <linux/dma-mapping.h>
+#include <asm/arch/edma.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/mux.h>
+
+#if CONFIG_SPI_DAVINCI_DMA
+static unsigned use_dma = 1;
+#else
+static unsigned use_dma;
+#endif
+module_param(use_dma, uint, 0644);
+
+/* #define CONFIG_SPI_DEBUG */
+
+#if defined(CONFIG_SPI_DEBUG)
+#define DEBUG_SPI(fmt, arg...)  printk(KERN_EMERG fmt , ##arg);
+#else
+#define DEBUG_SPI(fmt, arg...)
+#endif
+
+#define ENTER DEBUG_SPI("[Ei %s-%d] \n", __FUNCTION__, __LINE__);
+#define EXIT  DEBUG_SPI("[Ex %s-%d] \n", __FUNCTION__, __LINE__);
+
+/* operating momde selection from kconfig */
+struct davinci_spi_config_t davinci_spi_config;
+
+#define davinci_SPI_RX_BUF(type) 	static inline void		  \
+davinci_spi_rx_buf_##type(u32 data, struct davinci_spi *davinci_spi)	  \
+{									  \
+	type * rx = davinci_spi->rx;					  \
+	*rx++ = (type)data;						  \
+	davinci_spi->rx = rx;						  \
+}
+
+#define davinci_SPI_TX_BUF(type)				\
+static inline u32 davinci_spi_tx_buf_##type(struct davinci_spi *davinci_spi) \
+{								\
+	u32 data;						\
+	const type * tx = davinci_spi->tx;			\
+	data = *tx++;						\
+	davinci_spi->tx = tx;					\
+	return data;						\
+}
+
+davinci_SPI_RX_BUF(u8);
+davinci_SPI_RX_BUF(u16);
+davinci_SPI_TX_BUF(u8);
+davinci_SPI_TX_BUF(u16);
+
+#define SP0_MUX_SEL_LINE \
+{ \
+davinci_cfg_reg(DM355_SPI0_SDI); \
+davinci_cfg_reg(DM355_SPI0_SDENA0); \
+davinci_cfg_reg(DM355_SPI0_SDENA1); \
+}
+
+#define SP1_MUX_SEL_LINE \
+{ \
+davinci_cfg_reg(DM355_SPI1_SCLK); \
+davinci_cfg_reg(DM355_SPI1_SDO); \
+davinci_cfg_reg(DM355_SPI1_SDENA0); \
+davinci_cfg_reg(DM355_SPI1_SDENA1); \
+}
+
+#define SP2_MUX_SEL_LINE \
+{ \
+davinci_cfg_reg(DM355_SPI2_SCLK); \
+davinci_cfg_reg(DM355_SPI2_SDO); \
+davinci_cfg_reg(DM355_SPI2_SDENA0); \
+davinci_cfg_reg(DM355_SPI2_SDENA1); \
+}
+
+#define DM355_CLEAR_RX_BUFFER(base) do { 				\
+		if (base->SPIBUF & SPI_SPIBUF_RXEMPTY_MASK)		\
+			break;						\
+		} while (1)
+
+extern void davinci_clean_channel(int);
+
+static void davinci_spi_set_dma_req(const struct spi_device *spi, int enable)
+{
+	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
+	u32 l;
+
+	l = davinci_spi->base->SPIINT;
+
+	if (enable)
+		l |= SPI_SPIINT_DMA_REQ_EN;
+	else
+		l &= ~SPI_SPIINT_DMA_REQ_EN;
+
+	davinci_spi->base->SPIINT = l;
+}
+
+/*
+ * Interface to control the chip select signal
+ */
+static void davinci_spi_chipselect(struct spi_device *spi, int value)
+{
+	struct davinci_spi *davinci_spi;
+	u32 data1_reg_val = 0;
+	ENTER
+	davinci_spi = spi_master_get_devdata(spi->master);
+	    /* board specific chip select logic decides the polarity and cs */
+	    /* line for the controller */
+	    if (value == BITBANG_CS_INACTIVE) {
+		davinci_spi->base->SPIDEF |= CS_DEFAULT;
+
+		data1_reg_val |= CS_DEFAULT << SPI_SPIDAT1_CSNR_SHIFT;
+		davinci_spi->base->SPIDAT1 = data1_reg_val;
+
+		DM355_CLEAR_RX_BUFFER(davinci_spi->base);
+	}
+	EXIT
+	return;
+}
+
+/**
+ * davinci_spi_setup_transfer - This functions will determine transfer method
+ * @spi: spi device on which data transfer to be done
+ * @t: spi transfer in which transfer info is filled
+ *
+ * This function determines data transfer method (8/16/32 bit transfer).
+ * It will also set the SPI Clock Control register according to
+ * SPI slave device freq.
+ */
+static int davinci_spi_setup_transfer(struct spi_device *spi,
+				      struct spi_transfer *t)
+{
+
+	struct davinci_spi *davinci_spi;
+	u8 bits_per_word = 0;
+	u32 hz = 0;
+	int i = 0;
+
+	ENTER
+	davinci_spi = spi_master_get_devdata(spi->master);
+
+	spi->controller_data = NULL;
+	spi->controller_data = &davinci_spi_config;
+
+	if (t) {
+		bits_per_word = t->bits_per_word;
+		hz = t->speed_hz;
+	}
+
+	/* if bits_per_word is not set then set it default */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+
+	/* Assign function pointer to appropriate transfer method */
+	/* 8bit/16bit or 32bit transfer */
+	if (bits_per_word <= 8 && bits_per_word >= 2) {
+		DEBUG_SPI("BITS PER WORD = %d\n", bits_per_word);
+		davinci_spi->get_rx = davinci_spi_rx_buf_u8;
+		davinci_spi->get_tx = davinci_spi_tx_buf_u8;
+		davinci_spi->slave[spi->chip_select].bytes_per_word = 1;
+	} else if (bits_per_word <= 16 && bits_per_word >= 2) {
+		DEBUG_SPI("BITS PER WORD = %d\n", bits_per_word);
+		davinci_spi->get_rx = davinci_spi_rx_buf_u16;
+		davinci_spi->get_tx = davinci_spi_tx_buf_u16;
+		davinci_spi->slave[spi->chip_select].bytes_per_word = 2;
+	} else
+		return ERROR;
+
+	if (!hz) {
+		hz = spi->max_speed_hz;
+		if (!hz) {
+			hz = 2000000;	/* defaulting to 2Mhz */
+			printk (KERN_INFO "[SPI] -> Slave device speed not set "
+			    "correctly. Trying with %dHz\n", hz);
+		}
+	}
+
+/**************************************************************************/
+
+	for (i = 0; i < 4; i++) {
+		davinci_spi->base->SPIFMT[i] &= ~(SPI_SPIFMT_CHARLEN_MASK);
+		davinci_spi->base->SPIFMT[i] |= bits_per_word;
+	}
+
+	EXIT
+	return 0;
+}
+
+static void davinci_spi_dma_rx_callback(int lch, u16 ch_status, void *data)
+{
+	struct spi_device *spi = (struct spi_device *)data;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
+
+	if (ch_status == DMA_COMPLETE)
+		davinci_stop_dma(davinci_spi_dma->dma_rx_channel);
+	else
+		davinci_clean_channel(davinci_spi_dma->dma_rx_channel);
+
+	complete(&davinci_spi_dma->dma_rx_completion);
+	/* We must disable the DMA RX request */
+	davinci_spi_set_dma_req(spi, 0);
+
+	DEBUG_SPI("RX DMA COMPLETE ch_status=0x%x\n", ch_status);
+}
+
+static void davinci_spi_dma_tx_callback(int lch, u16 ch_status, void *data)
+{
+	struct spi_device *spi = (struct spi_device *)data;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
+
+	if (ch_status == DMA_COMPLETE)
+		davinci_stop_dma(davinci_spi_dma->dma_tx_channel);
+	else
+		davinci_clean_channel(davinci_spi_dma->dma_tx_channel);
+
+	complete(&davinci_spi_dma->dma_tx_completion);
+	/* We must disable the DMA TX request */
+	davinci_spi_set_dma_req(spi, 0);
+
+	DEBUG_SPI("TX DMA COMPLETE ch_status=0x%x\n", ch_status);
+}
+
+static int davinci_spi_request_dma(struct spi_device *spi)
+{
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+	int tcc;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = davinci_spi->dma_channels + spi->chip_select;
+
+	if (davinci_request_dma(davinci_spi_dma->dma_rx_sync_dev, "MibSPI RX",
+				davinci_spi_dma_rx_callback, spi,
+				&davinci_spi_dma->dma_rx_channel,
+				&tcc, EVENTQ_3)) {
+		printk(KERN_ERR
+		       "Unable to request DMA channel for MibSPI RX\n");
+		return -EAGAIN;
+	}
+	if (davinci_request_dma(davinci_spi_dma->dma_tx_sync_dev, "MibSPI TX",
+				davinci_spi_dma_tx_callback, spi,
+				&davinci_spi_dma->dma_tx_channel,
+				&tcc, EVENTQ_3)) {
+		davinci_free_dma(davinci_spi_dma->dma_rx_channel);
+		davinci_spi_dma->dma_rx_channel = -1;
+		printk(KERN_ERR
+		       "Unable to request DMA channel for MibSPI TX\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/**
+ * davinci_spi_setup - This functions will set default transfer method
+ * @spi: spi device on which data transfer to be done
+ *
+ * This functions sets the default transfer method.
+ */
+
+static int davinci_spi_setup(struct spi_device *spi)
+{
+	int retval;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	ENTER
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+	/*if bits per word length is zero then set it default 8 */
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	davinci_spi->slave[spi->chip_select].cmd_to_write = 0;
+
+	if (davinci_spi_dma->dma_rx_channel == -1 ||
+	    davinci_spi_dma->dma_tx_channel == -1) {
+		retval = davinci_spi_request_dma(spi);
+		if (retval < 0)
+			return retval;
+	}
+
+	retval = davinci_spi_setup_transfer(spi, NULL);
+
+	EXIT
+	return retval;
+}
+
+static void davinci_spi_cleanup(const struct spi_device *spi)
+{
+	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+	if (davinci_spi_dma->dma_rx_channel != -1 &&
+	    davinci_spi_dma->dma_tx_channel != -1) {
+		davinci_free_dma(davinci_spi_dma->dma_tx_channel);
+		davinci_free_dma(davinci_spi_dma->dma_rx_channel);
+	}
+}
+
+/**
+ * davinci_spi_bufs - functions which will handle transfer data
+ * @spi: spi device on which data transfer to be done
+ * @t: spi transfer in which transfer info is filled
+ *
+ * This function will put data to be transferred into data register
+ * of SPI controller and then wait untill the completion will be marked
+ * by the IRQ Handler.
+ */
+#define BIT_CLEAR_TIME_OUT	10000
+
+/* #define SPI_PROFILE 1 */
+
+#ifdef SPI_PROFILE
+
+static unsigned int spi_prof_start;
+static unsigned int spi_prof_end;
+static unsigned int spi_avg_latency;
+
+#define rdtscl(dest) \
+	    __asm__ __volatile__("mfc0 %0,$9; nop" : "=r" (dest))
+
+static void calculate_spi_latency(void)
+{
+	unsigned int diff = spi_prof_end - spi_prof_start;
+
+	if (diff < 0) {
+		printk(KERN_INFO "Count register wraparound not supported.\n");
+	} else {
+		if (spi_avg_latency == 0) {
+			spi_avg_latency = diff;
+		} else {
+			spi_avg_latency += diff;
+			spi_avg_latency /= 2;
+		}
+	}
+}
+
+void spi_start_profile(void)
+{
+	rdtscl(spi_prof_start);
+}
+
+void spi_end_profile(void)
+{
+	rdtscl(spi_prof_end);
+	calculate_spi_latency();
+	DEBUG_SPI("[SPI-PROFILE] Throughput = %d\n", spi_avg_latency);
+}
+
+unsigned int spi_get_avg_latency()
+{
+	return spi_avg_latency;
+}
+#endif				/* SPI_PROFILE */
+
+static int davinci_spi_bufs_pio(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct davinci_spi *davinci_spi;
+	int i, intStatus = 0;
+	int count;
+	u8 conv = 1;
+	u8 tmp;
+	u32 tx_data = 0;
+	u32 data1_reg_val = 0;
+
+	struct davinci_spi_config_t *spi_cfg;
+	u32 sPIPC0 = 0;
+	u32 buf_val, flg_val;
+
+	ENTER
+	davinci_spi = spi_master_get_devdata(spi->master);
+
+	davinci_spi->tx = t->tx_buf;
+	davinci_spi->rx = t->rx_buf;
+
+	/* DEBUG_SPI("tx_buf value = %x\n",*(u16 *)davinci_spi->tx); */
+
+	/* convert len to words bbased on bits_per_word */
+	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
+
+	davinci_spi->count = t->len / conv;
+
+	DEBUG_SPI("chipselect=%d, bytes_per_word=%d, t->len=%d, conv=%d\n",
+		  spi->chip_select,
+		  davinci_spi->slave[spi->chip_select].bytes_per_word, t->len,
+		  conv);
+
+	INIT_COMPLETION(davinci_spi->done);
+
+	/*configuraton parameter for SPI */
+
+	spi_cfg = (struct davinci_spi_config_t *) spi->controller_data;
+
+	for (i = 0; i < 4; i++) {
+
+		if (spi_cfg->phaseIn)
+			davinci_spi->base->SPIFMT[i] |= SPI_SPIFMT_PHASE_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_PHASE_MASK);
+
+		if (spi_cfg->clkHigh)
+			davinci_spi->base->SPIFMT[i] |=
+			    SPI_SPIFMT_POLARITY_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_POLARITY_MASK);
+
+		if (spi_cfg->lsbFirst)
+			davinci_spi->base->SPIFMT[i] |=
+			    SPI_SPIFMT_SHIFTDIR_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_SHIFTDIR_MASK);
+
+	}
+
+	/*Enable SPI */
+	davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_SPIENA_MASK;
+
+	/*Clock internal */
+	if (spi_cfg->clkInternal)
+		davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_CLKMOD_MASK;
+	else
+		davinci_spi->base->SPIGCR1 &= ~(SPI_SPIGCR1_CLKMOD_MASK);
+
+	/* master mode default */
+	davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_MASTER_MASK;
+
+	if (spi_cfg->intrLevel)
+		davinci_spi->base->SPILVL = SPI_INTLVL_1;
+	else
+		davinci_spi->base->SPILVL = SPI_INTLVL_0;
+
+	switch (spi_cfg->pinOpModes) {
+
+	case SPI_OPMODE_3PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+
+		break;
+
+	case SPI_OPMODE_SPISCS_4PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+		    | (SPI_SPIPC0_EN1FUN_EN1 << SPI_SPIPC0_EN1FUN_SHIFT)
+		    | (SPI_SPIPC0_EN0FUN_EN0 << SPI_SPIPC0_EN0FUN_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+
+		break;
+
+	case SPI_OPMODE_SPIENA_4PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+		    | (SPI_SPIPC0_SPIENA << SPI_SPIPC0_SPIENA_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+		break;
+
+	default:
+		return -1;
+	}
+
+	if (spi_cfg->loopBack)
+		davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_LOOPBACK_MASK;
+	else
+		davinci_spi->base->SPIGCR1 &= ~(SPI_SPIGCR1_LOOPBACK_MASK);
+
+	/*Put delay val if required */
+	davinci_spi->base->SPIDELAY = 0 | (8 << 24) | (8 << 16);
+
+	count = davinci_spi->count;
+	data1_reg_val |= spi_cfg->csHold << SPI_SPIDAT1_CSHOLD_SHIFT;
+
+	/*CD default = 0xFF */
+	tmp = ~(0x1 << spi->chip_select);
+	davinci_spi->base->SPIDEF &= tmp;
+	data1_reg_val |= tmp << SPI_SPIDAT1_CSNR_SHIFT;
+
+	DM355_CLEAR_RX_BUFFER(davinci_spi->base);
+	/* Determine the command to execute READ or WRITE */
+	if (t->tx_buf) {
+		davinci_spi->base->SPIINT &= ~(SPI_SPIINT_MASKALL);
+
+		i = 0;
+		while (1) {
+			tx_data = davinci_spi->get_tx(davinci_spi);
+
+			data1_reg_val &= ~(0xFFFF);
+			data1_reg_val |= (0xFFFF & tx_data);
+
+			DEBUG_SPI("data to be TX = 0x%x\n", tx_data);
+			DEBUG_SPI("\nwriting into DATA1 register val = 0x%x\n",
+				  data1_reg_val);
+
+			buf_val = davinci_spi->base->SPIBUF;
+			if ((buf_val & SPI_SPIBUF_TXFULL_MASK) == FALSE) {
+				davinci_spi->base->SPIDAT1 = data1_reg_val;
+				i++;
+				DEBUG_SPI("\n***I have transmited...on "
+					  "iteration %d and buf_val = "
+					  "0x%8x***\n", i, buf_val);
+
+				count--;
+				if (count <= 0)
+					break;
+			}
+			while (davinci_spi->base->
+			       SPIBUF & SPI_SPIBUF_RXEMPTY_MASK) ;
+		}
+	} else {
+		DEBUG_SPI("In receive\n");
+
+#ifdef CONFIG_SPI_INTERRUPT
+		spi_cfg->op_mode = 1;
+#else
+		spi_cfg->op_mode = 0;
+#endif
+
+		if (!spi_cfg->op_mode) {	/*In Polling mode receive */
+
+			i = 0;
+			while (1) {
+				i++;
+
+				/* keeps the serial clock going */
+				if ((davinci_spi->base->SPIBUF &
+				     SPI_SPIBUF_TXFULL_MASK) == FALSE)
+					davinci_spi->base->SPIDAT1 =
+					    data1_reg_val;
+
+				while (davinci_spi->base->SPIBUF &
+				       SPI_SPIBUF_RXEMPTY_MASK) ;
+
+				flg_val = davinci_spi->base->SPIFLG;
+				buf_val = davinci_spi->base->SPIBUF;
+
+				DEBUG_SPI("flg_val = 0x%8x & buf_val = "
+					  "0x%8x\n", flg_val, buf_val);
+
+				davinci_spi->get_rx(buf_val, davinci_spi);
+
+				DEBUG_SPI("I have got it... after "
+					  "%d iteration buf_val = "
+					  "0x%8x\nflg_val =  0x%8x\n",
+					  i, buf_val, flg_val);
+
+				count--;
+				if (count <= 0)
+					break;
+			}
+		} else {	/*Receive in Interrupt mode */
+
+			for (i = 0; i <= davinci_spi->count; i++) {
+				if (i == davinci_spi->count)
+					davinci_spi->base->SPIDAT1 =
+					    (data1_reg_val & 0x0ffcffff);
+				else {
+					davinci_spi->base->SPIINT |=
+					    SPI_SPIFLG_BITERRFLG_MASK |
+					    SPI_SPIFLG_OVRNINTFLG_MASK |
+					    SPI_SPIFLG_RXINTFLAG_MASK;
+
+					davinci_spi->base->SPIDAT1 =
+					    (data1_reg_val);
+
+					while ((flg_val =
+						davinci_spi->base->
+						SPIINT) &
+					       SPI_SPIFLG_RXINTFLAG_MASK) ;
+				}
+			}
+		}
+	}
+
+	/* Check for bit error, desync error,parity error,timeout error and
+	   receive overflow errors */
+	intStatus = davinci_spi->base->SPIFLG;
+
+	if ((intStatus & SPI_SPIINT_TIMEOUT_INTR) == SPI_SPIINT_TIMEOUT_INTR) {
+		printk(KERN_INFO "SPI Time-out Error\n");
+		return SPI_TIMEOUT_ERR;
+	}
+
+	/* De-Synchronization error, holds only in master mode */
+	else if ((intStatus&SPI_SPIINT_DESYNC_INTR) == SPI_SPIINT_DESYNC_INTR) {
+		printk(KERN_INFO "SPI Desynchronization Error\n");
+		return SPI_DESYNC_ERR;
+	}
+
+	/* Bit error error */
+	else if ((intStatus&SPI_SPIINT_BITERR_INTR) == SPI_SPIINT_BITERR_INTR) {
+		printk(KERN_INFO "SPI Bit error\n");
+		return SPI_BIT_ERR;
+	}
+
+	/* SPI Framework maintains the count only in bytes so convert back */
+	davinci_spi->count *= conv;
+
+	EXIT
+	return t->len;
+}
+
+#define DAVINCI_DMA_DATA_TYPE_S8           0x01
+#define DAVINCI_DMA_DATA_TYPE_S16          0x02
+#define DAVINCI_DMA_DATA_TYPE_S32          0x04
+
+static int davinci_spi_bufs_dma(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct davinci_spi *davinci_spi;
+	int i, intStatus = 0;
+	int count;
+	u8 conv = 1;
+	u8 tmp;
+	u32 data1_reg_val = 0;
+	struct davinci_spi_dma *davinci_spi_dma;
+	int word_len, data_type;
+	unsigned long tx_reg, rx_reg;
+
+	struct davinci_spi_config_t *spi_cfg;
+	u32 sPIPC0 = 0;
+
+	ENTER
+	davinci_spi = spi_master_get_devdata(spi->master);
+
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+	tx_reg = DAVINCI_SPI_BASE + 0x3c;	/* davinci_spi->base->SPIDAT1 */
+	rx_reg = DAVINCI_SPI_BASE + 0x40;	/* davinci_spi->base->SPIBUF */
+
+	/* used for macro defs */
+	davinci_spi->tx = t->tx_buf;
+	davinci_spi->rx = t->rx_buf;
+
+	/* convert len to words bbased on bits_per_word */
+	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
+	davinci_spi->count = t->len / conv;
+
+	DEBUG_SPI("chipselect=%d, bytes_per_word=%d, t->len=%d, conv=%d\n",
+		  spi->chip_select,
+		  davinci_spi->slave[spi->chip_select].bytes_per_word, t->len,
+		  conv);
+
+	INIT_COMPLETION(davinci_spi->done);
+
+	init_completion(&davinci_spi_dma->dma_rx_completion);
+	init_completion(&davinci_spi_dma->dma_tx_completion);
+
+	word_len = conv * 8;
+	if (word_len <= 8)
+		data_type = DAVINCI_DMA_DATA_TYPE_S8;
+	else if (word_len <= 16)
+		data_type = DAVINCI_DMA_DATA_TYPE_S16;
+	else if (word_len <= 32)
+		data_type = DAVINCI_DMA_DATA_TYPE_S32;
+	else
+		return -1;
+
+	/*configuraton parameter for SPI */
+	spi_cfg = (struct davinci_spi_config_t *) spi->controller_data;
+
+	for (i = 0; i < 4; i++) {
+		if (spi_cfg->phaseIn)
+			davinci_spi->base->SPIFMT[i] |= SPI_SPIFMT_PHASE_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_PHASE_MASK);
+
+		if (spi_cfg->clkHigh)
+			davinci_spi->base->SPIFMT[i] |=
+			    SPI_SPIFMT_POLARITY_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_POLARITY_MASK);
+
+		if (spi_cfg->lsbFirst)
+			davinci_spi->base->SPIFMT[i] |=
+			    SPI_SPIFMT_SHIFTDIR_MASK;
+		else
+			davinci_spi->base->SPIFMT[i] &=
+			    ~(SPI_SPIFMT_SHIFTDIR_MASK);
+	}
+
+	/*Clock internal */
+	if (spi_cfg->clkInternal)
+		davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_CLKMOD_MASK;
+	else
+		davinci_spi->base->SPIGCR1 &= ~(SPI_SPIGCR1_CLKMOD_MASK);
+
+	/* master mode default */
+	davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_MASTER_MASK;
+
+	if (spi_cfg->intrLevel)
+		davinci_spi->base->SPILVL = SPI_INTLVL_1;
+	else
+		davinci_spi->base->SPILVL = SPI_INTLVL_0;
+
+	switch (spi_cfg->pinOpModes) {
+	case SPI_OPMODE_3PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+
+		break;
+
+	case SPI_OPMODE_SPISCS_4PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+		    | (SPI_SPIPC0_EN1FUN_EN1 << SPI_SPIPC0_EN1FUN_SHIFT)
+		    | (SPI_SPIPC0_EN0FUN_EN0 << SPI_SPIPC0_EN0FUN_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+
+		break;
+
+	case SPI_OPMODE_SPIENA_4PIN:
+		sPIPC0 |= (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+		    | (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+		    | (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+		    | (SPI_SPIPC0_SPIENA << SPI_SPIPC0_SPIENA_SHIFT);
+
+		davinci_spi->base->SPIPC0 = sPIPC0;
+		break;
+
+	default:
+		return -1;
+	}
+
+	if (spi_cfg->loopBack)
+		davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_LOOPBACK_MASK;
+	else
+		davinci_spi->base->SPIGCR1 &= ~(SPI_SPIGCR1_LOOPBACK_MASK);
+
+	/*Put delay val if required */
+/*        davinci_spi->base->SPIDELAY = 0 | (8 << 24) | (8 <<16); */
+	davinci_spi->base->SPIDELAY = 0;
+
+	count = davinci_spi->count;	/* the number of elements */
+	data1_reg_val |= spi_cfg->csHold << SPI_SPIDAT1_CSHOLD_SHIFT;
+
+	/*CD default = 0xFF */
+	tmp = ~(0x1 << spi->chip_select);
+	davinci_spi->base->SPIDEF &= tmp;
+	data1_reg_val |= tmp << SPI_SPIDAT1_CSNR_SHIFT;
+
+	/*disable all interrupts for dma transfers */
+	davinci_spi->base->SPIINT &= ~(SPI_SPIINT_MASKALL);
+	/* Disable SPI to write configuration bits in SPIDAT */
+	davinci_spi->base->SPIGCR1 &= ~SPI_SPIGCR1_SPIENA_MASK;
+	davinci_spi->base->SPIDAT1 = data1_reg_val;
+	/*Enable SPI */
+	davinci_spi->base->SPIGCR1 |= SPI_SPIGCR1_SPIENA_MASK;
+
+	DM355_CLEAR_RX_BUFFER(davinci_spi->base);
+
+	if (t->tx_buf != NULL) {
+#ifdef CONFIG_SPI_DEBUG
+		for (i = 0; i < count; i++)
+			DEBUG_SPI("tx[%d]=0x%x\n", i,
+				  *((u8 *) (t->tx_buf) + i));
+#endif
+		t->tx_dma = dma_map_single(&spi->dev, (void *)t->tx_buf, count,
+					   DMA_TO_DEVICE);
+		if (dma_mapping_error(t->tx_dma)) {
+			printk(KERN_ERR
+			       "%s(): Couldn't DMA map a %d bytes TX buffer\n",
+			       __FUNCTION__, count);
+			return -1;
+		}
+		davinci_set_dma_transfer_params(davinci_spi_dma->dma_tx_channel,
+						data_type, count, 1, 0, ASYNC);
+		davinci_set_dma_dest_params(davinci_spi_dma->dma_tx_channel,
+					    tx_reg, INCR, W8BIT);
+		davinci_set_dma_src_params(davinci_spi_dma->dma_tx_channel,
+					   t->tx_dma, INCR, W8BIT);
+		davinci_set_dma_src_index(davinci_spi_dma->dma_tx_channel,
+					  data_type, 0);
+		davinci_set_dma_dest_index(davinci_spi_dma->dma_tx_channel, 0,
+					   0);
+	} else {
+		/* We need TX clocking for RX transaction */
+		t->tx_dma =
+		    dma_map_single(&spi->dev, (void *)davinci_spi->tmp_buf,
+				   count + 1, DMA_TO_DEVICE);
+		if (dma_mapping_error(t->tx_dma)) {
+			printk(KERN_ERR
+			       "%s(): Couldn't DMA map a %d bytes TX ",
+			       "tmp buffer\n", __FUNCTION__, count);
+			return -1;
+		}
+		davinci_set_dma_transfer_params(davinci_spi_dma->dma_tx_channel,
+						data_type, count + 1, 1, 0,
+						ASYNC);
+		davinci_set_dma_dest_params(davinci_spi_dma->dma_tx_channel,
+					    tx_reg, INCR, W8BIT);
+		davinci_set_dma_src_params(davinci_spi_dma->dma_tx_channel,
+					   t->tx_dma, INCR, W8BIT);
+		davinci_set_dma_src_index(davinci_spi_dma->dma_tx_channel,
+					  data_type, 0);
+		davinci_set_dma_dest_index(davinci_spi_dma->dma_tx_channel, 0,
+					   0);
+	}
+
+	if (t->rx_buf != NULL) {
+		/* initiate transaction */
+		davinci_spi->base->SPIDAT1 = data1_reg_val;
+
+		t->rx_dma = dma_map_single(&spi->dev, (void *)t->rx_buf, count,
+					   DMA_FROM_DEVICE);
+		if (dma_mapping_error(t->rx_dma)) {
+			printk(KERN_ERR
+			       "%s(): Couldn't DMA map a %d bytes RX buffer\n",
+			       __FUNCTION__, count);
+			if (t->tx_buf != NULL)
+				dma_unmap_single(NULL, t->tx_dma,
+						 count, DMA_TO_DEVICE);
+			return -1;
+		}
+		davinci_set_dma_transfer_params(davinci_spi_dma->dma_rx_channel,
+						data_type, count, 1, 0, ASYNC);
+		davinci_set_dma_src_params(davinci_spi_dma->dma_rx_channel,
+					   rx_reg, INCR, W8BIT);
+		davinci_set_dma_dest_params(davinci_spi_dma->dma_rx_channel,
+					    t->rx_dma, INCR, W8BIT);
+		davinci_set_dma_src_index(davinci_spi_dma->dma_rx_channel, 0,
+					  0);
+		davinci_set_dma_dest_index(davinci_spi_dma->dma_rx_channel,
+					   data_type, 0);
+	}
+
+	if ((t->tx_buf != NULL) || (t->rx_buf != NULL))
+		davinci_start_dma(davinci_spi_dma->dma_tx_channel);
+
+	if (t->rx_buf != NULL)
+		davinci_start_dma(davinci_spi_dma->dma_rx_channel);
+
+	if ((t->rx_buf != NULL) || (t->tx_buf != NULL))
+		davinci_spi_set_dma_req(spi, 1);
+
+	if (t->tx_buf != NULL) {
+		DEBUG_SPI("WAIT TX DMA\n");
+		wait_for_completion_interruptible(&davinci_spi_dma->
+						  dma_tx_completion);
+	}
+
+	if (t->rx_buf != NULL) {
+		DEBUG_SPI("WAIT RX DMA\n");
+		wait_for_completion_interruptible(&davinci_spi_dma->
+						  dma_rx_completion);
+#ifdef CONFIG_SPI_DEBUG
+		for (i = 0; i < count; i++)
+			DEBUG_SPI("rx[%d]=0x%x\n", i, *(u8 *) (t->rx_buf + i));
+#endif
+	}
+
+	if (t->tx_buf != NULL)
+		dma_unmap_single(NULL, t->tx_dma, count, DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, t->tx_dma, count + 1, DMA_TO_DEVICE);
+
+	if (t->rx_buf != NULL)
+		dma_unmap_single(NULL, t->rx_dma, count, DMA_FROM_DEVICE);
+
+	/* Check for bit error, desync error,parity error,timeout error and
+	   receive overflow errors */
+	intStatus = davinci_spi->base->SPIFLG;
+
+	if ((intStatus & SPI_SPIINT_TIMEOUT_INTR) == SPI_SPIINT_TIMEOUT_INTR) {
+		printk(KERN_INFO "SPI Time-out Error\n");
+		return SPI_TIMEOUT_ERR;
+	}
+
+	/* De-Synchronization error, holds only in master mode */
+	else if ((intStatus&SPI_SPIINT_DESYNC_INTR) == SPI_SPIINT_DESYNC_INTR) {
+		printk(KERN_INFO "SPI Desynchronization Error\n");
+		return SPI_DESYNC_ERR;
+	}
+
+	/* Bit error error */
+	else if ((intStatus&SPI_SPIINT_BITERR_INTR) == SPI_SPIINT_BITERR_INTR) {
+		printk(KERN_INFO "SPI Bit error\n");
+		return SPI_BIT_ERR;
+	}
+
+	/* SPI Framework maintains the count only in bytes so convert back */
+	davinci_spi->count *= conv;
+
+	EXIT
+	return t->len;
+}
+
+/**
+ * davinci_spi_irq - probe function for SPI Master Controller
+ * @irq: IRQ number for this SPI Master
+ * @context_data: structure for SPI Master controller davinci_spi
+ * @ptregs:
+ *
+ * ISR will determine that interrupt arrives either for READ or WRITE command.
+ * According to command it will do the appropriate action. It will check
+ * transfer length and if it is not zero then dispatch transfer command again.
+ * If transfer length is zero then it will indicate the COMPLETION so that
+ * davinci_spi_bufs function can go ahead.
+ */
+irqreturn_t davinci_spi_irq(s32 irq, void *context_data,
+			    struct pt_regs *ptregs)
+{
+	struct davinci_spi *davinci_spi = context_data;
+	u32 rx_data = 0;
+
+	DEBUG_SPI("IN_IRQ\n");
+	DEBUG_SPI("received interrupt = 0x%8x\n", davinci_spi->base->SPIFLG);
+
+	while (davinci_spi->base->SPIFLG != 0) {
+		/*Time out Error */
+		if ((davinci_spi->base->SPIFLG & SPI_SPIINT_TIMEOUT_INTR) ==
+		    SPI_SPIINT_TIMEOUT_INTR) {
+			printk(KERN_INFO "SPI Time-out Error\n");
+			return SPI_TIMEOUT_ERR;
+		}
+
+		/* De-Synchronization interrupt, holds only in master mode */
+		else if ((davinci_spi->base->SPIFLG & SPI_SPIINT_DESYNC_INTR) ==
+			 SPI_SPIINT_DESYNC_INTR) {
+			printk(KERN_INFO "SPI Desynchronization Error\n");
+			return SPI_DESYNC_ERR;
+		}
+
+		/* Bit error Interrupt */
+		else if ((davinci_spi->base->SPIFLG & SPI_SPIINT_BITERR_INTR) ==
+			 SPI_SPIINT_BITERR_INTR) {
+			printk(KERN_INFO "SPI Bit error\n");
+			return SPI_BIT_ERR;
+		 /**/}
+
+		/*Receive Interrupt */
+		else if (davinci_spi->base->SPIFLG & SPI_SPIINT_RX_INTR) {
+
+			rx_data = davinci_spi->base->SPIBUF;
+			davinci_spi->get_rx(rx_data, davinci_spi);
+			DEBUG_SPI("IRQ rx_data = 0x16%x\n", rx_data);
+
+			/*Disable Receive Interrupt */
+			davinci_spi->base->SPIINT = ~SPI_SPIINT_RX_INTR;
+			return IRQ_HANDLED;
+		}
+
+	}
+	return -1;
+
+}
+
+/**
+ * davinci_spi_probe - probe function for SPI Master Controller
+ * @dev: platform_device structure which contains plateform specific data
+ *
+ * According to Linux Deviced Model this function will be invoked by Linux
+ * with plateform_device struct which contains the device specific info
+ * like bus_num, max_chipselect (how many slave devices can be connected),
+ * clock freq. of SPI controller, SPI controller's memory range, IRQ number etc.
+ *
+ * According to Linux Deviced Model this function will be invoked by Linux
+ * with plateform_device struct which contains the device specific info
+ * like bus_num, max_chipselect (how many slave devices can be connected),
+ * clock freq. of SPI controller, SPI controller's memory range, IRQ number etc.
+ * This info will be provided by board specific code which will reside in
+ * linux-2.6.10/arch/mips/mips-boards/davinci_davinci/davinci_yamuna code.
+ * This function will map the SPI controller's memory, register IRQ,
+ * Reset SPI controller and setting its registers to default value.
+ * It will invoke spi_bitbang_start to create work queue so that client driver
+ * can register transfer method to work queue.
+ */
+static u8 __initdata spi0_rxdma_id[] = {
+	DAVINCI_DMA_SPI_SPIR,
+	DAVINCI_DMA_SPI_SPIR,
+};
+
+static u8 __initdata spi0_txdma_id[] = {
+	DAVINCI_DMA_SPI_SPIX,
+	DAVINCI_DMA_SPI_SPIX,
+};
+
+static u8 __initdata spi1_rxdma_id[] = {
+	DAVINCI_DMA_SPI_SPIR,
+	DAVINCI_DMA_SPI_SPIR,
+};
+
+static u8 __initdata spi1_txdma_id[] = {
+	DAVINCI_DMA_SPI_SPIX,
+	DAVINCI_DMA_SPI_SPIX,
+};
+
+static int davinci_spi_probe(struct device *d)
+{
+	struct platform_device *dev =
+	    container_of(d, struct platform_device, dev);
+	struct spi_master *master;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_platform_data *pdata;
+	struct resource *r;
+	int i = 0, ret = 0, prescale = 0, clk_freq = 0;
+	const u8 *rxdma_id, *txdma_id;
+
+	switch (dev->id) {
+	case 0:
+		rxdma_id = spi0_rxdma_id;
+		txdma_id = spi0_txdma_id;
+		break;
+	case 1:
+		rxdma_id = spi1_rxdma_id;
+		txdma_id = spi1_txdma_id;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Get resources(memory, IRQ) associated with the device */
+	master = spi_alloc_master(&dev->dev, sizeof(struct davinci_spi));
+
+	if (master == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev_set_drvdata(&(dev)->dev, (master));
+
+	pdata = dev->dev.platform_data;
+
+	if (pdata == NULL) {
+		ret = -ENODEV;
+		goto free_master;
+	}
+
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+
+	if (r == NULL) {
+		ret = -ENODEV;
+		goto free_master;
+	}
+
+	davinci_spi = spi_master_get_devdata(master);
+	davinci_spi->bitbang.master = spi_master_get(master);
+	davinci_spi->bitbang.chipselect = davinci_spi_chipselect;
+	davinci_spi->bitbang.setup_transfer = davinci_spi_setup_transfer;
+
+	/* DM355 does not have DMA capabilities */
+	if (cpu_is_davinci_dm355())
+		use_dma = 0;
+
+	if (use_dma) {
+		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_dma;
+	} else {
+		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_pio;
+	}
+	davinci_spi->sysclk = pdata->sysclk;
+	davinci_spi->activate_cs = pdata->activate_cs;
+	davinci_spi->deactivate_cs = pdata->deactivate_cs;
+	davinci_spi->get_rx = davinci_spi_rx_buf_u8;
+	davinci_spi->get_tx = davinci_spi_tx_buf_u8;
+
+	davinci_spi->bitbang.master->setup = davinci_spi_setup;
+	davinci_spi->bitbang.master->cleanup = davinci_spi_cleanup;
+	init_completion(&davinci_spi->done);
+
+	ENTER
+	    davinci_spi->base =
+	    (struct davinci_spi_reg __iomem *)ioremap(r->start,
+						      (r->end - r->start));
+
+	if (davinci_spi->base == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+	davinci_spi->irq = platform_get_irq(dev, 0);
+
+	if (davinci_spi->irq < 0) {
+		ret = -ENXIO;
+		goto unmap_io;
+	}
+
+	/* Register for SPI Interrupt */
+	ret = request_irq(davinci_spi->irq, davinci_spi_irq,
+			  SA_INTERRUPT, "dm_spi", davinci_spi);
+
+	if (ret != 0) {
+		DEBUG_SPI("request_irq fails\n");
+		goto unmap_io;
+	}
+
+	master->bus_num = pdata->bus_num;
+	master->num_chipselect = pdata->max_chipselect;
+
+	/* SPI controller initializations */
+	if (cpu_is_davinci_dm6467()) {
+		clk_freq = 240 * 1000000 / 2;
+	} else if (cpu_is_davinci_dm355()) {
+		clk_freq = 216000000 / 2;
+
+	} else {
+		clk_freq = 270 * 1000000 / 4;
+	}
+
+	prescale = (clk_freq / SPI_BUS_FREQ) + 1;
+
+	/*Reset In/OUT SPI modle */
+	(davinci_spi->base->SPIGCR0) = 0x0;
+	udelay(100);
+	(davinci_spi->base->SPIGCR0) = 0x1;
+
+	for (i = 0; i < 4; i++) {
+		davinci_spi->base->SPIFMT[i] &= 0xFFFF00FF;
+
+		davinci_spi->base->SPIFMT[i] |= (prescale << 8);
+	}
+
+	davinci_spi->dma_channels =
+	    (struct davinci_spi_dma *)kzalloc(master->num_chipselect *
+					      sizeof(struct davinci_spi_dma),
+					      GFP_KERNEL);
+	if (davinci_spi->dma_channels == NULL)
+		goto free_irq;
+
+	for (i = 0; i < master->num_chipselect; i++) {
+		davinci_spi->dma_channels[i].dma_rx_channel = -1;
+		davinci_spi->dma_channels[i].dma_rx_sync_dev = rxdma_id[i];
+		davinci_spi->dma_channels[i].dma_tx_channel = -1;
+		davinci_spi->dma_channels[i].dma_tx_sync_dev = txdma_id[i];
+	}
+
+	/* Allocate tmp_buf for tx_buf */
+	davinci_spi->tmp_buf = kmalloc(SPI_BUFSIZ, SLAB_KERNEL);
+	if (!davinci_spi->tmp_buf)
+		goto free_tmp_buf;
+
+	ret = davinci_spi_bitbang_start(&davinci_spi->bitbang);
+
+	if (ret != 0)
+		goto free_dma;
+
+	printk(KERN_INFO "%s: davinci SPI Controller driver at "
+	       "0x%p (irq = %d) use_dma=%d\n",
+	       dev->dev.bus_id, davinci_spi->base, davinci_spi->irq, use_dma);
+
+	EXIT
+	return ret;
+
+free_dma:
+	kfree(davinci_spi->dma_channels);
+free_tmp_buf:
+	kfree(davinci_spi->tmp_buf);
+free_irq:
+	free_irq(davinci_spi->irq, davinci_spi);
+unmap_io:
+
+	iounmap(davinci_spi->base);
+put_master:
+	spi_master_put(master);
+free_master:
+	kfree(master);
+err:
+	return ret;
+}
+
+/**
+ * davinci_spi_remove - remove function for SPI Master Controller
+ * @dev: platform_device structure which contains plateform specific data
+ *
+ * This function will do the reverse action of davinci_spi_probe function
+ * It will free the IRQ and SPI controller's memory region.
+ * It will also call spi_bitbang_stop to destroy the work queue which was
+ * created by spi_bitbang_start.
+ */
+static int __devexit davinci_spi_remove(struct device *d)
+{
+	struct platform_device *dev =
+	    container_of(d, struct platform_device, dev);
+	struct davinci_spi *davinci_spi;
+	struct spi_master *master;
+
+	master = dev_get_drvdata(&(dev)->dev);
+
+	davinci_spi = spi_master_get_devdata(master);
+
+	davinci_spi_bitbang_stop(&davinci_spi->bitbang);
+	free_irq(davinci_spi->irq, davinci_spi);
+	iounmap(davinci_spi->base);
+
+	kfree(davinci_spi->tmp_buf);
+	kfree(davinci_spi->dma_channels);
+
+	spi_master_put(davinci_spi->bitbang.master);
+
+	return 0;
+}
+
+static struct device_driver davinci_spi_driver = {
+	.name = "dm_spi",
+	.bus = &platform_bus_type,
+	.probe = davinci_spi_probe,
+	.remove = __devexit_p(davinci_spi_remove),
+};
+
+static int __init davinci_spi_init(void)
+{
+	return driver_register(&davinci_spi_driver);
+}
+
+static void __exit davinci_spi_exit(void)
+{
+	driver_unregister(&davinci_spi_driver);
+}
+
+module_init(davinci_spi_init);
+module_exit(davinci_spi_exit);
+
+MODULE_AUTHOR("Dhruval Shah & Varun Shah");
+MODULE_DESCRIPTION("DM355 SPI Master Controller Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/include/linux/spi/at25xxA_eeprom.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/spi/at25xxA_eeprom.h
@@ -0,0 +1,50 @@
+/*
+ * DaVinci SPI-EEPROM client driver header file
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef DAVINCI_SPI_EEPROM_H
+#define DAVINCI_SPI_EEPROM_H
+
+#include <linux/cache.h>
+/*
+ *  EEPROM op-codes
+ */
+#define DAVINCI_EEPROM_READ	0x03	/* read */
+#define DAVINCI_EEPROM_WRITE	0x02	/* write */
+#define DAVINCI_EEPROM_WREN	0x06	/* write enable */
+#define DAVINCI_EEPROM_WRDIS	0x04	/* write disable */
+#define DAVINCI_EEPROM_RDSTAT	0x05	/* read status register */
+#define DAVINCI_EEPROM_WRSTAT	0x01	/* write status register */
+
+#define SPI_BUFFER_SIZE SMP_CACHE_BYTES
+#define DAVINCI_SPI_TX_CMD_SIZE 3
+
+#define DAVINCI_SPI_EEPROM_NAME "davinci_spi_eeprom"
+
+struct mtd_partition;
+
+struct davinci_eeprom_info {
+	unsigned int eeprom_size;
+	unsigned int page_size;
+	unsigned int page_mask;
+	unsigned long chip_sel;
+	unsigned int commit_delay;
+	struct spi_device *spi;
+	struct davinci_spi *spi_data;
+
+	struct mtd_partition *parts;
+	unsigned int nr_parts;
+
+	struct semaphore lock;
+	char tx_buffer[SPI_BUFFER_SIZE + DAVINCI_SPI_TX_CMD_SIZE];
+	char rx_buffer[SPI_BUFFER_SIZE];
+};
+
+#endif				/*DAVINCI_SPI_EEPROM_H */
Index: linux-2.6.10/include/linux/spi/davinci_spi_bitbang.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/spi/davinci_spi_bitbang.h
@@ -0,0 +1,153 @@
+#ifndef	__DAVINCI_SPI_BITBANG_H
+#define	__DAVINCI_SPI_BITBANG_H
+
+/*
+ * Mix this utility code with some glue code to get one of several types of
+ * simple SPI master driver.  Two do polled word-at-a-time I/O:
+ *
+ *   -	GPIO/parport bitbangers.  Provide chipselect() and txrx_word[](),
+ *	expanding the per-word routines from the inline templates below.
+ *
+ *   -	Drivers for controllers resembling bare shift registers.  Provide
+ *	chipselect() and txrx_word[](), with custom setup()/cleanup() methods
+ *	that use your controller's clock and chipselect registers.
+ *
+ * Some hardware works well with requests at spi_transfer scope:
+ *
+ *   -	Drivers leveraging smarter hardware, with fifos or DMA; or for half
+ *	duplex (MicroWire) controllers.  Provide chipslect() and txrx_bufs(),
+ *	and custom setup()/cleanup() methods.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+struct spi_bitbang {
+	struct workqueue_struct *workqueue;
+	struct work_struct work;
+	spinlock_t lock;	/* mutex for queue */
+	struct list_head queue;
+	u8 busy;
+	u8 shutdown;
+	u8 use_dma;
+	struct spi_master *master;
+
+	/* setup_transfer() changes clock and/or wordsize to match settings
+	 * for this transfer; zeroes restore defaults from spi_device.
+	 */
+	int (*setup_transfer) (struct spi_device *spi,
+			       struct spi_transfer *t);
+	void (*chipselect) (struct spi_device *spi, int is_on);
+
+#define	BITBANG_CS_ACTIVE	1	/* normally nCS, active low */
+#define	BITBANG_CS_INACTIVE	0
+
+	/* txrx_bufs() may handle dma mapping for transfers that don't
+	 * already have one (transfer.{tx,rx}_dma is zero), or use PIO
+	 */
+	int (*txrx_bufs) (struct spi_device *spi, struct spi_transfer *t);
+
+	/* txrx_word[SPI_MODE_*]() just looks like a shift register */
+	 u32(*txrx_word[4]) (struct spi_device *spi, unsigned nsecs,
+			     u32 word, u8 bits);
+	void (*set_flen) (struct spi_device *spi, u32 flen);
+};
+
+/* you can call these default bitbang->master methods from your custom
+ * methods, if you like.
+ */
+extern int davinci_spi_bitbang_setup(struct spi_device *spi);
+extern void davinci_spi_bitbang_cleanup(const struct spi_device *spi);
+extern int davinci_spi_bitbang_transfer(struct spi_device *spi,
+					struct spi_message *m);
+extern int davinci_spi_bitbang_setup_transfer(struct spi_device *spi,
+					      struct spi_transfer *t);
+
+/* start or stop queue processing */
+extern int davinci_spi_bitbang_start(struct spi_bitbang *spi);
+extern int davinci_spi_bitbang_stop(struct spi_bitbang *spi);
+
+#endif				/* __DAVINCI_SPI_BITBANG_H */
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	EXPAND_BITBANG_TXRX
+
+/*
+ * The code that knows what GPIO pins do what should have declared four
+ * functions, ideally as inlines, before #defining EXPAND_BITBANG_TXRX
+ * and including this header:
+ *
+ *  void setsck(struct spi_device *, int is_on);
+ *  void setmosi(struct spi_device *, int is_on);
+ *  int getmiso(struct spi_device *);
+ *  void spidelay(unsigned);
+ *
+ * A non-inlined routine would call bitbang_txrx_*() routines.  The
+ * main loop could easily compile down to a handful of instructions,
+ * especially if the delay is a NOP (to run at peak speed).
+ *
+ * Since this is software, the timings may not be exactly what your board's
+ * chips need ... there may be several reasons you'd need to tweak timings
+ * in these routines, not just make to make it faster or slower to match a
+ * particular CPU clock rate.
+ */
+static inline u32
+bitbang_txrx_be_cpha0(struct spi_device *spi, unsigned nsecs,
+		      unsigned cpol, u32 word, u8 bits)
+{
+
+	/* if (cpol == 0) this is SPI_MODE_0; else this is SPI_MODE_2 */
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+
+		/* setup MSB (to slave) on trailing edge */
+		setmosi(spi, word & (1 << 31));
+		spidelay(nsecs);	/* T(setup) */
+		setsck(spi, !cpol);
+		spidelay(nsecs);
+
+		/* sample MSB (from slave) on leading edge */
+		word <<= 1;
+		word |= getmiso(spi);
+		setsck(spi, cpol);
+	}
+	return word;
+}
+static inline u32
+bitbang_txrx_be_cpha1(struct spi_device *spi, unsigned nsecs,
+		      unsigned cpol, u32 word, u8 bits)
+{
+
+	/* if (cpol == 0) this is SPI_MODE_1; else this is SPI_MODE_3 */
+
+	/* clock starts at inactive polarity */
+	for (word <<= (32 - bits); likely(bits); bits--) {
+
+		/* setup MSB (to slave) on leading edge */
+		setsck(spi, !cpol);
+		setmosi(spi, word & (1 << 31));
+		spidelay(nsecs);	/* T(setup) */
+		setsck(spi, cpol);
+		spidelay(nsecs);
+
+		/* sample MSB (from slave) on trailing edge */
+		word <<= 1;
+		word |= getmiso(spi);
+	}
+	return word;
+}
+
+#endif				/* EXPAND_BITBANG_TXRX */
Index: linux-2.6.10/include/linux/spi/davinci_spi.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/spi/davinci_spi.h
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DAVINCI_SPI_H_
+#define __DAVINCI_SPI_H_
+
+#define DAVINCI_SPI_SIZE				0xFF
+#define DAVINCI_SPI_INIT_SPMODE			0
+
+/* Chip selects available on the spi IP */
+#define DAVINCI_SPI_CS0		0
+#define DAVINCI_SPI_CS1		1
+#define DAVINCI_SPI_CS2		2
+#define DAVINCI_SPI_CS3		3
+
+struct spi_cmd_t {
+	unsigned int addr;
+	unsigned int data;
+};
+
+struct ctlr_cs_sel_t {
+	u8 cs;
+	u8 pol;
+};
+
+struct davinci_spi_platform_data {
+	/* initial SPMODE value */
+	u32 initial_spmode;
+	/* board specific information */
+	u16 bus_num;		/* id for controller */
+	u16 max_chipselect;
+	int (*activate_cs) (u8 cs, u8 polarity,
+			    struct ctlr_cs_sel_t *ctlr_cs_sel);
+	int (*deactivate_cs) (u8 cs, u8 polarity,
+			      struct ctlr_cs_sel_t *ctlr_cs_sel);
+	u32 sysclk;
+};
+
+#endif				/* __DAVINCI_SPI_H_ */
Index: linux-2.6.10/include/linux/spi/davinci_spi_master.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/spi/davinci_spi_master.h
@@ -0,0 +1,307 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <linux/device.h>
+#include <asm-arm/arch/hardware.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/davinci_spi.h>
+#include <linux/spi/davinci_spi_bitbang.h>
+
+#define FALSE 0
+#define TRUE  1
+#define ERROR -1
+
+/*Board specific declarations*/
+#define SPI_BUS_FREQ  			(4000000)
+#define CS_DEFAULT 0xFF
+#define SCS0_SELECT	0x01
+#define SCS1_SELECT	0x02
+#define SCS2_SELECT	0x04
+#define SCS3_SELECT	0x08
+#define SCS4_SELECT	0x10
+#define SCS5_SELECT	0x20
+#define SCS6_SELECT	0x40
+#define SCS7_SELECT	0x80
+
+/* Standard values for DAVINCI */
+#define DAVINCI_SPI_MAX_CHIPSELECT 7
+
+/* #define SPI_INTERRUPT_MODE 1 */
+#define SPI_SPIFMT_PHASE_MASK        (0x00010000u)
+#define SPI_SPIFMT_PHASE_SHIFT       (0x00000010u)
+#define SPI_SPIFMT_PHASE_RESETVAL    (0x00000000u)
+
+#define SPI_SPIFMT_POLARITY_MASK     (0x00020000u)
+#define SPI_SPIFMT_POLARITY_SHIFT    (0x00000011u)
+#define SPI_SPIFMT_POLARITY_RESETVAL (0x00000000u)
+
+#define SPI_SPIFMT_SHIFTDIR_MASK     (0x00100000u)
+#define SPI_SPIFMT_SHIFTDIR_SHIFT    (0x00000014u)
+#define SPI_SPIFMT_SHIFTDIR_RESETVAL (0x00000000u)
+
+/* SPIGCR1 */
+
+#define SPI_SPIGCR1_SPIENA_MASK      (0x01000000u)
+#define SPI_SPIGCR1_SPIENA_SHIFT     (0x00000018u)
+#define SPI_SPIGCR1_SPIENA_RESETVAL  (0x00000000u)
+
+#define SPI_INTLVL_1				 (0x000001FFu)
+#define SPI_INTLVL_0				 (0x00000000u)
+
+/* SPIPC0 */
+
+#define SPI_SPIPC0_DIFUN_MASK        (0x00000800u)
+#define SPI_SPIPC0_DIFUN_SHIFT       (0x0000000Bu)
+#define SPI_SPIPC0_DIFUN_RESETVAL    (0x00000000u)
+
+/*----DIFUN Tokens----*/
+#define SPI_SPIPC0_DIFUN_DI          (0x00000001u)
+
+#define SPI_SPIPC0_DOFUN_MASK        (0x00000400u)
+#define SPI_SPIPC0_DOFUN_SHIFT       (0x0000000Au)
+#define SPI_SPIPC0_DOFUN_RESETVAL    (0x00000000u)
+
+/*----DOFUN Tokens----*/
+#define SPI_SPIPC0_DOFUN_DO          (0x00000001u)
+
+#define SPI_SPIPC0_CLKFUN_MASK       (0x00000200u)
+#define SPI_SPIPC0_CLKFUN_SHIFT      (0x00000009u)
+#define SPI_SPIPC0_CLKFUN_RESETVAL   (0x00000000u)
+
+/*----CLKFUN Tokens----*/
+#define SPI_SPIPC0_CLKFUN_CLK        (0x00000001u)
+
+#define SPI_SPIPC0_EN1FUN_MASK       (0x00000002u)
+#define SPI_SPIPC0_EN1FUN_SHIFT      (0x00000001u)
+#define SPI_SPIPC0_EN1FUN_RESETVAL   (0x00000000u)
+
+/*----EN1FUN Tokens----*/
+#define SPI_SPIPC0_EN1FUN_EN1        (0x00000001u)
+
+#define SPI_SPIPC0_EN0FUN_MASK       (0x00000001u)
+#define SPI_SPIPC0_EN0FUN_SHIFT      (0x00000000u)
+#define SPI_SPIPC0_EN0FUN_RESETVAL   (0x00000000u)
+
+/*----EN0FUN Tokens----*/
+#define SPI_SPIPC0_EN0FUN_EN0        (0x00000001u)
+
+#define SPI_SPIPC0_RESETVAL          (0x00000000u)
+#define SPI_SPIPC0_SPIENA		 (0x00000001u)
+#define SPI_SPIPC0_SPIENA_SHIFT	 (0x00000008u)
+
+#define SPI_SPIINT_MASKALL	         (0x000001FF)
+
+/* SPIDAT1 */
+
+#define SPI_SPIDAT1_CSHOLD_MASK      (0x10000000u)
+#define SPI_SPIDAT1_CSHOLD_SHIFT     (0x0000001Cu)
+#define SPI_SPIDAT1_CSHOLD_RESETVAL  (0x00000000u)
+
+#define SPI_SPIDAT1_CSNR_MASK        (0x00030000u)
+#define SPI_SPIDAT1_CSNR_SHIFT       (0x00000010u)
+#define SPI_SPIDAT1_CSNR_RESETVAL    (0x00000000u)
+
+#define SPI_SPIDAT1_DFSEL_MASK       (0x03000000u)
+#define SPI_SPIDAT1_DFSEL_SHIFT      (0x00000018u)
+#define SPI_SPIDAT1_DFSEL_RESETVAL   (0x00000000u)
+
+#define SPI_SPIFMT_CHARLEN_MASK      (0x0000001Fu)
+#define SPI_SPIFMT_CHARLEN_SHIFT     (0x00000000u)
+#define SPI_SPIFMT_CHARLEN_RESETVAL  (0x00000000u)
+
+#define SPI_SPIGCR1_CLKMOD_MASK      (0x00000002u)
+#define SPI_SPIGCR1_CLKMOD_SHIFT     (0x00000001u)
+#define SPI_SPIGCR1_CLKMOD_RESETVAL  (0x00000000u)
+
+#define SPI_SPIGCR1_MASTER_MASK      (0x00000001u)
+#define SPI_SPIGCR1_MASTER_SHIFT     (0x00000000u)
+#define SPI_SPIGCR1_MASTER_RESETVAL  (0x00000000u)
+
+#define SPI_SPIGCR1_LOOPBACK_MASK    (0x00010000u)
+#define SPI_SPIGCR1_LOOPBACK_SHIFT   (0x00000010u)
+#define SPI_SPIGCR1_LOOPBACK_RESETVAL (0x00000000u)
+
+#define SPI_SPIBUF_TXFULL_MASK       (0x20000000u)
+#define SPI_SPIBUF_TXFULL_SHIFT      (0x0000001Du)
+#define SPI_SPIBUF_TXFULL_RESETVAL   (0x00000000u)
+
+/* SPIBUF */
+
+#define SPI_SPIBUF_RXEMPTY_MASK      (0x80000000u)
+#define SPI_SPIBUF_RXEMPTY_SHIFT     (0x0000001Fu)
+#define SPI_SPIBUF_RXEMPTY_RESETVAL  (0x00000001u)
+
+#define SPI_SPIFLG_BITERRFLG_MASK    (0x00000010u)
+#define SPI_SPIFLG_BITERRFLG_SHIFT   (0x00000004u)
+#define SPI_SPIFLG_BITERRFLG_RESETVAL (0x00000000u)
+
+#define SPI_SPIFLG_OVRNINTFLG_MASK   (0x00000040u)
+#define SPI_SPIFLG_OVRNINTFLG_SHIFT  (0x00000006u)
+#define SPI_SPIFLG_OVRNINTFLG_RESETVAL (0x00000000u)
+
+#define SPI_SPIFLG_RXINTFLAG_MASK    (0x00000100u)
+#define SPI_SPIFLG_RXINTFLAG_SHIFT   (0x00000008u)
+#define SPI_SPIFLG_RXINTFLAG_RESETVAL (0x00000000u)
+
+#define SPI_SPIINT_DMA_REQ_EN	         (0x00010000u)
+#define SPI_SPIINT_RX_INTR	         (0x00000100u)
+#define SPI_SPIINT_TIMEOUT_INTR 	 (0x00000002u)
+#define SPI_SPIINT_PARERR_INTR	 (0x00000004u)
+#define SPI_SPIINT_DESYNC_INTR	 (0x00000008u)
+#define SPI_SPIINT_BITERR_INTR	 (0x00000010u)
+#define SPI_SPIINT_OVRRUN_INTR	 (0x00000040u)
+
+/**< Error return coded */
+#define SPI_ERROR_BASE 			(-30)
+#define SPI_RECEIVE_OVERRUN_ERR 	(SPI_ERROR_BASE-1)
+#define SPI_BIT_ERR		(SPI_ERROR_BASE-2)
+#define SPI_DESYNC_ERR         	(SPI_ERROR_BASE-3)
+#define SPI_PARITY_ERR		(SPI_ERROR_BASE-4)
+#define SPI_TIMEOUT_ERR		(SPI_ERROR_BASE-5)
+#define SPI_TRANSMIT_FULL_ERR	(SPI_ERROR_BASE-6)
+#define SPI_POWERDOWN		(SPI_ERROR_BASE-7)
+
+#define SPI_BYTELENGTH 8u
+
+/******************************************************************/
+
+enum spiPinOpMode {
+	SPI_OPMODE_3PIN = 0,
+	/**< SPI master 3 pin mode */
+	SPI_OPMODE_SPISCS_4PIN = 1,
+	/**< SPI master 4 pin mode uses SPISCS */
+	SPI_OPMODE_SPIENA_4PIN = 2,
+	/**< SPI master 4 pin mode uses SPIENA */
+	SPI_OPMODE_5PIN = 3
+    /**< SPI master 5 pin mode */
+};
+
+struct davinci_spi_config_t {
+	u32 op_mode;
+	u32 moduleInputClkFreq;
+	u32 spiBusFreq;
+	u32 clkInternal;
+	u32 csHold;
+	u32 delay;
+	u32 intrLevel;
+	enum spiPinOpMode pinOpModes;
+	u32 clkHigh;
+	u32 lsbFirst;
+	u32 oddParity;
+	u32 parityEnable;
+	u32 phaseIn;
+	u32 loopBack;
+};
+
+/* SPI Controller registers */
+
+struct davinci_spi_reg {
+	volatile __u32 __bitwise SPIGCR0;
+	volatile __u32 __bitwise SPIGCR1;
+	volatile __u32 __bitwise SPIINT;
+	volatile __u32 __bitwise SPILVL;
+	volatile __u32 __bitwise SPIFLG;
+	volatile __u32 __bitwise SPIPC0;
+	volatile __u32 __bitwise SPIPC1;
+	volatile __u32 __bitwise SPIPC2;
+	volatile __u32 __bitwise SPIPC3;
+	volatile __u32 __bitwise SPIPC4;
+	volatile __u32 __bitwise SPIPC5;
+	volatile __u32 __bitwise SPIPC6;
+	volatile __u32 __bitwise SPIPC7;
+	volatile __u32 __bitwise SPIPC8;
+	volatile __u32 __bitwise SPIDAT0;
+	volatile __u32 __bitwise SPIDAT1;
+	volatile __u32 __bitwise SPIBUF;
+	volatile __u32 __bitwise SPIEMU;
+	volatile __u32 __bitwise SPIDELAY;
+	volatile __u32 __bitwise SPIDEF;
+	volatile __u32 __bitwise SPIFMT[4];
+	volatile __u32 __bitwise TGINTVEC[2];
+	volatile __u8 __bitwise RSVD0[8];
+	volatile __u32 __bitwise MIBSPIE;
+};
+
+struct davinci_spi_slave {
+	u32 cmd_to_write;
+	u32 clk_ctrl_to_write;
+	u32 bytes_per_word;
+	u8 active_cs;
+};
+
+#define SPI_BUFSIZ      (SMP_CACHE_BYTES + 1)
+
+/* We have 2 DMA channels per CS, one for RX and one for TX */
+struct davinci_spi_dma {
+	int dma_tx_channel;
+	int dma_rx_channel;
+
+	int dma_tx_sync_dev;
+	int dma_rx_sync_dev;
+
+	struct completion dma_tx_completion;
+	struct completion dma_rx_completion;
+};
+
+/* SPI Controller driver's private data. */
+struct davinci_spi {
+	/* bitbang has to be first */
+	struct spi_bitbang bitbang;
+	struct completion done;
+
+	struct davinci_spi_reg __iomem *base;
+
+	/* rx & tx bufs from the spi_transfer */
+	const void *tx;
+	void *rx;
+
+	u8 *tmp_buf;
+
+	/* functions to deal with different sized buffers */
+	void (*get_rx) (u32 rx_data, struct davinci_spi *);
+	 u32(*get_tx) (struct davinci_spi *);
+
+	int count;
+	u32 irq;
+
+	u32 nsecs;		/* (clock cycle time)/2 */
+	u32 sysclk;
+	u32 vbus_freq;
+
+	/* chip select activation deactivation */
+	int (*activate_cs) (u8 cs, u8 polarity,
+			    struct ctlr_cs_sel_t *ctlr_cs_sel);
+	int (*deactivate_cs) (u8 cs, u8 polarity,
+			      struct ctlr_cs_sel_t *ctlr_cs_sel);
+
+	struct davinci_spi_slave slave[DAVINCI_SPI_MAX_CHIPSELECT];
+	struct spi_device *spi;
+
+	struct davinci_spi_dma *dma_channels;
+};
Index: linux-2.6.10/include/linux/spi/eeprom.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/spi/eeprom.h
@@ -0,0 +1,38 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_SPI_EEPROM_H
+#define __LINUX_SPI_EEPROM_H
+
+/*
+ * Put one of these structures in platform_data for SPI EEPROMS handled
+ * by the "at25" driver.  On SPI, most EEPROMS understand the same core
+ * command set.  If you need to support EEPROMs that don't yet fit, add
+ * flags to support those protocol options.  These values all come from
+ * the chip datasheets.
+ */
+struct spi_eeprom {
+	u32 byte_len;
+	char name[10];
+	u16 page_size;		/* for writes */
+	u16 flags;
+#define	EE_ADDR1	0x0001	/*  8 bit addrs */
+#define	EE_ADDR2	0x0002	/* 16 bit addrs */
+#define	EE_ADDR3	0x0004	/* 24 bit addrs */
+#define	EE_READONLY	0x0008	/* disallow writes */
+};
+
+#endif				/* __LINUX_SPI_EEPROM_H */
Index: linux-2.6.10/drivers/mtd/devices/at25xxA_eeprom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/devices/at25xxA_eeprom.c
@@ -0,0 +1,285 @@
+/*
+ * Davinci SPI-EEPROM client driver
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/uaccess.h>
+
+#include <linux/spi/at25xxA_eeprom.h>
+#include <linux/spi/davinci_spi_master.h>
+
+/*
+ *  Utilities functions
+ */
+static int spi_generic_config(struct davinci_spi_config_t *spi_cfg)
+{
+	if (spi_cfg == NULL) {
+		printk(KERN_INFO "spi_cfg = NULL\n");
+		return -1;
+	}
+
+	spi_cfg->clkInternal = TRUE;
+	spi_cfg->csHold = TRUE;
+	spi_cfg->intrLevel = FALSE;
+	spi_cfg->pinOpModes = SPI_OPMODE_SPISCS_4PIN;
+	spi_cfg->clkHigh = FALSE;
+	spi_cfg->lsbFirst = FALSE;
+	spi_cfg->parityEnable = TRUE;
+	spi_cfg->oddParity = FALSE;
+	spi_cfg->phaseIn = TRUE;
+	spi_cfg->op_mode = TRUE;	/*Polling -> FALSE, Interrupt -> TRUE */
+	spi_cfg->loopBack = FALSE;	/* loopback is disabled */
+
+}
+static int spi_generic_eeprom_read(struct mtd_info *mtd, loff_t from,
+				   size_t count, size_t *retlen, u_char *buf)
+{
+	u8 *tx_ptr, *rx_ptr;
+	int rx_cnt;
+	unsigned int addr;
+	unsigned long flags;
+	struct spi_transfer x[2];
+	struct spi_message msg;
+	struct davinci_eeprom_info *priv_dat = mtd->priv;
+
+	addr = (u16) from;
+	*retlen = 0;
+	if (addr > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if (count > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if ((addr + count) > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	memset(x, 0, sizeof x);
+	down(&priv_dat->lock);
+	x[0].tx_buf = tx_ptr = priv_dat->tx_buffer;
+
+	tx_ptr[0] = DAVINCI_EEPROM_READ;
+
+	x[0].len = 3;
+
+	/* Handle data return from EEPROM */
+	x[1].rx_buf = rx_ptr = priv_dat->rx_buffer;
+
+	while (count > 0) {
+		if (likely(count > SPI_BUFFER_SIZE))
+			rx_cnt = SPI_BUFFER_SIZE;
+		else
+			rx_cnt = count;
+
+		spi_message_init(&msg);
+		/* setup read command */
+		tx_ptr[1] = (addr >> 8) & 0xFF;
+		tx_ptr[2] = (addr & 0xFF);
+
+		local_irq_save(flags);
+		spi_message_add_tail(&x[0], &msg);
+
+		/* read the eeprom */
+		x[1].len = rx_cnt;
+		spi_message_add_tail(&x[1], &msg);
+		local_irq_restore(flags);
+
+		spi_sync(priv_dat->spi, &msg);
+
+		/* spi_read(priv_dat->spi, rx_ptr, rx_cnt); */
+		memcpy(buf, rx_ptr, rx_cnt);
+
+		buf += rx_cnt;
+		count -= rx_cnt;
+		addr += rx_cnt;
+		*retlen += rx_cnt;
+	}
+	up(&priv_dat->lock);
+
+	return 0;
+}
+
+static int spi_generic_eeprom_write(struct mtd_info *mtd, loff_t to,
+				    size_t count, size_t *retlen,
+				    const u_char *buf)
+{
+	char *ptr;
+	int status;
+	int tx_cnt;
+	unsigned int addr;
+	struct spi_transfer xfer[2];
+	struct spi_message msg;
+	struct davinci_eeprom_info *priv_dat = mtd->priv;
+	unsigned long flags;
+
+	addr = (u16) (to);
+	*retlen = 0;
+	memset(xfer, 0, sizeof xfer);
+	if (addr > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if (count > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if ((addr + count) > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	down(&priv_dat->lock);
+	while (count > 0) {
+		xfer[0].tx_buf = ptr = priv_dat->tx_buffer;
+
+		/* set write enable */
+		ptr[0] = DAVINCI_EEPROM_WREN;
+		spi_write(priv_dat->spi, ptr, 1);
+
+		spi_message_init(&msg);
+
+		/* set the write command */
+		ptr[0] = DAVINCI_EEPROM_WRITE;
+		ptr[1] = (addr >> 8) & 0xFF;
+		ptr[2] = (addr & 0xFF);
+		xfer[0].len = DAVINCI_SPI_TX_CMD_SIZE;
+		local_irq_save(flags);
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* figure out the max transfer within a page */
+		tx_cnt = priv_dat->page_size - (addr & priv_dat->page_mask);
+
+		if (count < tx_cnt)
+			tx_cnt = count;
+
+		ptr = &priv_dat->tx_buffer[DAVINCI_SPI_TX_CMD_SIZE];
+		xfer[1].tx_buf = ptr;
+		xfer[1].len = tx_cnt;
+		memcpy(ptr, buf, tx_cnt);
+		spi_message_add_tail(&xfer[1], &msg);
+		local_irq_restore(flags);
+		status = spi_sync(priv_dat->spi, &msg);
+
+		count -= tx_cnt;
+		buf += tx_cnt;
+		addr += tx_cnt;
+		*retlen += tx_cnt;
+		/* Some SPI-EEPROM (CSI for example) starts an internal
+		   transfer (from buffer to EEPROM) when WREN is disalbed.
+		   All requrests are ignored until the transfer is completed.
+		   This delay ensure no data is lost */
+		if (priv_dat->commit_delay)
+			mdelay(priv_dat->commit_delay);
+	}
+	up(&priv_dat->lock);
+
+	return (0);
+}
+
+static int spi_eeprom_generic_erase(struct mtd_info *mtd,
+				    struct erase_info *instr)
+{
+	return 0;
+}
+
+static struct mtd_info davinci_at25;
+
+static int __devinit eeprom_probe(struct spi_device *spi)
+{
+	int ret;
+	static struct mtd_info *mtd;
+	struct davinci_eeprom_info *info;
+
+	mtd = &davinci_at25;
+	memset(mtd, 0, sizeof(struct mtd_info));
+
+	/* are there any id we need to read? */
+	info = spi->dev.platform_data;
+	info->spi = spi;
+	spi_generic_config(spi->controller_data);
+	info->spi_data = spi_master_get_devdata(spi->master);
+	init_MUTEX(&info->lock);
+
+	mtd->priv = info;
+	mtd->size = info->eeprom_size;
+	mtd->flags = MTD_CAP_RAM;
+	mtd->read = spi_generic_eeprom_read;
+	mtd->write = spi_generic_eeprom_write;
+	mtd->erase = spi_eeprom_generic_erase;
+	mtd->type = MTD_RAM;
+	mtd->name = "spi_eeprom";
+	mtd->erasesize = 0x10;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = add_mtd_partitions(mtd, info->parts, info->nr_parts);
+	else
+		ret = add_mtd_device(mtd);
+#else
+	ret = add_mtd_device(mtd);
+#endif
+
+	if (ret < 0) {
+		printk(KERN_INFO "at25xxA_spi_eeprom device register failed\n");
+	}
+	return ret;
+}
+
+static int __devexit eeprom_remove(struct spi_device *spi)
+{
+	int ret;
+	struct mtd_info *mtd;
+	struct davinci_eeprom_info *info;
+
+	mtd = &davinci_at25;
+	info = spi->dev.platform_data;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = del_mtd_partitions(mtd);
+	else
+		ret = del_mtd_device(mtd);
+#else
+	ret = del_mtd_device(mtd);
+#endif
+
+	return ret;
+}
+
+static struct spi_driver spi_eeprom_driver = {
+	.driver = {
+		   .name = DAVINCI_SPI_EEPROM_NAME,
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = eeprom_probe,
+	.remove = eeprom_remove,
+};
+
+static int __init spi_eeprom_init(void)
+{
+	return spi_register_driver(&spi_eeprom_driver);
+}
+
+module_init(spi_eeprom_init);
+
+static void __exit spi_eeprom_exit(void)
+{
+	spi_unregister_driver(&spi_eeprom_driver);
+}
+
+module_exit(spi_eeprom_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steve Chen");
+MODULE_DESCRIPTION("SPI EEPROM driver");
Index: linux-2.6.10/arch/arm/mach-davinci/davinci_spi_platform.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/arm/mach-davinci/davinci_spi_platform.c
@@ -0,0 +1,245 @@
+/*
+ * TI DaVinci EVM board
+ *
+ * Copyright (C) 2007 Texas Instruments.
+ * Copyright (C) 2007 Monta Vista Software Inc.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ *  This file came directly from spi_platform_init.c.  This file has been
+ *  generalized to all DaVinci variants.  This file should replace
+ *  spi_platform_init.c
+ *
+ */
+
+/*
+ * Platform device support for TI SoCs.
+ *
+ */
+#include <linux/config.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/davinci_spi.h>
+#include <linux/spi/flash.h>
+#include <linux/device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/arch/hardware.h>
+#include <linux/spi/at25xxA_eeprom.h>
+#include <linux/spi/davinci_spi_master.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+
+static struct davinci_spi_platform_data dm355_spi_platform_data = {
+	.initial_spmode = 0,
+	.bus_num = -1,
+	.max_chipselect = 2,
+	.activate_cs = NULL,
+	.deactivate_cs = NULL,
+	.sysclk = 108 * 1000 * 1000,
+};
+
+static struct davinci_spi_platform_data dm646x_spi_platform_data = {
+	.initial_spmode = 0,
+	.bus_num = -1,
+	.max_chipselect = 2,
+	.activate_cs = NULL,
+	.deactivate_cs = NULL,
+	.sysclk = 67.5 * 1000 * 1000,
+};
+
+static struct resource dm646x_spi_resources[] = {
+	[0] = {
+	       .start = DAVINCI_SPI_BASE,
+	       .end = DAVINCI_SPI_BASE + (SZ_4K/2),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_SPINT0,
+	       .end = IRQ_SPINT0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct resource dm355_spi_resources[] = {
+	[0] = {
+	       .start = DAVINCI_DM355_SPI0_BASE,
+	       .end = DAVINCI_DM355_SPI0_BASE + (SZ_4K/2),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_DM355_SPINT0_0,
+	       .end = IRQ_DM355_SPINT0_0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct platform_device davinci_spi_device = {
+	.name = "dm_spi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(dm646x_spi_resources),
+	.resource = dm646x_spi_resources,
+};
+
+#if defined (CONFIG_DAVINCI_SPI_EEPROM_MODULE) || \
+    defined (CONFIG_DAVINCI_SPI_EEPROM)
+static struct mtd_partition spi_partitions[] = {
+	/* UBL in first sector */
+	{
+	 .name = "UBL",
+	 .offset = 0,
+	 .size = SZ_16K,
+	 .mask_flags = MTD_WRITEABLE,
+	 },
+	/* User data in the next sector */
+	{
+	 .name = "data",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,
+	 .mask_flags = 0,
+	 }
+};
+
+struct davinci_eeprom_info davinci_8k_spi_eeprom_info = {
+	.eeprom_size = 8192,
+	.page_size = 32,
+	.page_mask = 0x001F,
+	.chip_sel = SCS0_SELECT,
+	.parts = NULL,
+	.nr_parts = 0,
+	.commit_delay = 3,
+};
+
+struct davinci_eeprom_info davinci_32k_spi_eeprom_info = {
+	.eeprom_size = 32768,
+	.page_size = 64,
+	.page_mask = 0x003F,
+	.chip_sel = SCS0_SELECT,
+	.parts = spi_partitions,
+	.nr_parts = ARRAY_SIZE(spi_partitions),
+	.commit_delay = 5,
+};
+#endif
+
+/*Put slave specific information in this array.*/
+/*For more information refer the table at the end of file tnetd84xx_spi_cs.c*/
+static struct spi_board_info dm6467_spi_board_info[] = {
+#if defined (CONFIG_DAVINCI_SPI_EEPROM_MODULE) || \
+    defined (CONFIG_DAVINCI_SPI_EEPROM)
+	{
+	 .modalias = DAVINCI_SPI_EEPROM_NAME,
+	 .platform_data = &davinci_32k_spi_eeprom_info,
+	 .mode = SPI_MODE_0,
+	 .irq = 0,
+	 .max_speed_hz = 2 * 1000 * 1000 /* max sample rate at 3V */ ,
+	 .bus_num = 65535,
+	 .chip_select = 0,
+	 },
+#endif
+};
+
+static struct spi_board_info dm355_spi_board_info[] = {
+#if defined (CONFIG_DAVINCI_SPI_EEPROM_MODULE) || \
+    defined (CONFIG_DAVINCI_SPI_EEPROM)
+	{
+	 .modalias = DAVINCI_SPI_EEPROM_NAME,
+	 .platform_data = &davinci_8k_spi_eeprom_info,
+	 .mode = SPI_MODE_0,
+	 .irq = 0,
+	 .max_speed_hz = 2 * 1000 * 1000 /* max sample rate at 3V */ ,
+	 .bus_num = 65535,
+	 .chip_select = 0,
+	 },
+#endif
+#if defined (CONFIG_LOOPBACK_SPI_MODULE) || defined (CONFIG_LOOPBACK_SPI)
+	{
+	 .modalias = "LOOPB",
+	 .platform_data = &eeprom1_info,
+	 .mode = SPI_MODE_0,
+	 .irq = 0,
+	 .max_speed_hz = 2 * 1000 * 1000 /* max sample rate at 3V */ ,
+	 .bus_num = 0,
+	 .chip_select = 0,
+	 },
+#endif
+#if defined (CONFIG_DLCD_SPI) || defined (CONFIG_DLCD_SPI_MODULE)
+	{
+	 .modalias = "DLCD_SPI",
+	 .platform_data = &eeprom1_info,
+	 .mode = SPI_MODE_0,
+	 .irq = 0,
+	 .max_speed_hz = 2 * 1000 * 1000 /* max sample rate at 3V */ ,
+	 .bus_num = 0,
+	 .chip_select = 0,
+	 },
+#endif
+};
+
+/*
+ * This function initializes the GPIOs used by the SPI module
+ * and it also registers the spi mastere device with the platform
+ * and the spi slave devices with the spi bus
+ */
+static int __init davinci_spi_board_init(void)
+{
+	int ret = 0;
+	int size;
+	struct spi_board_info *davinci_board_info;
+
+	if (cpu_is_davinci_dm6467()) {
+		davinci_board_info = dm6467_spi_board_info;
+		size = ARRAY_SIZE(dm6467_spi_board_info);
+		davinci_spi_device.resource = dm646x_spi_resources;
+		davinci_spi_device.num_resources =
+		    ARRAY_SIZE(dm646x_spi_resources);
+		davinci_spi_device.dev.platform_data =
+		    &dm646x_spi_platform_data;
+	} else if (cpu_is_davinci_dm355()) {
+		davinci_board_info = dm355_spi_board_info;
+		size = ARRAY_SIZE(dm355_spi_board_info);
+		davinci_spi_device.resource = dm355_spi_resources;
+		davinci_spi_device.num_resources =
+		    ARRAY_SIZE(dm355_spi_resources);
+		davinci_spi_device.dev.platform_data = &dm355_spi_platform_data;
+	} else {
+		printk (KERN_INFO "davinci_spi_board_init: NO spi support\n");
+		return 0;
+	}
+
+	/* Register the slave devices present in the board with SPI subsytem */
+	ret = spi_register_board_info(davinci_board_info, size);
+
+	/* Register the master controller with platform */
+	(void)platform_device_register(&davinci_spi_device);
+
+	return 0;
+}
+
+static void __exit davinci_spi_board_exit(void)
+{
+	/* nothing to be done */
+}
+
+module_init(davinci_spi_board_init);
+module_exit(davinci_spi_board_exit);
Index: linux-2.6.10/mvl_patches/pro-1663.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1663.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1663);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

