#! /usr/bin/env bash
# Patch: -pro_ppc440epx_sequoia
# Date: Tue Mar  6 16:11:41 2007
# Source: AMCC
# MR: 21052
# Type: Enhancement
# Disposition: backport of http://www.amcc.com/Embedded/Downloads/440EPx
# Signed-off-by: Valentine Barshak <vbarshak@ru.mvista.com>
# Description:
#     The patch adds initial support for the PPC440EPx Sequoia/PPC440GRx Rainier 
#     evaluation boards.
# 

PATCHNUM=1182
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: AMCC
MR: 21052
Type: Enhancement
Disposition: backport of http://www.amcc.com/Embedded/Downloads/440EPx
Signed-off-by: Valentine Barshak <vbarshak@ru.mvista.com>
Description:
    The patch adds initial support for the PPC440EPx Sequoia/PPC440GRx Rainier 
    evaluation boards.

Index: linux-2.6.10/arch/ppc/kernel/cputable.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/kernel/cputable.c
+++ linux-2.6.10/arch/ppc/kernel/cputable.c
@@ -872,6 +872,8 @@ struct cpu_spec	cpu_specs[] = {
 
 #endif /* CONFIG_40x */
 #ifdef CONFIG_44x
+#ifdef CONFIG_440EP
+	/* AMCC 440EP Rev. B has same PVR as 440GR Rev. A */
 	{
 		.pvr_mask		= 0xf0000fff,
 		.pvr_value		= 0x40000850,
@@ -885,13 +887,85 @@ struct cpu_spec	cpu_specs[] = {
 	{
 		.pvr_mask		= 0xf0000fff,
 		.pvr_value		= 0x400008d3,
-		.cpu_name		= "440EP Rev. B",
+		.cpu_name		= "440EP Rev.2.0",
 		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
 			CPU_FTR_USE_TB,
 		.cpu_user_features	= COMMON_PPC, /* 440EP has an FPU */
 		.icache_bsize		= 32,
 		.dcache_bsize		= 32,
 	},
+	{
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x400008d4,
+		.cpu_name		= "440EP Rev.2.1",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= COMMON_PPC, /* 440EP has an FPU */
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+#else /* CONFIG_440GR */
+	{
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x400008d3,
+		.cpu_name		= "440GR Rev. A",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= PPC_FEATURE_32 | PPC_FEATURE_HAS_MMU,
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+	{
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x400008d4,
+		.cpu_name		= "440GR Rev.B",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= PPC_FEATURE_32 | PPC_FEATURE_HAS_MMU,
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+#endif /* CONFIG_440EP */
+	{ /* 440EPX  - with Security/Kasumi  */
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x200008D0,
+		.cpu_name		= "440EPX - with Security/Kasumi",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= COMMON_PPC, /* 440EPX has an FPU */
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+	{ /* 440EPX  - without Security/Kasumi  */
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x200008D4,
+		.cpu_name		= "440EPX - no Security/Kasumi",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= COMMON_PPC, /* 440EPX has an FPU */
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+	{ /* 440GRX  - with Security/Kasumi  */
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x200008D8,
+		.cpu_name		= "440GRX - with Security/Kasumi",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= PPC_FEATURE_32 | PPC_FEATURE_HAS_MMU, /* 440GRX has no FPU */
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
+	{ /* 440GRX  - without Security/Kasumi  */
+		.pvr_mask		= 0xf0000fff,
+		.pvr_value		= 0x200008DC,
+		.cpu_name		= "440GRX - no Security/Kasumi",
+		.cpu_features		= CPU_FTR_SPLIT_ID_CACHE |
+			CPU_FTR_USE_TB,
+		.cpu_user_features	= PPC_FEATURE_32 | PPC_FEATURE_HAS_MMU, /* 440GRX has no FPU */
+		.icache_bsize		= 32,
+		.dcache_bsize		= 32,
+	},
 	{ 	/* 440GP Rev. B */
 		.pvr_mask		= 0xf0000fff,
 		.pvr_value		= 0x40000440,
Index: linux-2.6.10/arch/ppc/kernel/head_44x.S
===================================================================
--- linux-2.6.10.orig/arch/ppc/kernel/head_44x.S
+++ linux-2.6.10/arch/ppc/kernel/head_44x.S
@@ -230,7 +230,16 @@ skpinv:	addi	r4,r4,1				/* Increment */
 	lis	r4,interrupt_base@h	/* IVPR only uses the high 16-bits */
 	mtspr	SPRN_IVPR,r4
 
-#ifdef CONFIG_440EP
+#if defined(CONFIG_440GR) || (defined(CONFIG_440GRX)) ||	\
+	(defined(CONFIG_440EPX) && !defined(CONFIG_PPC_FPU))
+  /* Set DAPUIB flag in CCR0 (disable APU between CPU and FPU) */
+	mfspr	r2,SPRN_CCR0
+	oris	r2,r2,0x0010
+	mtspr	SPRN_CCR0,r2
+	isync
+#endif
+#if (defined(CONFIG_440EP) || (defined(CONFIG_440EPX)) &&	\
+	defined (CONFIG_PPC_FPU))
 	/* Clear DAPUIB flag in CCR0 (enable APU between CPU and FPU) */
 	mfspr	r2,SPRN_CCR0
 	lis	r3,0xffef
Index: linux-2.6.10/arch/ppc/platforms/4xx/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/4xx/Kconfig
+++ linux-2.6.10/arch/ppc/platforms/4xx/Kconfig
@@ -88,11 +88,21 @@ config YOSEMITE
 	help
 	  This option enables support for the AMCC PPC440EP evaluation board.
 
+config SEQUOIA
+	bool "Sequoia"
+	help
+	  This option enables support for the AMCC PPC440EPX evaluation board.
+
 config YELLOWSTONE
 	bool "Yellowstone"
 	help
 	  This option enables support for the AMCC PPC440GR evaluation board.
 
+config RAINIER
+	bool "Rainier"
+	help
+	  This option enables support for the AMCC PPC440GRX evaluation board.
+
 config EBONY
 	bool "Ebony"
 	help
@@ -129,6 +139,12 @@ config 440EP
 	select PPC_FPU
 	default y
 
+config 440EPX
+	bool
+	depends on SEQUOIA
+	select PPC_FPU
+	default y
+
 config 440GP
 	bool
 	depends on EBONY
@@ -139,6 +155,11 @@ config 440GR
 	depends on YELLOWSTONE
 	default y
 
+config 440GRX
+	bool
+	depends on RAINIER
+	default y
+
 config 440GX
 	bool
 	depends on OCOTEA
@@ -156,7 +177,7 @@ config 440
 
 config 440A
 	bool
-	depends on 440GX
+	depends on 440GX || 440EPX || 440GRX
 	default y
 
 config IBM440EP_ERR42
@@ -183,7 +204,7 @@ config BOOKE
 
 config IBM_OCP
 	bool
-	depends on ASH || BAMBOO || YOSEMITE || YELLOWSTONE || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ASH || BAMBOO || YOSEMITE || YELLOWSTONE || BUBINGA || CPCI405 || EBONY || EP405 || LUAN || OCOTEA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT || SEQUOIA || RAINIER
 	default y
 
 config XILINX_OCP
@@ -193,9 +214,14 @@ config XILINX_OCP
 
 config IBM_EMAC4
 	bool
-	depends on 440GX || 440SP
+	depends on 440GX || 440SP || 440EPX || 440GRX
 	default y
 
+config IBM_EMAC4V4
+	bool
+	depends on 440EPX || 440GRX
+ 	default y
+
 config BIOS_FIXUP
 	bool
 	depends on BUBINGA || EP405 || SYCAMORE || WALNUT
Index: linux-2.6.10/arch/ppc/platforms/4xx/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/platforms/4xx/Makefile
+++ linux-2.6.10/arch/ppc/platforms/4xx/Makefile
@@ -5,6 +5,8 @@ obj-$(CONFIG_ASH)		+= ash.o
 obj-$(CONFIG_BAMBOO)		+= bamboo.o
 obj-$(CONFIG_YOSEMITE)		+= yosemite.o
 obj-$(CONFIG_YELLOWSTONE)	+= yosemite.o
+obj-$(CONFIG_SEQUOIA)		+= sequoia.o
+obj-$(CONFIG_RAINIER)		+= sequoia.o
 obj-$(CONFIG_CPCI405)		+= cpci405.o
 obj-$(CONFIG_EBONY)		+= ebony.o
 obj-$(CONFIG_EP405)		+= ep405.o
@@ -32,3 +34,5 @@ obj-$(CONFIG_440SP)		+= ibm440sp.o
 obj-$(CONFIG_405EP)		+= ibm405ep.o
 obj-$(CONFIG_405GPR)		+= ibm405gpr.o
 obj-$(CONFIG_XILINX_VIRTEX)	+= virtex.o
+obj-$(CONFIG_440EPX)		+= ppc440epx.o
+obj-$(CONFIG_440GRX)		+= ppc440epx.o
Index: linux-2.6.10/arch/ppc/platforms/4xx/ppc440epx.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/4xx/ppc440epx.c
@@ -0,0 +1,318 @@
+/*
+ * arch/ppc/platforms/4xx/amcc440epx.c
+ *
+ * PPC440EPX I/O descriptions
+ *
+ * Wade Farnsworth <wfarnsworth@mvista.com>
+ * Copyright 2004 MontaVista Software Inc.
+ * Copyright 2006 AMCC
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ * DONE : changed ibm440ep in amcc440epx
+ * TO DO : check Ethernet
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <platforms/4xx/ppc440epx.h>
+#include <asm/ocp.h>
+#include <asm/ppc4xx_pic.h>
+
+static struct ocp_func_emac_data amcc440epx_emac0_def = {
+	.rgmii_idx	= 0,            /* RGMII device index */
+	.rgmii_mux	= 0,
+	.mal_idx        = 0,            /* MAL device index */
+	.mal_rx_chan    = 0,            /* MAL rx channel number */
+	.mal_tx_chan    = 0,            /* MAL tx channel number */
+	.wol_irq        = 61,		/* WOL interrupt number - same as 440EP*/
+	.mdio_idx       = -1,           /* No shared MDIO but always via ZMII bridge */
+	.tah_idx	= -1,           /* No TAH */
+#ifdef	CONFIG_INTR_COALESCE
+	.txcoal_irq 	= 70,  		/* Interrupt coalescence TX IRQ  */
+	.rxcoal_irq 	= 72,  		/* Interrupt coalescence RX IRQ  */
+#endif
+
+};
+
+static struct ocp_func_emac_data amcc440epx_emac1_def = {
+	.rgmii_idx	= 0,            /* RGMII */
+	.rgmii_mux	= 1,            /* RGMII */
+	.mal_idx        = 0,            /* MAL device index */
+	.mal_rx_chan    = 1,            /* MAL rx channel number */
+	.mal_tx_chan    = 1,            /* MAL tx channel number */
+	.wol_irq        = 63,  		/* WOL interrupt number _- same as 440EP     */
+	.mdio_idx       = -1,           /* no shared MDIO but always via ZMII bridge */
+	.tah_idx	= -1,           /* No TAH */
+#ifdef	CONFIG_INTR_COALESCE
+	.txcoal_irq 	= 71,  		/* Interrupt coalescence TX IRQ  */
+	.rxcoal_irq 	= 73,  		/* Interrupt coalescence RX IRQ  */
+#endif
+};
+OCP_SYSFS_EMAC_DATA()
+
+static struct ocp_func_mal_data amcc440epx_mal0_def = {
+	.num_tx_chans   = 2,  		/* Number of TX channels */
+	.num_rx_chans   = 2,    	/* Number of RX channels */
+	.txeob_irq	= 10,		/* TX End Of Buffer IRQ  - same as 440EP */
+	.rxeob_irq	= 11,		/* RX End Of Buffer IRQ  - same as 440EP*/
+	.txde_irq	  = 33,		/* TX Descriptor Error IRQ - same as 440EP */
+	.rxde_irq	  = 34,		/* RX Descriptor Error IRQ - same as 440EP*/
+	.serr_irq	  = 32,		/* MAL System Error IRQ  - same as 440EP   */
+	.dcr_base	= DCRN_MAL_BASE /* MAL0_CFG DCR number */
+};
+OCP_SYSFS_MAL_DATA()
+
+static struct ocp_func_iic_data amcc440epx_iic0_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+
+static struct ocp_func_iic_data amcc440epx_iic1_def = {
+	.fast_mode	= 0,		/* Use standad mode (100Khz) */
+};
+OCP_SYSFS_IIC_DATA()
+
+struct ocp_def core_ocp[] = {
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_OPB,
+	  .index	= 0,
+	  .paddr	= 0x1EF600000ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 0,
+	  .paddr	= PPC440EPX_UART0_ADDR,
+	  .irq		= UART0_INT,
+	  .pm		= IBM_CPM_UART0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 1,
+	  .paddr	= PPC440EPX_UART1_ADDR,
+	  .irq		= UART1_INT,
+	  .pm		= IBM_CPM_UART1,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 2,
+	  .paddr	= PPC440EPX_UART2_ADDR,
+	  .irq		= UART2_INT,
+	  .pm		= IBM_CPM_UART2,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_16550,
+	  .index	= 3,
+	  .paddr	= PPC440EPX_UART3_ADDR,
+	  .irq		= UART3_INT,
+	  .pm		= IBM_CPM_UART3,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .index	= 0,
+	  .paddr	= 0x1EF600700ULL,
+	  .irq		= IIC0_INT,
+	  .pm		= IBM_CPM_IIC0,
+	  .additions	= &amcc440epx_iic0_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_IIC,
+	  .index	= 1,
+	  .paddr	= 0x1EF600800ULL,
+	  .irq		= IIC1_INT,
+	  .pm		= IBM_CPM_IIC1,
+	  .additions	= &amcc440epx_iic1_def,
+	  .show		= &ocp_show_iic_data
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_GPIO,
+	  .index	= 0,
+	  .paddr	= 0x1EF600B00ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= IBM_CPM_GPIO0,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_GPIO,
+	  .index	= 1,
+	  .paddr	= 0x1EF600C00ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_MAL,
+	  .paddr	= OCP_PADDR_NA,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	  .additions	= &amcc440epx_mal0_def,
+	  .show		= &ocp_show_mal_data,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_EMAC,
+	  .index	= 0,
+	  .paddr	= 0x1EF600E00ULL,
+	  .irq		= EMAC0_INT,
+	  .pm		= OCP_CPM_NA,
+	  .additions	= &amcc440epx_emac0_def,
+	  .show		= &ocp_show_emac_data,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_EMAC,
+	  .index	= 1,
+	  .paddr	= 0x1EF600F00ULL,
+	  .irq		= EMAC1_INT,
+	  .pm		= OCP_CPM_NA,
+	  .additions	= &amcc440epx_emac1_def,
+	  .show		= &ocp_show_emac_data,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_ZMII,
+	  .paddr	= 0x1EF600D00ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_IBM,
+	  .function	= OCP_FUNC_RGMII,
+	  .paddr	= 0x1EF601000ULL,
+	  .irq		= OCP_IRQ_NA,
+	  .pm		= OCP_CPM_NA,
+	},
+	{ .vendor	= OCP_VENDOR_INVALID
+	}
+};
+
+/* Polarity and triggering settings for internal interrupt sources */
+/* 3 UIC */
+struct ppc4xx_uic_settings ppc4xx_core_uic_cfg[] __initdata = {
+	{ .polarity	= 0xffbff1ef,
+	  .triggering   = 0x00000800,
+	  .ext_irq_mask = 0x000000010,	/* IRQ4 */
+	},
+	{ .polarity	= 0xffffe7A5,
+	  .triggering	= 0x06000040,
+	  .ext_irq_mask = 0x0000380A,	/* IRQ7-IRQ8-IRQ9-IRQ0-IRQ1 */
+	},
+	{ .polarity	= 0x27ffffff,
+	  .triggering	= 0x03e00000,
+	  .ext_irq_mask = 0xd8000000,	/* IRQ5-IRQ6-IRQ2-IRQ3*/
+	},
+};
+
+static struct resource usb_gadget_resources[] = {
+	[0] = {
+		.start	= 0x0E0000100ULL,
+		.end 	= 0x0E000017FULL,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name	= "usb_device_irq",
+		.start	= 20,
+		.end	= 20,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ohci_usb_resources[] = {
+	[0] = {
+		.start	= 0x0E0000400,
+		.end	= 0x0E00004FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 21,
+		.end	= 21,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ehci_usb_resources[] = {
+	[0] = {
+		.start	= 0x0E0000300,
+		.end	= 0x0E00003FF,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 26,
+		.end	= 26,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource spi_resources[] = {
+	/*
+	 * SPI memory resource should be added
+	 * when 64-bit resources are supported
+	 * start	= 0x1EF600900ULL,
+	 * end		= 0x1EF600906ULL,
+	 * flags	= IORESOURCE_MEM,
+	 */
+	[0] = {
+		.start	= 8,
+		.end	= 8,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 dma_mask = 0xffffffffULL;
+
+static struct platform_device ohci_usb_device = {
+	.name		= "ppc-soc-ohci",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(ohci_usb_resources),
+	.resource	= ohci_usb_resources,
+	.dev		= {
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xffffffffULL,
+	}
+};
+
+static struct platform_device usb_gadget_device = {
+	.name		= "musbhsfc_udc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(usb_gadget_resources),
+	.resource       = usb_gadget_resources,
+	.dev		= {
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xffffffffULL,
+	}
+};
+
+static struct platform_device ehci_usb_device = {
+	.name		= "ppc-soc-ehci",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(ehci_usb_resources),
+	.resource	= ehci_usb_resources,
+	.dev		= {
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xffffffffULL,
+	}
+};
+
+static struct platform_device spi_device = {
+	.name		= "ppc-soc-spi",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(spi_resources),
+	.resource	= spi_resources,
+	.dev		= {
+		.dma_mask = &dma_mask,
+		.coherent_dma_mask = 0xffffffffULL,
+	}
+};
+
+static struct platform_device *amcc440epx_devs[] __initdata = {
+	&ohci_usb_device,
+	&ehci_usb_device,
+	&usb_gadget_device,
+	&spi_device,
+};
+
+
+static int __init
+amcc440epx_platform_add_devices(void)
+{
+	return platform_add_devices(amcc440epx_devs, ARRAY_SIZE(amcc440epx_devs));
+}
+arch_initcall(amcc440epx_platform_add_devices);
+
Index: linux-2.6.10/arch/ppc/platforms/4xx/ppc440epx.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/4xx/ppc440epx.h
@@ -0,0 +1,184 @@
+/*
+ * arch/ppc/platforms/4xx/amcc440epx.h
+ *
+ * PPC440EPX definitions
+ *
+ *
+ * Copyright 2002 Roland Dreier
+ * Copyright 2004 MontaVista Software, Inc.
+ * Copyright 2006 AMCC.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __PPC_PLATFORMS_AMCC440EPX_H
+#define __PPC_PLATFORMS_AMCC440EPX_H
+
+#include <linux/config.h>
+#include <asm/ibm44x.h>
+/*Interrupt Assignements - used in OCP table definition */
+#define IIC0_INT     2
+#define IIC1_INT     7
+#define EMAC0_INT   24
+#define EMAC1_INT   25
+
+/* UART */
+#define PPC440EPX_UART0_ADDR		0x00000001EF600300ULL
+#define PPC440EPX_UART1_ADDR		0x00000001EF600400ULL
+#define PPC440EPX_UART2_ADDR		0x00000001EF600500ULL
+#define PPC440EPX_UART3_ADDR		0x00000001EF600600ULL
+#define UART0_INT			0
+#define UART1_INT			1
+#define UART2_INT			35
+#define UART3_INT			36
+
+/* IIC Bootstrap Registers */
+#define SDR0_CFGADDR 0x00E		/* System DCR Address Register */
+#define SDR0_CFGDATA 0x00F		/* System DCR Data Register */
+#define SDR0_SDSTP1  0x021		/* Serial Device Strap Register 1 */
+
+/* Clock and Power Management CPM0 */
+#define IBM_CPM_IIC0		0x80000000	/* IIC interface */
+#define IBM_CPM_IIC1		0x40000000	/* IIC interface */
+#define IBM_CPM_PCI		  0x20000000	/* PCI bridge */
+#define IBM_CPM_USB1H		0x08000000	/* USB 1.1 Host */
+#define IBM_CPM_FPU		  0x04000000	/* floating point unit */
+#define IBM_CPM_CPU		  0x02000000	/* processor core */
+#define IBM_CPM_DMA		  0x01000000	/* DMA controller */
+#define IBM_CPM_BGO		  0x00800000	/* PLB3 to OPB bus arbiter */
+/*#define IBM_CPM_BGI		  0x00400000	 OPB to PLB bridge */
+#define IBM_CPM_EBC		  0x00200000	/* External Bus Controller */
+#define IBM_CPM_RGMII 	0x00100000	/* Reduced Gigabit MII Bridge */
+#define IBM_CPM_DMC		  0x00080000	/* SDRAM peripheral controller */
+#define IBM_CPM_PLB4		0x00040000	/* PLB4 bus arbiter */
+#define IBM_CPM_PLB4x3	0x00020000	/* PLB4 to PLB3 bridge controller */
+#define IBM_CPM_PLB3x4	0x00010000	/* PLB3 to PLB4 bridge controller */
+#define IBM_CPM_PLB3		0x00008000	/* PLB3 bus arbiter */
+#define IBM_CPM_NDFC 		0x00004000      /* NAND Flash Controller */
+/*#define IBM_CPM_PPM		  0x00002000	 PLB Performance Monitor */
+#define IBM_CPM_UIC1		0x00001000	/* Universal Interrupt Controller */
+#define IBM_CPM_GPIO0		0x00000800	/* General Purpose IO (??) */
+#define IBM_CPM_GPT		  0x00000400	/* General Purpose Timers  */
+#define IBM_CPM_UART0		0x00000200	/* serial port 0 */
+#define IBM_CPM_UART1		0x00000100	/* serial port 1 */
+#define IBM_CPM_UIC0		0x00000080	/* Universal Interrupt Controller */
+#define IBM_CPM_TMRCLK	0x00000040	/* CPU timers */
+#define IBM_CPM_EMAC0		0x00000020	/* ethernet port 0 */
+#define IBM_CPM_UART2		0x00000010	/* serial port 2 */
+#define IBM_CPM_UART3		0x00000008	/* serial port 3 */
+#define IBM_CPM_EMAC1		0x00000004	/* ethernet port 1 */
+#define IBM_CPM_P42OPB1	0x00000002	/* USB 2.0 Host*/
+#define IBM_CPM_OPB2P4	0x00000001	/* USB 2.0 Host */
+
+/* Clock and Power Management CPM1*/
+#define IBM_CPM_UIC2		0x80000000	/* Universal Interrupt Controller 2*/
+#define IBM_CPM_SRAM0		0x40000000	/* Internal SRAM Controller  */
+#define IBM_CPM_MAL0		0x20000000	/* Memory Access Layer  */
+#define IBM_CPM_USB2D0	0x10000000	/* USB2.0 Device  */
+#define IBM_CPM_USB2H		0x08000000	/* USB 2.0 HOST  */
+#define IBM_CPM_CRYP0  	0x0400000	/* Security Engine */
+#define IBM_CPM_KASU0		0x02000000	/* Kasumi Engine */
+
+
+/* not used at all */
+/*#define DFLT_IBM4xx_PM		*/
+
+/*412- SDRAM Controller - ECC Function   */
+#define UIC_IRQ_ECC  69
+/*  ECC Registers */
+
+
+#define DDR_DCR_BASE 0x10
+#define ddrcfga  (DDR_DCR_BASE+0x0)   /* DDR configuration address reg */
+#define ddrcfgd  (DDR_DCR_BASE+0x1)   /* DDR configuration data reg    */
+
+#define DDR0_00                            0x00
+#define DDR0_00_INT_ACK_MASK               0x7F000000 /* Write only */
+#define DDR0_00_INT_STATUS_MASK            0x00FF0000 /* Read only */
+#define DDR0_00_SINGLE_ACCESS_ERR_MASK     0x00800000
+#define DDR0_00_MULTI_ACCESS_ERR_MASK      0x00400000
+#define DDR0_00_SINGLE_C_EVENT_MASK        0x00200000
+#define DDR0_00_MULTI_C_EVENT_MASK         0x00100000
+#define DDR0_00_SINGLE_U_EVENT_MASK        0x00080000
+#define DDR0_00_MULTI_U_EVENT_MASK         0x00040000
+
+#define DDR0_01                           0x01
+#define DDR0_01_INT_MASK                  0x0000000F
+#define DDR0_01_ALL_INT_ENABLE            0x00000000
+
+#define DDR0_22                           0x16
+
+#define DDR0_22_CTRL_RAW_MASK             0x03000000
+#define DDR0_22_CTRL_RAW_ECC_DISABLE      0x00000000
+#define DDR0_22_CTRL_RAW_ECC_CHECK_ONLY   0x01000000
+#define DDR0_22_CTRL_RAW_NO_ECC_RAM       0x02000000
+#define DDR0_22_CTRL_RAW_ECC_ENABLE       0x03000000
+
+#define DDR0_23                         0x17
+#define DDR0_31                         0x1F
+#define DDR0_31_XOR_CHECK_BITS_MASK       0x0000FFFF
+#define DDR0_32                         0x20
+#define DDR0_32_OUT_OF_RANGE_ADDR_MASK    0xFFFFFFFF /* Read only */
+#define DDR0_33                         0x21
+#define DDR0_33_OUT_OF_RANGE_ADDR_MASK    0x00000001 /* Read only */
+#define DDR0_34                         0x22
+#define DDR0_34_ECC_U_ADDR_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_35                         0x23
+#define DDR0_35_ECC_U_ADDR_MASK           0x00000001 /* Read only */
+#define DDR0_36                         0x24
+#define DDR0_36_ECC_U_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_37                         0x25
+#define DDR0_37_ECC_U_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_38                         0x26
+#define DDR0_38_ECC_C_ADDR_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_39                         0x27
+#define DDR0_39_ECC_C_ADDR_MASK           0x00000001 /* Read only */
+#define DDR0_40                         0x28
+#define DDR0_40_ECC_C_DATA_MASK           0xFFFFFFFF /* Read only */
+#define DDR0_41                         0x29
+#define DDR0_41_ECC_C_DATA_MASK           0xFFFFFFFF /* Read only */
+
+/* Configuration Selection provided via Board Info structure by UBoot      */
+/* The table bi-config[30] corresponds to the 30 selectable functionality  */
+/* The function is selected if bi-config[function-number] == 1             */
+/* The table order is defined by following define - don't change the value */
+
+#define ENET_PACKET_REJECT	0     /* Enet Packet Reject                               */
+#define    IIC_CORE		1     /* I2C1                                             */
+#define    SCP_CORE		2     /* SCP                                              */
+#define    UIC_0_3		3     /* UIC 0:3                                          */
+#define    UIC_4_6		4     /* UIC 4:6                                          */
+#define    UIC_7_9		5     /* UIC 7:9                                          */
+#define    EXT_DMA_TO_PLB3_0 	6     /* External DMA to PLB3 Channel 0                   */
+#define    EXT_DMA_TO_PLB3_1 	7     /* External DMA to PLB3 Channel 1                   */
+#define    EXT_DMA_TO_PLB3_2 	8     /* External DMA to PLB3 Channel 2                   */
+#define    EXT_DMA_TO_PLB3_3 	9     /* External DMA to PLB3 Channel 3                   */
+#define    EBC_MASTER 		10    /* EBC Master                                       */
+#define    EBC_16BITS_ADDR_8_31	11    /* EBC 16bits, address[8:31], with parity selection */
+#define    EBC_ADDR_5_7		12    /* EBC address[5:7] selection                       */
+#define    EBC_ADDR_2_4		13    /* EBC address[2:4] selection                       */
+#define    EBC_32BITS		14    /* EBC 32bits with parity selection                 */
+#define    NAND_FLASH 		15    /* NAND Flash                                       */
+#define    USB2_DEVICE_EXT	16    /* USB2 Device with external PHY selection          */
+#define    USB2_DEVICE_INT	17    /* USB2 Device with internal PHY selection          */
+#define    USB2_HOST 		18    /* USB2 Host with internal PHY selection            */
+#define    UART_CORE0		19    /* UART0                                            */
+#define    UART_CORE1		20    /* UART1                                            */
+#define    UART_CORE2		21    /* UART2                                            */
+#define    UART_CORE3		22    /* UART3                                            */
+#define    ENET_CONFIG_1_1	23    /* 1xMII   using RGMII core                         */
+#define    ENET_CONFIG_1_2	24    /* 1xMII   using  ZMII core                         */
+#define    ENET_CONFIG_2	25    /* 1xGMII  using RGMII core                         */
+#define    ENET_CONFIG_3	26    /* 1xTBI   using RGMII core                         */
+#define    ENET_CONFIG_4	27    /* 2xRGMII using RGMII core                         */
+#define    ENET_CONFIG_5	28    /* 2xRTBI  using RGMII core                         */
+#define    ENET_CONFIG_6	29    /* 2xSMII  using  ZMII core                         */
+
+
+#endif /* __PPC_PLATFORMS_AMCC440EPX_H */
+#endif /* __KERNEL__ */
Index: linux-2.6.10/arch/ppc/platforms/4xx/sequoia.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/4xx/sequoia.c
@@ -0,0 +1,459 @@
+/*
+ * arch/ppc/platforms/4xx/sequoia.c
+ *
+ * Sequoia board specific routines
+ *
+ * Based on Bamboo.c from Wade Farnsworth <wfarnsworth@mvista.com>
+ * Copyright 2004 MontaVista Software Inc.
+ * Copyright 2006 AMCC
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <linux/initrd.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/ethtool.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+#include <asm/pci-bridge.h>
+#include <asm/time.h>
+#include <asm/todc.h>
+#include <asm/bootinfo.h>
+#include <asm/ppc4xx_pic.h>
+#include <asm/ppcboot.h>
+
+#include <syslib/gen550.h>
+#include <syslib/ibm440gx_common.h>
+
+
+bd_t __res;
+
+static struct ibm44x_clocks clocks __initdata;
+
+/*
+ * Sequoia external IRQ triggering/polarity settings
+ */
+unsigned char ppc4xx_uic_ext_irq_cfg[] __initdata = {
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index0 - IRQ4: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index1 - IRQ7: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index2 - IRQ8: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index3 - IRQ9: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index4 - IRQ0: Ethernet 0 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index5 - IRQ1: Ethernet 1 */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index6 - IRQ5: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index7 - IRQ6: */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index8 - IRQ2: PCI slots */
+	(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE), /* Index9 - IRQ3: STTM alert */
+};
+
+/*
+* get size of system memory from Board Info .
+*/
+unsigned long __init sequoia_find_end_of_memory(void)
+{
+	/* board info structure defined in /include/asm-ppc/ppcboot.h */
+	return  __res.bi_memsize;
+}
+
+
+static void __init sequoia_calibrate_decr(void)
+{
+	unsigned int freq;
+
+	if (mfspr(SPRN_CCR1) & CCR1_TCS)
+		freq = SEQUOIA_TMRCLK;
+	else
+		freq = clocks.cpu;
+
+	ibm44x_calibrate_decr(freq);
+
+}
+
+
+static int sequoia_show_cpuinfo(struct seq_file *m)
+{
+	seq_printf(m, "vendor\t\t: AMCC\n");
+	seq_printf(m, "machine\t\t: PPC440EPx EVB (Sequoia)\n");
+
+	return 0;
+}
+
+
+static inline int
+sequoia_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 * 	   A   B   C   D
+	 */
+	{
+		{ 67, 67, 67, 67 },	/* IDSEL [0] bit address 14 - PCI Slot 1 associated to ext. IRQ 2*/
+		{ 67, 67, 67, 67 },	/* IDSEL [0] bit address 14 - PCI Slot x associated to ext. IRQ 2*/
+		{ 67, 67, 67, 67 },	/* IDSEL [0] bit address 14 - PCI Slot 0 associated to ext. IRQ 2*/
+	};
+
+	const long min_idsel = 10, max_idsel = 12, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+}
+
+
+static void __init sequoia_set_emacdata(void)
+{
+	struct ocp_def *def;
+	struct ocp_func_emac_data *emacdata;
+
+	/* Set mac_addr, phy mode and unsupported phy features for each EMAC */
+
+	def = ocp_get_one_device(OCP_VENDOR_IBM, OCP_FUNC_EMAC, 0);
+	emacdata = def->additions;
+
+	memcpy(emacdata->mac_addr, __res.bi_enetaddr, 6);
+
+	emacdata->phy_mode = PHY_MODE_RGMII;
+	emacdata->phy_feat_exc = SUPPORTED_Autoneg;
+
+	emacdata->rgmii_idx = 0;
+	emacdata->rgmii_mux = 0;
+
+	def = ocp_get_one_device(OCP_VENDOR_IBM, OCP_FUNC_EMAC, 1);
+	emacdata = def->additions;
+
+	emacdata->rgmii_idx = 0;
+	emacdata->rgmii_mux = 1;
+
+	memcpy(emacdata->mac_addr, __res.bi_enet1addr, 6);
+
+	emacdata->phy_mode = PHY_MODE_RGMII;
+	emacdata->phy_feat_exc = SUPPORTED_Autoneg;
+	emacdata->mdio_idx = 0;
+}
+
+
+static int
+sequoia_exclude_device(unsigned char bus, unsigned char devfn)
+{
+	return (bus == 0 && devfn == 0);
+}
+
+#define PCI_READW(offset) \
+        (readw((void *)((u32)pci_reg_base+offset)))
+
+#define PCI_WRITEW(value, offset) \
+	(writew(value, (void *)((u32)pci_reg_base+offset)))
+
+#define PCI_WRITEL(value, offset) \
+	(writel(value, (void *)((u32)pci_reg_base+offset)))
+
+#define PCI_CFG_OUT(offset, value)\
+	(out_le32 (pci_cfg_base+offset, value))
+
+#define PCI_CFG_IN(offset)\
+	 (in_le32(pci_cfg_base+offset))
+
+
+static void __init sequoia_setup_pci(void)
+{
+	void *pci_reg_base;
+	void *pci_cfg_base;
+	unsigned long memory_size;
+
+	memory_size = ppc_md.find_end_of_memory();
+
+	pci_reg_base = ioremap64(SEQUOIA_PCIL0_BASE, SEQUOIA_PCIL0_SIZE);
+	pci_cfg_base = ioremap64(SEQUOIA_PCI_CFGREGS_BASE, 64);
+
+	PCI_CFG_OUT(SEQUOIA_PCI_CFGA_OFFSET,
+		    0x80000000 | (PCI_COMMAND & 0xfc));
+	PCI_CFG_OUT(SEQUOIA_PCI_CFGD_OFFSET,
+		    ( PCI_CFG_IN(SEQUOIA_PCI_CFGD_OFFSET) |
+		    PCI_COMMAND_MEMORY |
+		    PCI_COMMAND_MASTER));
+
+	/* Disable region first */
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM0MA);
+
+	/* PLB starting addr: 0x0000000180000000 */
+	PCI_WRITEL(SEQUOIA_PCI_PHY_MEM_BASE, SEQUOIA_PCIL0_PMM0LA);
+
+	/* PCI start addr, 0x80000000 (PCI Address) */
+	PCI_WRITEL(SEQUOIA_PCI_MEM_BASE, SEQUOIA_PCIL0_PMM0PCILA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM0PCIHA);
+
+	/* Enable no pre-fetch, enable region */
+	PCI_WRITEL(((0xffffffff -
+		     (SEQUOIA_PCI_UPPER_MEM - SEQUOIA_PCI_MEM_BASE)) | 0x01),
+		      SEQUOIA_PCIL0_PMM0MA);
+
+	/* Disable region one */
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM1MA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM1LA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM1PCILA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM1PCIHA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM1MA);
+
+	/* Disable region two */
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM2MA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM2LA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM2PCILA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM2PCIHA);
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PMM2MA);
+
+	/* Now configure the PCI->PLB windows, we only use PTM1
+	 *
+	 * For Inbound flow, set the window size to all available memory
+	 * This is required because if size is smaller,
+	 * then Eth/PCI DD would fail as PCI card not able to access
+	 * the memory allocated by DD.
+	 */
+
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PTM1MS);	/* disabled region 1 */
+	PCI_WRITEL(0, SEQUOIA_PCIL0_PTM1LA);	/* begin of address map */
+
+	memory_size = 1 << fls(memory_size - 1);
+
+	/* Size low + Enabled */
+	PCI_WRITEL((0xffffffff - (memory_size - 1)) | 0x1, SEQUOIA_PCIL0_PTM1MS);
+
+	eieio();
+	iounmap(pci_reg_base);
+}
+
+
+static void __init sequoia_setup_hose(void)
+{
+	unsigned int bar_response, bar;
+	struct pci_controller *hose;
+
+	sequoia_setup_pci();
+
+	hose = pcibios_alloc_controller();
+
+	if (!hose)
+		return;
+
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	hose->pci_mem_offset = SEQUOIA_PCI_MEM_OFFSET;
+
+	pci_init_resource(&hose->io_resource,
+			SEQUOIA_PCI_LOWER_IO,
+			SEQUOIA_PCI_UPPER_IO,
+			IORESOURCE_IO,
+			"PCI host bridge");
+
+	pci_init_resource(&hose->mem_resources[0],
+			SEQUOIA_PCI_LOWER_MEM,
+			SEQUOIA_PCI_UPPER_MEM,
+			IORESOURCE_MEM,
+			"PCI host bridge");
+
+	ppc_md.pci_exclude_device = sequoia_exclude_device;
+
+	hose->io_space.start = SEQUOIA_PCI_LOWER_IO;
+	hose->io_space.end = SEQUOIA_PCI_UPPER_IO;
+	hose->mem_space.start = SEQUOIA_PCI_LOWER_MEM;
+	hose->mem_space.end = SEQUOIA_PCI_UPPER_MEM;
+	isa_io_base =
+		(unsigned long)ioremap64(SEQUOIA_PCI_IO_BASE, SEQUOIA_PCI_IO_SIZE);
+	hose->io_base_virt = (void *)isa_io_base;
+
+	setup_indirect_pci(hose,
+			SEQUOIA_PCI_CFGA_PLB32,
+			SEQUOIA_PCI_CFGD_PLB32);
+	hose->set_cfg_type = 1;
+
+	/* Zero config bars */
+	for (bar = PCI_BASE_ADDRESS_1; bar <= PCI_BASE_ADDRESS_2; bar += 4) {
+		early_write_config_dword(hose, hose->first_busno,
+					 PCI_FUNC(hose->first_busno), bar,
+					 0x00000000);
+		early_read_config_dword(hose, hose->first_busno,
+					PCI_FUNC(hose->first_busno), bar,
+					&bar_response);
+	}
+
+	hose->last_busno = pciauto_bus_scan(hose, hose->first_busno);
+
+	ppc_md.pci_swizzle = common_swizzle;
+
+	ppc_md.pci_map_irq = sequoia_map_irq;
+}
+
+TODC_ALLOC();
+
+static void __init sequoia_early_serial_map(void)
+{
+	struct uart_port port;
+
+	/* Setup ioremapped serial port access */
+	memset(&port, 0, sizeof(port));
+	port.membase = ioremap64(PPC440EPX_UART0_ADDR, 8);
+	port.irq = UART0_INT;
+	port.uartclk = clocks.uart0;
+	port.regshift = 0;
+	port.iotype = SERIAL_IO_MEM;
+	port.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
+	port.line = 0;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 0 failed\n");
+	}
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	/* Configure debug serial access */
+	gen550_init(0, &port);
+#endif
+
+	port.membase = ioremap64(PPC440EPX_UART1_ADDR, 8);
+	port.irq = UART1_INT;
+	port.uartclk = clocks.uart1;
+	port.line = 1;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 1 failed\n");
+	}
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	/* Configure debug serial access */
+	gen550_init(1, &port);
+#endif
+
+	port.membase = ioremap64(PPC440EPX_UART2_ADDR, 8);
+	port.irq = UART2_INT;
+	port.uartclk = clocks.uart2;
+	port.line = 2;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 2 failed\n");
+	}
+
+#if defined(CONFIG_SERIAL_TEXT_DEBUG) || defined(CONFIG_KGDB)
+	/* Configure debug serial access */
+	gen550_init(2, &port);
+#endif
+
+	port.membase = ioremap64(PPC440EPX_UART3_ADDR, 8);
+	port.irq = UART3_INT;
+	port.uartclk = clocks.uart3;
+	port.line = 3;
+
+	if (early_serial_setup(&port) != 0) {
+		printk("Early serial init of port 3 failed\n");
+	}
+}
+
+
+static void __init sequoia_setup_arch(void)
+{
+	sequoia_set_emacdata();
+
+	/* parm1 = sys clock is OK , parm 2 ser_clock to be checked */
+	ibm440gx_get_clocks(&clocks, 33333333, 6 * 1843200);
+	ocp_sys_info.opb_bus_freq = clocks.opb;
+
+	/* init to some ~sane value until calibrate_delay() runs */
+        loops_per_jiffy = 50000000/HZ;
+
+	/* Setup PCI host bridge */
+	sequoia_setup_hose();
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else {
+#ifdef CONFIG_ROOT_NFS
+		ROOT_DEV = Root_NFS;
+#else
+		ROOT_DEV = Root_HDA1;
+#endif
+	}
+#endif
+
+	sequoia_early_serial_map();
+
+	printk( "AMCC PowerPC Sequoia platform\n" );
+}
+
+
+static void __init sequoia_init_irq(void)
+{
+	ppc4xx_pic_init();
+}
+
+
+void __init platform_init(unsigned long r3, unsigned long r4,
+			  unsigned long r5, unsigned long r6, unsigned long r7)
+{
+	parse_bootinfo(find_bootinfo());
+
+	/*
+	 * If we were passed in a board information, copy it into the
+	 * residual data area.
+	 */
+	if (r3)
+		__res = *(bd_t *)(r3 + KERNELBASE);
+
+#if defined(CONFIG_BLK_DEV_INITRD)
+	/*
+	 * If the init RAM disk has been configured in, and there's a valid
+	 * starting address for it, set it up.
+	 */
+	if (r4) {
+		initrd_start = r4 + KERNELBASE;
+		initrd_end = r5 + KERNELBASE;
+	}
+#endif  /* CONFIG_BLK_DEV_INITRD */
+
+	/* Copy the kernel command line arguments to a safe place. */
+
+	if (r6) {
+		*(char *) (r7 + KERNELBASE) = 0;
+		strcpy(cmd_line, (char *) (r6 + KERNELBASE));
+	}
+	ibm44x_platform_init();
+
+	ppc_md.setup_arch = sequoia_setup_arch;
+	ppc_md.show_cpuinfo = sequoia_show_cpuinfo;
+	ppc_md.find_end_of_memory = sequoia_find_end_of_memory;
+	ppc_md.get_irq = NULL;		/* Set in ppc4xx_pic_init() */
+
+	ppc_md.calibrate_decr = sequoia_calibrate_decr;
+	ppc_md.time_init = NULL;
+	ppc_md.set_rtc_time = NULL;
+	ppc_md.get_rtc_time = NULL;
+
+	ppc_md.init_IRQ = sequoia_init_irq;
+
+#ifdef CONFIG_KGDB
+	ppc_md.early_serial_map = sequoia_early_serial_map;
+#endif
+}
Index: linux-2.6.10/arch/ppc/platforms/4xx/sequoia.h
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/ppc/platforms/4xx/sequoia.h
@@ -0,0 +1,124 @@
+/*
+ * arch/ppc/platforms/4xx/sequoia.h
+ *
+ * Sequoia board definitions
+ *
+ * Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * Copyright 2004 MontaVista Software Inc.
+ * Copyright 2006 AMCC
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_SEQUOIA_H__
+#define __ASM_SEQUOIA_H__
+
+#include <linux/config.h>
+#include <platforms/4xx/ppc440epx.h>
+
+/* Default clock rate */
+#define SEQUOIA_TMRCLK     50000000
+#define SEQUOIA_SYSCLK     33333333
+
+
+/* Board Control and Status Registers */
+#define SEQUOIA_BCSR_BASE_ADDR	0x1c0000000ULL
+
+#ifndef __ASSEMBLY__
+struct sequoia_bcsr {
+    unsigned char board_id;		/* board revision */
+    unsigned char cpld_version;		/* CPLD version */
+    unsigned char user_dip_switch;	/* LEDs and user DIP switch */
+    unsigned char conf_dip_switch;	/* configuration DIP switch */
+    unsigned char tmrclk_control;	/* TMRCLK source and modifier */
+    unsigned char pci_and_status;	/* PCI speed 33/66 */
+    unsigned char reset_ctrl;		/* reset control */
+    unsigned char memory_ctrl;		/* FLASH, EEPROM write protect, STTM addr */
+    unsigned char eth_ctrl;		/* Ethernet PHY resets */
+    unsigned char usb_ctrl;		/* USB control */
+    unsigned char perf_timer0;		/* performance timer */
+    unsigned char perf_timer1;
+    unsigned char perf_timer2;
+    unsigned char perf_timer3;
+};
+#endif /* __ASSEMBLY__ */
+
+#define SEQUOIA_NAND_FLASH_REG_ADDR	0x1D0000000ULL
+#define SEQUOIA_NAND_FLASH_REG_SIZE	0x2000
+
+/*
+ * Serial port defines
+ */
+#define RS_TABLE_SIZE			4
+/* UART mappings used before early_serial_setup so should be coherent with UBoot */
+#define UART0_IO_BASE			0xEF600300
+#define UART1_IO_BASE			0xEF600400
+#define UART2_IO_BASE			0xEF600500
+#define UART3_IO_BASE			0xEF600600
+
+#define BASE_BAUD			33177600/3/16
+/*
+#define UART0_INT			0
+#define UART1_INT			1
+#define UART2_INT			35
+#define UART3_INT			36
+*/
+
+#define STD_UART_OP(num)					\
+	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
+		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
+		iomem_base: (void*)UART##num##_IO_BASE,		\
+		io_type: SERIAL_IO_MEM},
+
+#define SERIAL_PORT_DFNS	\
+	STD_UART_OP(0)		\
+	STD_UART_OP(1)		\
+	STD_UART_OP(2)		\
+	STD_UART_OP(3)
+
+/* PCI support */
+#define SEQUOIA_PCI_CFGREGS_BASE	0x00000001eec00000ULL
+#define SEQUOIA_PCI_CFGA_PLB32		0xeec00000
+#define SEQUOIA_PCI_CFGD_PLB32		0xeec00004
+#define SEQUOIA_PCI_CFGA_OFFSET		0
+#define SEQUOIA_PCI_CFGD_OFFSET		0x4
+
+#define SEQUOIA_PCI_IO_BASE		0x00000001e8000000ULL
+#define SEQUOIA_PCI_IO_SIZE		0x00010000
+#define SEQUOIA_PCI_MEM_OFFSET	  	0x00000000
+#define SEQUOIA_PCI_PHY_MEM_BASE	0x000000080000000ULL  /* PLB base address base as seen by the core, implemented on PLB3*/
+                                                        /* PLB base address as seen by the SOC : 0x000000180000000ULL    */
+
+#define SEQUOIA_PCI_LOWER_IO		0x00000000
+#define SEQUOIA_PCI_UPPER_IO		0x0000ffff
+#define SEQUOIA_PCI_LOWER_MEM		0x80000000
+#define SEQUOIA_PCI_UPPER_MEM		0x8fffffff            /* to be checked with AS & TR should be bfffffff */
+#define SEQUOIA_PCI_MEM_BASE		0x80000000
+
+#define SEQUOIA_PCIL0_BASE		0x00000001ef400000ULL
+#define SEQUOIA_PCIL0_SIZE		0x40
+
+#define SEQUOIA_PCIL0_PMM0LA		0x000
+#define SEQUOIA_PCIL0_PMM0MA		0x004
+#define SEQUOIA_PCIL0_PMM0PCILA		0x008
+#define SEQUOIA_PCIL0_PMM0PCIHA		0x00C
+#define SEQUOIA_PCIL0_PMM1LA		0x010
+#define SEQUOIA_PCIL0_PMM1MA		0x014
+#define SEQUOIA_PCIL0_PMM1PCILA		0x018
+#define SEQUOIA_PCIL0_PMM1PCIHA		0x01C
+#define SEQUOIA_PCIL0_PMM2LA		0x020
+#define SEQUOIA_PCIL0_PMM2MA		0x024
+#define SEQUOIA_PCIL0_PMM2PCILA		0x028
+#define SEQUOIA_PCIL0_PMM2PCIHA		0x02C
+#define SEQUOIA_PCIL0_PTM1MS		0x030
+#define SEQUOIA_PCIL0_PTM1LA		0x034
+#define SEQUOIA_PCIL0_PTM2MS		0x038
+#define SEQUOIA_PCIL0_PTM2LA		0x03C
+
+#endif                          /* __ASM_SEQUOIA_H__ */
+#endif                          /* __KERNEL__ */
Index: linux-2.6.10/arch/ppc/syslib/Makefile
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/Makefile
+++ linux-2.6.10/arch/ppc/syslib/Makefile
@@ -13,6 +13,8 @@ obj-$(CONFIG_IBM_OCP)		+= ibm_ocp.o
 obj-$(CONFIG_44x)		+= ibm44x_common.o
 obj-$(CONFIG_440EP)		+= ibm440gx_common.o
 obj-$(CONFIG_440GR)		+= ibm440gx_common.o
+obj-$(CONFIG_440EPX)		+= ibm440gx_common.o
+obj-$(CONFIG_440GRX)		+= ibm440gx_common.o
 obj-$(CONFIG_440GP)		+= ibm440gp_common.o
 obj-$(CONFIG_440GX)		+= ibm440gx_common.o
 obj-$(CONFIG_440SP)		+= ibm440gx_common.o ibm440sp_common.o
@@ -50,6 +52,8 @@ obj-$(CONFIG_ADIR)		+= i8259.o indirect_
 obj-$(CONFIG_BAMBOO)		+= indirect_pci.o pci_auto.o todc_time.o
 obj-$(CONFIG_YOSEMITE)		+= indirect_pci.o pci_auto.o
 obj-$(CONFIG_YELLOWSTONE)	+= indirect_pci.o pci_auto.o
+obj-$(CONFIG_SEQUOIA)		+= indirect_pci.o pci_auto.o
+obj-$(CONFIG_RAINIER)		+= indirect_pci.o pci_auto.o
 obj-$(CONFIG_CPCI690)		+= todc_time.o pci_auto.o
 obj-$(CONFIG_EBONY)		+= indirect_pci.o pci_auto.o todc_time.o
 obj-$(CONFIG_EV64260)		+= todc_time.o pci_auto.o
Index: linux-2.6.10/arch/ppc/syslib/ibm440gx_common.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ibm440gx_common.c
+++ linux-2.6.10/arch/ppc/syslib/ibm440gx_common.c
@@ -34,10 +34,12 @@ void __init ibm440gx_get_clocks(struct i
 	u32 plld  = CPR_READ(DCRN_CPR_PLLD);
 	u32 uart0 = SDR_READ(DCRN_SDR_UART0);
 	u32 uart1 = SDR_READ(DCRN_SDR_UART1);
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR) || defined(CONFIG_440SP)
+#if defined(CONFIG_440SP) || defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	u32 uart2 = SDR_READ(DCRN_SDR_UART2);
 #endif
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#if defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	u32 uart3 = SDR_READ(DCRN_SDR_UART3);
 #endif
 
@@ -102,14 +104,16 @@ bypass:
 		p->uart1 = ser_clk;
 	else
 		p->uart1 = p->plb / __fix_zero(uart1 & 0xff, 256);
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR) || defined(CONFIG_440SP)
+#if defined(CONFIG_440SP) || defined(CONFIG_440GR) || defined(CONFIG_440EP) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	if (uart2 & 0x00800000)
 		p->uart2 = ser_clk;
 	else
 		p->uart2 = p->plb / __fix_zero(uart2 & 0xff, 256);
 #endif
 
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#if defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	if (uart3 & 0x00800000)
 		p->uart3 = ser_clk;
 	else
Index: linux-2.6.10/arch/ppc/syslib/ibm44x_common.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ibm44x_common.c
+++ linux-2.6.10/arch/ppc/syslib/ibm44x_common.c
@@ -179,6 +179,32 @@ void __init ibm44x_platform_init(void)
 /* Called from MachineCheckException */
 void platform_machine_check(struct pt_regs *regs)
 {
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+     	printk("OPB to PLB3: BSTAT= 0x%08x\n",
+		mfdcr(DCRN_OPB2PLB30_BSTAT));
+		 	printk("PLB3 to PLB4: BEAR=0x%08x%08x BESR0=0x%08x BESR1=0x%08x\n",
+		mfdcr(DCRN_P3P4BI0_BEARH), mfdcr(DCRN_P3P4BI0_BEARL),
+		mfdcr(DCRN_P3P4BI0_BESR0), mfdcr(DCRN_P3P4BI0_BESR1));
+		 	printk("PLB4 to PLB3: BEAR=0x%08x%08x BESR0=0x%08x BESR1=0x%08x\n",
+		mfdcr(DCRN_P4P3BO0_BEARH), mfdcr(DCRN_P4P3BO0_BEARL),
+		mfdcr(DCRN_P4P3BO0_BESR0), mfdcr(DCRN_P4P3BO0_BESR1));
+   		 	printk("PLB3 to OPB: BEAR=0x%08x BESR0=0x%08x BESR1=0x%08x\n",
+		mfdcr(DCRN_PLB32OPB0_BEAR),
+		mfdcr(DCRN_PLB32OPB0_BESR0), mfdcr(DCRN_PLB32OPB0_BESR1));
+		    	printk("PLB3 arbiter: BEAR=0x%08x ACR=0x%08x BESR=0x%08x\n",
+		mfdcr(DCRN_PLB3A0_BEAR),
+		mfdcr(DCRN_PLB3A0_ACR),  mfdcr(DCRN_PLB3A0_BESR));
+		 	printk("PLB4 to OPB1: BEAR=0x%08x%08x BESR0=0x%08x BESR1=0x%08x\n",
+		mfdcr(DCRN_PLB42OPB1_BEARH), mfdcr(DCRN_PLB42OPB1_BEARL),
+		mfdcr(DCRN_PLB42OPB1_BESR0), mfdcr(DCRN_PLB42OPB1_BESR1));
+		 	printk("PLB40 Arbiter: BEAR=0x%08x%08x ACR=0x%08x BESR0=0x%08x\n",
+		mfdcr(DCRN_PLB4A0_BEARH), mfdcr(DCRN_PLB4A0_BEARL),
+		mfdcr(DCRN_PLB4A0_ACR), mfdcr(DCRN_PLB4A0_BESR));
+		 	printk("PLB41 Arbiter: BEAR=0x%08x%08x ACR=0x%08x BESR0=0x%08x\n",
+		mfdcr(DCRN_PLB4A1_BEARH), mfdcr(DCRN_PLB4A1_BEARL),
+		mfdcr(DCRN_PLB4A1_ACR), mfdcr(DCRN_PLB4A1_BESR));
+
+#else
     	printk("PLB0: BEAR=0x%08x%08x ACR=  0x%08x BESR= 0x%08x\n",
 		mfdcr(DCRN_PLB0_BEARH), mfdcr(DCRN_PLB0_BEARL),
 		mfdcr(DCRN_PLB0_ACR),  mfdcr(DCRN_PLB0_BESR));
@@ -188,4 +214,5 @@ void platform_machine_check(struct pt_re
 	printk("OPB0: BEAR=0x%08x%08x BSTAT=0x%08x\n",
 		mfdcr(DCRN_OPB0_BEARH), mfdcr(DCRN_OPB0_BEARL),
 		mfdcr(DCRN_OPB0_BSTAT));
+#endif
 }
Index: linux-2.6.10/arch/ppc/syslib/ibm44x_common.h
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ibm44x_common.h
+++ linux-2.6.10/arch/ppc/syslib/ibm44x_common.h
@@ -29,10 +29,12 @@ struct ibm44x_clocks {
 	unsigned int ebc;	/* PerClk */
 	unsigned int uart0;
 	unsigned int uart1;
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR) || defined(CONFIG_440SP)
+#if defined(CONFIG_440SP) || defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	unsigned int uart2;
 #endif
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#if defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 	unsigned int uart3;
 #endif
 };
Index: linux-2.6.10/arch/ppc/syslib/ppc4xx_pic.c
===================================================================
--- linux-2.6.10.orig/arch/ppc/syslib/ppc4xx_pic.c
+++ linux-2.6.10/arch/ppc/syslib/ppc4xx_pic.c
@@ -83,6 +83,32 @@ static void ppc4xx_uic##n##_end(unsigned
 }									\
 
 #if NR_UICS == 3
+#if defined(CONFIG_440EPX)|| defined(CONFIG_440GRX)
+#define ACK_UIC0_PARENT
+#define ACK_UIC1_PARENT	mtdcr(DCRN_UIC_SR(UIC0), UIC0_UIC1NC);
+#define ACK_UIC2_PARENT	mtdcr(DCRN_UIC_SR(UIC0), UIC0_UIC2NC);
+UIC_HANDLERS(0); UIC_HANDLERS(1); UIC_HANDLERS(2);
+
+static int ppc4xx_pic_get_irq(struct pt_regs *regs)
+{
+	u32 uic0 = mfdcr(DCRN_UIC_MSR(UIC0));
+	if (uic0 & UIC0_UIC1NC)
+		return 64 - ffs(mfdcr(DCRN_UIC_MSR(UIC1)));
+	else if (uic0 & UIC0_UIC2NC)
+		return 96 - ffs(mfdcr(DCRN_UIC_MSR(UIC2)));
+	else
+		return uic0 ? 32 - ffs(uic0) : -1;
+}
+
+static void __init ppc4xx_pic_impl_init(void)
+{
+	/* Enable cascade interrupts in UIC0 */
+	ppc_cached_irq_mask[0] |= UIC0_UIC1NC | UIC0_UIC2NC;
+	mtdcr(DCRN_UIC_SR(UIC0), UIC0_UIC1NC | UIC0_UIC2NC );
+	mtdcr(DCRN_UIC_ER(UIC0), ppc_cached_irq_mask[0]);
+}
+
+#else
 #define ACK_UIC0_PARENT	mtdcr(DCRN_UIC_SR(UICB), UICB_UIC0NC);
 #define ACK_UIC1_PARENT	mtdcr(DCRN_UIC_SR(UICB), UICB_UIC1NC);
 #define ACK_UIC2_PARENT	mtdcr(DCRN_UIC_SR(UICB), UICB_UIC2NC);
@@ -110,6 +136,7 @@ static void __init ppc4xx_pic_impl_init(
 	mtdcr(DCRN_UIC_SR(UICB), 0xffffffff);
 	mtdcr(DCRN_UIC_ER(UICB), UICB_UIC0NC | UICB_UIC1NC | UICB_UIC2NC);
 }
+#endif
 
 #elif NR_UICS == 2
 #define ACK_UIC0_PARENT
Index: linux-2.6.10/include/asm-ppc/ibm44x.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ibm44x.h
+++ linux-2.6.10/include/asm-ppc/ibm44x.h
@@ -37,7 +37,8 @@
 /* LS 32-bits of UART0 physical address location for early serial text debug */
 #if defined(CONFIG_440SP)
 #define UART0_PHYS_IO_BASE	0xf0000200
-#elif defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#elif defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 #define UART0_PHYS_IO_BASE	0xe0000000
 #else
 #define UART0_PHYS_IO_BASE	0x40000200
@@ -61,6 +62,11 @@
 #define PPC44x_PCICFG_PAGE	0x0000000000000000ULL
 #define PPC44x_PCIIO_PAGE	PPC44x_PCICFG_PAGE
 #define PPC44x_PCIMEM_PAGE	0x0000000000000000ULL
+#elif defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define PPC44x_IO_PAGE		0x0000000100000000ULL
+#define PPC44x_PCICFG_PAGE	0x0000000100000000ULL
+#define PPC44x_PCIIO_PAGE	PPC44x_PCICFG_PAGE
+#define PPC44x_PCIMEM_PAGE	PPC44x_PCICFG_PAGE
 #else
 #define	PPC44x_IO_PAGE		0x0000000100000000ULL
 #define	PPC44x_PCICFG_PAGE	0x0000000200000000ULL
@@ -69,6 +75,17 @@
 #endif
 
 /*
+ * Internal SRAM or OCM definitions
+ */
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define PPC44x_SRAM_ADDR	0x00000000e0010000ULL	/* On Chip Memory */
+#define PPC44x_SRAM_SIZE	0x4000			/* 16 Kb*/
+#elif defined(CONFIG_440GX)
+#define PPC44x_SRAM_ADDR	0x0000000080000000ULL	/* Internal SRAM*/
+#define PPC44x_SRAM_SIZE	0x40000			/* 256 Kb*/
+#endif
+
+/*
  * 36-bit trap ranges
  */
 #if defined(CONFIG_440SP)
@@ -89,6 +106,13 @@
 #define PPC44x_PCI0CFG_HI	0xeecfffffUL
 #define PPC44x_PCIMEM_LO	0xa0000000UL
 #define PPC44x_PCIMEM_HI	0xdfffffffUL
+#elif defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define PPC44x_IO_LO		0xef500000UL
+#define PPC44x_IO_HI		0xefffffffUL
+#define PPC44x_PCI0CFG_LO	0xeec00000UL
+#define PPC44x_PCI0CFG_HI	0xeecfffffUL
+#define PPC44x_PCIMEM_LO	0x80000000UL
+#define PPC44x_PCIMEM_HI	0xbfffffffUL
 #else
 #define PPC44x_IO_LO		0x40000000UL
 #define PPC44x_IO_HI		0x40000fffUL
@@ -109,7 +133,7 @@
  */
 
 
-/* CPRs (440GX and 440SP) */
+/* CPRs (440GX 440SP 440EP(X) 440GR(X)) */
 #define DCRN_CPR_CONFIG_ADDR	0xc
 #define DCRN_CPR_CONFIG_DATA	0xd
 
@@ -130,7 +154,7 @@
 	mtdcr(DCRN_CPR_CONFIG_ADDR, offset); \
 	mtdcr(DCRN_CPR_CONFIG_DATA, data);})
 
-/* SDRs (440GX and 440SP) */
+/* SDRs (440GX 440SP 440EP(X) 440GR(X)) */
 #define DCRN_SDR_CONFIG_ADDR 	0xe
 #define DCRN_SDR_CONFIG_DATA	0xf
 #define DCRN_SDR_PFC0		0x4100
@@ -166,10 +190,12 @@
 #define DCRN_SDR_UART0		0x0120
 #define DCRN_SDR_UART1		0x0121
 
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR) || defined(CONFIG_440SP)
+#if defined(CONFIG_440SP) || defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 #define DCRN_SDR_UART2		0x0122
 #endif
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#if defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 #define DCRN_SDR_UART3		0x0123
 #define DCRN_SDR_USB0		0x0320
 #define DCRN_SDR_CUST0		0x4000
@@ -192,7 +218,8 @@
 #define DCRNCAP_DMA_SG		1	/* have DMA scatter/gather capability */
 #define DCRN_MAL_BASE		0x180
 
-#if defined(CONFIG_440EP) || defined(CONFIG_440GR)
+#if defined(CONFIG_440EP) || defined(CONFIG_440GR) ||	\
+	defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 #define DCRN_DMA2P40_BASE	0x300
 #define DCRN_DMA2P41_BASE	0x308
 #define DCRN_DMA2P42_BASE	0x310
@@ -203,7 +230,11 @@
 /* UIC */
 #define DCRN_UIC0_BASE	0xc0
 #define DCRN_UIC1_BASE	0xd0
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define DCRN_UIC2_BASE	0xe0
+#else
 #define DCRN_UIC2_BASE	0x210
+#endif
 #define DCRN_UICB_BASE	0x200
 #define UIC0		DCRN_UIC0_BASE
 #define UIC1		DCRN_UIC1_BASE
@@ -221,6 +252,10 @@
 
 #define UIC0_UIC1NC      	0x00000002
 
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define UIC0_UIC2NC		0x00000008
+#endif
+
 #define UICB_UIC0NC		0x40000000
 #define UICB_UIC1NC		0x10000000
 #define UICB_UIC2NC		0x04000000
@@ -300,6 +335,47 @@
 #define MALOBISR_CH0		0x80000000	/* EOB channel 1 bit */
 #define MALOBISR_CH2		0x40000000	/* EOB channel 2 bit */
 
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+/* EBC error Status */
+#define DCRN_EBC0_BEAR		0x020
+#define DCRN_EBC0_BESR0		0x021
+
+/* OPB to PLB3 Bridge  DCRs */
+#define DCRN_OPB2PLB30_BSTAT	0x0A9
+/* PLB3 to PLB4 bridge DCRs */
+#define DCRN_P3P4BI0_BESR0	0x030
+#define DCRN_P3P4BI0_BEARL	0x032
+#define DCRN_P3P4BI0_BEARH	0x033
+#define DCRN_P3P4BI0_BESR1	0x034
+/* PLB4 to PLB3 bridge DCRs */
+#define DCRN_P4P3BO0_BESR0	0x020
+#define DCRN_P4P3BO0_BEARL	0x022
+#define DCRN_P4P3BO0_BEARH	0x023
+#define DCRN_P4P3BO0_BESR1	0x024
+/* PLB3 to OPB  bridge DCRs */
+#define DCRN_PLB32OPB0_BEAR	0x092
+#define DCRN_PLB32OPB0_BESR0	0x090
+#define DCRN_PLB32OPB0_BESR1	0x094
+/* PLB3 Arbiter DCRs */
+#define DCRN_PLB3A0_ACR		0x077
+#define DCRN_PLB3A0_BEAR	0x076
+#define DCRN_PLB3A0_BESR	0x074
+/* PLB4 to OPB1 Bridge DCRs */
+#define DCRN_PLB42OPB1_BEARH	0x0203
+#define DCRN_PLB42OPB1_BEARL	0x0202
+#define DCRN_PLB42OPB1_BESR0	0x0200
+#define DCRN_PLB42OPB1_BESR1	0x0204
+/* PLB4 Arbiter DCRs */
+#define DCRN_PLB4A0_ACR		0x081
+#define DCRN_PLB4A0_BEARH	0x085
+#define DCRN_PLB4A0_BEARL	0x084
+#define DCRN_PLB4A0_BESR	0x082
+#define DCRN_PLB4A1_ACR		0x089
+#define DCRN_PLB4A1_BEARH	0x08D
+#define DCRN_PLB4A1_BEARL	0x08C
+#define DCRN_PLB4A1_BESR	0x08A
+/* end of 440EPX DCR's definition*/
+#else
 /* 440GP/GX PLB Arbiter DCRs */
 #define DCRN_PLB0_REVID		0x082		/* PLB Arbiter Revision ID */
 #define DCRN_PLB0_ACR		0x083		/* PLB Arbiter Control */
@@ -338,8 +414,10 @@
 #define DCRN_CPC0_MIRQ0		0x0ec
 #define DCRN_CPC0_MIRQ1		0x0ed
 #define DCRN_CPC0_JTAGID	0x0ef
+/* end of 440GP/GX PLB OPB DCRs definition*/
+#endif
 
-/* 440GP DMA controller DCRs */
+/* 440GP 440EPX DMA controller DCRs */
 #define DCRN_DMACR0	(DCRN_DMA0_BASE + 0x0)	/* DMA Channel Control 0 */
 #define DCRN_DMACT0	(DCRN_DMA0_BASE + 0x1)  /* DMA Count 0 */
 #define DCRN_DMASAH0	(DCRN_DMA0_BASE + 0x2)	/* DMA Src Addr High 0 */
@@ -425,9 +503,12 @@
 #define MQ0_CONFIG_SIZE_1G		0x0000e000
 #define MQ0_CONFIG_SIZE_2G		0x0000c000
 
-/* Internal SRAM Controller 440GX/440SP */
+/* Internal SRAM Controller 440GX/440SP or 440EPX/440GRX */
+#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
+#define DCRN_SRAM0_BASE		0x360
+#else
 #define DCRN_SRAM0_BASE		0x000
-
+#endif
 #define DCRN_SRAM0_SB0CR	(DCRN_SRAM0_BASE + 0x020)
 #define DCRN_SRAM0_SB1CR	(DCRN_SRAM0_BASE + 0x021)
 #define DCRN_SRAM0_SB2CR	(DCRN_SRAM0_BASE + 0x022)
@@ -613,7 +694,7 @@
 #define IIC_CLOCK		50
 
 #undef NR_UICS
-#ifdef CONFIG_440GX
+#if defined(CONFIG_440GX) || defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
 #define NR_UICS 3
 #else
 #define NR_UICS 2
Index: linux-2.6.10/include/asm-ppc/ibm4xx.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ibm4xx.h
+++ linux-2.6.10/include/asm-ppc/ibm4xx.h
@@ -109,6 +109,10 @@ void ppc4xx_init(unsigned long r3, unsig
 #include <platforms/4xx/yosemite.h>
 #endif
 
+#if defined(CONFIG_SEQUOIA) || defined(CONFIG_RAINIER)
+#include <platforms/4xx/sequoia.h>
+#endif
+
 #if defined(CONFIG_EBONY)
 #include <platforms/4xx/ebony.h>
 #endif
Index: linux-2.6.10/include/asm-ppc/ppcboot.h
===================================================================
--- linux-2.6.10.orig/include/asm-ppc/ppcboot.h
+++ linux-2.6.10/include/asm-ppc/ppcboot.h
@@ -99,9 +99,25 @@ typedef struct bd_info {
 	int		bi_phynum[4];		/* phy mapping */
 	int		bi_phymode[4];		/* phy mode */
 #endif
+#if defined (CONFIG_440EPX)|| defined (CONFIG_440GRX)
+	unsigned int	bi_phynum[2];		/* phy mapping */
+	unsigned int	bi_phymode[2];		/* phy mode */
+#endif
+#if defined (CONFIG_440EPX)|| defined (CONFIG_440GRX)
+	unsigned int	bi_funct_select[30];	/* configuration selection*/
+#endif
 } bd_t;
 
 #define bi_tbfreq	bi_intfreq
 
+/* UBoot ENET Mode definition     */
+#define BI_PHYMODE_NONE		0
+#define BI_PHYMODE_MII		1
+#define BI_PHYMODE_RGMII	2
+#define BI_PHYMODE_GMII		3
+#define BI_PHYMODE_RTBI		4
+#define BI_PHYMODE_TBI		5
+#define BI_PHYMODE_SMII		6
+
 #endif /* __ASSEMBLY__ */
 #endif	/* __ASM_PPCBOOT_H__ */
Index: linux-2.6.10/mvl_patches/pro-1182.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-1182.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1182);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

