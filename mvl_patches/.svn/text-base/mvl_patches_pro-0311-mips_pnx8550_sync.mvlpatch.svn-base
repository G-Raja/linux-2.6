#! /usr/bin/env bash
# Patch: -mips_pnx8550_sync
# Date: Mon Mar  6 10:13:58 2006
# Source: MontaVista Software, Inc.
# MR: 16189
# Type: Integration
# Disposition: merged from linux-mips.org
# Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
# Description:
#     Philips PNX8550 board support
# 
#  arch/mips/Kconfig                                 |   25 
#  arch/mips/Makefile                                |   13 
#  arch/mips/configs/pnx8550-jbs_defconfig           | 1117 ++++++++++++++++++
#  arch/mips/configs/pnx8550-v2pci_defconfig         | 1302 ++++++++++++++++++++++
#  arch/mips/kernel/cpu-probe.c                      |   18 
#  arch/mips/kernel/proc.c                           |    3 
#  arch/mips/kernel/time.c                           |    2 
#  arch/mips/mm/tlbex.c                              |    1 
#  arch/mips/pci/Makefile                            |    1 
#  arch/mips/pci/fixup-pnx8550.c                     |   57 
#  arch/mips/pci/ops-pnx8550.c                       |  284 ++++
#  arch/mips/philips/pnx8550/common/Kconfig          |    1 
#  arch/mips/philips/pnx8550/common/Makefile         |   27 
#  arch/mips/philips/pnx8550/common/gdb_hook.c       |  109 +
#  arch/mips/philips/pnx8550/common/int.c            |  293 ++++
#  arch/mips/philips/pnx8550/common/mipsIRQ.S        |   76 +
#  arch/mips/philips/pnx8550/common/pci.c            |  133 ++
#  arch/mips/philips/pnx8550/common/platform.c       |  135 ++
#  arch/mips/philips/pnx8550/common/proc.c           |  113 +
#  arch/mips/philips/pnx8550/common/prom.c           |  138 ++
#  arch/mips/philips/pnx8550/common/reset.c          |   49 
#  arch/mips/philips/pnx8550/common/setup.c          |  151 ++
#  arch/mips/philips/pnx8550/common/time.c           |  105 +
#  arch/mips/philips/pnx8550/jbs/Makefile            |    4 
#  arch/mips/philips/pnx8550/jbs/board_setup.c       |   65 +
#  arch/mips/philips/pnx8550/jbs/init.c              |   57 
#  arch/mips/philips/pnx8550/jbs/irqmap.c            |   36 
#  drivers/serial/Kconfig                            |   19 
#  drivers/serial/Makefile                           |    1 
#  drivers/serial/ip3106_uart.c                      |  912 +++++++++++++++
#  drivers/usb/host/ohci-hcd.c                       |    4 
#  drivers/usb/host/ohci-pnx8550.c                   |  352 +++++
#  include/asm-mips/bootinfo.h                       |    1 
#  include/asm-mips/cpu.h                            |    5 
#  include/asm-mips/mach-pnx8550/cm.h                |   43 
#  include/asm-mips/mach-pnx8550/glb.h               |   86 +
#  include/asm-mips/mach-pnx8550/int.h               |  140 ++
#  include/asm-mips/mach-pnx8550/kernel-entry-init.h |  262 ++++
#  include/asm-mips/mach-pnx8550/nand.h              |  121 ++
#  include/asm-mips/mach-pnx8550/pci.h               |  185 +++
#  include/asm-mips/mach-pnx8550/uart.h              |   16 
#  include/asm-mips/mach-pnx8550/usb.h               |   32 
#  include/asm-mips/mipsregs.h                       |   14 
#  include/linux/serial_core.h                       |    2 
#  include/linux/serial_ip3106.h                     |   93 +
#  45 files changed, 6601 insertions(+), 2 deletions(-)
# 

PATCHNUM=311
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 16189
Type: Integration
Disposition: merged from linux-mips.org
Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
Description:
    Philips PNX8550 board support

 arch/mips/Kconfig                                 |   25 
 arch/mips/Makefile                                |   13 
 arch/mips/configs/pnx8550-jbs_defconfig           | 1117 ++++++++++++++++++
 arch/mips/configs/pnx8550-v2pci_defconfig         | 1302 ++++++++++++++++++++++
 arch/mips/kernel/cpu-probe.c                      |   18 
 arch/mips/kernel/proc.c                           |    3 
 arch/mips/kernel/time.c                           |    2 
 arch/mips/mm/tlbex.c                              |    1 
 arch/mips/pci/Makefile                            |    1 
 arch/mips/pci/fixup-pnx8550.c                     |   57 
 arch/mips/pci/ops-pnx8550.c                       |  284 ++++
 arch/mips/philips/pnx8550/common/Kconfig          |    1 
 arch/mips/philips/pnx8550/common/Makefile         |   27 
 arch/mips/philips/pnx8550/common/gdb_hook.c       |  109 +
 arch/mips/philips/pnx8550/common/int.c            |  293 ++++
 arch/mips/philips/pnx8550/common/mipsIRQ.S        |   76 +
 arch/mips/philips/pnx8550/common/pci.c            |  133 ++
 arch/mips/philips/pnx8550/common/platform.c       |  135 ++
 arch/mips/philips/pnx8550/common/proc.c           |  113 +
 arch/mips/philips/pnx8550/common/prom.c           |  138 ++
 arch/mips/philips/pnx8550/common/reset.c          |   49 
 arch/mips/philips/pnx8550/common/setup.c          |  151 ++
 arch/mips/philips/pnx8550/common/time.c           |  105 +
 arch/mips/philips/pnx8550/jbs/Makefile            |    4 
 arch/mips/philips/pnx8550/jbs/board_setup.c       |   65 +
 arch/mips/philips/pnx8550/jbs/init.c              |   57 
 arch/mips/philips/pnx8550/jbs/irqmap.c            |   36 
 drivers/serial/Kconfig                            |   19 
 drivers/serial/Makefile                           |    1 
 drivers/serial/ip3106_uart.c                      |  912 +++++++++++++++
 drivers/usb/host/ohci-hcd.c                       |    4 
 drivers/usb/host/ohci-pnx8550.c                   |  352 +++++
 include/asm-mips/bootinfo.h                       |    1 
 include/asm-mips/cpu.h                            |    5 
 include/asm-mips/mach-pnx8550/cm.h                |   43 
 include/asm-mips/mach-pnx8550/glb.h               |   86 +
 include/asm-mips/mach-pnx8550/int.h               |  140 ++
 include/asm-mips/mach-pnx8550/kernel-entry-init.h |  262 ++++
 include/asm-mips/mach-pnx8550/nand.h              |  121 ++
 include/asm-mips/mach-pnx8550/pci.h               |  185 +++
 include/asm-mips/mach-pnx8550/uart.h              |   16 
 include/asm-mips/mach-pnx8550/usb.h               |   32 
 include/asm-mips/mipsregs.h                       |   14 
 include/linux/serial_core.h                       |    2 
 include/linux/serial_ip3106.h                     |   93 +
 mvl_patches/pro-0311.c                            |   16 
 46 files changed, 6617 insertions(+), 2 deletions(-)

Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -363,6 +363,20 @@ config MOMENCO_OCELOT_3
 	  The Ocelot-3 is based off Discovery III System Controller and
 	  PMC-Sierra Rm79000 core.
 
+config PNX8550_V2PCI
+	bool "Support for Philips PNX8550 based Viper2-PCI board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PNX8550_JBS
+	bool "Support for Philips PNX8550 based JBS board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+#if PNX8550_JBS
+	source "arch/mips/philips/pnx8550/common/Kconfig"
+#endif
+
 config MOMENCO_JAGUAR_ATX
 	bool "Support for Momentum Jaguar board"
 	select BOOT_ELF32
@@ -1100,6 +1114,17 @@ config ITE_BOARD_GEN
 	depends on MIPS_IVR || MIPS_ITE8172
 	default y
 
+config PNX8550
+	bool
+	select SOC_PNX8550
+
+config SOC_PNX8550
+	bool
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+
 config SWAP_IO_SPACE
 	bool
 
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -543,6 +543,19 @@ core-$(CONFIG_TANBAC_TB0229)	+= arch/mip
 load-$(CONFIG_TANBAC_TB0229)	+= 0xffffffff80000000
 
 #
+# Common Philips PNX8550
+#
+core-$(CONFIG_SOC_PNX8550)	+= arch/mips/philips/pnx8550/common/
+cflags-$(CONFIG_SOC_PNX8550)	+= -Iinclude/asm-mips/mach-pnx8550
+
+#
+# Philips PNX8550 JBS board
+#
+libs-$(CONFIG_PNX8550_JBS)	+= arch/mips/philips/pnx8550/jbs/
+#cflags-$(CONFIG_PNX8550_JBS)	+= -Iinclude/asm-mips/mach-pnx8550
+load-$(CONFIG_PNX8550_JBS)	+= 0xffffffff80060000
+
+#
 # SGI IP22 (Indy/Indigo2)
 #
 # Set the load address to >= 0xffffffff88069000 if you want to leave space for
Index: linux-2.6.10/arch/mips/configs/pnx8550-jbs_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/configs/pnx8550-jbs_defconfig
@@ -0,0 +1,1117 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15-rc2
+# Thu Nov 24 01:06:54 2005
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+CONFIG_PNX8550_JBS=y
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_PNX8550=y
+CONFIG_SOC_PNX8550=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_DEBUG is not set
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+CONFIG_BLK_DEV_IDESCSI=y
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_BLK_DEV_OFFBOARD=y
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_PCI_AUTO is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+CONFIG_BLK_DEV_HPT366=y
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+CONFIG_ISCSI_TCP=m
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_TUNE_TWISTER=y
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_IP3106 is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS1,38400n8 kgdb=ttyS0 root=/dev/nfs ip=bootp"
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_KGDB is not set
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_MIPS_UNCACHED is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=m
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
Index: linux-2.6.10/arch/mips/configs/pnx8550-v2pci_defconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/configs/pnx8550-v2pci_defconfig
@@ -0,0 +1,1302 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15-rc2
+# Thu Nov 24 01:06:58 2005
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+CONFIG_PNX8550_V2PCI=y
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_PNX8550=y
+CONFIG_SOC_PNX8550=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+CONFIG_CPU_ADVANCED=y
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+# CONFIG_NF_CONNTRACK is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+CONFIG_BLK_DEV_CMD64X=y
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=m
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+CONFIG_ISCSI_TCP=m
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+# CONFIG_AIC7XXX_REG_PRETTY_PRINT is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+CONFIG_NATSEMI=y
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPP_MPPE=m
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_IP3106 is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_RTC_X1205_I2C is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON_OLD is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
Index: linux-2.6.10/arch/mips/kernel/cpu-probe.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/cpu-probe.c
+++ linux-2.6.10/arch/mips/kernel/cpu-probe.c
@@ -110,6 +110,7 @@ static inline void check_wait(void)
 /*	case CPU_20KC:*/
 	case CPU_24K:
 	case CPU_25KF:
+	case CPU_PR4450:
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
 		break;
@@ -560,6 +561,20 @@ static inline void cpu_probe_sandcraft(s
 	}
 }
 
+static inline void cpu_probe_philips(struct cpuinfo_mips *c)
+{
+	decode_config1(c);
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_PR4450:
+		c->cputype = CPU_PR4450;
+		c->isa_level = MIPS_CPU_ISA_M32;
+		break;
+	default:
+		panic("Unknown Philips Core!"); /* REVISIT: die? */
+		break;
+	}
+}
+
 __init void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -586,6 +601,9 @@ __init void cpu_probe(void)
 	case PRID_COMP_SANDCRAFT:
 		cpu_probe_sandcraft(c);
 		break;
+	case PRID_COMP_PHILIPS:
+		cpu_probe_philips(c);
+		break;
 	default:
 		c->cputype = CPU_UNKNOWN;
 	}
Index: linux-2.6.10/arch/mips/kernel/proc.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/proc.c
+++ linux-2.6.10/arch/mips/kernel/proc.c
@@ -75,7 +75,8 @@ static const char *cpu_name[] = {
 	[CPU_VR4133]	"NEC VR4133",
 	[CPU_VR4181]	"NEC VR4181",
 	[CPU_VR4181A]	"NEC VR4181A",
-	[CPU_SR71000]	"Sandcraft SR71000"
+	[CPU_SR71000]	"Sandcraft SR71000",
+	[CPU_PR4450]	"Philips PR4450"
 };
 
 #if defined(CONFIG_CPU_TIMER)
Index: linux-2.6.10/arch/mips/kernel/time.c
===================================================================
--- linux-2.6.10.orig/arch/mips/kernel/time.c
+++ linux-2.6.10/arch/mips/kernel/time.c
@@ -108,8 +108,10 @@ static void c0_timer_ack(void)
 {
 	unsigned int count;
 
+#ifndef CONFIG_SOC_PNX8550	/* pnx8550 resets to zero */
 	/* Ack this timer interrupt and set the next one.  */
 	expirelo += cycles_per_jiffy;
+#endif
 	write_c0_compare(expirelo);
 
 	/* Check to see if we have missed any timer interrupts.  */
Index: linux-2.6.10/arch/mips/pci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/pci/Makefile
+++ linux-2.6.10/arch/mips/pci/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_MIPS_ITE8172)	+= fixup-ite8
 obj-$(CONFIG_MIPS_IVR)		+= fixup-ivr.o
 obj-$(CONFIG_SOC_AU1500)	+= fixup-au1000.o ops-au1000.o
 obj-$(CONFIG_SOC_AU1550)	+= fixup-au1000.o ops-au1000.o
+obj-$(CONFIG_SOC_PNX8550)	+= fixup-pnx8550.o ops-pnx8550.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o
 obj-$(CONFIG_MOMENCO_JAGUAR_ATX)+= fixup-jaguar.o
 obj-$(CONFIG_MOMENCO_OCELOT)	+= fixup-ocelot.o pci-ocelot.o
Index: linux-2.6.10/arch/mips/pci/fixup-pnx8550.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/fixup-pnx8550.c
@@ -0,0 +1,57 @@
+/*
+ *  Philips PNX8550 pci fixups.
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddealley.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/mach-pnx8550/pci.h>
+#include <asm/mach-pnx8550/int.h>
+
+
+#undef	DEBUG
+#ifdef 	DEBUG
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)
+#endif
+
+extern char irq_tab_jbs[][5];
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+	/* no need to fixup IO resources */
+}
+
+void __init pcibios_fixup(void)
+{
+	/* nothing to do here */
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return irq_tab_jbs[slot][pin];
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
Index: linux-2.6.10/arch/mips/pci/ops-pnx8550.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/ops-pnx8550.c
@@ -0,0 +1,284 @@
+/*
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *
+ *  2.6 port, Embedded Alley Solutions, Inc
+ *
+ *  Based on:
+ *  Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+
+#include <asm/mach-pnx8550/pci.h>
+#include <asm/mach-pnx8550/glb.h>
+#include <asm/debug.h>
+
+
+static inline void clear_status(void)
+{
+	unsigned long pci_stat;
+
+	pci_stat = inl(PCI_BASE | PCI_GPPM_STATUS);
+	outl(pci_stat, PCI_BASE | PCI_GPPM_ICLR);
+}
+
+static inline unsigned int
+calc_cfg_addr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+	unsigned int addr;
+
+	addr = ((bus->number > 0) ? (((bus->number & 0xff) << PCI_CFG_BUS_SHIFT) | 1) : 0);
+	addr |= ((devfn & 0xff) << PCI_CFG_FUNC_SHIFT) | (where & 0xfc);
+
+	return addr;
+}
+
+static int
+config_access(unsigned int pci_cmd, struct pci_bus *bus, unsigned int devfn, int where, unsigned int pci_mode, unsigned int *val)
+{
+	unsigned int flags;
+	unsigned long loops = 0;
+	unsigned long ioaddr = calc_cfg_addr(bus, devfn, where);
+
+	local_irq_save(flags);
+	/*Clear pending interrupt status */
+	if (inl(PCI_BASE | PCI_GPPM_STATUS)) {
+		clear_status();
+		while (!(inl(PCI_BASE | PCI_GPPM_STATUS) == 0)) ;
+	}
+
+	outl(ioaddr, PCI_BASE | PCI_GPPM_ADDR);
+
+	if ((pci_cmd == PCI_CMD_IOW) || (pci_cmd == PCI_CMD_CONFIG_WRITE))
+		outl(*val, PCI_BASE | PCI_GPPM_WDAT);
+
+	outl(INIT_PCI_CYCLE | pci_cmd | (pci_mode & PCI_BYTE_ENABLE_MASK),
+	     PCI_BASE | PCI_GPPM_CTRL);
+
+	loops =
+	    ((loops_per_jiffy *
+	      PCI_IO_JIFFIES_TIMEOUT) >> (PCI_IO_JIFFIES_SHIFT));
+	while (1) {
+		if (inl(PCI_BASE | PCI_GPPM_STATUS) & GPPM_DONE) {
+			if ((pci_cmd == PCI_CMD_IOR) ||
+			    (pci_cmd == PCI_CMD_CONFIG_READ))
+				*val = inl(PCI_BASE | PCI_GPPM_RDAT);
+			clear_status();
+			local_irq_restore(flags);
+			return PCIBIOS_SUCCESSFUL;
+		} else if (inl(PCI_BASE | PCI_GPPM_STATUS) & GPPM_R_MABORT) {
+			break;
+		}
+
+		loops--;
+		if (loops == 0) {
+			printk("%s : Arbiter Locked.\n", __FUNCTION__);
+		}
+	}
+
+	clear_status();
+	if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_IOW)) {
+		printk("%s timeout (GPPM_CTRL=%X) ioaddr %lX pci_cmd %X\n",
+		       __FUNCTION__, inl(PCI_BASE | PCI_GPPM_CTRL), ioaddr,
+		       pci_cmd);
+	}
+
+	if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_CONFIG_READ))
+		*val = 0xffffffff;
+	local_irq_restore(flags);
+	return PCIBIOS_DEVICE_NOT_FOUND;
+}
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int
+read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 * val)
+{
+	unsigned int data = 0;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(1 << (where & 3)), &data);
+	switch (where & 0x03) {
+	case 0:
+		*val = (unsigned char)(data & 0x000000ff);
+		break;
+	case 1:
+		*val = (unsigned char)((data & 0x0000ff00) >> 8);
+		break;
+	case 2:
+		*val = (unsigned char)((data & 0x00ff0000) >> 16);
+		break;
+	case 3:
+		*val = (unsigned char)((data & 0xff000000) >> 24);
+		break;
+	}
+
+	return err;
+}
+
+static int
+read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 * val)
+{
+	unsigned int data = 0;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x01)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(3 << (where & 3)), &data);
+	switch (where & 0x02) {
+	case 0:
+		*val = (unsigned short)(data & 0x0000ffff);
+		break;
+	case 2:
+		*val = (unsigned short)((data & 0xffff0000) >> 16);
+		break;
+	}
+
+	return err;
+}
+
+static int
+read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 * val)
+{
+	int err;
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x03)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, 0, val);
+
+	return err;
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 val)
+{
+	unsigned int data = (unsigned int)val;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	switch (where & 0x03) {
+	case 1:
+		data = (data << 8);
+		break;
+	case 2:
+		data = (data << 16);
+		break;
+	case 3:
+		data = (data << 24);
+		break;
+	default:
+		break;
+	}
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(1 << (where & 3)), &data);
+
+	return err;
+}
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 val)
+{
+	unsigned int data = (unsigned int)val;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x01)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (where & 0x02) {
+	case 2:
+		data = (data << 16);
+		break;
+	default:
+		break;
+	}
+	err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, ~(3 << (where & 3)), &data);
+
+	return err;
+}
+
+static int
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
+{
+	int err;
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x03)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, 0, &val);
+
+	return err;
+}
+
+static int config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1: {
+			u8 _val;
+			int rc = read_config_byte(bus, devfn, where, &_val);
+			*val = _val;
+			return rc;
+		}
+       case 2: {
+			u16 _val;
+			int rc = read_config_word(bus, devfn, where, &_val);
+			*val = _val;
+			return rc;
+		}
+	default:
+		return read_config_dword(bus, devfn, where, val);
+	}
+}
+
+static int config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	switch (size) {
+	case 1:
+		return write_config_byte(bus, devfn, where, (u8) val);
+	case 2:
+		return write_config_word(bus, devfn, where, (u16) val);
+	default:
+		return write_config_dword(bus, devfn, where, val);
+	}
+}
+
+struct pci_ops pnx8550_pci_ops = {
+	config_read,
+	config_write
+};
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/Kconfig
@@ -0,0 +1 @@
+# Place holder
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/Makefile
@@ -0,0 +1,27 @@
+#
+# Per Hallsmark, per.hallsmark@mvista.com
+#
+# ########################################################################
+#
+# This program is free software; you can distribute it and/or modify it
+# under the terms of the GNU General Public License (Version 2) as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+#
+# #######################################################################
+#
+# Makefile for the PNX8550 specific kernel interface routines
+# under Linux.
+#
+
+obj-y := setup.o prom.o mipsIRQ.o int.o reset.o time.o proc.o platform.o
+obj-$(CONFIG_PCI) += pci.o
+obj-$(CONFIG_KGDB) += gdb_hook.o
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/gdb_hook.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/gdb_hook.c
@@ -0,0 +1,109 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * This is the interface to the remote debugger stub.
+ *
+ */
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/serial.h>
+#include <asm/io.h>
+
+#include <uart.h>
+
+static struct serial_state rs_table[IP3106_NR_PORTS] = {
+};
+static struct async_struct kdb_port_info = {0};
+
+void rs_kgdb_hook(int tty_no)
+{
+	struct serial_state *ser = &rs_table[tty_no];
+
+	kdb_port_info.state = ser;
+	kdb_port_info.magic = SERIAL_MAGIC;
+	kdb_port_info.port  = tty_no;
+	kdb_port_info.flags = ser->flags;
+
+	/*
+	 * Clear all interrupts
+	 */
+	/* Clear all the transmitter FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, tty_no) |= IP3106_UART_LCR_TX_RST;
+	/* Clear all the receiver FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, tty_no) |= IP3106_UART_LCR_RX_RST;
+	/* Clear all interrupts */
+	ip3106_iclr(UART_BASE, tty_no) = IP3106_UART_INT_ALLRX |
+		IP3106_UART_INT_ALLTX;
+
+	/*
+	 * Now, initialize the UART
+	 */
+	ip3106_lcr(UART_BASE, tty_no) = IP3106_UART_LCR_8BIT;
+	ip3106_baud(UART_BASE, tty_no) = 5; // 38400 Baud
+}
+
+int putDebugChar(char c)
+{
+	/* Wait until FIFO not full */
+	while (((ip3106_fifo(UART_BASE, kdb_port_info.port) & IP3106_UART_FIFO_TXFIFO) >> 16) >= 16)
+		;
+	/* Send one char */
+	ip3106_fifo(UART_BASE, kdb_port_info.port) = c;
+
+	return 1;
+}
+
+char getDebugChar(void)
+{
+	char ch;
+
+	/* Wait until there is a char in the FIFO */
+	while (!((ip3106_fifo(UART_BASE, kdb_port_info.port) &
+					IP3106_UART_FIFO_RXFIFO) >> 8))
+		;
+	/* Read one char */
+	ch = ip3106_fifo(UART_BASE, kdb_port_info.port) &
+		IP3106_UART_FIFO_RBRTHR;
+	/* Advance the RX FIFO read pointer */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_RX_NEXT;
+	return (ch);
+}
+
+void rs_disable_debug_interrupts(void)
+{
+	ip3106_ien(UART_BASE, kdb_port_info.port) = 0; /* Disable all interrupts */
+}
+
+void rs_enable_debug_interrupts(void)
+{
+	/* Clear all the transmitter FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_TX_RST;
+	/* Clear all the receiver FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_RX_RST;
+	/* Clear all interrupts */
+	ip3106_iclr(UART_BASE, kdb_port_info.port) = IP3106_UART_INT_ALLRX |
+		IP3106_UART_INT_ALLTX;
+	ip3106_ien(UART_BASE, kdb_port_info.port)  = IP3106_UART_INT_ALLRX; /* Enable RX interrupts */
+}
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/int.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/int.c
@@ -0,0 +1,293 @@
+/*
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ * Ported to 2.6.
+ *
+ * Per Hallsmark, per.hallsmark@mvista.com
+ * Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2001 Ralf Baechle
+ *
+ * Cleaned up and bug fixing: Pete Popov, ppopov@embeddedalley.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/random.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/gdb-stub.h>
+#include <int.h>
+#include <uart.h>
+
+extern asmlinkage void cp0_irqdispatch(void);
+
+static DEFINE_SPINLOCK(irq_lock);
+
+/* default prio for interrupts */
+/* first one is a no-no so therefore always prio 0 (disabled) */
+static char gic_prio[PNX8550_INT_GIC_TOTINT] = {
+	0, 1, 1, 1, 1, 15, 1, 1, 1, 1,	//   0 -  9
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  10 - 19
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  20 - 29
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  30 - 39
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  40 - 49
+	1, 1, 1, 1, 1, 1, 1, 1, 2, 1,	//  50 - 59
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  60 - 69
+	1			//  70
+};
+
+void hw0_irqdispatch(int irq, struct pt_regs *regs)
+{
+	/* find out which interrupt */
+	irq = PNX8550_GIC_VECTOR_0 >> 3;
+
+	if (irq == 0) {
+		printk("hw0_irqdispatch: irq 0, spurious interrupt?\n");
+		return;
+	}
+	do_IRQ(PNX8550_INT_GIC_MIN + irq, regs);
+}
+
+
+void timer_irqdispatch(int irq, struct pt_regs *regs)
+{
+	irq = (0x01c0 & read_c0_config7()) >> 6;
+
+	if (irq == 0) {
+		printk("timer_irqdispatch: irq 0, spurious interrupt?\n");
+		return;
+	}
+
+	if (irq & 0x1) {
+		do_IRQ(PNX8550_INT_TIMER1, regs);
+	}
+	if (irq & 0x2) {
+		do_IRQ(PNX8550_INT_TIMER2, regs);
+	}
+	if (irq & 0x4) {
+		do_IRQ(PNX8550_INT_TIMER3, regs);
+	}
+}
+
+static inline void modify_cp0_intmask(unsigned clr_mask, unsigned set_mask)
+{
+	unsigned long status = read_c0_status();
+
+	status &= ~((clr_mask & 0xFF) << 8);
+	status |= (set_mask & 0xFF) << 8;
+
+	write_c0_status(status);
+}
+
+static inline void mask_gic_int(unsigned int irq_nr)
+{
+	/* interrupt disabled, bit 26(WE_ENABLE)=1 and bit 16(enable)=0 */
+	PNX8550_GIC_REQ(irq_nr) = 1<<28; /* set priority to 0 */
+}
+
+static inline void unmask_gic_int(unsigned int irq_nr)
+{
+	/* set prio mask to lower four bits and enable interrupt */
+	PNX8550_GIC_REQ(irq_nr) = (1<<26 | 1<<16) | (1<<28) | gic_prio[irq_nr];
+}
+
+static inline void mask_irq(unsigned int irq_nr)
+{
+	if ((PNX8550_INT_CP0_MIN <= irq_nr) && (irq_nr <= PNX8550_INT_CP0_MAX)) {
+		modify_cp0_intmask(1 << irq_nr, 0);
+	} else if ((PNX8550_INT_GIC_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_GIC_MAX)) {
+		mask_gic_int(irq_nr - PNX8550_INT_GIC_MIN);
+	} else if ((PNX8550_INT_TIMER_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_TIMER_MAX)) {
+		modify_cp0_intmask(1 << 7, 0);
+	} else {
+		printk("mask_irq: irq %d doesn't exist!\n", irq_nr);
+	}
+}
+
+static inline void unmask_irq(unsigned int irq_nr)
+{
+	if ((PNX8550_INT_CP0_MIN <= irq_nr) && (irq_nr <= PNX8550_INT_CP0_MAX)) {
+		modify_cp0_intmask(0, 1 << irq_nr);
+	} else if ((PNX8550_INT_GIC_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_GIC_MAX)) {
+		unmask_gic_int(irq_nr - PNX8550_INT_GIC_MIN);
+	} else if ((PNX8550_INT_TIMER_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_TIMER_MAX)) {
+		modify_cp0_intmask(0, 1 << 7);
+	} else {
+		printk("mask_irq: irq %d doesn't exist!\n", irq_nr);
+	}
+}
+
+#define pnx8550_disable pnx8550_ack
+static void pnx8550_ack(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_lock, flags);
+	mask_irq(irq);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+#define pnx8550_enable pnx8550_unmask
+static void pnx8550_unmask(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_lock, flags);
+	unmask_irq(irq);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+static unsigned int startup_irq(unsigned int irq_nr)
+{
+	pnx8550_unmask(irq_nr);
+	return 0;
+}
+
+static void shutdown_irq(unsigned int irq_nr)
+{
+	pnx8550_ack(irq_nr);
+	return;
+}
+
+int pnx8550_set_gic_priority(int irq, int priority)
+{
+	int gic_irq = irq-PNX8550_INT_GIC_MIN;
+	int prev_priority = PNX8550_GIC_REQ(gic_irq) & 0xf;
+
+        gic_prio[gic_irq] = priority;
+	PNX8550_GIC_REQ(gic_irq) |= (0x10000000 | gic_prio[gic_irq]);
+
+	return prev_priority;
+}
+
+static inline void mask_and_ack_level_irq(unsigned int irq)
+{
+	pnx8550_disable(irq);
+	return;
+}
+
+static void end_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pnx8550_enable(irq);
+	}
+}
+
+static struct hw_interrupt_type level_irq_type = {
+	.typename =	"PNX Level IRQ",
+	.startup =	startup_irq,
+	.shutdown =	shutdown_irq,
+	.enable =	pnx8550_enable,
+	.disable =	pnx8550_disable,
+	.ack =		mask_and_ack_level_irq,
+	.end =		end_irq,
+};
+
+static struct irqaction gic_action = {
+	.handler =	no_action,
+	.flags =	SA_INTERRUPT,
+	.name =		"GIC",
+};
+
+static struct irqaction timer_action = {
+	.handler =	no_action,
+	.flags =	SA_INTERRUPT,
+	.name =		"Timer",
+};
+
+void __init arch_init_irq(void)
+{
+	int i;
+	int configPR;
+
+	/* init of cp0 interrupts */
+	set_except_vector(0, cp0_irqdispatch);
+
+	for (i = 0; i < PNX8550_INT_CP0_TOTINT; i++) {
+		irq_desc[i].handler = &level_irq_type;
+		pnx8550_ack(i);	/* mask the irq just in case  */
+	}
+
+	/* init of GIC/IPC interrupts */
+	/* should be done before cp0 since cp0 init enables the GIC int */
+	for (i = PNX8550_INT_GIC_MIN; i <= PNX8550_INT_GIC_MAX; i++) {
+		int gic_int_line = i - PNX8550_INT_GIC_MIN;
+		if (gic_int_line == 0 )
+			continue;	// don't fiddle with int 0
+		/*
+		 * enable change of TARGET, ENABLE and ACTIVE_LOW bits
+		 * set TARGET        0 to route through hw0 interrupt
+		 * set ACTIVE_LOW    0 active high  (correct?)
+		 *
+		 * We really should setup an interrupt description table
+		 * to do this nicely.
+		 * Note, PCI INTA is active low on the bus, but inverted
+		 * in the GIC, so to us it's active high.
+		 */
+#ifdef CONFIG_PNX8550_V2PCI
+		if (gic_int_line == (PNX8550_INT_GPIO0 - PNX8550_INT_GIC_MIN)) {
+			/* PCI INT through gpio 8, which is setup in
+			 * pnx8550_setup.c and routed to GPIO
+ 			 * Interrupt Level 0 (GPIO Connection 58).
+			 * Set it active low. */
+
+			PNX8550_GIC_REQ(gic_int_line) = 0x1E020000;
+		} else
+#endif
+		{
+			PNX8550_GIC_REQ(i - PNX8550_INT_GIC_MIN) = 0x1E000000;
+		}
+
+		/* mask/priority is still 0 so we will not get any
+		 * interrupts until it is unmasked */
+
+		irq_desc[i].handler = &level_irq_type;
+	}
+
+	/* Priority level 0 */
+	PNX8550_GIC_PRIMASK_0 = PNX8550_GIC_PRIMASK_1 = 0;
+
+	/* Set int vector table address */
+	PNX8550_GIC_VECTOR_0 = PNX8550_GIC_VECTOR_1 = 0;
+
+	irq_desc[MIPS_CPU_GIC_IRQ].handler = &level_irq_type;
+	setup_irq(MIPS_CPU_GIC_IRQ, &gic_action);
+
+	/* init of Timer interrupts */
+	for (i = PNX8550_INT_TIMER_MIN; i <= PNX8550_INT_TIMER_MAX; i++) {
+		irq_desc[i].handler = &level_irq_type;
+	}
+
+	/* Stop Timer 1-3 */
+	configPR = read_c0_config7();
+	configPR |= 0x00000038;
+	write_c0_config7(configPR);
+
+	irq_desc[MIPS_CPU_TIMER_IRQ].handler = &level_irq_type;
+	setup_irq(MIPS_CPU_TIMER_IRQ, &timer_action);
+}
+
+EXPORT_SYMBOL(pnx8550_set_gic_priority);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/mipsIRQ.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/mipsIRQ.S
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2002 Philips, Inc. All rights.
+ * Copyright (c) 2002 Red Hat, Inc. All rights.
+ *
+ * This software may be freely redistributed under the terms of the
+ * GNU General Public License.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Based upon arch/mips/galileo-boards/ev64240/int-handler.S
+ *
+ */
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ * cp0_irqdispatch
+ *
+ *    Code to handle in-core interrupt exception.
+ */
+
+		.align	5
+		.set	reorder
+		.set	noat
+		NESTED(cp0_irqdispatch, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+		mfc0	t0,CP0_CAUSE
+		mfc0	t2,CP0_STATUS
+
+		and	t0,t2
+
+		andi	t1,t0,STATUSF_IP2 /* int0 hardware line */
+		bnez	t1,ll_hw0_irq
+		nop
+
+		andi	t1,t0,STATUSF_IP7 /* int5 hardware line */
+		bnez	t1,ll_timer_irq
+		nop
+
+		/* wrong alarm or masked ... */
+
+		j	spurious_interrupt
+		nop
+		END(cp0_irqdispatch)
+
+		.align	5
+		.set	reorder
+ll_hw0_irq:
+		li	a0,2
+		move	a1,sp
+		jal	hw0_irqdispatch
+		nop
+		j	ret_from_irq
+		nop
+
+		.align	5
+		.set	reorder
+ll_timer_irq:
+		mfc0	t3,CP0_CONFIG,7
+		andi	t4,t3,0x01c0
+		beqz	t4,ll_timer_out
+		nop
+		li	a0,7
+		move	a1,sp
+		jal	timer_irqdispatch
+		nop
+
+ll_timer_out:	j	ret_from_irq
+		nop
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/pci.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/pci.c
@@ -0,0 +1,133 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <pci.h>
+#include <glb.h>
+#include <nand.h>
+
+static struct resource pci_io_resource = {
+	"pci IO space",
+	(u32)(PNX8550_PCIIO + 0x1000),	/* reserve regacy I/O space */
+	(u32)(PNX8550_PCIIO + PNX8550_PCIIO_SIZE),
+	IORESOURCE_IO
+};
+
+static struct resource pci_mem_resource = {
+	"pci memory space",
+	(u32)(PNX8550_PCIMEM),
+	(u32)(PNX8550_PCIMEM + PNX8550_PCIMEM_SIZE - 1),
+	IORESOURCE_MEM
+};
+
+extern struct pci_ops pnx8550_pci_ops;
+
+static struct pci_controller pnx8550_controller = {
+	.pci_ops	= &pnx8550_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+};
+
+/* Return the total size of DRAM-memory, (RANK0 + RANK1) */
+static inline unsigned long get_system_mem_size(void)
+{
+	/* Read IP2031_RANK0_ADDR_LO */
+	unsigned long dram_r0_lo = inl(PCI_BASE | 0x65010);
+	/* Read IP2031_RANK1_ADDR_HI */
+	unsigned long dram_r1_hi = inl(PCI_BASE | 0x65018);
+
+	return dram_r1_hi - dram_r0_lo + 1;
+}
+
+static int __init pnx8550_pci_setup(void)
+{
+	int pci_mem_code;
+	int mem_size = get_system_mem_size() >> 20;
+
+	/* Clear the Global 2 Register, PCI Inta Output Enable Registers
+	   Bit 1:Enable DAC Powerdown
+	  -> 0:DACs are enabled and are working normally
+	     1:DACs are powerdown
+	   Bit 0:Enable of PCI inta output
+	  -> 0 = Disable PCI inta output
+	     1 = Enable PCI inta output
+	*/
+	PNX8550_GLB2_ENAB_INTA_O = 0;
+
+	/* Calc the PCI mem size code */
+	if (mem_size >= 128)
+		pci_mem_code = SIZE_128M;
+	else if (mem_size >= 64)
+		pci_mem_code = SIZE_64M;
+	else if (mem_size >= 32)
+		pci_mem_code = SIZE_32M;
+	else
+		pci_mem_code = SIZE_16M;
+
+	/* Set PCI_XIO registers */
+	outl(pci_mem_resource.start, PCI_BASE | PCI_BASE1_LO);
+	outl(pci_mem_resource.end + 1, PCI_BASE | PCI_BASE1_HI);
+	outl(pci_io_resource.start, PCI_BASE | PCI_BASE2_LO);
+	outl(pci_io_resource.end, PCI_BASE | PCI_BASE2_HI);
+
+	/* Send memory transaction via PCI_BASE2 */
+	outl(0x00000001, PCI_BASE | PCI_IO);
+
+	/* Unlock the setup register */
+	outl(0xca, PCI_BASE | PCI_UNLOCKREG);
+
+	/*
+	 * BAR0 of PNX8550 (pci base 10) must be zero in order for ide
+	 * to work, and in order for bus_to_baddr to work without any
+	 * hacks.
+	 */
+	outl(0x00000000, PCI_BASE | PCI_BASE10);
+
+	/*
+	 *These two bars are set by default or the boot code.
+	 * However, it's safer to set them here so we're not boot
+	 * code dependent.
+	 */
+	outl(0x1be00000, PCI_BASE | PCI_BASE14);  /* PNX MMIO */
+	outl(PNX8550_NAND_BASE_ADDR, PCI_BASE | PCI_BASE18);  /* XIO      */
+
+	outl(PCI_EN_TA |
+	     PCI_EN_PCI2MMI |
+	     PCI_EN_XIO |
+	     PCI_SETUP_BASE18_SIZE(SIZE_32M) |
+	     PCI_SETUP_BASE18_EN |
+	     PCI_SETUP_BASE14_EN |
+	     PCI_SETUP_BASE10_PREF |
+	     PCI_SETUP_BASE10_SIZE(pci_mem_code) |
+	     PCI_SETUP_CFGMANAGE_EN |
+	     PCI_SETUP_PCIARB_EN,
+	     PCI_BASE |
+	     PCI_SETUP);	/* PCI_SETUP */
+	outl(0x00000000, PCI_BASE | PCI_CTRL);	/* PCI_CONTROL */
+
+	register_pci_controller(&pnx8550_controller);
+
+	return 0;
+}
+
+arch_initcall(pnx8550_pci_setup);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/platform.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/platform.c
@@ -0,0 +1,135 @@
+/*
+ * Platform device support for Philips PNX8550 SoCs
+ *
+ * Copyright 2005, Embedded Alley Solutions, Inc
+ *
+ * Based on arch/mips/au1000/common/platform.c
+ * Platform device support for Au1x00 SoCs.
+ *
+ * Copyright 2004, Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+#include <linux/serial.h>
+#include <linux/serial_ip3106.h>
+
+#include <int.h>
+#include <usb.h>
+#include <uart.h>
+
+extern struct uart_ops ip3106_pops;
+
+static struct resource pnx8550_usb_ohci_resources[] = {
+	[0] = {
+		.start		= PNX8550_USB_OHCI_OP_BASE,
+		.end		= PNX8550_USB_OHCI_OP_BASE +
+				  PNX8550_USB_OHCI_OP_LEN,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= PNX8550_INT_USB,
+		.end		= PNX8550_INT_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource pnx8550_uart_resources[] = {
+	[0] = {
+		.start		= PNX8550_UART_PORT0,
+		.end		= PNX8550_UART_PORT0 + 0xfff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= PNX8550_UART_INT(0),
+		.end		= PNX8550_UART_INT(0),
+		.flags		= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start		= PNX8550_UART_PORT1,
+		.end		= PNX8550_UART_PORT1 + 0xfff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start		= PNX8550_UART_INT(1),
+		.end		= PNX8550_UART_INT(1),
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct ip3106_port ip3106_ports[] = {
+	[0] = {
+		.port   = {
+			.type		= PORT_IP3106,
+			.iotype		= SERIAL_IO_MEM,
+			.membase	= (void __iomem *)PNX8550_UART_PORT0,
+			.mapbase	= PNX8550_UART_PORT0,
+			.irq		= PNX8550_UART_INT(0),
+			.uartclk	= 3692300,
+			.fifosize	= 16,
+			.ops		= &ip3106_pops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+	},
+	[1] = {
+		.port   = {
+			.type		= PORT_IP3106,
+			.iotype		= SERIAL_IO_MEM,
+			.membase	= (void __iomem *)PNX8550_UART_PORT1,
+			.mapbase	= PNX8550_UART_PORT1,
+			.irq		= PNX8550_UART_INT(1),
+			.uartclk	= 3692300,
+			.fifosize	= 16,
+			.ops		= &ip3106_pops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static u64 uart_dmamask = ~(u32)0;
+
+static struct platform_device pnx8550_usb_ohci_device = {
+	.name		= "pnx8550-ohci",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(pnx8550_usb_ohci_resources),
+	.resource	= pnx8550_usb_ohci_resources,
+};
+
+static struct platform_device pnx8550_uart_device = {
+	.name		= "ip3106-uart",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data = ip3106_ports,
+	},
+	.num_resources	= ARRAY_SIZE(pnx8550_uart_resources),
+	.resource	= pnx8550_uart_resources,
+};
+
+static struct platform_device *pnx8550_platform_devices[] __initdata = {
+	&pnx8550_usb_ohci_device,
+	&pnx8550_uart_device,
+};
+
+int pnx8550_platform_init(void)
+{
+	return platform_add_devices(pnx8550_platform_devices,
+			            ARRAY_SIZE(pnx8550_platform_devices));
+}
+
+arch_initcall(pnx8550_platform_init);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/proc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/proc.c
@@ -0,0 +1,113 @@
+/*
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/random.h>
+
+#include <asm/io.h>
+#include <asm/gdb-stub.h>
+#include <int.h>
+#include <uart.h>
+
+
+static int pnx8550_timers_read (char* page, char** start, off_t offset, int count, int* eof, void* data)
+{
+        int len = 0;
+	int configPR = read_c0_config7();
+
+        if (offset==0) {
+		len += sprintf(&page[len],"Timer:       count,  compare, tc, status\n");
+                len += sprintf(&page[len],"    1: %11i, %8i,  %1i, %s\n",
+			       read_c0_count(), read_c0_compare(),
+			      (configPR>>6)&0x1, ((configPR>>3)&0x1)? "off":"on");
+                len += sprintf(&page[len],"    2: %11i, %8i,  %1i, %s\n",
+			       read_c0_count2(), read_c0_compare2(),
+			      (configPR>>7)&0x1, ((configPR>>4)&0x1)? "off":"on");
+                len += sprintf(&page[len],"    3: %11i, %8i,  %1i, %s\n",
+			       read_c0_count3(), read_c0_compare3(),
+			      (configPR>>8)&0x1, ((configPR>>5)&0x1)? "off":"on");
+        }
+
+        return len;
+}
+
+static int pnx8550_registers_read (char* page, char** start, off_t offset, int count, int* eof, void* data)
+{
+        int len = 0;
+
+        if (offset==0) {
+                len += sprintf(&page[len],"config1:   %#10.8x\n",read_c0_config1());
+                len += sprintf(&page[len],"config2:   %#10.8x\n",read_c0_config2());
+                len += sprintf(&page[len],"config3:   %#10.8x\n",read_c0_config3());
+                len += sprintf(&page[len],"configPR:  %#10.8x\n",read_c0_config7());
+                len += sprintf(&page[len],"status:    %#10.8x\n",read_c0_status());
+                len += sprintf(&page[len],"cause:     %#10.8x\n",read_c0_cause());
+                len += sprintf(&page[len],"count:     %#10.8x\n",read_c0_count());
+                len += sprintf(&page[len],"count_2:   %#10.8x\n",read_c0_count2());
+                len += sprintf(&page[len],"count_3:   %#10.8x\n",read_c0_count3());
+                len += sprintf(&page[len],"compare:   %#10.8x\n",read_c0_compare());
+                len += sprintf(&page[len],"compare_2: %#10.8x\n",read_c0_compare2());
+                len += sprintf(&page[len],"compare_3: %#10.8x\n",read_c0_compare3());
+        }
+
+        return len;
+}
+
+static struct proc_dir_entry* pnx8550_dir        = NULL;
+static struct proc_dir_entry* pnx8550_timers     = NULL;
+static struct proc_dir_entry* pnx8550_registers  = NULL;
+
+static int pnx8550_proc_init( void )
+{
+
+	// Create /proc/pnx8550
+        pnx8550_dir = create_proc_entry("pnx8550", S_IFDIR|S_IRUGO, NULL);
+        if (pnx8550_dir){
+                pnx8550_dir->nlink = 1;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 proc dir\n");
+                return -1;
+        }
+
+	// Create /proc/pnx8550/timers
+        pnx8550_timers = create_proc_entry("timers", S_IFREG|S_IRUGO, pnx8550_dir );
+        if (pnx8550_timers){
+                pnx8550_timers->nlink = 1;
+                pnx8550_timers->read_proc = pnx8550_timers_read;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 timers proc file\n");
+        }
+
+	// Create /proc/pnx8550/registers
+        pnx8550_registers = create_proc_entry("registers", S_IFREG|S_IRUGO, pnx8550_dir );
+        if (pnx8550_registers){
+                pnx8550_registers->nlink = 1;
+                pnx8550_registers->read_proc = pnx8550_registers_read;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 registers proc file\n");
+        }
+
+	return 0;
+}
+
+__initcall(pnx8550_proc_init);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/prom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/prom.c
@@ -0,0 +1,138 @@
+/*
+ *
+ * Per Hallsmark, per.hallsmark@mvista.com
+ *
+ * Based on jmr3927/common/prom.c
+ *
+ * 2004 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/bootinfo.h>
+#include <uart.h>
+
+/* #define DEBUG_CMDLINE */
+
+extern int prom_argc;
+extern char **prom_argv, **prom_envp;
+
+typedef struct
+{
+    char *name;
+/*    char *val; */
+}t_env_var;
+
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+}
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * Environment variables are stored in the form of "memsize=64".
+	 */
+
+	t_env_var *env = (t_env_var *)prom_envp;
+	int i;
+
+	i = strlen(envname);
+
+	while(env->name) {
+		if(strncmp(envname, env->name, i) == 0) {
+			return(env->name + strlen(envname) + 1);
+		}
+		env++;
+	}
+	return(NULL);
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+	return 0;
+}
+
+unsigned long __init prom_free_prom_memory(void)
+{
+	return 0;
+}
+
+extern int pnx8550_console_port;
+
+/* used by prom_printf */
+void prom_putchar(char c)
+{
+	if (pnx8550_console_port != -1) {
+		/* Wait until FIFO not full */
+		while( ((ip3106_fifo(UART_BASE, pnx8550_console_port) & IP3106_UART_FIFO_TXFIFO) >> 16) >= 16)
+			;
+		/* Send one char */
+		ip3106_fifo(UART_BASE, pnx8550_console_port) = c;
+	}
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/reset.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/reset.c
@@ -0,0 +1,49 @@
+/*.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Reset the PNX8550 board.
+ *
+ */
+#include <linux/slab.h>
+#include <asm/reboot.h>
+#include <glb.h>
+
+void pnx8550_machine_restart(char *command)
+{
+	char head[] = "************* Machine restart *************";
+	char foot[] = "*******************************************";
+
+	printk("\n\n");
+	printk("%s\n", head);
+	if (command != NULL)
+		printk("* %s\n", command);
+	printk("%s\n", foot);
+
+	PNX8550_RST_CTL = PNX8550_RST_DO_SW_RST;
+}
+
+void pnx8550_machine_halt(void)
+{
+	printk("*** Machine halt. (Not implemented) ***\n");
+}
+
+void pnx8550_machine_power_off(void)
+{
+	printk("*** Machine power off.  (Not implemented) ***\n");
+}
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/setup.c
@@ -0,0 +1,151 @@
+/*
+ *
+ * 2.6 port, Embedded Alley Solutions, Inc
+ *
+ *  Based on Per Hallsmark, per.hallsmark@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+
+#include <glb.h>
+#include <int.h>
+#include <pci.h>
+#include <uart.h>
+#include <nand.h>
+
+extern void prom_printf(char *fmt, ...);
+
+extern void __init board_setup(void);
+extern void pnx8550_machine_restart(char *);
+extern void pnx8550_machine_halt(void);
+extern void pnx8550_machine_power_off(void);
+extern struct resource ioport_resource;
+extern struct resource iomem_resource;
+extern void (*board_time_init)(void);
+extern void pnx8550_time_init(void);
+extern void (*board_timer_setup)(struct irqaction *irq);
+extern void pnx8550_timer_setup(struct irqaction *irq);
+extern void rs_kgdb_hook(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern char *prom_getcmdline(void);
+
+struct resource standard_io_resources[] = {
+	{"dma1", 0x00, 0x1f, IORESOURCE_BUSY},
+	{"timer", 0x40, 0x5f, IORESOURCE_BUSY},
+	{"dma page reg", 0x80, 0x8f, IORESOURCE_BUSY},
+	{"dma2", 0xc0, 0xdf, IORESOURCE_BUSY},
+};
+
+#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
+
+extern struct resource pci_io_resource;
+extern struct resource pci_mem_resource;
+
+/* Return the total size of DRAM-memory, (RANK0 + RANK1) */
+unsigned long get_system_mem_size(void)
+{
+	/* Read IP2031_RANK0_ADDR_LO */
+	unsigned long dram_r0_lo = inl(PCI_BASE | 0x65010);
+	/* Read IP2031_RANK1_ADDR_HI */
+	unsigned long dram_r1_hi = inl(PCI_BASE | 0x65018);
+
+	return dram_r1_hi - dram_r0_lo + 1;
+}
+
+int pnx8550_console_port = -1;
+
+static int __init plat_setup(void)
+{
+	int i;
+	char* argptr;
+
+	board_setup();  /* board specific setup */
+
+        _machine_restart = pnx8550_machine_restart;
+        _machine_halt = pnx8550_machine_halt;
+        _machine_power_off = pnx8550_machine_power_off;
+
+	board_time_init = pnx8550_time_init;
+	board_timer_setup = pnx8550_timer_setup;
+
+	/* Clear the Global 2 Register, PCI Inta Output Enable Registers
+	   Bit 1:Enable DAC Powerdown
+	  -> 0:DACs are enabled and are working normally
+	     1:DACs are powerdown
+	   Bit 0:Enable of PCI inta output
+	  -> 0 = Disable PCI inta output
+	     1 = Enable PCI inta output
+	*/
+	PNX8550_GLB2_ENAB_INTA_O = 0;
+
+	/* IO/MEM resources. */
+	set_io_port_base(KSEG1);
+	ioport_resource.start = 0;
+	ioport_resource.end = ~0;
+	iomem_resource.start = 0;
+	iomem_resource.end = ~0;
+
+	/* Request I/O space for devices on this board */
+	for (i = 0; i < STANDARD_IO_RESOURCES; i++)
+		request_resource(&ioport_resource, standard_io_resources + i);
+
+	/* Place the Mode Control bit for GPIO pin 16 in primary function */
+	/* Pin 16 is used by UART1, UA1_TX                                */
+	outl((PNX8550_GPIO_MODE_PRIMOP << PNX8550_GPIO_MC_16_BIT) |
+			(PNX8550_GPIO_MODE_PRIMOP << PNX8550_GPIO_MC_17_BIT),
+			PNX8550_GPIO_MC1);
+
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "console=ttyS")) != NULL) {
+		argptr += strlen("console=ttyS");
+		pnx8550_console_port = *argptr == '0' ? 0 : 1;
+
+		/* We must initialize the UART (console) before prom_printf */
+		/* Set LCR to 8-bit and BAUD to 38400 (no 5)                */
+		ip3106_lcr(UART_BASE, pnx8550_console_port) =
+			IP3106_UART_LCR_8BIT;
+		ip3106_baud(UART_BASE, pnx8550_console_port) = 5;
+	}
+
+#ifdef CONFIG_KGDB
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "kgdb=ttyS")) != NULL) {
+		int line;
+		argptr += strlen("kgdb=ttyS");
+		line = *argptr == '0' ? 0 : 1;
+		rs_kgdb_hook(line);
+		prom_printf("KGDB: Using ttyS%i for session, "
+				"please connect your debugger\n", line ? 1 : 0);
+	}
+#endif
+	return 0;
+}
+
+early_initcall(plat_setup);
Index: linux-2.6.10/arch/mips/philips/pnx8550/common/time.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/common/time.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2001, 2002, 2003 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Common time service routines for MIPS machines. See
+ * Documents/MIPS/README.txt.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/smp.h>
+#include <linux/kernel_stat.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+#include <asm/debug.h>
+
+#include <int.h>
+#include <cm.h>
+
+extern unsigned int mips_hpt_frequency;
+
+/*
+ * pnx8550_time_init() - it does the following things:
+ *
+ * 1) board_time_init() -
+ * 	a) (optional) set up RTC routines,
+ *      b) (optional) calibrate and set the mips_hpt_frequency
+ *	    (only needed if you intended to use fixed_rate_gettimeoffset
+ *	     or use cpu counter as timer interrupt source)
+ */
+
+void pnx8550_time_init(void)
+{
+	unsigned int             n;
+	unsigned int             m;
+	unsigned int             p;
+	unsigned int             pow2p;
+
+        /* PLL0 sets MIPS clock (PLL1 <=> TM1, PLL6 <=> TM2, PLL5 <=> mem) */
+        /* (but only if CLK_MIPS_CTL select value [bits 3:1] is 1:  FIXME) */
+
+        n = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_N_MASK) >> 16;
+        m = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_M_MASK) >> 8;
+        p = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_P_MASK) >> 2;
+	pow2p = (1 << p);
+
+	db_assert(m != 0 && pow2p != 0);
+
+        /*
+	 * Compute the frequency as in the PNX8550 User Manual 1.0, p.186
+	 * (a.k.a. 8-10).  Divide by HZ for a timer offset that results in
+	 * HZ timer interrupts per second.
+	 */
+	mips_hpt_frequency = 27UL * ((1000000UL * n)/(m * pow2p));
+}
+
+/*
+ * pnx8550_timer_setup() - it does the following things:
+ *
+ * 5) board_timer_setup() -
+ *	a) (optional) over-write any choices made above by time_init().
+ *	b) machine specific code should setup the timer irqaction.
+ *	c) enable the timer interrupt
+ */
+
+void __init pnx8550_timer_setup(struct irqaction *irq)
+{
+	int configPR;
+
+	setup_irq(PNX8550_INT_TIMER1, irq);
+
+	/* Start timer1 */
+	configPR = read_c0_config7();
+	configPR &= ~0x00000008;
+	write_c0_config7(configPR);
+
+	/* Timer 2 stop */
+	configPR = read_c0_config7();
+	configPR |= 0x00000010;
+	write_c0_config7(configPR);
+
+	write_c0_count2(0);
+	write_c0_compare2(0xffffffff);
+
+	/* Timer 3 stop */
+	configPR = read_c0_config7();
+	configPR |= 0x00000020;
+	write_c0_config7(configPR);
+}
Index: linux-2.6.10/arch/mips/philips/pnx8550/jbs/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/jbs/Makefile
@@ -0,0 +1,4 @@
+
+# Makefile for the Philips JBS Board.
+
+lib-y := init.o board_setup.o irqmap.o
Index: linux-2.6.10/arch/mips/philips/pnx8550/jbs/board_setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/jbs/board_setup.c
@@ -0,0 +1,65 @@
+/*
+ *  JBS Specific board startup routines.
+ *
+ *  Copyright 2005, Embedded Alley Solutions, Inc
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+
+#include <glb.h>
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+
+void __init board_setup(void)
+{
+	unsigned long config0, configpr;
+
+	config0 = read_c0_config();
+
+	/* clear all three cache coherency fields */
+	config0 &= ~(0x7 | (7<<25) | (7<<28));
+	config0 |= (CONF_CM_DEFAULT | (CONF_CM_DEFAULT<<25) |
+			(CONF_CM_DEFAULT<<28));
+	write_c0_config(config0);
+	BARRIER;
+
+	configpr = read_c0_config7();
+	configpr |= (1<<19); /* enable tlb */
+	write_c0_config7(configpr);
+	BARRIER;
+}
Index: linux-2.6.10/arch/mips/philips/pnx8550/jbs/init.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/jbs/init.c
@@ -0,0 +1,57 @@
+/*
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddedalley.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "Philips PNX8550/JBS";
+}
+
+void __init prom_init(void)
+{
+
+	unsigned long memsize;
+
+	mips_machgroup = MACH_GROUP_PHILIPS;
+	mips_machtype = MACH_PHILIPS_JBS;
+
+	//memsize = 0x02800000; /* Trimedia uses memory above */
+	memsize = 0x08000000; /* Trimedia uses memory above */
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
Index: linux-2.6.10/arch/mips/philips/pnx8550/jbs/irqmap.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/philips/pnx8550/jbs/irqmap.c
@@ -0,0 +1,36 @@
+/*
+ *  Philips JBS board irqmap.
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddealley.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <int.h>
+
+char irq_tab_jbs[][5] __initdata = {
+ [8] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+ [9] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+ [17] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+};
+
Index: linux-2.6.10/drivers/serial/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/serial/Kconfig
+++ linux-2.6.10/drivers/serial/Kconfig
@@ -573,6 +573,25 @@ config SERIAL_AU1X00_CONSOLE
 	  If you have an Alchemy AU1X00 processor (MIPS based) and you want
 	  to use a console on a serial port, say Y.  Otherwise, say N.
 
+config SERIAL_IP3106
+	bool "Enable IP3106 UART Support (Philips PNX 8xx0 SoCs)"
+	depends on MIPS && (SOC_PNX8550 || SOC_PNX8330)
+	select SERIAL_CORE
+	help
+	  If you have a Philips SoC with an IP 3106 UART in it, such as
+	  the PNX8550 or PNX8330 (MIPS based) and you want to use
+	  serial ports, say Y.  Otherwise, say N.
+
+config SERIAL_IP3106_CONSOLE
+	bool "Enable PNX8XX0 serial console"
+	depends on SERIAL_IP3106
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have a Philips SoC with an IP 3106 UART in it, such as
+	  the PNX8550 or PNX8330 (MIPS based) and you want to use
+	  a serial console, say Y.
+	  Otherwise, say N.
+
 config SERIAL_CORE
 	tristate
 
Index: linux-2.6.10/drivers/serial/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/serial/Makefile
+++ linux-2.6.10/drivers/serial/Makefile
@@ -37,6 +37,7 @@ obj-$(CONFIG_V850E_UART) += v850e_uart.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
 obj-$(CONFIG_SERIAL_LH7A40X) += serial_lh7a40x.o
 obj-$(CONFIG_SERIAL_AU1X00) += au1x00_uart.o
+obj-$(CONFIG_SERIAL_IP3106) += ip3106_uart.o
 obj-$(CONFIG_SERIAL_DZ) += dz.o
 obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
 obj-$(CONFIG_SERIAL_BAST_SIO) += bast_sio.o
Index: linux-2.6.10/drivers/serial/ip3106_uart.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/serial/ip3106_uart.c
@@ -0,0 +1,912 @@
+/*
+ * Initially based on linux-2.4.20_mvl31-pnx8xx0/drivers/char/serial_pnx8550.c
+ *
+ * Complete rewrite to drivers/serial/pnx8550_uart.c by
+ * Embedded Alley Solutions, source@embeddedalley.com as part of the
+ * PNX8550 2.6 port, and then drivers/serial/ip3106_uart.c to work
+ * with other Philips SoCs.
+ *
+ * Existing copyrights from files used to write this driver:
+ * Author: Per Hallsmark per.hallsmark@mvista.com
+ *
+ * and
+ *
+ * Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ * Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_IP3106_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <uart.h>
+
+/* We've been assigned a range on the "Low-density serial ports" major */
+#define SERIAL_IP3106_MAJOR	204
+#define MINOR_START		5
+
+#define NR_PORTS		2
+
+#define IP3106_ISR_PASS_LIMIT	256
+
+/*
+ * Convert from ignore_status_mask or read_status_mask to FIFO
+ * and interrupt status bits
+ */
+#define SM_TO_FIFO(x)	((x) >> 10)
+#define SM_TO_ISTAT(x)	((x) & 0x000001ff)
+#define FIFO_TO_SM(x)	((x) << 10)
+#define ISTAT_TO_SM(x)	((x) & 0x000001ff)
+
+/*
+ * This is the size of our serial port register set.
+ */
+#define UART_PORT_SIZE	0x1000
+
+/*
+ * This determines how often we check the modem status signals
+ * for any change.  They generally aren't connected to an IRQ
+ * so we have to poll them.  We also check immediately before
+ * filling the TX fifo incase CTS has been dropped.
+ */
+#define MCTRL_TIMEOUT	(250*HZ/1000)
+
+
+extern struct ip3106_port ip3106_ports[];
+
+static inline int serial_in(struct ip3106_port *sport, int offset)
+{
+	return (__raw_readl(sport->port.membase + offset));
+}
+
+static inline void serial_out(struct ip3106_port *sport, int offset, int value)
+{
+	__raw_writel(value, sport->port.membase + offset);
+}
+
+/*
+ * Handle any change of modem status signal since we were last called.
+ */
+static void ip3106_mctrl_check(struct ip3106_port *sport)
+{
+	unsigned int status, changed;
+
+	status = sport->port.ops->get_mctrl(&sport->port);
+	changed = status ^ sport->old_status;
+
+	if (changed == 0)
+		return;
+
+	sport->old_status = status;
+
+	if (changed & TIOCM_RI)
+		sport->port.icount.rng++;
+	if (changed & TIOCM_DSR)
+		sport->port.icount.dsr++;
+	if (changed & TIOCM_CAR)
+		uart_handle_dcd_change(&sport->port, status & TIOCM_CAR);
+	if (changed & TIOCM_CTS)
+		uart_handle_cts_change(&sport->port, status & TIOCM_CTS);
+
+	wake_up_interruptible(&sport->port.info->delta_msr_wait);
+}
+
+/*
+ * This is our per-port timeout handler, for checking the
+ * modem status signals.
+ */
+static void ip3106_timeout(unsigned long data)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)data;
+	unsigned long flags;
+
+	if (sport->port.info) {
+		spin_lock_irqsave(&sport->port.lock, flags);
+		ip3106_mctrl_check(sport);
+		spin_unlock_irqrestore(&sport->port.lock, flags);
+
+		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
+	}
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void ip3106_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	u32 ien;
+
+	/* Disable TX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien & ~IP3106_UART_INT_ALLTX);
+
+	/* Clear all pending TX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLTX);
+}
+
+/*
+ * interrupts may not be disabled on entry
+ */
+static void ip3106_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	u32 ien;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	/* Clear all pending TX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLTX);
+
+	/* Enable TX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien | IP3106_UART_INT_ALLTX);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+/*
+ * Interrupts enabled
+ */
+static void ip3106_stop_rx(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	u32 ien;
+
+	/* Disable RX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien & ~IP3106_UART_INT_ALLRX);
+
+	/* Clear all pending RX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX);
+}
+
+/*
+ * Set the modem control timer to fire immediately.
+ */
+static void ip3106_enable_ms(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	mod_timer(&sport->timer, jiffies);
+}
+
+static void
+ip3106_rx_chars(struct ip3106_port *sport, struct pt_regs *regs)
+{
+	struct tty_struct *tty = sport->port.info->tty;
+	unsigned int status, ch, flg, ignored = 0;
+
+	status = FIFO_TO_SM(serial_in(sport, IP3106_FIFO)) |
+		 ISTAT_TO_SM(serial_in(sport, IP3106_ISTAT));
+	while (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFIFO)) {
+		ch = serial_in(sport, IP3106_FIFO);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		sport->port.icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE |
+					IP3106_UART_FIFO_RXPAR))
+			goto handle_error;
+
+		if (uart_handle_sysrq_char(&sport->port, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		tty_insert_flip_char(tty, ch, flg);
+	ignore_char:
+		serial_out(sport, IP3106_LCR, serial_in(sport, IP3106_LCR) |
+				IP3106_UART_LCR_RX_NEXT);
+		status = FIFO_TO_SM(serial_in(sport, IP3106_FIFO)) |
+			 ISTAT_TO_SM(serial_in(sport, IP3106_ISTAT));
+	}
+ out:
+	tty_flip_buffer_push(tty);
+	return;
+
+ handle_error:
+	if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXPAR))
+		sport->port.icount.parity++;
+	else if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE))
+		sport->port.icount.frame++;
+	if (status & ISTAT_TO_SM(IP3106_UART_INT_RXOVRN))
+		sport->port.icount.overrun++;
+
+	if (status & sport->port.ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+
+//	status &= sport->port.read_status_mask;
+
+	if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXPAR))
+		flg = TTY_PARITY;
+	else if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE))
+		flg = TTY_FRAME;
+
+	if (status & ISTAT_TO_SM(IP3106_UART_INT_RXOVRN)) {
+		/*
+		 * overrun does *not* affect the character
+		 * we read from the FIFO
+		 */
+		tty_insert_flip_char(tty, ch, flg);
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef SUPPORT_SYSRQ
+	sport->port.sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void ip3106_tx_chars(struct ip3106_port *sport)
+{
+	struct circ_buf *xmit = &sport->port.info->xmit;
+
+	if (sport->port.x_char) {
+		serial_out(sport, IP3106_FIFO, sport->port.x_char);
+		sport->port.icount.tx++;
+		sport->port.x_char = 0;
+		return;
+	}
+
+	/*
+	 * Check the modem control lines before
+	 * transmitting anything.
+	 */
+	ip3106_mctrl_check(sport);
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {
+		ip3106_stop_tx(&sport->port, 0);
+		return;
+	}
+
+	/*
+	 * TX while bytes available
+	 */
+	while (((serial_in(sport, IP3106_FIFO) &
+					IP3106_UART_FIFO_TXFIFO) >> 16) < 16) {
+		serial_out(sport, IP3106_FIFO, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		sport->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&sport->port);
+
+	if (uart_circ_empty(xmit))
+		ip3106_stop_tx(&sport->port, 0);
+}
+
+static irqreturn_t ip3106_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ip3106_port *sport = dev_id;
+	unsigned int status;
+
+	spin_lock(&sport->port.lock);
+	/* Get the interrupts */
+	status  = serial_in(sport, IP3106_ISTAT) & serial_in(sport, IP3106_IEN);
+
+	/* RX Receiver Holding Register Overrun */
+	if (status & IP3106_UART_INT_RXOVRN) {
+		sport->port.icount.overrun++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RXOVRN);
+	}
+
+	/* RX Frame Error */
+	if (status & IP3106_UART_INT_FRERR) {
+		sport->port.icount.frame++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_FRERR);
+	}
+
+	/* Break signal received */
+	if (status & IP3106_UART_INT_BREAK) {
+		sport->port.icount.brk++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_BREAK);
+	}
+
+	/* RX Parity Error */
+	if (status & IP3106_UART_INT_PARITY) {
+		sport->port.icount.parity++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_PARITY);
+	}
+
+	/* Byte received */
+	if (status & IP3106_UART_INT_RX) {
+		ip3106_rx_chars(sport, regs);
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RX);
+	}
+
+	/* TX holding register empty - transmit a byte */
+	if (status & IP3106_UART_INT_TX) {
+		ip3106_tx_chars(sport);
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_TX);
+	}
+
+	/* TX shift register and holding register empty  */
+	if (status & IP3106_UART_INT_EMPTY) {
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_EMPTY);
+	}
+
+	/* Receiver time out */
+	if (status & IP3106_UART_INT_RCVTO) {
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RCVTO);
+	}
+	spin_unlock(&sport->port.lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static unsigned int ip3106_tx_empty(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return serial_in(sport, IP3106_FIFO) & IP3106_UART_FIFO_TXFIFO_STA ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int ip3106_get_mctrl(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned int mctrl = TIOCM_DSR;
+	unsigned int msr;
+
+	/* REVISIT */
+
+	msr = serial_in(sport, IP3106_MCR);
+
+	mctrl |= msr & IP3106_UART_MCR_CTS ? TIOCM_CTS : 0;
+	mctrl |= msr & IP3106_UART_MCR_DCD ? TIOCM_CAR : 0;
+
+	return mctrl;
+}
+
+static void ip3106_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+#if	0	/* FIXME */
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned int msr;
+#endif
+}
+
+/*
+ * Interrupts always disabled.
+ */
+static void ip3106_break_ctl(struct uart_port *port, int break_state)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	unsigned int lcr;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+	lcr = serial_in(sport, IP3106_LCR);
+	if (break_state == -1)
+		lcr |= IP3106_UART_LCR_TXBREAK;
+	else
+		lcr &= ~IP3106_UART_LCR_TXBREAK;
+	serial_out(sport, IP3106_LCR, lcr);
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static int ip3106_startup(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	int retval;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(sport->port.irq, ip3106_int, 0,
+			     "ip3106-uart", sport);
+	if (retval)
+		return retval;
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX |
+			     IP3106_UART_INT_ALLTX);
+
+	serial_out(sport, IP3106_IEN, serial_in(sport, IP3106_IEN) |
+			    IP3106_UART_INT_ALLRX |
+			    IP3106_UART_INT_ALLTX);
+
+	/*
+	 * Enable modem status interrupts
+	 */
+	spin_lock_irq(&sport->port.lock);
+	ip3106_enable_ms(&sport->port);
+	spin_unlock_irq(&sport->port.lock);
+
+	return 0;
+}
+
+static void ip3106_shutdown(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	/*
+	 * Stop our timer.
+	 */
+	del_timer_sync(&sport->timer);
+
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+	serial_out(sport, IP3106_IEN, 0);
+
+	/*
+	 * Reset the Tx and Rx FIFOS
+	 */
+	serial_out(sport, IP3106_LCR, serial_in(sport, IP3106_LCR) |
+			    IP3106_UART_LCR_TX_RST |
+			    IP3106_UART_LCR_RX_RST);
+
+	/*
+	 * Clear all interrupts
+	 */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX |
+			     IP3106_UART_INT_ALLTX);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(sport->port.irq, sport);
+}
+
+static void
+ip3106_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	unsigned int lcr_fcr, old_ien, baud, quot;
+	unsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;
+
+	/*
+	 * We only support CS7 and CS8.
+	 */
+	while ((termios->c_cflag & CSIZE) != CS7 &&
+	       (termios->c_cflag & CSIZE) != CS8) {
+		termios->c_cflag &= ~CSIZE;
+		termios->c_cflag |= old_csize;
+		old_csize = CS8;
+	}
+
+	if ((termios->c_cflag & CSIZE) == CS8)
+		lcr_fcr = IP3106_UART_LCR_8BIT;
+	else
+		lcr_fcr = 0;
+
+	if (termios->c_cflag & CSTOPB)
+		lcr_fcr |= IP3106_UART_LCR_2STOPB;
+	if (termios->c_cflag & PARENB) {
+		lcr_fcr |= IP3106_UART_LCR_PAREN;
+		if (!(termios->c_cflag & PARODD))
+			lcr_fcr |= IP3106_UART_LCR_PAREVN;
+	}
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+#if	0	/* REVISIT */
+	sport->port.read_status_mask &= UTSR0_TO_SM(UTSR0_TFS);
+	sport->port.read_status_mask |= UTSR1_TO_SM(UTSR1_ROR);
+	if (termios->c_iflag & INPCK)
+		sport->port.read_status_mask |=
+				UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		sport->port.read_status_mask |=
+				UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+
+	/*
+	 * Characters to ignore
+	 */
+	sport->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		sport->port.ignore_status_mask |=
+				UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (termios->c_iflag & IGNBRK) {
+		sport->port.ignore_status_mask |=
+				UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			sport->port.ignore_status_mask |=
+				UTSR1_TO_SM(UTSR1_ROR);
+	}
+#endif
+
+	del_timer_sync(&sport->timer);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * disable interrupts and drain transmitter
+	 */
+	old_ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, old_ien & ~(IP3106_UART_INT_ALLTX |
+					IP3106_UART_INT_ALLRX));
+
+	while (serial_in(sport, IP3106_FIFO) & IP3106_UART_FIFO_TXFIFO_STA)
+		barrier();
+
+	/* then, disable everything */
+	serial_out(sport, IP3106_IEN, 0);
+
+	/* Reset the Rx and Tx FIFOs too */
+	lcr_fcr |= IP3106_UART_LCR_TX_RST;
+	lcr_fcr |= IP3106_UART_LCR_RX_RST;
+
+	/* set the parity, stop bits and data size */
+	serial_out(sport, IP3106_LCR, lcr_fcr);
+
+	/* set the baud rate */
+	quot -= 1;
+	serial_out(sport, IP3106_BAUD, quot);
+
+	serial_out(sport, IP3106_ICLR, -1);
+
+	serial_out(sport, IP3106_IEN, old_ien);
+
+	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
+		ip3106_enable_ms(&sport->port);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static const char *ip3106_type(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return sport->port.type == PORT_IP3106 ? "IP3106" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void ip3106_release_port(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	release_mem_region(sport->port.mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int ip3106_request_port(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return request_mem_region(sport->port.mapbase, UART_PORT_SIZE,
+			"ip3106-uart") != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void ip3106_config_port(struct uart_port *port, int flags)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	if (flags & UART_CONFIG_TYPE &&
+	    ip3106_request_port(&sport->port) == 0)
+		sport->port.type = PORT_IP3106;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ * The only change we allow are to the flags and type, and
+ * even then only between PORT_IP3106 and PORT_UNKNOWN
+ */
+static int
+ip3106_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	int ret = 0;
+
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_IP3106)
+		ret = -EINVAL;
+	if (sport->port.irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != SERIAL_IO_MEM)
+		ret = -EINVAL;
+	if (sport->port.uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)sport->port.mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (sport->port.iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+struct uart_ops ip3106_pops = {
+	.tx_empty	= ip3106_tx_empty,
+	.set_mctrl	= ip3106_set_mctrl,
+	.get_mctrl	= ip3106_get_mctrl,
+	.stop_tx	= ip3106_stop_tx,
+	.start_tx	= ip3106_start_tx,
+	.stop_rx	= ip3106_stop_rx,
+	.enable_ms	= ip3106_enable_ms,
+	.break_ctl	= ip3106_break_ctl,
+	.startup	= ip3106_startup,
+	.shutdown	= ip3106_shutdown,
+	.set_termios	= ip3106_set_termios,
+	.type		= ip3106_type,
+	.release_port	= ip3106_release_port,
+	.request_port	= ip3106_request_port,
+	.config_port	= ip3106_config_port,
+	.verify_port	= ip3106_verify_port,
+};
+
+
+/*
+ * Setup the IP3106 serial ports.
+ *
+ * Note also that we support "console=ttySx" where "x" is either 0 or 1.
+ */
+static void __init ip3106_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		init_timer(&ip3106_ports[i].timer);
+		ip3106_ports[i].timer.function = ip3106_timeout;
+		ip3106_ports[i].timer.data     = (unsigned long)&ip3106_ports[i];
+	}
+}
+
+#ifdef CONFIG_SERIAL_IP3106_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void
+ip3106_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct ip3106_port *sport = &ip3106_ports[co->index];
+	unsigned int old_ien, status, i;
+
+	/*
+	 *	First, save IEN and then disable interrupts
+	 */
+	old_ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, old_ien & ~(IP3106_UART_INT_ALLTX |
+					IP3106_UART_INT_ALLRX));
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			/* Wait for UART_TX register to empty */
+			status = serial_in(sport, IP3106_FIFO);
+		} while (status & IP3106_UART_FIFO_TXFIFO);
+		serial_out(sport, IP3106_FIFO, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = serial_in(sport, IP3106_FIFO);
+			} while (status & IP3106_UART_FIFO_TXFIFO);
+			serial_out(sport, IP3106_FIFO, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore IEN
+	 */
+	do {
+		/* Wait for UART_TX register to empty */
+		status = serial_in(sport, IP3106_FIFO);
+	} while (status & IP3106_UART_FIFO_TXFIFO);
+
+	/* Clear TX and EMPTY interrupt */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_TX |
+			     IP3106_UART_INT_EMPTY);
+
+	serial_out(sport, IP3106_IEN, old_ien);
+}
+
+static int __init
+ip3106_console_setup(struct console *co, char *options)
+{
+	struct ip3106_port *sport;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index == -1 || co->index >= NR_PORTS)
+		co->index = 0;
+	sport = &ip3106_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver ip3106_reg;
+static struct console ip3106_console = {
+	.name		= "ttyS",
+	.write		= ip3106_console_write,
+	.device		= uart_console_device,
+	.setup		= ip3106_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ip3106_reg,
+};
+
+static int __init ip3106_rs_console_init(void)
+{
+	ip3106_init_ports();
+	register_console(&ip3106_console);
+	return 0;
+}
+console_initcall(ip3106_rs_console_init);
+
+#define IP3106_CONSOLE	&ip3106_console
+#else
+#define IP3106_CONSOLE	NULL
+#endif
+
+static struct uart_driver ip3106_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "ttyS",
+	.dev_name		= "ttyS",
+	.devfs_name		= "tts/",
+	.major			= SERIAL_IP3106_MAJOR,
+	.minor			= MINOR_START,
+	.nr			= NR_PORTS,
+	.cons			= IP3106_CONSOLE,
+};
+
+static int ip3106_serial_suspend(struct device *_dev, u32 state, u32 level)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	if (sport && level == SUSPEND_DISABLE)
+		uart_suspend_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static int ip3106_serial_resume(struct device *_dev, u32 level)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	if (sport && level == RESUME_ENABLE)
+		uart_resume_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static int ip3106_serial_probe(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+	struct resource *res = dev->resource;
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++, res++) {
+		if (!(res->flags & IORESOURCE_MEM))
+			continue;
+
+		for (i = 0; i < NR_PORTS; i++) {
+			if (ip3106_ports[i].port.mapbase != res->start)
+				continue;
+
+			ip3106_ports[i].port.dev = _dev;
+			uart_add_one_port(&ip3106_reg, &ip3106_ports[i].port);
+			dev_set_drvdata(_dev, &ip3106_ports[i]);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int ip3106_serial_remove(struct device *_dev)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	dev_set_drvdata(_dev, NULL);
+
+	if (sport)
+		uart_remove_one_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static struct device_driver ip3106_serial_driver = {
+	.name		= "ip3106-uart",
+	.bus		= &platform_bus_type,
+	.probe		= ip3106_serial_probe,
+	.remove		= ip3106_serial_remove,
+	.suspend	= ip3106_serial_suspend,
+	.resume		= ip3106_serial_resume,
+};
+
+static int __init ip3106_serial_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: IP3106 driver $Revision: 1.2 $\n");
+
+	ip3106_init_ports();
+
+	ret = uart_register_driver(&ip3106_reg);
+	if (ret == 0) {
+		ret = driver_register(&ip3106_serial_driver);
+		if (ret)
+			uart_unregister_driver(&ip3106_reg);
+	}
+	return ret;
+}
+
+static void __exit ip3106_serial_exit(void)
+{
+	driver_unregister(&ip3106_serial_driver);
+	uart_unregister_driver(&ip3106_reg);
+}
+
+module_init(ip3106_serial_init);
+module_exit(ip3106_serial_exit);
+
+MODULE_AUTHOR("Embedded Alley Solutions, Inc.");
+MODULE_DESCRIPTION("IP3106 generic serial port driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_IP3106_MAJOR);
Index: linux-2.6.10/drivers/usb/host/ohci-hcd.c
===================================================================
--- linux-2.6.10.orig/drivers/usb/host/ohci-hcd.c
+++ linux-2.6.10/drivers/usb/host/ohci-hcd.c
@@ -905,6 +905,10 @@ MODULE_LICENSE ("GPL");
 #include "ohci-au1xxx.c"
 #endif
 
+#ifdef CONFIG_PNX8550
+#include "ohci-pnx8550.c"
+#endif
+
 #ifdef CONFIG_USB_OHCI_HCD_PPC_SOC
 #include "ohci-ppc-soc.c"
 #endif
Index: linux-2.6.10/drivers/usb/host/ohci-pnx8550.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/usb/host/ohci-pnx8550.c
@@ -0,0 +1,352 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2005 Embedded Alley Solutions, Inc.
+ *
+ * Bus Glue for PNX8550
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Russell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ *
+ * Modified for pxa27x from ohci-lh7a404.c
+ *  by Nick Bane <nick@cecomputing.co.uk> 26-8-2004
+ *
+ * Modified for PNX8550 from ohci-pxa27x.c
+ *  by Embedded Alley Solutions, Inc.
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/device.h>
+#include <asm/mach-pnx8550/usb.h>
+#include <asm/mach-pnx8550/int.h>
+#include <asm/mach-pnx8550/pci.h>
+
+#ifndef CONFIG_PNX8550
+#error "This file is PNX8550 bus glue.  CONFIG_PNX8550 must be defined."
+#endif
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void pnx8550_start_hc(struct platform_device *dev)
+{
+	/*
+	 * Set register CLK48CTL to enable and 48MHz
+	 */
+	outl(0x00000003, PCI_BASE | 0x0004770c);
+
+	/*
+	 * Set register CLK12CTL to enable and 48MHz
+	 */
+	outl(0x00000003, PCI_BASE | 0x00047710);
+
+	udelay(100);
+}
+
+static void pnx8550_stop_hc(struct platform_device *dev)
+{
+	udelay(10);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_pnx8550_remove - shutdown processing for pnx8550-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_pnx8550_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_pnx8550_remove (struct usb_hcd *hcd, struct platform_device *dev)
+{
+	pr_debug ("remove: %s, state %x", hcd->self.bus_name, hcd->state);
+
+	if (in_interrupt ())
+		BUG ();
+
+	hcd->state = USB_STATE_QUIESCING;
+
+	pr_debug ("%s: roothub graceful disconnect", hcd->self.bus_name);
+	usb_disconnect (&hcd->self.root_hub);
+
+	hcd->driver->stop (hcd);
+	hcd->state = USB_STATE_HALT;
+
+	free_irq (hcd->irq, hcd);
+	hcd_buffer_destroy (hcd);
+
+	usb_deregister_bus (&hcd->self);
+
+	pnx8550_stop_hc(dev);
+
+	iounmap(hcd->regs);
+	release_mem_region(pci_resource_start (dev, 0),
+				pci_resource_len (dev, 0));
+}
+
+static irqreturn_t usb_hcd_pnx8550_hcim_irq (int irq, void *__hcd,
+					     struct pt_regs * r)
+{
+	struct usb_hcd *hcd = __hcd;
+
+	return usb_hcd_irq(irq, hcd, r);
+}
+
+/**
+ * usb_hcd_pnx8550_probe - initialize pnx8550-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+
+int usb_hcd_pnx8550_probe (const struct hc_driver *driver,
+			  struct usb_hcd **hcd_out,
+			  struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd = 0;
+
+	unsigned int *addr = NULL;
+
+	if (!request_mem_region(dev->resource[0].start,
+				dev->resource[0].end
+				- dev->resource[0].start + 1, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		return -EBUSY;
+	}
+
+	pnx8550_start_hc(dev);
+
+	addr = ioremap(dev->resource[0].start,
+		       dev->resource[0].end
+		       - dev->resource[0].start + 1);
+	if (!addr) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	hcd = ohci_hcd_alloc();
+	if (hcd == NULL){
+		pr_debug ("hcd_alloc failed");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	if(dev->resource[1].flags != IORESOURCE_IRQ){
+		pr_debug ("resource[1] is not IORESOURCE_IRQ");
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	hcd->driver = (struct hc_driver *) driver;
+	hcd->description = driver->description;
+	hcd->irq = dev->resource[1].start;
+	hcd->regs = addr;
+	hcd->self.controller = &dev->dev;
+
+	retval = hcd_buffer_create (hcd);
+	if (retval != 0) {
+		pr_debug ("pool alloc fail");
+		goto err1;
+	}
+
+	retval = request_irq (hcd->irq, usb_hcd_pnx8550_hcim_irq, SA_INTERRUPT,
+			      hcd->description, hcd);
+	if (retval != 0) {
+		pr_debug("request_irq failed");
+		retval = -EBUSY;
+		goto err2;
+	}
+
+	pr_debug ("%s (PNX8550 OHCI) at 0x%p, irq %d",
+	     hcd->description, hcd->regs, hcd->irq);
+
+	usb_bus_init (&hcd->self);
+	hcd->self.op = &usb_hcd_operations;
+	hcd->self.hcpriv = (void *) hcd;
+	hcd->self.bus_name = "pnx8550";
+	hcd->product_desc = "PNX8550 OHCI";
+
+	INIT_LIST_HEAD (&hcd->dev_list);
+
+	usb_register_bus (&hcd->self);
+
+	if ((retval = driver->start (hcd)) < 0)
+	{
+		usb_hcd_pnx8550_remove(hcd, dev);
+		printk("bad driver->start\n");
+		return retval;
+	}
+
+	*hcd_out = hcd;
+	return 0;
+
+ err2:
+	hcd_buffer_destroy (hcd);
+ err1:
+	kfree(hcd);
+	pnx8550_stop_hc(dev);
+	release_mem_region(dev->resource[0].start,
+				dev->resource[0].end
+			   - dev->resource[0].start + 1);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_pnx8550_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	ohci_dbg (ohci, "ohci_pnx8550_start, ohci:%p", ohci);
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_pnx8550_hc_driver = {
+	.description =		hcd_name,
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_pnx8550_start,
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef  CONFIG_USB_SUSPEND
+	.hub_suspend =		ohci_hub_suspend,
+	.hub_resume =		ohci_hub_resume,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_pnx8550_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	pr_debug ("In ohci_hcd_pnx8550_drv_probe");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_pnx8550_probe(&ohci_pnx8550_hc_driver, &hcd, pdev);
+
+	if (ret == 0)
+		dev_set_drvdata(dev, hcd);
+
+	return ret;
+}
+
+static int ohci_hcd_pnx8550_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	usb_hcd_pnx8550_remove(hcd, pdev);
+	return 0;
+}
+
+static int ohci_hcd_pnx8550_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+//	struct platform_device *pdev = to_platform_device(dev);
+//	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s: not implemented yet\n", __FUNCTION__);
+
+	return 0;
+}
+
+static int ohci_hcd_pnx8550_drv_resume(struct device *dev, u32 state)
+{
+//	struct platform_device *pdev = to_platform_device(dev);
+//	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s: not implemented yet\n", __FUNCTION__);
+
+	return 0;
+}
+
+
+static struct device_driver ohci_hcd_pnx8550_driver = {
+	.name		= "pnx8550-ohci",
+	.bus		= &platform_bus_type,
+	.probe		= ohci_hcd_pnx8550_drv_probe,
+	.remove		= ohci_hcd_pnx8550_drv_remove,
+	.suspend	= ohci_hcd_pnx8550_drv_suspend,
+	.resume		= ohci_hcd_pnx8550_drv_resume,
+};
+
+static int __init ohci_hcd_pnx8550_init (void)
+{
+	pr_debug (DRIVER_INFO " (pnx8550)");
+	pr_debug ("block sizes: ed %d td %d\n",
+		sizeof (struct ed), sizeof (struct td));
+
+	return driver_register(&ohci_hcd_pnx8550_driver);
+}
+
+static void __exit ohci_hcd_pnx8550_cleanup (void)
+{
+	driver_unregister(&ohci_hcd_pnx8550_driver);
+}
+
+module_init (ohci_hcd_pnx8550_init);
+module_exit (ohci_hcd_pnx8550_cleanup);
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -136,6 +136,7 @@
 #define MACH_GROUP_PHILIPS     14
 #define  MACH_PHILIPS_NINO	0	/* Nino */
 #define  MACH_PHILIPS_VELO	1	/* Velo */
+#define  MACH_PHILIPS_JBS	2	/* JBS */
 
 /*
  * Valid machtype for group Globespan
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/cm.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/cm.h
@@ -0,0 +1,43 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   Clock module specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_CM_H
+#define __PNX8550_CM_H
+
+#define PNX8550_CM_BASE	0xBBE47000
+
+#define PNX8550_CM_PLL0_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x000)
+#define PNX8550_CM_PLL1_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x004)
+#define PNX8550_CM_PLL2_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x008)
+#define PNX8550_CM_PLL3_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x00C)
+
+// Table not complete.....
+
+#define PNX8550_CM_PLL_BLOCKED_MASK     0x80000000
+#define PNX8550_CM_PLL_LOCK_MASK        0x40000000
+#define PNX8550_CM_PLL_CURRENT_ADJ_MASK 0x3c000000
+#define PNX8550_CM_PLL_N_MASK           0x01ff0000
+#define PNX8550_CM_PLL_M_MASK           0x00003f00
+#define PNX8550_CM_PLL_P_MASK           0x0000000c
+#define PNX8550_CM_PLL_PD_MASK          0x00000002
+
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/glb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/glb.h
@@ -0,0 +1,86 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   PNX8550 global definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_GLB_H
+#define __PNX8550_GLB_H
+
+#define PNX8550_GLB1_BASE	0xBBE63000
+#define PNX8550_GLB2_BASE	0xBBE4d000
+#define PNX8550_RESET_BASE      0xBBE60000
+
+/* PCI Inta Output Enable Registers */
+#define PNX8550_GLB2_ENAB_INTA_O	*(volatile unsigned long *)(PNX8550_GLB2_BASE + 0x050)
+
+/* Bit 1:Enable DAC Powerdown
+     0:DACs are enabled and are working normally
+     1:DACs are powerdown
+*/
+#define PNX8550_GLB_DAC_PD      0x2
+/*   Bit 0:Enable of PCI inta output
+     0 = Disable PCI inta output
+     1 = Enable PCI inta output
+*/
+#define PNX8550_GLB_ENABLE_INTA_O 0x1
+
+/* PCI Direct Mappings */
+#define PNX8550_PCIMEM	        0x12000000
+#define PNX8550_PCIMEM_SIZE	0x08000000
+#define PNX8550_PCIIO	        0x1c000000
+#define PNX8550_PCIIO_SIZE	0x02000000	/* 32M */
+
+#define PNX8550_PORT_BASE	KSEG1
+
+// GPIO def
+#define PNX8550_GPIO_BASE	0x1Be00000
+
+#define PNX8550_GPIO_DIRQ0	 (PNX8550_GPIO_BASE + 0x104500)
+#define PNX8550_GPIO_MC1         (PNX8550_GPIO_BASE + 0x104004)
+#define PNX8550_GPIO_MC_31_BIT   30
+#define PNX8550_GPIO_MC_30_BIT   28
+#define PNX8550_GPIO_MC_29_BIT   26
+#define PNX8550_GPIO_MC_28_BIT   24
+#define PNX8550_GPIO_MC_27_BIT   22
+#define PNX8550_GPIO_MC_26_BIT   20
+#define PNX8550_GPIO_MC_25_BIT   18
+#define PNX8550_GPIO_MC_24_BIT   16
+#define PNX8550_GPIO_MC_23_BIT   14
+#define PNX8550_GPIO_MC_22_BIT   12
+#define PNX8550_GPIO_MC_21_BIT   10
+#define PNX8550_GPIO_MC_20_BIT   8
+#define PNX8550_GPIO_MC_19_BIT   6
+#define PNX8550_GPIO_MC_18_BIT   4
+#define PNX8550_GPIO_MC_17_BIT   2
+#define PNX8550_GPIO_MC_16_BIT   0
+
+#define PNX8550_GPIO_MODE_PRIMOP    0x1
+#define PNX8550_GPIO_MODE_NO_OPENDR 0x2
+#define PNX8550_GPIO_MODE_OPENDR    0x3
+
+// RESET module
+#define PNX8550_RST_CTL             *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x0)
+#define PNX8550_RST_CAUSE           *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x4)
+#define PNX8550_RST_EN_WATCHDOG     *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x8)
+
+#define PNX8550_RST_REL_MIPS_RST_N     0x8
+#define PNX8550_RST_DO_SW_RST          0x4
+#define PNX8550_RST_REL_SYS_RST_OUT    0x2
+#define PNX8550_RST_ASSERT_SYS_RST_OUT 0x1
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/int.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/int.h
@@ -0,0 +1,140 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   Interrupt specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_INT_H
+#define __PNX8550_INT_H
+
+#define PNX8550_GIC_BASE	0xBBE3E000
+
+#define PNX8550_GIC_PRIMASK_0	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x000)
+#define PNX8550_GIC_PRIMASK_1	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x004)
+#define PNX8550_GIC_VECTOR_0	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x100)
+#define PNX8550_GIC_VECTOR_1	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x104)
+#define PNX8550_GIC_PEND_1_31	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x200)
+#define PNX8550_GIC_PEND_32_63	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x204)
+#define PNX8550_GIC_PEND_64_70	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x208)
+#define PNX8550_GIC_FEATURES	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x300)
+#define PNX8550_GIC_REQ(x)	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x400 + (x)*4)
+#define PNX8550_GIC_MOD_ID	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0xFFC)
+
+// cp0 is two software + six hw exceptions
+#define PNX8550_INT_CP0_TOTINT	8
+#define PNX8550_INT_CP0_MIN	0
+#define PNX8550_INT_CP0_MAX	(PNX8550_INT_CP0_MIN + PNX8550_INT_CP0_TOTINT - 1)
+
+#define MIPS_CPU_GIC_IRQ        2
+#define MIPS_CPU_TIMER_IRQ      7
+
+// GIC are 71 exceptions connected to cp0's first hardware exception
+#define PNX8550_INT_GIC_TOTINT	71
+#define PNX8550_INT_GIC_MIN	(PNX8550_INT_CP0_MAX+1)
+#define PNX8550_INT_GIC_MAX	(PNX8550_INT_GIC_MIN + PNX8550_INT_GIC_TOTINT - 1)
+
+#define PNX8550_INT_UNDEF              (PNX8550_INT_GIC_MIN+0)
+#define PNX8550_INT_IPC_TARGET0_MIPS   (PNX8550_INT_GIC_MIN+1)
+#define PNX8550_INT_IPC_TARGET1_TM32_1 (PNX8550_INT_GIC_MIN+2)
+#define PNX8550_INT_IPC_TARGET1_TM32_2 (PNX8550_INT_GIC_MIN+3)
+#define PNX8550_INT_RESERVED_4         (PNX8550_INT_GIC_MIN+4)
+#define PNX8550_INT_USB                (PNX8550_INT_GIC_MIN+5)
+#define PNX8550_INT_GPIO_EQ1           (PNX8550_INT_GIC_MIN+6)
+#define PNX8550_INT_GPIO_EQ2           (PNX8550_INT_GIC_MIN+7)
+#define PNX8550_INT_GPIO_EQ3           (PNX8550_INT_GIC_MIN+8)
+#define PNX8550_INT_GPIO_EQ4           (PNX8550_INT_GIC_MIN+9)
+
+#define PNX8550_INT_GPIO_EQ5           (PNX8550_INT_GIC_MIN+10)
+#define PNX8550_INT_GPIO_EQ6           (PNX8550_INT_GIC_MIN+11)
+#define PNX8550_INT_RESERVED_12        (PNX8550_INT_GIC_MIN+12)
+#define PNX8550_INT_QVCP1              (PNX8550_INT_GIC_MIN+13)
+#define PNX8550_INT_QVCP2              (PNX8550_INT_GIC_MIN+14)
+#define PNX8550_INT_I2C1               (PNX8550_INT_GIC_MIN+15)
+#define PNX8550_INT_I2C2               (PNX8550_INT_GIC_MIN+16)
+#define PNX8550_INT_ISO_UART1          (PNX8550_INT_GIC_MIN+17)
+#define PNX8550_INT_ISO_UART2          (PNX8550_INT_GIC_MIN+18)
+#define PNX8550_INT_UART1              (PNX8550_INT_GIC_MIN+19)
+
+#define PNX8550_INT_UART2              (PNX8550_INT_GIC_MIN+20)
+#define PNX8550_INT_QNTR               (PNX8550_INT_GIC_MIN+21)
+#define PNX8550_INT_RESERVED22         (PNX8550_INT_GIC_MIN+22)
+#define PNX8550_INT_T_DSC              (PNX8550_INT_GIC_MIN+23)
+#define PNX8550_INT_M_DSC              (PNX8550_INT_GIC_MIN+24)
+#define PNX8550_INT_RESERVED25         (PNX8550_INT_GIC_MIN+25)
+#define PNX8550_INT_2D_DRAW_ENG        (PNX8550_INT_GIC_MIN+26)
+#define PNX8550_INT_MEM_BASED_SCALAR1  (PNX8550_INT_GIC_MIN+27)
+#define PNX8550_INT_VIDEO_MPEG         (PNX8550_INT_GIC_MIN+28)
+#define PNX8550_INT_VIDEO_INPUT_P1     (PNX8550_INT_GIC_MIN+29)
+
+#define PNX8550_INT_VIDEO_INPUT_P2     (PNX8550_INT_GIC_MIN+30)
+#define PNX8550_INT_SPDI1              (PNX8550_INT_GIC_MIN+31)
+#define PNX8550_INT_SPDO               (PNX8550_INT_GIC_MIN+32)
+#define PNX8550_INT_AUDIO_INPUT1       (PNX8550_INT_GIC_MIN+33)
+#define PNX8550_INT_AUDIO_OUTPUT1      (PNX8550_INT_GIC_MIN+34)
+#define PNX8550_INT_AUDIO_INPUT2       (PNX8550_INT_GIC_MIN+35)
+#define PNX8550_INT_AUDIO_OUTPUT2      (PNX8550_INT_GIC_MIN+36)
+#define PNX8550_INT_MEMBASED_SCALAR2   (PNX8550_INT_GIC_MIN+37)
+#define PNX8550_INT_VPK                (PNX8550_INT_GIC_MIN+38)
+#define PNX8550_INT_MPEG1_MIPS         (PNX8550_INT_GIC_MIN+39)
+
+#define PNX8550_INT_MPEG1_TM           (PNX8550_INT_GIC_MIN+40)
+#define PNX8550_INT_MPEG2_MIPS         (PNX8550_INT_GIC_MIN+41)
+#define PNX8550_INT_MPEG2_TM           (PNX8550_INT_GIC_MIN+42)
+#define PNX8550_INT_TS_DMA             (PNX8550_INT_GIC_MIN+43)
+#define PNX8550_INT_EDMA               (PNX8550_INT_GIC_MIN+44)
+#define PNX8550_INT_TM_DEBUG1          (PNX8550_INT_GIC_MIN+45)
+#define PNX8550_INT_TM_DEBUG2          (PNX8550_INT_GIC_MIN+46)
+#define PNX8550_INT_PCI_INTA           (PNX8550_INT_GIC_MIN+47)
+#define PNX8550_INT_CLOCK_MODULE       (PNX8550_INT_GIC_MIN+48)
+#define PNX8550_INT_PCI_XIO_INTA_PCI   (PNX8550_INT_GIC_MIN+49)
+
+#define PNX8550_INT_PCI_XIO_INTB_DMA   (PNX8550_INT_GIC_MIN+50)
+#define PNX8550_INT_PCI_XIO_INTC_GPPM  (PNX8550_INT_GIC_MIN+51)
+#define PNX8550_INT_PCI_XIO_INTD_GPXIO (PNX8550_INT_GIC_MIN+52)
+#define PNX8550_INT_DVD_CSS            (PNX8550_INT_GIC_MIN+53)
+#define PNX8550_INT_VLD                (PNX8550_INT_GIC_MIN+54)
+#define PNX8550_INT_GPIO_TSU_7_0       (PNX8550_INT_GIC_MIN+55)
+#define PNX8550_INT_GPIO_TSU_15_8      (PNX8550_INT_GIC_MIN+56)
+#define PNX8550_INT_GPIO_CTU_IR        (PNX8550_INT_GIC_MIN+57)
+#define PNX8550_INT_GPIO0              (PNX8550_INT_GIC_MIN+58)
+#define PNX8550_INT_GPIO1              (PNX8550_INT_GIC_MIN+59)
+
+#define PNX8550_INT_GPIO2              (PNX8550_INT_GIC_MIN+60)
+#define PNX8550_INT_GPIO3              (PNX8550_INT_GIC_MIN+61)
+#define PNX8550_INT_GPIO4              (PNX8550_INT_GIC_MIN+62)
+#define PNX8550_INT_GPIO5              (PNX8550_INT_GIC_MIN+63)
+#define PNX8550_INT_GPIO6              (PNX8550_INT_GIC_MIN+64)
+#define PNX8550_INT_GPIO7              (PNX8550_INT_GIC_MIN+65)
+#define PNX8550_INT_PMAN_SECURITY      (PNX8550_INT_GIC_MIN+66)
+#define PNX8550_INT_I2C3               (PNX8550_INT_GIC_MIN+67)
+#define PNX8550_INT_RESERVED_68        (PNX8550_INT_GIC_MIN+68)
+#define PNX8550_INT_SPDI2              (PNX8550_INT_GIC_MIN+69)
+
+#define PNX8550_INT_I2C4               (PNX8550_INT_GIC_MIN+70)
+
+// Timer are 3 exceptions connected to cp0's 7th hardware exception
+#define PNX8550_INT_TIMER_TOTINT       3
+#define PNX8550_INT_TIMER_MIN	       (PNX8550_INT_GIC_MAX+1)
+#define PNX8550_INT_TIMER_MAX          (PNX8550_INT_TIMER_MIN + PNX8550_INT_TIMER_TOTINT - 1)
+
+#define PNX8550_INT_TIMER1             (PNX8550_INT_TIMER_MIN+0)
+#define PNX8550_INT_TIMER2             (PNX8550_INT_TIMER_MIN+1)
+#define PNX8550_INT_TIMER3             (PNX8550_INT_TIMER_MIN+2)
+#define PNX8550_INT_WATCHDOG           PNX8550_INT_TIMER3
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/kernel-entry-init.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/kernel-entry-init.h
@@ -0,0 +1,262 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ */
+#ifndef __ASM_MACH_KERNEL_ENTRY_INIT_H
+#define __ASM_MACH_KERNEL_ENTRY_INIT_H
+
+#include <asm/cacheops.h>
+#include <asm/addrspace.h>
+
+#define CO_CONFIGPR_VALID  0x3F1F41FF    /* valid bits to write to ConfigPR */
+#define HAZARD_CP0 nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;
+#define CACHE_OPC      0xBC000000  /* MIPS cache instruction opcode */
+#define ICACHE_LINE_SIZE        32      /* Instruction cache line size bytes */
+#define DCACHE_LINE_SIZE        32      /* Data cache line size in bytes */
+
+#define ICACHE_SET_COUNT        256     /* Instruction cache set count */
+#define DCACHE_SET_COUNT        128     /* Data cache set count */
+
+#define ICACHE_SET_SIZE         (ICACHE_SET_COUNT * ICACHE_LINE_SIZE)
+#define DCACHE_SET_SIZE         (DCACHE_SET_COUNT * DCACHE_LINE_SIZE)
+
+	.macro	kernel_entry_setup
+	.set	push
+	.set	noreorder
+	/*
+	 * PNX8550 entry point, when running a non compressed
+	 * kernel. When loading a zImage, the head.S code in
+	 * arch/mips/zboot/pnx8550 will init the caches and,
+	 * decompress the kernel, and branch to kernel_entry.
+		 */
+cache_begin:	li	t0, (1<<28)
+	mtc0	t0, CP0_STATUS /* cp0 usable */
+	HAZARD_CP0
+
+	mtc0 	zero, CP0_CAUSE
+	HAZARD_CP0
+
+
+	/* Set static virtual to phys address translation and TLB disabled */
+	mfc0 	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	and t0,~((1<<19) | (1<<20))     /* TLB/MAP cleared */
+	mtc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	/* CPU boots with kseg0 cache algo set to 0x2 -- uncached */
+
+	init_icache
+	nop
+	init_dcache
+	nop
+
+	cachePr4450ICReset
+	nop
+
+	cachePr4450DCReset
+	nop
+
+	/* read ConfigPR into t0 */
+	mfc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	/*  enable the TLB */
+	or      t0, (1<<19)
+
+	/* disable the ICACHE: at least 10x slower */
+	/* or      t0, (1<<26) */
+
+	/* disable the DCACHE; CONFIG_CPU_HAS_LLSC should not be set  */
+	/* or      t0, (1<<27) */
+
+	and	t0, CO_CONFIGPR_VALID
+
+	/* enable TLB. */
+	mtc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+cache_end:
+	/* Setup CMEM_0 to MMIO address space, 2MB */
+	lui    t0, 0x1BE0
+	addi   t0, t0, 0x3
+	mtc0   $8, $22, 4
+	nop
+
+	/* Setup CMEM_1, 128MB */
+	lui    t0, 0x1000
+	addi   t0, t0, 0xf
+	mtc0   $8, $22, 5
+	nop
+
+
+	/* Setup CMEM_2, 32MB */
+	lui    t0, 0x1C00
+	addi   t0, t0, 0xb
+	mtc0   $8, $22, 6
+	nop
+
+	/* Setup CMEM_3, 0MB */
+	lui    t0, 0x0
+	addi   t0, t0, 0x0
+	mtc0   $8, $22, 7
+	nop
+
+	/* Enable cache */
+	mfc0	t0, CP0_CONFIG
+	HAZARD_CP0
+	and	t0, t0, 0xFFFFFFF8
+	or	t0, t0, 3
+	mtc0	t0, CP0_CONFIG
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+	.macro	init_icache
+	.set	push
+	.set	noreorder
+
+	/* Get Cache Configuration */
+	mfc0	t3, CP0_CONFIG, 1
+	HAZARD_CP0
+
+	/* get cache Line size */
+
+	srl   t1, t3, 19   /* C0_CONFIGPR_IL_SHIFT */
+	andi  t1, t1, 0x7  /* C0_CONFIGPR_IL_MASK */
+	beq   t1, zero, pr4450_instr_cache_invalidated /* if zero instruction cache is absent */
+	nop
+	addiu t0, t1, 1
+	ori   t1, zero, 1
+	sllv  t1, t1, t0
+
+	/* get max cache Index */
+	srl   t2, t3, 22  /* C0_CONFIGPR_IS_SHIFT */
+	andi  t2, t2, 0x7 /* C0_CONFIGPR_IS_MASK */
+	addiu t0, t2, 6
+	ori   t2, zero, 1
+	sllv  t2, t2, t0
+
+	/* get max cache way */
+	srl   t3, t3, 16  /* C0_CONFIGPR_IA_SHIFT */
+	andi  t3, t3, 0x7 /* C0_CONFIGPR_IA_MASK */
+	addiu t3, t3, 1
+
+	/* total no of cache lines */
+	multu t2, t3             /* max index * max way */
+	mflo  t2
+	addiu t2, t2, -1
+
+	move  t0, zero
+pr4450_next_instruction_cache_set:
+	cache  Index_Invalidate_I, 0(t0)
+	addu  t0, t0, t1         /* add bytes in a line */
+	bne   t2, zero, pr4450_next_instruction_cache_set
+	addiu t2, t2, -1   /* reduce no of lines to invalidate by one */
+pr4450_instr_cache_invalidated:
+	.set	pop
+	.endm
+
+	.macro	init_dcache
+	.set	push
+	.set	noreorder
+	move t1, zero
+
+	/* Store Tag Information */
+	mtc0	zero, CP0_TAGLO, 0
+	HAZARD_CP0
+
+	mtc0	zero, CP0_TAGHI, 0
+	HAZARD_CP0
+
+	/* Cache size is 16384 = 512 lines x 32 bytes per line */
+	or       t2, zero, (128*4)-1  /* 512 lines  */
+	/* Invalidate all lines */
+2:
+	cache Index_Store_Tag_D, 0(t1)
+	addiu    t2, t2, -1
+	bne      t2, zero, 2b
+	addiu    t1, t1, 32        /* 32 bytes in a line */
+	.set pop
+	.endm
+
+	.macro	cachePr4450ICReset
+	.set	push
+	.set	noreorder
+
+	/* Save CP0 status reg on entry; */
+	/* disable interrupts during cache reset */
+	mfc0    t0, CP0_STATUS      /* T0 = interrupt status on entry */
+	HAZARD_CP0
+
+	mtc0    zero, CP0_STATUS   /* disable CPU interrupts */
+	HAZARD_CP0
+
+	or      t1, zero, zero              /* T1 = starting cache index (0) */
+	ori     t2, zero, (256 - 1) /* T2 = inst cache set cnt - 1 */
+
+	icache_invd_loop:
+	/* 9 == register t1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Invalidate_I << 16) | \
+		(0 * ICACHE_SET_SIZE))  /* invalidate inst cache WAY0 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Invalidate_I << 16) | \
+		(1 * ICACHE_SET_SIZE))  /* invalidate inst cache WAY1 */
+
+	addiu   t1, t1, ICACHE_LINE_SIZE    /* T1 = next cache line index */
+	bne     t2, zero, icache_invd_loop /* T2 = 0 if all sets invalidated */
+	addiu   t2, t2, -1        /* decrement T2 set cnt (delay slot) */
+
+	/* Initialize the latches in the instruction cache tag */
+	/* that drive the way selection tri-state bus drivers, by doing a */
+	/* dummy load while the instruction cache is still disabled. */
+	/* TODO: Is this needed ? */
+	la      t1, KSEG0            /* T1 = cached memory base address */
+	lw      zero, 0x0000(t1)      /* (dummy read of first memory word) */
+
+	mtc0    t0, CP0_STATUS        /* restore interrupt status on entry */
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+	.macro	cachePr4450DCReset
+	.set	push
+	.set	noreorder
+	mfc0    t0, CP0_STATUS           /* T0 = interrupt status on entry */
+	HAZARD_CP0
+	mtc0    zero, CP0_STATUS         /* disable CPU interrupts */
+	HAZARD_CP0
+
+	/* Writeback/invalidate entire data cache sets/ways/lines */
+	or      t1, zero, zero              /* T1 = starting cache index (0) */
+	ori     t2, zero, (DCACHE_SET_COUNT - 1) /* T2 = data cache set cnt - 1 */
+
+	dcache_wbinvd_loop:
+	/* 9 == register t1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(0 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY0 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(1 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(2 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY2 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(3 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY3 */
+
+	addiu   t1, t1, DCACHE_LINE_SIZE  /* T1 = next data cache line index */
+	bne     t2, zero, dcache_wbinvd_loop /* T2 = 0 when wbinvd entire cache */
+	addiu   t2, t2, -1          /* decrement T2 set cnt (delay slot) */
+
+	/* Initialize the latches in the data cache tag that drive the way
+	selection tri-state bus drivers, by doing a dummy load while the
+	data cache is still in the disabled mode.  TODO: Is this needed ? */
+	la      t1, KSEG0            /* T1 = cached memory base address */
+	lw      zero, 0x0000(t1)      /* (dummy read of first memory word) */
+
+	mtc0    t0, CP0_STATUS       /* restore interrupt status on entry */
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+#endif /* __ASM_MACH_KERNEL_ENTRY_INIT_H */
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/nand.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/nand.h
@@ -0,0 +1,121 @@
+#ifndef __PNX8550_NAND_H
+#define __PNX8550_NAND_H
+
+#define PNX8550_NAND_BASE_ADDR   0x10000000
+#define PNX8550_PCIXIO_BASE	 0xBBE40000
+
+#define PNX8550_DMA_EXT_ADDR     *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x800)
+#define PNX8550_DMA_INT_ADDR     *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x804)
+#define PNX8550_DMA_TRANS_SIZE   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x808)
+#define PNX8550_DMA_CTRL         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x80c)
+#define PNX8550_XIO_SEL0         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x814)
+#define PNX8550_GPXIO_ADDR       *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x820)
+#define PNX8550_GPXIO_WR         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x824)
+#define PNX8550_GPXIO_RD         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x828)
+#define PNX8550_GPXIO_CTRL       *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x82C)
+#define PNX8550_XIO_FLASH_CTRL   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x830)
+#define PNX8550_GPXIO_INT_STATUS *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb0)
+#define PNX8550_GPXIO_INT_ENABLE *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb4)
+#define PNX8550_GPXIO_INT_CLEAR  *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb8)
+#define PNX8550_DMA_INT_STATUS   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd0)
+#define PNX8550_DMA_INT_ENABLE   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd4)
+#define PNX8550_DMA_INT_CLEAR    *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd8)
+
+#define PNX8550_XIO_SEL0_EN_16BIT    0x00800000
+#define PNX8550_XIO_SEL0_USE_ACK     0x00400000
+#define PNX8550_XIO_SEL0_REN_HIGH    0x00100000
+#define PNX8550_XIO_SEL0_REN_LOW     0x00040000
+#define PNX8550_XIO_SEL0_WEN_HIGH    0x00010000
+#define PNX8550_XIO_SEL0_WEN_LOW     0x00004000
+#define PNX8550_XIO_SEL0_WAIT        0x00000200
+#define PNX8550_XIO_SEL0_OFFSET      0x00000020
+#define PNX8550_XIO_SEL0_TYPE_68360  0x00000000
+#define PNX8550_XIO_SEL0_TYPE_NOR    0x00000008
+#define PNX8550_XIO_SEL0_TYPE_NAND   0x00000010
+#define PNX8550_XIO_SEL0_TYPE_IDE    0x00000018
+#define PNX8550_XIO_SEL0_SIZE_8MB    0x00000000
+#define PNX8550_XIO_SEL0_SIZE_16MB   0x00000002
+#define PNX8550_XIO_SEL0_SIZE_32MB   0x00000004
+#define PNX8550_XIO_SEL0_SIZE_64MB   0x00000006
+#define PNX8550_XIO_SEL0_ENAB        0x00000001
+
+#define PNX8550_SEL0_DEFAULT ((PNX8550_XIO_SEL0_EN_16BIT)  | \
+                              (PNX8550_XIO_SEL0_REN_HIGH*0)| \
+	                      (PNX8550_XIO_SEL0_REN_LOW*2) | \
+	                      (PNX8550_XIO_SEL0_WEN_HIGH*0)| \
+                              (PNX8550_XIO_SEL0_WEN_LOW*2) | \
+	                      (PNX8550_XIO_SEL0_WAIT*4)    | \
+			      (PNX8550_XIO_SEL0_OFFSET*0)  | \
+			      (PNX8550_XIO_SEL0_TYPE_NAND) | \
+			      (PNX8550_XIO_SEL0_SIZE_32MB) | \
+			      (PNX8550_XIO_SEL0_ENAB))
+
+#define PNX8550_GPXIO_PENDING        0x00000200
+#define PNX8550_GPXIO_DONE           0x00000100
+#define PNX8550_GPXIO_CLR_DONE       0x00000080
+#define PNX8550_GPXIO_INIT           0x00000040
+#define PNX8550_GPXIO_READ_CMD       0x00000010
+#define PNX8550_GPXIO_BEN            0x0000000F
+
+#define PNX8550_XIO_FLASH_64MB       0x00200000
+#define PNX8550_XIO_FLASH_INC_DATA   0x00100000
+#define PNX8550_XIO_FLASH_CMD_PH     0x000C0000
+#define PNX8550_XIO_FLASH_CMD_PH2    0x00080000
+#define PNX8550_XIO_FLASH_CMD_PH1    0x00040000
+#define PNX8550_XIO_FLASH_CMD_PH0    0x00000000
+#define PNX8550_XIO_FLASH_ADR_PH     0x00030000
+#define PNX8550_XIO_FLASH_ADR_PH3    0x00030000
+#define PNX8550_XIO_FLASH_ADR_PH2    0x00020000
+#define PNX8550_XIO_FLASH_ADR_PH1    0x00010000
+#define PNX8550_XIO_FLASH_ADR_PH0    0x00000000
+#define PNX8550_XIO_FLASH_CMD_B(x)   ((x<<8) & 0x0000FF00)
+#define PNX8550_XIO_FLASH_CMD_A(x)   (x & 0x000000FF)
+
+#define PNX8550_XIO_INT_ACK          0x00004000
+#define PNX8550_XIO_INT_COMPL        0x00002000
+#define PNX8550_XIO_INT_NONSUP       0x00000200
+#define PNX8550_XIO_INT_ABORT        0x00000004
+
+#define PNX8550_DMA_CTRL_SINGLE_DATA 0x00000400
+#define PNX8550_DMA_CTRL_SND2XIO     0x00000200
+#define PNX8550_DMA_CTRL_FIX_ADDR    0x00000100
+#define PNX8550_DMA_CTRL_BURST_8     0x00000000
+#define PNX8550_DMA_CTRL_BURST_16    0x00000020
+#define PNX8550_DMA_CTRL_BURST_32    0x00000040
+#define PNX8550_DMA_CTRL_BURST_64    0x00000060
+#define PNX8550_DMA_CTRL_BURST_128   0x00000080
+#define PNX8550_DMA_CTRL_BURST_256   0x000000A0
+#define PNX8550_DMA_CTRL_BURST_512   0x000000C0
+#define PNX8550_DMA_CTRL_BURST_NORES 0x000000E0
+#define PNX8550_DMA_CTRL_INIT_DMA    0x00000010
+#define PNX8550_DMA_CTRL_CMD_TYPE    0x0000000F
+
+/* see PCI system arch, page 100 for the full list: */
+#define PNX8550_DMA_CTRL_PCI_CMD_READ    0x00000006
+#define PNX8550_DMA_CTRL_PCI_CMD_WRITE   0x00000007
+
+#define PNX8550_DMA_INT_STAT_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_STAT_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_STAT_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_STAT_PERR5	(1<<5)
+#define PNX8550_DMA_INT_STAT_PERR4	(1<<4)
+#define PNX8550_DMA_INT_STAT_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_STAT_T_ABORT	(1<<1)
+
+#define PNX8550_DMA_INT_EN_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_EN_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_EN_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_EN_PERR5	(1<<5)
+#define PNX8550_DMA_INT_EN_PERR4	(1<<4)
+#define PNX8550_DMA_INT_EN_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_EN_T_ABORT	(1<<1)
+
+#define PNX8550_DMA_INT_CLR_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_CLR_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_CLR_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_CLR_PERR5	(1<<5)
+#define PNX8550_DMA_INT_CLR_PERR4	(1<<4)
+#define PNX8550_DMA_INT_CLR_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_CLR_T_ABORT	(1<<1)
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/pci.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/pci.h
@@ -0,0 +1,185 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ * PCI specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_PCI_H
+#define __PNX8550_PCI_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+#define PCI_CMD_IOR                     0x20
+#define PCI_CMD_IOW                     0x30
+#define PCI_CMD_CONFIG_READ             0xa0
+#define PCI_CMD_CONFIG_WRITE            0xb0
+
+#define PCI_IO_TIMEOUT                  1000
+#define PCI_IO_RETRY			5
+/* Timeout for IO and CFG accesses.
+   This is in 1/1024 th of a jiffie(=10ms)
+   i.e. approx 10us */
+#define PCI_IO_JIFFIES_TIMEOUT          40
+#define PCI_IO_JIFFIES_SHIFT            10
+
+#define PCI_BYTE_ENABLE_MASK		0x0000000f
+#define PCI_CFG_BUS_SHIFT               16
+#define PCI_CFG_FUNC_SHIFT              8
+#define PCI_CFG_REG_SHIFT               2
+
+#define PCI_BASE                  0x1be00000
+#define PCI_SETUP                 0x00040010
+#define PCI_DIS_REQGNT           (1<<30)
+#define PCI_DIS_REQGNTA          (1<<29)
+#define PCI_DIS_REQGNTB          (1<<28)
+#define PCI_D2_SUPPORT           (1<<27)
+#define PCI_D1_SUPPORT           (1<<26)
+#define PCI_EN_TA                (1<<24)
+#define PCI_EN_PCI2MMI           (1<<23)
+#define PCI_EN_XIO               (1<<22)
+#define PCI_BASE18_PREF          (1<<21)
+#define SIZE_16M                 0x3
+#define SIZE_32M                 0x4
+#define SIZE_64M                 0x5
+#define SIZE_128M                0x6
+#define PCI_SETUP_BASE18_SIZE(X) (X<<18)
+#define PCI_SETUP_BASE18_EN      (1<<17)
+#define PCI_SETUP_BASE14_PREF    (1<<16)
+#define PCI_SETUP_BASE14_SIZE(X) (X<<12)
+#define PCI_SETUP_BASE14_EN      (1<<11)
+#define PCI_SETUP_BASE10_PREF    (1<<10)
+#define PCI_SETUP_BASE10_SIZE(X) (X<<7)
+#define PCI_SETUP_CFGMANAGE_EN   (1<<1)
+#define PCI_SETUP_PCIARB_EN      (1<<0)
+
+#define PCI_CTRL                  0x040014
+#define PCI_SWPB_DCS_PCI         (1<<16)
+#define PCI_SWPB_PCI_PCI         (1<<15)
+#define PCI_SWPB_PCI_DCS         (1<<14)
+#define PCI_REG_WR_POST          (1<<13)
+#define PCI_XIO_WR_POST          (1<<12)
+#define PCI_PCI2_WR_POST         (1<<13)
+#define PCI_PCI1_WR_POST         (1<<12)
+#define PCI_SERR_SEEN            (1<<11)
+#define PCI_B10_SPEC_RD          (1<<6)
+#define PCI_B14_SPEC_RD          (1<<5)
+#define PCI_B18_SPEC_RD          (1<<4)
+#define PCI_B10_NOSUBWORD        (1<<3)
+#define PCI_B14_NOSUBWORD        (1<<2)
+#define PCI_B18_NOSUBWORD        (1<<1)
+#define PCI_RETRY_TMREN          (1<<0)
+
+#define PCI_BASE1_LO              0x040018
+#define PCI_BASE1_HI              0x04001C
+#define PCI_BASE2_LO              0x040020
+#define PCI_BASE2_HI              0x040024
+#define PCI_RDLIFETIM             0x040028
+#define PCI_GPPM_ADDR             0x04002C
+#define PCI_GPPM_WDAT             0x040030
+#define PCI_GPPM_RDAT             0x040034
+#define PCI_GPPM_CTRL             0x040038
+#define GPPM_DONE                (1<<10)
+#define INIT_PCI_CYCLE           (1<<9)
+#define GPPM_CMD(X)              (((X)&0xf)<<4)
+#define GPPM_BYTEEN(X)           ((X)&0xf)
+#define PCI_UNLOCKREG             0x04003C
+#define UNLOCK_SSID(X)           (((X)&0xff)<<8)
+#define UNLOCK_SETUP(X)          (((X)&0xff)<<0)
+#define UNLOCK_MAGIC             0xCA
+#define PCI_DEV_VEND_ID           0x040040
+#define DEVICE_ID(X)             (((X)>>16)&0xffff)
+#define VENDOR_ID(X)             (((X)&0xffff))
+#define PCI_CFG_CMDSTAT           0x040044
+#define PCI_CFG_STATUS(X)            (((X)>>16)&0xffff)
+#define PCI_CFG_COMMAND(X)           ((X)&0xffff)
+#define PCI_CLASS_REV             0x040048
+#define PCI_CLASSCODE(X)         (((X)>>8)&0xffffff)
+#define PCI_REVID(X)             ((X)&0xff)
+#define PCI_LAT_TMR     0x04004c
+#define PCI_BASE10      0x040050
+#define PCI_BASE14      0x040054
+#define PCI_BASE18      0x040058
+#define PCI_SUBSYS_ID   0x04006c
+#define PCI_CAP_PTR     0x040074
+#define PCI_CFG_MISC    0x04007c
+#define PCI_PMC         0x040080
+#define PCI_PWR_STATE   0x040084
+#define PCI_IO          0x040088
+#define PCI_SLVTUNING   0x04008C
+#define PCI_DMATUNING   0x040090
+#define PCI_DMAEADDR    0x040800
+#define PCI_DMAIADDR    0x040804
+#define PCI_DMALEN      0x040808
+#define PCI_DMACTRL     0x04080C
+#define PCI_XIOCTRL     0x040810
+#define PCI_SEL0PROF    0x040814
+#define PCI_SEL1PROF    0x040818
+#define PCI_SEL2PROF    0x04081C
+#define PCI_GPXIOADDR   0x040820
+#define PCI_NANDCTRLS   0x400830
+#define PCI_SEL3PROF    0x040834
+#define PCI_SEL4PROF    0x040838
+#define PCI_GPXIO_STAT  0x040FB0
+#define PCI_GPXIO_IMASK 0x040FB4
+#define PCI_GPXIO_ICLR  0x040FB8
+#define PCI_GPXIO_ISET  0x040FBC
+#define PCI_GPPM_STATUS 0x040FC0
+#define GPPM_DONE      (1<<10)
+#define GPPM_ERR       (1<<9)
+#define GPPM_MPAR_ERR  (1<<8)
+#define GPPM_PAR_ERR   (1<<7)
+#define GPPM_R_MABORT  (1<<2)
+#define GPPM_R_TABORT  (1<<1)
+#define PCI_GPPM_IMASK  0x040FC4
+#define PCI_GPPM_ICLR   0x040FC8
+#define PCI_GPPM_ISET   0x040FCC
+#define PCI_DMA_STATUS  0x040FD0
+#define PCI_DMA_IMASK   0x040FD4
+#define PCI_DMA_ICLR    0x040FD8
+#define PCI_DMA_ISET    0x040FDC
+#define PCI_ISTATUS     0x040FE0
+#define PCI_IMASK       0x040FE4
+#define PCI_ICLR        0x040FE8
+#define PCI_ISET        0x040FEC
+#define PCI_MOD_ID      0x040FFC
+
+/*
+ *  PCI configuration cycle AD bus definition
+ */
+/* Type 0 */
+#define PCI_CFG_TYPE0_REG_SHF           0
+#define PCI_CFG_TYPE0_FUNC_SHF          8
+
+/* Type 1 */
+#define PCI_CFG_TYPE1_REG_SHF           0
+#define PCI_CFG_TYPE1_FUNC_SHF          8
+#define PCI_CFG_TYPE1_DEV_SHF           11
+#define PCI_CFG_TYPE1_BUS_SHF           16
+
+/*
+ *  Ethernet device DP83816 definition
+ */
+#define DP83816_IRQ_ETHER               66
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/uart.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/uart.h
@@ -0,0 +1,16 @@
+#ifndef __IP3106_UART_H
+#define __IP3106_UART_H
+
+#include <int.h>
+
+/* early macros for kgdb use. fixme: clean this up */
+
+#define UART_BASE		0xbbe4a000	/* PNX8550 */
+
+#define PNX8550_UART_PORT0	(UART_BASE)
+#define PNX8550_UART_PORT1	(UART_BASE + 0x1000)
+
+#define PNX8550_UART_INT(x)		(PNX8550_INT_GIC_MIN+19+x)
+#define IRQ_TO_UART(x)			(x-PNX8550_INT_GIC_MIN-19)
+
+#endif
Index: linux-2.6.10/include/asm-mips/mach-pnx8550/usb.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/mach-pnx8550/usb.h
@@ -0,0 +1,32 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  USB specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_USB_H
+#define __PNX8550_USB_H
+
+/*
+ * USB Host controller
+ */
+
+#define PNX8550_USB_OHCI_OP_BASE	0x1be48000
+#define PNX8550_USB_OHCI_OP_LEN	        0x1000
+
+#endif
Index: linux-2.6.10/include/asm-mips/mipsregs.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/mipsregs.h
+++ linux-2.6.10/include/asm-mips/mipsregs.h
@@ -781,12 +781,24 @@ do {									\
 #define read_c0_count()		__read_32bit_c0_register($9, 0)
 #define write_c0_count(val)	__write_32bit_c0_register($9, 0, val)
 
+#define read_c0_count2()	__read_32bit_c0_register($9, 6) /* pnx8550 */
+#define write_c0_count2(val)	__write_32bit_c0_register($9, 6, val)
+
+#define read_c0_count3()	__read_32bit_c0_register($9, 7) /* pnx8550 */
+#define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
+
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
 
+#define read_c0_compare2()	__read_32bit_c0_register($11, 6) /* pnx8550 */
+#define write_c0_compare2(val)	__write_32bit_c0_register($11, 6, val)
+
+#define read_c0_compare3()	__read_32bit_c0_register($11, 7) /* pnx8550 */
+#define write_c0_compare3(val)	__write_32bit_c0_register($11, 7, val)
+
 #define read_c0_status()	__read_32bit_c0_register($12, 0)
 #define write_c0_status(val)	__write_32bit_c0_register($12, 0, val)
 
@@ -802,10 +814,12 @@ do {									\
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
Index: linux-2.6.10/include/linux/serial_core.h
===================================================================
--- linux-2.6.10.orig/include/linux/serial_core.h
+++ linux-2.6.10/include/linux/serial_core.h
@@ -106,6 +106,8 @@
 /* TXX9 type number */
 #define PORT_TXX9	64
 
+#define PORT_IP3106     70
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>
Index: linux-2.6.10/include/linux/serial_ip3106.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/linux/serial_ip3106.h
@@ -0,0 +1,93 @@
+/*
+ * Embedded Alley Solutions, source@embeddedalley.com.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_SERIAL_IP3106_H
+#define _LINUX_SERIAL_IP3106_H
+
+#include <linux/serial_core.h>
+#include <linux/device.h>
+
+#define IP3106_NR_PORTS		2
+
+struct ip3106_port {
+	struct uart_port	port;
+	struct timer_list	timer;
+	unsigned int		old_status;
+};
+
+/* register offsets */
+#define IP3106_LCR		0
+#define IP3106_MCR		0x004
+#define IP3106_BAUD		0x008
+#define IP3106_CFG		0x00c
+#define IP3106_FIFO		0x028
+#define IP3106_ISTAT		0xfe0
+#define IP3106_IEN		0xfe4
+#define IP3106_ICLR		0xfe8
+#define IP3106_ISET		0xfec
+#define IP3106_PD		0xff4
+#define IP3106_MID		0xffc
+
+#define IP3106_UART_LCR_TXBREAK		(1<<30)
+#define IP3106_UART_LCR_PAREVN		0x10000000
+#define IP3106_UART_LCR_PAREN		0x08000000
+#define IP3106_UART_LCR_2STOPB		0x04000000
+#define IP3106_UART_LCR_8BIT		0x01000000
+#define IP3106_UART_LCR_TX_RST		0x00040000
+#define IP3106_UART_LCR_RX_RST		0x00020000
+#define IP3106_UART_LCR_RX_NEXT		0x00010000
+
+#define IP3106_UART_MCR_SCR		0xFF000000
+#define IP3106_UART_MCR_DCD		0x00800000
+#define IP3106_UART_MCR_CTS		0x00100000
+#define IP3106_UART_MCR_LOOP		0x00000010
+#define IP3106_UART_MCR_RTS		0x00000002
+#define IP3106_UART_MCR_DTR		0x00000001
+
+#define IP3106_UART_INT_TX		0x00000080
+#define IP3106_UART_INT_EMPTY		0x00000040
+#define IP3106_UART_INT_RCVTO		0x00000020
+#define IP3106_UART_INT_RX		0x00000010
+#define IP3106_UART_INT_RXOVRN		0x00000008
+#define IP3106_UART_INT_FRERR		0x00000004
+#define IP3106_UART_INT_BREAK		0x00000002
+#define IP3106_UART_INT_PARITY		0x00000001
+#define IP3106_UART_INT_ALLRX		0x0000003F
+#define IP3106_UART_INT_ALLTX		0x000000C0
+
+#define IP3106_UART_FIFO_TXFIFO		0x001F0000
+#define IP3106_UART_FIFO_TXFIFO_STA	(0x1f<<16)
+#define IP3106_UART_FIFO_RXBRK		0x00008000
+#define IP3106_UART_FIFO_RXFE		0x00004000
+#define IP3106_UART_FIFO_RXPAR		0x00002000
+#define IP3106_UART_FIFO_RXFIFO		0x00001F00
+#define IP3106_UART_FIFO_RBRTHR		0x000000FF
+
+#define ip3106_lcr(base,port)    *(volatile u32 *)(base+(port*0x1000) + 0x000)
+#define ip3106_mcr(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0x004)
+#define ip3106_baud(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0x008)
+#define ip3106_cfg(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0x00C)
+#define ip3106_fifo(base, port)	 *(volatile u32 *)(base+(port*0x1000) + 0x028)
+#define ip3106_istat(base, port) *(volatile u32 *)(base+(port*0x1000) + 0xFE0)
+#define ip3106_ien(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0xFE4)
+#define ip3106_iclr(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0xFE8)
+#define ip3106_iset(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0xFEC)
+#define ip3106_pd(base, port)    *(volatile u32 *)(base+(port*0x1000) + 0xFF4)
+#define ip3106_mid(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0xFFC)
+
+#endif
Index: linux-2.6.10/arch/mips/mm/tlbex.c
===================================================================
--- linux-2.6.10.orig/arch/mips/mm/tlbex.c
+++ linux-2.6.10/arch/mips/mm/tlbex.c
@@ -840,6 +840,7 @@ static __init void build_tlb_write_entry
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
+	case CPU_PR4450:
 		i_nop(p);
 		tlbw(p);
 		break;
Index: linux-2.6.10/include/asm-mips/cpu.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/cpu.h
+++ linux-2.6.10/include/asm-mips/cpu.h
@@ -28,6 +28,7 @@
 #define PRID_COMP_ALCHEMY      0x030000
 #define PRID_COMP_SIBYTE       0x040000
 #define PRID_COMP_SANDCRAFT    0x050000
+#define PRID_COMP_PHILIPS      0x060000
 
 /*
  * Assigned values for the product ID register.  In order to detect a
@@ -46,6 +47,7 @@
 #define PRID_IMP_VR41XX		0x0c00
 #define PRID_IMP_R12000		0x0e00
 #define PRID_IMP_R8000		0x1000
+#define PRID_IMP_PR4450		0x1200
 #define PRID_IMP_R4600		0x2000
 #define PRID_IMP_R4700		0x2100
 #define PRID_IMP_TX39		0x2200
@@ -177,7 +179,8 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
-#define CPU_LAST		58
+#define CPU_PR4450		60
+#define CPU_LAST		60
 
 /*
  * ISA Level encodings
Index: linux-2.6.10/mvl_patches/pro-0311.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0311.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(311);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

