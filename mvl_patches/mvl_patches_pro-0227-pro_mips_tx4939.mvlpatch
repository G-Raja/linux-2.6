#! /usr/bin/env bash
# Patch: -pro_mips_tx4939
# Date: Wed Dec 28 15:02:13 2005
#  Source: MontaVista Software, Inc. | http://source.mvista.com | Hiroshi DOYU <hdoyu@mvista.com>
#  MR: 13614
#  Type: Enhancement
#  Disposition: Needs submitting to linux-mips.org
#  Signed-off-by: Hiroshi DOYU <hdoyu@mvista.com>
#  Signed-off-by: Atsuo Igarashi <aigarashi@mvista.com>
#  Description:
#         Support for TX4939 in 2.6.
# 
#  arch/mips/Kconfig                     |   20 
#  arch/mips/Makefile                    |    8 
#  arch/mips/pci/Makefile                |    1 
#  arch/mips/pci/fixup-tx4939.c          |  118 +
#  arch/mips/pci/ops-tx4939.c            |  174 ++
#  arch/mips/pci/pci-tx4939.c            |  511 ++++++
#  arch/mips/tx4939/Kconfig              |   95 +
#  arch/mips/tx4939/common/Makefile      |   12 
#  arch/mips/tx4939/common/ide.c         |   68 
#  arch/mips/tx4939/common/irq.c         |  365 ++++
#  arch/mips/tx4939/common/irq_handler.S |   95 +
#  arch/mips/tx4939/common/proc.c        |  952 ++++++++++++
#  arch/mips/tx4939/common/prom.c        |  144 +
#  arch/mips/tx4939/common/puts.c        |  169 ++
#  arch/mips/tx4939/common/rtc.c         |   97 +
#  arch/mips/tx4939/common/setup.c       |  541 +++++++
#  arch/mips/tx4939/common/spi_txx9.c    |  177 ++
#  arch/mips/tx4939/common/tx49wtoe.c    |   92 +
#  arch/mips/tx4939/rbtx4939/Makefile    |   11 
#  arch/mips/tx4939/rbtx4939/irq.c       |  164 ++
#  arch/mips/tx4939/rbtx4939/led.c       |   57 
#  arch/mips/tx4939/rbtx4939/proc.c      |  137 +
#  arch/mips/tx4939/rbtx4939/setup.c     |  320 ++++
#  drivers/ide/Kconfig                   |    5 
#  drivers/ide/ide-cd.c                  |   14 
#  drivers/ide/ide-dma.c                 |    5 
#  drivers/ide/ide-proc.c                |    1 
#  drivers/ide/ide.c                     |    9 
#  drivers/ide/mips/Makefile             |    1 
#  drivers/ide/mips/ide-tx4939.c         |  534 ++++++
#  drivers/mtd/maps/Kconfig              |    6 
#  drivers/mtd/maps/Makefile             |    1 
#  drivers/mtd/maps/tx4939-flash.c       |  278 +++
#  drivers/mtd/nand/Kconfig              |    7 
#  drivers/mtd/nand/Makefile             |    1 
#  drivers/mtd/nand/tx4939ndfmc.c        |  592 +++++++
#  drivers/net/Kconfig                   |    6 
#  drivers/net/Makefile                  |    1 
#  drivers/net/smc91x.h                  |   35 
#  drivers/net/tc35815_1.c               | 2622 ++++++++++++++++++++++++++++++++++
#  drivers/pci/pci.ids                   |    8 
#  drivers/pci/quirks.c                  |   15 
#  drivers/scsi/ide-scsi.c               |    6 
#  include/asm-mips/bootinfo.h           |    4 
#  include/asm-mips/tx4939/config.h      |  162 ++
#  include/asm-mips/tx4939/ide.h         |   71 
#  include/asm-mips/tx4939/rbtx4939.h    |  173 ++
#  include/asm-mips/tx4939/spi.h         |   81 +
#  include/asm-mips/tx4939/tx4939.h      | 1670 +++++++++++++++++++++
#  include/linux/ide.h                   |    1 
#  include/linux/pci_ids.h               |    2 
#  51 files changed, 10632 insertions(+), 7 deletions(-)
# 

PATCHNUM=227
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
 Source: MontaVista Software, Inc. | http://source.mvista.com | Hiroshi DOYU <hdoyu@mvista.com>
 MR: 13614
 Type: Enhancement
 Disposition: Needs submitting to linux-mips.org
 Signed-off-by: Hiroshi DOYU <hdoyu@mvista.com>
 Signed-off-by: Atsuo Igarashi <aigarashi@mvista.com>
 Description:
        Support for TX4939 in 2.6.

 arch/mips/Kconfig                     |   20 
 arch/mips/Makefile                    |    8 
 arch/mips/pci/Makefile                |    1 
 arch/mips/pci/fixup-tx4939.c          |  118 +
 arch/mips/pci/ops-tx4939.c            |  174 ++
 arch/mips/pci/pci-tx4939.c            |  511 ++++++
 arch/mips/tx4939/Kconfig              |   95 +
 arch/mips/tx4939/common/Makefile      |   12 
 arch/mips/tx4939/common/ide.c         |   68 
 arch/mips/tx4939/common/irq.c         |  365 ++++
 arch/mips/tx4939/common/irq_handler.S |   95 +
 arch/mips/tx4939/common/proc.c        |  952 ++++++++++++
 arch/mips/tx4939/common/prom.c        |  144 +
 arch/mips/tx4939/common/puts.c        |  169 ++
 arch/mips/tx4939/common/rtc.c         |   97 +
 arch/mips/tx4939/common/setup.c       |  541 +++++++
 arch/mips/tx4939/common/spi_txx9.c    |  177 ++
 arch/mips/tx4939/common/tx49wtoe.c    |   92 +
 arch/mips/tx4939/rbtx4939/Makefile    |   11 
 arch/mips/tx4939/rbtx4939/irq.c       |  164 ++
 arch/mips/tx4939/rbtx4939/led.c       |   57 
 arch/mips/tx4939/rbtx4939/proc.c      |  137 +
 arch/mips/tx4939/rbtx4939/setup.c     |  320 ++++
 drivers/ide/Kconfig                   |    5 
 drivers/ide/ide-cd.c                  |   14 
 drivers/ide/ide-dma.c                 |    5 
 drivers/ide/ide-proc.c                |    1 
 drivers/ide/ide.c                     |    9 
 drivers/ide/mips/Makefile             |    1 
 drivers/ide/mips/ide-tx4939.c         |  534 ++++++
 drivers/mtd/maps/Kconfig              |    6 
 drivers/mtd/maps/Makefile             |    1 
 drivers/mtd/maps/tx4939-flash.c       |  278 +++
 drivers/mtd/nand/Kconfig              |    7 
 drivers/mtd/nand/Makefile             |    1 
 drivers/mtd/nand/tx4939ndfmc.c        |  592 +++++++
 drivers/net/Kconfig                   |    6 
 drivers/net/Makefile                  |    1 
 drivers/net/smc91x.h                  |   35 
 drivers/net/tc35815_1.c               | 2622 ++++++++++++++++++++++++++++++++++
 drivers/pci/pci.ids                   |    8 
 drivers/pci/quirks.c                  |   15 
 drivers/scsi/ide-scsi.c               |    6 
 include/asm-mips/bootinfo.h           |    4 
 include/asm-mips/tx4939/config.h      |  162 ++
 include/asm-mips/tx4939/ide.h         |   71 
 include/asm-mips/tx4939/rbtx4939.h    |  173 ++
 include/asm-mips/tx4939/spi.h         |   81 +
 include/asm-mips/tx4939/tx4939.h      | 1670 +++++++++++++++++++++
 include/linux/ide.h                   |    1 
 include/linux/pci_ids.h               |    2 
 mvl_patches/pro-0227.c                |   16 
 52 files changed, 10648 insertions(+), 7 deletions(-)

Index: linux-2.6.10/arch/mips/Kconfig
===================================================================
--- linux-2.6.10.orig/arch/mips/Kconfig
+++ linux-2.6.10/arch/mips/Kconfig
@@ -940,6 +940,26 @@ config TOSHIBA_RBTX4938
 	  This Toshiba board is based on the TX4938 processor. Say Y here to
 	  support this machine type
 
+config TOSHIBA_RBTX4939
+	bool "Support for Toshiba RBTX4939 board"
+	select HAVE_STD_PC_SERIAL_PORT
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
+	select HAS_TXX9_SERIAL
+	select HW_HAS_PCI
+	select I8259
+	select ISA
+	select SWAP_IO_SPACE
+	select TOSHIBA_BOARDS
+	select 	GEN_RTC
+	help
+	  This Toshiba board is based on the TX4938 processor. Say Y here to
+	  support this machine type
+
+if TOSHIBA_RBTX4939
+	source "arch/mips/tx4939/Kconfig"
+endif
+
 source "lib/Kconfig.RT"
 
 config RWSEM_GENERIC_SPINLOCK
Index: linux-2.6.10/arch/mips/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/Makefile
+++ linux-2.6.10/arch/mips/Makefile
@@ -665,6 +665,14 @@ core-$(CONFIG_TOSHIBA_RBTX4938) += arch/
 core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/common/
 load-$(CONFIG_TOSHIBA_RBTX4938) += 0xffffffff80100000
 
+#
+# Toshiba RBTX4939 board
+#
+core-$(CONFIG_TOSHIBA_RBTX4939) += arch/mips/tx4939/rbtx4939/
+core-$(CONFIG_TOSHIBA_RBTX4939) += arch/mips/tx4939/common/
+cflags-$(CONFIG_TOSHIBA_RBTX4939) += -Iinclude/asm-mips/tx4939
+load-$(CONFIG_TOSHIBA_RBTX4939) += 0xffffffff80100000
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
Index: linux-2.6.10/arch/mips/pci/Makefile
===================================================================
--- linux-2.6.10.orig/arch/mips/pci/Makefile
+++ linux-2.6.10/arch/mips/pci/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0
 obj-$(CONFIG_TOSHIBA_JMR3927)	+= fixup-jmr3927.o pci-jmr3927.o
 obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o ops-tx4927.o
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-tx4938.o ops-tx4938.o
+obj-$(CONFIG_TOSHIBA_RBTX4939)	+= fixup-tx4939.o ops-tx4939.o pci-tx4939.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_VR5701_SG2)	+= pci-vr5701_sg2.o ops-vr5701_sg2.o
Index: linux-2.6.10/arch/mips/pci/fixup-tx4939.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/fixup-tx4939.c
@@ -0,0 +1,118 @@
+/*
+ * arch/mips/pci/fixup-tx4939.c
+ *
+ * Toshiba rbtx4939 pci routines
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/tx4939/rbtx4939.h>
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+	/* nothing to do here */
+}
+
+void __init pcibios_fixup(void)
+{
+	/* nothing to do here */
+}
+
+/**
+ * pci_get_irq - get IRQ number of pci device
+ * @dev: pci_dev structure
+ * @pin: pci interrupt pin
+ *
+ *
+ */
+static int __init pci_get_irq(struct pci_dev *dev, int pin)
+{
+	int irq = pin;
+	u8 slot = PCI_SLOT(dev->devfn);
+	struct pci_controller *controller =
+	    (struct pci_controller *)dev->sysdata;
+	struct pci_bus *bus;
+
+	pr_debug("pci_get_irq: pin is %d, slot is %d\n", pin, slot);
+	if (controller == &tx4939_pci_controller[1]) {
+		unsigned int i;
+		for (i = 0; i < 2; i++) {
+			if (slot ==
+			    TX4939_PCIC_IDSEL_AD_TO_SLOT(TX4939_ETHER_IDSEL(i))) {
+				if (reg_rd64s(&tx4939_ccfgptr->pcfg) & (TX4939_PCFG_ET0MODE_ETHER << i)) {
+					pr_debug("eth%d pci slot: irq from slot %d is %d\n", i, slot, TX4939_IRQ_ETHER(i));
+					return TX4939_IRQ_ETHER(i);
+				}
+			}
+		}
+		return 0;
+	}
+
+	/* IRQ rotation */
+	irq--;			/* 0-3 */
+	bus = dev->bus;
+	if (bus->parent != NULL) {
+		/* PCI-PCI Bridge */
+		while (bus != NULL && bus->number > 0) {
+			irq = (irq + slot) % 4;
+			slot = PCI_SLOT(bus->self->devfn);
+			bus = bus->parent;
+		}
+	}
+	irq = (irq + 33 - slot) % 4;	/* magic number to calculate IRQ on RBX4939 */
+	irq++;			/* 1-4 */
+
+	switch (irq) {
+	case 1:
+		irq = TX4939_IRQ_INTA;
+		break;
+	case 2:
+		irq = TX4939_IRQ_INTB;
+		break;
+	case 3:
+		irq = TX4939_IRQ_INTC;
+		break;
+	case 4:
+		irq = TX4939_IRQ_INTD;
+		break;
+	}
+
+	pr_debug("assigned irq %d\n", irq);
+
+	return irq;
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	unsigned char irq = 0;
+
+	irq = pci_get_irq(dev, pin);
+
+	printk(KERN_INFO "PCI: 0x%02x:0x%02x(0x%02x,0x%02x) IRQ=%d\n",
+	       dev->bus->number, dev->devfn, PCI_SLOT(dev->devfn),
+	       PCI_FUNC(dev->devfn), irq);
+
+	return irq;
+}
+
+/*
+ * Do platform specific device initialization at pci_enable_device() time
+ */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
Index: linux-2.6.10/arch/mips/pci/ops-tx4939.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/ops-tx4939.c
@@ -0,0 +1,174 @@
+/*
+ * arch/mips/pci/ops-tx4939.c
+ *
+ * Define the pci_ops for the Toshiba rbtx4939
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/config.h>
+
+#include <asm/addrspace.h>
+#include <asm/tx4939/tx4939.h>
+#include <asm/tx4939/rbtx4939.h>
+#include <asm/debug.h>
+
+static inline struct tx4939_pcic_reg *pci_dev_to_pcicptr(struct pci_bus *dev)
+{
+	struct pci_controller *channel = (struct pci_controller *)dev->sysdata;
+	return pcicptrs[channel - &tx4939_pci_controller[0]];
+}
+
+static int
+mkaddr(unsigned char bus, unsigned char dev_fn, unsigned char where,
+       int *flagsp, struct tx4939_pcic_reg *pcicptr)
+{
+	u32 l;
+	if (bus > 0) {
+		/* Type 1 configuration */
+		reg_wr32(&pcicptr->g2pcfgadrs, ((bus & 0xff) << 0x10) |
+			  ((dev_fn & 0xff) << 0x08) | (where & 0xfc) | 1);
+	} else {
+		if (dev_fn >= PCI_DEVFN(TX4939_PCIC_MAX_DEVNU, 0))
+			return -1;
+
+		/* Type 0 configuration */
+		reg_wr32(&pcicptr->g2pcfgadrs, ((bus & 0xff) << 0x10) |
+			  ((dev_fn & 0xff) << 0x08) | (where & 0xfc));
+	}
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	reg_wr32(&pcicptr->pcistatus,
+		  (reg_rd32(&pcicptr->pcistatus) & 0x0000ffff) |
+		  (PCI_STATUS_REC_MASTER_ABORT << 16));
+	l = reg_rd32(&pcicptr->pcimask);
+	reg_wr32(&pcicptr->pcimask, l & ~PCI_STATUS_REC_MASTER_ABORT);
+	return 0;
+}
+
+static int check_abort(int flags, struct tx4939_pcic_reg *pcicptr)
+{
+	u32 l;
+	int code = PCIBIOS_SUCCESSFUL;
+	/* wait write cycle completion before checking error status */
+	while (reg_rd32(&pcicptr->pcicstatus) & TX4939_PCICSTATUS_IWB) ;
+	if (reg_rd32(&pcicptr->pcistatus) &
+	    (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		reg_wr32(&pcicptr->pcistatus,
+			  (reg_rd32(&pcicptr->pcistatus) & 0x0000ffff) |
+			  (PCI_STATUS_REC_MASTER_ABORT << 16));
+		code = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	l = reg_rd32(&pcicptr->pcimask);
+	reg_wr32(&pcicptr->pcimask, l | PCI_STATUS_REC_MASTER_ABORT);
+	return code;
+}
+
+static int tx4939_pcibios_read_config(struct pci_bus *bus, unsigned int devfn,
+				      int where, int size, u32 * val)
+{
+	int flags, retval, dev, busno, func;
+	struct tx4939_pcic_reg *tx4939_pcicptr = pci_dev_to_pcicptr(bus);
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL)
+		busno = bus->number;
+	else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags, tx4939_pcicptr))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*val = *(volatile u8 *)((ulong) & tx4939_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+					((where & 3) ^ 3));
+#else
+					(where & 3));
+#endif
+		break;
+	case 2:
+		*val = *(volatile u16 *)((ulong) & tx4939_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+					 ((where & 3) ^ 2));
+#else
+					 (where & 3));
+#endif
+		break;
+	case 4:
+		*val = reg_rd32(&tx4939_pcicptr->g2pcfgdata);
+		break;
+	}
+
+	retval = check_abort(flags, tx4939_pcicptr);
+	if (retval == PCIBIOS_DEVICE_NOT_FOUND)
+		*val = 0xffffffff;
+
+	return retval;
+}
+
+static int tx4939_pcibios_write_config(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 val)
+{
+	int flags, dev, busno, func;
+	struct tx4939_pcic_reg *tx4939_pcicptr = pci_dev_to_pcicptr(bus);
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		busno = bus->number;
+	} else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags, tx4939_pcicptr))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*(volatile u8 *)((ulong) & tx4939_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+				 ((where & 3) ^ 3)) = val;
+#else
+				 (where & 3)) = val;
+#endif
+		break;
+	case 2:
+		*(volatile u16 *)((ulong) & tx4939_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+				  ((where & 0x3) ^ 0x2)) = val;
+#else
+				  (where & 3)) = val;
+#endif
+		break;
+	case 4:
+		reg_wr32(&tx4939_pcicptr->g2pcfgdata, val);
+		break;
+	}
+
+	return check_abort(flags, tx4939_pcicptr);
+}
+
+struct pci_ops tx4939_pci_ops = {
+        .read = tx4939_pcibios_read_config,
+	.write = tx4939_pcibios_write_config
+};
Index: linux-2.6.10/arch/mips/pci/pci-tx4939.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/pci/pci-tx4939.c
@@ -0,0 +1,511 @@
+/*
+ * arch/mips/pci/pci-tx4939.c
+ *
+ * tx4939 pcic setup routines
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/stddef.h>
+#include <asm/tx4939/tx4939.h>
+
+static struct resource pci_io_resource = {
+	.name = "pci IO space",
+	.start = 0x0,
+	.end = 0x0,
+	.flags = IORESOURCE_IO,
+ };
+
+static struct resource pci_mem_resource = {
+	.name = "pci memory space",
+	.start = 0x0,
+	.end = 0x0,
+	.flags = IORESOURCE_MEM,
+};
+
+static struct resource tx4939_pcic1_pci_io_resource = {
+	.name = "PCI1 IO",
+	.start = 0x0,
+	.end = 0x0,
+	.flags = IORESOURCE_IO,
+};
+static struct resource tx4939_pcic1_pci_mem_resource = {
+	.name = "PCI1 mem",
+	.start = 0x0,
+	.end = 0x0,
+	.flags = IORESOURCE_MEM,
+};
+
+struct pci_controller tx4939_pci_controller[] = {
+	/* h/w only supports devices 0x00 to 0x14 */
+	{
+		.pci_ops = &tx4939_pci_ops,
+		.io_resource = &pci_io_resource,
+		.mem_resource = &pci_mem_resource,
+	},
+	/* h/w only supports devices 0x00 to 0x14 */
+	{
+		.pci_ops = &tx4939_pci_ops,
+		.io_resource = &tx4939_pcic1_pci_io_resource,
+		.mem_resource = &tx4939_pcic1_pci_mem_resource,
+	},
+};
+
+
+struct tx4939_pcic_reg *pcicptrs[4] = {
+	tx4939_pcicptr(0),
+};
+
+/**
+ * set_tx4939_pcicptr - set pcicptr
+ * @ch: PCI controller channel
+ * @pcicptr: setting pointer
+ *
+ * This function sets pcicptr which use in pci_ops.c.
+ */
+
+void __init set_tx4939_pcicptr(int ch, struct tx4939_pcic_reg *pcicptr)
+{
+	pcicptrs[ch] = pcicptr;
+}
+
+/**
+ * get_tx4939_pcic_reg - get pcicptr
+ * @ch: PCI controller channel
+ *
+ * This function gets pcicptr which use in pci_ops.c.
+ */
+
+struct tx4939_pcic_reg *get_tx4939_pcicptr(int ch)
+{
+	return pcicptrs[ch];
+}
+
+#ifdef CONFIG_TC35815
+inline unsigned long tc_readl(volatile __u32 * addr)
+{
+	return readl(addr);
+}
+
+inline void tc_writel(unsigned long data, volatile __u32 * addr)
+{
+	writel(data, addr);
+}
+#endif
+
+
+/**
+ * tx4939_pcic_setup - sets up PCI controller
+ * @ch: PCIC channel
+ * @intarb:
+ *
+ * This functions sets up PCI controller.
+ */
+void __init tx4939_pcic_setup(unsigned ch, unsigned long pci_io_base,
+			      int intarb)
+{
+	int i;
+	u32 l;
+	u64 q;
+	struct tx4939_pcic_reg *r = tx4939_pcicptr(ch);
+	struct pci_controller *pcic = &tx4939_pci_controller[ch];
+
+	/* Disable All Initiator Space */
+	l = reg_rd32(&r->pciccfg);
+	reg_wr32(&r->pciccfg, l & ~(TX4939_PCICCFG_G2PM0EN |
+				    TX4939_PCICCFG_G2PM1EN |
+				    TX4939_PCICCFG_G2PM2EN |
+				    TX4939_PCICCFG_G2PIOEN));
+	/* GB->PCI IO mappings */
+	reg_wr32(&r->g2piomask,
+		 (pcic->io_resource->end - pcic->io_resource->start) >> 4);
+	reg_wr64s(&r->g2piogbase, pci_io_base |
+#if defined(__BIG_ENDIAN)
+		 TX4939_G2PIOGBASE_EXFER
+#else
+		 TX4939_G2PIOGBASE_BSWAP
+#endif
+		);
+	reg_wr64s(&r->g2piopbase, 0);
+
+	/* GB->PCI MEM mappings */
+	for (i = 0; i < 3; i++) {
+		reg_wr32(&r->g2pmmask[i], 0);
+		reg_wr64s(&r->g2pmgbase[i], 0);
+		reg_wr64s(&r->g2pmpbase[i], 0);
+	}
+	if (pcic->mem_resource->end) {
+		reg_wr32(&r->g2pmmask[0],
+			 (pcic->mem_resource->end - pcic->mem_resource->start) >> 4);
+		reg_wr64s(&r->g2pmgbase[0], pcic->mem_resource->start |
+#if defined(__BIG_ENDIAN)
+			 TX4939_G2PMGBASE_EXFER
+#else
+			 TX4939_G2PMGBASE_BSWAP
+#endif
+			);
+		reg_wr64s(&r->g2pmpbase[0], pcic->mem_resource->start);
+	}
+
+	/* PCI->GB IO mappings */
+	reg_wr32(&r->p2giopbase, 0);
+	reg_wr64s(&r->p2giogbase, 0 |
+#if defined(__BIG_ENDIAN)
+		  TX4939_P2GIOGBASE_EXFER
+#else
+		  TX4939_P2GIOGBASE_BSWAP
+#endif
+		);
+	/* PCI->GB MEM mappings */
+	l = reg_rd32(&r->p2gm0cfg);
+	reg_wr32(&r->p2gm0cfg, l & ~TX4939_P2GMCFG_MSS_MASK);
+	l = reg_rd32(&r->p2gm0cfg);
+	reg_wr32(&r->p2gm0cfg, l | TX4939_P2GMCFG_MSS_MB(tx4939_get_mem_size()));
+	reg_wr32(&r->p2gm0plbase, 0);
+	reg_wr32(&r->p2gm0pubase, 0);
+	reg_wr64s(&r->p2gmgbase[0], 0 | TX4939_P2GMGBASE_P2GMEN |
+#if defined(__BIG_ENDIAN)
+		  TX4939_P2GMGBASE_EXFER
+#else
+		  TX4939_P2GMGBASE_BSWAP
+#endif
+		);
+	reg_wr64s(&r->p2gmgbase[1], 0);
+	l = reg_rd32(&r->p2gm1cfg);
+	reg_wr32(&r->p2gm1cfg, l & ~TX4939_P2GMCFG_MSS_MASK);
+	l = reg_rd32(&r->p2gm1cfg);
+	reg_wr32(&r->p2gm1cfg, l | TX4939_P2GMCFG_MSS_MB(16));	/* 16MB */
+	reg_wr32(&r->p2gm1plbase, 0xffffffff);
+	reg_wr32(&r->p2gm1pubase, 0xffffffff);
+	reg_wr64s(&r->p2gmgbase[2], 0);
+	l = reg_rd32(&r->p2gm2cfg);
+	reg_wr32(&r->p2gm2cfg, l & ~TX4939_P2GMCFG_MSS_MASK);
+	l = reg_rd32(&r->p2gm2cfg);
+	reg_wr32(&r->p2gm2cfg, l | TX4939_P2GMCFG_MSS_MB(1));	/* 1MB */
+	reg_wr32(&r->p2gm2pbase, 0xffffffff);
+
+	l = reg_rd32(&r->pciccfg);
+	reg_wr32(&r->pciccfg,
+		 l & TX4939_PCICCFG_GBWC_SET(CONFIG_TOSHIBA_TX4939_PCI_GBWC));
+	/* Enable Initiator Memory Space */
+	if (pcic->mem_resource->end) {
+		l = reg_rd32(&r->pciccfg);
+		reg_wr32(&r->pciccfg, l | TX4939_PCICCFG_G2PM0EN);
+	}
+	/* Enable Initiator I/O Space */
+	if (pcic->io_resource->end) {
+		l = reg_rd32(&r->pciccfg);
+		reg_wr32(&r->pciccfg, l | TX4939_PCICCFG_G2PIOEN);
+	}
+	/* Enable Initiator Config */
+	l = reg_rd32(&r->pciccfg);
+	reg_wr32(&r->pciccfg,
+		 l | (TX4939_PCICCFG_ICAEN | TX4939_PCICCFG_TCAR));
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	reg_wr32(&r->pcicfg1, 0);
+	/* set RETRYTO=0, TRDYTO=0 */
+	reg_wr32(&r->g2ptocnt, (TX4939_G2PTOCNT_RETRYTO_SET(0)
+				| TX4939_G2PTOCNT_TRDYTO_SET(0)));
+	/* pdmac endian setting */
+	q = reg_rd64s(&r->pdmcfg);
+	reg_wr64s(&r->pdmcfg, q |
+#if defined(__BIG_ENDIAN)
+		  TX4939_PDMCFG_BSWAP
+#else
+		  TX4939_PDMCFG_EXFER
+#endif
+		);
+
+	/* Clear All Local Bus Status */
+	reg_wr32(&r->pcicstatus, TX4939_PCICSTATUS_ALL);
+	/* Enable All Local Bus Interrupts */
+	reg_wr32(&r->pcicmask, TX4939_PCICSTATUS_ALL);
+	/* Clear All Initiator Status */
+	reg_wr32(&r->g2pstatus, TX4939_G2PSTATUS_ALL);
+	/* Enable All Initiator Interrupts */
+	reg_wr32(&r->g2pmask, TX4939_G2PSTATUS_ALL);
+	/* Clear All PCI Status Error */
+	l = reg_rd32(&r->pcistatus);
+	reg_wr32(&r->pcistatus, (l & 0x0000ffff) | (TX4939_PCISTATUS_ALL << 16));
+	/* Enable All PCI Status Error Interrupts */
+	reg_wr32(&r->pcimask, TX4939_PCISTATUS_ALL);
+
+	if (intarb) {		/* case of built-in PCI bus arbiter */
+		/* Reset Bus Arbiter */
+		reg_wr32(&r->pbacfg, TX4939_PBACFG_RPBA);
+		reg_wr32(&r->pbabm, 0);
+		/* Enable Bus Arbiter */
+		reg_wr32(&r->pbacfg, TX4939_PBACFG_PBAEN);
+	}
+	/* set PCIC IRQ number */
+	l = reg_rd32(&r->pcicfg2);
+	reg_wr32(&r->pcicfg2,
+		 (l & ~TX4939_PCICFG2_IL_MASK) | (TX4939_IRQ_PCIC(ch) - TX4939_IRQ_IRC_BEG));
+
+	reg_wr32(&r->pcistatus, PCI_COMMAND_MASTER |
+		 PCI_COMMAND_MEMORY | PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+}
+
+static void tx4939_dump_pcic_settings(unsigned ch)
+{
+	int i;
+	u32 *preg = (u32 *) tx4939_pcicptr(ch);
+
+	printk(KERN_INFO "tx4939 pcic(%d) settings:", ch);
+
+	for (i = 0; i < sizeof(struct tx4939_pcic_reg); i += 4) {
+		if (i % 32 == 0)
+			printk(KERN_INFO "\n%04x:", i);
+		if (preg == &tx4939_pcicptr(ch)->g2pintack
+		    || preg == &tx4939_pcicptr(ch)->g2pspc) {
+			printk(KERN_INFO " XXXXXXXX");
+			preg++;
+			continue;
+		}
+		printk(KERN_INFO " %08lx", (unsigned long)*preg++);
+		if (preg == &tx4939_pcicptr(ch)->g2pcfgadrs)
+			break;
+	}
+	printk(KERN_INFO "\n");
+}
+
+struct tx4939_pcic_stat_tbl {
+	unsigned long flag;
+	const char *str;
+};
+
+static struct tx4939_pcic_stat_tbl pcistat_tbl[] = {
+	{ PCI_STATUS_DETECTED_PARITY,  "DetectedParityError"},
+	{ PCI_STATUS_SIG_SYSTEM_ERROR, "SignaledSystemError"},
+	{ PCI_STATUS_REC_MASTER_ABORT, "ReceivedMasterAbort"},
+	{ PCI_STATUS_REC_TARGET_ABORT, "ReceivedTargetAbort"},
+	{ PCI_STATUS_SIG_TARGET_ABORT, "SignaledTargetAbort"},
+	{ PCI_STATUS_PARITY,           "MasterParityError"  },};
+
+static struct tx4939_pcic_stat_tbl g2pstat_tbl[] = {
+	{ TX4939_G2PSTATUS_IDTTOE, "IDTIOE"},
+	{ TX4939_G2PSTATUS_IDRTOE, "IDRTOE"},};
+
+static struct tx4939_pcic_stat_tbl pcicstat_tbl[] = {
+	{ TX4939_PCICSTATUS_PME,  "PME" },
+	{ TX4939_PCICSTATUS_TLB,  "TLB" },
+	{ TX4939_PCICSTATUS_NIB,  "NIB" },
+	{ TX4939_PCICSTATUS_ZIB,  "ZIB" },
+	{ TX4939_PCICSTATUS_PERR, "PERR"},
+	{ TX4939_PCICSTATUS_SERR, "SERR"},
+	{ TX4939_PCICSTATUS_GBE,  "GBE" },
+	{ TX4939_PCICSTATUS_IWB,  "IWB" },};
+
+static inline void tx4939_report_pcic_status1(struct tx4939_pcic_reg *pcicptr)
+{
+	int i;
+	unsigned short pcistatus =
+		(unsigned short)(reg_rd32(&pcicptr->pcistatus) >> 16);
+	unsigned long g2pstatus = reg_rd32(&pcicptr->g2pstatus);
+	unsigned long pcicstatus = reg_rd32(&pcicptr->pcicstatus);
+
+	printk(KERN_INFO "pcistat:%04x(", pcistatus);
+	for (i = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
+		if (pcistatus & pcistat_tbl[i].flag)
+			printk(KERN_INFO "%s ", pcistat_tbl[i].str);
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	for (i = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
+		if (g2pstatus & g2pstat_tbl[i].flag)
+			printk("%s ", g2pstat_tbl[i].str);
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	for (i = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
+		if (pcicstatus & pcicstat_tbl[i].flag)
+			printk("%s ", pcicstat_tbl[i].str);
+	printk(")\n");
+}
+
+void tx4939_report_pcic_status(void)
+{
+	int i;
+	struct tx4939_pcic_reg *pcicptr;
+	for (i = 0; (pcicptr = get_tx4939_pcicptr(i)) != NULL; i++)
+		tx4939_report_pcic_status1(pcicptr);
+}
+
+/**
+ * tx4939_pcierr_interrupt - PCI error interrupt hendler
+ * @irq: irq number
+ * @dev_id:
+ * @regs:
+ *
+ */
+
+static irqreturn_t tx4939_pcierr_interrupt(int irq, void *dev_id,
+					   struct pt_regs *regs)
+{
+#if defined(CONFIG_IDE)
+	/* ignore MasterAbort for ide probing... */
+	u32 stat = reg_rd32(&tx4939_pcicptr(0)->pcistatus);
+	if (((stat >> 16) & 0xf900) ==  PCI_STATUS_REC_MASTER_ABORT) {
+		reg_wr32(&tx4939_pcicptr(0)->pcistatus,
+			 (stat & 0x0000ffff) | (PCI_STATUS_REC_MASTER_ABORT << 16));
+		goto done;
+	}
+#endif
+	printk(KERN_ERR "PCIERR interrupt (irq 0x%x) at 0x%08lx.\n", irq, regs->cp0_epc);
+	printk(KERN_ERR "ccfg:%Lx, tear:%Lx\n",
+	       reg_rd64s(&tx4939_ccfgptr->ccfg),
+	       reg_rd64s(&tx4939_ccfgptr->toea));
+	tx4939_report_pcic_status();
+	show_regs(regs);
+	tx4939_dump_pcic_settings(0);
+	tx4939_dump_pcic_settings(1);
+	panic("PCI error.");
+ done:
+	return IRQ_HANDLED;
+}
+
+static struct irqaction tx4939_pcic_action = {
+	.handler = tx4939_pcierr_interrupt,
+	.flags = SA_INTERRUPT,
+	.mask = CPU_MASK_NONE,
+	.name = "PCIC",
+};
+
+static struct irqaction tx4939_pcierr_action = {
+	.handler = tx4939_pcierr_interrupt,
+	.flags = SA_INTERRUPT,
+	.mask = CPU_MASK_NONE,
+	.name = "PCI error",
+};
+
+static struct irqaction tx4939_pcic1_action = {
+	.handler = tx4939_pcierr_interrupt,
+	.flags = SA_INTERRUPT,
+	.mask = CPU_MASK_NONE,
+	.name = "PCIC1(ether)",
+};
+
+void __init tx4939_pci_setup_irq(void)
+{
+	setup_irq(TX4939_IRQ_PCIC(0), &tx4939_pcic_action);
+	setup_irq(TX4939_IRQ_PCI0ERR, &tx4939_pcierr_action);
+	setup_irq(TX4939_IRQ_PCIC(1), &tx4939_pcic1_action);
+}
+
+static void tx4939_pcic_bootlog(void)
+{
+	int intarb =
+	    (reg_rd64s(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_PCIARB_BUILTIN);
+	int pci66 = (reg_rd64s(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_PCI66);
+
+	printk
+	    (KERN_INFO "TX4939 PCIC (Internal)-- DID:%04x VID:%04x RID:%02x Arbiter:%s (%2sMHz)\n",
+	     (unsigned short)(reg_rd32(&tx4939_pcicptr(0)->pciid) >> 16),
+	     (unsigned short)(reg_rd32(&tx4939_pcicptr(0)->pciid) & 0xffff),
+	     (unsigned short)(reg_rd32(&tx4939_pcicptr(0)->pciccrev) & 0xff),
+	     intarb ? "External" : "Internal", pci66 ? "66" : "33");
+	printk(KERN_INFO "TX4939 PCIC1(Ether)   -- DID:%04x VID:%04x RID:%02x\n",
+	       (unsigned short)(reg_rd32(&tx4939_pcicptr(1)->pciid) >> 16),
+	       (unsigned short)(reg_rd32(&tx4939_pcicptr(1)->pciid) & 0xffff),
+	       (unsigned short)(reg_rd32(&tx4939_pcicptr(1)->pciccrev) &
+				0xff));
+}
+
+/**
+ * tx4939_pci_setup - pci setup routine
+ *
+ * This function resets PCI controller using CCFG.CLKCTR pci reset
+ * bit, and sets tx4939_pci_controller and mips_io_port_base.
+ */
+static int __init tx4939_pcibios_init(void)
+{
+	u64 q;
+	int intarb =
+		(reg_rd64s(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_PCIARB_BUILTIN);
+
+	tx4939_pcic_bootlog();
+
+	/* Reset PCIC */
+	q = reg_rd64s(&tx4939_ccfgptr->clkctr);
+	reg_wr64s(&tx4939_ccfgptr->clkctr, q | (TX4939_CLKCTR_PCICRST |
+					       TX4939_CLKCTR_PCI1RST |
+						  TX4939_CLKCTR_EPCIRST));
+	wbflush();
+	udelay(1);		/* wait 128 cpu clock for CLKCTR (2.5ns x 128 = 320ns) */
+	/* clear PCIC reset */
+	q = reg_rd64s(&tx4939_ccfgptr->clkctr);
+	reg_wr64s(&tx4939_ccfgptr->clkctr, q & ~(TX4939_CLKCTR_PCICRST |
+						   TX4939_CLKCTR_PCI1RST |
+						   TX4939_CLKCTR_EPCIRST));
+	wbflush();
+	udelay(1);		/* wait 128 cpu clock for CLKCTR (2.5ns x 128 = 320ns) */
+
+#if 0 /* PCI Hard Reset */
+	{
+		u32 l;
+		l = reg_rd32(&tx4939_pcicptr(0)->pciccfg);
+		reg_wr32(&tx4939_pcicptr(0)->pciccfg, l | TX4939_PCICCFG_HRST);
+		l = reg_rd32(&tx4939_pcicptr(1)->pciccfg);
+		reg_wr32(&tx4939_pcicptr(1)->pciccfg, l | TX4939_PCICCFG_HRST);
+		wbflush();
+		mdelay(1);		/* wait 32 G-Bus clock cycles */
+	}
+#endif
+
+	/* setup PCI0 area */
+	tx4939_pci_controller[0].io_resource->start = ioport_resource.start;
+	tx4939_pci_controller[0].io_resource->end =
+		(ioport_resource.start + TX4939_PCI0_IO_RESOURCE_SIZE) - 1;
+
+	tx4939_pci_controller[0].mem_resource->start =
+		TX4939_PCI0_MEM_RESOURCE_START;
+	tx4939_pci_controller[0].mem_resource->end =
+		(TX4939_PCI0_MEM_RESOURCE_START + TX4939_PCI0_MEM_RESOURCE_SIZE) - 1;
+
+	tx4939_pci_controller[0].pci_ops = &tx4939_pci_ops;
+
+	set_tx4939_pcicptr(0, tx4939_pcicptr(0));
+
+	register_pci_controller(&tx4939_pci_controller[0]);
+
+	tx4939_pcic_setup(0, TX4939_PCI0_IO_RESOURCE_START, intarb);
+
+
+	/* setup PCI1(Ether) area */
+	tx4939_pci_controller[1].io_resource->start =
+		TX4939_PCI1_IO_RESOURCE_START - TX4939_PCI0_IO_RESOURCE_START;
+	tx4939_pci_controller[1].io_resource->end =
+		(TX4939_PCI1_IO_RESOURCE_START - TX4939_PCI0_IO_RESOURCE_START
+		 + TX4939_PCI1_IO_RESOURCE_SIZE) - 1;
+
+	tx4939_pci_controller[1].mem_resource->start =
+		TX4939_PCI1_MEM_RESOURCE_START;
+	tx4939_pci_controller[1].mem_resource->end =
+		(TX4939_PCI1_MEM_RESOURCE_START + TX4939_PCI1_MEM_RESOURCE_SIZE) - 1;
+
+	tx4939_pci_controller[1].pci_ops = &tx4939_pci_ops;
+
+	set_tx4939_pcicptr(1, tx4939_pcicptr(1));
+
+	register_pci_controller(&tx4939_pci_controller[1]);
+
+	tx4939_pcic_setup(1, TX4939_PCI1_IO_RESOURCE_START, 1);
+
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1 + TX4939_PCI0_IO_RESOURCE_START);
+
+	return 0;
+}
+
+arch_initcall(tx4939_pcibios_init);
Index: linux-2.6.10/arch/mips/tx4939/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/Kconfig
@@ -0,0 +1,95 @@
+comment "Multiplex Pin Select"
+
+
+choice
+	prompt "GPIO[04:09] ACLINK or I2S"
+	default TOSHIBA_TX4939_MPLEX_GPIO04_09
+config TOSHIBA_TX4939_MPLEX_GPIO04_09
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_ACLINK
+	bool "ACLINK"
+config TOSHIBA_TX4939_MPLEX_I2S
+	bool "I2S"
+endchoice
+
+
+choice
+	prompt "GPIO[10:11] I2C"
+	default TOSHIBA_TX4939_MPLEX_GPIO10_11
+config TOSHIBA_TX4939_MPLEX_GPIO10_11
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_I2C
+	bool "I2C"
+endchoice
+
+
+choice
+	prompt "GPIO[12:15] CTS/RTS or SIO2/3"
+	default TOSHIBA_TX4939_MPLEX_GPIO12_15
+config TOSHIBA_TX4939_MPLEX_GPIO12_15
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_SPI
+	bool "SPI"
+config TOSHIBA_TX4939_MPLEX_CTS_RTS
+	bool "CTS/RTS"
+config TOSHIBA_TX4939_MPLEX_SIO2
+	bool "SIO2"
+endchoice
+
+
+choice
+	prompt "G0PIO[00:29] ATA100-0"
+	default TOSHIBA_TX4939_MPLEX_ATA0
+config TOSHIBA_TX4939_MPLEX_G0PIO
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_ATA0
+	bool "ATA100-0"
+endchoice
+
+
+choice
+	prompt "G1PIO[00:29] ATA100-1 or Ether"
+	default TOSHIBA_TX4939_MPLEX_ETHER
+config TOSHIBA_TX4939_MPLEX_G1PIO
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_ATA1
+	bool "ATA100-1"
+config TOSHIBA_TX4939_MPLEX_ETHER
+	bool "ETHER"
+endchoice
+
+
+choice
+	prompt "G2PIO[00:16] Video port"
+	default TOSHIBA_TX4939_MPLEX_G2PIO
+config TOSHIBA_TX4939_MPLEX_G2PIO
+	bool "GPIO"
+config TOSHIBA_TX4939_MPLEX_PC_TRACE
+	bool "PC-Trace"
+config TOSHIBA_TX4939_MPLEX_1PARALLEL_PORT
+	bool "1-Parallel&GPIO"
+config TOSHIBA_TX4939_MPLEX_3SERIAL_PORT
+	bool "3-Serial&GPIO"
+config TOSHIBA_TX4939_MPLEX_1PARALLEL_1SERIAL
+	bool "1-Serial&1-Parallel"
+endchoice
+
+
+choice
+	prompt "PCICLK[1:4] Reset"
+	default TOSHIBA_TX4939_MPLEX_RESET
+config TOSHIBA_TX4939_MPLEX_RESET
+	bool "RESET"
+config TOSHIBA_TX4939_MPLEX_PCICLKON
+	bool "PCICLK"
+endchoice
+
+
+choice
+	prompt "CIR or SIO3"
+	default TOSHIBA_RBTX4939_PIN_CIR
+config TOSHIBA_RBTX4939_PIN_CIR
+	bool "CIR"
+config TOSHIBA_RBTX4939_PIN_SIO3
+	bool "SIO3"
+endchoice
Index: linux-2.6.10/arch/mips/tx4939/common/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for common code for Toshiba TX4939 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= prom.o setup.o irq.o irq_handler.o rtc.o puts.o \
+		spi_txx9.o tx49wtoe.o
+obj-$(CONFIG_BLK_DEV_IDE_TX4939) += ide.o
+obj-$(CONFIG_PROC_FS) += proc.o
Index: linux-2.6.10/arch/mips/tx4939/common/ide.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/ide.c
@@ -0,0 +1,68 @@
+/*
+ * arch/mips/tx4939/common/ide.c
+ *
+ * tx4939 ide setup routines
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/ide.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/tx4939/tx4939.h>
+
+/**
+ * tx4939_ide_init - initialize TX4939 IDE controller
+ *
+ * This function initiates TX4939 IDE controller.
+ */
+
+void __init tx4939_ide_setup(int ch)
+{
+	unsigned long status_base;
+	u16 s;
+	int i;
+
+	status_base = (TX4939_ATA_REG(ch) + TX4939_ATA_ALT_STATUS_OFFSET
+		       - mips_io_port_base);
+
+	/* Soft Reset */
+	s = reg_rd16(&tx4939_ataptr(ch)->sysctl1);
+	reg_wr16(&tx4939_ataptr(ch)->sysctl1, s | TX4939_ATA_SC_SOFT_RESET);
+	wbflush();
+	udelay(1);	/* wait for soft reset */
+
+	/* FIFO Reset */
+	s = reg_rd16(&tx4939_ataptr(ch)->sysctl1);
+	reg_wr16(&tx4939_ataptr(ch)->sysctl1, s | TX4939_ATA_SC_FIFO_RESET);
+	wbflush();
+	udelay(1);
+
+	/* ATA Hard Reset */
+	s = reg_rd16(&tx4939_ataptr(ch)->sysctl1);
+	reg_wr16(&tx4939_ataptr(ch)->sysctl1, s | TX4939_ATA_SC_ATA_HARD_RESET);
+	wbflush();
+	mdelay(3);	/* wait for device */
+
+	/* Wait for Status(BSY) to be cleared (Timeout: 60s=50us*1200000) */
+	for (i = 0; (inb(status_base) & BUSY_STAT) && i < 1200000; i++)
+		udelay(50);
+
+	/* Clear Interrupt status */
+	s = reg_rd16(&tx4939_ataptr(ch)->int_ctl);
+	reg_wr16(&tx4939_ataptr(ch)->int_ctl, s & TX4939_ATA_IC_TIMERINT);
+
+	/* Set Lower Burst Count Register */
+	reg_wr16(&tx4939_ataptr(ch)->lo_bcnt, 0x0008);
+	reg_wr16(&tx4939_ataptr(ch)->hi_bcnt, 0x0000);
+}
Index: linux-2.6.10/arch/mips/tx4939/common/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/irq.c
@@ -0,0 +1,365 @@
+/*
+ * arch/mps/tx4939/common/irq.c
+ *
+ * Common tx4939 irq handler
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/mipsregs.h>
+#include <asm/tx4939/tx4939.h>
+#include <asm/tx4939/rbtx4939.h>
+
+/**
+ * tx4939_irq_handler - TX4939 interrupt exception handler
+ * @regs: The stack pointer which store the registers during a system
+ * call/exception.
+ *
+ * This is TX4939 interrupt execption handler.
+ * This checks CP0.status register, and calls do_IRQ routine.
+ */
+
+extern asmlinkage void tx4939_irq_handler(void);
+
+/***************************************************
+ * Forward definitions for all pic's
+ ***************************************************/
+
+static unsigned int tx4939_irq_cp0_startup(unsigned int irq);
+static void tx4939_irq_cp0_shutdown(unsigned int irq);
+static void tx4939_irq_cp0_enable(unsigned int irq);
+static void tx4939_irq_cp0_disable(unsigned int irq);
+static void tx4939_irq_cp0_mask_and_ack(unsigned int irq);
+static void tx4939_irq_cp0_end(unsigned int irq);
+
+static unsigned int tx4939_irq_irc_startup(unsigned int irq);
+static void tx4939_irq_irc_shutdown(unsigned int irq);
+static void tx4939_irq_irc_enable(unsigned int irq);
+static void tx4939_irq_irc_disable(unsigned int irq);
+static void tx4939_irq_irc_mask_and_ack(unsigned int irq);
+static void tx4939_irq_irc_end(unsigned int irq);
+
+/***************************************************
+ * Kernel structs for all pic's
+ ***************************************************/
+
+static spinlock_t tx4939_cp0_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t tx4939_irc_lock = SPIN_LOCK_UNLOCKED;
+
+#define TX4939_CP0_NAME "TX4939-CP0"
+static struct hw_interrupt_type tx4939_irq_cp0_type = {
+	.typename = TX4939_CP0_NAME,
+	.startup = tx4939_irq_cp0_startup,
+	.shutdown = tx4939_irq_cp0_shutdown,
+	.enable = tx4939_irq_cp0_enable,
+	.disable = tx4939_irq_cp0_disable,
+	.ack = tx4939_irq_cp0_mask_and_ack,
+	.end = tx4939_irq_cp0_end,
+	.set_affinity = NULL
+};
+
+#define TX4939_IRC_NAME "TX4939-IRC"
+static struct hw_interrupt_type tx4939_irq_irc_type = {
+	.typename = TX4939_IRC_NAME,
+	.startup = tx4939_irq_irc_startup,
+	.shutdown = tx4939_irq_irc_shutdown,
+	.enable = tx4939_irq_irc_enable,
+	.disable = tx4939_irq_irc_disable,
+	.ack = tx4939_irq_irc_mask_and_ack,
+	.end = tx4939_irq_irc_end,
+	.set_affinity = NULL
+};
+
+static struct irqaction tx4939_irq_irc_action = {
+	.handler = no_action,
+	.name = TX4939_IRC_NAME
+};
+
+/***************************************************
+ * Functions for cp0
+ ***************************************************/
+
+#define tx4939_irq_cp0_mask(irq) ( 0x1 << ( (irq) - TX4939_IRQ_CP0_BEG + CAUSEB_IP) )
+
+/**
+ * tx4939_irq_cp0_init - Initialize TX49 core interrupt routine
+ *
+ * This function sets up TX4939 core interrupt routine irq_dest_t
+ * descriptor.
+ */
+static void __init tx4939_irq_cp0_init(void)
+{
+	int i;
+	for (i = TX4939_IRQ_CP0_BEG; i <= TX4939_IRQ_CP0_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx4939_irq_cp0_type;
+	}
+}
+
+static unsigned int tx4939_irq_cp0_startup(unsigned int irq)
+{
+	tx4939_irq_cp0_enable(irq);
+	return 0;
+}
+
+static void tx4939_irq_cp0_shutdown(unsigned int irq)
+{
+	tx4939_irq_cp0_disable(irq);
+}
+
+static void tx4939_irq_cp0_enable(unsigned int irq)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&tx4939_cp0_lock, flags);
+	set_c0_status(tx4939_irq_cp0_mask(irq));
+	spin_unlock_irqrestore(&tx4939_cp0_lock, flags);
+}
+
+static void tx4939_irq_cp0_disable(unsigned int irq)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&tx4939_cp0_lock, flags);
+	clear_c0_status(tx4939_irq_cp0_mask(irq));
+	spin_unlock_irqrestore(&tx4939_cp0_lock, flags);
+}
+
+static void tx4939_irq_cp0_mask_and_ack(unsigned int irq)
+{
+	tx4939_irq_cp0_disable(irq);
+}
+
+static void tx4939_irq_cp0_end(unsigned int irq)
+{
+	if (irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))
+		return;
+
+	tx4939_irq_cp0_enable(irq);
+}
+
+/***************************************************
+ * Functions for pic
+ ***************************************************/
+
+static void tx4939_irq_set_irc_lvl(unsigned int ic, unsigned int lvl)
+{
+	volatile u32 *irlvl;
+	unsigned int offset;
+
+	ic = (ic - 1 + ((ic & 0x20) >> 5)) & 0x3f;
+	irlvl = (volatile u32 *)(TX4939_IRC_REG + 0x20);
+
+	offset = ((ic & 0x1) << 3) + ((ic & 0x10));
+	irlvl += (ic & 0xe) + ((ic & 0x20) >> 1);
+
+	*irlvl &= ~(0x7 << offset);
+	*irlvl |= ((lvl & 0x7) << offset);
+
+	{			/* prevent spurious interrupt */
+		volatile u32 tmp;
+		__asm__ __volatile__("sync\n\t");
+		tmp = *irlvl;
+	}
+}
+
+/**
+ * tx4939_irq_irc_init - Initialize TX4939 IRC routine
+ *
+ * This function sets up TX4939 IRC irq_desc_t descriptoer. and sets
+ * up IRC to enable.
+ */
+
+static void __init tx4939_irq_irc_init(void)
+{
+	unsigned long flags;
+	int i;
+	u32 v;
+
+	for (i = TX4939_IRQ_IRC_BEG; i <= TX4939_IRQ_IRC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 2;
+		irq_desc[i].handler = &tx4939_irq_irc_type;
+	}
+
+	setup_irq(TX4939_IRQ_IRC_CP0, &tx4939_irq_irc_action);
+
+	spin_lock_irqsave(&tx4939_irc_lock, flags);
+	/* set compatible mode */
+	v = reg_rd32(&tx4939_ircptr->iscipb);
+	reg_wr32(&tx4939_ircptr->iscipb, v | TX4939_ISCIPB_CMM_COMPATIBLE);
+	/* irq level mask -- only accept hightest */
+	reg_wr32(&tx4939_ircptr->msk, TX4939_IRMSK_IML_LEVEL(0x6));
+	/* irq enable */
+	v = reg_rd32(&tx4939_ircptr->den);
+	reg_wr32(&tx4939_ircptr->den, v | TX4939_IRDEN_IDE_START);
+
+	spin_unlock_irqrestore(&tx4939_irc_lock, flags);
+}
+
+static unsigned int tx4939_irq_irc_startup(unsigned int irq)
+{
+	tx4939_irq_irc_enable(irq);
+	return 0;
+}
+
+static void tx4939_irq_irc_shutdown(unsigned int irq)
+{
+	tx4939_irq_irc_disable(irq);
+}
+
+static void tx4939_irq_irc_enable(unsigned int irq)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&tx4939_irc_lock, flags);
+	tx4939_irq_set_irc_lvl(irq - TX4939_IRQ_IRC_BEG, 0x7);
+	spin_unlock_irqrestore(&tx4939_irc_lock, flags);
+}
+
+static void tx4939_irq_irc_disable(unsigned int irq)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&tx4939_irc_lock, flags);
+	tx4939_irq_set_irc_lvl(irq - TX4939_IRQ_IRC_BEG, 0x0);
+	spin_unlock_irqrestore(&tx4939_irc_lock, flags);
+}
+
+static void tx4939_irq_irc_mask_and_ack(unsigned int irq)
+{
+	tx4939_irq_irc_disable(irq);
+}
+
+static void tx4939_irq_irc_end(unsigned int irq)
+{
+	if (irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))
+		return;
+
+	tx4939_irq_irc_enable(irq);
+}
+
+/***************************************************
+ * Main init functions
+ ***************************************************/
+
+/**
+ * tx4939_irq_nested - return irq number on TX4939 IRC
+ *
+ * This function give the irq number from IRCS.CAUSE register.
+ */
+
+int tx4939_irq_nested(void)
+{
+	int irq, ircs;
+
+	ircs = reg_rd32(&tx4939_ircptr->cs);
+
+	if (ircs & TX4939_IRCS_IF_MASK)
+		return 0;
+
+	irq = (ircs & TX4939_IRCS_CAUSE_MASK) + TX4939_IRQ_IRC_BEG;
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	if (irq == RBTX4939_IRQ_IOC)
+		irq = rbtx4939_irq_nested();
+#endif
+	return irq;
+}
+
+/**
+ * tx4939_irq_init - tx4939 interrupt setup routine
+ *
+ * This function runs tx4939_irq_cp0_init and tx4939_irq_irc_init
+ * routines. And sets a vector for tx4939 interrupt exception.
+ */
+
+static void __init tx4939_irq_init(void)
+{
+	tx4939_irq_cp0_init();
+	tx4939_irq_irc_init();
+	set_except_vector(0, tx4939_irq_handler);
+}
+
+void tx4939_irc_set_irdn(unsigned int ic, u32 isc)
+{
+	volatile u32 *irdn;
+	unsigned int offset;
+
+	ic--;
+	irdn = (volatile u32 *)TX4939_IRC_REG + 0x10;
+	offset = (ic & 0x7) << 1;
+
+	if (ic & 0x8)
+		irdn += 0x8;
+
+	if (ic & 0x10)
+		offset += 0x10;
+
+	if (ic & 0x20)
+		irdn += 0xb8;
+
+	*irdn &= ~(0x3 << offset);
+	*irdn |= (isc & 0x3) << offset;
+}
+
+/**
+ * arch_init_IRQ - Initialize IRQ routines.
+ *
+ * This function initiate IRQ routines.
+ */
+
+void __init arch_init_irq(void)
+{
+	local_irq_disable();
+
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	tx4939_irq_init();
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	rbtx4939_irq_init();
+#endif
+
+#if defined(CONFIG_TX4939_SPI)
+	txx9_spi_irqinit(RBTX4939_IRQ_IRC_SPI);
+#endif
+
+#if defined(CONFIG_PCI)
+	tx4939_pci_setup_irq();
+#endif
+	wbflush();
+}
+
+/**
+ * mips_spurious_interrupt - cannot specify the interruption cause
+ *
+ * This function calls interruption which cannot specify the
+ * interruption cause. (Usually not use)
+ */
+
+void mips_spurious_interrupt(struct pt_regs *regs)
+{
+	unsigned long status, cause;
+	printk(KERN_WARNING "got spurious interrupt\n");
+	status = read_c0_status();
+	cause = read_c0_cause();
+	printk(KERN_WARNING "interrupt current status register %x\n",
+	       reg_rd32(&tx4939_ircptr->cs));
+	printk(KERN_WARNING "interrupt pending0 register %x\n",
+	       reg_rd32(&tx4939_ircptr->pnd0));
+	printk(KERN_WARNING "interrupt pending1 register %x\n",
+	       reg_rd32(&tx4939_ircptr->pnd1));
+	printk(KERN_WARNING "status %lx cause %lx\n", status, cause);
+	printk(KERN_WARNING "epc %lx badvaddr %lx \n", regs->cp0_epc, regs->cp0_badvaddr);
+}
Index: linux-2.6.10/arch/mips/tx4939/common/irq_handler.S
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/irq_handler.S
@@ -0,0 +1,95 @@
+/*
+ * arch/mips/tx4939/common/irq_handler.S
+ *
+ * Primary interrupt handler for tx4939 based systems
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/tx4939/rbtx4939.h>
+
+
+		.align	5
+		NESTED(tx4939_irq_handler, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+
+		mfc0	t0, CP0_CAUSE
+		mfc0	t1, CP0_STATUS
+		and	t0, t1
+
+		andi	t1, t0, STATUSF_IP7	/* cpu timer */
+		bnez	t1, ll_ip7
+
+		/* IP6..IP3 multiplexed -- do not use */
+
+		andi	t1, t0, STATUSF_IP2	/* tx4939 pic */
+		bnez	t1, ll_ip2
+
+		andi	t1, t0, STATUSF_IP1	/* user line 1 */
+		bnez	t1, ll_ip1
+
+		andi	t1, t0, STATUSF_IP0	/* user line 0 */
+		bnez	t1, ll_ip0
+
+		.set	reorder
+
+		/* wrong alarm or masked ... */
+		b       goto_spurious_interrupt
+		nop
+
+		END(tx4939_irq_handler)
+
+		.align	5
+
+
+ll_ip7:
+		li	a0, TX4939_IRQ_CPU_TIMER
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+
+ll_ip2:
+		jal	tx4939_irq_nested
+		nop
+		beqz 	v0, goto_spurious_interrupt
+		nop
+		move	a0, v0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+goto_spurious_interrupt:
+		move	a0, sp
+		jal	mips_spurious_interrupt
+		j       spurious_interrupt
+		nop
+
+ll_ip1:
+		li	a0, TX4939_IRQ_USER1
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+ll_ip0:
+		li	a0, TX4939_IRQ_USER0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
Index: linux-2.6.10/arch/mips/tx4939/common/proc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/proc.c
@@ -0,0 +1,952 @@
+/*
+ * arch/mips/tx4939/common/proc.c
+ *
+ * Setup proc-fs for tx4939
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2005
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>	/* Definitions needed for kernel modules */
+#include <linux/kmod.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* We run in the kernel so we need this */
+#include <linux/proc_fs.h>	/* The /proc definitions are in this one */
+
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/tx4939/tx4939.h>
+
+
+struct proc_dir_entry *tx4939_proc_entry;
+
+static int
+tx4939_proc_show_cp0(char *sysbuf, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "INDEX   :0x%08x\n", read_c0_index());
+	len += sprintf(sysbuf + len, "ENTRYLO0:0x%08lx\n", read_c0_entrylo0());
+	len += sprintf(sysbuf + len, "ENTRYLO1:0x%08lx\n", read_c0_entrylo1());
+	len += sprintf(sysbuf + len, "CONTEXT :0x%08lx\n", read_c0_context());
+	len += sprintf(sysbuf + len, "PAGEMASK:0x%08x\n", read_c0_pagemask());
+	len += sprintf(sysbuf + len, "WIRED   :0x%08x\n", read_c0_wired());
+	len += sprintf(sysbuf + len, "COUNT   :0x%08x\n", read_c0_count());
+	len += sprintf(sysbuf + len, "ENTRYHI :0x%08lx\n", read_c0_entryhi());
+	len += sprintf(sysbuf + len, "COMPARE :0x%08x\n", read_c0_compare());
+	len += sprintf(sysbuf + len, "STATUS  :0x%08x\n", read_c0_status());
+	len += sprintf(sysbuf + len, "CAUSE   :0x%08x\n", read_c0_cause());
+	len += sprintf(sysbuf + len, "PRId    :0x%08x\n", read_c0_prid());
+	len += sprintf(sysbuf + len, "CONFIG  :0x%08x\n", read_c0_config());
+	len += sprintf(sysbuf + len, "XCONTEXT:0x%08lx\n", read_c0_xcontext());
+	len += sprintf(sysbuf + len, "TagLo   :0x%08x\n", read_c0_taglo());
+	len += sprintf(sysbuf + len, "TagHi   :0x%08x\n", read_c0_taghi());
+	len += sprintf(sysbuf + len, "ErrorEPC:0x%08lx\n", read_c0_errorepc());
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_mips_io_port_base(char *sysbuf, char **start, off_t off,
+				   int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "mips_io_port_base = 0x%08lx\n",
+		       mips_io_port_base);
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_ccfg(char *sysbuf, char **start, off_t off,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_ccfg *****\n");
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->ccfg        : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->ccfg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->revid       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->revid));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->pcfg        : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->pcfg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->toea        : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->toea));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->clkctr      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->clkctr));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->garbc       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->garbc));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->ramp        : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->ramp));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->dskwctrl    : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->dskwctrl));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->mclkosc     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->mclkosc));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->mclkctl     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->mclkctl));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->gpiomr1     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->gpio[0].mr));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->gpiodr1     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->gpio[0].dr));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->gpiomr2     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->gpio[1].mr));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ccfgptr  ->gpiodr2     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ccfgptr->gpio[1].dr));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_ddrc(char *sysbuf, char **start, off_t off,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_ddrc *****\n");
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ddrcptr  ->drwinen     : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ddrcptr->drwinen));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ddrcptr  ->drwin[0]    : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ddrcptr->drwin[0]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ddrcptr  ->drwin[1]    : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ddrcptr->drwin[1]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ddrcptr  ->drwin[2]    : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ddrcptr->drwin[2]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ddrcptr  ->drwin[3]    : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_ddrcptr->drwin[3]));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_ebusc(char *sysbuf, char **start, off_t off,
+		       int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_ebusc *****\n");
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ebuscptr ->cr[0]       : 0x%016Lx\n",
+		    reg_rd64(&tx4939_ebuscptr->cr[0]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ebuscptr ->cr[1]       : 0x%016Lx\n",
+		    reg_rd64(&tx4939_ebuscptr->cr[1]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ebuscptr ->cr[2]       : 0x%016Lx\n",
+		    reg_rd64(&tx4939_ebuscptr->cr[2]));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ebuscptr ->cr[3]       : 0x%016Lx\n",
+		    reg_rd64(&tx4939_ebuscptr->cr[3]));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_pcic(char *sysbuf, char **start, off_t off,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_pcic *****\n");
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pciid       : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pciid));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcistatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcistatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pciccrev    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pciccrev));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcicfg1     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcicfg1));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm0plbase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm0plbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm0pubase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm0pubase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm1plbase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm1plbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm1pubase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm1pubase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm2pbase  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm2pbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2giopbase  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2giopbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcisid      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcisid));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcicapptr   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcicapptr));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcicfg2     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcicfg2));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2ptocnt    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2ptocnt));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pstatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcisstatus  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcisstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcimask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcimask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gcfg      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gcfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gstatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gmask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gccmd     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gccmd));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbareqport  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbareqport));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbacfg      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbacfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbastatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbastatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbamask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbamask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbabm       : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbabm));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbacreq     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbacreq));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbacgnt     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbacgnt));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pbacstate   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pbacstate));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmgbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmgbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmgbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmgbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmgbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmgbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2piogbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2piogbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmmask[0] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pmmask[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmmask[1] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pmmask[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmmask[2] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pmmask[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2piomask   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2piomask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmpbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmpbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmpbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmpbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pmpbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2pmpbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2piopbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->g2piopbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pciccfg     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pciccfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcicstatus  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcicstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pcicmask    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->pcicmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gmgbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->p2gmgbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gmgbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->p2gmgbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gmgbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->p2gmgbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2giogbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->p2giogbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->g2pcfgadrs  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->g2pcfgadrs));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm0cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm0cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm1cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm1cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->p2gm2cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(0)->p2gm2cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmca       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmca));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmga       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmga));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmpa       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmpa));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmctr      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmctr));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmcfg      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmcfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(0)  ->pdmsts      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(0)->pdmsts));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_pcic1(char *sysbuf, char **start, off_t off,
+		       int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_pcic *****\n");
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pciid       : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pciid));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcistatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcistatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pciccrev    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pciccrev));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcicfg1     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcicfg1));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm0plbase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm0plbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm0pubase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm0pubase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm1plbase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm1plbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm1pubase : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm1pubase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm2pbase  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm2pbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2giopbase  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2giopbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcisid      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcisid));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcicapptr   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcicapptr));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcicfg2     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcicfg2));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2ptocnt    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2ptocnt));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pstatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcisstatus  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcisstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcimask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcimask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gcfg      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gcfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gstatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gmask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gccmd     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gccmd));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbareqport  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbareqport));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbacfg      : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbacfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbastatus   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbastatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbamask     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbamask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbabm       : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbabm));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbacreq     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbacreq));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbacgnt     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbacgnt));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pbacstate   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pbacstate));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmgbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmgbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmgbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmgbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmgbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmgbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2piogbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2piogbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmmask[0] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pmmask[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmmask[1] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pmmask[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmmask[2] : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pmmask[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2piomask   : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2piomask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmpbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmpbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmpbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmpbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pmpbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2pmpbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2piopbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->g2piopbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pciccfg     : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pciccfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcicstatus  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcicstatus));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pcicmask    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->pcicmask));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gmgbase[0]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->p2gmgbase[0]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gmgbase[1]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->p2gmgbase[1]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gmgbase[2]: 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->p2gmgbase[2]));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2giogbase  : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->p2giogbase));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->g2pcfgadrs  : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->g2pcfgadrs));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm0cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm0cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm1cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm1cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->p2gm2cfg    : 0x%08x\n",
+		    reg_rd32(&tx4939_pcicptr(1)->p2gm2cfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmca       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmca));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmga       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmga));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmpa       : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmpa));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmctr      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmctr));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmcfg      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmcfg));
+	len +=
+	    sprintf(sysbuf + len,
+		    "tx4939_pcicptr(1)  ->pdmsts      : 0x%016Lx\n",
+		    reg_rd64s(&tx4939_pcicptr(1)->pdmsts));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_irc(char *sysbuf, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "***** tx4939_irc *****\n");
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->den         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->den));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->iscipb      : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->iscipb));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dm0         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dm0));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dm1         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dm1));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[0]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[0].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[1]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[1].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[2]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[2].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[3]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[3].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[4]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[4].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[5]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[5].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[6]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[6].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[7]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[7].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[8]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[8].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[9]    : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[9].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[10]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[10].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[11]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[11].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[12]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[12].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[13]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[13].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[14]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[14].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->irlvl[15]   : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->irlvl[15].reg));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->msk         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->msk));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->edc         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->edc));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->pnd0        : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->pnd0));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->cs          : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->cs));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->pnd1        : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->pnd1));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dm2         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dm2));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dm3         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dm3));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dbr0        : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dbr0));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dbr1        : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dbr1));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->dben        : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->dben));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->flag0       : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->flag0));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->flag1       : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->flag1));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->pol         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->pol));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->cnt         : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->cnt));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->maskint     : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->maskint));
+	len +=
+	    sprintf(sysbuf + len, "tx4939_ircptr   ->maskext     : 0x%08x\n",
+		    reg_rd32(&tx4939_ircptr->maskext));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_ide0(char *sysbuf, char **start, off_t off,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->sysctl1    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->sysctl1));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->sysctl2    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->sysctl2));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->xfer_cnt1  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->xfer_cnt1));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->xfer_cnt2  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->xfer_cnt2));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->sec_cnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->sec_cnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->strt_addl  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->strt_addl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->strt_addu  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->strt_addu));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->add_ctrl   : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->add_ctrl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->hi_bcnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->hi_bcnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->lo_bcnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->lo_bcnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->pio_acc    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->pio_acc));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->h_rst_tim  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->h_rst_tim));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->int_ctl    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->int_ctl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->dma_cmd    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->dma_cmd));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(0) ->dma_stat   : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(0)->dma_stat));
+	*eof = 1;
+	return len;
+}
+
+static int
+tx4939_proc_show_ide1(char *sysbuf, char **start, off_t off,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->sysctl1    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->sysctl1));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->sysctl2    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->sysctl2));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->xfer_cnt1  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->xfer_cnt1));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->xfer_cnt2  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->xfer_cnt2));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->sec_cnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->sec_cnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->strt_addl  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->strt_addl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->strt_addu  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->strt_addu));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->add_ctrl   : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->add_ctrl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->hi_bcnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->hi_bcnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->lo_bcnt    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->lo_bcnt));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->pio_acc    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->pio_acc));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->h_rst_tim  : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->h_rst_tim));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->int_ctl    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->int_ctl));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->dma_cmd    : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->dma_cmd));
+	len += sprintf(sysbuf + len, "tx4939_ataptr(1) ->dma_stat   : 0x%04x\n",
+		       reg_rd16(&tx4939_ataptr(1)->dma_stat));
+	*eof = 1;
+	return len;
+}
+
+/**
+ * tx4939_proc_setup - setup proc interface for TX4939 registers
+ *
+ * This function makes proc entry to show TX4939 registers, like as
+ * "tx4939", "cp0", "mips_io_port_base", "ccfg".
+ */
+
+static int __init tx4939_proc_setup(void)
+{
+	struct proc_dir_entry *entry;
+
+	if (tx4939_proc_entry == NULL)
+		tx4939_proc_entry = proc_mkdir("tx4939", NULL);
+
+	if (!tx4939_proc_entry) {
+		printk(KERN_ERR "tx4939 cannot be registered in /proc\n");
+		return -1;
+	}
+
+	entry = create_proc_entry("cp0", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_cp0;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("mips_io_port_base", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_mips_io_port_base;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("ccfg", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_ccfg;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("ebusc", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_ebusc;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("ddrc", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_ddrc;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("pcic", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_pcic;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("pcic1", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_pcic1;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("irc", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_irc;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("ide0", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_ide0;
+		entry->data = 0;
+	}
+
+	entry = create_proc_entry("ide1", 0, tx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = tx4939_proc_show_ide1;
+		entry->data = 0;
+	}
+
+	return 0;
+}
+
+static int __init tx4939_proc_init(void)
+{
+	return tx4939_proc_setup();
+}
+
+static void __exit tx4939_proc_exit(void)
+{
+	/* need to do something */
+}
+
+module_init(tx4939_proc_init);
+module_exit(tx4939_proc_exit);
+
+MODULE_DESCRIPTION("tx4939 proc interface");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(tx4939_proc_entry);
Index: linux-2.6.10/arch/mips/tx4939/common/prom.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/prom.c
@@ -0,0 +1,144 @@
+/*
+ * arch/mips/tx4939/common/prom.c
+ *
+ * common tx4939 memory interface
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4939/tx4939.h>
+
+#ifndef COMMAND_LINE_SIZE
+#define COMMAND_LINE_SIZE CL_SIZE
+#endif
+
+extern void sio_setup(void);
+extern void fputs(unsigned char *cp);
+
+static int *_prom_envp;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension, if running in 64-bit mode.
+ */
+#define prom_envp(index) ((char *)(((int *)(int)_prom_envp)[(index)]))
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * In 64-bit mode: we're using 64-bit pointers, but all pointers
+	 * in the PROM structures are only 32-bit, so we need some
+	 * workarounds, if we are running in 64-bit mode.
+	 */
+	int i, index = 0;
+
+	i = strlen(envname);
+
+	while (prom_envp(index)) {
+		if (strncmp(envname, prom_envp(index), i) == 0)
+			if (strlen(prom_envp(index)) == i)
+				return (prom_envp(index + 1));
+		index += 2;
+	}
+
+	return NULL;
+}
+
+void __init prom_init_cmdline(void)
+{
+	int argc = (int)fw_arg0;
+	char **argv = (char **)fw_arg1;
+	int i;			/* Always ignore the "-c" at argv[0] */
+
+	/* ignore all built-in args if any f/w args given */
+	if (argc > 1)
+		*arcs_cmdline = '\0';
+
+	for (i = 1; i < argc; i++) {
+		if (i != 1)
+			strcat(arcs_cmdline, " ");
+		strcat(arcs_cmdline, argv[i]);
+	}
+}
+
+/**
+ * tx4939_get_mem_size - get memory size on tx4939 board
+ *
+ * This function gives memory size which can use by kernel.
+ * This size defines in include/asm-mips/tx4939/config.h
+ */
+
+unsigned int __init tx4939_get_mem_size(void)
+{
+	unsigned int total;
+
+	total = CONFIG_TOSHIBA_TX4939_MEMSIZE;
+
+	return total;
+}
+
+/**
+ * prom_init - the initialize routine related to PROM
+ * @argc: The count of arguments
+ * @argv: The pointer list of arguments
+ * @envp: The pointer list of pmon environment value
+ * *pvec: The pointer list of pmon vector
+ *
+ * This function sets mipsmarchgroup/type. and sets memory region
+ */
+
+void __init prom_init(void)
+{
+	int msize;
+
+#ifndef CONFIG_TX4939_NAND_BOOT
+	prom_init_cmdline();
+#endif
+	mips_machgroup = MACH_GROUP_TOSHIBA;
+	mips_machtype = MACH_TOSHIBA_RBTX4939;
+
+	sio_setup();
+	fputs("\nLINUX started...\r\n");
+
+	msize = tx4939_get_mem_size();
+	add_memory_region(0, msize << 20, BOOT_MEM_RAM);
+}
+
+void __init prom_free_prom_memory(void)
+{
+	return;
+}
+
+void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
+{
+	return;
+}
+
+const char *get_system_type(void)
+{
+	return "Toshiba RBTX4939";
+}
+
+char *__init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
Index: linux-2.6.10/arch/mips/tx4939/common/puts.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/puts.c
@@ -0,0 +1,169 @@
+/*
+ * arch/mips/tx4939/common/puts.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Low level uart routines to directly access a 16550 uart.
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/types.h>
+#include <asm/tx4939/tx4939.h>
+
+#define SERIAL_BASE   TX4939_SIO_REG(0)
+#define SER_CMD       0x7
+#define SER_DATA      0x1
+#define TX_BUSY       0x20
+
+#define TIMEOUT       0xffffff
+#define SLOW_DOWN
+
+static const char digits[16] = "0123456789abcdef";
+static volatile unsigned long *const com1 = (unsigned long *)SERIAL_BASE;
+
+#if defined(SLOW_DOWN)
+static inline void slow_down(void)
+{
+	int k;
+	for (k = 0; k < 10000; k++) ;
+}
+#else
+#define slow_down()
+#endif
+
+#define TXX9_SILCR	0x00
+#define TXX9_SIDICR	0x04
+#define TXX9_SIDISR	0x08
+#define TXX9_SICISR	0x0c
+#define TXX9_SIFCR	0x10
+#define TXX9_SIFLCR	0x14
+#define TXX9_SIBGR	0x18
+#define TXX9_SITFIFO	0x1c
+#define TXX9_SIRFIFO	0x20
+
+/* SICISR : Change Int. Status */
+#define TXX9_SICISR_OERS	0x00000020
+#define TXX9_SICISR_CTSS	0x00000010
+#define TXX9_SICISR_RBRKD	0x00000008
+#define TXX9_SICISR_TRDY	0x00000004
+#define TXX9_SICISR_TXALS	0x00000002
+#define TXX9_SICISR_UBRKD	0x00000001
+
+/* SIFLCR : Flow Control */
+#define TXX9_SIFLCR_RTSTL_MAX	0x0000001e
+
+static unsigned int sio_in(unsigned long base, int offset)
+{
+	return (*(volatile unsigned long *)(base + offset));
+}
+
+static void sio_out(unsigned long base, int offset, unsigned int value)
+{
+	(*(volatile unsigned long *)(base + offset)) = (value);
+}
+
+static void putch(const unsigned char c)
+{
+	unsigned int status;
+	int i = 0;
+
+	do {
+		status = sio_in(SERIAL_BASE, TXX9_SICISR);
+		slow_down();
+		i++;
+		if (i > TIMEOUT) {
+			break;
+		}
+	} while (0 == (status & TXX9_SICISR_TRDY));
+	sio_out(SERIAL_BASE, TXX9_SITFIFO, (u32) c);
+	if (c == '\n') {
+		sio_out(SERIAL_BASE, TXX9_SITFIFO, (u32) '\n');
+		sio_out(SERIAL_BASE, TXX9_SITFIFO, (u32) '\r');
+	}
+
+}
+
+static void puts(unsigned char *cp)
+{
+	unsigned int status;
+	int i = 0;
+
+	while (*cp) {
+		do {
+			status = sio_in(SERIAL_BASE, TXX9_SICISR);
+			slow_down();
+			i++;
+			if (i > TIMEOUT) {
+				break;
+			}
+		} while (0 == (status & TXX9_SICISR_TRDY));
+		sio_out(SERIAL_BASE, TXX9_SITFIFO, (u32) * cp++);
+	}
+	putch('\r');
+	putch('\n');
+}
+
+void fputs(unsigned char *cp)
+{
+	unsigned int status;
+	int i = 0;
+
+	while (*cp) {
+
+		do {
+			status = sio_in(SERIAL_BASE, TXX9_SICISR);
+			slow_down();
+			i++;
+			if (i > TIMEOUT) {
+				break;
+			}
+		} while (0 == (status & TXX9_SICISR_TRDY));
+		sio_out(SERIAL_BASE, TXX9_SITFIFO, (u32) * cp++);
+	}
+}
+
+static void put64(uint64_t ul)
+{
+	int cnt;
+	unsigned ch;
+
+	cnt = 16;		/* 16 nibbles in a 64 bit long */
+	putch('0');
+	putch('x');
+	do {
+		cnt--;
+		ch = (unsigned char)(ul >> cnt * 4) & 0x0F;
+		putch(digits[ch]);
+	} while (cnt > 0);
+}
+
+static void put32(unsigned u)
+{
+	int cnt;
+	unsigned ch;
+
+	cnt = 8;		/* 8 nibbles in a 32 bit long */
+	putch('0');
+	putch('x');
+	do {
+		cnt--;
+		ch = (unsigned char)(u >> cnt * 4) & 0x0F;
+		putch(digits[ch]);
+	} while (cnt > 0);
+}
+
+void sio_setup(void)
+{
+	/* Enable RX/TX */
+	/* console port should not use RTC/CTS. */
+	sio_out(SERIAL_BASE, TXX9_SIFLCR, TXX9_SIFLCR_RTSTL_MAX);
+}
Index: linux-2.6.10/arch/mips/tx4939/common/rtc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/rtc.c
@@ -0,0 +1,97 @@
+/*
+ * arch/mips/tx4939/common/rtc.c
+ *
+ * RTC routines for TX4939.
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include <asm/time.h>
+#include <asm/tx4939/tx4939.h>
+
+static void write_rtc_time(u64 data)
+{
+	int i;
+	u32 l;
+
+	/* Write to RWB. */
+	reg_wr32(&tx4939_rtcptr->adr, 0);
+	for (i = 0; i < 6; i++) {
+		reg_wr32(&tx4939_rtcptr->dat, (u8) data);
+		data >>= 8;
+	}
+
+	/* RWB -> RTC. */
+	l = reg_rd32(&tx4939_rtcptr->ctl);
+	reg_wr32(&tx4939_rtcptr->ctl, l & TX4939_RTCCTL_CMD_CLEAR);
+	l = reg_rd32(&tx4939_rtcptr->ctl);
+	reg_wr32(&tx4939_rtcptr->ctl, l | TX4939_RTCCTL_CMD_SETTIME);
+
+	/* Wait for completion. */
+	while (reg_rd32(&tx4939_rtcptr->ctl) & TX4939_RTCCTL_BUSY) ;
+}
+
+static u64 read_rtc_time(void)
+{
+	int i;
+	u32 l;
+
+	u64 data = 0;
+
+	/* RWB <- RTC. */
+	l = reg_rd32(&tx4939_rtcptr->ctl);
+	reg_wr32(&tx4939_rtcptr->ctl, l & TX4939_RTCCTL_CMD_CLEAR);
+	l = reg_rd32(&tx4939_rtcptr->ctl);
+	reg_wr32(&tx4939_rtcptr->ctl, l | TX4939_RTCCTL_CMD_GETTIME);
+
+	/* Wait for completion. */
+	while (reg_rd32(&tx4939_rtcptr->ctl) & TX4939_RTCCTL_BUSY) ;
+
+	/* Read from RWB. */
+	for (i = 0; i < 6; i++)
+		data |= (u64) (reg_rd32(&tx4939_rtcptr->dat)) << (8 * i);
+
+	return data;
+}
+
+/**
+ * tx4939_rtc_set_time - set time to TX4939 rtc
+ * @t: set time
+ */
+
+static int tx4939_rtc_set_time(unsigned long t)
+{
+	write_rtc_time((u64) t << 16);
+	return 0;
+}
+
+/**
+ * tx4939_rtc_get_time - get time from TX4939 rtc
+ */
+
+static unsigned long tx4939_rtc_get_time(void)
+{
+	return (read_rtc_time() >> 16);
+}
+
+/**
+ * tx4939_rtc_init - set the rtc function pointers
+ */
+
+void __init tx4939_rtc_init(void)
+{
+	rtc_get_time = tx4939_rtc_get_time;
+	rtc_set_time = tx4939_rtc_set_time;
+}
Index: linux-2.6.10/arch/mips/tx4939/common/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/setup.c
@@ -0,0 +1,541 @@
+/*
+ * arch/mips/tx4939/common/setup.c
+ *
+ * common tx4939 setup routines
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include <asm/types.h>
+#include <asm/tx4939/tx4939.h>
+#ifdef CONFIG_IDE
+#include <linux/ide.h>
+#endif
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
+
+void (*__wbflush) (void);
+
+extern void fputs(unsigned char *cp);
+extern void rbtx4939_heartbeat(void);
+extern void rbtx4939_machine_restart(char *command);
+extern void __init tx4939_pcibios_init(void);
+extern void __init tx4939_ide_setup(int ch);
+extern void __init rbtx4939_setup(void);
+extern void __init tx4939_rtc_init(void);
+extern char *__init prom_getcmdline(void);
+extern int early_serial_txx9_setup(struct uart_port *port);
+
+/* clocks */
+unsigned int txx9_cpu_clock;
+unsigned int txx9_gbus_clock;
+unsigned int txx9_sys_clock;
+
+/**
+ * tx4939_write_buffer_flush - __wbflush function
+ *
+ * This function runs sync command to flush TX49 core write buffer.
+ */
+
+static void tx4939_write_buffer_flush(void)
+{
+	__asm__ __volatile__(".set	push\n\t"
+			     ".set	noreorder\n\t"
+			     ".set	mips2\n\t"
+			     "sync\n\t"
+			     ".set	pop"
+			     :	/* no output */
+			     :	/* no input */
+			     :"memory");
+
+	__asm__ __volatile__(".set	push\n\t"
+			     ".set	noreorder\n\t"
+			     "lw	$0,%0\n\t"
+			     "nop\n\t"
+			     ".set	pop"
+			     :	/* no output */
+			     :"m"(*(int *)KSEG1)
+			     :"memory");
+}
+
+/**
+ * tx4939_machine_halt - system halt
+ *
+ * This function calls asm_wait function instead of power-off.
+ */
+
+static void tx4939_machine_halt(void)
+{
+	printk(KERN_NOTICE "System Halted\n");
+	local_irq_disable();
+	while (1)
+		asm_wait();
+	/* no return */
+}
+
+/**
+ * tx4939_machine_power_off - system power off
+ *
+ * This function calls _machine_halt function.
+ */
+
+static void tx4939_machine_power_off(void)
+{
+	tx4939_machine_halt();
+	/* no return */
+}
+
+/**
+ * tx4939_machine_restart - system reset
+ * @command: unknown (not use)
+ *
+ * This function sets ISORST bit of TX4939.CCFG.CLTCTL
+ */
+
+static void tx4939_machine_restart(char *command)
+{
+	u64 q;
+	local_irq_disable();
+	printk(KERN_INFO "Rebooting...");
+	q = reg_rd64s(&tx4939_ccfgptr->clkctr);
+	reg_wr64s(&tx4939_ccfgptr->clkctr, q | TX4939_CLKCTR_IOSRST);
+	wbflush();
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	rbtx4939_machine_restart(command);
+#endif
+	while (1) ;
+}
+
+/**
+ * tx4939_check_clock - check clkctl register and set clock valuable
+ *
+ * This function reads TX4939.CCFG.clkctl register to set clock
+ * variable.
+ */
+
+static void tx4939_check_clock(void)
+{
+	{
+		unsigned int mulclk =
+		    TX4939_CCFG_MULCLK_GET(reg_rd64s(&tx4939_ccfgptr->ccfg));
+		unsigned int nd = (0x8 + ((mulclk + 1) & 0x7)) - 0x1;
+		unsigned pll2 = (nd + 1) * 200 / 3;
+		txx9_cpu_clock = pll2 / 2 * 1000000;
+	}
+	{
+		unsigned int ydivmode =
+		    TX4939_CCFG_YDIVMODE_GET(reg_rd64s
+					     (&tx4939_ccfgptr->ccfg));
+		unsigned int gbusdiv =
+		    ((ydivmode & 0x3) + 2) + ((ydivmode & 0x2) >> 1);
+		txx9_gbus_clock = txx9_cpu_clock / gbusdiv;
+	}
+	{
+		unsigned int syssp =
+		    TX4939_CCFG_SYSSP_GET(reg_rd64s(&tx4939_ccfgptr->ccfg));
+		unsigned int sysdiv =
+		    (2 + (((syssp + 1) & 0x1) << 1) +
+		     (((syssp + 1) & 0x2) >> 1) + ((syssp + 1) & 0x4));
+		txx9_sys_clock = txx9_gbus_clock / sysdiv;
+	}
+}
+
+static void __init tx4939_ccfg_bootlog(void)
+{
+	printk(KERN_INFO "TX4939 -- CPU:%dMHz(GBUS:%dMHz,SYS:%dMHz) REVID:%08lx\n",
+	       txx9_cpu_clock / 1000000,
+	       txx9_gbus_clock / 1000000,
+	       txx9_sys_clock / 1000000,
+	       (unsigned long)reg_rd64s(&tx4939_ccfgptr->revid));
+	printk(KERN_INFO "          CCFG:%016Lx PCFG:%016Lx\n",
+	       reg_rd64s(&tx4939_ccfgptr->ccfg),
+	       reg_rd64s(&tx4939_ccfgptr->pcfg));
+}
+
+/** tx4939_ccfg_setup - initialize CCFG
+ *
+ * This function sets ccfg and pcfg register. This function sets pin
+ * multiplexing by pcfg
+ */
+
+static void __init tx4939_ccfg_setup(void)
+{
+	u64 q;
+
+	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
+	q = reg_rd64s(&tx4939_ccfgptr->ccfg);
+	reg_wr64s(&tx4939_ccfgptr->ccfg,
+		    q | TX4939_CCFG_WDRST | TX4939_CCFG_BEOW);
+	/* clear PCIC1 reset */
+	q = reg_rd64s(&tx4939_ccfgptr->clkctr);
+	if (q & TX4939_CLKCTR_PCI1RST)
+		reg_wr64s(&tx4939_ccfgptr->clkctr, q & ~TX4939_CLKCTR_PCI1RST);
+
+	/* CCFG setting */
+	reg_wr64s(&tx4939_ccfgptr->ccfg, CONFIG_TOSHIBA_TX4939_CCFG);
+
+	/* PCFG setting */
+	reg_wr64s(&tx4939_ccfgptr->pcfg, CONFIG_TOSHIBA_TX4939_PCFG);
+
+	/* MCLKCTL setting (baud clock enable) */
+	q = reg_rd64s(&tx4939_ccfgptr->mclkctl);
+	reg_wr64s(&tx4939_ccfgptr->mclkctl, q | TX4939_MCLKCTL_BDE);
+
+	tx4939_ccfg_bootlog();
+}
+
+void tx4939_set_pcfg_rmii_speed(struct net_device *dev, int speed)
+{
+	u64 speed_bit, q;
+	switch (dev->irq) {
+	case TX4939_IRQ_ETHER(0):
+		speed_bit = TX4939_PCFG_SPEED0_100MBPS;
+		break;
+	case TX4939_IRQ_ETHER(1):
+		speed_bit = TX4939_PCFG_SPEED1_100MBPS;
+		break;
+	default:
+		return;
+	}
+
+	q = reg_rd64s(&tx4939_ccfgptr->pcfg);
+	if (speed)
+		reg_wr64s(&tx4939_ccfgptr->pcfg, q | speed_bit);
+	else
+		reg_wr64s(&tx4939_ccfgptr->pcfg, q & ~speed_bit);
+}
+
+/**
+ * tx4939_ebusc_setup - initialize EBUSC
+ *
+ */
+
+static void __init tx4939_ebusc_setup(void)
+{
+	/* EBUSC */
+}
+
+/**
+ * tx4939_ddrc_setup - initialize DDRC
+ *
+ */
+
+static void __init tx4939_ddrc_setup(void)
+{
+	u16 s;
+	/* DDRC */
+	s = reg_rd16(&tx4939_ddrcptr->ddr[1].ctl);
+	reg_wr16(&tx4939_ddrcptr->ddr[1].ctl, s | TX4939_DDR01_INIT_CLEAR);
+}
+
+/**
+ * tx4939_sram_setup - initialize SRAM
+ *
+ */
+
+static void __init tx4939_sram_setup(void)
+{
+	/* SRAM */
+}
+
+/**
+ * tx4939_irc_setup - initialize IRC
+ *
+ * This function sets up TX4939 Interrupt Controller.
+ */
+
+static void __init tx4939_irc_setup(void)
+{
+	/* IRC */
+	/* disable interrupt control */
+	reg_wr32(&tx4939_ircptr->den, 0);
+	/* clear irq trigger */
+	reg_wr32(&tx4939_ircptr->dm0, 0x00000000);
+	reg_wr32(&tx4939_ircptr->dm1, 0x00000000);
+	reg_wr32(&tx4939_ircptr->dm2, 0x00000000);
+	reg_wr32(&tx4939_ircptr->dm3, 0x00000000);
+}
+
+/**
+ * tx4939_tmr_setup - initialize TMR
+ *
+ * This function sets up TX4939 Timer/Counter.
+ * This function sets Timer/Counter to disable.
+ */
+
+static void __init tx4939_tmr_setup(void)
+{
+	unsigned int i;
+	/* TMR */
+	/* disable all timers */
+	for (i = 0; i < TX4939_NR_TMR; i++) {
+		reg_wr32(&tx4939_tmrptr(i)->tcr, TX4939_TMTCR_CRE);
+		reg_wr32(&tx4939_tmrptr(i)->tisr, 0);
+		reg_wr32(&tx4939_tmrptr(i)->cpra, 0xffffffff);
+		reg_wr32(&tx4939_tmrptr(i)->itmr, 0);
+		reg_wr32(&tx4939_tmrptr(i)->ccdr, 0);
+		reg_wr32(&tx4939_tmrptr(i)->pgmr, 0);
+	}
+}
+
+/**
+ * tx4939_sio_setup - initialize SIO
+ *
+ * This function sets up Serial I/O.  This function sets their serial
+ * control attributes. (uses SCLK, clock frequency, has cts line)
+ */
+
+static void __init tx4939_sio_setup(void)
+{
+	char *argptr;
+	unsigned int i;
+	int tx4939_sio_flag[4] =
+	    { UPF_BUGGY_UART | UPF_MAGIC_MULTIPLIER,
+	      UPF_MAGIC_MULTIPLIER,
+	      UPF_MAGIC_MULTIPLIER,
+	      UPF_MAGIC_MULTIPLIER };
+
+	/* SIO h/w flow control off */
+	for (i = 0; i < TX4939_NR_SIO; i++) {
+		reg_wr32(&tx4939_sioptr(i)->flcr, 0);
+	}
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		int i;
+		struct uart_port req;
+
+		for (i = 0; i <= 3; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)TX4939_SIO_REG(i);
+			req.mapbase = TX4939_SIO_REG(i);
+			req.irq = TX4939_IRQ_SIO(i);
+			req.flags = tx4939_sio_flag[i];
+			req.uartclk = 14745600;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+	argptr = prom_getcmdline();
+	if (strstr(argptr, "console=") == NULL) {
+		strcat(argptr, " console=ttyS0,38400");
+	}
+#endif
+#endif
+}
+
+/**
+ * tx4939_dmac_setup - initialize DMAC
+ *
+ *
+ */
+
+static void __init tx4939_dmac_setup(void)
+{
+	unsigned int i;
+	/* enable DMA */
+	for (i = 0; i < TX4939_NR_DMA; i++)
+		reg_wr32(&tx4939_dmacptr(i)->mcr, TX4939_DMMCR_MSTEN);
+}
+
+#if defined(CONFIG_SPI_TX4939)
+static int tx4939_spi_cs_func(int chipid, int on)
+{
+	/* dummy function */
+	static status;
+	status = chipid & on;
+}
+
+/**
+ * tx4939_spi_setup - initialize SPI
+ *
+ *
+ */
+
+static void __init tx4939_spi_setup(void)
+{
+	u32 l;
+
+	l = reg_rd32(&tx4939_ccfgptr->pcfg);
+	reg_wr32(&tx4939_ccfgptr->pcfg, l & TX4939_PCFG_SPIMODE_MASK);
+	l = reg_rd32(&tx4939_ccfgptr->pcfg);
+	reg_wr32(&tx4939_ccfgptr->pcfg, l | TX4939_PCFG_SPIMODE_SPI);
+
+	txx9_spi_setup(TX4939_SPIC_REG, tx4939_spi_cs_func);
+}
+#endif				/* CONFIG_SPI_TX4939 */
+
+/**
+ * tx4939_request_resource - request resource for TX49 internal
+ * registers
+ *
+ *
+ */
+
+static void __init tx4939_request_resource(void)
+{
+	/* TX4939 internal registers */
+	static struct resource tx4939_reg_resource = {
+		.name = "TX4939 internal registers",
+		.start = TX4939_REG_BASE,
+		.end = TX4939_REG_BASE + TX4939_REG_SIZE,
+		.flags = IORESOURCE_MEM,
+	};
+
+	if (request_resource(&iomem_resource, &tx4939_reg_resource))
+		printk(KERN_ERR "request resource for internal registers failed\n");
+}
+
+/**
+ * tx4939_time_init - time setup routine
+ *
+ * This function runs TX4939 time setup routine.
+ *
+ */
+
+static void __init tx4939_time_init(void)
+{
+	tx4939_rtc_init();
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+}
+
+#if defined(CONFIG_HEARTBEAT)
+void (*org_timer_handler) (int irq, void *dev_id, struct pt_regs * regs);
+
+static void tx4939_timer_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	org_timer_handler(irq, dev_id, regs);
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	{
+		static int i = 0;
+		if (i < 0) {
+			rbtx4939_heartbeat();
+			i = 50;
+		}
+		i--;
+	}
+#endif
+}
+#endif
+
+/**
+ * tx4939_timer_setup - generate the first timer interrupt
+ * @irq: The irqaction descripter for tick timer interrupt
+ *
+ * This function set to generate the first timer interrupt.
+ *
+ * This reads CP0.count register. And calculates a timing for first
+ * timer interrupt. And writes it to CP0.compare register.
+ */
+
+static void __init tx4939_timer_setup(struct irqaction *irq)
+{
+	u32 count;
+	u32 c1;
+	u32 c2;
+#if defined(CONFIG_HEARTBEAT)
+	org_timer_handler = irq->handler;
+	irq->handler = tx4939_timer_handler;
+#endif
+
+	if (reg_rd64s(&tx4939_ccfgptr->ccfg) & TX4939_CCFG_TINTDIS) {	/* TINTDIS is off */
+		fputs
+		    ("***** Please set TINTDIS to be able to TX49 core timer interrupt *****\r\n");
+		while (1) ;
+	}
+
+	setup_irq(TX4939_IRQ_CPU_TIMER, irq);
+
+	/* to generate the first timer interrupt */
+	c1 = read_c0_count();
+	count = c1 + (mips_hpt_frequency / HZ);
+	write_c0_compare(count);
+	c2 = read_c0_count();
+}
+
+/**
+ * tx4939_setup - common setup function
+ *
+ * This function runs setup routine related to TX4939/RBTX4939.
+ * This sets some function pointers, board_time_init, board_timer_setup,
+ * __wbflush.
+ *
+ */
+
+static int __init tx4939_setup(void)
+{
+	board_time_init = tx4939_time_init;
+	board_timer_setup = tx4939_timer_setup;
+	__wbflush = tx4939_write_buffer_flush;
+
+	ioport_resource.start = 0x1000;
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.start = 0x1000;
+	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
+
+	tx4939_check_clock();
+
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
+	tx4939_ccfg_setup();
+	tx4939_ebusc_setup();
+	tx4939_ddrc_setup();
+	tx4939_sram_setup();
+	tx4939_irc_setup();
+	tx4939_tmr_setup();
+
+#if defined(CONFIG_SERIAL_TXX9)
+	tx4939_sio_setup();
+#endif
+	tx4939_dmac_setup();
+
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	rbtx4939_setup();
+#endif
+
+#if defined(CONFIG_SPI_TX4939)
+	tx4939_spi_setup();
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_TX4939)
+	tx4939_ide_setup(0);
+#ifdef CONFIG_TOSHIBA_TX4939_MPLEX_ATA1
+	tx4939_ide_setup(1);
+#endif
+#endif
+	tx4939_request_resource();
+	_machine_restart = tx4939_machine_restart;
+	_machine_halt = tx4939_machine_halt;
+	_machine_power_off = tx4939_machine_power_off;
+
+	return 0;
+}
+
+early_initcall(tx4939_setup);
+
+EXPORT_SYMBOL(__wbflush);
+EXPORT_SYMBOL(tx4939_set_pcfg_rmii_speed);
Index: linux-2.6.10/arch/mips/tx4939/common/spi_txx9.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/spi_txx9.c
@@ -0,0 +1,177 @@
+/*
+ * arch/mips/tx4939/rbtx4939/spi_txx9.c
+ *
+ * Author: source@mvista.com
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <asm/tx4939/tx4939.h>
+#include <asm/tx4939/spi.h>
+
+static int (*txx9_spi_cs_func) (int chipid, int on);
+static spinlock_t txx9_spi_lock = SPIN_LOCK_UNLOCKED;
+
+extern unsigned int txx9_gbus_clock;
+
+#define SPI_FIFO_SIZE	4
+
+void __init
+txx9_spi_init(unsigned long base, int (*cs_func) (int chipid, int on))
+{
+	txx9_spi_cs_func = cs_func;
+	/* enter config mode */
+	reg_wr32(&tx4939_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(txx9_spi_wait);
+static irqreturn_t txx9_spi_interrupt(int irq, void *dev_id,
+				      struct pt_regs *regs)
+{
+	u32 v;
+
+	/* disable rx intr */
+	v = reg_rd32(&tx4939_spiptr->cr0);
+	reg_wr32(&tx4939_spiptr->cr0, v & ~TXx9_SPCR0_RBSIE);
+	wake_up(&txx9_spi_wait);
+
+	return IRQ_HANDLED;
+}
+static struct irqaction txx9_spi_action = {
+	.handler = txx9_spi_interrupt,
+	.name = "spi",
+};
+
+void __init txx9_spi_irqinit(int irc_irq)
+{
+	setup_irq(irc_irq, &txx9_spi_action);
+}
+
+int
+txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+	    unsigned char **inbufs, unsigned int *incounts,
+	    unsigned char **outbufs, unsigned int *outcounts, int cansleep)
+{
+	unsigned int incount, outcount;
+	unsigned char *inp, *outp;
+	int ret;
+	unsigned long flags;
+	u32 v;
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	if (((v =
+	      reg_rd32(&tx4939_spiptr->mcr)) & TXx9_SPMCR_OPMODE) ==
+	    TXx9_SPMCR_ACTIVE) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return -EBUSY;
+	}
+	/* enter config mode */
+	reg_wr32(&tx4939_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+	reg_wr32(&tx4939_spiptr->cr0,
+		  (desc->byteorder ? TXx9_SPCR0_SBOS : 0) |
+		  (desc->polarity ? TXx9_SPCR0_SPOL : 0) |
+		  (desc->phase ? TXx9_SPCR0_SPHA : 0) | 0x08);
+	reg_wr32(&tx4939_spiptr->cr1,
+		  (((TXX9_IMCLK + desc->baud) / (2 * desc->baud) - 1) << 8) |
+		  0x08) /* 8 bit only */ ;
+	/* enter active mode */
+	reg_wr32(&tx4939_spiptr->mcr, TXx9_SPMCR_ACTIVE);
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	/* CS ON */
+	if ((ret = txx9_spi_cs_func(chipid, 1)) < 0) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return ret;
+	}
+	udelay(desc->tcss);
+
+	/* do scatter IO */
+	inp = inbufs ? *inbufs : NULL;
+	outp = outbufs ? *outbufs : NULL;
+	incount = 0;
+	outcount = 0;
+	while (1) {
+		unsigned char data;
+		unsigned int count;
+		int i;
+		if (!incount) {
+			incount = incounts ? *incounts++ : 0;
+			inp = (incount && inbufs) ? *inbufs++ : NULL;
+		}
+		if (!outcount) {
+			outcount = outcounts ? *outcounts++ : 0;
+			outp = (outcount && outbufs) ? *outbufs++ : NULL;
+		}
+		if (!inp && !outp)
+			break;
+		count = SPI_FIFO_SIZE;
+		if (incount)
+			count = min(count, incount);
+		if (outcount)
+			count = min(count, outcount);
+
+		/* now tx must be idle... */
+		while (!(reg_rd32(&tx4939_spiptr->sr) & TXx9_SPSR_SIDLE)) ;
+
+		reg_wr32(&tx4939_spiptr->cr0,
+			 (reg_rd32(&tx4939_spiptr->cr0) &
+			  ~TXx9_SPCR0_RXIFL_MASK) | ((count - 1) << 12));
+		if (cansleep) {
+			/* enable rx intr */
+			reg_wr32(&tx4939_spiptr->cr0,
+				 reg_rd32(&tx4939_spiptr->cr0) | TXx9_SPCR0_RBSIE);
+		}
+		/* send */
+		for (i = 0; i < count; i++)
+			reg_wr32(&tx4939_spiptr->dr, inp ? *inp++ : 0);
+		/* wait all rx data */
+		if (cansleep) {
+			wait_event(txx9_spi_wait,
+				   reg_rd32(&tx4939_spiptr->
+					     sr) & TXx9_SPSR_SRRDY);
+		} else {
+			while (!
+			       (reg_rd32(&tx4939_spiptr->sr) &
+				TXx9_SPSR_RBSI)) ;
+		}
+		/* receive */
+		for (i = 0; i < count; i++) {
+			data = reg_rd32(&tx4939_spiptr->dr);
+			if (outp)
+				*outp++ = data;
+		}
+		if (incount)
+			incount -= count;
+		if (outcount)
+			outcount -= count;
+	}
+
+	/* CS OFF */
+	udelay(desc->tcsh);
+	txx9_spi_cs_func(chipid, 0);
+	udelay(desc->tcsr);
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	/* enter config mode */
+	reg_wr32(&tx4939_spiptr->mcr, TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR);
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	return 0;
+}
Index: linux-2.6.10/arch/mips/tx4939/common/tx49wtoe.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/common/tx49wtoe.c
@@ -0,0 +1,92 @@
+/*
+ * arch/mips/tx4939/common/tx49wtoe.c
+ *
+ * Interrupt handler for TX49 Write timeout error
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+#include <linux/config.h>
+#include <linux/module.h>	/* Definitions needed for kernel modules */
+#include <linux/kmod.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* We run in the kernel so we need this */
+#include <linux/slab.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <asm/io.h>
+
+#include <asm/tx4939/tx4939.h>
+
+#define IRQ_WTOERR TX4939_IRQ_TX49WTOE
+#define CCFG_BEOW  TX4939_CCFG_BEOW
+#define WDRST      TX4939_CCFG_WDRST
+#define TOEA       reg_rd64s(&tx4939_ccfgptr->toea)
+#define GBUS_WIDTH 36
+
+/**
+ * handler_tx49wtoe - Interrupt handler for TX49 write timeout error
+ * @ird:
+ * @dev_id:
+ * @regs:
+ *
+ * This is a interrupt handler for TX49 write timeout error. This
+ * shows message that it occurs, and show timeout error address
+ * register.
+ * TX49 write timeout error is related to write buffer.
+ * You should notice that the timing differs between the interrupt and
+ * the wrong access
+ */
+
+static irqreturn_t handler_tx49wtoe(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u64 q;
+
+	printk(KERN_ALERT "TX49 write timeout error\n");
+	printk(KERN_ALERT
+	       "toea = 0x%0*Lx, epc == %08lx, ra == %08lx (Bad address in epc)\n",
+	       GBUS_WIDTH / 4, (u64) TOEA, regs->cp0_epc, regs->regs[31]);
+	printk(KERN_ALERT
+	       "(This timeout error occurs after few instructions from a wrong access.)\n");
+
+	q = reg_rd64s(&tx4939_ccfgptr->ccfg);
+	reg_wr64s(&tx4939_ccfgptr->ccfg, (q & ~WDRST) | CCFG_BEOW);
+
+	return IRQ_HANDLED;
+}
+
+static int __init tx49wtoe_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "TX49 Write TimeOut Error interrupt module\n");
+
+	ret = request_irq(IRQ_WTOERR, handler_tx49wtoe, SA_INTERRUPT,
+			  "TX49 write timeout error", NULL);
+	if (ret) {
+		printk(KERN_ERR "unable to get wtoe irq%d: [%d]", IRQ_WTOERR,  ret);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit tx49wtoe_exit(void)
+{
+	free_irq(IRQ_WTOERR, NULL);
+}
+
+module_init(tx49wtoe_init);
+module_exit(tx49wtoe_exit);
+
+MODULE_DESCRIPTION("tx49 write timeout error");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/arch/mips/tx4939/rbtx4939/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/rbtx4939/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for common code for Toshiba TX4939 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= setup.o irq.o led.o
+obj-$(CONFIG_PROC_FS) += proc.o
+
Index: linux-2.6.10/arch/mips/tx4939/rbtx4939/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/rbtx4939/irq.c
@@ -0,0 +1,164 @@
+/*
+ * arch/mps/tx4939/rbtx4939/irq.c
+ *
+ * RBTX4939 irq handler
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/tx4939/tx4939.h>
+#include <asm/tx4939/rbtx4939.h>
+
+extern void tx4939_irc_set_irdn(unsigned int ic, u32 isc);
+
+static unsigned int rbtx4939_irq_ioc_startup(unsigned int irq);
+static void rbtx4939_irq_ioc_shutdown(unsigned int irq);
+static void rbtx4939_irq_ioc_enable(unsigned int irq);
+static void rbtx4939_irq_ioc_disable(unsigned int irq);
+static void rbtx4939_irq_ioc_mask_and_ack(unsigned int irq);
+static void rbtx4939_irq_ioc_end(unsigned int irq);
+
+static spinlock_t rbtx4939_ioc_lock = SPIN_LOCK_UNLOCKED;
+
+#define RBTX4939_IOC_NAME "RBTX4939-IOC"
+static struct hw_interrupt_type rbtx4939_irq_ioc_type = {
+	.typename = RBTX4939_IOC_NAME,
+	.startup = rbtx4939_irq_ioc_startup,
+	.shutdown = rbtx4939_irq_ioc_shutdown,
+	.enable = rbtx4939_irq_ioc_enable,
+	.disable = rbtx4939_irq_ioc_disable,
+	.ack = rbtx4939_irq_ioc_mask_and_ack,
+	.end = rbtx4939_irq_ioc_end,
+	.set_affinity = NULL
+};
+
+
+static struct irqaction rbtx4939_irq_ioc_action = {
+	.handler = no_action,
+	.name = RBTX4939_IOC_NAME
+};
+
+int rbtx4939_irq_nested(void)
+{
+	int irq;
+	u8 intf2;
+
+	intf2 = reg_rd08(rbtx4939_intf2_ptr);
+	if (!intf2) {
+		printk(KERN_ERR "%s(%03d): why ioc invoked?\n", __FUNCTION__, __LINE__);
+		return 0;
+	}
+
+	irq = RBTX4939_IRQ_IOC_BEG + fls(intf2) - 1;
+
+	return irq;
+}
+
+/***************************************************
+ * Functions for ioc
+ ***************************************************/
+
+static void rbtx4939_irq_ioc_mask_modify(unsigned bit, int irq)
+{
+	u8 c;
+	unsigned int offset = (irq - RBTX4939_IRQ_IOC_BEG);
+
+	c = reg_rd08(rbtx4939_intf1_ptr);
+	reg_wr08(rbtx4939_intf1_ptr, c & ~(0x1 << offset));
+	c = reg_rd08(rbtx4939_intf1_ptr);
+	reg_wr08(rbtx4939_intf1_ptr, c | (bit << offset));
+
+	/* prevent spurious interrupt */
+	__asm__ __volatile__("sync\n\t");
+	reg_rd08(rbtx4939_intf1_ptr);
+}
+
+/**
+ * rbtx4939_irq_ioc_init -
+ *
+ *
+ */
+
+static void __init rbtx4939_irq_ioc_init(void)
+{
+	int i;
+
+	for (i = RBTX4939_IRQ_IOC_BEG; i <= RBTX4939_IRQ_IOC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 3;
+		irq_desc[i].handler = &rbtx4939_irq_ioc_type;
+	}
+
+	setup_irq(RBTX4939_IRQ_IOC, &rbtx4939_irq_ioc_action);
+}
+
+static unsigned int rbtx4939_irq_ioc_startup(unsigned int irq)
+{
+	rbtx4939_irq_ioc_enable(irq);
+	return 0;
+}
+
+static void rbtx4939_irq_ioc_shutdown(unsigned int irq)
+{
+	rbtx4939_irq_ioc_disable(irq);
+}
+
+static void rbtx4939_irq_ioc_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rbtx4939_ioc_lock, flags);
+	rbtx4939_irq_ioc_mask_modify(0x1, irq);
+	spin_unlock_irqrestore(&rbtx4939_ioc_lock, flags);
+}
+
+static void rbtx4939_irq_ioc_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rbtx4939_ioc_lock, flags);
+	rbtx4939_irq_ioc_mask_modify(0x0, irq);
+	spin_unlock_irqrestore(&rbtx4939_ioc_lock, flags);
+}
+
+static void rbtx4939_irq_ioc_mask_and_ack(unsigned int irq)
+{
+	rbtx4939_irq_ioc_disable(irq);
+}
+
+static void rbtx4939_irq_ioc_end(unsigned int irq)
+{
+	if (irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))
+		return;
+	rbtx4939_irq_ioc_enable(irq);
+}
+
+/**
+ * rbtx4939_irq_init -
+ *
+ *
+ */
+
+void __init rbtx4939_irq_init(void)
+{
+	/* mask all IOC interrupts */
+	/* clear SoftInt interrupts */
+
+	/* Onboard 10M Ether: High Active */
+	tx4939_irc_set_irdn(RBTX4939_IRQ_DEBUG_ETHER - TX4939_IRQ_IRC_BEG,
+			    TX4939_IRDM_LOW_LEVEL);
+
+	rbtx4939_irq_ioc_init();
+}
Index: linux-2.6.10/arch/mips/tx4939/rbtx4939/led.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/rbtx4939/led.c
@@ -0,0 +1,57 @@
+/*
+ * arch/mips/tx4939/toshiba_rbtx4939/led.c
+ *
+ * LED driver on RBTX4939
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <asm/io.h>
+#include <asm/tx4939/rbtx4939.h>
+
+static int segment[0x10] = {
+	0x7e, 0x30, 0x6d, 0x79, 0x33, 0x5b, 0x5f, 0x70, 0x7f, 0x7b,	/* 0-9 */
+	0x77, 0x1f, 0x0d, 0x3d, 0x4f, 0x47	/* a-f */
+};
+
+void rbtx4939_led(unsigned int led, unsigned int hex)
+{
+	if (hex < 0x0 || 0xf < hex)
+		reg_wr08(rbtx4939_7segled_ptr + (led << 1), 0x00);
+	else
+		reg_wr08(rbtx4939_7segled_ptr + (led << 1), segment[hex]);
+}
+
+#if defined(CONFIG_HEARTBEAT)
+void rbtx4939_heartbeat(void)
+{
+	static int sw;
+	switch (sw) {
+	case 1:
+		reg_wr08(rbtx4939_7segled_ptr + 0, 0x1d);
+		reg_wr08(rbtx4939_7segled_ptr + 2, 0x00);
+		break;
+	case 2:
+		reg_wr08(rbtx4939_7segled_ptr + 0, 0x63);
+		reg_wr08(rbtx4939_7segled_ptr + 2, 0x00);
+		break;
+	case 3:
+		reg_wr08(rbtx4939_7segled_ptr + 0, 0x00);
+		reg_wr08(rbtx4939_7segled_ptr + 2, 0x63);
+		break;
+	default:
+		reg_wr08(rbtx4939_7segled_ptr + 0, 0x00);
+		reg_wr08(rbtx4939_7segled_ptr + 2, 0x1d);
+		sw = 0;
+		break;
+	}
+	sw++;
+}
+#endif
Index: linux-2.6.10/arch/mips/tx4939/rbtx4939/proc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/rbtx4939/proc.c
@@ -0,0 +1,137 @@
+/*
+ * arch/mips/tx4939/common/proc.c
+ *
+ * Setup proc-fs for tx4939
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>	/* Definitions needed for kernel modules */
+#include <linux/kmod.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* We run in the kernel so we need this */
+#include <linux/proc_fs.h>	/* The /proc definitions are in this one */
+
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/tx4939/rbtx4939.h>
+
+static struct proc_dir_entry *rbtx4939_proc_entry;
+
+static int rbtx4939_proc_show_ioc(char *sysbuf, char **start, off_t off,
+				  int count, int *eof, void *data)
+{
+	int len = 0;
+	len += sprintf(sysbuf + len, "rbtx4939_board_rev_ptr        :0x%02x\n",
+		       reg_rd08(rbtx4939_board_rev_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_ioc_rev_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_ioc_rev_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_config1_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_config1_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_config2_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_config2_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_config3_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_config3_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_config4_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_config4_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_usersw_ptr           :0x%02x\n",
+		       reg_rd08(rbtx4939_usersw_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_bootsw_ptr           :0x%02x\n",
+		       reg_rd08(rbtx4939_bootsw_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_inte_ptr             :0x%02x\n",
+		       reg_rd08(rbtx4939_inte_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_intp_ptr             :0x%02x\n",
+		       reg_rd08(rbtx4939_intp_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_intf1_ptr            :0x%02x\n",
+		       reg_rd08(rbtx4939_intf1_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_intf2_ptr            :0x%02x\n",
+		       reg_rd08(rbtx4939_intf2_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_soft_int_ptr         :0x%02x\n",
+		       reg_rd08(rbtx4939_soft_int_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_isa_status_ptr       :0x%02x\n",
+		       reg_rd08(rbtx4939_isa_status_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_pci66_ptr            :0x%02x\n",
+		       reg_rd08(rbtx4939_pci66_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_romemu_ptr           :0x%02x\n",
+		       reg_rd08(rbtx4939_romemu_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_spics_ptr            :0x%02x\n",
+		       reg_rd08(rbtx4939_spics_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_audio_mode_ptr       :0x%02x\n",
+		       reg_rd08(rbtx4939_audio_mode_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_isa_gpio_ptr         :0x%02x\n",
+		       reg_rd08(rbtx4939_isa_gpio_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_pe1_ptr              :0x%02x\n",
+		       reg_rd08(rbtx4939_pe1_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_pe2_ptr              :0x%02x\n",
+		       reg_rd08(rbtx4939_pe2_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_pe3_ptr              :0x%02x\n",
+		       reg_rd08(rbtx4939_pe3_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_vport_mode_ptr       :0x%02x\n",
+		       reg_rd08(rbtx4939_vport_mode_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_vport_reset_ptr      :0x%02x\n",
+		       reg_rd08(rbtx4939_vport_reset_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_vport_sout_ptr       :0x%02x\n",
+		       reg_rd08(rbtx4939_vport_sout_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_vport_sin_ptr        :0x%02x\n",
+		       reg_rd08(rbtx4939_vport_sin_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_7segled_ptr          :0x%02x\n",
+		       reg_rd08(rbtx4939_7segled_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_soft_reset_ptr       :0x%02x\n",
+		       reg_rd08(rbtx4939_soft_reset_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_sreset_enable_ptr    :0x%02x\n",
+		       reg_rd08(rbtx4939_sreset_enable_ptr));
+	len += sprintf(sysbuf + len, "rbtx4939_reset_status_ptr     :0x%02x\n",
+		       reg_rd08(rbtx4939_reset_status_ptr));
+	*eof = 1;
+	return len;
+}
+
+/**
+ * rbtx4939_proc_setup - setup proc interface for RBTX4939 registers
+ *
+ * This function makes proc entry to show RBTX4939 registers.
+ */
+
+static int __init rbtx4939_proc_setup(void)
+{
+	struct proc_dir_entry *entry;
+
+	rbtx4939_proc_entry = proc_mkdir("rbtx4939", NULL);
+
+	if (!rbtx4939_proc_entry) {
+		printk(KERN_ERR "rbtx4939 cannot be registered in /proc\n");
+		return -1;
+	}
+
+	entry = create_proc_entry("ioc_register", 0, rbtx4939_proc_entry);
+	if (entry) {
+		entry->read_proc = rbtx4939_proc_show_ioc;
+		entry->data = 0;
+	}
+
+	return 0;
+}
+
+static int __init rbtx4939_proc_init(void)
+{
+	return rbtx4939_proc_setup();
+}
+
+static void __exit rbtx4939_proc_exit(void)
+{
+	/* need to do something */
+}
+
+module_init(rbtx4939_proc_init);
+module_exit(rbtx4939_proc_exit);
+
+MODULE_DESCRIPTION("rbtx4939 proc interface");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/arch/mips/tx4939/rbtx4939/setup.c
===================================================================
--- /dev/null
+++ linux-2.6.10/arch/mips/tx4939/rbtx4939/setup.c
@@ -0,0 +1,320 @@
+/*
+ * arch/mips/tx4939/toshiba_rbtx4939/setup.c
+ *
+ * Setup pointers to hardware-dependent routines.
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/tx4939/tx4939.h>
+#include <asm/tx4939/rbtx4939.h>
+#if defined(CONFIG_PCI)
+#include <linux/pci.h>
+#endif
+#if defined(CONFIG_MTD_TX4939)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#endif
+
+void rbtx4939_machine_restart(char *command)
+{
+	local_irq_disable();
+	reg_wr08(rbtx4939_sreset_enable_ptr, 1);
+	reg_wr08(rbtx4939_soft_reset_ptr, 1);
+	wbflush();
+	while (1) ;
+}
+
+#if defined(CONFIG_SMC91X)
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.start = CPHYSADDR(RBTX4939_DEBUG_ETHER_BASE),
+		.end = CPHYSADDR(RBTX4939_DEBUG_ETHER_BASE) + 0x10 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = RBTX4939_IRQ_DEBUG_ETHER,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 1 /* io_mask: 8bit only */ ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name = "smc91x",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(smc91x_resources),
+	.resource = smc91x_resources,
+};
+
+static struct platform_device *rbtx4939_devs[] __initdata = {
+	&smc91x_device,
+};
+
+static int __init rbtx4939_device_init(void)
+{
+	platform_add_devices(rbtx4939_devs, ARRAY_SIZE(rbtx4939_devs));
+	return 0;
+}
+
+__initcall(rbtx4939_device_init);
+
+#endif
+
+void __init rbtx4939_pin_enable_setup(void)
+{
+	u64 pcfg = reg_rd64s(&tx4939_ccfgptr->pcfg);
+	u8 pe1, pe2, pe3;
+
+	pe1 = 0xf0;
+
+	if (pcfg & TX4939_PCFG_ET1MODE_ETHER)
+		pe1 |= RBTX4939_PE1_RMII1;
+
+	if (pcfg & TX4939_PCFG_ET0MODE_ETHER)
+		pe1 |= RBTX4939_PE1_RMII0;
+
+	if (pcfg & TX4939_PCFG_ATA1MODE_ATA)
+		pe1 |= RBTX4939_PE1_ATA1;
+
+	if (pcfg & TX4939_PCFG_ATA0MODE_ATA)
+		pe1 |= RBTX4939_PE1_ATA0;
+
+	reg_wr08(rbtx4939_pe1_ptr, pe1);
+
+
+	pe2 = 0xc0;
+
+	if (pcfg & TX4939_PCFG_I2SMODE_GPIO)
+		pe2 |= RBTX4939_PE2_GPIO;
+
+	if (pcfg & TX4939_PCFG_SPIMODE_SIO_GPIO) {
+#if defined(CONFIG_TOSHIBA_RBTX4939_PIN_CIR)
+		pe2 |= RBTX4939_PE2_CIR;
+#endif
+#if defined(CONFIG_TOSHIBA_RBTX4939_PIN_SIO3)
+		pe2 |= RBTX4939_PE2_SIO3
+#endif
+	} else
+		pe2 |= RBTX4939_PE2_SPI;
+
+	if (pcfg & TX4939_PCFG_SIO2MODE_SIO2)
+		pe2 |= RBTX4939_PE2_SIO2;
+
+	pe2 |= RBTX4939_PE2_SIO1;
+	reg_wr08(rbtx4939_pe2_ptr, pe2);
+
+
+	pe3 = 0xf0;
+
+	if (pcfg & TX4939_PCFG_VPMODE_3S)
+		pe3 |= RBTX4939_PE3_VP_S;
+
+	if (pcfg & (TX4939_PCFG_VPMODE_1P | TX4939_PCFG_VPMODE_1P1S))
+		pe3 |= RBTX4939_PE3_VP_P;
+
+	if (pcfg & (TX4939_PCFG_VPMODE_3S | TX4939_PCFG_VPMODE_1P1S))
+		pe3 |= RBTX4939_PE3_VP;
+
+	reg_wr08(rbtx4939_pe3_ptr, pe3);
+}
+
+static void __init rbtx4939_request_resource(void)
+{
+	/* RBTX4939 I/O Controller */
+	static struct resource rbtx4939_ioc_resource = {
+		.name = "RBTX4939 I/O controller",
+		.start = CPHYSADDR(RBTX4939_IOC_REG),
+		.end = CPHYSADDR(RBTX4939_IOC_REG + RBTX4939_IOC_SIZE),
+		.flags = IORESOURCE_MEM,
+	};
+
+	if (request_resource(&iomem_resource, &rbtx4939_ioc_resource))
+		printk(KERN_ERR "request resource for I/O controller failed\n");
+}
+
+static void __init rbtx4939_bootlog(void)
+{
+	printk
+	    (KERN_INFO "RBTX4939 --- Board(0x%02x) IOC(0x%02x) DIPSW:(User:0x%02x,Boot:0x%02x)\n",
+	     reg_rd08(rbtx4939_board_rev_ptr),
+	     reg_rd08(rbtx4939_ioc_rev_ptr),
+	     reg_rd08(rbtx4939_usersw_ptr),
+	     reg_rd08(rbtx4939_bootsw_ptr));
+}
+
+#if defined(CONFIG_MTD_TX4939)
+
+static struct mtd_partition tx4939_userrom1_parts[] = {
+	{
+		.name = "USER ROM1_1",
+		.size = 0x00800000,  /* 8MB */
+		.offset = 0,
+	},
+	{
+		.name = "USER ROM1_2",
+		.size = 0x007c0000,  /* 8MB *//* don't expose yamon data area */
+		.offset = 0x00800000,
+	},
+};
+
+static struct mtd_partition tx4939_userrom2_parts[] = {
+	{
+		.name = "USER ROM2_1",
+		.size = 0x00800000,  /* 8MB */
+		.offset = 0,
+	},
+	{
+		.name = "USER ROM2_2",
+		.size = 0x00800000,  /* 8MB */
+		.offset = 0x00800000,
+	},
+};
+static void __init rbtx4939_nor_setup(void)
+{
+	int n = 0;
+	u8 sw = reg_rd08(rbtx4939_bootsw_ptr);
+
+	switch (sw) {
+	case 0x0:
+	case 0x1:
+		early_txmtd_setup(n++, "USER ROM1",
+				  0x1d000000, 0x1000000,
+				  2, 2, tx4939_userrom1_parts, NULL);
+		early_txmtd_setup(n++, "USER ROM2",
+				  0x1c000000, 0x1000000,
+				  2, 2, tx4939_userrom2_parts, NULL);
+		break;
+	case 0x8:
+	case 0x9:
+	case 0xa:
+	case 0xb:
+		early_txmtd_setup(n++, "USER ROM1",
+				  0x1f000000, 0x1000000,
+				  2, 2, tx4939_userrom1_parts, NULL);
+		early_txmtd_setup(n++, "USER ROM2",
+				  0x1e000000, 0x1000000,
+				  2, 2, tx4939_userrom2_parts, NULL);
+		break;
+	case 0xc:
+	case 0xd:
+	case 0xe:
+	case 0xf:
+		early_txmtd_setup(n++, "USER ROM2",
+				  0x1f000000, 0x1000000,
+				  2, 2, tx4939_userrom2_parts, NULL);
+		early_txmtd_setup(n++, "USER ROM1",
+				  0x1e000000, 0x1000000,
+				  2, 2, tx4939_userrom1_parts, NULL);
+		break;
+	}
+}
+
+/**
+ * rbtx4939_get_tx4939_nandc_parameter - get rbtx4939 nandc parameter
+ * @hold: hold time
+ * @spw: strobe pulse width
+ *
+ */
+#if defined(CONFIG_MTD_NAND)
+void rbtx4939_get_tx4939_nandc_parameter(int *hold, int *spw)
+{
+	*hold = 2;
+	*spw = 7;               /*  GBUSCLK = 5ns (@ GBUSCLK 200MHz) */
+}
+#endif                         /* CONFIG_MTD_NAND */
+#endif				/* CONFIG_MTD_TX4938 */
+
+/**
+ * rbtx4939_setup - TX4939 reference board setup routine
+ *
+ * This function runs RBTX4939(TX4939 reference board) setup routines.
+ */
+
+void __init rbtx4939_setup(void)
+{
+	rbtx4939_pin_enable_setup();
+	rbtx4939_request_resource();
+	rbtx4939_bootlog();
+#if defined(CONFIG_MTD_TX4939)
+	rbtx4939_nor_setup();
+#endif
+	rbtx4939_led(0, 0x0);
+	rbtx4939_led(1, 0x0);
+	rbtx4939_led(2, 0x2);
+	rbtx4939_led(3, 0x6);
+	/* mips_io_port_base will be overwritten by tx4939_pci_setup() */
+	set_io_port_base(TX4939_PCI0_MEM_RESOURCE_START);
+}
+
+#if defined(CONFIG_PCI)
+/**
+ * rbtx4939_get_tx4939_ethaddr - get rbtx4939 debug ether mac address
+ * @dev:
+ * @addr: character pointer for address string
+ *
+ */
+
+int rbtx4939_get_tx4939_ethaddr(struct pci_dev *dev, unsigned char *addr)
+{
+	int ch;
+	static int read_dat;
+	struct pci_controller *channel =
+		(struct pci_controller *)dev->bus->sysdata;
+	static unsigned char dat[0x17];
+
+	if (channel != &tx4939_pci_controller[1])
+		return -ENODEV;
+	/* TX4939 PCIC1 */
+	switch (PCI_SLOT(dev->devfn)) {
+	case TX4939_PCIC_IDSEL_AD_TO_SLOT(TX4939_ETHER_IDSEL(0)):
+		ch = 0;
+		break;
+	case TX4939_PCIC_IDSEL_AD_TO_SLOT(TX4939_ETHER_IDSEL(1)):
+		ch = 1;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	if (!read_dat) {
+		unsigned char sum;
+		int i;
+		read_dat = 1;
+		memcpy(dat, (void *)(KSEG1 + RBTX4939_ETHER_MAC_ADDR_BASE),
+		       sizeof(dat));
+
+		for (i = 0, sum = 0; i < sizeof(dat); i++)
+			sum += dat[i];
+
+		if (sum)
+			printk(KERN_WARNING
+			       "Ethernet MAC Address: bad checksum.\n");
+	}
+
+	memcpy(addr, &dat[0x10 * ch], 6);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(rbtx4939_get_tx4939_ethaddr);
+
+#endif				/* CONFIG_PCI */
Index: linux-2.6.10/drivers/ide/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/ide/Kconfig
+++ linux-2.6.10/drivers/ide/Kconfig
@@ -1015,6 +1015,11 @@ config BLK_DEV_UMC8672
 	  See the files <file:Documentation/ide.txt> and
 	  <file:drivers/ide/legacy/umc8672.c> for more info.
 
+config BLK_DEV_IDE_TX4939
+	tristate "TX4939 internal IDE support"
+	depends TOSHIBA_RBTX4939
+	help
+
 endif
 
 config BLK_DEV_IDEDMA
Index: linux-2.6.10/drivers/ide/ide-cd.c
===================================================================
--- linux-2.6.10.orig/drivers/ide/ide-cd.c
+++ linux-2.6.10/drivers/ide/ide-cd.c
@@ -678,6 +678,13 @@ static int cdrom_decode_status(ide_drive
 	err = HWIF(drive)->INB(IDE_ERROR_REG);
 	sense_key = err >> 4;
 
+#if defined(CONFIG_BLK_DEV_IDE_TX4939)
+        if (IS_IDE_TX4939) {
+		extern void tx4939_ide_softreset(ide_drive_t*);
+                tx4939_ide_softreset(drive);
+        }
+#endif
+
 	if (rq == NULL) {
 		printk("%s: missing rq in cdrom_decode_status\n", drive->name);
 		return 1;
@@ -3254,7 +3261,12 @@ int ide_cdrom_setup (ide_drive_t *drive)
 	info->changer_info      = NULL;
 	info->last_block	= 0;
 	info->start_seek	= 0;
-
+#ifdef CONFIG_BLK_DEV_IDE_TX4939
+	{
+		extern void tx4939_ide_cdrom_setup(ide_drive_t *drive);
+		tx4939_ide_cdrom_setup(drive);
+	}
+#endif
 	nslots = ide_cdrom_probe_capabilities (drive);
 
 	/*
Index: linux-2.6.10/drivers/ide/ide-dma.c
===================================================================
--- linux-2.6.10.orig/drivers/ide/ide-dma.c
+++ linux-2.6.10/drivers/ide/ide-dma.c
@@ -856,7 +856,8 @@ int ide_mapped_mmio_dma (ide_hwif_t *hwi
 	printk(KERN_INFO "    %s: MMIO-DMA ", hwif->name);
 
 	hwif->dma_base = base;
-	if (hwif->cds->extra && hwif->channel == 0)
+
+	if (hwif->cds && hwif->cds->extra && hwif->channel == 0)
 		hwif->dma_extra = hwif->cds->extra;
 
 	if(hwif->mate)
@@ -875,7 +876,7 @@ int ide_iomio_dma (ide_hwif_t *hwif, uns
 		return 1;
 	}
 	hwif->dma_base = base;
-	if ((hwif->cds->extra) && (hwif->channel == 0)) {
+	if (hwif->cds && (hwif->cds->extra) && (hwif->channel == 0)) {
 		request_region(base+16, hwif->cds->extra, hwif->cds->name);
 		hwif->dma_extra = hwif->cds->extra;
 	}
Index: linux-2.6.10/drivers/ide/ide-proc.c
===================================================================
--- linux-2.6.10.orig/drivers/ide/ide-proc.c
+++ linux-2.6.10/drivers/ide/ide-proc.c
@@ -64,6 +64,7 @@ static int proc_ide_read_imodel
 		case ide_cy82c693:	name = "cy82c693";	break;
 		case ide_4drives:	name = "4drives";	break;
 		case ide_pmac:		name = "mac-io";	break;
+		case ide_tx4939:	name = "tx4939";	break;
 		default:		name = "(unknown)";	break;
 	}
 	len = sprintf(page, "%s\n", name);
Index: linux-2.6.10/drivers/ide/ide.c
===================================================================
--- linux-2.6.10.orig/drivers/ide/ide.c
+++ linux-2.6.10/drivers/ide/ide.c
@@ -2151,6 +2151,15 @@ static void __init probe_for_hwifs (void
 		swarm_ide_probe();
 	}
 #endif /* CONFIG_BLK_IDE_SWARM */
+#ifdef CONFIG_BLK_DEV_IDE_TX4939
+	{
+		extern void tx4939_ide_init(int ch);
+		tx4939_ide_init(0);
+#ifdef CONFIG_TOSHIBA_TX4939_MPLEX_ATA1
+		tx4939_ide_init(1);
+#endif
+	}
+#endif /* CONFIG_BLK_DEV_IDE_TX4939 */
 #ifdef CONFIG_BLK_DEV_BUDDHA
 	{
 		extern void buddha_init(void);
Index: linux-2.6.10/drivers/ide/mips/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/ide/mips/Makefile
+++ linux-2.6.10/drivers/ide/mips/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= ide-tx4939.o
 
 EXTRA_CFLAGS	:= -I../
Index: linux-2.6.10/drivers/ide/mips/ide-tx4939.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/ide/mips/ide-tx4939.c
@@ -0,0 +1,534 @@
+/*
+ * drivers/ide/mips/ide-tx4939.c
+ *
+ * TX4939 internal IDE driver
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>
+#include <linux/ide.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/bootinfo.h>
+#include <asm/pci.h>
+#include <asm/delay.h>
+#include <asm/tx4939/tx4939.h>
+
+/* from ide-cd.h */
+#define CD_FRAMESIZE    2048
+#define SECTOR_BITS                     9
+#define SECTORS_PER_FRAME       (CD_FRAMESIZE >> SECTOR_BITS)
+
+/* add command line TX4939 IDE DMA setteing */
+byte tx4939_ide_udma_mode;
+
+/* wait for transfer end */
+static u16 wait_transfer_end[2];
+
+#define IS_ATAPI(drive) ((drive)->media == ide_cdrom || (drive)->media == ide_scsi)
+#define GET_CH(hwif) (hwif->irq == TX4939_IRQ_ATA(0) ? 0 : 1)
+
+void tx4939_ide_softreset(ide_drive_t * drive)
+{
+	int ch = GET_CH(HWIF(drive));
+	u16 lo_bcnt, hi_bcnt, s;
+
+	/* save ata controller valiable */
+	lo_bcnt = reg_rd16(&tx4939_ataptr(ch)->lo_bcnt);
+	hi_bcnt = reg_rd16(&tx4939_ataptr(ch)->hi_bcnt);
+
+	/* Soft Reset */
+	s = reg_rd16(&tx4939_ataptr(ch)->sysctl1);
+	reg_wr16(&tx4939_ataptr(ch)->sysctl1, s|TX4939_ATA_SC_SOFT_RESET);
+	wbflush();
+	udelay(1);
+
+	/* load ata controller valiable */
+	reg_wr16(&tx4939_ataptr(ch)->lo_bcnt, lo_bcnt);
+	reg_wr16(&tx4939_ataptr(ch)->hi_bcnt, hi_bcnt);
+}
+
+/**
+ * tx4939_ide_tune_drive - ide_tuneproc_t function for TX4939-IDE
+ * @drive: This is the drive data.
+ * @pio: This is used to select the PIO mode by number (0,1,2,3,4,5).
+ *
+ * An ide_tuneproc_t() is used to set the speed of an IDE interface
+ * to a particular PIO mode.  The "byte" parameter is used
+ * to select the PIO mode by number (0,1,2,3,4,5), and a value of 255
+ * indicates that the interface driver should "auto-tune" the PIO mode
+ * according to the drive capabilities in drive->id;
+ *
+ * Not all interface types support tuning, and not all of those
+ * support all possible PIO settings.  They may silently ignore
+ * or round values as they see fit.
+ */
+
+static void tx4939_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	u16 data = 0;
+	u16 mode = 0;
+	byte speed = XFER_PIO_0;
+	unsigned long data_port;
+	unsigned long sc_port;
+	int is_slave = (&HWIF(drive)->drives[1] == drive);
+	ide_hwif_t *hwif = drive->hwif;
+
+	data_port = (unsigned long)hwif->io_ports[IDE_DATA_OFFSET];
+	sc_port = (!is_slave) ?
+		data_port + TX4939_ATA_SYSTEM_CONTROL1_OFFSET :
+		data_port + TX4939_ATA_SYSTEM_CONTROL2_OFFSET;
+
+	if (!hwif->channel) {	/* primary */
+		pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+		switch (pio) {
+		case 4:
+			mode = TX4939_ATA_SC_MODE_XFER_PIO_4;
+			speed = XFER_PIO_4;
+			break;
+		case 3:
+			mode = TX4939_ATA_SC_MODE_XFER_PIO_3;
+			speed = XFER_PIO_3;
+			break;
+		case 2:
+			mode = TX4939_ATA_SC_MODE_XFER_PIO_2;
+			speed = XFER_PIO_2;
+			break;
+		case 1:
+			mode = TX4939_ATA_SC_MODE_XFER_PIO_1;
+			speed = XFER_PIO_1;
+			break;
+		case 0:
+			mode = TX4939_ATA_SC_MODE_XFER_PIO_0;
+			speed = XFER_PIO_0;
+			break;
+		default:
+			break;
+		}
+
+		data = inw(sc_port);
+		data &= ~TX4939_ATA_SC_MODE_MASK;
+		data |= mode;
+		outw(data, sc_port);
+	}
+
+	drive->current_speed = speed;
+	ide_config_drive_speed(drive, speed);
+}
+
+/**
+ * tx4939_ide_tune_chipset - ide_speedproc_t function for TX4939-IDE
+ * @drive: This is the drive data.
+ * @speed: This parameter is used to select the transfer mode.
+ *
+ * This function sets the transfer mode.
+ */
+
+static int tx4939_ide_tune_chipset(ide_drive_t * drive, byte speed)
+{
+	u16 data = 0;
+	u16 mode = 0;
+	unsigned long data_port;
+	unsigned long sc_port;
+	int err;
+
+	int is_slave = (&HWIF(drive)->drives[1] == drive);
+	ide_hwif_t *hwif = HWIF(drive);
+	data_port = (unsigned long)hwif->io_ports[IDE_DATA_OFFSET];
+	sc_port = (!is_slave) ?
+		data_port + TX4939_ATA_SYSTEM_CONTROL1_OFFSET :
+		data_port + TX4939_ATA_SYSTEM_CONTROL2_OFFSET;
+
+	if (!hwif->channel) {
+		switch (speed) {
+		case XFER_UDMA_5:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_5;
+			break;
+		case XFER_UDMA_4:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_4;
+			break;
+		case XFER_UDMA_3:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_3;
+			break;
+		case XFER_UDMA_2:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_2;
+			break;
+		case XFER_UDMA_1:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_1;
+			break;
+		case XFER_UDMA_0:
+			mode = TX4939_ATA_SC_MODE_XFER_UDMA_0;
+			break;
+		case XFER_MW_DMA_2:
+			mode = TX4939_ATA_SC_MODE_XFER_MDMA_2;
+			break;
+		case XFER_MW_DMA_1:
+			mode = TX4939_ATA_SC_MODE_XFER_MDMA_1;
+			break;
+		case XFER_MW_DMA_0:
+			mode = TX4939_ATA_SC_MODE_XFER_MDMA_0;
+			break;
+		default:
+			return -1;
+		}
+
+		data = inw(sc_port);
+		data &= ~TX4939_ATA_SC_MODE_MASK;
+		data |=
+			mode | (TX4939_ATA_SC_MODE_XFER_PIO_4 &
+				TX4939_ATA_SC_CMD_MODE_MASK);
+		outw(data, sc_port);
+	}
+
+	if (!drive->init_speed) {
+		drive->init_speed = speed;
+	}
+
+	drive->current_speed = speed;
+	err = ide_config_drive_speed(drive, speed);
+
+	return err;
+}
+
+/* called from ide_cdrom_setup */
+void tx4939_ide_cdrom_setup(ide_drive_t * drive)
+{
+	unsigned int ch = GET_CH(HWIF(drive));
+	ide_hwif_t *hwif = HWIF(drive);
+	int is_slave = (&hwif->drives[1] == drive);
+
+	if (!is_slave)
+		reg_wr16(&tx4939_ataptr(ch)->xfer_cnt1, CD_FRAMESIZE / 2);	/* word, not byte */
+	else
+		reg_wr16(&tx4939_ataptr(ch)->xfer_cnt2, CD_FRAMESIZE / 2);
+}
+
+/* called from cdrom_transfer_packet_bytes */
+static void
+tx4939_ide_atapi_output_bytes(ide_drive_t * drive, void *buffer,
+				unsigned int bytecount)
+{
+	unsigned int ch = GET_CH(HWIF(drive));
+	unsigned int i;
+	u16 s;
+
+	if (bytecount < 12) {
+		printk(KERN_ERR "tx4939_ide_atapi_output_command: bad count %d\n",
+		       bytecount);
+		return;
+	}
+#if 0				/* This driver uses Packet Command Register */
+	for (i = 0; i < bytecount; i += 2) {
+		OUT_WORD(*(u16 *) (buffer + i), IDE_DATA_REG);
+	}
+	do {
+	} while ((IN_BYTE(IDE_NSECTOR_REG) & 0x1) == 0x1);	/* wait C/D clear */
+	return;
+#endif
+
+	/* set interrupt mask (Data Transfer End) */
+	reg_wr16(&tx4939_ataptr(ch)->int_ctl, TX4939_ATA_IC_DATA_TRANSFER_END << 8);
+
+	/* set the command packet in FIFO */
+	for (i = 0; i < bytecount; i += 2) {
+		reg_wr16(&tx4939_ataptr(ch)->pkt_cmd, *(u16 *) (buffer + i));
+	}
+
+	/* set the transfer count and the packet start bit */
+	reg_wr16(&tx4939_ataptr(ch)->pkt_xfer_ct,
+		((bytecount / 2 - 1) << 8) | TX4939_ATA_PTC_PACKET_START);
+
+	/* wait for command out from FIFO (Data Transfer End) */
+	do {
+		s = reg_rd16(&tx4939_ataptr(ch)->int_ctl);
+	} while (!(s & TX4939_ATA_IC_DATA_TRANSFER_END));
+	reg_wr16(&tx4939_ataptr(ch)->int_ctl, s & TX4939_ATA_IC_DATA_TRANSFER_END);
+
+	/* clear packet transfer count register and */
+	reg_wr16(&tx4939_ataptr(ch)->pkt_xfer_ct, 0);
+}
+
+/**
+ * tx4939_ide_intr - interrupt handler for TX4939-IDE
+ * @hwif:
+ *
+ * This function calls from ide_intr function which is entry point for
+ * all interrupts of IDE driver.
+ *
+ * If TX4939-IDE has HOSTINT interrupt (which indicates INTRQ),
+ * continues ide_intr process.
+ */
+
+#define INT_ERROR_MASK  (TX4939_ATA_IC_BUS_ERROR |\
+                         TX4939_ATA_IC_DEV_TIMING_ERROR |\
+                         TX4939_ATA_IC_REACH_MALTIPLE_INT |\
+                         TX4939_ATA_IC_ADDRESS_ERROR_INT)
+
+static int tx4939_ide_intr(struct hwif_s *hwif)
+{
+	unsigned int ch = GET_CH(hwif);
+	ide_drive_t *drive;
+	u16 int_ctl;
+
+	drive = hwif->drives;
+
+	/* get and clear interrupt status */
+	int_ctl = reg_rd16(&tx4939_ataptr(ch)->int_ctl);
+	reg_wr16(&tx4939_ataptr(ch)->int_ctl, int_ctl);
+#ifdef  DEBUG
+	/* check error sattus */
+	if (int_ctl & INT_ERROR_MASK) {
+		if (int_ctl & TX4939_ATA_IC_ADDRESS_ERROR_INT)
+			printk(KERN_INFO "%s: Address Error\n", drive->name);
+		if (int_ctl & TX4939_ATA_IC_REACH_MALTIPLE_INT)
+			printk(KERN_INFO "%s: PIO transfer in the break state\n",
+			       drive->name);
+		if (int_ctl & TX4939_ATA_IC_DEV_TIMING_ERROR)
+			printk(KERN_INFO "%s: Device timing error (out of spec) - 0x%04x\n",
+			       drive->name, reg_rd16(&tx4939_ataptr(ch)->dev_terr));
+		if (int_ctl & TX4939_ATA_IC_DMA_DEV_TERMINATE) {
+			printk(KERN_INFO
+			       "%s: The device terminated DMA transfer\n",
+			       drive->name);
+		}
+		if (int_ctl & TX4939_ATA_IC_BUS_ERROR)
+			printk(KERN_INFO "%s: Bus error\n", drive->name);
+	}
+#endif
+	/* wait for transfer end in DMA mode */
+	if (drive->waiting_for_dma == 1) {
+		wait_transfer_end[ch] |= int_ctl;
+		if ((wait_transfer_end[ch] & 0x3) == 0x3)
+			return 1;
+		return 0;
+	}
+	return (int_ctl & TX4939_ATA_IC_HOSTINT);
+	/* HOSTINT indicates that INTRQ */
+}
+
+/* returns 1 on error, 0 otherwise */
+static int tx4939_ide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	unsigned int ch = GET_CH(HWIF(drive));
+
+	u8 dma_stat = 0, dma_cmd = 0;
+
+	drive->waiting_for_dma = 0;
+	/* get dma_command mode */
+	dma_cmd = hwif->INB(hwif->dma_command);
+	/* stop DMA */
+	hwif->OUTB(dma_cmd&~1, hwif->dma_command);
+	/* get DMA status */
+	dma_stat = hwif->INB(hwif->dma_status);
+	/* clear the INTR & ERROR bits */
+	hwif->OUTB(dma_stat|6, hwif->dma_status);
+	/* purge DMA mappings */
+	ide_destroy_dmatable(drive);
+
+	return (reg_rd16(&tx4939_ataptr(ch)->sec_cnt) != 0);
+}
+
+static int tx4939_ide_dma_test_irq (ide_drive_t *drive)
+{
+	return 1;
+}
+
+/**
+ * tx4939_ide_config_drive_for_dma
+ * @drive
+ *
+ */
+
+static int
+tx4939_ide_config_drive_for_dma(ide_drive_t * drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct hd_driveid *id = drive->id;
+	int ultra = 1;
+	byte speed = 0;
+	byte udma_66 = eighty_ninty_three(drive);	/* hwif->udma_four 0:default 1:ATA66 */
+
+	if ((id->dma_ultra & 0x0020) && (ultra)) {
+		speed = (udma_66) ? XFER_UDMA_5 : XFER_UDMA_2;
+	} else if ((id->dma_ultra & 0x0010) && (ultra)) {
+		speed = (udma_66) ? XFER_UDMA_4 : XFER_UDMA_2;
+	} else if ((id->dma_ultra & 0x0008) && (ultra)) {
+		speed = (udma_66) ? XFER_UDMA_3 : XFER_UDMA_1;
+	} else if ((id->dma_ultra & 0x0004) && (ultra)) {
+		speed = XFER_UDMA_2;
+	} else if ((id->dma_ultra & 0x0002) && (ultra)) {
+		speed = XFER_UDMA_1;
+	} else if ((id->dma_ultra & 0x0001) && (ultra)) {
+		speed = XFER_UDMA_0;
+	} else if (id->dma_mword & 0x0004) {
+		speed = XFER_MW_DMA_2;
+	} else if (id->dma_mword & 0x0002) {
+		speed = XFER_MW_DMA_1;
+	} else if (id->dma_1word & 0x0004) {
+		speed = XFER_SW_DMA_2;
+	} else {
+		/* speed = XFER_PIO_0 + ide_get_best_pio_mode(drive, 255, 5, NULL); */
+		return hwif->ide_dma_off_quietly(drive);
+	}
+
+	/* add command line TX4939IDE DMA setting */
+	if (tx4939_ide_udma_mode && speed >= XFER_UDMA_0) {
+		speed =
+		    (tx4939_ide_udma_mode >
+		     speed) ? speed : tx4939_ide_udma_mode;
+	}
+
+	tx4939_ide_tune_chipset(drive, speed);
+
+	return ((int) ((id->dma_ultra >> 11) & 7) ? hwif->ide_dma_on(drive) :
+		((id->dma_ultra >> 8) & 7) ? hwif->ide_dma_on(drive) :
+		((id->dma_mword >> 8) & 7) ? hwif->ide_dma_on(drive) :
+		((id->dma_1word >> 8) & 7) ? hwif->ide_dma_on(drive) : hwif->ide_dma_off_quietly(drive));
+}
+
+
+/**
+ *	tx4939_ide_dma_check		-	check DMA setup
+ *	@drive: drive to check
+ *
+ *	Don't use - due for extermination
+ */
+
+static int tx4939_ide_dma_check (ide_drive_t *drive)
+{
+	return tx4939_ide_config_drive_for_dma(drive);
+}
+
+/**
+ *	tx4939_ide_dma_setup	-	begin a DMA phase
+ *	@drive: target device
+ *
+ *	Build an IDE DMA PRD (IDE speak for scatter gather table)
+ *	and then set up the DMA transfer registers for a device
+ *	that follows generic IDE PCI DMA behaviour. Controllers can
+ *	override this function if they need to
+ *
+ *	Returns 0 on success. If a PIO fallback is required then 1
+ *	is returned.
+ */
+
+static int tx4939_ide_dma_setup(ide_drive_t *drive)
+{
+	unsigned int ch = GET_CH(HWIF(drive));
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int reading;
+	u8 dma_stat;
+	u16 s;
+
+	/* FIFO reset */
+	s = reg_rd16(&tx4939_ataptr(ch)->sysctl1);
+	reg_wr16(&tx4939_ataptr(ch)->sysctl1, s|TX4939_ATA_SC_FIFO_RESET);
+	wbflush();
+	udelay(1);	/* ATA I/F controller spec 12 UPSCLK cycles */
+
+	/* set sector count (cpu:c10h) */
+	if (!IS_ATAPI(drive)) {
+		reg_wr16(&tx4939_ataptr(ch)->sec_cnt, rq->nr_sectors);
+	} else {
+		unsigned int nframes = 0;
+		struct bio *b = rq->bio;
+		int is_slave = (&hwif->drives[1] == drive);
+
+		do {
+			nframes += b->bi_size;
+		} while ((b = b->bi_next) != NULL);
+		nframes /= CD_FRAMESIZE;
+		reg_wr16(&tx4939_ataptr(ch)->sec_cnt, nframes);
+
+		if (!is_slave)
+			reg_wr16(&tx4939_ataptr(ch)->xfer_cnt1, CD_FRAMESIZE / 2); /* word, not byte */
+		else
+			reg_wr16(&tx4939_ataptr(ch)->xfer_cnt2, CD_FRAMESIZE / 2);
+
+	}
+
+	wait_transfer_end[ch] = 0;
+
+	return ide_dma_setup(drive);
+}
+
+/**
+ * tx4939_ide_init - initialize TX4939 IDE function
+ * @ch: TX4939-ATA controller channel
+ *
+ */
+void __init tx4939_ide_init(int ch)
+{
+	hw_regs_t hw;
+	int i, idx;
+	int offsets[IDE_NR_PORTS];
+	void *base;
+	ide_hwif_t *hwif;
+	unsigned long dma_base;
+
+	for (i = 0; i < 8; i++)
+		offsets[i] = i;
+
+	offsets[IDE_CONTROL_OFFSET] = TX4939_ATA_ALT_STATUS_OFFSET;
+	base = (void *)(TX4939_ATA_REG(ch) - mips_io_port_base);
+
+	memset(&hw, 0, sizeof(hw));
+
+	ide_setup_ports(&hw, (unsigned long)base, offsets,
+			0, 0, tx4939_ide_intr, TX4939_IRQ_ATA(ch));
+
+	idx = ide_register_hw(&hw, NULL);
+	if (idx == -1) {
+		printk(KERN_ERR "%s: IDE I/F register failed\n", __FILE__);
+		return;
+	}
+
+	hwif = &ide_hwifs[idx];
+	printk(KERN_INFO "%s: TX4939 IDE interface\n", hwif->name);
+
+	/* set hwif functions */
+	hwif->chipset = ide_tx4939;
+	hwif->tuneproc = tx4939_ide_tune_drive;
+	hwif->speedproc = tx4939_ide_tune_chipset;
+
+	hwif->ultra_mask = 0x7f;
+	hwif->mwdma_mask = 0x07;
+	hwif->swdma_mask = 0x07;
+
+	hwif->mmio = 0;
+
+	/* cable(PDIAGN) check */
+	if (!(hwif->udma_four)) {
+		unsigned int pdiagn;
+		/* bit13(PDIAGN) = 0:(80pin cable) 1:(40pin cable) */
+		pdiagn = (reg_rd16(&tx4939_ataptr(ch)->sysctl1) & TX4939_ATA_SC_PDIAGN);
+		hwif->udma_four = pdiagn ? 0 : 1;
+	}
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	hwif->autodma = 1;
+	hwif->atapi_dma = 1;
+	hwif->ide_dma_check = &tx4939_ide_dma_check;
+	hwif->dma_setup = &tx4939_ide_dma_setup;
+	hwif->ide_dma_test_irq = &tx4939_ide_dma_test_irq;
+	hwif->ide_dma_end = &tx4939_ide_dma_end;
+	hwif->atapi_output_bytes = &tx4939_ide_atapi_output_bytes;
+	dma_base = TX4939_ATA_REG(ch) + TX4939_ATA_DMA_BASE_OFFSET  - mips_io_port_base;
+	ide_setup_dma(hwif, dma_base, 8);
+#endif	/*CONFIG_BLK_DEV_IDEDMA */
+}
+
Index: linux-2.6.10/drivers/mtd/maps/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/Kconfig
+++ linux-2.6.10/drivers/mtd/maps/Kconfig
@@ -301,6 +301,12 @@ config MTD_LASAT
 	help
 	  Support for the flash chips on the Lasat 100 and 200 boards.
 
+config MTD_TX4939
+	tristate "Flash chip mapping on TX4939 board"
+	depends on TOSHIBA_RBTX4939
+	help
+	  Flash memory access on Toshiba RBTX4939 Reference Boards
+
 config MTD_NETtel
 	tristate "CFI flash device on SnapGear/SecureEdge"
 	depends on X86 && MTD_PARTITIONS && MTD_JEDECPROBE
Index: linux-2.6.10/drivers/mtd/maps/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/maps/Makefile
+++ linux-2.6.10/drivers/mtd/maps/Makefile
@@ -73,3 +73,4 @@ obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+obj-$(CONFIG_MTD_TX4939)        += tx4939-flash.o
\ No newline at end of file
Index: linux-2.6.10/drivers/mtd/maps/tx4939-flash.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/maps/tx4939-flash.c
@@ -0,0 +1,278 @@
+/*
+ * drivers/mtd/maps/tx4939-flash.c
+ *
+ * Mapping of flash on RBTX4939 board.
+ *
+ * Based on cstm_mips_ixx.c by MontaVista Software Inc.
+ *
+ * Author: source@mvista.com
+ *
+ * Copyright (C) 2000-2001,2005 Toshiba Corporation
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/bootinfo.h>
+
+/* board and partition description */
+
+#define MAX_PHYSMAP_PARTITIONS	4
+struct tx4939_info {
+	char *name;
+	unsigned long window_addr;
+	unsigned long window_size;
+	int buswidth;
+	char *drvname;
+	struct mtd_info *mtd_info;
+#ifdef CONFIG_MTD_PARTITIONS
+	int num_partitions;
+	char *part_names[MAX_PHYSMAP_PARTITIONS];
+	struct mtd_partition partitions[MAX_PHYSMAP_PARTITIONS];
+#endif
+};
+
+#define PHYSMAP_NUMBER  8	/* number of board desc structs needed, one per contiguous flash type */
+static struct tx4939_info tx4939_desc[PHYSMAP_NUMBER];
+static struct map_info tx4939_maps[PHYSMAP_NUMBER];
+
+int __init init_txmtd(void)
+{
+	int i;
+	struct mtd_info *mymtd = NULL;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+	int j;
+#endif
+
+	/* tx4939_desc[] is initialized by early_txmtd_setup() */
+	/* Initialize mapping */
+	for (i = 0; i < PHYSMAP_NUMBER; i++) {
+		if (!tx4939_desc[i].name)
+			continue;
+		pr_debug("tx4939 flash device: probe %lx at %lx\n",
+		       tx4939_desc[i].window_size, tx4939_desc[i].window_addr);
+		printk(KERN_INFO "tx4939 flash device: probe %lx at %lx\n",
+		       tx4939_desc[i].window_size, tx4939_desc[i].window_addr);
+		tx4939_maps[i].phys = tx4939_desc[i].window_addr;
+		tx4939_maps[i].virt =
+		    (unsigned long)ioremap(tx4939_desc[i].window_addr,
+					   tx4939_desc[i].window_size);
+		if (!tx4939_maps[i].virt) {
+			printk(KERN_WARNING "Failed to ioremap\n");
+			return -EIO;
+		}
+		tx4939_maps[i].name = tx4939_desc[i].name;
+		tx4939_maps[i].size = tx4939_desc[i].window_size;
+		tx4939_maps[i].bankwidth = tx4939_desc[i].buswidth;
+		simple_map_init(&tx4939_maps[i]);
+		pr_debug("tx4939: ioremap is %x\n", (unsigned int)(tx4939_maps[i].virt));
+	}
+
+	for (i = 0; i < PHYSMAP_NUMBER; i++) {
+		struct tx4939_info *txinfo = &tx4939_desc[i];
+		if (!tx4939_maps[i].name)
+			continue;
+		if (txinfo->drvname) {
+			/* probe only specified chipdriver */
+			mymtd =
+			    (struct mtd_info *)do_map_probe(txinfo->drvname,
+							    &tx4939_maps[i]);
+		} else {
+			/* probe cfi then try jedec */
+			mymtd =
+			    (struct mtd_info *)do_map_probe("cfi_probe",
+							    &tx4939_maps[i]);
+			pr_debug("phymap %d cfi_probe: mymtd is %x\n", i, (unsigned int)mymtd);
+			if (!mymtd) {
+				mymtd =
+				    (struct mtd_info *)
+				    do_map_probe("jedec_probe",
+						 &tx4939_maps[i]);
+				pr_debug("tx4939 %d jedec: mymtd is %x\n", i, (unsigned int)mymtd);
+			}
+		}
+		if (!mymtd)
+			continue;
+		mymtd->owner = THIS_MODULE;
+		/* true map size */
+		tx4939_maps[i].size = mymtd->size;
+		/* If this window contains boot vector, adjust the map area.
+		 * 1f000000-1f3fffff to 1fc00000-1fffffff,
+		 * 1f000000-1f7fffff to 1f800000-1fffffff, etc. */
+		if (txinfo->window_addr <= 0x1fc00000 &&
+		    txinfo->window_addr + txinfo->window_size > 0x1fc00000) {
+			txinfo->window_addr =
+			    0x1fc00000 / tx4939_maps[i].size *
+			    tx4939_maps[i].size;
+			iounmap((void *)tx4939_maps[i].virt);
+			tx4939_maps[i].virt =
+			    (unsigned long)ioremap(txinfo->window_addr,
+						   tx4939_maps[i].size);
+		}
+		printk(KERN_NOTICE "tx4939 flash device(%s): %lx at %lx\n",
+		       tx4939_maps[i].name, tx4939_maps[i].size,
+		       txinfo->window_addr);
+		txinfo->mtd_info = mymtd;
+		tx4939_maps[i].map_priv_2 = 1;	/* mark invalidate */
+#ifdef CONFIG_MTD_PARTITIONS
+		parts = &txinfo->partitions[0];
+		if (txinfo->num_partitions == 0) {
+			/* initialize txinfo->partitions[] */
+			if (txinfo->window_addr < 0x1fc00000 &&
+			    txinfo->window_addr + mymtd->size > 0x1fc00000) {
+				/* split boot mtd device */
+				parts[0].offset =
+				    0x1fc00000 - txinfo->window_addr;
+				parts[0].size =
+				    txinfo->window_addr + mymtd->size -
+				    0x1fc00000;
+				parts[1].offset = 0;
+				parts[1].size =
+				    0x1fc00000 - txinfo->window_addr;
+				txinfo->num_partitions = 2;
+			} else {
+				parts->size = txinfo->window_size;
+				txinfo->num_partitions = 1;
+			}
+		}
+		for (j = 0; j < txinfo->num_partitions; j++) {
+			int isboot =
+			    (txinfo->window_addr + parts[j].offset
+			     == 0x1fc00000);
+			char buf[128];
+			if (parts[j].name)
+				strcpy(buf, parts[j].name);
+			else if (txinfo->num_partitions == 1)
+				strcpy(buf, mymtd->name);
+			else
+				sprintf(buf, "%s (part%d)", mymtd->name, j);
+			if (isboot)
+				strcat(buf, " (boot)");
+			txinfo->part_names[j] =
+			    kmalloc(strlen(buf) + 1, GFP_KERNEL);
+			if (txinfo->part_names[j]) {
+				strcpy(txinfo->part_names[j], buf);
+				parts[j].name = txinfo->part_names[j];
+			} else {
+				parts[j].name = mymtd->name;
+			}
+		}
+		add_mtd_partitions(mymtd, parts, txinfo->num_partitions);
+#else
+		add_mtd_device(mymtd);
+#endif
+	}
+	if (!mymtd)
+		return -ENXIO;
+	return 0;
+}
+
+static void __exit cleanup_txmtd(void)
+{
+	int i, j;
+	struct mtd_info *mymtd;
+
+	for (i = 0; i < PHYSMAP_NUMBER; i++) {
+		mymtd = tx4939_desc[i].mtd_info;
+		if (mymtd) {
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(mymtd);
+#else
+			del_mtd_device(mymtd);
+#endif
+			map_destroy(mymtd);
+		}
+		if (tx4939_maps[i].virt) {
+			iounmap((void *)tx4939_maps[i].virt);
+			tx4939_maps[i].virt = 0;
+		}
+#ifdef CONFIG_MTD_PARTITIONS
+		for (j = 0; j < MAX_PHYSMAP_PARTITIONS; j++) {
+			if (tx4939_desc[i].part_names[j])
+				kfree(tx4939_desc[i].part_names[j]);
+			tx4939_desc[i].part_names[j] = 0;
+		}
+#endif
+	}
+}
+
+module_init(init_txmtd);
+module_exit(cleanup_txmtd);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for TX boards");
+
+#ifndef MODULE
+int __init early_txmtd_setup(int no, char *name,
+			     unsigned long addr, unsigned long size,
+			     int buswidth, int num_partitions,
+			     struct mtd_partition *parts, char *drvname)
+{
+	int i;
+	if (no < 0 || no >= PHYSMAP_NUMBER)
+		return -EINVAL;
+	if (num_partitions < 0 || num_partitions >= MAX_PHYSMAP_PARTITIONS)
+		return -EINVAL;
+	tx4939_desc[no].name = name;
+	tx4939_desc[no].window_addr = addr;
+	tx4939_desc[no].window_size = size;
+	tx4939_desc[no].buswidth = buswidth;
+#ifdef CONFIG_MTD_PARTITIONS
+	tx4939_desc[no].num_partitions = num_partitions;
+	for (i = 0; i < num_partitions; i++)
+		tx4939_desc[no].partitions[i] = parts[i];
+#endif
+	tx4939_desc[no].drvname = drvname;
+	return 0;
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+/* mtdpart=SZ[@[OFS]][+SZ[@[OFS]]]...[,SZ[@[OFS]][+SZ[@[OFS]]]...]... */
+static int __init txmtd_part_setup(char *str)
+{
+	char buf[128];
+	char *p1, *p2, *s;
+	int i, j;
+
+	strncpy(buf, str, sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = 0;
+	p1 = buf;
+	/* for each mtd device... */
+	for (i = 0; p1 && i < PHYSMAP_NUMBER; i++) {
+		p2 = strsep(&p1, ",");
+		if (!*p2)
+			continue;	/* keep early configurations */
+		memset(tx4939_desc[i].partitions, 0,
+		       sizeof(tx4939_desc[i].partitions));
+		/* for each mtd partition... */
+		for (j = 0; p2 && j < MAX_PHYSMAP_PARTITIONS; j++) {
+			struct mtd_partition *part;
+			s = strsep(&p2, "+");
+			part = &tx4939_desc[i].partitions[j];
+			part->size = memparse(s, &s);
+			part->offset = (*s == '@') ?
+			    memparse(s + 1, &s) : MTDPART_OFS_NXTBLK;
+		}
+		tx4939_desc[i].num_partitions = j;
+	}
+	return 1;
+}
+
+__setup("mtdpart=", txmtd_part_setup);
+#endif				/* CONFIG_MTD_PARTITIONS */
+#endif				/* !MODULE */
Index: linux-2.6.10/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/Kconfig
+++ linux-2.6.10/drivers/mtd/nand/Kconfig
@@ -85,6 +85,13 @@ config MTD_NAND_TX4938NDFMC
 	  This enables the driver for the NAND flash device found on the
 	  Toshiba RBTX4938 reference board.
 
+config MTD_NAND_TX4939NDFMC
+	tristate "NAND Flash device on Toshiba RBTX4939 reference board"
+	depends on TOSHIBA_RBTX4939 && MTD_NAND
+	help
+	  This enables the driver for the NAND flash device found on the
+	  Toshiba RBTX4939 reference board.
+
 config MTD_NAND_AU1550
 	tristate "Au1550 NAND support"
 	depends on SOC_AU1550 && MTD_NAND
Index: linux-2.6.10/drivers/mtd/nand/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/mtd/nand/Makefile
+++ linux-2.6.10/drivers/mtd/nand/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_MTD_NAND_AUTCPU12)		+= autc
 obj-$(CONFIG_MTD_NAND_EDB7312)		+= edb7312.o
 obj-$(CONFIG_MTD_NAND_TX4925NDFMC)	+= tx4925ndfmc.o
 obj-$(CONFIG_MTD_NAND_TX4938NDFMC)	+= tx4938ndfmc.o
+obj-$(CONFIG_MTD_NAND_TX4939NDFMC)	+= tx4939ndfmc.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
Index: linux-2.6.10/drivers/mtd/nand/tx4939ndfmc.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/mtd/nand/tx4939ndfmc.c
@@ -0,0 +1,592 @@
+/*
+ * drivers/mtd/nand/tx4939ndfmc.c
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device connected to
+ *   TX4939 internal NAND Memory Controller.
+ *   TX4939 NDFMC is almost same as TX4938 NDFMC.
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ *
+ * Author: source@mvista.com
+ *
+ * Based on spia.c by Steven J. Hill
+ *
+ * $Id: tx4939ndfmc.c,v 1.1.2.8.2.1 2005/08/04 12:09:00 issey Exp $
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+#include <linux/config.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <asm/tx4939/tx4939.h>
+
+/*
+ * Configuration
+ */
+#define USE_DMA
+#define TRANSFER_SIZE_512BYTE
+
+#ifdef TRANSFER_SIZE_512BYTE
+#define TRANSFER_SIZE	512
+#else
+#define TRANSFER_SIZE	256
+#endif
+
+extern struct nand_oobinfo jffs2_oobinfo;
+
+/*
+ * MTD structure for TX4939 NDFMC
+ */
+static struct mtd_info *tx4939ndfmc_mtd;
+
+/*
+ * Define partitions for flash device
+ */
+#define flush_wb()	reg_rd16(&tx4939_ndfmcptr->mcr);
+
+#define NUM_PARTITIONS  	1
+#define NUMBER_OF_CIS_BLOCKS	24
+#define SIZE_OF_BLOCK		0x00004000
+#define NUMBER_OF_BLOCK_PER_ZONE 1024
+#define SIZE_OF_ZONE		(NUMBER_OF_BLOCK_PER_ZONE * SIZE_OF_BLOCK)
+#ifndef CONFIG_MTD_CMDLINE_PARTS
+
+static struct mtd_partition partition_info[NUM_PARTITIONS] = {
+	{
+	 .name = "TX4939 NAND",
+	 .offset = 0,
+	 .size = MTDPART_SIZ_FULL,
+	 },
+};
+#endif
+
+/**
+ * tx4939ndfmc_hwcontrol - send command to NDFMC
+ * @mtd_info: device information
+ * @cmd: command to send to NDFMC
+ *
+ */
+static void tx4939ndfmc_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	u16 s = reg_rd16(&tx4939_ndfmcptr->mcr);
+	switch (cmd) {
+	case NAND_CTL_SETCLE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s | TX4939_NDFMCR_CLE);
+		break;
+	case NAND_CTL_CLRCLE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s & ~TX4939_NDFMCR_CLE);
+		break;
+	case NAND_CTL_SETALE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s | TX4939_NDFMCR_ALE);
+		break;
+	case NAND_CTL_CLRALE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s & ~TX4939_NDFMCR_ALE);
+		break;
+		/* TX4939_NDFMCR_CE bit is 0:high 1:low */
+	case NAND_CTL_SETNCE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s | TX4939_NDFMCR_CE);
+		break;
+	case NAND_CTL_CLRNCE:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s & ~TX4939_NDFMCR_CE);
+		break;
+	case NAND_CTL_SETWP:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s | TX4939_NDFMCR_WE);
+		break;
+	case NAND_CTL_CLRWP:
+		reg_wr16(&tx4939_ndfmcptr->mcr, s & ~TX4939_NDFMCR_WE);
+		break;
+	}
+}
+
+/**
+ * tx4939ndfmc_dev_ready - return NDFMC status
+ * @mtd: device information
+ *
+ */
+static int tx4939ndfmc_dev_ready(struct mtd_info *mtd)
+{
+	flush_wb();
+	return !(reg_rd16(&tx4939_ndfmcptr->sr) & TX4939_NDFSR_BUSY);
+}
+
+/**
+ * tx4939ndfmc_calculate_ecc - read ecc data
+ * @mtd: device information
+ * @dat:
+ * @ecc_code: ecc data
+ *
+ */
+static int
+tx4939ndfmc_calculate_ecc(struct mtd_info *mtd, const u_char * dat,
+			  u_char * ecc_code)
+{
+	u16 mcr = reg_rd16(&tx4939_ndfmcptr->mcr);
+	mcr &= ~TX4939_NDFMCR_ECC_ALL;
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_DISABLE);
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_READ);
+	ecc_code[1] = reg_rd16(&tx4939_ndfmcptr->dtr);
+	ecc_code[0] = reg_rd16(&tx4939_ndfmcptr->dtr);
+	ecc_code[2] = reg_rd16(&tx4939_ndfmcptr->dtr);
+#ifdef TRANSFER_SIZE_512BYTE
+	ecc_code[4] = reg_rd16(&tx4939_ndfmcptr->dtr);
+	ecc_code[3] = reg_rd16(&tx4939_ndfmcptr->dtr);
+	ecc_code[5] = reg_rd16(&tx4939_ndfmcptr->dtr);
+#endif
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_DISABLE);
+
+	return 0;
+}
+
+/**
+ * tx4939ndfmc_enable_hwecc - enable hardware ecc
+ * @mtd: device information
+ * @mode:
+ *
+ */
+static void tx4939ndfmc_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u32 mcr = reg_rd16(&tx4939_ndfmcptr->mcr);
+	mcr &= ~TX4939_NDFMCR_ECC_ALL;
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_RESET);
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_DISABLE);
+	reg_wr16(&tx4939_ndfmcptr->mcr, mcr | TX4939_NDFMCR_ECC_ENABLE);
+}
+
+/**
+ * tx4939ndfmc_nand_read_byte - read 1-byte data from NDFMC
+ * @mtd: device information
+ *
+ */
+static u_char tx4939ndfmc_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	return tx4939_read_nfmc(this->IO_ADDR_R);
+}
+
+/**
+ * tx4939ndfmc_nand_write_byte - write 1-byte data to NDFMC
+ * @mtd: device information
+ * @byte: data to write
+ *
+ */
+static void tx4939ndfmc_nand_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *this = mtd->priv;
+	tx4939_write_nfmc(byte, this->IO_ADDR_W);
+}
+
+/**
+ * dma_irq_handler - interrupt handler for dma transfer
+ * @irq: interrupt request number
+ * @dev_id:
+ * @regs:
+ *
+ */
+#ifdef USE_DMA
+static unsigned int interrupt_flag = 0;
+static DECLARE_WAIT_QUEUE_HEAD(txx9_dma_wait);
+static irqreturn_t dma_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32 l;
+	/* clear DMA interrupt status */
+	l = reg_rd32(&tx4939_dmacptr(0)->ch[3].csr);
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].csr, l | TX4939_DMCSR_NTRNFC);
+	interrupt_flag = 1;
+	wake_up(&txx9_dma_wait);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/**
+ * tx4939ndfmc_nand_write_buf - write data to NDFMC
+ * @mtd: device information
+ * @buf: data to write
+ * @len: length of data
+ *
+ */
+static void
+tx4939ndfmc_nand_write_buf(struct mtd_info *mtd, const u_char * buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		tx4939_write_nfmc(buf[i], this->IO_ADDR_W);
+}
+
+/**
+ * tx4939ndfmc_nand_read_buf - read data from NDFMC
+ * @mtd: device information
+ * @buf: read data
+ * @len: length of data
+ *
+ */
+static void
+tx4939ndfmc_nand_read_buf(struct mtd_info *mtd, u_char * buf, int len)
+{
+	int i;
+	u32 l;
+	u16 s;
+	struct nand_chip *this = mtd->priv;
+
+#ifdef USE_DMA
+	/* To use DMA, buf must be alined with 8byte */
+	if (len == TRANSFER_SIZE && ((unsigned long)buf & 7) == 0) {
+		dma_cache_inv((unsigned long)buf, len);
+		reg_wr32(&tx4939_dmacptr(0)->ch[3].cntr, TRANSFER_SIZE);
+		reg_wr32(&tx4939_dmacptr(0)->ch[3].sar, CPHYSADDR(buf));
+		l = reg_rd32(&tx4939_dmacptr(0)->ch[3].ccr);
+		reg_wr32(&tx4939_dmacptr(0)->ch[3].ccr, l | TX4939_DMCCR_XFACT);
+
+		s = reg_rd16(&tx4939_ndfmcptr->mcr);
+#ifdef TRANSFER_SIZE_512BYTE
+		reg_wr16(&tx4939_ndfmcptr->mcr, s|TX4939_NDFMCR_DMAREQ_512BYTE);
+#else
+		reg_wr16(&tx4939_ndfmcptr->mcr, s|TX4939_NDFMCR_DMAREQ_256BYTE);
+#endif
+		wait_event_interruptible(txx9_dma_wait, interrupt_flag);
+		interrupt_flag = 0;
+		return;
+	}
+#endif
+	for (i = 0; i < len; i++)
+		buf[i] = tx4939_read_nfmc(this->IO_ADDR_R);
+}
+
+/**
+ * tx4939ndfmc_nand_verify_buf - verify data
+ * @mtd: device information
+ * @buf: data to compare
+ * @len: length of data
+ *
+ */
+static int
+tx4939ndfmc_nand_verify_buf(struct mtd_info *mtd, const u_char * buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i = 0; i < len; i++)
+		if (buf[i] != tx4939_read_nfmc(this->IO_ADDR_R))
+			return i;
+
+	return 0;
+}
+
+/**
+ * tx4939ndfmc_nand_command - send command to NAND device
+ * @mtd: device information
+ * @cmd: command to send to NAND device
+ * @column:
+ * @page_addr:
+ */
+static void
+tx4939ndfmc_nand_command(struct mtd_info *mtd, unsigned command, int column,
+			 int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/* Begin command latch cycle */
+	this->hwcontrol(mtd, NAND_CTL_SETCLE);
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command == NAND_CMD_SEQIN) {
+		int readcmd;
+
+		if (column >= mtd->oobblock) {
+			/* OOB area */
+			column -= mtd->oobblock;
+			readcmd = NAND_CMD_READOOB;
+		} else if (column < 256) {
+			/* First 256 bytes --> READ0 */
+			readcmd = NAND_CMD_READ0;
+		} else {
+			column -= 256;
+			readcmd = NAND_CMD_READ1;
+		}
+		this->write_byte(mtd, readcmd);
+	}
+	this->write_byte(mtd, command);
+
+	/* Set ALE and clear CLE to start address cycle */
+	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+
+	if (column != -1 || page_addr != -1) {
+		this->hwcontrol(mtd, NAND_CTL_SETALE);
+
+		/* Serially input address */
+		if (column != -1)
+			this->write_byte(mtd, column);
+		if (page_addr != -1) {
+			this->write_byte(mtd,
+					 (unsigned char)(page_addr & 0xff));
+			this->write_byte(mtd,
+					 (unsigned char)((page_addr >> 8) &
+							 0xff));
+			/* One more address cycle for higher density devices */
+			if (mtd->size & 0x0c000000)
+				this->write_byte(mtd,
+						 (unsigned
+						  char)((page_addr >> 16) &
+							0x0f));
+		}
+		/* Latch in address */
+		this->hwcontrol(mtd, NAND_CTL_CLRALE);
+	}
+
+	/*
+	 * program and erase have their own busy handlers
+	 * status and sequential in needs no delay
+	 */
+	switch (command) {
+
+	case NAND_CMD_PAGEPROG:
+		/* Turn off WE */
+		this->hwcontrol(mtd, NAND_CTL_CLRWP);
+		return;
+
+	case NAND_CMD_SEQIN:
+		/* Turn on WE */
+		this->hwcontrol(mtd, NAND_CTL_SETWP);
+		return;
+
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_STATUS:
+		return;
+
+	case NAND_CMD_RESET:
+		if (this->dev_ready)
+			break;
+		this->hwcontrol(mtd, NAND_CTL_SETCLE);
+		this->write_byte(mtd, NAND_CMD_STATUS);
+		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+		while (!(this->read_byte(mtd) & 0x40)) ;
+		return;
+
+		/* This applies to read commands */
+	default:
+		/*
+		 * If we don't have access to the busy pin, we apply the given
+		 * command delay
+		 */
+		if (!this->dev_ready) {
+			udelay(this->chip_delay);
+			return;
+		}
+	}
+
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd)) ;
+}
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+extern int parse_cmdline_partitions(struct mtd_info *master,
+				    struct mtd_partition **pparts, char *);
+#endif
+extern void rbtx4939_get_tx4939_nandc_parameter(int *hold, int *spw);
+
+/**
+ * tx4939ndfmc_init - main initialization routine
+ *
+ */
+int __init tx4939ndfmc_init(void)
+{
+	struct nand_chip *this;
+	int bsprt = 0, hold = 0xf, spw = 0xf;
+	int protected = 0;
+	u64 q;
+	u32 l;
+	int ret;
+
+	bsprt = 1;
+
+	/* reset NDFMC */
+	q = reg_rd64(&tx4939_ccfgptr->clkctr);
+	reg_wr64(&tx4939_ccfgptr->clkctr, q | TX4939_CLKCTR_NDCRST);
+	udelay(1);		/* wait 128 CPU clocks (2.5ns * 128 = 320ns) */
+	q = reg_rd64(&tx4939_ccfgptr->clkctr);
+	reg_wr64(&tx4939_ccfgptr->clkctr, q & ~TX4939_CLKCTR_NDCRST);
+	udelay(1);		/* wait 128 CPU clocks (2.5ns * 128 = 320ns) */
+	reg_wr16(&tx4939_ndfmcptr->sr, 0);
+	reg_wr16(&tx4939_ndfmcptr->dtr, 0);
+
+	/* setup BusSeparete */
+	reg_wr16(&tx4939_ndfmcptr->mcr, bsprt ? TX4939_NDFMCR_BSPRT : 0);
+	/* setup  Hold Time, Strobe Pulse Width */
+	rbtx4939_get_tx4939_nandc_parameter(&hold, &spw);
+	reg_wr16(&tx4939_ndfmcptr->spr, hold << 4 | spw);
+
+#ifdef USE_DMA
+	/* Initialize DMAC */
+	reg_wr32(&tx4939_dmacptr(0)->mcr, TX4939_DMMCR_RSFIF | TX4939_DMMCR_MSTEN);
+	reg_wr32(&tx4939_dmacptr(0)->mcr, TX4939_DMMCR_MSTEN);
+
+	q = reg_rd64(&tx4939_ccfgptr->pcfg);
+	reg_wr64(&tx4939_ccfgptr->pcfg, q & ~TX4939_PCFG_DMASEL3_MASK);
+
+	l = reg_rd32(&tx4939_dmacptr(0)->ch[3].ccr);
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].ccr, l |TX4939_DMCCR_CHRST);
+	l = reg_rd32(&tx4939_dmacptr(0)->ch[3].ccr);
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].ccr, l & (~TX4939_DMCCR_CHRST));
+	l = reg_rd32(&tx4939_dmacptr(0)->ch[3].ccr);
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].ccr, l | (TX4939_DMCCR_XFSZ_8BYTE
+						     | TX4939_DMCCR_SNGAD | TX4939_DMCCR_EXTRQ));
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].sair, 8);
+	ret = request_irq(TX4939_IRQ_DMA0(3), dma_irq_handler, SA_INTERRUPT,
+			  "DMAC-INT", NULL);
+	if (ret) {
+		printk(KERN_ERR "tx4939 nand: cannot register IRQ %d\n", TX4939_IRQ_DMA0(3)) ;
+		return -EIO;
+
+	}
+
+	interrupt_flag = 0;
+	l = reg_rd32(&tx4939_dmacptr(0)->ch[3].ccr);
+	reg_wr32(&tx4939_dmacptr(0)->ch[3].ccr, l | TX4939_DMCCR_INTENT);
+#endif
+
+	/* Allocate memory for MTD device structure and private data */
+	tx4939ndfmc_mtd =
+	    kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip),
+		    GFP_KERNEL);
+	if (!tx4939ndfmc_mtd) {
+		printk
+		    (KERN_ERR "Unable to allocate TX4939 NDFMC MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *)(&tx4939ndfmc_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *)tx4939ndfmc_mtd, 0, sizeof(struct mtd_info));
+	memset((char *)this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	tx4939ndfmc_mtd->priv = this;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = (unsigned long)&tx4939_ndfmcptr->dtr;
+	this->IO_ADDR_W = (unsigned long)&tx4939_ndfmcptr->dtr;
+	this->hwcontrol = tx4939ndfmc_hwcontrol;
+	this->dev_ready = tx4939ndfmc_dev_ready;
+	this->calculate_ecc = tx4939ndfmc_calculate_ecc;
+	this->correct_data = nand_correct_data;
+	this->enable_hwecc = tx4939ndfmc_enable_hwecc;
+#ifdef TRANSFER_SIZE_512BYTE
+	this->eccmode = NAND_ECC_HW6_512;
+#else
+	this->eccmode = NAND_ECC_HW3_256;
+#endif
+	this->chip_delay = 100;
+	this->read_byte = tx4939ndfmc_nand_read_byte;
+	this->write_byte = tx4939ndfmc_nand_write_byte;
+	this->cmdfunc = tx4939ndfmc_nand_command;
+	this->write_buf = tx4939ndfmc_nand_write_buf;
+	this->read_buf = tx4939ndfmc_nand_read_buf;
+	this->verify_buf = tx4939ndfmc_nand_verify_buf;
+
+	/* Scan to find existance of the device */
+	if (nand_scan(tx4939ndfmc_mtd, 1)) {
+		kfree(tx4939ndfmc_mtd);
+		return -ENXIO;
+	}
+
+	/* Allocate memory for internal data buffer */
+	this->data_buf =
+	    kmalloc(sizeof(u_char) *
+		    (tx4939ndfmc_mtd->oobblock + tx4939ndfmc_mtd->oobsize),
+		    GFP_KERNEL);
+	if (!this->data_buf) {
+		printk(KERN_ERR "Unable to allocate NAND data buffer for TX4939.\n");
+		kfree(tx4939ndfmc_mtd);
+		return -ENOMEM;
+	}
+
+	if (protected) {
+		printk(KERN_INFO "TX4939 NDFMC: write protected.\n");
+		tx4939ndfmc_mtd->flags &= ~(MTD_WRITEABLE | MTD_ERASEABLE);
+	}
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	{
+		int mtd_parts_nb = 0;
+		struct mtd_partition *mtd_parts = 0;
+		mtd_parts_nb =
+		    parse_cmdline_partitions(tx4939ndfmc_mtd, &mtd_parts,
+					     "tx4939ndfmc");
+		if (mtd_parts_nb > 0)
+			add_mtd_partitions(tx4939ndfmc_mtd, mtd_parts,
+					   mtd_parts_nb);
+		else
+			add_mtd_device(tx4939ndfmc_mtd);
+	}
+#else
+	add_mtd_partitions(tx4939ndfmc_mtd, partition_info, NUM_PARTITIONS);
+#endif
+
+	return 0;
+}
+
+module_init(tx4939ndfmc_init);
+
+/**
+ * tx4939ndfmc_cleanup - clean up routine
+ *
+ */
+static void __exit tx4939ndfmc_cleanup(void)
+{
+	struct nand_chip *this = (struct nand_chip *)tx4939ndfmc_mtd->priv;
+
+	/* Unregister the device */
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	del_mtd_partitions(tx4939ndfmc_mtd);
+#endif
+	del_mtd_device(tx4939ndfmc_mtd);
+
+	/* Free the MTD device structure */
+	kfree(tx4939ndfmc_mtd);
+
+	/* Free internal data buffer */
+	kfree(this->data_buf);
+}
+
+module_exit(tx4939ndfmc_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Alice Hennessy <ahennessy@mvista.com>");
+MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on TX4939 NDFMC");
Index: linux-2.6.10/drivers/net/Kconfig
===================================================================
--- linux-2.6.10.orig/drivers/net/Kconfig
+++ linux-2.6.10/drivers/net/Kconfig
@@ -821,7 +821,7 @@ config SMC91X
 	tristate "SMC 91C9x/91C1xxx support"
 	select CRC32
 	select MII
-	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R)
+	depends on NET_ETHERNET && (ARM || REDWOOD_5 || REDWOOD_6 || M32R || MIPS)
 	help
 	  This is a driver for SMC's 91x series of Ethernet chipsets,
 	  including the SMC91C94 and the SMC91C111. Say Y if you want it
@@ -1410,6 +1410,10 @@ config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && TOSHIBA_JMR3927
 
+config TC35815_1
+	tristate "TOSHIBA TC35815 Ethernet support"
+	depends on NET_PCI && PCI && TOSHIBA_RBTX4939
+
 config DGRS
 	tristate "Digi Intl. RightSwitch SE-X support"
 	depends on NET_PCI && (PCI || EISA)
Index: linux-2.6.10/drivers/net/Makefile
===================================================================
--- linux-2.6.10.orig/drivers/net/Makefile
+++ linux-2.6.10/drivers/net/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_STNIC) += stnic.o 8390.o
 obj-$(CONFIG_FEALNX) += fealnx.o
 obj-$(CONFIG_TIGON3) += tg3.o
 obj-$(CONFIG_TC35815) += tc35815.o
+obj-$(CONFIG_TC35815_1) += tc35815_1.o
 obj-$(CONFIG_SK98LIN) += sk98lin/
 obj-$(CONFIG_SKFP) += skfp/
 obj-$(CONFIG_VIA_RHINE) += via-rhine.o
Index: linux-2.6.10/drivers/net/smc91x.h
===================================================================
--- linux-2.6.10.orig/drivers/net/smc91x.h
+++ linux-2.6.10/drivers/net/smc91x.h
@@ -182,6 +182,41 @@ SMC_outw(u16 val, unsigned long ioaddr, 
 #define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
 #define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
 
+#elif	defined(CONFIG_TOSHIBA_RBTX4939)
+
+#define IRQT_RISING 0
+#define set_irq_type(irq, type)	do {} while(0)
+
+#define SMC_CAN_USE_8BIT	0
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	0
+
+#define SMC_inw(a, r)		le16_to_cpu(readw((a) + (r)))
+#define SMC_outw(v, a, r)	writew(le16_to_cpu(v), (a) + (r))
+#define SMC_insw(a, r, p, l) 						\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		readsw(__port, __p, __l);				\
+		while (__l > 0) {					\
+			*__p = le16_to_cpu(*__p);			\
+			__p++;						\
+			__l--;						\
+		}							\
+	} while (0)
+#define SMC_outsw(a, r, p, l) 						\
+	do {								\
+		unsigned long __port = (a) + (r);			\
+		u16 *__p = (u16 *)(p);					\
+		int __l = (l);						\
+		while (__l > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			writew( /* swab16 */ (*__p++), __port);		\
+			__l--;						\
+		}							\
+	} while (0)
+
 #elif	defined(CONFIG_ISA)
 
 #define SMC_CAN_USE_8BIT	1
Index: linux-2.6.10/drivers/net/tc35815_1.c
===================================================================
--- /dev/null
+++ linux-2.6.10/drivers/net/tc35815_1.c
@@ -0,0 +1,2622 @@
+/*
+ * tc35815_1.c: A TOSHIBA TC35815CF PCI 10/100Mbps ethernet driver for linux.
+ *
+ * Based on skelton.c by Donald Becker.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * (C) Copyright TOSHIBA CORPORATION 2004-2005
+ * All Rights Reserved.
+ *
+ * There is yet another tc35815 driver (tc35815.c) which is based on
+ * early version of this driver.
+ *
+ *  Revision History:
+ *	1.13	64-bit proof.
+ *	1.14	Do not round-up transmit length.
+ *	1.15	Define TC35815_DMA_SYNC_ONDEMMAND, cleanup.
+ *	1.16	Fix free_page bug introduced in 1.15
+ *	1.17	Add mii/ethtool ioctl support.
+ *		Remove workaround for early TX4938.  Cleanup.
+ *	1.20	Kernel 2.6.
+ *	1.21	Fix receive packet length (omit CRC).
+ *		Call netif_carrier_on/netif_carrier_off.
+ *		Add kernel/module options (speed, duplex, doforce).
+ *		Do not try "force link mode" by default.
+ *		Reconfigure CAM on restarting.
+ *		Reset PHY on restarting.
+ *		Add workaround for 100MHalf HUB.
+ *	1.22	Minor fix.
+ *	1.23	Minor cleanup.
+ */
+
+#define DRV_VERSION	"1.23"
+static const char *version = "tc35815_1.c:v" DRV_VERSION "\n";
+#define MODNAME			"tc35815"
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+/* First, a few definitions that the brave might change. */
+
+#define GATHER_TXINT	/* On-Demand Tx Interrupt */
+#define WORKAROUND_LOSTCAR
+#define WORKAROUND_100HALF_PROMISC
+
+typedef enum {
+	TC35815CF = 0,
+	TC35815_NWU,
+	TX4939_ETHER,
+} board_t;
+
+/* indexed by board_t, above */
+static struct {
+	const char *name;
+} board_info[] __devinitdata = {
+	{ "TOSHIBA TC35815CF 10/100BaseTX" },
+	{ "TOSHIBA TC35815 with Wake on LAN" },
+	{ "TOSHIBA TX4939 ETHERNET" },
+};
+
+static struct pci_device_id tc35815_pci_tbl[] = {
+	{PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC35815CF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TC35815CF },
+	{PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TC35815_NWU, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TC35815_NWU },
+	{PCI_VENDOR_ID_TOSHIBA_2, PCI_DEVICE_ID_TOSHIBA_TX4939_ETHER, PCI_ANY_ID, PCI_ANY_ID, 0, 0, TX4939_ETHER},
+	{0,}
+};
+MODULE_DEVICE_TABLE (pci, tc35815_pci_tbl);
+
+/* see MODULE_PARM_DESC */
+static struct tc35815_options {
+	int speed;
+	int duplex;
+	int doforce;
+} options;
+
+/*
+ * Registers
+ */
+struct tc35815_regs {
+	volatile __u32 DMA_Ctl;		/* 0x00 */
+	volatile __u32 TxFrmPtr;
+	volatile __u32 TxThrsh;
+	volatile __u32 TxPollCtr;
+	volatile __u32 BLFrmPtr;
+	volatile __u32 RxFragSize;
+	volatile __u32 Int_En;
+	volatile __u32 FDA_Bas;
+	volatile __u32 FDA_Lim;		/* 0x20 */
+	volatile __u32 Int_Src;
+	volatile __u32 unused0[2];
+	volatile __u32 PauseCnt;
+	volatile __u32 RemPauCnt;
+	volatile __u32 TxCtlFrmStat;
+	volatile __u32 unused1;
+	volatile __u32 MAC_Ctl;		/* 0x40 */
+	volatile __u32 CAM_Ctl;
+	volatile __u32 Tx_Ctl;
+	volatile __u32 Tx_Stat;
+	volatile __u32 Rx_Ctl;
+	volatile __u32 Rx_Stat;
+	volatile __u32 MD_Data;
+	volatile __u32 MD_CA;
+	volatile __u32 CAM_Adr;		/* 0x60 */
+	volatile __u32 CAM_Data;
+	volatile __u32 CAM_Ena;
+	volatile __u32 PROM_Ctl;
+	volatile __u32 PROM_Data;
+	volatile __u32 Algn_Cnt;
+	volatile __u32 CRC_Cnt;
+	volatile __u32 Miss_Cnt;
+};
+
+/*
+ * Bit assignments
+ */
+/* DMA_Ctl bit asign ------------------------------------------------------- */
+#define DMA_IntMask            0x00040000 /* 1:Interupt mask                 */
+#define DMA_SWIntReq           0x00020000 /* 1:Software Interrupt request    */
+#define DMA_TxWakeUp           0x00010000 /* 1:Transmit Wake Up              */
+#define DMA_RxBigE             0x00008000 /* 1:Receive Big Endian            */
+#define DMA_TxBigE             0x00004000 /* 1:Transmit Big Endian           */
+#define DMA_TestMode           0x00002000 /* 1:Test Mode                     */
+#define DMA_PowrMgmnt          0x00001000 /* 1:Power Management              */
+#define DMA_DmBurst_Mask       0x000001fc /* DMA Burst size                  */
+
+/* RxFragSize bit asign ---------------------------------------------------- */
+#define RxFrag_EnPack          0x00008000 /* 1:Enable Packing                */
+#define RxFrag_MinFragMask     0x00000ffc /* Minimum Fragment                */
+
+/* MAC_Ctl bit asign ------------------------------------------------------- */
+#define MAC_Link10             0x00008000 /* 1:Link Status 10Mbits           */
+#define MAC_EnMissRoll         0x00002000 /* 1:Enable Missed Roll            */
+#define MAC_MissRoll           0x00000400 /* 1:Missed Roll                   */
+#define MAC_Loop10             0x00000080 /* 1:Loop 10 Mbps                  */
+#define MAC_Conn_Auto          0x00000000 /*00:Connection mode (Automatic)   */
+#define MAC_Conn_10M           0x00000020 /*01:                (10Mbps endec)*/
+#define MAC_Conn_Mll           0x00000040 /*10:                (Mll clock)   */
+#define MAC_MacLoop            0x00000010 /* 1:MAC Loopback                  */
+#define MAC_FullDup            0x00000008 /* 1:Full Duplex 0:Half Duplex     */
+#define MAC_Reset              0x00000004 /* 1:Software Reset                */
+#define MAC_HaltImm            0x00000002 /* 1:Halt Immediate                */
+#define MAC_HaltReq            0x00000001 /* 1:Halt request                  */
+
+/* PROM_Ctl bit asign ------------------------------------------------------ */
+#define PROM_Busy              0x00008000 /* 1:Busy (Start Operation)        */
+#define PROM_Read              0x00004000 /*10:Read operation                */
+#define PROM_Write             0x00002000 /*01:Write operation               */
+#define PROM_Erase             0x00006000 /*11:Erase operation               */
+                                          /*00:Enable or Disable Writting,   */
+                                          /*      as specified in PROM_Addr. */
+#define PROM_Addr_Ena          0x00000030 /*11xxxx:PROM Write enable         */
+                                          /*00xxxx:           disable        */
+
+/* CAM_Ctl bit asign ------------------------------------------------------- */
+#define CAM_CompEn             0x00000010 /* 1:CAM Compare Enable            */
+#define CAM_NegCAM             0x00000008 /* 1:Reject packets CAM recognizes,*/
+                                          /*                    accept other */
+#define CAM_BroadAcc           0x00000004 /* 1:Broadcast assept              */
+#define CAM_GroupAcc           0x00000002 /* 1:Multicast assept              */
+#define CAM_StationAcc         0x00000001 /* 1:unicast accept                */
+
+/* CAM_Ena bit asign ------------------------------------------------------- */
+#define CAM_ENTRY_MAX                  21   /* CAM Data entry max count      */
+#define CAM_Ena_Mask ((1<<CAM_ENTRY_MAX)-1) /* CAM Enable bits (Max 21bits)  */
+#define CAM_Ena_Bit(index)         (1<<(index))
+#define CAM_ENTRY_DESTINATION	0
+#define CAM_ENTRY_SOURCE	1
+#define CAM_ENTRY_MACCTL	20
+
+/* Tx_Ctl bit asign -------------------------------------------------------- */
+#define Tx_En                  0x00000001 /* 1:Transmit enable               */
+#define Tx_TxHalt              0x00000002 /* 1:Transmit Halt Request         */
+#define Tx_NoPad               0x00000004 /* 1:Suppress Padding              */
+#define Tx_NoCRC               0x00000008 /* 1:Suppress Padding              */
+#define Tx_FBack               0x00000010 /* 1:Fast Back-off                 */
+#define Tx_EnUnder             0x00000100 /* 1:Enable Underrun               */
+#define Tx_EnExDefer           0x00000200 /* 1:Enable Excessive Deferral     */
+#define Tx_EnLCarr             0x00000400 /* 1:Enable Lost Carrier           */
+#define Tx_EnExColl            0x00000800 /* 1:Enable Excessive Collision    */
+#define Tx_EnLateColl          0x00001000 /* 1:Enable Late Collision         */
+#define Tx_EnTxPar             0x00002000 /* 1:Enable Transmit Parity        */
+#define Tx_EnComp              0x00004000 /* 1:Enable Completion             */
+
+/* Tx_Stat bit asign ------------------------------------------------------- */
+#define Tx_TxColl_MASK         0x0000000F /* Tx Collision Count              */
+#define Tx_ExColl              0x00000010 /* Excessive Collision             */
+#define Tx_TXDefer             0x00000020 /* Transmit Defered                */
+#define Tx_Paused              0x00000040 /* Transmit Paused                 */
+#define Tx_IntTx               0x00000080 /* Interrupt on Tx                 */
+#define Tx_Under               0x00000100 /* Underrun                        */
+#define Tx_Defer               0x00000200 /* Deferral                        */
+#define Tx_NCarr               0x00000400 /* No Carrier                      */
+#define Tx_10Stat              0x00000800 /* 10Mbps Status                   */
+#define Tx_LateColl            0x00001000 /* Late Collision                  */
+#define Tx_TxPar               0x00002000 /* Tx Parity Error                 */
+#define Tx_Comp                0x00004000 /* Completion                      */
+#define Tx_Halted              0x00008000 /* Tx Halted                       */
+#define Tx_SQErr               0x00010000 /* Signal Quality Error(SQE)       */
+
+/* Rx_Ctl bit asign -------------------------------------------------------- */
+#define Rx_EnGood              0x00004000 /* 1:Enable Good                   */
+#define Rx_EnRxPar             0x00002000 /* 1:Enable Receive Parity         */
+#define Rx_EnLongErr           0x00000800 /* 1:Enable Long Error             */
+#define Rx_EnOver              0x00000400 /* 1:Enable OverFlow               */
+#define Rx_EnCRCErr            0x00000200 /* 1:Enable CRC Error              */
+#define Rx_EnAlign             0x00000100 /* 1:Enable Alignment              */
+#define Rx_IgnoreCRC           0x00000040 /* 1:Ignore CRC Value              */
+#define Rx_StripCRC            0x00000010 /* 1:Strip CRC Value               */
+#define Rx_ShortEn             0x00000008 /* 1:Short Enable                  */
+#define Rx_LongEn              0x00000004 /* 1:Long Enable                   */
+#define Rx_RxHalt              0x00000002 /* 1:Receive Halt Request          */
+#define Rx_RxEn                0x00000001 /* 1:Receive Intrrupt Enable       */
+
+/* Rx_Stat bit asign ------------------------------------------------------- */
+#define Rx_Halted              0x00008000 /* Rx Halted                       */
+#define Rx_Good                0x00004000 /* Rx Good                         */
+#define Rx_RxPar               0x00002000 /* Rx Parity Error                 */
+                            /* 0x00001000    not use                         */
+#define Rx_LongErr             0x00000800 /* Rx Long Error                   */
+#define Rx_Over                0x00000400 /* Rx Overflow                     */
+#define Rx_CRCErr              0x00000200 /* Rx CRC Error                    */
+#define Rx_Align               0x00000100 /* Rx Alignment Error              */
+#define Rx_10Stat              0x00000080 /* Rx 10Mbps Status                */
+#define Rx_IntRx               0x00000040 /* Rx Interrupt                    */
+#define Rx_CtlRecd             0x00000020 /* Rx Control Receive              */
+
+#define Rx_Stat_Mask           0x0000EFC0 /* Rx All Status Mask              */
+
+/* Int_En bit asign -------------------------------------------------------- */
+#define Int_NRAbtEn            0x00000800 /* 1:Non-recoverable Abort Enable  */
+#define Int_TxCtlCmpEn         0x00000400 /* 1:Transmit Control Complete Enable */
+#define Int_DmParErrEn         0x00000200 /* 1:DMA Parity Error Enable       */
+#define Int_DParDEn            0x00000100 /* 1:Data Parity Error Enable      */
+#define Int_EarNotEn           0x00000080 /* 1:Early Notify Enable           */
+#define Int_DParErrEn          0x00000040 /* 1:Detected Parity Error Enable  */
+#define Int_SSysErrEn          0x00000020 /* 1:Signalled System Error Enable */
+#define Int_RMasAbtEn          0x00000010 /* 1:Received Master Abort Enable  */
+#define Int_RTargAbtEn         0x00000008 /* 1:Received Target Abort Enable  */
+#define Int_STargAbtEn         0x00000004 /* 1:Signalled Target Abort Enable */
+#define Int_BLExEn             0x00000002 /* 1:Buffer List Exhausted Enable  */
+#define Int_FDAExEn            0x00000001 /* 1:Free Descriptor Area          */
+                                          /*               Exhausted Enable  */
+
+/* Int_Src bit asign ------------------------------------------------------- */
+#define Int_NRabt              0x00004000 /* 1:Non Recoverable error         */
+#define Int_DmParErrStat       0x00002000 /* 1:DMA Parity Error & Clear      */
+#define Int_BLEx               0x00001000 /* 1:Buffer List Empty & Clear     */
+#define Int_FDAEx              0x00000800 /* 1:FDA Empty & Clear             */
+#define Int_IntNRAbt           0x00000400 /* 1:Non Recoverable Abort         */
+#define	Int_IntCmp             0x00000200 /* 1:MAC control packet complete   */
+#define Int_IntExBD            0x00000100 /* 1:Interrupt Extra BD & Clear    */
+#define Int_DmParErr           0x00000080 /* 1:DMA Parity Error & Clear      */
+#define Int_IntEarNot          0x00000040 /* 1:Receive Data write & Clear    */
+#define Int_SWInt              0x00000020 /* 1:Software request & Clear      */
+#define Int_IntBLEx            0x00000010 /* 1:Buffer List Empty & Clear     */
+#define Int_IntFDAEx           0x00000008 /* 1:FDA Empty & Clear             */
+#define Int_IntPCI             0x00000004 /* 1:PCI controller & Clear        */
+#define Int_IntMacRx           0x00000002 /* 1:Rx controller & Clear         */
+#define Int_IntMacTx           0x00000001 /* 1:Tx controller & Clear         */
+
+/* MD_CA bit asign --------------------------------------------------------- */
+#define MD_CA_PreSup           0x00001000 /* 1:Preamble Supress              */
+#define MD_CA_Busy             0x00000800 /* 1:Busy (Start Operation)        */
+#define MD_CA_Wr               0x00000400 /* 1:Write 0:Read                  */
+
+
+/*
+ * Descriptors
+ */
+
+/* Frame descripter */
+struct FDesc {
+	volatile __u32 FDNext;
+	volatile __u32 FDSystem;
+	volatile __u32 FDStat;
+	volatile __u32 FDCtl;
+};
+
+/* Buffer descripter */
+struct BDesc {
+	volatile __u32 BuffData;
+	volatile __u32 BDCtl;
+};
+
+#define FD_ALIGN	16
+
+/* Frame Descripter bit asign ---------------------------------------------- */
+#define FD_FDLength_MASK       0x0000FFFF /* Length MASK                     */
+#define FD_BDCnt_MASK          0x001F0000 /* BD count MASK in FD             */
+#define FD_FrmOpt_MASK         0x7C000000 /* Frame option MASK               */
+#define FD_FrmOpt_BigEndian    0x40000000 /* Tx/Rx */
+#define FD_FrmOpt_IntTx        0x20000000 /* Tx only */
+#define FD_FrmOpt_NoCRC        0x10000000 /* Tx only */
+#define FD_FrmOpt_NoPadding    0x08000000 /* Tx only */
+#define FD_FrmOpt_Packing      0x04000000 /* Rx only */
+#define FD_CownsFD             0x80000000 /* FD Controller owner bit         */
+#define FD_Next_EOL            0x00000001 /* FD EOL indicator                */
+#define FD_BDCnt_SHIFT         16
+
+/* Buffer Descripter bit asign --------------------------------------------- */
+#define BD_BuffLength_MASK     0x0000FFFF /* Recieve Data Size               */
+#define BD_RxBDID_MASK         0x00FF0000 /* BD ID Number MASK               */
+#define BD_RxBDSeqN_MASK       0x7F000000 /* Rx BD Sequence Number           */
+#define BD_CownsBD             0x80000000 /* BD Controller owner bit         */
+#define BD_RxBDID_SHIFT        16
+#define BD_RxBDSeqN_SHIFT      24
+
+#undef NO_CHECK_CARRIER	/* Does not check No-Carrier with TP */
+/* Some useful constants. */
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+#define NO_CHECK_CARRIER	/* Does not check No-Carrier with TP */
+#endif
+#ifdef NO_CHECK_CARRIER
+#define TX_CTL_CMD	(Tx_EnComp | Tx_EnTxPar | Tx_EnLateColl | \
+	Tx_EnExColl | Tx_EnExDefer | Tx_EnUnder | \
+	Tx_En)	/* maybe  0x7b01 */
+#else
+#define TX_CTL_CMD	(Tx_EnComp | Tx_EnTxPar | Tx_EnLateColl | \
+	Tx_EnExColl | Tx_EnLCarr | Tx_EnExDefer | Tx_EnUnder | \
+	Tx_En)	/* maybe  0x7b01 */
+#endif
+#define RX_CTL_CMD	(Rx_EnGood | Rx_EnRxPar | Rx_EnLongErr | Rx_EnOver \
+	| Rx_EnCRCErr | Rx_EnAlign | Rx_RxEn)	/* maybe 0x6f01 */
+#define INT_EN_CMD  (Int_NRAbtEn | \
+	Int_DmParErrEn | Int_DParDEn | Int_DParErrEn | \
+	Int_SSysErrEn  | Int_RMasAbtEn | Int_RTargAbtEn | \
+	Int_STargAbtEn | \
+	Int_BLExEn  | Int_FDAExEn) /* maybe 0xb7f*/
+
+/* Tuning parameters */
+#define DMA_BURST_SIZE	32
+#define TX_THRESHOLD	1024
+#define TX_THRESHOLD_MAX 1536       /* used threshold with packet max byte for low pci transfer ability.*/
+#define TX_THRESHOLD_KEEP_LIMIT 10  /* setting threshold max value when overrun error occured this count. */
+
+#define FD_PAGE_NUM 2
+#define FD_PAGE_ORDER 1
+/* 16 + RX_BUF_PAGES * 8 + RX_FD_NUM * 16 + TX_FD_NUM * 32 <= PAGE_SIZE*2 */
+#define RX_BUF_PAGES	8	/* >= 2 */
+
+#define RX_FD_NUM	250	/* >= 32 */
+#define TX_FD_NUM	128
+
+struct TxFD {
+	struct FDesc fd;
+	struct BDesc bd;
+	struct BDesc unused;
+};
+
+struct RxFD {
+	struct FDesc fd;
+	struct BDesc bd[0];	/* variable length */
+};
+
+struct FrFD {
+	struct FDesc fd;
+	struct BDesc bd[RX_BUF_PAGES];
+};
+
+
+#define tc_readl(addr)	readl(addr)
+#define tc_writel(d, addr)	writel(d, addr)
+
+#define TC35815_TX_TIMEOUT  ((400*HZ)/1000)
+
+/* Timer state engine. */
+enum tc35815_timer_state {
+	arbwait  = 0,	/* Waiting for auto negotiation to complete.          */
+	lupwait  = 1,	/* Auto-neg complete, awaiting link-up status.        */
+	ltrywait = 2,	/* Forcing try of all modes, from fastest to slowest. */
+	asleep   = 3,	/* Time inactive.                                     */
+	lcheck   = 4,	/* Check link status.                                 */
+};
+
+/* Information that need to be kept for each board. */
+struct tc35815_local {
+	struct pci_dev *pci_dev;
+
+	/* statistics */
+	struct net_device_stats stats;
+	struct {
+		int max_tx_qlen;
+		int tx_ints;
+		int rx_ints;
+	        int tx_underrun;
+	} lstats;
+
+	/* Tx control lock.  This protects the transmit buffer ring
+	 * state along with the "tx full" state of the driver.  This
+	 * means all netif_queue flow control actions are protected
+	 * by this lock as well.
+	 */
+	spinlock_t lock;
+
+	int phy_addr;
+	int fullduplex;
+	unsigned short saved_lpa;
+	struct timer_list timer;
+	enum tc35815_timer_state timer_state; /* State of auto-neg timer. */
+	unsigned int timer_ticks;	/* Number of clicks at each state  */
+
+	/*
+	 * Transmitting: Batch Mode.
+	 *	1 BD in 1 TxFD.
+	 * Receiving: Packing Mode.
+	 *	1 circular FD for Free Buffer List.
+	 *	RX_BUF_PAGES BD in Free Buffer FD.
+	 *	One Free Buffer BD has PAGE_SIZE data buffer.
+	 */
+	void * fd_buf;	/* for TxFD, RxFD, FrFD */
+	dma_addr_t fd_buf_dma;
+	struct TxFD *tfd_base;
+	unsigned int tfd_start;
+	unsigned int tfd_end;
+	struct RxFD *rfd_base;
+	struct RxFD *rfd_limit;
+	struct RxFD *rfd_cur;
+	struct FrFD *fbl_ptr;
+	unsigned char fbl_curid;
+	void * data_buf[RX_BUF_PAGES];		/* packing */
+	dma_addr_t data_buf_dma[RX_BUF_PAGES];		/* packing */
+
+	struct {
+		struct sk_buff *skb;
+		dma_addr_t skb_dma;
+	} tx_skbs[TX_FD_NUM];
+	struct mii_if_info mii;
+	unsigned short mii_id[2];
+	u32 msg_enable;
+};
+
+static inline dma_addr_t fd_virt_to_bus(struct tc35815_local *lp, void *virt)
+{
+#if 0
+	if ((u8 *)virt < (u8 *)lp->fd_buf ||
+	    (u8 *)virt >= (u8 *)lp->fd_buf + PAGE_SIZE * FD_PAGE_NUM)
+		panic("tc35815: fd_virt_to_bus: %x %x\n", lp, virt);
+#endif
+	return lp->fd_buf_dma + ((u8 *)virt - (u8 *)lp->fd_buf);
+}
+static inline void *fd_bus_to_virt(struct tc35815_local *lp, dma_addr_t bus)
+{
+#if 0
+	if (bus < lp->fd_buf_dma ||
+	    bus >= lp->fd_buf_dma + PAGE_SIZE * FD_PAGE_NUM)
+		panic("tc35815: fd_bus_to_virt: %x %x\n", lp, bus);
+#endif
+	return (void *)((u8 *)lp->fd_buf + (bus - lp->fd_buf_dma));
+}
+static inline dma_addr_t rxbuf_virt_to_bus(struct tc35815_local *lp, void *virt)
+{
+	int i;
+	for (i = 0; i < RX_BUF_PAGES; i++) {
+		if ((u8 *)virt >= (u8 *)lp->data_buf[i] &&
+		    (u8 *)virt < (u8 *)lp->data_buf[i] + PAGE_SIZE)
+			return lp->data_buf_dma[i] + ((u8 *)virt - (u8 *)lp->data_buf[i]);
+	}
+#if 0
+	panic("tc35815: rxbuf_virt_to_bus: %x %x\n", lp, virt);
+#endif
+	return 0;
+}
+static inline void *rxbuf_bus_to_virt(struct tc35815_local *lp, dma_addr_t bus)
+{
+	int i;
+	for (i = 0; i < RX_BUF_PAGES; i++) {
+		if (bus >= lp->data_buf_dma[i] &&
+		    bus < lp->data_buf_dma[i] + PAGE_SIZE)
+			return (void *)((u8 *)lp->data_buf[i] +
+					(bus - lp->data_buf_dma[i]));
+	}
+#if 0
+	panic("tc35815: rxbuf_bus_to_virt: %x %x\n", lp, bus);
+#endif
+	return NULL;
+}
+
+#define TC35815_DMA_SYNC_ONDEMMAND
+static void* alloc_rxbuf_page(struct pci_dev *hwdev, dma_addr_t *dma_handle)
+{
+#ifdef TC35815_DMA_SYNC_ONDEMMAND
+	void *buf;
+	/* pci_map + pci_dma_sync will be more effective than
+	 * pci_alloc_consistent on some archs. */
+	if ((buf = (void *)__get_free_page(GFP_ATOMIC)) == NULL)
+		return NULL;
+	if ((*dma_handle = pci_map_single(hwdev, buf, PAGE_SIZE,
+					  PCI_DMA_FROMDEVICE)) == 0) {
+		free_page((unsigned long)buf);
+		return NULL;
+	}
+	return buf;
+#else
+	return pci_alloc_consistent(hwdev, PAGE_SIZE, dma_handle);
+#endif
+}
+
+static void free_rxbuf_page(struct pci_dev *hwdev, void *buf, dma_addr_t dma_handle)
+{
+#ifdef TC35815_DMA_SYNC_ONDEMMAND
+	pci_unmap_single(hwdev, dma_handle, PAGE_SIZE, PCI_DMA_FROMDEVICE);
+	free_page((unsigned long)buf);
+#else
+	pci_free_consistent(hwdev, PAGE_SIZE, buf, dma_handle);
+#endif
+}
+
+/* Index to functions, as function prototypes. */
+
+static int	tc35815_open(struct net_device *dev);
+static int	tc35815_send_packet(struct sk_buff *skb, struct net_device *dev);
+static irqreturn_t	tc35815_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static void	tc35815_rx(struct net_device *dev);
+static void	tc35815_txdone(struct net_device *dev);
+static int	tc35815_close(struct net_device *dev);
+static struct	net_device_stats *tc35815_get_stats(struct net_device *dev);
+static void	tc35815_set_multicast_list(struct net_device *dev);
+static void     tc35815_tx_timeout(struct net_device *dev);
+static int	tc35815_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static struct ethtool_ops tc35815_ethtool_ops;
+
+/* Example routines you must write ;->. */
+static void 	tc35815_chip_reset(struct tc35815_regs *tr);
+static void 	tc35815_chip_init(struct net_device *dev);
+static void	tc35815_find_phy(struct net_device *dev);
+static void 	tc35815_phy_chip_init(struct net_device *dev);
+
+static void	panic_queues(struct net_device *dev);
+
+static void tc35815_start_auto_negotiation(struct net_device *dev,
+					   struct ethtool_cmd *ep);
+static int tc_mdio_read(struct net_device *dev, int phy_id, int location);
+static void tc_mdio_write(struct net_device *dev, int phy_id, int location,
+			  int val);
+
+static void __devinit tc35815_init_dev_addr (struct net_device *dev)
+{
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	int i;
+
+#ifdef CONFIG_TX_BOARDS	/* TX4938-builtin LANC only */
+	struct tc35815_local *lp = dev->priv;
+	extern int (*txboard_get_tx4938_ethaddr)(struct pci_dev *dev, unsigned char *addr);
+	if (txboard_get_tx4938_ethaddr &&
+	    txboard_get_tx4938_ethaddr(lp->pci_dev, dev->dev_addr) == 0)
+		return;
+#endif
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+	struct tc35815_local *lp = dev->priv;
+	extern int rbtx4939_get_tx4939_ethaddr(struct pci_dev *dev, unsigned char *addr);
+	if (rbtx4939_get_tx4939_ethaddr &&
+	    rbtx4939_get_tx4939_ethaddr(lp->pci_dev, dev->dev_addr) == 0)
+		return;
+#endif
+	while (tc_readl(&tr->PROM_Ctl) & PROM_Busy)
+		;
+	for (i = 0; i < 6; i += 2) {
+		unsigned short data;
+		tc_writel(PROM_Busy | PROM_Read | (i / 2 + 2), &tr->PROM_Ctl);
+		while (tc_readl(&tr->PROM_Ctl) & PROM_Busy)
+			;
+		data = tc_readl(&tr->PROM_Data);
+		dev->dev_addr[i] = data & 0xff;
+		dev->dev_addr[i+1] = data >> 8;
+	}
+}
+
+static int __devinit tc35815_init_one (struct pci_dev *pdev,
+				       const struct pci_device_id *ent)
+{
+	void *ioaddr = NULL;
+	struct net_device *dev;
+	struct tc35815_local *lp;
+	int rc;
+	unsigned long mmio_start, mmio_end, mmio_flags, mmio_len;
+
+/* when built into the kernel, we only print version if device is found */
+#ifndef MODULE
+	static int printed_version;
+	if (!printed_version++) {
+		printk(version);
+		printk(KERN_DEBUG MODNAME ": speed:%d duplex:%d doforce:%d\n",
+		       options.speed, options.duplex, options.doforce);
+	}
+#endif
+
+	if (!pdev->irq) {
+		printk (KERN_WARNING MODNAME ": no IRQ assigned (%s).\n",
+			pci_name(pdev));
+		return -ENODEV;
+	}
+
+	/* dev zeroed in alloc_etherdev */
+	dev = alloc_etherdev (sizeof (*lp));
+	if (dev == NULL) {
+		printk (KERN_ERR MODNAME ": unable to alloc new ethernet\n");
+		return -ENOMEM;
+	}
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	lp = dev->priv;
+
+	/* enable device (incl. PCI PM wakeup), and bus-mastering */
+	rc = pci_enable_device (pdev);
+	if (rc)
+		goto err_out;
+
+	mmio_start = pci_resource_start (pdev, 1);
+	mmio_end = pci_resource_end (pdev, 1);
+	mmio_flags = pci_resource_flags (pdev, 1);
+	mmio_len = pci_resource_len (pdev, 1);
+
+	/* set this immediately, we need to know before
+	 * we talk to the chip directly */
+
+	/* make sure PCI base addr 1 is MMIO */
+	if (!(mmio_flags & IORESOURCE_MEM)) {
+		printk (KERN_ERR MODNAME ": region #1 not an MMIO resource, aborting\n");
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	/* check for weird/broken PCI region reporting */
+	if ((mmio_len < sizeof(struct tc35815_regs))) {
+		printk (KERN_ERR MODNAME ": Invalid PCI region size(s), aborting\n");
+		rc = -ENODEV;
+		goto err_out;
+	}
+
+	rc = pci_request_regions (pdev, MODNAME);
+	if (rc)
+		goto err_out;
+
+	pci_set_master (pdev);
+
+	/* ioremap MMIO region */
+	ioaddr = ioremap (mmio_start, mmio_len);
+	if (ioaddr == NULL) {
+		printk (KERN_ERR MODNAME ": cannot remap MMIO, aborting\n");
+		rc = -EIO;
+		goto err_out_free_res;
+	}
+
+	/* Initialize the device structure. */
+	dev->open = tc35815_open;
+	dev->hard_start_xmit = tc35815_send_packet;
+	dev->stop = tc35815_close;
+	dev->get_stats = tc35815_get_stats;
+	dev->set_multicast_list = tc35815_set_multicast_list;
+	dev->do_ioctl = tc35815_ioctl;
+	dev->ethtool_ops = &tc35815_ethtool_ops;
+	dev->tx_timeout = tc35815_tx_timeout;
+	dev->watchdog_timeo = TC35815_TX_TIMEOUT;
+
+	dev->irq = pdev->irq;
+	dev->base_addr = (unsigned long) ioaddr;
+
+	/* dev->priv/lp zeroed and aligned in alloc_etherdev */
+	lp = dev->priv;
+	spin_lock_init(&lp->lock);
+	lp->pci_dev = pdev;
+
+	lp->msg_enable = NETIF_MSG_TX_ERR | NETIF_MSG_HW | NETIF_MSG_DRV | NETIF_MSG_LINK;
+	pci_set_drvdata(pdev, dev);
+
+	/* Soft reset the chip. */
+	tc35815_chip_reset((struct tc35815_regs*)ioaddr);
+
+	/* Retrieve the ethernet address. */
+	tc35815_init_dev_addr(dev);
+
+	rc = register_netdev (dev);
+	if (rc)
+		goto err_out_unmap;
+
+	printk (KERN_INFO "%s: %s at 0x%lx, "
+		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+		"IRQ %d\n",
+		dev->name,
+		board_info[ent->driver_data].name,
+		dev->base_addr,
+		dev->dev_addr[0], dev->dev_addr[1],
+		dev->dev_addr[2], dev->dev_addr[3],
+		dev->dev_addr[4], dev->dev_addr[5],
+		dev->irq);
+
+	init_timer(&lp->timer);
+	lp->mii.dev = dev;
+	lp->mii.mdio_read = tc_mdio_read;
+	lp->mii.mdio_write = tc_mdio_write;
+	lp->mii.phy_id_mask = 0x1f;
+	lp->mii.reg_num_mask = 0x1f;
+	tc35815_find_phy(dev);
+	lp->mii.phy_id = lp->phy_addr;
+	lp->mii.full_duplex = 0;
+	lp->mii.force_media = 0;
+
+	return 0;
+
+err_out_unmap:
+	iounmap(ioaddr);
+err_out_free_res:
+	pci_release_regions (pdev);
+err_out:
+	free_netdev (dev);
+	return rc;
+}
+
+
+static void __devexit tc35815_remove_one (struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata (pdev);
+	unsigned long mmio_addr;
+
+	mmio_addr = dev->base_addr;
+
+	unregister_netdev (dev);
+
+	if (mmio_addr) {
+		iounmap ((void __iomem *)mmio_addr);
+		pci_release_regions (pdev);
+	}
+
+	free_netdev (dev);
+
+	pci_set_drvdata (pdev, NULL);
+}
+
+static int
+tc35815_init_queues(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int i;
+	unsigned long fd_addr;
+
+	if (!lp->fd_buf) {
+		if (sizeof(struct FDesc) +
+		    sizeof(struct BDesc) * RX_BUF_PAGES +
+		    sizeof(struct FDesc) * RX_FD_NUM +
+		    sizeof(struct TxFD) * TX_FD_NUM > PAGE_SIZE * FD_PAGE_NUM) {
+			printk("%s: Invalid Queue Size.\n", dev->name);
+			return -ENOMEM;
+		}
+
+		if ((lp->fd_buf = pci_alloc_consistent(lp->pci_dev, PAGE_SIZE * FD_PAGE_NUM, &lp->fd_buf_dma)) == 0)
+			return -ENOMEM;
+		for (i = 0; i < RX_BUF_PAGES; i++) {
+			if ((lp->data_buf[i] = alloc_rxbuf_page(lp->pci_dev, &lp->data_buf_dma[i])) == NULL) {
+				while (--i >= 0) {
+					free_rxbuf_page(lp->pci_dev,
+							lp->data_buf[i],
+							lp->data_buf_dma[i]);
+					lp->data_buf[i] = NULL;
+				}
+				pci_free_consistent(lp->pci_dev, PAGE_SIZE * FD_PAGE_NUM, lp->fd_buf, lp->fd_buf_dma);
+				lp->fd_buf = 0;
+				return -ENOMEM;
+			}
+		}
+		printk(KERN_DEBUG "%s: FD buf %p DataBuf", dev->name, lp->fd_buf);
+		for (i = 0; i < RX_BUF_PAGES; i++) {
+			printk(" %p", lp->data_buf[i]);
+		}
+		printk("\n");
+	} else {
+		for (i = 0; i < FD_PAGE_NUM; i++) {
+			clear_page((void *)((unsigned long)lp->fd_buf + i * PAGE_SIZE));
+		}
+	}
+	fd_addr = (unsigned long)lp->fd_buf;
+
+	/* Free Descriptors (for Receive) */
+	lp->rfd_base = (struct RxFD *)fd_addr;
+	fd_addr += sizeof(struct RxFD) * RX_FD_NUM;
+	for (i = 0; i < RX_FD_NUM; i++) {
+		lp->rfd_base[i].fd.FDCtl = cpu_to_le32(FD_CownsFD);
+	}
+	lp->rfd_cur = lp->rfd_base;
+	lp->rfd_limit = (struct RxFD *)(fd_addr -
+					sizeof(struct FDesc) -
+					sizeof(struct BDesc) * 30);
+
+	/* Transmit Descriptors */
+	lp->tfd_base = (struct TxFD *)fd_addr;
+	fd_addr += sizeof(struct TxFD) * TX_FD_NUM;
+	for (i = 0; i < TX_FD_NUM; i++) {
+		lp->tfd_base[i].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[i+1]));
+		lp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);
+		lp->tfd_base[i].fd.FDCtl = cpu_to_le32(0);
+	}
+	lp->tfd_base[TX_FD_NUM-1].fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, &lp->tfd_base[0]));
+	lp->tfd_start = 0;
+	lp->tfd_end = 0;
+
+	/* Buffer List (for Receive) */
+	lp->fbl_ptr = (struct FrFD *)fd_addr;
+	lp->fbl_ptr->fd.FDNext = cpu_to_le32(fd_virt_to_bus(lp, lp->fbl_ptr));
+	lp->fbl_ptr->fd.FDCtl = cpu_to_le32(RX_BUF_PAGES | FD_CownsFD);
+	for (i = 0; i < RX_BUF_PAGES; i++) {
+		lp->fbl_ptr->bd[i].BuffData = cpu_to_le32(lp->data_buf_dma[i]);
+		/* BDID is index of FrFD.bd[] */
+		lp->fbl_ptr->bd[i].BDCtl =
+			cpu_to_le32(BD_CownsBD | (i << BD_RxBDID_SHIFT) | PAGE_SIZE);
+	}
+	lp->fbl_curid = 0;
+
+	printk(KERN_DEBUG "%s: TxFD %p RxFD %p FrFD %p\n",
+	       dev->name, lp->tfd_base, lp->rfd_base, lp->fbl_ptr);
+	return 0;
+}
+
+static void
+tc35815_clear_queues(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int i;
+
+	for (i = 0; i < TX_FD_NUM; i++) {
+		struct sk_buff *skb =
+			lp->tfd_base[i].fd.FDSystem != cpu_to_le32(0xffffffff) ?
+			lp->tx_skbs[le32_to_cpu(lp->tfd_base[i].fd.FDSystem)].skb : NULL;
+		if (lp->tx_skbs[i].skb != skb) {
+			printk("%s: tx_skbs mismatch(%d).\n", dev->name, i);
+			panic_queues(dev);
+		}
+		if (skb) {
+			pci_unmap_single(lp->pci_dev, lp->tx_skbs[i].skb_dma, skb->len, PCI_DMA_TODEVICE);
+			lp->tx_skbs[i].skb = NULL;
+			lp->tx_skbs[i].skb_dma = 0;
+			dev_kfree_skb_any(skb);
+		}
+		lp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);
+	}
+
+	tc35815_init_queues(dev);
+}
+
+static void
+tc35815_free_queues(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int i;
+
+	if (lp->tfd_base) {
+		for (i = 0; i < TX_FD_NUM; i++) {
+			struct sk_buff *skb =
+				lp->tfd_base[i].fd.FDSystem != cpu_to_le32(0xffffffff) ?
+				lp->tx_skbs[le32_to_cpu(lp->tfd_base[i].fd.FDSystem)].skb : NULL;
+			if (lp->tx_skbs[i].skb != skb) {
+				printk("%s: tx_skbs mismatch(%d).\n", dev->name, i);
+				panic_queues(dev);
+			}
+			if (skb) {
+				dev_kfree_skb(skb);
+				pci_unmap_single(lp->pci_dev, lp->tx_skbs[i].skb_dma, skb->len, PCI_DMA_TODEVICE);
+				lp->tx_skbs[i].skb = NULL;
+				lp->tx_skbs[i].skb_dma = 0;
+			}
+			lp->tfd_base[i].fd.FDSystem = cpu_to_le32(0xffffffff);
+		}
+	}
+
+	lp->rfd_base = NULL;
+	lp->rfd_limit = NULL;
+	lp->rfd_cur = NULL;
+	lp->fbl_ptr = NULL;
+
+	for (i = 0; i < RX_BUF_PAGES; i++) {
+		if (lp->data_buf[i]) {
+			free_rxbuf_page(lp->pci_dev,
+					lp->data_buf[i], lp->data_buf_dma[i]);
+			lp->data_buf[i] = NULL;
+		}
+	}
+	if (lp->fd_buf) {
+		pci_free_consistent(lp->pci_dev, PAGE_SIZE * FD_PAGE_NUM,
+				    lp->fd_buf, lp->fd_buf_dma);
+		lp->fd_buf = NULL;
+	}
+}
+
+static void
+dump_txfd(struct TxFD *fd)
+{
+	printk("TxFD(%p): %08x %08x %08x %08x\n", fd,
+	       le32_to_cpu(fd->fd.FDNext),
+	       le32_to_cpu(fd->fd.FDSystem),
+	       le32_to_cpu(fd->fd.FDStat),
+	       le32_to_cpu(fd->fd.FDCtl));
+	printk("BD: ");
+	printk(" %08x %08x",
+	       le32_to_cpu(fd->bd.BuffData),
+	       le32_to_cpu(fd->bd.BDCtl));
+	printk("\n");
+}
+
+static int
+dump_rxfd(struct RxFD *fd)
+{
+	int i, bd_count = (le32_to_cpu(fd->fd.FDCtl) & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;
+	if (bd_count > 8)
+		bd_count = 8;
+	printk("RxFD(%p): %08x %08x %08x %08x\n", fd,
+	       le32_to_cpu(fd->fd.FDNext),
+	       le32_to_cpu(fd->fd.FDSystem),
+	       le32_to_cpu(fd->fd.FDStat),
+	       le32_to_cpu(fd->fd.FDCtl));
+	if (le32_to_cpu(fd->fd.FDCtl) & FD_CownsFD)
+	    return 0;
+	printk("BD: ");
+	for (i = 0; i < bd_count; i++)
+		printk(" %08x %08x",
+		       le32_to_cpu(fd->bd[i].BuffData),
+		       le32_to_cpu(fd->bd[i].BDCtl));
+	printk("\n");
+	return bd_count;
+}
+
+static void
+dump_frfd(struct FrFD *fd)
+{
+	int i;
+	printk("FrFD(%p): %08x %08x %08x %08x\n", fd,
+	       le32_to_cpu(fd->fd.FDNext),
+	       le32_to_cpu(fd->fd.FDSystem),
+	       le32_to_cpu(fd->fd.FDStat),
+	       le32_to_cpu(fd->fd.FDCtl));
+	printk("BD: ");
+	for (i = 0; i < RX_BUF_PAGES; i++)
+		printk(" %08x %08x",
+		       le32_to_cpu(fd->bd[i].BuffData),
+		       le32_to_cpu(fd->bd[i].BDCtl));
+	printk("\n");
+}
+
+static void
+panic_queues(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int i;
+
+	printk("TxFD base %p, start %u, end %u\n",
+	       lp->tfd_base, lp->tfd_start, lp->tfd_end);
+	printk("RxFD base %p limit %p cur %p\n",
+	       lp->rfd_base, lp->rfd_limit, lp->rfd_cur);
+	printk("FrFD %p\n", lp->fbl_ptr);
+	for (i = 0; i < TX_FD_NUM; i++)
+		dump_txfd(&lp->tfd_base[i]);
+	for (i = 0; i < RX_FD_NUM; i++) {
+		int bd_count = dump_rxfd(&lp->rfd_base[i]);
+		i += (bd_count + 1) / 2;	/* skip BDs */
+	}
+	dump_frfd(lp->fbl_ptr);
+	panic("%s: Illegal queue state.", dev->name);
+}
+
+static void print_eth(char *add)
+{
+	int i;
+
+	printk("print_eth(%p)\n", add);
+	for (i = 0; i < 6; i++)
+		printk(" %2.2X", (unsigned char) add[i + 6]);
+	printk(" =>");
+	for (i = 0; i < 6; i++)
+		printk(" %2.2X", (unsigned char) add[i]);
+	printk(" : %2.2X%2.2X\n", (unsigned char) add[12], (unsigned char) add[13]);
+}
+
+static int tc35815_tx_full(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	return ((lp->tfd_start + 1) % TX_FD_NUM == lp->tfd_end);
+}
+
+static void tc35815_restart(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	int do_phy_reset = 1;
+	del_timer(&lp->timer);		/* Kill if running	*/
+
+	if (lp->mii_id[0] == 0x0016 && (lp->mii_id[1] & 0xfc00) == 0xf800) {
+		/* Resetting PHY cause problem on some chip... (SEEQ 80221) */
+		do_phy_reset = 0;
+	}
+	if (do_phy_reset) {
+		int timeout;
+		tc_mdio_write(dev, pid, MII_BMCR, BMCR_RESET);
+		timeout = 100;
+		while (--timeout) {
+			if (!(tc_mdio_read(dev, pid, MII_BMCR) & BMCR_RESET))
+				break;
+			udelay(1);
+		}
+		if (!timeout)
+			printk(KERN_ERR "%s: BMCR reset failed.\n", dev->name);
+	}
+
+	tc35815_chip_reset(tr);
+	tc35815_clear_queues(dev);
+	tc35815_chip_init(dev);
+	/* Reconfigure CAM again since tc35815_chip_init() initialize it. */
+	tc35815_set_multicast_list(dev);
+}
+
+static void tc35815_tx_timeout(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+
+	printk(KERN_WARNING "%s: transmit timed out, status %#x\n",
+	       dev->name, tc_readl(&tr->Tx_Stat));
+
+	/* Try to restart the adaptor. */
+	spin_lock_irq(&lp->lock);
+	tc35815_restart(dev);
+	spin_unlock_irq(&lp->lock);
+
+	lp->stats.tx_errors++;
+
+	/* If we have space available to accept new transmit
+	 * requests, wake up the queueing layer.  This would
+	 * be the case if the chipset_init() call above just
+	 * flushes out the tx queue and empties it.
+	 *
+	 * If instead, the tx queue is retained then the
+	 * netif_wake_queue() call should be placed in the
+	 * TX completion interrupt handler of the driver instead
+	 * of here.
+	 */
+	if (!tc35815_tx_full(dev))
+		netif_wake_queue(dev);
+}
+
+/*
+ * Open/initialize the board. This is called (in the current kernel)
+ * sometime after booting when the 'ifconfig' program is run.
+ *
+ * This routine should set everything up anew at each open, even
+ * registers that "should" only need to be set once at boot, so that
+ * there is non-reboot way to recover if something goes wrong.
+ */
+static int
+tc35815_open(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+
+	/*
+	 * This is used if the interrupt line can turned off (shared).
+	 * See 3c503.c for an example of selecting the IRQ at config-time.
+	 */
+	if (request_irq(dev->irq, &tc35815_interrupt, SA_SHIRQ, dev->name, dev)) {
+		return -EAGAIN;
+	}
+
+	del_timer(&lp->timer);		/* Kill if running	*/
+	tc35815_chip_reset((struct tc35815_regs*)dev->base_addr);
+
+	if (tc35815_init_queues(dev) != 0) {
+		free_irq(dev->irq, dev);
+		return -EAGAIN;
+	}
+
+	/* Reset the hardware here. Don't forget to set the station address. */
+	spin_lock_irq(&lp->lock);
+	tc35815_chip_init(dev);
+	spin_unlock_irq(&lp->lock);
+
+	/* We are now ready to accept transmit requeusts from
+	 * the queueing layer of the networking.
+	 */
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+/* This will only be invoked if your driver is _not_ in XOFF state.
+ * What this means is that you need not check it, and that this
+ * invariant will hold if you make sure that the netif_*_queue()
+ * calls are done at the proper times.
+ */
+static int tc35815_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	short length = skb->len;
+	struct TxFD *txfd;
+
+	/* If some error occurs while trying to transmit this
+	 * packet, you should return '1' from this function.
+	 * In such a case you _may not_ do anything to the
+	 * SKB, it is still owned by the network queueing
+	 * layer when an error is returned.  This means you
+	 * may not modify any SKB fields, you may not free
+	 * the SKB, etc.
+	 */
+
+	/* This is the most common case for modern hardware.
+	 * The spinlock protects this code from the TX complete
+	 * hardware interrupt handler.  Queue flow control is
+	 * thus managed under this lock as well.
+	 */
+	spin_lock_irq(&lp->lock);
+
+	/*add to ring */
+	txfd = &lp->tfd_base[lp->tfd_start];
+
+	/* failsafe... */
+	if (lp->tfd_start != lp->tfd_end)
+		tc35815_txdone(dev);
+
+	if (netif_msg_pktdata(lp))
+		print_eth(skb->data);
+	if (lp->tx_skbs[lp->tfd_start].skb) {
+		printk("%s: tx_skbs conflict.\n", dev->name);
+		panic_queues(dev);
+	}
+	lp->tx_skbs[lp->tfd_start].skb = skb;
+	lp->tx_skbs[lp->tfd_start].skb_dma = pci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);
+	txfd->bd.BuffData = cpu_to_le32(lp->tx_skbs[lp->tfd_start].skb_dma);
+	txfd->bd.BDCtl = cpu_to_le32(length);
+	txfd->fd.FDSystem = cpu_to_le32(lp->tfd_start);
+	txfd->fd.FDCtl = cpu_to_le32(FD_CownsFD | (1 << FD_BDCnt_SHIFT));
+
+	if (lp->tfd_start == lp->tfd_end) {
+		/* Start DMA Transmitter. */
+		txfd->fd.FDNext |= cpu_to_le32(FD_Next_EOL);
+#ifdef GATHER_TXINT
+		txfd->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);
+#endif
+		if (netif_msg_tx_queued(lp)) {
+			printk("%s: starting TxFD.\n", dev->name);
+			dump_txfd(txfd);
+		}
+		tc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);
+	} else {
+		txfd->fd.FDNext &= cpu_to_le32(~FD_Next_EOL);
+		if (netif_msg_tx_queued(lp)) {
+			printk("%s: queueing TxFD.\n", dev->name);
+			dump_txfd(txfd);
+		}
+	}
+	lp->tfd_start = (lp->tfd_start + 1) % TX_FD_NUM;
+
+	dev->trans_start = jiffies;
+
+	/* If we just used up the very last entry in the
+	 * TX ring on this device, tell the queueing
+	 * layer to send no more.
+	 */
+	if (tc35815_tx_full(dev)) {
+		if (netif_msg_tx_queued(lp))
+			printk(KERN_WARNING "%s: TxFD Exhausted.\n", dev->name);
+		netif_stop_queue(dev);
+	}
+
+	/* When the TX completion hw interrupt arrives, this
+	 * is when the transmit statistics are updated.
+	 */
+
+	spin_unlock_irq(&lp->lock);
+	return 0;
+}
+
+#define FATAL_ERROR_INT \
+	(Int_IntPCI | Int_DmParErr | Int_IntNRAbt)
+#if 0  // for error end with DMA Parity error happened
+static int tc35815_fatal_error_interrupt(struct net_device *dev, int status)
+#else  // for error reset
+static void tc35815_fatal_error_interrupt(struct net_device *dev, int status)
+#endif
+{
+	static int count;
+	printk(KERN_WARNING "%s: Fatal Error Intterrupt (%#x):",
+	       dev->name, status);
+	if (status & Int_IntPCI)
+		printk(" IntPCI");
+	if (status & Int_DmParErr)
+#if 0  // for error end with DMA Parity error happened
+	{
+		struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+		unsigned long tmp;
+		tmp = tc_readl(&tr->Int_En);
+		tmp &= ~Int_DmParErrEn;
+		tc_writel(tmp, &tr->Int_En);
+		printk(KERN_WARNING "Disable DMA Parity error Int.\n");
+		return 1;
+	}
+#else  // for error reset
+		printk(" DmParErr");
+#endif
+	if (status & Int_IntNRAbt)
+		printk(" IntNRAbt");
+	printk("\n");
+	if (count++ > 100)
+		panic("%s: Too many fatal errors.", dev->name);
+	printk(KERN_WARNING "%s: Resetting ...\n", dev->name);
+	/* Try to restart the adaptor. */
+	tc35815_restart(dev);
+#if 0  // for error end with DMA Parity error happened
+	return 0;
+#else
+	return;
+#endif
+}
+
+/*
+ * The typical workload of the driver:
+ * Handle the network interface interrupts.
+ */
+static irqreturn_t tc35815_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = dev_id;
+	struct tc35815_regs *tr;
+	struct tc35815_local *lp;
+	int status, handled = 0;
+
+	tr = (struct tc35815_regs *)dev->base_addr;
+	lp = dev->priv;
+
+	spin_lock(&lp->lock);
+	status = tc_readl(&tr->Int_Src);
+	tc_writel(status, &tr->Int_Src);	/* write to clear */
+
+	/* Fatal errors... */
+	if (status & FATAL_ERROR_INT) {
+#if 0  // for error end with DMA Parity error happened
+		if (tc35815_fatal_error_interrupt(dev, status) == 0)
+#else  // for error reset
+		tc35815_fatal_error_interrupt(dev, status);
+#endif
+			spin_unlock(&lp->lock);
+			return IRQ_HANDLED;
+	}
+	/* recoverable errors */
+	if (status & Int_IntFDAEx) {
+		/* disable FDAEx int. (until we make rooms...) */
+		tc_writel(tc_readl(&tr->Int_En) & ~Int_FDAExEn, &tr->Int_En);
+		printk(KERN_WARNING
+		       "%s: Free Descriptor Area Exhausted (%#x).\n",
+		       dev->name, status);
+		lp->stats.rx_dropped++;
+		handled = 1;
+	}
+	if (status & Int_IntBLEx) {
+		/* disable BLEx int. (until we make rooms...) */
+		tc_writel(tc_readl(&tr->Int_En) & ~Int_BLExEn, &tr->Int_En);
+		printk(KERN_WARNING
+		       "%s: Buffer List Exhausted (%#x).\n",
+		       dev->name, status);
+		lp->stats.rx_dropped++;
+		handled = 1;
+	}
+	if (status & Int_IntExBD) {
+		printk(KERN_WARNING
+		       "%s: Excessive Buffer Descriptiors (%#x).\n",
+		       dev->name, status);
+		lp->stats.rx_length_errors++;
+		handled = 1;
+	}
+
+	/* normal notification */
+	if (status & Int_IntMacRx) {
+		/* Got a packet(s). */
+		lp->lstats.rx_ints++;
+		tc35815_rx(dev);
+		handled = 1;
+	}
+	if (status & Int_IntMacTx) {
+		/* Transmit complete. */
+		lp->lstats.tx_ints++;
+		tc35815_txdone(dev);
+		netif_wake_queue(dev);
+		handled = 1;
+	}
+	(void)tc_readl(&tr->Int_Src);	/* flush */
+	spin_unlock(&lp->lock);
+	return IRQ_RETVAL(handled);
+}
+
+/* We have a good packet(s), get it/them out of the buffers. */
+static void
+tc35815_rx(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	unsigned int fdctl;
+	int i;
+	int buf_free_count = 0;
+	int fd_free_count = 0;
+
+	while (!((fdctl = le32_to_cpu(lp->rfd_cur->fd.FDCtl)) & FD_CownsFD)) {
+		int status = le32_to_cpu(lp->rfd_cur->fd.FDStat);
+		int pkt_len = fdctl & FD_FDLength_MASK;
+		struct RxFD *next_rfd;
+		int bd_count = (fdctl & FD_BDCnt_MASK) >> FD_BDCnt_SHIFT;
+#if (RX_CTL_CMD & Rx_StripCRC) == 0
+		pkt_len -= 4;
+#endif
+
+		if (netif_msg_rx_status(lp))
+			dump_rxfd(lp->rfd_cur);
+		if (status & Rx_Good) {
+			/* Malloc up new buffer. */
+			struct sk_buff *skb;
+			unsigned char *data;
+			int cur_bd, offset;
+
+			skb = dev_alloc_skb(pkt_len + 2); /* +2: for reserve */
+			if (skb == NULL) {
+				printk(KERN_NOTICE "%s: Memory squeeze, dropping packet.\n",
+				       dev->name);
+				lp->stats.rx_dropped++;
+				break;
+			}
+			skb_reserve(skb, 2);   /* 16 bit alignment */
+			skb->dev = dev;
+
+			data = skb_put(skb, pkt_len);
+
+			/* copy from receive buffer */
+			cur_bd = 0;
+			offset = 0;
+			while (offset < pkt_len && cur_bd < bd_count) {
+				int len = le32_to_cpu(lp->rfd_cur->bd[cur_bd].BDCtl) &
+					BD_BuffLength_MASK;
+				dma_addr_t dma = le32_to_cpu(lp->rfd_cur->bd[cur_bd].BuffData);
+				void *rxbuf = rxbuf_bus_to_virt(lp, dma);
+				if (offset + len > pkt_len)
+					len = pkt_len - offset;
+#ifdef TC35815_DMA_SYNC_ONDEMMAND
+				pci_dma_sync_single_for_cpu(lp->pci_dev,
+							    dma, len,
+							    PCI_DMA_FROMDEVICE);
+#endif
+				memcpy(data + offset, rxbuf, len);
+				offset += len;
+				cur_bd++;
+			}
+			if (netif_msg_pktdata(lp))
+				print_eth(data);
+			skb->protocol = eth_type_trans(skb, dev);
+			netif_rx(skb);
+			dev->last_rx = jiffies;
+			lp->stats.rx_packets++;
+			lp->stats.rx_bytes += pkt_len;
+		} else {
+			lp->stats.rx_errors++;
+			printk(KERN_DEBUG "%s: Rx error (status %x)\n",
+			       dev->name, status & Rx_Stat_Mask);
+			/* WORKAROUND: LongErr and CRCErr means Overflow. */
+			if ((status & Rx_LongErr) && (status & Rx_CRCErr)) {
+				status &= ~(Rx_LongErr|Rx_CRCErr);
+				status |= Rx_Over;
+			}
+			if (status & Rx_LongErr) lp->stats.rx_length_errors++;
+			if (status & Rx_Over) lp->stats.rx_fifo_errors++;
+			if (status & Rx_CRCErr) lp->stats.rx_crc_errors++;
+			if (status & Rx_Align) lp->stats.rx_frame_errors++;
+		}
+
+		if (bd_count > 0) {
+			/* put Free Buffer back to controller */
+			int bdctl = le32_to_cpu(lp->rfd_cur->bd[bd_count - 1].BDCtl);
+			unsigned char id =
+				(bdctl & BD_RxBDID_MASK) >> BD_RxBDID_SHIFT;
+			if (id >= RX_BUF_PAGES) {
+				printk("%s: invalid BDID.\n", dev->name);
+				panic_queues(dev);
+			}
+			/* free old buffers */
+			while (lp->fbl_curid != id) {
+				bdctl = le32_to_cpu(lp->fbl_ptr->bd[lp->fbl_curid].BDCtl);
+				if (bdctl & BD_CownsBD) {
+					printk("%s: Freeing invalid BD.\n",
+					       dev->name);
+					panic_queues(dev);
+				}
+				/* pass BD to controler */
+				/* Note: BDLength was modified by chip. */
+				lp->fbl_ptr->bd[lp->fbl_curid].BDCtl =
+					cpu_to_le32(BD_CownsBD |
+						    (lp->fbl_curid << BD_RxBDID_SHIFT) |
+						    PAGE_SIZE);
+				lp->fbl_curid =
+					(lp->fbl_curid + 1) % RX_BUF_PAGES;
+				if (netif_msg_rx_status(lp)) {
+					printk("%s: Entering new FBD %d\n",
+					       dev->name, lp->fbl_curid);
+					dump_frfd(lp->fbl_ptr);
+				}
+				buf_free_count++;
+			}
+		}
+
+		/* put RxFD back to controller */
+		next_rfd = fd_bus_to_virt(lp, le32_to_cpu(lp->rfd_cur->fd.FDNext));
+		if (next_rfd < lp->rfd_base || next_rfd > lp->rfd_limit) {
+			printk("%s: RxFD FDNext invalid.\n", dev->name);
+			panic_queues(dev);
+		}
+		for (i = 0; i < (bd_count + 1) / 2 + 1; i++) {
+			/* pass FD to controler */
+			lp->rfd_cur->fd.FDNext = cpu_to_le32(0xdeaddead);	/* for debug */
+			lp->rfd_cur->fd.FDCtl = cpu_to_le32(FD_CownsFD);
+			lp->rfd_cur++;
+			fd_free_count++;
+		}
+
+		lp->rfd_cur = next_rfd;
+	}
+
+	/* re-enable BL/FDA Exhaust interrupts. */
+	if (fd_free_count) {
+		tc_writel(tc_readl(&tr->Int_En) | Int_FDAExEn, &tr->Int_En);
+		if (buf_free_count)
+			tc_writel(tc_readl(&tr->Int_En) | Int_BLExEn, &tr->Int_En);
+	}
+}
+
+#ifdef NO_CHECK_CARRIER
+#define TX_STA_ERR	(Tx_ExColl|Tx_Under|Tx_Defer|Tx_LateColl|Tx_TxPar|Tx_SQErr)
+#else
+#define TX_STA_ERR	(Tx_ExColl|Tx_Under|Tx_Defer|Tx_NCarr|Tx_LateColl|Tx_TxPar|Tx_SQErr)
+#endif
+
+static void
+tc35815_check_tx_stat(struct net_device *dev, int status)
+{
+	struct tc35815_local *lp = dev->priv;
+	const char *msg = NULL;
+
+	/* count collisions */
+	if (status & Tx_ExColl)
+		lp->stats.collisions += 16;
+	if (status & Tx_TxColl_MASK)
+		lp->stats.collisions += status & Tx_TxColl_MASK;
+
+#ifdef WORKAROUND_LOSTCAR
+	/* WORKAROUND: ignore LostCrS in full duplex operation */
+	if ((lp->timer_state != asleep && lp->timer_state != lcheck)
+	    || lp->fullduplex)
+		status &= ~Tx_NCarr;
+#endif
+
+	if (!(status & TX_STA_ERR)) {
+		/* no error. */
+		lp->stats.tx_packets++;
+		return;
+	}
+
+	lp->stats.tx_errors++;
+	if (status & Tx_ExColl) {
+		lp->stats.tx_aborted_errors++;
+		msg = "Excessive Collision.";
+	}
+	if (status & Tx_Under) {
+		lp->stats.tx_fifo_errors++;
+		msg = "Tx FIFO Underrun.";
+		if (lp->lstats.tx_underrun < TX_THRESHOLD_KEEP_LIMIT) {
+		  lp->lstats.tx_underrun++;
+		  if (lp->lstats.tx_underrun >= TX_THRESHOLD_KEEP_LIMIT) {
+		    struct tc35815_regs *tr =
+		      (struct tc35815_regs *)dev->base_addr;
+		    tc_writel(TX_THRESHOLD_MAX, &tr->TxThrsh);
+		    msg = "Tx FIFO Underrun.Change Tx threshold to max.";
+		  }
+		}
+	}
+	if (status & Tx_Defer) {
+		lp->stats.tx_fifo_errors++;
+		msg = "Excessive Deferral.";
+	}
+#ifndef NO_CHECK_CARRIER
+	if (status & Tx_NCarr) {
+		lp->stats.tx_carrier_errors++;
+		msg = "Lost Carrier Sense.";
+	}
+#endif
+	if (status & Tx_LateColl) {
+		lp->stats.tx_aborted_errors++;
+		msg = "Late Collision.";
+	}
+	if (status & Tx_TxPar) {
+		lp->stats.tx_fifo_errors++;
+		msg = "Transmit Parity Error.";
+	}
+	if (status & Tx_SQErr) {
+		lp->stats.tx_heartbeat_errors++;
+		msg = "Signal Quality Error.";
+	}
+	if (msg && netif_msg_tx_err(lp))
+		printk(KERN_WARNING "%s: %s (%#x)\n", dev->name, msg, status);
+}
+
+/* This handles TX complete events posted by the device
+ * via interrupts.
+ */
+static void
+tc35815_txdone(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	struct TxFD *txfd;
+	unsigned int fdctl;
+
+	txfd = &lp->tfd_base[lp->tfd_end];
+	while (lp->tfd_start != lp->tfd_end &&
+	       !((fdctl = le32_to_cpu(txfd->fd.FDCtl)) & FD_CownsFD)) {
+		int status = le32_to_cpu(txfd->fd.FDStat);
+		struct sk_buff *skb;
+		unsigned long fdnext = le32_to_cpu(txfd->fd.FDNext);
+
+		if (netif_msg_tx_done(lp)) {
+			printk("%s: complete TxFD.\n", dev->name);
+			dump_txfd(txfd);
+		}
+		tc35815_check_tx_stat(dev, status);
+
+		skb = le32_to_cpu(txfd->fd.FDSystem) != cpu_to_le32(0xffffffff) ?
+			lp->tx_skbs[le32_to_cpu(txfd->fd.FDSystem)].skb : NULL;
+		if (lp->tx_skbs[lp->tfd_end].skb != skb) {
+			printk("%s: tx_skbs mismatch.\n", dev->name);
+			panic_queues(dev);
+		}
+		if (skb) {
+			lp->stats.tx_bytes += skb->len;
+			pci_unmap_single(lp->pci_dev, lp->tx_skbs[lp->tfd_end].skb_dma, skb->len, PCI_DMA_TODEVICE);
+			lp->tx_skbs[lp->tfd_end].skb = NULL;
+			lp->tx_skbs[lp->tfd_end].skb_dma = 0;
+			dev_kfree_skb_irq(skb);
+		}
+		txfd->fd.FDSystem = cpu_to_le32(0xffffffff);
+
+		lp->tfd_end = (lp->tfd_end + 1) % TX_FD_NUM;
+		txfd = &lp->tfd_base[lp->tfd_end];
+		if ((fdnext & ~FD_Next_EOL) != fd_virt_to_bus(lp, txfd)) {
+			printk("%s: TxFD FDNext invalid.\n", dev->name);
+			panic_queues(dev);
+		}
+		if (fdnext & FD_Next_EOL) {
+			/* DMA Transmitter has been stopping... */
+			if (lp->tfd_end != lp->tfd_start) {
+				int head = (lp->tfd_start + TX_FD_NUM - 1) % TX_FD_NUM;
+				struct TxFD* txhead = &lp->tfd_base[head];
+				int qlen = (lp->tfd_start + TX_FD_NUM
+					    - lp->tfd_end) % TX_FD_NUM;
+
+				if (!(le32_to_cpu(txfd->fd.FDCtl) & FD_CownsFD)) {
+					printk("%s: TxFD FDCtl invalid.\n", dev->name);
+					panic_queues(dev);
+				}
+				/* log max queue length */
+				if (lp->lstats.max_tx_qlen < qlen)
+					lp->lstats.max_tx_qlen = qlen;
+
+
+				/* start DMA Transmitter again */
+				txhead->fd.FDNext |= cpu_to_le32(FD_Next_EOL);
+#ifdef GATHER_TXINT
+				txhead->fd.FDCtl |= cpu_to_le32(FD_FrmOpt_IntTx);
+#endif
+				if (netif_msg_tx_queued(lp)) {
+					printk("%s: start TxFD on queue.\n",
+					       dev->name);
+					dump_txfd(txfd);
+				}
+				tc_writel(fd_virt_to_bus(lp, txfd), &tr->TxFrmPtr);
+			}
+			break;
+		}
+	}
+
+	/* If we had stopped the queue due to a "tx full"
+	 * condition, and space has now been made available,
+	 * wake up the queue.
+	 */
+	if (netif_queue_stopped(dev) && ! tc35815_tx_full(dev))
+		netif_wake_queue(dev);
+}
+
+/* The inverse routine to tc35815_open(). */
+static int
+tc35815_close(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	netif_stop_queue(dev);
+
+	/* Flush the Tx and disable Rx here. */
+
+	del_timer(&lp->timer);		/* Kill if running	*/
+	tc35815_chip_reset((struct tc35815_regs*)dev->base_addr);
+	free_irq(dev->irq, dev);
+
+	tc35815_free_queues(dev);
+
+	return 0;
+
+}
+
+/*
+ * Get the current statistics.
+ * This may be called with the card open or closed.
+ */
+static struct net_device_stats *tc35815_get_stats(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	if (netif_running(dev)) {
+		/* Update the statistics from the device registers. */
+		lp->stats.rx_missed_errors = tc_readl(&tr->Miss_Cnt);
+	}
+
+	return &lp->stats;
+}
+
+static void tc35815_set_cam_entry(struct net_device *dev, int index, unsigned char *addr)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	int cam_index = index * 6;
+	unsigned long cam_data;
+	unsigned long saved_addr;
+	saved_addr = tc_readl(&tr->CAM_Adr);
+
+	if (netif_msg_hw(lp)) {
+		int i;
+		printk(KERN_DEBUG "%s: CAM %d:", MODNAME, index);
+		for (i = 0; i < 6; i++)
+			printk(" %02x", addr[i]);
+		printk("\n");
+	}
+	if (index & 1) {
+		/* read modify write */
+		tc_writel(cam_index - 2, &tr->CAM_Adr);
+		cam_data = tc_readl(&tr->CAM_Data) & 0xffff0000;
+		cam_data |= addr[0] << 8 | addr[1];
+		tc_writel(cam_data, &tr->CAM_Data);
+		/* write whole word */
+		tc_writel(cam_index + 2, &tr->CAM_Adr);
+		cam_data = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];
+		tc_writel(cam_data, &tr->CAM_Data);
+	} else {
+		/* write whole word */
+		tc_writel(cam_index, &tr->CAM_Adr);
+		cam_data = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
+		tc_writel(cam_data, &tr->CAM_Data);
+		/* read modify write */
+		tc_writel(cam_index + 4, &tr->CAM_Adr);
+		cam_data = tc_readl(&tr->CAM_Data) & 0x0000ffff;
+		cam_data |= addr[4] << 24 | (addr[5] << 16);
+		tc_writel(cam_data, &tr->CAM_Data);
+	}
+
+	tc_writel(saved_addr, &tr->CAM_Adr);
+}
+
+
+/*
+ * Set or clear the multicast filter for this adaptor.
+ * num_addrs == -1	Promiscuous mode, receive all packets
+ * num_addrs == 0	Normal mode, clear multicast list
+ * num_addrs > 0	Multicast mode, receive normal and MC packets,
+ *			and do best-effort filtering.
+ */
+static void
+tc35815_set_multicast_list(struct net_device *dev)
+{
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+
+	if (dev->flags&IFF_PROMISC)
+	{
+#ifdef WORKAROUND_100HALF_PROMISC
+		/* With some (all?) 100MHalf HUB, controller will hang
+		 * if we enabled promiscuous mode before linkup... */
+		struct tc35815_local *lp = dev->priv;
+		int pid = lp->phy_addr;
+		if (!(tc_mdio_read(dev, pid, MII_BMSR) & BMSR_LSTATUS))
+			return;
+#endif
+		/* Enable promiscuous mode */
+		tc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc | CAM_StationAcc, &tr->CAM_Ctl);
+	}
+	else if((dev->flags&IFF_ALLMULTI) || dev->mc_count > CAM_ENTRY_MAX - 3)
+	{
+		/* CAM 0, 1, 20 are reserved. */
+		/* Disable promiscuous mode, use normal mode. */
+		tc_writel(CAM_CompEn | CAM_BroadAcc | CAM_GroupAcc, &tr->CAM_Ctl);
+	}
+	else if(dev->mc_count)
+	{
+		struct dev_mc_list* cur_addr = dev->mc_list;
+		int i;
+		int ena_bits = CAM_Ena_Bit(CAM_ENTRY_SOURCE);
+
+		tc_writel(0, &tr->CAM_Ctl);
+		/* Walk the address list, and load the filter */
+		for (i = 0; i < dev->mc_count; i++, cur_addr = cur_addr->next) {
+			if (!cur_addr)
+				break;
+			/* entry 0,1 is reserved. */
+			tc35815_set_cam_entry(dev, i + 2, cur_addr->dmi_addr);
+			ena_bits |= CAM_Ena_Bit(i + 2);
+		}
+		tc_writel(ena_bits, &tr->CAM_Ena);
+		tc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);
+	}
+	else {
+		tc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);
+		tc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);
+	}
+}
+
+static void tc35815_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	struct tc35815_local *lp = dev->priv;
+	strcpy(info->driver, MODNAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, pci_name(lp->pci_dev));
+}
+
+static int tc35815_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tc35815_local *lp = dev->priv;
+	spin_lock_irq(&lp->lock);
+	mii_ethtool_gset(&lp->mii, cmd);
+	spin_unlock_irq(&lp->lock);
+	return 0;
+}
+
+static int tc35815_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct tc35815_local *lp = dev->priv;
+	int rc;
+#if 1	/* use our negotiation method... */
+	/* Verify the settings we care about. */
+	if (cmd->autoneg != AUTONEG_ENABLE &&
+	    cmd->autoneg != AUTONEG_DISABLE)
+		return -EINVAL;
+	if (cmd->autoneg == AUTONEG_DISABLE &&
+	    ((cmd->speed != SPEED_100 &&
+	      cmd->speed != SPEED_10) ||
+	     (cmd->duplex != DUPLEX_HALF &&
+	      cmd->duplex != DUPLEX_FULL)))
+		return -EINVAL;
+
+	/* Ok, do it to it. */
+	spin_lock_irq(&lp->lock);
+	del_timer(&lp->timer);
+	tc35815_start_auto_negotiation(dev, cmd);
+	spin_unlock_irq(&lp->lock);
+	rc = 0;
+#else
+	spin_lock_irq(&lp->lock);
+	rc = mii_ethtool_sset(&lp->mii, cmd);
+	spin_unlock_irq(&lp->lock);
+#endif
+	return rc;
+}
+
+static int tc35815_nway_reset(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int rc;
+	spin_lock_irq(&lp->lock);
+	rc = mii_nway_restart(&lp->mii);
+	spin_unlock_irq(&lp->lock);
+	return rc;
+}
+
+static u32 tc35815_get_link(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int rc;
+	spin_lock_irq(&lp->lock);
+	rc = mii_link_ok(&lp->mii);
+	spin_unlock_irq(&lp->lock);
+	return rc;
+}
+
+static u32 tc35815_get_msglevel(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	return lp->msg_enable;
+}
+
+static void tc35815_set_msglevel(struct net_device *dev, u32 datum)
+{
+	struct tc35815_local *lp = dev->priv;
+	lp->msg_enable = datum;
+}
+
+static int tc35815_get_stats_count(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	return sizeof(lp->lstats) / sizeof(int);
+}
+
+static void tc35815_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)
+{
+	struct tc35815_local *lp = dev->priv;
+	data[0] = lp->lstats.max_tx_qlen;
+	data[1] = lp->lstats.tx_ints;
+	data[2] = lp->lstats.rx_ints;
+	data[3] = lp->lstats.tx_underrun;
+}
+
+static struct {
+	const char str[ETH_GSTRING_LEN];
+} ethtool_stats_keys[] = {
+	{ "max_tx_qlen" },
+	{ "tx_ints" },
+	{ "rx_ints" },
+	{ "tx_underrun" },
+};
+
+static void tc35815_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	memcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));
+}
+
+static struct ethtool_ops tc35815_ethtool_ops = {
+	.get_drvinfo		= tc35815_get_drvinfo,
+	.get_settings		= tc35815_get_settings,
+	.set_settings		= tc35815_set_settings,
+	.nway_reset		= tc35815_nway_reset,
+	.get_link		= tc35815_get_link,
+	.get_msglevel		= tc35815_get_msglevel,
+	.set_msglevel		= tc35815_set_msglevel,
+	.get_strings		= tc35815_get_strings,
+	.get_stats_count	= tc35815_get_stats_count,
+	.get_ethtool_stats	= tc35815_get_ethtool_stats,
+};
+
+static int tc35815_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *) & rq->ifr_data;
+	int rc;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	spin_lock_irq(&lp->lock);
+	rc = generic_mii_ioctl(&lp->mii, data, cmd, NULL);
+	spin_unlock_irq(&lp->lock);
+
+	return rc;
+}
+
+static int tc_mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	unsigned long data;
+	tc_writel(MD_CA_Busy | (phy_id << 5) | location, &tr->MD_CA);
+	while (tc_readl(&tr->MD_CA) & MD_CA_Busy)
+		;
+	data = tc_readl(&tr->MD_Data);
+	return data & 0xffff;
+}
+
+static void tc_mdio_write(struct net_device *dev, int phy_id, int location,
+			  int val)
+{
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	tc_writel(val, &tr->MD_Data);
+	tc_writel(MD_CA_Busy | MD_CA_Wr | (phy_id << 5) | location, &tr->MD_CA);
+	while (tc_readl(&tr->MD_CA) & MD_CA_Busy)
+		;
+}
+
+/* Auto negotiation.  The scheme is very simple.  We have a timer routine
+ * that keeps watching the auto negotiation process as it progresses.
+ * The DP83840 is first told to start doing it's thing, we set up the time
+ * and place the timer state machine in it's initial state.
+ *
+ * Here the timer peeks at the DP83840 status registers at each click to see
+ * if the auto negotiation has completed, we assume here that the DP83840 PHY
+ * will time out at some point and just tell us what (didn't) happen.  For
+ * complete coverage we only allow so many of the ticks at this level to run,
+ * when this has expired we print a warning message and try another strategy.
+ * This "other" strategy is to force the interface into various speed/duplex
+ * configurations and we stop when we see a link-up condition before the
+ * maximum number of "peek" ticks have occurred.
+ *
+ * Once a valid link status has been detected we configure the BigMAC and
+ * the rest of the Happy Meal to speak the most efficient protocol we could
+ * get a clean link for.  The priority for link configurations, highest first
+ * is:
+ *                 100 Base-T Full Duplex
+ *                 100 Base-T Half Duplex
+ *                 10 Base-T Full Duplex
+ *                 10 Base-T Half Duplex
+ *
+ * We start a new timer now, after a successful auto negotiation status has
+ * been detected.  This timer just waits for the link-up bit to get set in
+ * the BMCR of the DP83840.  When this occurs we print a kernel log message
+ * describing the link type in use and the fact that it is up.
+ *
+ * If a fatal error of some sort is signalled and detected in the interrupt
+ * service routine, and the chip is reset, or the link is ifconfig'd down
+ * and then back up, this entire process repeats itself all over again.
+ */
+/* Note: Above comments are come from sunhme driver. */
+
+static int tc35815_try_next_permutation(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short bmcr;
+
+	bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+
+	/* Downgrade from full to half duplex.  Only possible via ethtool.  */
+	if (bmcr & BMCR_FULLDPLX) {
+		bmcr &= ~BMCR_FULLDPLX;
+		printk(KERN_DEBUG "%s: try next permutation (BMCR %x)\n", dev->name, bmcr);
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+		return 0;
+	}
+
+	/* Downgrade from 100 to 10. */
+	if (bmcr & BMCR_SPEED100) {
+		bmcr &= ~BMCR_SPEED100;
+		printk(KERN_DEBUG "%s: try next permutation (BMCR %x)\n", dev->name, bmcr);
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+		return 0;
+	}
+
+	/* We've tried everything. */
+	return -1;
+}
+
+static void
+tc35815_display_link_mode(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short lpa, bmcr;
+	char *speed = "", *duplex = "";
+
+	lpa = tc_mdio_read(dev, pid, MII_LPA);
+	bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+	if (options.speed ? (bmcr & BMCR_SPEED100) : (lpa & (LPA_100HALF | LPA_100FULL)))
+		speed = "100Mb/s";
+	else
+		speed = "10Mb/s";
+	if (options.duplex ? (bmcr & BMCR_FULLDPLX) : (lpa & (LPA_100FULL | LPA_10FULL)))
+		duplex = "Full Duplex";
+	else
+		duplex = "Half Duplex";
+
+	if (netif_msg_link(lp))
+		printk(KERN_INFO "%s: Link is up at %s, %s.\n",
+		       dev->name, speed, duplex);
+	printk(KERN_DEBUG "%s: MII BMCR %04x BMSR %04x LPA %04x\n",
+	       dev->name,
+	       bmcr, tc_mdio_read(dev, pid, MII_BMSR), lpa);
+}
+
+static void tc35815_display_forced_link_mode(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short bmcr;
+	char *speed = "", *duplex = "";
+
+	bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+	if (bmcr & BMCR_SPEED100)
+		speed = "100Mb/s";
+	else
+		speed = "10Mb/s";
+	if (bmcr & BMCR_FULLDPLX)
+		duplex = "Full Duplex.\n";
+	else
+		duplex = "Half Duplex.\n";
+
+	if (netif_msg_link(lp))
+		printk(KERN_INFO "%s: Link has been forced up at %s, %s",
+		       dev->name, speed, duplex);
+}
+
+static void tc35815_set_link_modes(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	int pid = lp->phy_addr;
+	unsigned short bmcr, lpa;
+
+	if (lp->timer_state == arbwait) {
+		printk(KERN_DEBUG "%s: MII BMCR %04x BMSR %04x LPA %04x\n",
+		       dev->name,
+		       tc_mdio_read(dev, pid, MII_BMCR),
+		       tc_mdio_read(dev, pid, MII_BMSR),
+		       tc_mdio_read(dev, pid, MII_LPA));
+		lpa = tc_mdio_read(dev, pid, MII_LPA);
+		if (!(lpa & (LPA_10HALF | LPA_10FULL |
+			     LPA_100HALF | LPA_100FULL))) {
+			/* fall back to 10HALF */
+			printk(KERN_INFO "%s: bad ability %04x - falling back to 10HD.\n",
+			       dev->name, lpa);
+			lpa = LPA_10HALF;
+		}
+		bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+		if (options.duplex ? (bmcr & BMCR_FULLDPLX) : (lpa & (LPA_100FULL | LPA_10FULL)))
+			lp->fullduplex = 1;
+		else
+			lp->fullduplex = 0;
+	} else {
+		/* Forcing a link mode. */
+		bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+		if (bmcr & BMCR_FULLDPLX)
+			lp->fullduplex = 1;
+		else
+			lp->fullduplex = 0;
+	}
+
+	tc_writel(tc_readl(&tr->MAC_Ctl) | MAC_HaltReq, &tr->MAC_Ctl);
+	if (lp->fullduplex) {
+		tc_writel(tc_readl(&tr->MAC_Ctl) | MAC_FullDup, &tr->MAC_Ctl);
+	} else {
+		tc_writel(tc_readl(&tr->MAC_Ctl) & ~MAC_FullDup, &tr->MAC_Ctl);
+	}
+	tc_writel(tc_readl(&tr->MAC_Ctl) & ~MAC_HaltReq, &tr->MAC_Ctl);
+
+#ifdef WORKAROUND_LOSTCAR
+	/* WORKAROUND: enable LostCrS only if half duplex operation */
+	if (!lp->fullduplex)
+		tc_writel(tc_readl(&tr->Tx_Ctl) | Tx_EnLCarr, &tr->Tx_Ctl);
+#endif
+	lp->mii.full_duplex = lp->fullduplex;
+}
+
+static void tc35815_timer(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short bmsr, bmcr, lpa;
+	int restart_timer = 0;
+
+	spin_lock_irq(&lp->lock);
+
+	lp->timer_ticks++;
+	switch (lp->timer_state) {
+	case arbwait:
+		/*
+		 * Only allow for 5 ticks, thats 10 seconds and much too
+		 * long to wait for arbitration to complete.
+		 */
+		/* TC35815 need more times... */
+		if (lp->timer_ticks >= 10) {
+			/* Enter force mode. */
+			if (!options.doforce) {
+				printk(KERN_NOTICE "%s: Auto-Negotiation unsuccessful,"
+				       " cable probblem?\n", dev->name);
+				/* Try to restart the adaptor. */
+				tc35815_restart(dev);
+				goto out;
+			}
+			printk(KERN_NOTICE "%s: Auto-Negotiation unsuccessful,"
+			       " trying force link mode\n", dev->name);
+			printk(KERN_DEBUG "%s: BMCR %x BMSR %x\n", dev->name,
+			       tc_mdio_read(dev, pid, MII_BMCR),
+			       tc_mdio_read(dev, pid, MII_BMSR));
+			bmcr = BMCR_SPEED100;
+			tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+
+			/*
+			 * OK, seems we need do disable the transceiver
+			 * for the first tick to make sure we get an
+			 * accurate link state at the second tick.
+			 */
+
+			lp->timer_state = ltrywait;
+			lp->timer_ticks = 0;
+			restart_timer = 1;
+		} else {
+			/* Anything interesting happen? */
+			bmsr = tc_mdio_read(dev, pid, MII_BMSR);
+			if (bmsr & BMSR_ANEGCOMPLETE) {
+				/* Just what we've been waiting for... */
+				tc35815_set_link_modes(dev);
+
+				/*
+				 * Success, at least so far, advance our state
+				 * engine.
+				 */
+				lp->timer_state = lupwait;
+				restart_timer = 1;
+			} else {
+				restart_timer = 1;
+			}
+		}
+		break;
+
+	case lupwait:
+		/*
+		 * Auto negotiation was successful and we are awaiting a
+		 * link up status.  I have decided to let this timer run
+		 * forever until some sort of error is signalled, reporting
+		 * a message to the user at 10 second intervals.
+		 */
+		bmsr = tc_mdio_read(dev, pid, MII_BMSR);
+		if (bmsr & BMSR_LSTATUS) {
+			/*
+			 * Wheee, it's up, display the link mode in use and put
+			 * the timer to sleep.
+			 */
+			tc35815_display_link_mode(dev);
+#if defined(CONFIG_TOSHIBA_RBTX4939)
+                        lpa = tc_mdio_read(dev, pid, MII_LPA);
+                        extern void tx4939_set_pcfg_rmii_speed(struct net_device *dev, int speed);
+                        tx4939_set_pcfg_rmii_speed(dev, lpa & (LPA_100HALF | LPA_100FULL));
+#endif
+			netif_carrier_on(dev);
+#ifdef WORKAROUND_100HALF_PROMISC
+			/* delayed promiscuous enabling */
+			if (dev->flags & IFF_PROMISC)
+				tc35815_set_multicast_list(dev);
+#endif
+#if 1
+			lp->saved_lpa = tc_mdio_read(dev, pid, MII_LPA);
+			lp->timer_state = lcheck;
+			restart_timer = 1;
+#else
+			lp->timer_state = asleep;
+			restart_timer = 0;
+#endif
+		} else {
+			if (lp->timer_ticks >= 10) {
+				printk(KERN_NOTICE "%s: Auto negotiation successful, link still "
+				       "not completely up.\n", dev->name);
+				lp->timer_ticks = 0;
+				restart_timer = 1;
+			} else {
+				restart_timer = 1;
+			}
+		}
+		break;
+
+	case ltrywait:
+		/*
+		 * Making the timeout here too long can make it take
+		 * annoyingly long to attempt all of the link mode
+		 * permutations, but then again this is essentially
+		 * error recovery code for the most part.
+		 */
+		bmsr = tc_mdio_read(dev, pid, MII_BMSR);
+		bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+		if (lp->timer_ticks == 1) {
+			/*
+			 * Re-enable transceiver, we'll re-enable the
+			 * transceiver next tick, then check link state
+			 * on the following tick.
+			 */
+			restart_timer = 1;
+			break;
+		}
+		if (lp->timer_ticks == 2) {
+			restart_timer = 1;
+			break;
+		}
+		if (bmsr & BMSR_LSTATUS) {
+			/* Force mode selection success. */
+			tc35815_display_forced_link_mode(dev);
+			netif_carrier_on(dev);
+			tc35815_set_link_modes(dev);
+#ifdef WORKAROUND_100HALF_PROMISC
+			/* delayed promiscuous enabling */
+			if (dev->flags & IFF_PROMISC)
+				tc35815_set_multicast_list(dev);
+#endif
+#if 1
+			lp->saved_lpa = tc_mdio_read(dev, pid, MII_LPA);
+			lp->timer_state = lcheck;
+			restart_timer = 1;
+#else
+			lp->timer_state = asleep;
+			restart_timer = 0;
+#endif
+		} else {
+			if (lp->timer_ticks >= 4) { /* 6 seconds or so... */
+				int ret;
+
+				ret = tc35815_try_next_permutation(dev);
+				if (ret == -1) {
+					/*
+					 * Aieee, tried them all, reset the
+					 * chip and try all over again.
+					 */
+					printk(KERN_NOTICE "%s: Link down, "
+					       "cable problem?\n",
+					       dev->name);
+
+					/* Try to restart the adaptor. */
+					tc35815_restart(dev);
+					goto out;
+				}
+				lp->timer_ticks = 0;
+				restart_timer = 1;
+			} else {
+				restart_timer = 1;
+			}
+		}
+		break;
+
+	case lcheck:
+		bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+		lpa = tc_mdio_read(dev, pid, MII_LPA);
+		if (bmcr & (BMCR_PDOWN | BMCR_ISOLATE | BMCR_RESET)) {
+			printk(KERN_ERR "%s: PHY down? (BMCR %x)\n", dev->name,
+			       bmcr);
+		} else if ((lp->saved_lpa ^ lpa) &
+			   (LPA_100FULL|LPA_100HALF|LPA_10FULL|LPA_10HALF)) {
+			printk(KERN_NOTICE "%s: link status changed"
+			       " (BMCR %x LPA %x->%x)\n", dev->name,
+			       bmcr, lp->saved_lpa, lpa);
+		} else {
+			/* go on */
+			restart_timer = 1;
+			break;
+		}
+		/* Try to restart the adaptor. */
+		tc35815_restart(dev);
+		goto out;
+
+	case asleep:
+	default:
+		/* Can't happens.... */
+		printk(KERN_ERR "%s: Aieee, link timer is asleep but we got "
+		       "one anyways!\n", dev->name);
+		restart_timer = 0;
+		lp->timer_ticks = 0;
+		lp->timer_state = asleep; /* foo on you */
+		break;
+	}
+
+	if (restart_timer) {
+		lp->timer.expires = jiffies + ((12 * HZ)/10); /* 1.2s */
+		add_timer(&lp->timer);
+	}
+out:
+	spin_unlock_irq(&lp->lock);
+}
+
+static void tc35815_start_auto_negotiation(struct net_device *dev,
+					   struct ethtool_cmd *ep)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short bmsr, bmcr, advertize;
+	int timeout;
+
+	netif_carrier_off(dev);
+	bmsr = tc_mdio_read(dev, pid, MII_BMSR);
+	bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+	advertize = tc_mdio_read(dev, pid, MII_ADVERTISE);
+
+	if (ep == NULL || ep->autoneg == AUTONEG_ENABLE) {
+		if (options.speed || options.duplex) {
+			/* Advertise only specified configuration. */
+			advertize &= ~(ADVERTISE_10HALF |
+				       ADVERTISE_10FULL |
+				       ADVERTISE_100HALF |
+				       ADVERTISE_100FULL);
+			if (options.speed != 10) {
+				if (options.duplex != 1)
+					advertize |= ADVERTISE_100FULL;
+				if (options.duplex != 2)
+					advertize |= ADVERTISE_100HALF;
+			}
+			if (options.speed != 100) {
+				if (options.duplex != 1)
+					advertize |= ADVERTISE_10FULL;
+				if (options.duplex != 2)
+					advertize |= ADVERTISE_10HALF;
+			}
+			if (options.speed == 100)
+				bmcr |= BMCR_SPEED100;
+			else if (options.speed == 10)
+				bmcr &= ~BMCR_SPEED100;
+			if (options.duplex == 2)
+				bmcr |= BMCR_FULLDPLX;
+			else if (options.duplex == 1)
+				bmcr &= ~BMCR_FULLDPLX;
+		} else {
+			/* Advertise everything we can support. */
+			if (bmsr & BMSR_10HALF)
+				advertize |= ADVERTISE_10HALF;
+			else
+				advertize &= ~ADVERTISE_10HALF;
+			if (bmsr & BMSR_10FULL)
+				advertize |= ADVERTISE_10FULL;
+			else
+				advertize &= ~ADVERTISE_10FULL;
+			if (bmsr & BMSR_100HALF)
+				advertize |= ADVERTISE_100HALF;
+			else
+				advertize &= ~ADVERTISE_100HALF;
+			if (bmsr & BMSR_100FULL)
+				advertize |= ADVERTISE_100FULL;
+			else
+				advertize &= ~ADVERTISE_100FULL;
+		}
+
+		tc_mdio_write(dev, pid, MII_ADVERTISE, advertize);
+
+		/* Enable Auto-Negotiation, this is usually on already... */
+		bmcr |= BMCR_ANENABLE;
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+
+		/* Restart it to make sure it is going. */
+		bmcr |= BMCR_ANRESTART;
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+		printk(KERN_DEBUG "%s: ADVERTISE %x BMCR %x\n", dev->name, advertize, bmcr);
+
+		/* BMCR_ANRESTART self clears when the process has begun. */
+		timeout = 64;  /* More than enough. */
+		while (--timeout) {
+			bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+			if (!(bmcr & BMCR_ANRESTART))
+				break; /* got it. */
+			udelay(10);
+		}
+		if (!timeout) {
+			printk(KERN_ERR "%s: TC35815 would not start auto "
+			       "negotiation BMCR=0x%04x\n",
+			       dev->name, bmcr);
+			printk(KERN_NOTICE "%s: Performing force link "
+			       "detection.\n", dev->name);
+			goto force_link;
+		} else {
+			printk(KERN_DEBUG "%s: auto negotiation started.\n", dev->name);
+			lp->timer_state = arbwait;
+		}
+	} else {
+force_link:
+		/* Force the link up, trying first a particular mode.
+		 * Either we are here at the request of ethtool or
+		 * because the Happy Meal would not start to autoneg.
+		 */
+
+		/* Disable auto-negotiation in BMCR, enable the duplex and
+		 * speed setting, init the timer state machine, and fire it off.
+		 */
+		if (ep == NULL || ep->autoneg == AUTONEG_ENABLE) {
+			bmcr = BMCR_SPEED100;
+		} else {
+			if (ep->speed == SPEED_100)
+				bmcr = BMCR_SPEED100;
+			else
+				bmcr = 0;
+			if (ep->duplex == DUPLEX_FULL)
+				bmcr |= BMCR_FULLDPLX;
+		}
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr);
+
+		/* OK, seems we need do disable the transceiver for the first
+		 * tick to make sure we get an accurate link state at the
+		 * second tick.
+		 */
+		lp->timer_state = ltrywait;
+	}
+
+	del_timer(&lp->timer);
+	lp->timer_ticks = 0;
+	lp->timer.expires = jiffies + (12 * HZ)/10;  /* 1.2 sec. */
+	lp->timer.data = (unsigned long) dev;
+	lp->timer.function = &tc35815_timer;
+	add_timer(&lp->timer);
+}
+
+static void tc35815_find_phy(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short id0;
+
+	/* find MII phy */
+	for (pid = 31; pid >= 0; pid--) {
+		id0 = tc_mdio_read(dev, pid, MII_BMSR);
+		if (id0 != 0xffff && id0 != 0x0000 &&
+		    (id0 & BMSR_RESV) != (0xffff & BMSR_RESV) /* paranoia? */
+			) {
+			lp->phy_addr = pid;
+			break;
+		}
+	}
+	if (pid < 0) {
+		printk(KERN_ERR "%s: No MII Phy found.\n",
+		       dev->name);
+		lp->phy_addr = pid = 0;
+	}
+
+	lp->mii_id[0] = tc_mdio_read(dev, pid, MII_PHYSID1);
+	lp->mii_id[1] = tc_mdio_read(dev, pid, MII_PHYSID2);
+	if (netif_msg_hw(lp))
+		printk(KERN_INFO "%s: PHY(%02x) ID %04x %04x\n", dev->name,
+		       pid, lp->mii_id[0], lp->mii_id[1]);
+}
+
+static void tc35815_phy_chip_init(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	int pid = lp->phy_addr;
+	unsigned short bmcr;
+	struct ethtool_cmd ecmd, *ep;
+
+	/* dis-isolate if needed. */
+	bmcr = tc_mdio_read(dev, pid, MII_BMCR);
+	if (bmcr & BMCR_ISOLATE) {
+		int count = 32;
+		printk(KERN_DEBUG "%s: unisolating...", dev->name);
+		tc_mdio_write(dev, pid, MII_BMCR, bmcr & ~BMCR_ISOLATE);
+		while (--count) {
+			if (!(tc_mdio_read(dev, pid, MII_BMCR) & BMCR_ISOLATE))
+				break;
+			udelay(20);
+		}
+		printk(" %s.\n", count ? "done" : "failed");
+	}
+
+	if (options.speed && options.duplex) {
+		ecmd.autoneg = AUTONEG_DISABLE;
+		ecmd.speed = options.speed == 10 ? SPEED_10 : SPEED_100;
+		ecmd.duplex = options.duplex == 1 ? DUPLEX_HALF : DUPLEX_FULL;
+		ep = &ecmd;
+	} else {
+		ep = NULL;
+	}
+	tc35815_start_auto_negotiation(dev, ep);
+}
+
+static void tc35815_chip_reset(struct tc35815_regs *tr)
+{
+	int i;
+	/* reset the controller */
+	tc_writel(MAC_Reset, &tr->MAC_Ctl);
+	udelay(40); /* 3200ns */
+	i = 0;
+	while (tc_readl(&tr->MAC_Ctl) & MAC_Reset) {
+		if (i++ > 100) {
+			printk(KERN_ERR "%s: MAC reset failed.\n", MODNAME);
+			break;
+		}
+		mdelay(1);
+	}
+	tc_writel(0, &tr->MAC_Ctl);
+
+	/* initialize registers to default value */
+	tc_writel(0, &tr->DMA_Ctl);
+	tc_writel(0, &tr->TxThrsh);
+	tc_writel(0, &tr->TxPollCtr);
+	tc_writel(0, &tr->RxFragSize);
+	tc_writel(0, &tr->Int_En);
+	tc_writel(0, &tr->FDA_Bas);
+	tc_writel(0, &tr->FDA_Lim);
+	tc_writel(0xffffffff, &tr->Int_Src);	/* Write 1 to clear */
+	tc_writel(0, &tr->CAM_Ctl);
+	tc_writel(0, &tr->Tx_Ctl);
+	tc_writel(0, &tr->Rx_Ctl);
+	tc_writel(0, &tr->CAM_Ena);
+	(void)tc_readl(&tr->Miss_Cnt);	/* Read to clear */
+
+	/* initialize internal SRAM */
+	tc_writel(DMA_TestMode, &tr->DMA_Ctl);
+	for (i = 0; i < 0x1000; i += 4) {
+		tc_writel(i, &tr->CAM_Adr);
+		tc_writel(0, &tr->CAM_Data);
+	}
+	tc_writel(0, &tr->DMA_Ctl);
+}
+
+static void tc35815_chip_init(struct net_device *dev)
+{
+	struct tc35815_local *lp = dev->priv;
+	struct tc35815_regs *tr = (struct tc35815_regs *)dev->base_addr;
+	unsigned long txctl = TX_CTL_CMD;
+
+	tc35815_phy_chip_init(dev);
+
+	/* load station address to CAM */
+	tc35815_set_cam_entry(dev, CAM_ENTRY_SOURCE, dev->dev_addr);
+
+	/* Enable CAM (broadcast and unicast) */
+	tc_writel(CAM_Ena_Bit(CAM_ENTRY_SOURCE), &tr->CAM_Ena);
+	tc_writel(CAM_CompEn | CAM_BroadAcc, &tr->CAM_Ctl);
+
+#if 0	/* __BIG_ENDIAN? */
+	tc_writel(DMA_RxBigE | DMA_TxBigE | DMA_BURST_SIZE, &tr->DMA_Ctl);
+#else
+	tc_writel(DMA_BURST_SIZE, &tr->DMA_Ctl);
+#endif
+	tc_writel(RxFrag_EnPack | ETH_ZLEN, &tr->RxFragSize);	/* Packing */
+	tc_writel(0, &tr->TxPollCtr);	/* Batch mode */
+	tc_writel(TX_THRESHOLD, &tr->TxThrsh);
+	tc_writel(INT_EN_CMD, &tr->Int_En);
+
+	/* set queues */
+	tc_writel(fd_virt_to_bus(lp, lp->rfd_base), &tr->FDA_Bas);
+	tc_writel((unsigned long)lp->rfd_limit - (unsigned long)lp->rfd_base,
+		  &tr->FDA_Lim);
+	/*
+	 * Activation method:
+	 * First, enable the MAC Transmitter and the DMA Receive circuits.
+	 * Then enable the DMA Transmitter and the MAC Receive circuits.
+	 */
+	tc_writel(fd_virt_to_bus(lp, lp->fbl_ptr), &tr->BLFrmPtr);	/* start DMA receiver */
+	tc_writel(RX_CTL_CMD, &tr->Rx_Ctl);	/* start MAC receiver */
+
+	/* start MAC transmitter */
+#ifdef WORKAROUND_LOSTCAR
+	/* WORKAROUND: ignore LostCrS in full duplex operation */
+	if ((lp->timer_state != asleep && lp->timer_state != lcheck) ||
+	    lp->fullduplex)
+		txctl = TX_CTL_CMD & ~Tx_EnLCarr;
+#endif
+#ifdef GATHER_TXINT
+	txctl &= ~Tx_EnComp;	/* disable global tx completion int. */
+#endif
+	tc_writel(txctl, &tr->Tx_Ctl);
+#if 0	/* No need to polling */
+	tc_writel(fd_virt_to_bus(lp, lp->tfd_base), &tr->TxFrmPtr);	/* start DMA transmitter */
+#endif
+}
+
+static struct pci_driver tc35815_pci_driver = {
+	.name		= MODNAME,
+	.id_table	= tc35815_pci_tbl,
+	.probe		= tc35815_init_one,
+	.remove		= __devexit_p(tc35815_remove_one),
+#if 0
+	.suspend	= tc35815_suspend,
+	.resume		= tc35815_resume,
+#endif
+};
+
+module_param_named(speed, options.speed, int, 0);
+MODULE_PARM_DESC(speed, "0:auto, 10:10Mbps, 100:100Mbps");
+module_param_named(duplex, options.duplex, int, 0);
+MODULE_PARM_DESC(duplex, "0:auto, 1:half, 2:full");
+module_param_named(doforce, options.doforce, int, 0);
+MODULE_PARM_DESC(doforce, "try force link mode if auto-negotiation failed");
+
+#ifndef MODULE
+static int __init tc35815_setup(char *str)
+{
+	static struct {
+		char *name;
+		int *val;
+	} opts[] = {
+		{ "speed:", &options.speed },
+		{ "duplex:", &options.duplex },
+		{ "doforce:", &options.doforce },
+	};
+	int i;
+	char *p;
+	p = str;
+	while (p) {
+		for (i = 0; i < ARRAY_SIZE(opts); i++) {
+			int optlen = strlen(opts[i].name);
+			if (strncmp(p, opts[i].name, optlen) == 0) {
+				*opts[i].val = simple_strtol(p + optlen, NULL, 0);
+				break;
+			}
+		}
+		p = strchr(p, ',');
+		if (p)
+			p++;
+	}
+	return 1;
+}
+__setup("tc35815=", tc35815_setup);
+#endif
+
+static int __init tc35815_init_module (void)
+{
+/* when a module, this is printed whether or not devices are found in probe */
+#ifdef MODULE
+	printk(version);
+#endif
+	return pci_module_init (&tc35815_pci_driver);
+}
+
+
+static void __exit tc35815_cleanup_module (void)
+{
+	pci_unregister_driver (&tc35815_pci_driver);
+}
+
+
+module_init(tc35815_init_module);
+module_exit(tc35815_cleanup_module);
+
+MODULE_DESCRIPTION("TOSHIBA TC35815 PCI 10M/100M Ethernet driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.10/drivers/pci/pci.ids
===================================================================
--- linux-2.6.10.orig/drivers/pci/pci.ids
+++ linux-2.6.10/drivers/pci/pci.ids
@@ -1438,11 +1438,17 @@
 	0009  r4x00
 	0020  ATM Meteor 155
 		102f 00f8  ATM Meteor 155
+	0030  TC35815 Ethernet Controller
+	0031  TC35815 Ethernet Controller
+	0032  TX4939 Ethernet MAC Controller
 	0105  TC86C001 [goku-s] IDE
 	0106  TC86C001 [goku-s] USB 1.1 Host
 	0107  TC86C001 [goku-s] USB Device Controller
 	0108  TC86C001 [goku-s] I2C/SIO/GPIO Controller
-	0180  TX4927
+	0180  TX4927 PCI Controller
+	0181  TX4925 PCI Controller
+	0184  TX4939 PCI Controller(external)
+	0185  TX4939 PCI Controller(internal)
 1030  TMC Research
 1031  Miro Computer Products AG
 	5601  DC20 ASIC
Index: linux-2.6.10/drivers/pci/quirks.c
===================================================================
--- linux-2.6.10.orig/drivers/pci/quirks.c
+++ linux-2.6.10/drivers/pci/quirks.c
@@ -585,6 +585,21 @@ static void __devinit quirk_dunord ( str
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_DUNORD,	PCI_DEVICE_ID_DUNORD_I3000,	quirk_dunord );
 
+
+static void __devinit quirk_vt6212(struct pci_dev *dev)
+{
+        unsigned char dat;
+
+        printk(KERN_INFO "PCI: %02x:%02x", dev->bus->number, dev->devfn);
+        pci_write_config_byte(dev, 0x41, 0x00);
+        pci_read_config_byte(dev, 0x41, &dat);
+        printk(" Offset 0x41 = %02x", dat);
+        printk("\n");
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, 0x3038, quirk_vt6212); /* function 0,1 */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, 0x3104, quirk_vt6212); /* function 2 */
+
+
 /*
  * i82380FB mobile docking controller: its PCI-to-PCI bridge
  * is subtractive decoding (transparent), and does indicate this
Index: linux-2.6.10/drivers/scsi/ide-scsi.c
===================================================================
--- linux-2.6.10.orig/drivers/scsi/ide-scsi.c
+++ linux-2.6.10/drivers/scsi/ide-scsi.c
@@ -391,6 +391,12 @@ static int idescsi_end_request (ide_driv
 	} else if (rq->errors) {
 		if (log)
 			printk ("ide-scsi: %s: check condition for %lu\n", drive->name, pc->scsi_cmd->serial_number);
+#if defined(CONFIG_BLK_DEV_IDE_TX4939)
+                if (IS_IDE_TX4939) {
+                        extern void tx4939_ide_softreset(ide_drive_t*);
+                        tx4939_ide_softreset(drive);
+                }
+#endif
 		if (!idescsi_check_condition(drive, rq))
 			/* we started a request sense, so we'll be back, exit for now */
 			return 0;
Index: linux-2.6.10/include/asm-mips/bootinfo.h
===================================================================
--- linux-2.6.10.orig/include/asm-mips/bootinfo.h
+++ linux-2.6.10/include/asm-mips/bootinfo.h
@@ -160,9 +160,9 @@
 #define  MACH_TOSHIBA_RBTX4927	4
 #define  MACH_TOSHIBA_RBTX4937	5
 #define  MACH_TOSHIBA_RBTX4938	6
-
+#define  MACH_TOSHIBA_RBTX4939	7
 #define GROUP_TOSHIBA_NAMES	{ "Pallas", "TopasCE", "JMR", "JMR TX3927", \
-				  "RBTX4927", "RBTX4937" }
+				  "RBTX4927", "RBTX4937", "RBTX4938", "RBTX4939", }
 
 /*
  * Valid machtype for group Alchemy
Index: linux-2.6.10/include/asm-mips/tx4939/config.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4939/config.h
@@ -0,0 +1,162 @@
+/*
+ * include/asm-mips/tx4939/config.h
+ *
+ * Definitions configuration for TX4939
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#ifndef __ASM_TX4939_CONFIG_H
+#define __ASM_TX4939_CONFIG_H
+
+/* Memory Size */
+#define CONFIG_TOSHIBA_TX4939_MEMSIZE   256	/* MB */
+#define CONFIG_TOSHIBA_TX4939_PCI_GBWC  0xf00
+
+/* Pin Multiplexing */
+#if 0				/* 1 means no using Menu Config */
+
+/* Pin Multiplexing for ACLINK ans I2S --- GPIO[04:09] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_GPIO04_09
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_ACLINK
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_I2S
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_GPIO04_09
+
+/* Pin Multiplexing for I2C --- GPIO[10:11] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_GPIO10_11
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_I2C
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_GPIO10_11
+
+/* Pin Multiplexing for RTS/CTS and SIO2/3 --- GPIO[12:15] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_GPIO12_15
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_SPI
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_CTS_RTS
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_SIO2
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_GPIO12_15
+
+/* Pin Multiplexing for ATA100-0 --- G0PIO[00:29] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_G0PIO
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_ATA0
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_ATA0
+
+/* Pin Multiplexing for ATA100-1 and Ether --- G1PIO[00:29] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_G1PIO
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_ATA1
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_ETHER
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_ETHER
+
+/* Pin Multiplexing for Video port --- G2PIO[00:16] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_G2PIO
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_PC_TRACE
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_1PARALLEL_PORT
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_3SERIAL_PORT
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_1PARALLEL_1SERIAL
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_G2PIO
+
+/* Pin Multiplexing for Reset --- PCICLK[1:4] */
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_RESET
+#undef CONFIG_TOSHIBA_TX4939_MPLEX_PCICLKON
+
+#define CONFIG_TOSHIBA_TX4939_MPLEX_RESET
+
+#endif				/* no using Menu Config */
+
+#define TX4939_GTOT        TX4939_CCFG_GTOT_4096
+#define TX4939_WR_NMI      TX4939_CCFG_WR_NMI	/* TX4939_CCFG_WR_RESET */
+#define TX4939_TOE         TX4939_CCFG_TOE
+#define TX4939_ACEHOLD     TX4939_CCFG_ACEHOLD_1CLOCK
+#define TX4939_SYSCLKEN    TX4939_PCFG_SYSCLKEN_OUTPUT
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_PC_TRACE)
+#define TX4939_PTSEL       TX4939_CCFG_PTSEL
+#else
+#define TX4939_PTSEL       0
+#endif
+
+#define CONFIG_TOSHIBA_TX4939_CCFG  (TX4939_GTOT | TX4939_WR_NMI | TX4939_TOE | TX4939_PTSEL | TX4939_ACEHOLD)
+
+#define TX4939_DMASEL3     TX4939_PCFG_DMASEL3_NDFC
+
+/********** Don't Edit following code **********/
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_GPIO12_15)
+#define TX4939_SIO2MODE    TX4939_PCFG_SIO2MODE_GPIO
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_SIO2)
+#define TX4939_SIO2MODE    TX4939_PCFG_SIO2MODE_SIO2
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_CTS_RTS)
+#define TX4939_SIO2MODE    TX4939_PCFG_SIO2MODE_SIO0
+#else
+#define TX4939_SIO2MODE    0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_SPI)
+#define TX4939_SPIMODE     TX4939_PCFG_SPIMODE_SPI
+#else
+#define TX4939_SPIMODE     TX4939_PCFG_SPIMODE_SIO_GPIO
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_I2C)
+#define TX4939_I2CMODE     TX4939_PCFG_I2CMODE_I2C
+#else
+#define TX4939_I2CMODE    0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_GPIO04_09)
+#define TX4939_I2SMODE     TX4939_PCFG_I2SMODE_GPIO
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_I2S)
+#define TX4939_I2SMODE     TX4939_PCFG_I2SMODE_I2S
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_ACLINK)
+#define TX4939_I2SMODE     TX4939_PCFG_I2SMODE_ACLC
+#else
+#define TX4939_I2SMODE     0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_1PARALLEL_PORT)
+#define TX4939_VPMODE      TX4939_PCFG_VPMODE_1P
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_3SERIAL_PORT)
+#define TX4939_VPMODE      TX4939_PCFG_VPMODE_3S
+#elif defined(CONFIG_TOSHIBA_TX4939_MPLEX_1PARALLEL_1SERIAL)
+#define TX4939_VPMODE      TX4939_PCFG_VPMODE_1P1S
+#else
+#define TX4939_VPMODE      0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_ETHER)
+#define TX4939_ETMODE      TX4939_PCFG_ETMODE_ALL
+#else
+#define TX4939_ETMODE      0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_ATA0)
+#define TX4939_ATA0MODE    TX4939_PCFG_ATA0MODE_ATA
+#else
+#define TX4939_ATA0MODE    0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_ATA1)
+#define TX4939_ATA1MODE    TX4939_PCFG_ATA1MODE_ATA
+#else
+#define TX4939_ATA1MODE    0
+#endif
+
+#if defined(CONFIG_TOSHIBA_TX4939_MPLEX_RESET)
+#define TX4939_PCICLKEN    (TX4939_PCFG_PCICLKEN(1) | TX4939_PCFG_PCICLKEN(2))
+#else
+#define TX4939_PCICLKEN    (TX4939_PCFG_PCICLKEN(1) | TX4939_PCFG_PCICLKEN(2) | TX4939_PCFG_PCICLKEN(3) | TX4939_PCFG_PCICLKEN(4))
+#endif
+
+#define CONFIG_TOSHIBA_TX4939_PCFG  (TX4939_SIO2MODE | TX4939_SPIMODE | TX4939_I2CMODE | TX4939_I2SMODE | TX4939_DMASEL3 | TX4939_VPMODE | TX4939_ETMODE | TX4939_ATA0MODE | TX4939_ATA1MODE | TX4939_SYSCLKEN | TX4939_PCICLKEN)
+
+#endif				/* __ASM_TXBOARDS_TX4939H */
Index: linux-2.6.10/include/asm-mips/tx4939/ide.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4939/ide.h
@@ -0,0 +1,71 @@
+/*
+ * include/asm-mips/tx4939/ide.h
+ *
+ * ide supplement routines
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2005
+ *
+ * Author: source@mvista.com,
+ *               Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ */
+
+#ifndef __ASM_MACH_TX4939_IDE_H
+#define __ASM_MACH_TX4939_IDE_H
+
+#ifdef __KERNEL__
+
+#ifndef MAX_HWIFS
+# ifdef CONFIG_BLK_DEV_IDEPCI
+#define MAX_HWIFS	10
+# else
+#define MAX_HWIFS	6
+# endif
+#endif
+
+/*
+ * Our Physical Region Descriptor (PRD) table should be large enough
+ * to handle the biggest I/O request we are likely to see.  Since requests
+ * can have no more than 256 sectors, and since the typical blocksize is
+ * two or more sectors, we could get by with a limit of 128 entries here for
+ * the usual worst case.  Most requests seem to include some contiguous blocks,
+ * further reducing the number of table entries required.
+ *
+ * The driver reverts to PIO mode for individual requests that exceed
+ * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling
+ * 100% of all crazy scenarios here is not necessary.
+ *
+ * As it turns out though, we must allocate a full 4KB page for this,
+ * so the two PRD tables (ide0 & ide1) will each get half of that,
+ * allowing each to have about 256 entries (8 bytes each) from this.
+ */
+
+#define PRD_BYTES       8
+#define PRD_ENTRIES     (PAGE_SIZE / (2 * PRD_BYTES))
+
+
+#define ide_ack_intr(hwif) (hwif->hw.ack_intr ? hwif->hw.ack_intr(hwif) : 1)
+#define IDE_ARCH_ACK_INTR
+
+#define __ide_insw	insw
+#define __ide_insl	insl
+#define __ide_outsw	outsw
+#define __ide_outsl	outsl
+
+#define __ide_mm_insw	readsw
+#define __ide_mm_insl	readsl
+#define __ide_mm_outsw	writesw
+#define __ide_mm_outsl	writesl
+
+
+#endif /* __KERNEL__ */
+
+#define IS_IDE_TX4939 (HWIF(drive)->chipset == ide_tx4939)
+
+#endif /* __ASM_MACH_TX4939_IDE_H */
+
Index: linux-2.6.10/include/asm-mips/tx4939/rbtx4939.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4939/rbtx4939.h
@@ -0,0 +1,173 @@
+/*
+ * include/asm-mips/tx4939/rbtx4939.h
+ *
+ * Definitions for RBTX4939
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#ifndef __ASM_TX_BOARDS_RBTX4939_H
+#define __ASM_TX_BOARDS_RBTX4939_H
+
+#include <asm/tx4939/tx4939.h>
+#include <asm/addrspace.h>
+
+#ifndef __ASSEMBLY__
+extern int rbtx4939_irq_nested(void);
+extern void rbtx4939_irq_init(void);
+extern void tx4939_pci_setup_irq(void);
+
+extern void rbtx4939_led(unsigned int led, unsigned int hex);
+#endif                         /* __ASSEMBLY__ */
+
+/* CS */
+#define RBTX4939_CS0                 0x1c000000
+#define RBTX4939_CS1                 0x17f00000	/* I/O Controller etc. */
+#define RBTX4939_CS2                 0x18000000
+#define RBTX4939_CS3                 0x16000000	/* LOCAL or ISA */
+
+/* RBTX4939 REGISTER ADDRESS MAP */
+#define RBTX4939_IOC_REG             (KSEG1 + RBTX4939_CS1)
+#define RBTX4939_IOC_SIZE            0x10000
+#define RBTX4939_IR_REG              (RBTX4939_IOC_REG + 0x00000)
+#define RBTX4939_ETHER_REG           (RBTX4939_IOC_REG + 0x20000)
+#define RBTX4939_DBOARD_REG          (RBTX4939_IOC_REG + 0x30000)
+
+/* Debug Ethernet port address */
+#define RBTX4939_DEBUG_ETHER_BASE       (0x300+RBTX4939_ETHER_REG)
+#define RBTX4939_ETHER_MAC_ADDR_BASE    0x1fff0000
+
+/* IRQ NUMBUR */
+#define RBTX4939_IRQ_IOC             TX4939_IRQ_INT(0)
+#define RBTX4939_IRQ_DEBUG_ETHER     TX4939_IRQ_INT(1)
+
+#define RBTX4939_IRQ_IOC_BEG         (1 + TX4939_IRQ_IRC_END)	/* 59 - 66 */
+#define RBTX4939_IRQ_IOC_END         (7 + RBTX4939_IRQ_IOC_BEG)
+
+#define RBTX4939_IRQ_ISA0            (0 + RBTX4939_IRQ_IOC_BEG)
+#define RBTX4939_IRQ_ISA11           (1 + RBTX4939_IRQ_IOC_BEG)
+#define RBTX4939_IRQ_ISA12           (2 + RBTX4939_IRQ_IOC_BEG)
+#define RBTX4939_IRQ_ISA15           (3 + RBTX4939_IRQ_IOC_BEG)
+#define RBTX4939_IRQ_I2S             (4 + RBTX4939_IRQ_IOC_BEG)
+
+/* I/O Controller REGISTER ADDRESS MAP */
+#define RBTX4939_BOARD_REV_REG       (0x0000 + RBTX4939_IR_REG)
+#define RBTX4939_IOC_REV_REG         (0x0002 + RBTX4939_IR_REG)
+#define RBTX4939_CONFIG1_REG         (0x0004 + RBTX4939_IR_REG)
+#define RBTX4939_CONFIG2_REG         (0x0006 + RBTX4939_IR_REG)
+#define RBTX4939_CONFIG3_REG         (0x0008 + RBTX4939_IR_REG)
+#define RBTX4939_CONFIG4_REG         (0x000a + RBTX4939_IR_REG)
+#define RBTX4939_USERSW_REG          (0x1002 + RBTX4939_IR_REG)
+#define RBTX4939_BOOTSW_REG          (0x1004 + RBTX4939_IR_REG)
+#define RBTX4939_INTE_REG            (0x2000 + RBTX4939_IR_REG)
+#define RBTX4939_INTP_REG            (0x2002 + RBTX4939_IR_REG)
+#define RBTX4939_INTF1_REG           (0x2004 + RBTX4939_IR_REG)
+#define RBTX4939_INTF2_REG           (0x2006 + RBTX4939_IR_REG)
+#define RBTX4939_SOFT_INT_REG        (0x3000 + RBTX4939_IR_REG)
+#define RBTX4939_ISA_STATUS_REG      (0x4000 + RBTX4939_IR_REG)
+#define RBTX4939_PCI66_REG           (0x4002 + RBTX4939_IR_REG)
+#define RBTX4939_ROMEMU_REG          (0x4004 + RBTX4939_IR_REG)
+#define RBTX4939_SPICS_REG           (0x4006 + RBTX4939_IR_REG)
+#define RBTX4939_AUDIO_MODE_REG      (0x4008 + RBTX4939_IR_REG)
+#define RBTX4939_ISA_GPIO_REG        (0x400a + RBTX4939_IR_REG)
+#define RBTX4939_PE1_REG             (0x5000 + RBTX4939_IR_REG)
+#define RBTX4939_PE2_REG             (0x5002 + RBTX4939_IR_REG)
+#define RBTX4939_PE3_REG             (0x5004 + RBTX4939_IR_REG)
+#define RBTX4939_VPORT_MODE_REG      (0x5006 + RBTX4939_IR_REG)
+#define RBTX4939_VPORT_RESET_REG     (0x5008 + RBTX4939_IR_REG)
+#define RBTX4939_VPORT_SOUT_REG      (0x500A + RBTX4939_IR_REG)
+#define RBTX4939_VPORT_SIN_REG       (0x500B + RBTX4939_IR_REG)
+#define RBTX4939_7SEGLED_REG         (0x6000 + RBTX4939_IR_REG)
+#define RBTX4939_SOFT_RESET_REG      (0x7000 + RBTX4939_IR_REG)
+#define RBTX4939_SRESET_ENABLE_REG   (0x7002 + RBTX4939_IR_REG)
+#define RBTX4939_RESET_STATUS_REG    (0x7004 + RBTX4939_IR_REG)
+
+#ifndef __ASSEMBLY__
+#define rbtx4939_board_rev_ptr       \
+        (RBTX4939_BOARD_REV_REG)
+#define rbtx4939_ioc_rev_ptr         \
+        (RBTX4939_IOC_REV_REG)
+#define rbtx4939_config1_ptr         \
+        (RBTX4939_CONFIG1_REG)
+#define rbtx4939_config2_ptr         \
+        (RBTX4939_CONFIG2_REG)
+#define rbtx4939_config3_ptr         \
+        (RBTX4939_CONFIG3_REG)
+#define rbtx4939_config4_ptr         \
+        (RBTX4939_CONFIG4_REG)
+#define rbtx4939_usersw_ptr          \
+        (RBTX4939_USERSW_REG)
+#define rbtx4939_bootsw_ptr          \
+        (RBTX4939_BOOTSW_REG)
+#define rbtx4939_inte_ptr            \
+        (RBTX4939_INTE_REG)
+#define rbtx4939_intp_ptr            \
+        (RBTX4939_INTP_REG)
+#define rbtx4939_intf1_ptr           \
+        (RBTX4939_INTF1_REG)
+#define rbtx4939_intf2_ptr           \
+        (RBTX4939_INTF2_REG)
+#define rbtx4939_soft_int_ptr        \
+        (RBTX4939_SOFT_INT_REG)
+#define rbtx4939_isa_status_ptr      \
+        (RBTX4939_ISA_STATUS_REG)
+#define rbtx4939_pci66_ptr           \
+        (RBTX4939_PCI66_REG)
+#define rbtx4939_romemu_ptr          \
+        (RBTX4939_ROMEMU_REG)
+#define rbtx4939_spics_ptr           \
+        (RBTX4939_SPICS_REG)
+#define rbtx4939_audio_mode_ptr      \
+        (RBTX4939_AUDIO_MODE_REG)
+#define rbtx4939_isa_gpio_ptr        \
+        (RBTX4939_ISA_GPIO_REG)
+#define rbtx4939_pe1_ptr             \
+        (RBTX4939_PE1_REG)
+#define rbtx4939_pe2_ptr             \
+        (RBTX4939_PE2_REG)
+#define rbtx4939_pe3_ptr             \
+        (RBTX4939_PE3_REG)
+#define rbtx4939_vport_mode_ptr      \
+        (RBTX4939_VPORT_MODE_REG)
+#define rbtx4939_vport_reset_ptr     \
+        (RBTX4939_VPORT_RESET_REG)
+#define rbtx4939_vport_sout_ptr      \
+        (RBTX4939_VPORT_SOUT_REG)
+#define rbtx4939_vport_sin_ptr       \
+        (RBTX4939_VPORT_SIN_REG)
+#define rbtx4939_7segled_ptr         \
+        (RBTX4939_7SEGLED_REG)
+#define rbtx4939_soft_reset_ptr      \
+        (RBTX4939_SOFT_RESET_REG)
+#define rbtx4939_sreset_enable_ptr   \
+        (RBTX4939_SRESET_ENABLE_REG)
+#define rbtx4939_reset_status_ptr    \
+        (RBTX4939_RESET_STATUS_REG)
+#endif				/* __ASSEMBLY__ */
+
+#define RBTX4939_PE1_RMII1   0x08
+#define RBTX4939_PE1_RMII0   0x04
+#define RBTX4939_PE1_ATA1    0x02
+#define RBTX4939_PE1_ATA0    0x01
+
+#define RBTX4939_PE2_GPIO    0x20
+#define RBTX4939_PE2_SPI     0x10
+#define RBTX4939_PE2_CIR     0x08
+#define RBTX4939_PE2_SIO3    0x04
+#define RBTX4939_PE2_SIO2    0x02
+#define RBTX4939_PE2_SIO1    0x01
+
+#define RBTX4939_PE3_VP_S    0x04
+#define RBTX4939_PE3_VP_P    0x02
+#define RBTX4939_PE3_VP      0x01
+
+#endif				/* __ASM_TX_BOARDS_RBTX4939_H */
Index: linux-2.6.10/include/asm-mips/tx4939/spi.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4939/spi.h
@@ -0,0 +1,81 @@
+/*
+ * linux/include/asm-mips/tx4939/spi.h
+ *
+ * Definitions for TX4937/TX4938/TX4939 SPI
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+#ifndef __ASM_TX_BOARDS_TX4939_SPI_H
+#define __ASM_TX_BOARDS_TX4939_SPI_H
+
+/* SPI */
+struct spi_dev_desc {
+	unsigned int baud;
+	unsigned short tcss, tcsh, tcsr;	/* CS setup/hold/recovery time */
+	unsigned int byteorder:1;	/* 0:LSB-First, 1:MSB-First */
+	unsigned int polarity:1;	/* 0:High-Active */
+	unsigned int phase:1;	/* 0:Sample-Then-Shift */
+};
+
+extern void txx9_spi_init(unsigned long base,
+			  int (*cs_func) (int chipid, int on)) __init;
+extern void txx9_spi_irqinit(int irc_irq) __init;
+extern int txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+		       unsigned char **inbufs, unsigned int *incounts,
+		       unsigned char **outbufs, unsigned int *outcounts,
+		       int cansleep);
+extern int spi_eeprom_write_enable(int chipid, int enable);
+extern int spi_eeprom_read_status(int chipid);
+extern int spi_eeprom_read(int chipid, int address, unsigned char *buf,
+			   int len);
+extern int spi_eeprom_write(int chipid, int address, unsigned char *buf,
+			    int len);
+extern void spi_eeprom_proc_create(struct proc_dir_entry *dir,
+				   int chipid) __init;
+
+#define TXX9_IMCLK     (txx9_gbus_clock / 2)
+
+/*
+* SPI
+*/
+
+/* SPMCR : SPI Master Control */
+#define TXx9_SPMCR_OPMODE	0xc0
+#define TXx9_SPMCR_CONFIG	0x40
+#define TXx9_SPMCR_ACTIVE	0x80
+#define TXx9_SPMCR_SPSTP	0x02
+#define TXx9_SPMCR_BCLR	0x01
+
+/* SPCR0 : SPI Status */
+#define TXx9_SPCR0_TXIFL_MASK	0xc000
+#define TXx9_SPCR0_RXIFL_MASK	0x3000
+#define TXx9_SPCR0_SIDIE	0x0800
+#define TXx9_SPCR0_SOEIE	0x0400
+#define TXx9_SPCR0_RBSIE	0x0200
+#define TXx9_SPCR0_TBSIE	0x0100
+#define TXx9_SPCR0_IFSPSE	0x0010
+#define TXx9_SPCR0_SBOS	0x0004
+#define TXx9_SPCR0_SPHA	0x0002
+#define TXx9_SPCR0_SPOL	0x0001
+
+/* SPSR : SPI Status */
+#define TXx9_SPSR_TBSI	0x8000
+#define TXx9_SPSR_RBSI	0x4000
+#define TXx9_SPSR_TBS_MASK	0x3800
+#define TXx9_SPSR_RBS_MASK	0x0700
+#define TXx9_SPSR_SPOE	0x0080
+#define TXx9_SPSR_IFSD	0x0008
+#define TXx9_SPSR_SIDLE	0x0004
+#define TXx9_SPSR_STRDY	0x0002
+#define TXx9_SPSR_SRRDY	0x0001
+
+#endif				/* __ASM_TX_BOARDS_TX4939_SPI_H */
Index: linux-2.6.10/include/asm-mips/tx4939/tx4939.h
===================================================================
--- /dev/null
+++ linux-2.6.10/include/asm-mips/tx4939/tx4939.h
@@ -0,0 +1,1670 @@
+/*
+ * include/asm-mips/tx4939/tx4939.h
+ *
+ * Definitions for TX4939
+ *
+ * (C) Copyright TOSHIBA CORPORATION SEMICONDUCTOR COMPANY 2000-2001,2005
+ *
+ * Author: source@mvista.com
+ *
+ * 2001-2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4939 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#ifndef __ASM_TX4939H
+#define __ASM_TX4939H
+
+#include <asm/tx4939/config.h>
+
+#ifndef __ASSEMBLY__
+
+extern struct pci_ops tx4939_pci_ops;
+extern struct tx4939_pcic_reg *pcicptrs[4];
+
+extern unsigned int tx4939_get_mem_size(void);
+
+/* TX4939 clocks */
+extern unsigned int txx9_cpu_clock;
+extern unsigned int txx9_gbus_clock;
+extern unsigned int txx9_sys_clock;
+
+/* TX4939 proc entry */
+extern struct proc_dir_entry *tx4939_proc_entry;
+extern struct pci_controller tx4939_pci_controller[];
+
+#endif                         /* __ASSEMBLY__ */
+
+
+/* TX4939 REGISTER ADDRESS MAP */
+
+#define TX4939_REG_BASE          0xff1f0000
+#define TX4939_REG_SIZE          0x00010000
+
+#define TX4939_ATA_REG(ch)       (TX4939_REG_BASE + 0x3000 + (ch) * 0x1000)
+#define TX4939_NDFMC_REG         (TX4939_REG_BASE + 0x5000)
+#define TX4939_SRAMC_REG         (TX4939_REG_BASE + 0x6000)
+#define TX4939_DDRC_REG          (TX4939_REG_BASE + 0x8000)
+#define TX4939_EBUSC_REG         (TX4939_REG_BASE + 0x9000)
+#define TX4939_VPC_REG           (TX4939_REG_BASE + 0xa000)
+#define TX4939_DMAC_REG(ch)      (TX4939_REG_BASE + 0xb000 + (ch) * 0x800)
+#define TX4939_PCIC_REG(ch)      (TX4939_REG_BASE + 0xd000 - (ch) * 0x6000)
+#define TX4939_CONFIG_REG        (TX4939_REG_BASE + 0xe000)
+#define TX4939_IRC_REG           (TX4939_REG_BASE + 0xe800)
+#define TX4939_TMR_REG(ch)       (TX4939_REG_BASE + 0xf000 + (ch) * 0x100 + (((ch)+1) & 0x4) * 0x280)
+#define TX4939_SIO_REG(ch)       (TX4939_REG_BASE + 0xf300 + ((ch) & 0x01) * 0x100 + ((ch) & 0x2) * 0x40)
+#define TX4939_ACLC_REG          (TX4939_REG_BASE + 0xf700)
+#define TX4939_SPIC_REG          (TX4939_REG_BASE + 0xf800)
+#define TX4939_I2C_REG           (TX4939_REG_BASE + 0xf900)
+#define TX4939_I2S_REG           (TX4939_REG_BASE + 0xfa00)
+#define TX4939_RTC_REG           (TX4939_REG_BASE + 0xfb00)
+#define TX4939_CIR_REG           (TX4939_REG_BASE + 0xfc00)
+
+/* IRQ NUMBER */
+#define TX4939_IRQ_CP0_BEG       0
+#define TX4939_IRQ_CP0_END       ( 7 + TX4939_IRQ_CP0_BEG)
+
+#define TX4939_IRQ_USER0         ( 0 + TX4939_IRQ_CP0_BEG)
+#define TX4939_IRQ_USER1         ( 1 + TX4939_IRQ_CP0_BEG)
+#define TX4939_IRQ_IRC_CP0       ( 2 + TX4939_IRQ_CP0_BEG)
+#define TX4939_IRQ_CPU_TIMER     ( 7 + TX4939_IRQ_CP0_BEG)
+
+#define TX4939_IRQ_IRC_BEG       ( 1 + TX4939_IRQ_CP0_END)
+#define TX4939_IRQ_IRC_END       (50 + TX4939_IRQ_IRC_BEG)
+
+#define TX4939_IRQ_DDR           ( 1 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_TX49WTOE      ( 2 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_INT(ch)       ( 3 + TX4939_IRQ_IRC_BEG + (ch))
+#define TX4939_IRQ_ETHER(ch)     ( 6 + TX4939_IRQ_IRC_BEG + ((ch) * 37))
+#define TX4939_IRQ_VIDEO         ( 7 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_CIR           ( 8 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_SIO(ch)       (43 + TX4939_IRQ_IRC_BEG - (((4-ch) & 0x4) >> 2) * 34 + ch)
+#define TX4939_IRQ_DMA0(x)       (10 + (x) + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_IRC           (14 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_PDMAC         (15 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_TMR(ch)       (16 + TX4939_IRQ_IRC_BEG + (((ch+1) & 0x4) >> 2) * 29 + ch)
+#define TX4939_IRQ_ATA(ch)       (19 + TX4939_IRQ_IRC_BEG + ((ch) & 0x1))
+#define TX4939_IRQ_ACLC          (21 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_DMA(ch)       (22 + TX4939_IRQ_IRC_BEG + ((ch) & 0x1))
+#define TX4939_IRQ_CIPHER        (26 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_INTA          (27 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_INTB          (28 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_INTC          (29 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_INTD          (30 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_I2C           (33 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_SPI           (34 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_PCIC(ch)      (35 + TX4939_IRQ_IRC_BEG + ((ch) & 0x1))
+#define TX4939_IRQ_PCI0ERR       (37 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_PCI0PME       (38 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_NDFMC         (39 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_ACLCPME       (40 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_RTC           (41 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_RSARND        (42 + TX4939_IRQ_IRC_BEG)
+#define TX4939_IRQ_I2S           (47 + TX4939_IRQ_IRC_BEG)
+
+/* PCI RESOURCE */
+#define TX4939_PCI0_MEM_RESOURCE_START  0x10000000
+#define TX4939_PCI0_MEM_RESOURCE_SIZE   0x04000000
+#define TX4939_PCI0_IO_RESOURCE_START   0x14000000
+#define TX4939_PCI0_IO_RESOURCE_SIZE    0x01000000
+#define TX4939_PCI1_MEM_RESOURCE_START  0x15000000
+#define TX4939_PCI1_MEM_RESOURCE_SIZE   0x00010000
+#define TX4939_PCI1_IO_RESOURCE_START   0x15010000
+#define TX4939_PCI1_IO_RESOURCE_SIZE    0x00010000
+
+/* MACRO DEFINITION */
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+__asm__(".macro\t__sti\n\t"
+	".set\tpush\n\t"
+	".set\treorder\n\t"
+	".set\tnoat\n\t"
+	"mfc0\t$1,$12\n\t"
+	"ori\t$1,0x1f\n\t"
+	"xori\t$1,0x1e\n\t" "mtc0\t$1,$12\n\t" ".set\tpop\n\t" ".endm");
+
+extern __inline__ void asm_wait(void)
+{
+	__asm__(".set\tmips3\n\t" "wait\n\t" ".set\tmips0");
+}
+
+#define __rswap64(x) \
+({ \
+	((__u64)( \
+		(__u64)(((__u64)(x) & (__u64)0x00000000ffffffffULL) << 32) | \
+		(__u64)(((__u64)(x) & (__u64)0xffffffff00000000ULL) >> 32) )); \
+})
+
+#define reg_rd08(r)    ((u8 )(*((vu8 *)(r))))
+#define reg_rd16(r)    ((u16)(*((vu16*)(r))))
+#define reg_rd32(r)    ((u32)(*((vu32*)(r))))
+#define reg_rd64(r)    ((u64)(*((vu64*)(r))))
+
+#define reg_wr08(r,v)  ((*((vu8 *)(r)))=((u8 )(v)))
+#define reg_wr16(r,v)  ((*((vu16*)(r)))=((u16)(v)))
+#define reg_wr32(r,v)  ((*((vu32*)(r)))=((u32)(v)))
+#define reg_wr64(r,v)  ((*((vu64*)(r)))=((u64)(v)))
+
+#ifdef __BIG_ENDIAN
+# define reg_rd64s(r)   __rswap64((u64)(*((vu64*)(r))))
+# define reg_wr64s(r,v)  ((*((vu64*)(r)))=((u64)(__rswap64(v))))
+#else
+# define reg_rd64s(r)   ((u64)(*((vu64*)(r))))
+# define reg_wr64s(r,v)  ((*((vu64*)(r)))=((u64)(v)))
+#endif
+
+typedef volatile __signed char vs8;
+typedef volatile unsigned char vu8;
+
+typedef volatile __signed short vs16;
+typedef volatile unsigned short vu16;
+
+typedef volatile __signed int vs32;
+typedef volatile unsigned int vu32;
+
+typedef s8 s08;
+typedef vs8 vs08;
+
+typedef u8 u08;
+typedef vu8 vu08;
+
+#if (_MIPS_SZLONG == 64)
+
+typedef volatile __signed__ long vs64;
+typedef volatile unsigned long vu64;
+
+#else
+
+typedef volatile __signed__ long long vs64;
+typedef volatile unsigned long long vu64;
+
+#endif
+
+#endif				/* __ASSEMBLY__ */
+
+#ifndef _LANGUAGE_ASSEMBLY
+#include <asm/byteorder.h>
+
+#define TX4939_MKA(x) ((u32)( ((u32)(TX4939_REG_BASE)) | ((u32)(x)) ))
+
+#define TX4939_RD08( reg      )   (*(vu08*)(reg))
+#define TX4939_WR08( reg, val )  ((*(vu08*)(reg))=(val))
+
+#define TX4939_RD16( reg      )   (*(vu16*)(reg))
+#define TX4939_WR16( reg, val )  ((*(vu16*)(reg))=(val))
+
+#define TX4939_RD32( reg      )   (*(vu32*)(reg))
+#define TX4939_WR32( reg, val )  ((*(vu32*)(reg))=(val))
+
+#define TX4939_RD64( reg      )   (*(vu64*)(reg))
+#define TX4939_WR64( reg, val )  ((*(vu64*)(reg))=(val))
+
+#define TX4939_RD( reg      ) TX4939_RD32( reg )
+#define TX4939_WR( reg, val ) TX4939_WR32( reg, val )
+
+#endif				/* !__ASSEMBLY__ */
+
+#ifdef __ASSEMBLY__
+#define _CONST64(c)     c
+#else
+#define _CONST64(c)     c##ull
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+#define endian_def_l2(e1,e2)    \
+        u32 e1,e2
+#define endian_def_s2(e1,e2)    \
+        u16 e1,e2
+#define endian_def_s4(e1,e2,e3,e4)      \
+        u16 e1,e2,e3,e4
+#define endian_def_sb2(e1,e2,e3)        \
+        u16 e1;u8 e2,e3
+#define endian_def_b2s(e1,e2,e3)        \
+        u8 e1,e2;u16 e3
+#define endian_def_b4(e1,e2,e3,e4)      \
+        u8 e1,e2,e3,e4
+#define endian_def_b8(e1,e2,e3,e4,e5,e6,e7,e8)      \
+        u8 e1,e2,e3,e4,e5,e6,e7,e8
+#else
+#define endian_def_l2(e1,e2)    \
+        u32 e2,e1
+#define endian_def_s2(e1,e2)    \
+        u16 e2,e1
+#define endian_def_s4(e1,e2,e3,e4)      \
+        u16 e4,e3,e2,e1
+#define endian_def_sb2(e1,e2,e3)        \
+        u8 e3,e2;u16 e1
+#define endian_def_b2s(e1,e2,e3)        \
+        u16 e3;u8 e2,e1
+#define endian_def_b4(e1,e2,e3,e4)      \
+        u8 e4,e3,e2,e1
+#define endian_def_b8(e1,e2,e3,e4,e5,e6,e7,e8)      \
+        u8 e8,e7,e6,e5,e4,e3,e2,e1
+#endif				/* __BIG_ENDIAN */
+#endif				/* __ASSEMBLY__ */
+
+/* TX4939 REGISTER STRUCTURE */
+
+#ifndef __ASSEMBLY__
+
+struct tx4939_ata_reg {
+	u64 ata_shadow;
+	u64 unused0[127];
+	endian_def_b8(unused10, unused11, unused12, unused13, unused14,
+		      alt_devctl, unused16, unused17);
+	u64 unused1[127];
+	endian_def_b8(unused20, unused21, unused22, prd_tbl, unused24,
+		      dma_stat, unused26, dma_cmd);
+	u64 unused2[127];
+	endian_def_s4(unused30, unused31, sysctl2, sysctl1);	/* +0xc00 */
+	endian_def_s4(unused32, unused33, xfer_cnt2, xfer_cnt1);
+	endian_def_s4(unused34, unused35, unused36, sec_cnt);
+	endian_def_s4(unused37, unused38, unused39, strt_addl);
+	endian_def_s4(unused40, unused41, unused42, strt_addu);
+	endian_def_s4(unused43, unused44, unused45, add_ctrl);
+	endian_def_s4(unused46, unused47, unused48, lo_bcnt);
+        endian_def_s4(unused49, unused50, unused51, hi_bcnt);
+	volatile u64 unused52[9];
+        endian_def_s4(unused53, unused54, unused55, pio_acc);
+        endian_def_s4(unused56, unused57, unused58, h_rst_tim);
+        endian_def_s4(unused59, unused60, unused61, int_ctl);
+	volatile u64 unused62[3];
+        endian_def_s4(unused63, unused64, unused65, pkt_cmd);
+        endian_def_s4(unused66, unused67, unused68, bxfer_cnth);
+        endian_def_s4(unused69, unused70, unused71, bxfer_cntl);
+        endian_def_s4(unused72, unused73, unused74, dev_terr);
+        endian_def_s4(unused75, unused76, unused77, pkt_xfer_ct);
+        endian_def_s4(unused78, unused79, unused80, strt_addr);
+};
+
+struct tx4939_ndfmc_reg {
+	endian_def_s4(unused00, unused01, unused02, dtr);
+	endian_def_s4(unused03, unused04, unused05, mcr);
+	endian_def_s4(unused06, unused07, unused08, sr);
+	endian_def_s4(unused09, unused10, unused11, isr);
+	endian_def_s4(unused12, unused13, unused14, imr);
+	endian_def_s4(unused15, unused16, unused17, spr);
+};
+
+struct tx4939_sramc_reg {
+	u64 cr;
+};
+
+struct tx4939_pcic_reg {
+	u32 pciid;
+	u32 pcistatus;
+	u32 pciccrev;
+	u32 pcicfg1;
+	u32 p2gm0plbase;	/* +10 */
+	u32 p2gm0pubase;
+	u32 p2gm1plbase;
+	u32 p2gm1pubase;
+	u32 p2gm2pbase;		/* +20 */
+	u32 p2giopbase;
+	u32 unused0;
+	u32 pcisid;
+	u32 unused1;		/* +30 */
+	u32 pcicapptr;
+	u32 unused2;
+	u32 pcicfg2;
+	u32 g2ptocnt;		/* +40 */
+	u32 unused3[15];
+	u32 g2pstatus;		/* +80 */
+	u32 g2pmask;
+	u32 pcisstatus;
+	u32 pcimask;
+	u32 p2gcfg;		/* +90 */
+	u32 p2gstatus;
+	u32 p2gmask;
+	u32 p2gccmd;
+	u32 unused4[24];	/* +a0 */
+	u32 pbareqport;		/* +100 */
+	u32 pbacfg;
+	u32 pbastatus;
+	u32 pbamask;
+	u32 pbabm;		/* +110 */
+	u32 pbacreq;
+	u32 pbacgnt;
+	u32 pbacstate;
+	u64 g2pmgbase[3];	/* +120 */
+	u64 g2piogbase;
+	u32 g2pmmask[3];	/* +140 */
+	u32 g2piomask;
+	u64 g2pmpbase[3];	/* +150 */
+	u64 g2piopbase;
+	u32 pciccfg;		/* +170 */
+	u32 pcicstatus;
+	u32 pcicmask;
+	u32 unused5;
+	u64 p2gmgbase[3];	/* +180 */
+	u64 p2giogbase;
+	u32 g2pcfgadrs;		/* +1a0 */
+	u32 g2pcfgdata;
+	u32 unused6[8];
+	u32 g2pintack;
+	u32 g2pspc;
+	u32 pcidata0;		/* +1d0 */
+	u32 pcidata1;
+	u32 pcidata2;
+	u32 pcidata3;
+	u32 p2gm0cfg;		/* +1e0 */
+	u32 p2gm1cfg;
+	u32 p2gm2cfg;
+	u32 unused7[5];
+	u64 pdmca;		/* +200 */
+	u64 pdmga;
+	u64 pdmpa;
+	u64 pdmctr;
+	u64 pdmcfg;		/* +220 */
+	u64 pdmsts;
+};
+
+struct tx4939_ddrc_reg {
+	struct tx4939_ddrc_ddr_ctl_reg {
+		endian_def_s4(unused0, unused1, unused2, ctl);
+	} ddr[47];
+	u64 unused0[17];
+	u64 drwinen;
+	u64 drwin[4];
+};
+
+struct tx4939_ebusc_reg {
+	u64 cr[8];
+};
+
+struct tx4939_vpc_reg {
+	u32 csr;
+	u32 unused0;
+	struct tx4939_vpc_ch_reg {
+		u32 ctrl_a;
+		u32 unused0;
+		u32 ctrl_b;
+		u32 unused1;
+		u32 idesptr;
+		u32 unused2;
+		u32 cdesptr;
+		u32 unused3;
+	} ch[3];
+	u32 buserr;
+};
+
+struct tx4939_dma_reg {
+	struct tx4939_dma_ch_reg {
+		u64 cha;
+		u64 sar;
+		u64 dar;
+		 endian_def_l2(unused0, cntr);
+		 endian_def_l2(unused1, sair);
+		 endian_def_l2(unused2, dair);
+		 endian_def_l2(unused3, ccr);
+		 endian_def_l2(unused4, csr);
+	} ch[4];
+	u64 unused[9];
+	u64 mfdr;
+	 endian_def_l2(unused0, mcr);
+};
+
+struct tx4939_ccfg_reg {
+	u64 ccfg;
+	u64 revid;
+	u64 pcfg;
+	u64 toea;
+	u64 clkctr;	/* +20 */
+	u64 unused0;
+	u64 garbc;
+	u64 unused1[2];
+	u64 ramp;	/* +48 */
+	u64 unused2[2];
+	u64 dskwctrl;	/* +60 */
+	u64 mclkosc;
+	u64 mclkctl;
+	u64 unused[17];
+	struct tx4939_ccfg_gpio_reg {	/* +100 */
+		u64 mr;
+		u64 dr;
+	} gpio[2];
+};
+
+struct tx4939_tmr_reg {
+	u32 tcr;
+	u32 tisr;
+	u32 cpra;
+	u32 cprb;
+	u32 itmr;
+	u32 unused0[3];
+	u32 ccdr;
+	u32 unused1[3];
+	u32 pgmr;
+	u32 unused2[3];
+	u32 wtmr;
+	u32 unused3[43];
+	u32 trr;
+};
+
+struct tx4939_sio_reg {
+	u32 lcr;
+	u32 dicr;
+	u32 disr;
+	u32 cisr;
+	u32 fcr;
+	u32 flcr;
+	u32 bgr;
+	u32 tfifo;
+	u32 rfifo;
+};
+
+struct tx4939_irc_reg {
+	u32 den;
+	u32 unused0;
+	u32 iscipb;
+	u32 unused1;
+	u32 dm0;
+	u32 unused2;
+	u32 dm1;
+	u32 unused3;
+	struct tx4939_irc_irlvl_reg {
+		u32 reg;
+		u32 unused0;
+	} irlvl[16];
+	u32 msk;
+	u32 unused4;
+	u32 edc;
+	u32 unused5;
+	u32 pnd0;
+	u32 unused6;
+	u32 cs;
+	u32 unused7;
+	u32 pnd1;
+	u32 unused8;
+	u32 dm2;
+	u32 unused9;
+	u32 dm3;
+	u32 unused10;
+	u32 dbr0;
+	u32 unused11;
+	u32 dbr1;
+	u32 unused12;
+	u32 dben;
+	u32 unused13;
+	u32 unused14[4];
+	u32 flag0;
+	u32 unused15;
+	u32 flag1;
+	u32 unused16;
+	u32 pol;
+	u32 unused17;
+	u32 cnt;
+	u32 unused18;
+	u32 maskint;
+	u32 unused19;
+	u32 maskext;
+};
+
+struct tx4939_aclc_reg {
+	u32 ctlen;
+	u32 ctldis;
+	u32 regacc;
+	u32 unused0;
+	u32 intsts;
+	u32 intmsts;
+	u32 inten;
+	u32 intdis;
+	u32 semaph;
+	u32 unused1[7];
+	u32 gpidat;
+	u32 gpodat;
+	u32 slten;
+	u32 sltdis;
+	u32 fifosts;
+	u32 unused2[11];
+	u32 dmasts;
+	u32 dmasel;
+	u32 unused3[6];
+	u32 audodat;
+	u32 surrdat;
+	u32 centdat;
+	u32 lfedat;
+	u32 audiat;
+	u32 unused4;
+	u32 modoat;
+	u32 modidat;
+	u32 unused5[15];
+	u32 revid;
+};
+
+struct tx4939_spi_reg {
+	u32 mcr;
+	u32 cr0;
+	u32 cr1;
+	u32 fs;
+	u32 unused1;
+	u32 sr;
+	u32 dr;
+	u32 unused2;
+};
+
+struct tx4939_i2c_reg {
+	u32 ictsr;
+	u32 txrr;
+	u32 cr;
+	u32 pre;
+	u32 unused0[4];
+	u32 ctr;	/* +20 */
+	u32 unused1[5];
+	u32 btxrr;	/* +34 */
+	u32 bcr;
+	u32 brbcnt;
+};
+
+struct tx4939_i2s_reg {
+	u32 mcr;
+	u32 ccr;
+	u32 ictrl;
+	u32 cor;
+	u32 unused0[28];
+	struct tx4939_i2s_ch_reg {	/* +80 */
+		u32 dmaaddr;
+		u32 unused[3];
+	} ch[3];
+};
+
+struct tx4939_rtc_reg {
+	u32 ctl;
+	u32 adr;
+	u32 dat;
+};
+
+struct tx4939_cir_reg {
+	u32 csr;
+};
+
+#define tx4939_ataptr(ch)       \
+        ((struct tx4939_ata_reg *)TX4939_ATA_REG(ch))
+#define tx4939_ndfmcptr         \
+        ((struct tx4939_ndfmc_reg *)TX4939_NDFMC_REG)
+#define tx4939_sramcptr         \
+        ((struct tx4939_sramc_reg *)TX4939_SRAMC_REG)
+#define tx4939_pcicptr(ch)      \
+        ((struct tx4939_pcic_reg *)TX4939_PCIC_REG(ch))
+#define tx4939_ddrcptr          \
+        ((struct tx4939_ddrc_reg *)TX4939_DDRC_REG)
+#define tx4939_ebuscptr         \
+        ((struct tx4939_ebusc_reg *)TX4939_EBUSC_REG)
+#define tx4939_vpcptr           \
+        ((struct tx4939_vpc_reg *)TX4939_VPC_REG)
+#define tx4939_dmacptr(ch)      \
+        ((struct tx4939_dma_reg *)TX4939_DMAC_REG(ch))
+#define tx4939_ccfgptr          \
+        ((struct tx4939_ccfg_reg *)TX4939_CONFIG_REG)
+#define tx4939_ircptr           \
+        ((struct tx4939_irc_reg *)TX4939_IRC_REG)
+#define tx4939_tmrptr(ch)       \
+        ((struct tx4939_tmr_reg *)TX4939_TMR_REG(ch))
+#define tx4939_sioptr(ch)       \
+        ((struct tx4939_sio_reg *)TX4939_SIO_REG(ch))
+#define tx4939_aclcptr          \
+        ((struct tx4939_aclc_reg *)TX4939_ACLC_REG)
+#define tx4939_spiptr           \
+        ((struct tx4939_spi_reg *)TX4939_SPIC_REG)
+#define tx4939_i2cptr           \
+        ((struct tx4939_i2c_reg *)TX4939_I2C_REG)
+#define tx4939_i2sptr           \
+        ((struct tx4939_i2s_reg *)TX4939_I2S_REG)
+#define tx4939_rtcptr           \
+        ((struct tx4939_rtc_reg *)TX4939_RTC_REG)
+#define tx4939_cirptr           \
+        ((struct tx4939_cir_reg *)TX4939_CIR_REG)
+
+#endif				/* __ASSEMBLY__ */
+
+/*
+ * Configuration Registers
+ */
+
+/* CCFG : Chip Configuration Register */
+
+#define TX4939_REG_BASE	               0xff1f0000
+#define TX4939_REG_SIZE	               0x00010000
+
+#define TX4939_CCFG_PCIBOOT_ON         _CONST64(0x0000040000000000)
+#define TX4939_CCFG_PCIBOOT_OFF        _CONST64(0x0000000000000000)
+#define TX4939_CCFG_WDRST              _CONST64(0x0000020000000000)
+#define TX4939_CCFG_WDREXEN_ASSERT     _CONST64(0x0000010000000000)
+#define TX4939_CCFG_BCFG_MASK          _CONST64(0x000000ff00000000)
+#define TX4939_CCFG_GTOT_MASK          _CONST64(0x0000000006000000)
+#define TX4939_CCFG_GTOT_4096          _CONST64(0x0000000006000000)
+#define TX4939_CCFG_GTOT_2048          _CONST64(0x0000000004000000)
+#define TX4939_CCFG_GTOT_1028          _CONST64(0x0000000002000000)
+#define TX4939_CCFG_GTOT_512           _CONST64(0x0000000000000000)
+#define TX4939_CCFG_TINTDIS            _CONST64(0x0000000001000000)
+#define TX4939_CCFG_PCI66              _CONST64(0x0000000000800000)
+#define TX4939_CCFG_PCIMODE_MASK       _CONST64(0x0000000000400000)
+#define TX4939_CCFG_PCIMODE_HOST       _CONST64(0x0000000000400000)
+#define TX4939_CCFG_PCIMODE_SATELLITE  _CONST64(0x0000000000000000)
+#define TX4939_CCFG_SSCG               _CONST64(0x0000000000100000)
+#define TX4939_CCFG_MULCLK_MASK        _CONST64(0x00000000000e0000)
+#define TX4939_CCFG_MULCLK_GET(x)      (((x) & TX4939_CCFG_MULCLK_MASK) >> 17)
+#define TX4939_CCFG_BEOW               _CONST64(0x0000000000010000)
+#define TX4939_CCFG_WR_NMI             _CONST64(0x0000000000000000)
+#define TX4939_CCFG_WR_RESET           _CONST64(0x0000000000008000)
+#define TX4939_CCFG_TOE                _CONST64(0x0000000000004000)
+#define TX4939_CCFG_PCIARB_BUILTIN     _CONST64(0x0000000000002000)
+#define TX4939_CCFG_PCIARB_EXTERNAL    _CONST64(0x0000000000000000)
+#define TX4939_CCFG_YDIVMODE_MASK      _CONST64(0x0000000000001c00)
+#define TX4939_CCFG_YDIVMODE_DIV2      _CONST64(0x0000000000000000)
+#define TX4939_CCFG_YDIVMODE_DIV3      _CONST64(0x0000000000000600)
+#define TX4939_CCFG_YDIVMODE_DIV5      _CONST64(0x0000000000001f00)
+#define TX4939_CCFG_YDIVMODE_DIV6      _CONST64(0x0000000000001c00)
+#define TX4939_CCFG_YDIVMODE_GET(x)    (((x) & TX4939_CCFG_YDIVMODE_MASK) >> 10)
+#define TX4939_CCFG_PTSEL              _CONST64(0x0000000000000200)
+#define TX4939_CCFG_BESEL_BWE          _CONST64(0x0000000000000100)
+#define TX4939_CCFG_SYSSP              _CONST64(0x00000000000000c0)
+#define TX4939_CCFG_SYSSP_DIV4         _CONST64(0x0000000000000000)
+#define TX4939_CCFG_SYSSP_DIV3         _CONST64(0x0000000000000040)
+#define TX4939_CCFG_SYSSP_DIV5         _CONST64(0x0000000000000080)
+#define TX4939_CCFG_SYSSP_DIV6         _CONST64(0x00000000000000c0)
+#define TX4939_CCFG_SYSSP_GET(x)       (((x) & TX4939_CCFG_SYSSP) >> 6)
+#define TX4939_CCFG_ACKSEL_MASK        _CONST64(0x0000000000000020)
+#define TX4939_CCFG_ACKSEL_ACK         _CONST64(0x0000000000000000)
+#define TX4939_CCFG_ACKSEL_NORMAL      _CONST64(0x0000000000000020)
+#define TX4939_CCFG_ROMW_MASK          _CONST64(0x0000000000000010)
+#define TX4939_CCFG_ROMW_16BIT         _CONST64(0x0000000000000000)
+#define TX4939_CCFG_ROMW_8BIT          _CONST64(0x0000000000000010)
+#define TX4939_CCFG_ENDIAN_MASK        _CONST64(0x0000000000000004)
+#define TX4939_CCFG_ENDIAN_LITTLE      _CONST64(0x0000000000000000)
+#define TX4939_CCFG_ENDIAN_BIG         _CONST64(0x0000000000000004)
+#define TX4939_CCFG_ARMODE_MASK        _CONST64(0x0000000000000002)
+#define TX4939_CCFG_ARMODE_DYNAMIC     _CONST64(0x0000000000000000)
+#define TX4939_CCFG_ARMODE_STATIC      _CONST64(0x0000000000000002)
+#define TX4939_CCFG_ACEHOLD_MASK       _CONST64(0x0000000000000001)
+#define TX4939_CCFG_ACEHOLD_SAME       _CONST64(0x0000000000000000)
+#define TX4939_CCFG_ACEHOLD_1CLOCK     _CONST64(0x0000000000000001)
+
+/* REVID : Chip Revision ID Register */
+
+#define TX4939_REVID_PCODE_MASK        _CONST64(0x00000000ffff0000)
+#define TX4939_REVID_MJERREV_MASK      _CONST64(0x000000000000f000)
+#define TX4939_REVID_MINEREV_MASK      _CONST64(0x0000000000000f00)
+#define TX4939_REVID_MJREV_MASK        _CONST64(0x00000000000000f0)
+#define TX4939_REVID_MINREV_MASK       _CONST64(0x000000000000000f)
+
+/* PCFG : Pin Configuration Register */
+#define TX4939_PCFG_SIO2MODE_MASK      _CONST64(0xc000000000000000)
+#define TX4939_PCFG_SIO2MODE_GPIO      _CONST64(0x8000000000000000)
+#define TX4939_PCFG_SIO2MODE_SIO2      _CONST64(0x4000000000000000)
+#define TX4939_PCFG_SIO2MODE_SIO0      _CONST64(0x0000000000000000)
+#define TX4939_PCFG_SPIMODE_MASK       _CONST64(0x2000000000000000)
+#define TX4939_PCFG_SPIMODE_SIO_GPIO   _CONST64(0x2000000000000000)
+#define TX4939_PCFG_SPIMODE_SPI        _CONST64(0x0000000000000000)
+#define TX4939_PCFG_I2CMODE_MASK       _CONST64(0x1000000000000000)
+#define TX4939_PCFG_I2CMODE_I2C        _CONST64(0x1000000000000000)
+#define TX4939_PCFG_I2CMODE_GPIO       _CONST64(0x0000000000000000)
+#define TX4939_PCFG_I2SMODE_MASK       _CONST64(0x0c00000000000000)
+#define TX4939_PCFG_I2SMODE_GPIO       _CONST64(0x0c00000000000000)
+#define TX4939_PCFG_I2SMODE_I2S        _CONST64(0x0800000000000000)
+#define TX4939_PCFG_I2SMODE_ACLC       _CONST64(0x0000000000000000)
+#define TX4939_PCFG_SIO3MODE_MASK      _CONST64(0x0200000000000000)
+#define TX4939_PCFG_SIO3MODE_GPIO      _CONST64(0x0200000000000000)
+#define TX4939_PCFG_SIO3MODE_SIO       _CONST64(0x0000000000000000)
+#define TX4939_PCFG_DMASEL3_MASK       _CONST64(0x0004000000000000)
+#define TX4939_PCFG_DMASEL3_NDFC       _CONST64(0x0000000000000000)
+#define TX4939_PCFG_DMASEL3_SIO0       _CONST64(0x0004000000000000)
+#define TX4939_PCFG_VPMODE_MASK        _CONST64(0x0000300000000000)
+#define TX4939_PCFG_VPMODE_GPIO        _CONST64(0x0000000000000000)
+#define TX4939_PCFG_VPMODE_1P          _CONST64(0x0000100000000000)
+#define TX4939_PCFG_VPMODE_3S          _CONST64(0x0000200000000000)
+#define TX4939_PCFG_VPMODE_1P1S        _CONST64(0x0000300000000000)
+#define TX4939_PCFG_ET1MODE_MASK       _CONST64(0x0000080000000000)
+#define TX4939_PCFG_ET1MODE_ETHER      _CONST64(0x0000080000000000)
+#define TX4939_PCFG_ET1MODE_OTHER      _CONST64(0x0000000000000000)
+#define TX4939_PCFG_ET0MODE_MASK       _CONST64(0x0000040000000000)
+#define TX4939_PCFG_ET0MODE_ETHER      _CONST64(0x0000040000000000)
+#define TX4939_PCFG_ET0MODE_OTHER      _CONST64(0x0000000000000000)
+#define TX4939_PCFG_ETMODE_ALL         _CONST64(0x00000c0000000000)
+#define TX4939_PCFG_ATA1MODE_MASK      _CONST64(0x0000020000000000)
+#define TX4939_PCFG_ATA1MODE_ATA       _CONST64(0x0000020000000000)
+#define TX4939_PCFG_ATA1MODE_OTHER     _CONST64(0x0000000000000000)
+#define TX4939_PCFG_ATA0MODE_MASK      _CONST64(0x0000010000000000)
+#define TX4939_PCFG_ATA0MODE_ATA       _CONST64(0x0000010000000000)
+#define TX4939_PCFG_ATA0MODE_OTHER     _CONST64(0x0000000000000000)
+#define TX4939_PCFG_BP_PLL_MASK        _CONST64(0x0000000100000000)
+#define TX4939_PCFG_BP_PLL_ON          _CONST64(0x0000000000000000)
+#define TX4939_PCFG_BP_PLL_OFF         _CONST64(0x0000000100000000)
+#define TX4939_PCFG_SYSCLKEN_MASK      _CONST64(0x0000000008000000)
+#define TX4939_PCFG_SYSCLKEN_OUTPUT    _CONST64(0x0000000008000000)
+#define TX4939_PCFG_SYSCLKEN_H         _CONST64(0x0000000000000000)
+#define TX4939_PCFG_PCICLKEN_MASK      _CONST64(0x00000000000f0000)
+#define TX4939_PCFG_PCICLKEN(x)        (TX4939_PCFG_PCICLKEN_MASK & (0x1 << (x+15)))
+#define TX4939_PCFG_SPEED1_MASK        _CONST64(0x0000000000002000)
+#define TX4939_PCFG_SPEED1_10MBPS      _CONST64(0x0000000000000000)
+#define TX4939_PCFG_SPEED1_100MBPS     _CONST64(0x0000000000002000)
+#define TX4939_PCFG_SPEED0_MASK        _CONST64(0x0000000000001000)
+#define TX4939_PCFG_SPEED0_10MBPS      _CONST64(0x0000000000000000)
+#define TX4939_PCFG_SPEED0_100MBPS     _CONST64(0x0000000000001000)
+#define TX4939_PCFG_ITMODE_MASK        _CONST64(0x0000000000000180)
+#define TX4939_PCFG_DMASEL2_MASK       _CONST64(0x0000000000000004)
+#define TX4939_PCFG_DMASEL2_DMAREQ2    _CONST64(0x0000000000000000)
+#define TX4939_PCFG_DMASEL2_SIO0       _CONST64(0x0000000000000004)
+#define TX4939_PCFG_DMASEL10_MASK      _CONST64(0x0000000000000003)
+#define TX4939_PCFG_DMASEL10_DMAREQ1   _CONST64(0x0000000000000000)
+
+/* TOEA : Timeout Error Access Address Register */
+#define TX4939_TOEA_TOEA_MASK          _CONST64(0x000000ffffffffff)
+
+/* CLKCTR : Clock Control Register */
+#define TX4939_CLKCTR_TM5CKD           _CONST64(0x2000000000000000)
+#define TX4939_CLKCTR_TM4CKD           _CONST64(0x1000000000000000)
+#define TX4939_CLKCTR_TM3CKD           _CONST64(0x0800000000000000)
+#define TX4939_CLKCTR_CIRCKD           _CONST64(0x0400000000000000)
+#define TX4939_CLKCTR_SIO3CKD          _CONST64(0x0200000000000000)
+#define TX4939_CLKCTR_SIO2CKD          _CONST64(0x0100000000000000)
+#define TX4939_CLKCTR_SIO1CKD          _CONST64(0x0080000000000000)
+#define TX4939_CLKCTR_VPCCKD           _CONST64(0x0040000000000000)
+#define TX4939_CLKCTR_ETH1CKD          _CONST64(0x0008000000000000)
+#define TX4939_CLKCTR_ATA1CKD          _CONST64(0x0004000000000000)
+#define TX4939_CLKCTR_BROMCKD          _CONST64(0x0002000000000000)
+#define TX4939_CLKCTR_NDCCKD           _CONST64(0x0001000000000000)
+#define TX4939_CLKCTR_I2CCKD           _CONST64(0x0000800000000000)
+#define TX4939_CLKCTR_ETH0CKD          _CONST64(0x0000400000000000)
+#define TX4939_CLKCTR_SPICKD           _CONST64(0x0000200000000000)
+#define TX4939_CLKCTR_SRAMCKD          _CONST64(0x0000100000000000)
+#define TX4939_CLKCTR_PCI1CKD          _CONST64(0x0000080000000000)
+#define TX4939_CLKCTR_DMA1CKD          _CONST64(0x0000040000000000)
+#define TX4939_CLKCTR_ACLCKD           _CONST64(0x0000020000000000)
+#define TX4939_CLKCTR_ATA0CKD          _CONST64(0x0000010000000000)
+#define TX4939_CLKCTR_DMAC0CKD         _CONST64(0x0000008000000000)
+#define TX4939_CLKCTR_PCICCKD          _CONST64(0x0000004000000000)
+#define TX4939_CLKCTR_I2SCKD           _CONST64(0x0000002000000000)
+#define TX4939_CLKCTR_TM0CKD           _CONST64(0x0000001000000000)
+#define TX4939_CLKCTR_TM1CKD           _CONST64(0x0000000800000000)
+#define TX4939_CLKCTR_TM2CKD           _CONST64(0x0000000400000000)
+#define TX4939_CLKCTR_SIO0CKD          _CONST64(0x0000000200000000)
+#define TX4939_CLKCTR_CYPCKD           _CONST64(0x0000000100000000)
+#define TX4939_CLKCTR_IOSRST           _CONST64(0x0000000080000000)
+#define TX4939_CLKCTR_SYSRST           _CONST64(0x0000000040000000)
+#define TX4939_CLKCTR_TM5RST           _CONST64(0x0000000020000000)
+#define TX4939_CLKCTR_TM4RST           _CONST64(0x0000000010000000)
+#define TX4939_CLKCTR_TM3RST           _CONST64(0x0000000008000000)
+#define TX4939_CLKCTR_CIRRST           _CONST64(0x0000000004000000)
+#define TX4939_CLKCTR_SIO3RST          _CONST64(0x0000000002000000)
+#define TX4939_CLKCTR_SIO2RST          _CONST64(0x0000000001000000)
+#define TX4939_CLKCTR_SIO1RST          _CONST64(0x0000000000800000)
+#define TX4939_CLKCTR_VPCRST           _CONST64(0x0000000000400000)
+#define TX4939_CLKCTR_EPCIRST          _CONST64(0x0000000000200000)
+#define TX4939_CLKCTR_ETH1RST          _CONST64(0x0000000000080000)
+#define TX4939_CLKCTR_ATA1RST          _CONST64(0x0000000000040000)
+#define TX4939_CLKCTR_BROMRST          _CONST64(0x0000000000020000)
+#define TX4939_CLKCTR_NDCRST           _CONST64(0x0000000000010000)
+#define TX4939_CLKCTR_I2CRST           _CONST64(0x0000000000008000)
+#define TX4939_CLKCTR_ETH0RST          _CONST64(0x0000000000004000)
+#define TX4939_CLKCTR_SPIRST           _CONST64(0x0000000000002000)
+#define TX4939_CLKCTR_SRAMRST          _CONST64(0x0000000000001000)
+#define TX4939_CLKCTR_PCI1RST          _CONST64(0x0000000000000800)
+#define TX4939_CLKCTR_DMA1RST          _CONST64(0x0000000000000400)
+#define TX4939_CLKCTR_ACLRST           _CONST64(0x0000000000000200)
+#define TX4939_CLKCTR_ATA0RST          _CONST64(0x0000000000000100)
+#define TX4939_CLKCTR_DMAC0RST         _CONST64(0x0000000000000080)
+#define TX4939_CLKCTR_PCICRST          _CONST64(0x0000000000000040)
+#define TX4939_CLKCTR_I2SRST           _CONST64(0x0000000000000020)
+#define TX4939_CLKCTR_TM0RST           _CONST64(0x0000000000000010)
+#define TX4939_CLKCTR_TM1RST           _CONST64(0x0000000000000008)
+#define TX4939_CLKCTR_TM2RST           _CONST64(0x0000000000000004)
+#define TX4939_CLKCTR_SIO0RST          _CONST64(0x0000000000000002)
+#define TX4939_CLKCTR_CYPRST           _CONST64(0x0000000000000001)
+
+/* GARBC : G-Bus Arbiter Control Register */
+#define TX4939_GARBC_ARBMD_MASK        _CONST64(0x8000000000000000)
+#define TX4939_GARBC_ARBMD_FIX         _CONST64(0x0000000000000000)
+#define TX4939_GARBC_ARBMD_RR          _CONST64(0x8000000000000000)
+#define TX4939_GARBC_PRIORITY_MASK     _CONST64(0x0000000fffffffff)
+#define TX4939_GARBC_PRIORITY_SET(a,b,c,d,e,f,g,h,i) \
+             (((0xf & (a)) << 32) | ((0xf & (b)) << 28) | ((0xf & (c)) << 24) | \
+              ((0xf & (d)) << 20) | ((0xf & (e)) << 16) | ((0xf & (f)) << 12) | \
+              ((0xf & (g)) << 8) | ((0xf & (h)) << 4) | ((0xf & (i))))
+#define TX4939_GARBCP_PCIC   0x0000
+#define TX4939_GARBCP_PDMAC  0x0001
+#define TX4939_GARBCP_DMAC0  0x0010
+#define TX4939_GARBCP_DMAC1  0x0011
+#define TX4939_GARBCP_PCIC1  0x0100
+#define TX4939_GARBCP_ATA0   0x0101
+#define TX4939_GARBCP_ATA1   0x0110
+#define TX4939_GARBCP_CYP    0x0111
+#define TX4939_GARBCP_VPC    0x1000
+
+/* RAMP : Register Address Mapping Register */
+
+/* DSKWCTRL: DLL De-Skew Control Register */
+
+/* MCLKOSC Register */
+
+/* MVLKCTL Register */
+#define TX4939_MCLKCTL_BDE             0x00008000
+#define TX4939_MCLKCTL_CBE             0x00000080
+
+/* GPIO Mode Register */
+
+/* GPIO Date Register */
+
+/*
+ * IRC
+ */
+
+/* IRDEN : Interrupt Detection Enable Register */
+#define TX4939_IRDEN_IDE_MASK          0x00000001
+#define TX4939_IRDEN_IDE_STOP          0x00000000
+#define TX4939_IRDEN_IDE_START         0x00000001
+
+/* ISCIPB : Interrupt Source and Cause IP Binding Register */
+#define TX4939_ISCIPB_CMM_MASK         0x80000000
+#define TX4939_ISCIPB_CMM_ORIGINAL     0x00000000
+#define TX4939_ISCIPB_CMM_COMPATIBLE   0x80000000
+
+/* IRDM : Interrupt Detection Mode Register */
+#define TX4939_IRDM_LOW_LEVEL          0x0
+#define TX4939_IRDM_HIGH_LEVEL         0x1
+#define TX4939_IRDM_FALLING_EGDE       0x2
+#define TX4939_IRDM_RISING_EGDE        0x3
+
+/* IRMSK : Interrupt Mask Level Register */
+#define TX4939_IRMSK_IML_MASK          0x00000007
+#define TX4939_IRMSK_IML_LEVEL(x)      (TX4939_IRMSK_IML_MASK & (x))
+
+/* IRLVLxx : Interrupt Level Registers */
+#define TX4939_IRLVL_ALL_LEVEL_7       0x07070707
+
+/* IREDC : Interrupt Edge Detection Clear Register */
+
+/* IRPND : Interrupt Pending Register */
+
+/* IRCS : Interrupt Current Status Register */
+#define TX4939_IRCS_IF_MASK            0x00010000
+#define TX4939_IRCS_IF_INTERRUPT       0x00000000
+#define TX4939_IRCS_LVL_MASK           0x00000700
+#define TX4939_IRCS_LVL_LEVEL(x)       ((0x7 & (x)) << 8)
+#define TX4939_IRCS_CAUSE_MASK         0x0000003f
+
+/* IRFLAG: Interrupt Request Flag Register */
+
+/* IRPOL: Interrupt Request Polarity Control Register */
+
+/* IRRCNT: Interrupt Request Control Register */
+
+/* IRMASKINT: Interrupt Request Internal Interrupt Mask Register */
+
+/* IRMASKEXT: Interrupt Request External Interrupt Mask Register */
+
+/* IRDBR: Interrupt Debug Register */
+
+/*
+ * External Bus Interface
+ */
+
+#define TX4939_EBCCR_BA_MASK            _CONST64(0xffff000000000000)
+#define TX4939_EBCCR_ISA_MASK           _CONST64(0x0000000000400000)
+#define TX4939_EBCCR_ISA_ENABLE         _CONST64(0x0000000000400000)
+#define TX4939_EBCCR_ISA_DISABLE        _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_BSZ_MASK           _CONST64(0x0000000000100000)
+#define TX4939_EBCCR_BSZ_16BIT          _CONST64(0x0000000000100000)
+#define TX4939_EBCCR_BSZ_8BIT           _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_PM_MASK            _CONST64(0x00000000000c0000)
+#define TX4939_EBCCR_PM_NORMAL          _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_PM_4PAGE           _CONST64(0x0000000000040000)
+#define TX4939_EBCCR_PM_8PAGE           _CONST64(0x0000000000080000)
+#define TX4939_EBCCR_PM_16PAGE          _CONST64(0x00000000000c0000)
+#define TX4939_EBCCR_PWT_MASK           _CONST64(0x0000000000030000)
+#define TX4939_EBCCR_PWT_CYCLES(x)      ((0x3 & (x)) << 16)
+#define TX4939_EBCCR_WT_MASK            _CONST64(0x000000000000f000)
+#define TX4939_EBCCR_WT_EX_ACK_MODE     _CONST64(0x000000000003f000)
+#define TX4939_EBCCR_WT_CYCLES(x)       ((0x6 & (x)) << 12)
+#define TX4939_EBCCR_CS_MASK            _CONST64(0x0000000000000f00)
+#define TX4939_EBCCR_CS_SIZE_1MB        _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_CS_SIZE_2MB        _CONST64(0x0000000000000100)
+#define TX4939_EBCCR_CS_SIZE_4MB        _CONST64(0x0000000000000200)
+#define TX4939_EBCCR_CS_SIZE_8MB        _CONST64(0x0000000000000300)
+#define TX4939_EBCCR_CS_SIZE_16MB       _CONST64(0x0000000000000400)
+#define TX4939_EBCCR_CS_SIZE_32MB       _CONST64(0x0000000000000500)
+#define TX4939_EBCCR_CS_SIZE_64MB       _CONST64(0x0000000000000600)
+#define TX4939_EBCCR_CS_SIZE_128MB      _CONST64(0x0000000000000700)
+#define TX4939_EBCCR_CS_SIZE_256MB      _CONST64(0x0000000000000800)
+#define TX4939_EBCCR_CS_SIZE_512MB      _CONST64(0x0000000000000900)
+#define TX4939_EBCCR_BC_MASK            _CONST64(0x0000000000000080)
+#define TX4939_EBCCR_BC_BE              _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_BC_BWE             _CONST64(0x0000000000000080)
+#define TX4939_EBCCR_RDY_MASK           _CONST64(0x0000000000000040)
+#define TX4939_EBCCR_RDY_DISABLE        _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_RDY_ENABLE         _CONST64(0x0000000000000040)
+#define TX4939_EBCCR_SP_MASK            _CONST64(0x0000000000000030)
+#define TX4939_EBCCR_SP_1_4             _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_SP_1_3             _CONST64(0x0000000000000010)
+#define TX4939_EBCCR_SP_1_5             _CONST64(0x0000000000000020)
+#define TX4939_EBCCR_SP_1_6             _CONST64(0x0000000000000030)
+#define TX4939_EBCCR_ME_MASK            _CONST64(0x0000000000000008)
+#define TX4939_EBCCR_ME_DISABLE         _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_ME_ENABLE          _CONST64(0x0000000000000008)
+#define TX4939_EBCCR_SHWT_MASK          _CONST64(0x0000000000000007)
+#define TX4939_EBCCR_SHWT_DISABLE       _CONST64(0x0000000000000000)
+#define TX4939_EBCCR_SHWT_CYCLE(X)      ((0x7 & (x)) << 0)
+
+/*
+ * NAND Flash Memory Controller
+ */
+
+#define tx4939_read_nfmc(addr) (*(volatile unsigned int *)(addr))
+#define tx4939_write_nfmc(b,addr) (*(volatile unsigned int *)(addr)) = (b)
+
+/* NDFDTR : NAND Flash Memory Data Transfer Register */
+
+/* NDFMCR : NAND Flash Memory Mode Control Register */
+#define TX4939_NDFMCR_X16BUS            0x0400
+#define TX4939_NDFMCR_DMAREQ_MASK       0x0300
+#define TX4939_NDFMCR_DMAREQ_NODMA      0x0000
+#define TX4939_NDFMCR_DMAREQ_128BYTE    0x0100
+#define TX4939_NDFMCR_DMAREQ_256BYTE    0x0200
+#define TX4939_NDFMCR_DMAREQ_512BYTE    0x0300
+#define TX4939_NDFMCR_WE                0x0080
+#define TX4939_NDFMCR_ECC_ALL           0x0060
+#define TX4939_NDFMCR_ECC_RESET         0x0060
+#define TX4939_NDFMCR_ECC_DISABLE       0x0000
+#define TX4939_NDFMCR_ECC_ENABLE        0x0020
+#define TX4939_NDFMCR_ECC_READ          0x0040
+#define TX4939_NDFMCR_CE                0x0010
+#define TX4939_NDFMCR_CS                0x00c0
+#define TX4939_NDFMCR_BSPRT             0x0004
+#define TX4939_NDFMCR_ALE               0x0002
+#define TX4939_NDFMCR_ALE_LOW           0x0000
+#define TX4939_NDFMCR_ALE_HIGH          0x0002
+#define TX4939_NDFMCR_CLE               0x0001
+#define TX4939_NDFMCR_CLE_LOW           0x0000
+#define TX4939_NDFMCR_CLE_HIGH          0x0001
+
+/* NDFSR : NAND Flash Memory Status Register */
+#define TX4939_NDFSR_BUSY               0x80
+#define TX4939_NDFSR_DMARUN             0x40
+
+/* NDFISR : NAND Flash Memory Interrupt Status Register */
+#define TX4939_NDFISR_DMADONE           0x02
+#define TX4939_NDFISR_DMADONE_CLEAR     0x02
+#define TX4939_NDFISR_RDY               0x01
+#define TX4939_NDFISR_RDY_CLEAR         0x01
+
+/* NDFIMR : NAND Flash Memory Interrupt Mask Register */
+#define TX4939_NDFIMR_INTEN             0x80
+#define TX4939_NDFIMR_MDMA              0x02
+#define TX4939_NDFIMR_MRDY              0x01
+
+/* NDFSPR : NAND Flash Memory Strobe Pulse Width Register */
+#define TX4939_NDFSPR_HOLD_MASK         0xf0
+#define TX4939_NDFSPR_HOLD_SET(x)       ((0xf & (x)) << 4)
+#define TX4939_NDFSPR_HOLD_GET(x)       ((0xf0 & (x)) >> 4)
+#define TX4939_NDFSPR_SPW_MASK          0x0f
+#define TX4939_NDFSPR_SPW_SET(x)        ((0xf & (x)) << 0)
+#define TX4939_NDFSPR_SPW_GET(x)        ((0x0f & (x)) >> 0)
+
+/*
+ * RTC
+ */
+
+/* RTCCTL : RTC Control and Status Register */
+#define TX4939_RTCCTL_ALME              0x80
+#define TX4939_RTCCTL_ALMD              0x40
+#define TX4939_RTCCTL_BUSY              0x20
+#define TX4939_RTCCTL_CMD_CLEAR          0xf8
+#define TX4939_RTCCTL_CMD_GETTIME       0x01
+#define TX4939_RTCCTL_CMD_SETTIME       0x02
+#define TX4939_RTCCTL_CMD_GETALARM      0x03
+#define TX4939_RTCCTL_CMD_SETALARM      0x04
+
+/* RTCADR : RTC Address Register */
+
+/* RTCDAT : Data port to access the contents of RTC Register */
+
+/* RTCTBC : RTC Time Base Corrector Register */
+#define TX4939_RTCTBC_PM                0x80
+#define TX4939_RTCTBC_COMP_MASK         0x7f
+
+/*
+ * Video Port
+ */
+
+/* CSR : Control and Status Register */
+#define TX4939_VPCCSR_GBINT                _CONST64(0x0000000000010000)
+#define TX4939_VPCCSR_SWAPO                _CONST64(0x0000000000000020)
+#define TX4939_VPCCSR_SWAPI                _CONST64(0x0000000000000010)
+#define TX4939_VPCCSR_GINTE                _CONST64(0x0000000000000008)
+#define TX4939_VPCCSR_RSTD                 _CONST64(0x0000000000000004)
+#define TX4939_VPCCSR_RSTVPC               _CONST64(0x0000000000000002)
+
+/*
+ * Timer/Counter
+ */
+
+#define TX4939_NR_TMR                      6
+
+/* TMTCRn : Timer Control Register n */
+#define TX4939_TMTCR_TCE                   0x00000080
+#define TX4939_TMTCR_CCDE                  0x00000040
+#define TX4939_TMTCR_CRE                   0x00000020
+#define TX4939_TMTCR_CECS                  0x00000008
+#define TX4939_TMTCR_CCS                   0x00000004
+#define TX4939_TMTCR_TMODE_MASK            0x00000003
+#define TX4939_TMTCR_TMODE_WATCHDOG        0x00000002
+#define TX4939_TMTCR_TMODE_PULSE           0x00000001
+#define TX4939_TMTCR_TMODE_INTERVAL        0x00000000
+
+/* TMTISRn : Timer Interrupt Status Register n */
+#define TX4939_TMTISR_TWIS                 0x00000008
+#define TX4939_TMTISR_TPIBS                0x00000004
+#define TX4939_TMTISR_TPIAS                0x00000002
+#define TX4939_TMTISR_TIIS                 0x00000001
+
+/* TMCPRAn : Compare Register An */
+
+/* TMCPRBn : Compare Register Bn */
+
+/* TMITMRn : Interval Timer Mode Register n */
+#define TX4939_TMITMR_TIIE                 0x00008000
+#define TX4939_TMITMR_TZCE                 0x00000001
+
+/* TMCCDRn : Devide Register n */
+#define TX4939_TMCCDR_CCD_MASK             0x00000007
+#define TX4939_TMCCDR_CCD_DIV_2            0x00000000
+#define TX4939_TMCCDR_CCD_DIV_4            0x00000001
+#define TX4939_TMCCDR_CCD_DIV_8            0x00000002
+#define TX4939_TMCCDR_CCD_DIV_16           0x00000003
+#define TX4939_TMCCDR_CCD_DIV_32           0x00000004
+#define TX4939_TMCCDR_CCD_DIV_64           0x00000005
+#define TX4939_TMCCDR_CCD_DIV_128          0x00000006
+#define TX4939_TMCCDR_CCD_DIV_256          0x00000007
+
+/* TMPGMRn : Pulse Generator Mode Register n */
+#define TX4939_TMPGMR_TPIBE                0x00008000
+#define TX4939_TMPGMR_TPIAE                0x00004000
+#define TX4939_TMPGMR_FFI                  0x00000001
+
+/* TMWTMRn : Watchdog Timer Mode Register n */
+#define TX4939_TMWTMR_TWIE                 0x00008000
+#define TX4939_TMWTMR_WDIS                 0x00000080
+#define TX4939_TMWTMR_TWC                  0x00000001
+
+/* TMTRRn : Timer Read Regiser n */
+
+/*
+ * DMAC
+ */
+
+#define TX4939_NR_DMA                      2
+
+/* DMmMCR : DMA Master Control Register */
+#define TX4939_DMMCR_EIS(n)                (0x1 << (28 + ((n) & 0x3)))
+#define TX4939_DMMCR_DIS(n)                (0x1 << (24 + ((n) & 0x3)))
+#define TX4939_DMMCR_FIFVC_MASK            _CONST64(0x00000000001fc000)
+#define TX4939_DMMCR_FIFVC_GET(n)          (((n) & TX4939_DMMCR_FIFVC_MASK) >> 14)
+#define TX4939_DMMCR_FIFWP_MASK            _CONST64(0x0000000000003800)
+#define TX4939_DMMCR_FIFWP_GET(n)          (((n) & TX4939_DMMCR_FIFWP_MASK) >> 11)
+#define TX4939_DMMCR_FIFRP_MASK            _CONST64(0x0000000000000700)
+#define TX4939_DMMCR_FIFRP_GET(n)          (((n) & TX4939_DMMCR_FIFRP_MASK) >> 8)
+#define TX4939_DMMCR_RSFIF                 _CONST64(0x0000000000000080)
+#define TX4939_DMMCR_FIFUM(n)              (0x1 << (3 + ((n) & 0x3)))
+#define TX4939_DMMCR_RRPT                  _CONST64(0x0000000000000002)
+#define TX4939_DMMCR_MSTEN                 _CONST64(0x0000000000000001)
+
+/* DMmCCRn : DMA Channel Control Register */
+#define TX4939_DMCCR_IMMCHN                _CONST64(0x0000000020000000)
+#define TX4939_DMCCR_USEXFSZ               _CONST64(0x0000000010000000)
+#define TX4939_DMCCR_LE                    _CONST64(0x0000000008000000)
+#define TX4939_DMCCR_DBINH                 _CONST64(0x0000000004000000)
+#define TX4939_DMCCR_SBINH                 _CONST64(0x0000000002000000)
+#define TX4939_DMCCR_CHRST                 _CONST64(0x0000000001000000)
+#define TX4939_DMCCR_REVBYTE               _CONST64(0x0000000000800000)
+#define TX4939_DMCCR_ACKPOL                _CONST64(0x0000000000400000)
+#define TX4939_DMCCR_REQPL                 _CONST64(0x0000000000200000)
+#define TX4939_DMCCR_EGREQ                 _CONST64(0x0000000000100000)
+#define TX4939_DMCCR_CHDN                  _CONST64(0x0000000000080000)
+#define TX4939_DMCCR_DNCTL_MASK            _CONST64(0x0000000000060000)
+#define TX4939_DMCCR_EXTRQ                 _CONST64(0x0000000000010000)
+#define TX4939_DMCCR_STLTIME_MASK          _CONST64(0x000000000000e000)
+#define TX4939_DMCCR_STLTIME_960           _CONST64(0x0000000000002000)
+#define TX4939_DMCCR_STLTIME_4032          _CONST64(0x0000000000004000)
+#define TX4939_DMCCR_STLTIME_16320         _CONST64(0x0000000000006000)
+#define TX4939_DMCCR_STLTIME_65472         _CONST64(0x0000000000008000)
+#define TX4939_DMCCR_STLTIME_262080        _CONST64(0x000000000000a000)
+#define TX4939_DMCCR_STLTIME_1048512       _CONST64(0x000000000000c000)
+#define TX4939_DMCCR_STLTIME_4194240       _CONST64(0x000000000000e000)
+#define TX4939_DMCCR_INTRQD_MASK           _CONST64(0x000000000000e000)
+#define TX4939_DMCCR_INTRQD_16             _CONST64(0x0000000000002000)
+#define TX4939_DMCCR_INTRQD_32             _CONST64(0x0000000000004000)
+#define TX4939_DMCCR_INTRQD_64             _CONST64(0x0000000000006000)
+#define TX4939_DMCCR_INTRQD_128            _CONST64(0x0000000000008000)
+#define TX4939_DMCCR_INTRQD_256            _CONST64(0x000000000000a000)
+#define TX4939_DMCCR_INTRQD_512            _CONST64(0x000000000000c000)
+#define TX4939_DMCCR_INTRQD_1024           _CONST64(0x000000000000e000)
+#define TX4939_DMCCR_INTENE                _CONST64(0x0000000000001000)
+#define TX4939_DMCCR_INTENC                _CONST64(0x0000000000000800)
+#define TX4939_DMCCR_INTENT                _CONST64(0x0000000000000400)
+#define TX4939_DMCCR_CHNEN                 _CONST64(0x0000000000000200)
+#define TX4939_DMCCR_XFACT                 _CONST64(0x0000000000000100)
+#define TX4939_DMCCR_SMPCHN                _CONST64(0x0000000000000020)
+#define TX4939_DMCCR_XFSZ_MASK             _CONST64(0x000000000000001c)
+#define TX4939_DMCCR_XFSZ_1BYTE            _CONST64(0x0000000000000000)
+#define TX4939_DMCCR_XFSZ_2BYTE            _CONST64(0x0000000000000004)
+#define TX4939_DMCCR_XFSZ_4BYTE            _CONST64(0x0000000000000008)
+#define TX4939_DMCCR_XFSZ_8BYTE            _CONST64(0x000000000000000c)
+#define TX4939_DMCCR_XFSZ_4DWORD           _CONST64(0x0000000000000010)
+#define TX4939_DMCCR_XFSZ_8DWORD           _CONST64(0x0000000000000014)
+#define TX4939_DMCCR_XFSZ_16DWORD          _CONST64(0x0000000000000018)
+#define TX4939_DMCCR_XFSZ_32DWORD          _CONST64(0x000000000000001c)
+#define TX4939_DMCCR_MEMIO                 _CONST64(0x0000000000000002)
+#define TX4939_DMCCR_SNGAD                 _CONST64(0x0000000000000001)
+
+/* DMmCSRn : DMA Channel Status Register */
+#define TX4939_DMCSR_WAITC_MASK            _CONST64(0x00000000ffff0000)
+#define TX4939_DMCSR_WAITC_GET(n)          ((TX4939_DMCSR_WAITC_MASK & (n)) >> 16)
+#define TX4939_DMCSR_CHNEN                 _CONST64(0x0000000000000400)
+#define TX4939_DMCSR_STLXFER               _CONST64(0x0000000000000200)
+#define TX4939_DMCSR_XFACT                 _CONST64(0x0000000000000100)
+#define TX4939_DMCSR_ABCHC                 _CONST64(0x0000000000000080)
+#define TX4939_DMCSR_NCHNC                 _CONST64(0x0000000000000040)
+#define TX4939_DMCSR_NTRNFC                _CONST64(0x0000000000000020)
+#define TX4939_DMCSR_EXTDN                 _CONST64(0x0000000000000010)
+#define TX4939_DMCSR_CFERR                 _CONST64(0x0000000000000008)
+#define TX4939_DMCSR_CHERR                 _CONST64(0x0000000000000004)
+#define TX4939_DMCSR_DESERR                _CONST64(0x0000000000000002)
+#define TX4939_DMCSR_SORERR                _CONST64(0x0000000000000001)
+
+/* DMmSARn : DMA Source Address Regiser */
+
+/* DMmDARn : DMA Destination Address Register */
+
+/* DMmCHARn : DMA Chain Address Register */
+
+/* DMmSAIRn : DMA Source Address Increment Register */
+
+/* DMmDAIRn : DMA Destination Address Increment Register */
+
+/* DMmCNTRn : DMA Count Register */
+
+/* DM0MFDRn  : DMA Memory Fill Data Register */
+
+/*
+ * DDR
+ */
+
+/* Interrupt */
+#define TX4939_DDR01_INIT_CLEAR            0x0c00
+
+/* DRWINEN : DDR Mapping Window Control Register */
+#define TX4939_DRWINEN_DCA_MASK            _CONST64(0x00000000c0000000)
+#define TX4939_DRWINEN_EN(n)               (0x1 >> ((n) & 0x3))
+
+/* DRWINn : DDR Mapping Window Register */
+#define TX4939_DRWINLO_MASK                _CONST64(0xffff000000000000)
+#define TX4939_DRWINLO_GET(n)              (((n) & TX4939_DRWINLO_MASK) >> (48-20))
+#define TX4939_DRWINLO_SET(n)              (((n) << (48-20) & TX4939_DRWINLO_MASK))
+#define TX4939_DRWINUP_MASK                _CONST64(0x0000ffff00000000)
+#define TX4939_DRWINUP_GET(n)              (((n) & TX4939_DRWINUP_MASK) >> (32-20))
+#define TX4939_DRWINUP_SET(n)              (((n) << (32-20) & 0x000003ff))
+#define TX4939_DRWINOF_MASK                _CONST64(0x0000000003ff0000)
+#define TX4939_DRWINOF_GET(n)              (((n) & TX4939_DRWINOF_MASK) << (20-16))
+#define TX4939_DRWINOF_SET(n)              (((n) >> (20-16) & TX4939_DRWINOF_MASK))
+#define TX4939_DRWIN_CS(n)                 ((n) & 0x3)
+
+/*
+ * PCIC
+ */
+
+/* PCIID : ID Register */
+
+/* PCISTATUS : PCI Status/Command Regsiter */
+#define TX4939_PCISTATUS_ALL               0x0000f900
+#define TX4939_PCISTATUS_DPE               0x80000000
+#define TX4939_PCISTATUS_SSE               0x40000000
+#define TX4939_PCISTATUS_RMA               0x20000000
+#define TX4939_PCISTATUS_RTA               0x10000000
+#define TX4939_PCISTATUS_STA               0x08000000
+#define TX4939_PCISTATUS_DT_MASK           0x06000000
+#define TX4939_PCISTATUS_DT_FAST           0x00000000
+#define TX4939_PCISTATUS_DT_MEDIUM         0x02000000
+#define TX4939_PCISTATUS_DT_SLOW           0x04000000
+#define TX4939_PCISTATUS_MDPE              0x01000000
+#define TX4939_PCISTATUS_FBBCP             0x00800000
+#define TX4939_PCISTATUS_66MCP             0x00200000
+#define TX4939_PCISTATUS_CL                0x00100000
+#define TX4939_PCISTATUS_FBBEN             0x00000200
+#define TX4939_PCISTATUS_SEREN             0x00000100
+#define TX4939_PCISTATUS_STPC              0x00000080
+#define TX4939_PCISTATUS_PEREN             0x00000040
+#define TX4939_PCISTATUS_VPS               0x00000020
+#define TX4939_PCISTATUS_MWIEN             0x00000010
+#define TX4939_PCISTATUS_SC                0x00000008
+#define TX4939_PCISTATUS_BM                0x00000004
+#define TX4939_PCISTATUS_MEMSP             0x00000002
+#define TX4939_PCISTATUS_IOSP              0x00000001
+
+/* PCICCREV : Class Code / Revision ID Register */
+
+/* PCICFG1 : PCI Configuration 1 Register */
+#define TX4939_PCICFG1_BISTC               0x80000000
+#define TX4939_PCICFG1_MFUNS               0x00800000
+#define TX4939_PCICFG1_HT_MASK             0x007f0000
+#define TX4939_PCICFG1_HT_GET(x)           (((x) & TX4939_PCICFG1_HT_MASK) >> 16)
+#define TX4939_PCICFG1_HT_SET(x)           (((x) & 0x7f) << 16)
+#define TX4939_PCICFG1_LT_MASK             0x0000ff00
+#define TX4939_PCICFG1_LT_GET(x)           (((x) & TX4939_PCICFG1_LT_MASK) >> 8)
+#define TX4939_PCICFG1_LT_SET(x)           (((x) & 0xff) << 8)
+#define TX4939_PCICFG1_CLS_MASK            0x000000ff
+#define TX4939_PCICFG1_CLS_GET(x)          (((x) & TX4939_PCICFG1_CLS_MASK) >> 0)
+#define TX4939_PCICFG1_CLS_SET(x)          (((x) & 0xff) << 0)
+
+/* P2GMmPLBASE : P2G Memory Space (m) PCI Lower Base Address Register */
+#define TX4939_P2GMPLBASE_BA_MASK          0xfff00000
+#define TX4939_P2GMPLBASE_BA(x)            ((x) & TX4939_P2GMPLBASE_BA_MASK)
+#define TX4939_P2GMPLBASE_PF               0x00000008
+#define TX4939_P2GMPLBASE_TYPE_MASK        0x00000006
+#define TX4939_P2GMPLBASE_MSI              0x00000001
+
+/* P2GMmCFG : P2G Memory Space (m) Configuration Register */
+#define TX4939_P2GMCFG_MSS_MASK            0x0000fff0
+#define TX4939_P2GMCFG_MSS_MB(x)           ((0xe000 | (~((x << 4)-1))) & TX4939_P2GMCFG_MSS_MASK)
+#define TX4939_P2GMCFG_PFCFG               0x00000008
+
+/* P2GIOPBASE : P2G I/O Space PCI Base Address Register */
+#define TX4939_P2GIOPBASE_MASK             0xffffff00
+#define TX4939_P2GIOPBASE_BA(x)            ((x) & TX4939_P2GIOPBASE_MASK)
+#define TX4939_P2GIOPBASE_IOSI             0x00000001
+
+/* PCISID : Subsystem ID Register */
+#define TX4939_PCISID_SSID_MASK            0xffff0000
+#define TX4939_PCISID_SSID(x)              ((x) & TX4939_PCISID_SSID_MASK)
+#define TX4939_PCISID_SSVID_MASK           0x0000ffff
+#define TX4939_PCISID_SSVID(x)             ((x) & TX4939_PCISID_SSVID_MASK)
+
+/* PCICAPPTR : Capabilities Pointer Register */
+#define TX4939_PCICAPPTR_CAPPTR_MASK       0x000000ff
+#define TX4939_PCICAPPTR_CAPPTR(x)         ((x) & TX4939_PCICAPPTR_CAPPTR_MASK)
+
+/* PCICFG2 : PCI Configuration 2 Register */
+#define TX4939_PCICFG2_ML_MASK             0xff000000
+#define TX4939_PCICFG2_ML_GET(x)           (((x) & TX4939_PCICFG2_ML_MASK) >> 24)
+#define TX4939_PCICFG2_ML_SET(x)           (((x) & 0xff) << 24)
+#define TX4939_PCICFG2_MG_MASK             0x00ff0000
+#define TX4939_PCICFG2_MG_GET(x)           (((x) & TX4939_PCICFG2_MG_MASK) >> 16)
+#define TX4939_PCICFG2_MG_SET(x)           (((x) & 0xff) << 16)
+#define TX4939_PCICFG2_IP_MASK             0x0000ff00
+#define TX4939_PCICFG2_IP_INTA             0x00000100
+#define TX4939_PCICFG2_IP_INTB             0x00000200
+#define TX4939_PCICFG2_IP_INTC             0x00000300
+#define TX4939_PCICFG2_IP_INTD             0x00000400
+#define TX4939_PCICFG2_IL_MASK             0x000000ff
+#define TX4939_PCICFG2_IL_GET(x)           (((x) & TX4939_PCICFG2_IL_MASK) >> 0)
+#define TX4939_PCICFG2_IL_SET(x)           (((x) & 0xff) << 0)
+
+/* G2PTOCNT : G2P Timeout Count Register */
+#define TX4939_G2PTOCNT_RETRYTO_MASK       0x0000ff00
+#define TX4939_G2PTOCNT_RETRYTO_GET(x)     (((x) & TX4939_G2PTOCNT_RETRYTO_MASK) >> 8)
+#define TX4939_G2PTOCNT_RETRYTO_SET(x)     (((x) & 0xff) << 8)
+#define TX4939_G2PTOCNT_TRDYTO_MASK        0x0000ff00
+#define TX4939_G2PTOCNT_TRDYTO_GET(x)      (((x) & TX4939_G2PTOCNT_TRDYTO_MASK) >> 0)
+#define TX4939_G2PTOCNT_TRDYTO_SET(x)      (((x) & 0xff) << 0)
+
+/* G2PSTATUS : G2P Status Register */
+#define TX4939_G2PSTATUS_ALL               0x00000003
+#define TX4939_G2PSTATUS_IDTTOE            0x00000002
+#define TX4939_G2PSTATUS_IDRTOE            0x00000001
+
+/* G2PMASK : G2P Mask Register */
+#define TX4939_G2PMASK_ALL                 0x00000003
+#define TX4939_G2PMASK_IDTTOEIE            0x00000002
+#define TX4939_G2PMASK_IDRTOEIE            0x00000001
+
+/* PCISSTATUS : Satellite Mode PCI Status Register */
+#define TX4939_PCISSTATUS_PS_MASK          0x03000000
+#define TX4939_PCISSTATUS_PS_GET(x)        (((x) & TX4939_PCISSTATUS_PS_MASK) >> 24)
+#define TX4939_PCISSTATUS_PMEEN            0x00800000
+#define TX4939_PCISSTATUS_DPE              0x00008000
+#define TX4939_PCISSTATUS_SSE              0x00004000
+#define TX4939_PCISSTATUS_RMA              0x00002000
+#define TX4939_PCISSTATUS_RTA              0x00001000
+#define TX4939_PCISSTATUS_STA              0x00000800
+#define TX4939_PCISSTATUS_DT_MASK          0x00000600
+#define TX4939_PCISSTATUS_DT_GET(x)        (((x) & TX4939_PCISSTATUS_DT_MASK) >> 9)
+#define TX4939_PCISSTATUS_MDPE             0x00000100
+
+/* PCIMASK : PCI Status Interrupt Maks Register */
+#define TX4939_PCIMASK_ALL                0x0000f900
+#define TX4939_PCIMASK_DPEIE              0x00008000
+#define TX4939_PCIMASK_SSEIE              0x00004000
+#define TX4939_PCIMASK_RMAIE              0x00002000
+#define TX4939_PCIMASK_RTAIE              0x00001000
+#define TX4939_PCIMASK_STAIE              0x00000800
+#define TX4939_PCIMASK_MDPEIE             0x00000100
+
+/* P2GCFG : P2G Configuration Register */
+#define TX4939_P2GCFG_PME                 0x00400000
+#define TX4939_P2GCFG_TPRBL_MASK          0x00300000
+#define TX4939_P2GCFG_TPRBL_2DWORD        0x00000000
+#define TX4939_P2GCFG_TPRBL_4DWORD        0x00100000
+#define TX4939_P2GCFG_TPRBL_6DWORD        0x00200000
+#define TX4939_P2GCFG_TPRBL_8DWORD        0x00300000
+#define TX4939_P2GCFG_FTRD                0x00008000
+#define TX4939_P2GCFG_FTA                 0x00004000
+#define TX4939_P2GCFG_MEM0PD              0x00001000
+#define TX4939_P2GCFG_MEM1PD              0x00000800
+#define TX4939_P2GCFG_MEM2PD              0x00000400
+#define TX4939_P2GCFG_TOBFR               0x00000200
+#define TX4939_P2GCFG_TIBFR               0x00000100
+
+/* P2GSTATUS : P2G Status Register */
+#define TX4939_P2GSTATUS_PMSC             0x01000000
+#define TX4939_P2GSTATUS_PMEES            0x00800000
+#define TX4939_P2GSTATUS_PMECLR           0x00400000
+#define TX4939_P2GSTATUS_M66EN            0x00200000
+#define TX4939_P2GSTATUS_IOBFE            0x00100000
+#define TX4939_P2GSTATUS_IIBFE            0x00080000
+#define TX4939_P2GSTATUS_TOBFE            0x00040000
+#define TX4939_P2GSTATUS_TIBFE            0x00020000
+
+/* P2GMASK : P2G Interrupt Mask Register */
+#define TX4939_P2GMASK_PMSCIE             0x01000000
+#define TX4939_P2GMASK_PMEESIE            0x00800000
+#define TX4939_P2GMASK_PMECLRIE           0x00400000
+
+/* P2GCCMD : P2G Current Command Register */
+#define TX4939_P2GCCMD_TCCMD_MASK         0x0000000f
+
+/* PBAREQPORT : PCI Bus Arbiter Request Port Register */
+
+/* PBACFG : PCI Bus Arbiter Configuration Register */
+#define TX4939_PBACFG_FIXPA               0x00000008
+#define TX4939_PBACFG_RPBA                0x00000004
+#define TX4939_PBACFG_PBAEN               0x00000002
+#define TX4939_PBACFG_BMCEN               0x00000001
+
+/* PBASTATUS : PCI Bus Arbiter Status Register */
+#define TX4939_PBASTATUS_BM               0x00000001
+
+/* PBAMASK : PCI Bus Arbiter Interrupt Mask Register */
+#define TX4939_PBAMASK_BMIE               0x00000000
+
+/* PBABM : PCI Bus Arbiter Broken Master Register */
+
+/* PBACREQ : PCI Bus Arbiter Current Request Register */
+
+/* PBACGNT : PCI Bus Arbiter Current Grant Register */
+
+/* PBACSTATE : PCI Bus Arbiter Current State Register */
+
+/* G2PMnGBASE : G2P Memory Space (m) G-Bus Base Address Register */
+#define TX4939_G2PMGBASE_BSWAP            _CONST64(0x0000002000000000)
+#define TX4939_G2PMGBASE_EXFER            _CONST64(0x0000001000000000)
+#define TX4939_G2PMGBASE_BA_MASK          _CONST64(0x0000000fffffff00)
+#define TX4939_G2PMnGBASE_BA(x)           ((x) & TX4939_G2PMnGBASE_BA_MASK)
+
+/* G2PIOGBASE : G2P IO Space G-Bus Base Address Register */
+#define TX4939_G2PIOGBASE_BSWAP           _CONST64(0x0000002000000000)
+#define TX4939_G2PIOGBASE_EXFER           _CONST64(0x0000001000000000)
+#define TX4939_G2PIOGBASE_BA_MASK         _CONST64(0x0000000fffffff00)
+#define TX4939_G2PIOGBASE_BA(x)           ((x) & TX4939_G2PIOGBASE_BA_MASK)
+
+/* G2PMnMASK : G2P Memory Space (m) Address Mask Register */
+#define TX4939_G2PMMASK_AM_MASK           0xfffffff0
+#define TX4939_G2PMMASK_AM_SET(X)         (((x-1) << 24) & TX4939_G2PMMASK_AM_MASK)
+
+/* G2PIOMASK : G2P IO Space Address Mask Register */
+#define TX4939_G2PIOMASK_AM_MASK          0xfffffff0
+#define TX4939_G2PIOMASK_AM_SET(X)        (((x-1) << 24) & TX4939_G2PIOMASK_AM_MASK)
+
+/* G2PMPBASE : G2P Memory Space (m) PCI Base Address Register */
+#define TX4939_G2PMPBASE_BA_MASK          _CONST64(0x000000ffffffff00)
+
+/* G2PIOPBASE : G2P IO Space PCI Base Address Register */
+#define TX4939_G2PIOPBASE_BA_MASK         _CONST64(0x000000ffffffff00)
+
+/* PCICCFG : PCI Controller Configuration Register */
+#define TX4939_PCICCFG_GBWC_MASK          0x0fff0000
+#define TX4939_PCICCFG_GBWC_SET(x)        (((x) << 16) & TX4939_PCICCFG_GBWC_MASK)
+#define TX4939_PCICCFG_HRST               0x00000800
+#define TX4939_PCICCFG_SRST               0x00000400
+#define TX4939_PCICCFG_IRBE               0x00000200
+#define TX4939_PCICCFG_G2PM(ch)           (0x00000100>>(ch))
+#define TX4939_PCICCFG_G2PM0EN            0x00000100
+#define TX4939_PCICCFG_G2PM1EN            0x00000080
+#define TX4939_PCICCFG_G2PM2EN            0x00000040
+#define TX4939_PCICCFG_G2PIOEN            0x00000020
+#define TX4939_PCICCFG_TCAR               0x00000010
+#define TX4939_PCICCFG_ICAEN              0x00000008
+#define TX4939_PCICCFG_LCFG               0x00000004
+
+/* PCICSTATUS : PCI Controller Status Register */
+#define TX4939_PCICSTATUS_ALL             0x000007b8
+#define TX4939_PCICSTATUS_PME             0x00000400
+#define TX4939_PCICSTATUS_TLB             0x00000200
+#define TX4939_PCICSTATUS_NIB             0x00000100
+#define TX4939_PCICSTATUS_ZIB             0x00000080
+#define TX4939_PCICSTATUS_PERR            0x00000020
+#define TX4939_PCICSTATUS_SERR            0x00000010
+#define TX4939_PCICSTATUS_GBE             0x00000008
+#define TX4939_PCICSTATUS_IWB             0x00000002
+#define TX4939_PCICSTATUS_E2PDONE         0x00000001
+
+/* PCICMASK : PCI Controller Mask Register */
+#define TX4939_PCICMASK_ALLIE             0x000007b8
+#define TX4939_PCICMASK_PMEIE             0x00000400
+#define TX4939_PCICMASK_TLBIE             0x00000200
+#define TX4939_PCICMASK_NIBIE             0x00000100
+#define TX4939_PCICMASK_ZIBIE             0x00000080
+#define TX4939_PCICMASK_PERRIE            0x00000020
+#define TX4939_PCICMASK_SERRIE            0x00000010
+#define TX4939_PCICMASK_GBEIE             0x00000008
+
+/* P2GMGBASE : P2G Memory Space (m) G-Bus Base Address Register */
+#define TX4939_P2GMGBASE_P2GMEN           _CONST64(0x0000004000000000)
+#define TX4939_P2GMGBASE_BSWAP            _CONST64(0x0000002000000000)
+#define TX4939_P2GMGBASE_EXFER            _CONST64(0x0000001000000000)
+#define TX4939_P2GMGBASE_BA_MASK          _CONST64(0x0000000fe0000000)
+#define TX4939_P2GMGBASE_BA_SET(x)        (((x) << 20) & TX4939_P2GMGBASE_BA_MASK)
+
+/* P2GIOGBASE : P2G IO Space G-Bus Base Address Register */
+#define TX4939_P2GIOGBASE_P2GMEN          _CONST64(0x0000004000000000)
+#define TX4939_P2GIOGBASE_BSWAP           _CONST64(0x0000002000000000)
+#define TX4939_P2GIOGBASE_EXFER           _CONST64(0x0000001000000000)
+#define TX4939_P2GIOGBASE_BA_MASK         _CONST64(0x0000000fe0000000)
+#define TX4939_P2GIOGBASE_BA_SET(x)       (((x) << 20) & TX4939_P2GIOGBASE_BA_MASK)
+
+/* G2PCFGADRS : G2P Configuration Address Register */
+#define TX4939_G2PCFGADRS_BUSNUM_MASK     0x00ff0000
+#define TX4939_G2PCFGADRS_BUSNUM_GET(x)   (((x) & TX4939_G2PCFGADRS_BUSNUM_MASK) >> 16)
+#define TX4939_G2PCFGADRS_BUSNUM_SET(x)   (((x) << 16) & TX4939_G2PCFGADRS_BUSNUM_MASK)
+#define TX4939_G2PCFGADRS_DEVNUM_MASK     0x0000f800
+#define TX4939_G2PCFGADRS_DEVNUM_GET(x)   (((x) & TX4939_G2PCFGADRS_DEVNUM_MASK) >> 11)
+#define TX4939_G2PCFGADRS_DEVNUM_SET(x)   (((x) << 11) & TX4939_G2PCFGADRS_DEVNUM_MASK)
+#define TX4939_G2PCFGADRS_FNNUM_MASK      0x00000700
+#define TX4939_G2PCFGADRS_FNNUM_GET(x)    (((x) & TX4939_G2PCFGADRS_FNNUM_MASK) >> 8)
+#define TX4939_G2PCFGADRS_FNNUM_SET(x)    (((x) << 8) & TX4939_G2PCFGADRS_FNNUM_MASK)
+#define TX4939_G2PCFGADRS_REGNUM_MASK     0x000000fc
+#define TX4939_G2PCFGADRS_REGNUM_GET(x)   (((x) & TX4939_G2PCFGADRS_REGNUM_MASK) >> 2)
+#define TX4939_G2PCFGADRS_REGNUM_SET(x)   (((x) << 2) & TX4939_G2PCFGADRS_REGNUM_MASK)
+#define TX4939_G2PCFGADRS_TYPE_MASK       0x00000002
+#define TX4939_G2PCFGADRS_TYPE_GET(x)     (((x) & TX4939_G2PCFGADRS_TYPE_MASK) >> 0)
+#define TX4939_G2PCFGADRS_TYPE_SET(x)     (((x) << 0) & TX4939_G2PCFGADRS_TYPE_MASK)
+
+#define TX4939_PCIC_IDSEL_AD_TO_SLOT(ad)  ((ad) - 11)
+#define TX4939_PCIC_MAX_DEVNU	          TX4939_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/* G2PCFGDATA : G2P Configuration Data Register */
+
+/* G2PINTACK : G2P Interrupt Acknowledge Data Register */
+
+/* G2PSPC : G2P Special Cycle Data Register */
+
+/* PCICDATA0 : Configuration Data 0 Register */
+
+/* PCICDATA1 : Configuration Data 1 Register */
+
+/* PCICDATA2 : Configuration Data 2 Register */
+
+/* PCICDATA3 : Configuration Data 3 Register */
+
+/* PDMCA : PDMAC Chain Address Register */
+#define TX4939_PDMCA_MASK                 _CONST64(0x0000000ffffffff8)
+#define TX4939_PDMCA(x)                   ((x) & TX4939_PDMCA_PDMCA_MASK)
+
+/* PDMGA : PDMAC G-Bus Address Register */
+#define TX4939_PDMGA_MASK                 _CONST64(0x0000000ffffffffc)
+#define TX4939_PDMGA(x)                   ((x) & TX4939_PDMGA_MASK)
+
+/* PDMPA : PDMAC PCI Bus Address Register */
+#define TX4939_PDMPA_MASK                 _CONST64(0x0000000ffffffffc)
+#define TX4939_PDMPA(x)                   ((x) & TX4939_PDMPA_MASK)
+
+/* PDMCTR : PDMAC Count Register */
+#define TX4939_PDMCTR_MASK                _CONST64(0x0000000000fffffc)
+#define TX4939_PDMCTR(x)                  ((x) & TX4939_PDMCTR_MASK)
+
+/* PDMCFG : PDMAC Control Register */
+#define TX4939_PDMCFG_RSTFIFO             _CONST64(0x0000000000200000)
+#define TX4939_PDMCFG_EXFER               _CONST64(0x0000000000100000)
+#define TX4939_PDMCFG_REQDLY_MASK         _CONST64(0x0000000000003800)
+#define TX4939_PDMCFG_REQDLY_SET(x)       (((x) << 10) & TX4939_PDMCFG_REQDLY_MASK)
+#define TX4939_PDMCFG_REQDLY_GET(x)       (((x) & TX4939_PDMCFG_REQDLY_MASK) >> 10)
+#define TX4939_PDMCFG_ERRIE               _CONST64(0x0000000000000400)
+#define TX4939_PDMCFG_MCCMPIE             _CONST64(0x0000000000000200)
+#define TX4939_PDMCFG_NTCMPIE             _CONST64(0x0000000000000100)
+#define TX4939_PDMCFG_CHNEN               _CONST64(0x0000000000000080)
+#define TX4939_PDMCFG_XFRACT              _CONST64(0x0000000000000040)
+#define TX4939_PDMCFG_BSWAP               _CONST64(0x0000000000000010)
+#define TX4939_PDMCFG_XFRSIZE_1DWORD      _CONST64(0x0000000000000000)
+#define TX4939_PDMCFG_XFRSIZE_1QWORD      _CONST64(0x0000000000000004)
+#define TX4939_PDMCFG_XFRSIZE_4QWORD      _CONST64(0x0000000000000008)
+#define TX4939_PDMCFG_XFRDIRC             _CONST64(0x0000000000000002)
+#define TX4939_PDMCFG_CHRST               _CONST64(0x0000000000000001)
+
+/* PDMSTATUS : PDMAC Status Register */
+#define TX4939_PDMSTATUS_REQCNT_MASK      _CONST64(0x000000003f000000)
+#define TX4939_PDMSTATUS_REQCNT_GET(x)    (((x) & TX4939_PDMSTATUS_REQCNT_MASK) >> 24)
+#define TX4939_PDMSTATUS_FIFOCNT_MASK     _CONST64(0x0000000000f00000)
+#define TX4939_PDMSTATUS_FIFOCNT_GET(x)   (((x) & TX4939_PDMSTATUS_FIFOCNT_MASK) >> 20)
+#define TX4939_PDMSTATUS_FIFOWP_MASK      _CONST64(0x00000000000c0000)
+#define TX4939_PDMSTATUS_FIFOWP_GET(x)    (((x) & TX4939_PDMSTATUS_FIFOWP_MASK) >> 18)
+#define TX4939_PDMSTATUS_FIFORP_MASK      _CONST64(0x0000000000030000)
+#define TX4939_PDMSTATUS_FIFORP_GET(x)    (((x) & TX4939_PDMSTATUS_FIFORP_MASK) >> 16)
+#define TX4939_PDMSTATUS_ERRINT           _CONST64(0x0000000000000800)
+#define TX4939_PDMSTATUS_DONEINT          _CONST64(0x0000000000000400)
+#define TX4939_PDMSTATUS_CHNEN            _CONST64(0x0000000000000200)
+#define TX4939_PDMSTATUS_XFRACT           _CONST64(0x0000000000000100)
+#define TX4939_PDMSTATUS_ACCMP            _CONST64(0x0000000000000080)
+#define TX4939_PDMSTATUS_NCCMP            _CONST64(0x0000000000000040)
+#define TX4939_PDMSTATUS_NTCMP            _CONST64(0x0000000000000020)
+#define TX4939_PDMSTATUS_CFGERR           _CONST64(0x0000000000000008)
+#define TX4939_PDMSTATUS_PCIERR           _CONST64(0x0000000000000004)
+#define TX4939_PDMSTATUS_CHNERR           _CONST64(0x0000000000000002)
+#define TX4939_PDMSTATUS_DATAERR          _CONST64(0x0000000000000001)
+
+/*
+ * ATA
+ */
+
+#define TX4939_ATA_DATA_OFFSET            0x000
+#define TX4939_ATA_ERROR_OFFSET           0x001
+#define TX4939_ATA_SECTOR_OFFSET          0x002
+#define TX4939_ATA_LBA_LOW_OFFSET         0x003
+#define TX4939_ATA_LBA_MID_OFFSET         0x004
+#define TX4939_ATA_LBA_HIGH_OFFSET        0x005
+#define TX4939_ATA_DRIVE_OFFSET           0x006
+#define TX4939_ATA_STATUS_OFFSET          0x007
+
+#define TX4939_ATA_DEVICE_CONTROL_OFFSET  0x402
+#define TX4939_ATA_ALT_STATUS_OFFSET      0x402
+
+#define TX4939_ATA_DMA_BASE_OFFSET        0x800
+
+#define TX4939_ATA_SYSTEM_CONTROL1_OFFSET 0xc00
+#define TX4939_ATA_SYSTEM_CONTROL2_OFFSET 0xc02
+
+#define TX4939_ATA_SC_SOFT_RESET          0x8000
+#define TX4939_ATA_SC_FIFO_RESET          0x4000
+#define TX4939_ATA_SC_PDIAGN              0x2000
+#define TX4939_ATA_SC_DASPN               0x1000
+#define TX4939_ATA_SC_ATA_HARD_RESET      0x0800
+#define TX4939_ATA_SC_MODE_XFER_PIO_4     0x0440
+#define TX4939_ATA_SC_MODE_XFER_PIO_3     0x0330
+#define TX4939_ATA_SC_MODE_XFER_PIO_2     0x0220
+#define TX4939_ATA_SC_MODE_XFER_PIO_1     0x0110
+#define TX4939_ATA_SC_MODE_XFER_PIO_0     0x0000
+#define TX4939_ATA_SC_MODE_XFER_UDMA_5    0x00d0
+#define TX4939_ATA_SC_MODE_XFER_UDMA_4    0x00c0
+#define TX4939_ATA_SC_MODE_XFER_UDMA_3    0x00b0
+#define TX4939_ATA_SC_MODE_XFER_UDMA_2    0x00a0
+#define TX4939_ATA_SC_MODE_XFER_UDMA_1    0x0090
+#define TX4939_ATA_SC_MODE_XFER_UDMA_0    0x0080
+#define TX4939_ATA_SC_MODE_XFER_MDMA_2    0x0070
+#define TX4939_ATA_SC_MODE_XFER_MDMA_1    0x0060
+#define TX4939_ATA_SC_MODE_XFER_MDMA_0    0x0050
+#define TX4939_ATA_SC_MODE_MASK           0x07f0
+#define TX4939_ATA_SC_CMD_MODE_MASK       0x0700
+#define TX4939_ATA_SC_DATA_MODE_MASK      0x00f0
+#define TX4939_ATA_SC_BREAK_ENABLE        0x0008
+#define TX4939_ATA_SC_END_BREAK           0x0004
+#define TX4939_ATA_SC_AUTO_DMA_ENABLE     0x0002
+#define TX4939_ATA_SC_ACCESS_NOW          0x0001
+
+#define TX4939_ATA_DMA_STARTSTOP          0x0001
+
+#define TX4939_ATA_IC_MASK_ALL            0xff00
+#define TX4939_ATA_IC_ADDRESS_ERROR_INT   0x0080
+#define TX4939_ATA_IC_REACH_MALTIPLE_INT  0x0040
+#define TX4939_ATA_IC_DEV_TIMING_ERROR    0x0020
+#define TX4939_ATA_IC_DMA_DEV_TERMINATE   0x0010
+#define TX4939_ATA_IC_TIMERINT            0x0008
+#define TX4939_ATA_IC_BUS_ERROR           0x0004
+#define TX4939_ATA_IC_DATA_TRANSFER_END   0x0002
+#define TX4939_ATA_IC_HOSTINT             0x0001
+
+#define TX4939_ATA_PTC_PACKET_START       0x0001
+
+/*
+ * Ether
+ */
+
+#define TX4939_ETHER_IDSEL(ch)            (31 - (0x1 & (ch)))
+
+/*
+ * SIO
+ */
+
+#define TX4939_NR_SIO                     4
+
+/*
+ * SPI
+ */
+
+/*
+ * CIR
+ */
+
+/*
+ * I2C
+ */
+
+/*
+ * I2S
+ */
+
+/*
+ * ACLink
+ */
+
+/*
+ * SRAM
+ */
+
+/*
+ * Crypt
+ */
+
+#endif				/* __ASM_TX4939H */
Index: linux-2.6.10/include/linux/ide.h
===================================================================
--- linux-2.6.10.orig/include/linux/ide.h
+++ linux-2.6.10/include/linux/ide.h
@@ -223,6 +223,7 @@ typedef enum {	ide_unknown,	ide_generic,
 		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_etrax100,	ide_acorn,
+		ide_tx4939,
 		ide_forced
 } hwif_chipset_t;
 
Index: linux-2.6.10/include/linux/pci_ids.h
===================================================================
--- linux-2.6.10.orig/include/linux/pci_ids.h
+++ linux-2.6.10/include/linux/pci_ids.h
@@ -1453,6 +1453,8 @@
 #define PCI_VENDOR_ID_TOSHIBA_2		0x102f
 #define PCI_DEVICE_ID_TOSHIBA_TX3927	0x000a
 #define PCI_DEVICE_ID_TOSHIBA_TC35815CF	0x0030
+#define PCI_DEVICE_ID_TOSHIBA_TC35815_NWU      0x0031
+#define PCI_DEVICE_ID_TOSHIBA_TX4939_ETHER      0x0032
 #define PCI_DEVICE_ID_TOSHIBA_TX4927	0x0180
 #define PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC	0x0108
 
Index: linux-2.6.10/mvl_patches/pro-0227.c
===================================================================
--- /dev/null
+++ linux-2.6.10/mvl_patches/pro-0227.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(227);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

